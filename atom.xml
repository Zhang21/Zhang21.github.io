<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风继续吹</title>
  
  <subtitle>Yesterday, you said tomorrow!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhang21.github.io/"/>
  <updated>2019-02-03T03:08:18.000Z</updated>
  <id>https://zhang21.github.io/</id>
  
  <author>
    <name>Zhang21</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netdata</title>
    <link href="https://zhang21.github.io/2019/02/02/Netdata/"/>
    <id>https://zhang21.github.io/2019/02/02/Netdata/</id>
    <published>2019-02-02T08:09:49.000Z</published>
    <updated>2019-02-03T03:08:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>GitHub: <a href="https://github.com/netdata/netdata" target="_blank" rel="noopener">https://github.com/netdata/netdata</a></li><li>Netdata: <a href="https://my-netdata.io/" target="_blank" rel="noopener">https://my-netdata.io/</a></li><li>Docs: <a href="https://docs.netdata.cloud/" target="_blank" rel="noopener">https://docs.netdata.cloud/</a></li></ul><p>环境:</p><ul><li>EL7x86_64</li><li>Netdata v1.12</li></ul><p><br><br><br></p><a id="more"></a><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>Netdata</strong> 是可用于系统和应用程序的 分布式(distributed)、实时(real-time)、性能(performance)、健康监控(health monitoring) 的高度优化的监控代理开源程序，用于解决性能问题。</p><p>Netdata使用高度交互的Web仪表板，实时提供其运行的系统（包括Web服务器，数据库，应用程序）上发生的所有事情的无与伦比的见解(unparalleled insights)。<br>它可以自动运行，无需任何第三方组件，也可以集成到现有的监控工具链中(Prometheus, Graphite, OpenTSDB, Kafka, Grafana…)</p><p><br></p><h2 id="Why-Netdata"><a href="#Why-Netdata" class="headerlink" title="Why Netdata"></a>Why Netdata</h2><p>Netdata采用完全不同的监控方法。<br>Netdata 是一个位于你安装系统上的 monitoring agent。它是:</p><ul><li>a <strong>metrics collector</strong>: 收集系统和应用指标</li><li>a <strong>time-series database</strong>: 全部存储在内存中，在运行时不会触及磁盘</li><li>a <strong>metrics visualizer</strong>: 超快速、交互式、现代化，针对异常检测进行了优化</li><li>a <strong>alarms notification engine</strong>: 用于检测性能和可用性问题的高级监控程序</li></ul><p><br><br><br><br><br></p><h2 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h2><p>Netdata 是一个高效，高度模块化的度量管理引擎。其无锁设计使其成为指标并发操作的理想选择。</p><p><img src="/images/Netdata/it_works.png" alt=""></p><p><br><br><br><br><br></p><h2 id="资料图"><a href="#资料图" class="headerlink" title="资料图"></a>资料图</h2><p>详情: <a href="https://my-netdata.io/infographic.html" target="_blank" rel="noopener">https://my-netdata.io/infographic.html</a></p><p>Netdata 功能特色和体系架构的高级预览。</p><p><img src="/images/Netdata/infoGraphic.png" alt=""></p><p><br><br><br><br><br></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>一般来说:</p><ul><li><strong>1s granularity</strong>: 所有指标的最高分辨率</li><li><strong>Unlimited metrics</strong>: 收集所有可用的指标，越多越好</li><li><strong>1% CPU utilization of a single core</strong>: 超级快，优化好</li><li><strong>A few MB of RAM</strong>: 默认使用25MB</li><li><strong>Zero disk I/O</strong>: 运行时，不会加载和保存任何东西，日志除外</li><li><strong>Zero configuration</strong>: 自动检测所有内容</li><li><strong>Zero maintenance</strong>: 你只需运行它，它完成剩余的事情</li><li><strong>Zero dependencies</strong>: 零依赖，自身便包含了Web服务器</li><li><strong>Scales to infinity</strong>: 你可在servers, containers, VMs and IoTs 上安装它。默认情况下，度量标准不是集中式的，因此没有限制</li><li><strong>Several operating modes</strong>: 自主主机监控（默认），无头数据收集器，转发代理，存储和转发代理，中央多主机监控</li></ul><p><br></p><p>健康检查和告警:</p><ul><li><strong>Sophisticated alerting</strong>: 自带上百个告警，开箱即用。支持动态阈值，滞后，警报模板，多种基于角色的通知方法</li><li><strong>Notifications</strong>: 支持多种通知方式</li></ul><p><br></p><p>集成:</p><ul><li><strong>time-series dbs</strong>: 可将其指标以相同或更低的方案存档到 <code>graphite</code>, <code>opentsdb</code>, <code>prometheus</code>, <code>json</code>, <code>document DB</code></li></ul><p><br><br><br></p><h2 id="监控什么"><a href="#监控什么" class="headerlink" title="监控什么"></a>监控什么</h2><p>Netdata 数据收集是可扩展的，您可以监控任何可以获得指标的内容。它的 <code>Plugin API</code> 支持所有的编程语言。</p><ul><li>为了获得更好的性能，大多数与系统相关的插件都是用C语言编写 (cpu, mem, disk, fs, network…)</li><li>为了更快的开发和更轻松的贡献，大多数与应用程序相关的插件都是用python编写 (database, web server…)</li></ul><p><br></p><p><strong>APM (Application Performance Monitoring):</strong></p><ul><li><strong>statsd</strong>: Netdata是一个功能齐全的statsd server</li><li><strong>Go expvar</strong>: 使用expvar包收集由Go语言编写的应用程序公开的度量标准</li><li><strong>Spring Boot</strong>: 运行Java Spring Boot，这些应用程序使用Spring Boot库中包含的Spring Boot Actuator来公开其指标</li><li><strong>uWSGI</strong>: 从uWSGI应用程序收集性能指标</li></ul><p><br></p><p><strong>System Resources:</strong></p><ul><li><strong>CPU Utilization</strong>: 总核心和每核心 的CPU使用率</li><li><strong>Interrupts</strong>: 总核心和每核心 的CPU中断</li><li><strong>SoftIRQs</strong>: 总核心和每核心 的SoftIRQs</li><li><strong>SoftNet</strong>: 与网络活动相关的总核心和每核心 的SoftIRQ</li><li><strong>CPU Throttling</strong>: 收集每个CPU的CPU限制</li><li><strong>CPU Frequency</strong>: 收集当前的CPU频率</li><li><strong>CPU Idle</strong>: 收集每个处理器状态所花费的时间</li><li><strong>IdleJitter</strong>: 测量CPU延迟</li><li><strong>Entropy</strong>: 随机数池，在密码学中使用</li><li><strong>Interprocess Communication(IPC)</strong></li></ul><p><br></p><p><strong>Memory:</strong></p><ul><li><strong>ram</strong>: 收集有关RAM使用情况</li><li><strong>swap</strong>: 收集有关SWAP使用情况</li><li><strong>available memory</strong>: 收集可用于用户空间进程的RAM量</li><li><strong>committed memory </strong>: 收集提交给用户空间进程的RAM量</li><li><strong>Page Faults</strong>: 收集系统页面错误</li><li><strong>writeback memory</strong>: 收集系统脏内存和回写活动</li><li><strong>huge pages</strong>: 收集用于大页面的RAM量</li><li><strong>KSM</strong>: 收集有关内核相同合并的信息</li><li><strong>Numa</strong>: 在支持它的系统上收集Numa信息</li><li><strong>slab</strong>: 收集有关Linux内核内存使用情况</li></ul><p><br></p><p><strong>Disks:</strong></p><ul><li><strong>block devices</strong>: 每个磁盘：I/O, 操作, 积压, 利用率, 空间…</li><li><strong>BCACHE</strong>: SSD缓存设备的详细性能</li><li><strong>DiskSpace</strong>: 监视磁盘空间使用情况</li><li><strong>mdstat</strong>: 软件RAID</li><li><strong>hddtemp</strong>: 磁盘温度</li><li><strong>smartd</strong>: 磁盘  S.M.A.R.T 值</li><li><strong>device mapper</strong>: 命名磁盘</li><li><strong>Veritas Volume Manager</strong>: 命名磁盘</li><li><strong>egacli</strong>: 适配器，物理驱动器和电池统计信息</li><li><strong>adaptec_raid</strong>: 逻辑和物理设备健康指标</li></ul><p><br></p><p><strong>Filesystems:</strong></p><ul><li><strong>BTRFS</strong>: 详细的磁盘空间分配和使用</li><li><strong>Ceph</strong>: OSD使用，池使用，对象数…</li><li><strong>NFS file servers and clients</strong>: NFS I/O, cache, read ahead, RPC调用</li><li><strong>Samba </strong>: SAMBA文件共享的性能指标</li><li><strong>ZFS</strong>: 详细的性能和资源使用情况</li></ul><p><br></p><p><strong>Networking:</strong></p><ul><li><strong>Network Stack</strong>: 关于网络堆栈(IPv4和IPv6的所有协议)和所有网络接口(每个接口: 带宽，数据包，错误，丢弃)的一切</li><li><strong>Netfilter</strong>: 关于Netfilter连接跟踪器的一切</li><li><strong>SynProxy</strong>: 收集有关linux SYNPROXY(DDoS)的性能数据</li><li><strong>NFacct</strong>: 从iptables收集统计的数据</li><li><strong>Network QoS</strong>: 实时显示网络tc类的工具</li><li><strong>FPing</strong>: 测量任意数量的主机之间的延迟和数据包丢失</li><li><strong>ISC dhcpd</strong>: 池利用…</li><li><strong>AP</strong>: 收集Linux访问点性能数据(<code>hostapd</code>)</li><li><strong>SNMP</strong>: 监视SNMP设备</li><li><strong>port_check</strong>: 检查TCP端口的可用性和响应时间</li></ul><p><br></p><p><strong>Virtual Private Networks:</strong></p><ul><li><strong>OpenVPN</strong>: 收集每个隧道的状态</li><li><strong>LibreSwan</strong>: 收集每个IPSEC隧道的指标</li><li><strong>Tor</strong>: 收集Tor流量统计信息</li></ul><p><br></p><p><strong>Processes:</strong></p><ul><li><strong>System Processes</strong>: running, blocked, forks, active</li><li><strong>Applications</strong>: 分析每个进程组的资源情况</li><li><strong>systemd</strong>: 使用CGROUPS监视systemd服务</li></ul><p><br></p><p><strong>Users:</strong></p><ul><li><strong>Users and User Groups resource usage</strong>: 总结每个用户和用户组资源使用情况</li><li><strong>logind</strong>: 收集会话，用户和连接</li></ul><p><br></p><p><strong>Containers and VMs:</strong></p><ul><li><strong>Containers</strong>: 使用CGROUPS收集各种容器的资源使用情况</li><li><strong>libvirt VMs</strong>: 使用CGROUPS收集各种VM的资源使用情况</li><li><strong>dockerd</strong>: 收集docker健康指标</li></ul><p><br></p><p><strong>Web Servers:</strong></p><ul><li><strong>Apache and lighttpd</strong>: <code>mod-status</code>和日志统计信息</li><li><strong>IPFS</strong>: 带宽，对等连接</li><li><strong>LiteSpeed</strong>: 读取litespeed rtreport文件以收集指标</li><li><strong>Nginx</strong>: <code>stub-status</code></li><li><strong>Nginx+</strong>: 连接到多个nginx_plus服务器以收集实时性能指标</li><li><strong>PHP-FPM</strong>: 多个实例，每个实例报告连接、请求、性能…</li><li><strong>Tomcat</strong>: 访问、线程、空闲内存、卷…</li><li><strong>web server <code>access.log</code> files</strong>: 实时提取，Web服务器和代理性能指标，并应用多个运行状况检查…</li><li><strong>HTTP check</strong>: 检查一个或多个Web服务器以获取HTTP状态代码和返回的内容</li></ul><p><br></p><p><strong>Proxies, Balancers, Accelerators:</strong></p><ul><li><strong>HAproxy</strong>: 带宽，会话，后端…</li><li><strong>Squid</strong>: 每个服务器显示，客户端带宽和请求、服务器带宽和请求</li><li><strong>Traefik</strong>: 连接到多个traefik实例以收集API指标</li><li><strong>Varnish</strong>: 线程，会话，命中，对象，后端…</li><li><strong>IPVS</strong>: 从Linux IPVS负载均衡器收集指标</li></ul><p><br></p><p><strong>Database Servers:</strong></p><ul><li><strong>CouchDB</strong>: I/O，请求方法，状态代码，任务，副本，每个数据库…</li><li><strong>MemCached</strong>: 带宽，连接，项目…</li><li><strong>MongoDB</strong>: 操作，客户端，事务，游标，连接，断言，锁…</li><li><strong>MySQL and mariadb</strong>: 带宽，查询率，锁，问题，tmp操作，连接，binlog指标，线程，innodb指标…</li><li><strong>PostgreSQL</strong>: 连接，元组读取/写入/返回，事务，锁定，后端进程，索引，表，预写，后台编写器…</li><li><strong>Proxy SQL</strong>: 收集后端和前端性能指标</li><li><strong>Redis</strong>: 操作，命中率，内存，键，客户端，从库</li><li><strong>RethinkDB</strong>: 连接到多个rethinkdb服务器以收集实时指标</li></ul><p><br></p><p><strong>Message Brokers:</strong></p><ul><li><strong>beanstalkd</strong>: 全局/每个 tube 监控</li><li><strong>RabbitMQ</strong>: 性能和健康指标</li></ul><p><br></p><p><strong>Search and Indexing:</strong></p><ul><li><strong>ElasticSearch</strong>: 搜索和索引的性能、延迟、计时、集群统计、线程统计…</li></ul><p><br></p><p><strong>DNS Servers:</strong></p><ul><li><strong>bind_rndc</strong>: 解析 <code>named.stats</code> 转储文件以收集实时性能指标</li><li><strong>dnsdist</strong>: 性能和健康指标</li><li><strong>ISC Bind (named)</strong>: 客户端，请求，查询，更新，失败和每个视图指标</li><li><strong>NSD</strong>: 查询，区域，协议，查询类型，传输…</li><li><strong>PowerDNS</strong>: 查询，回答，缓存，延迟…</li><li><strong>unbound</strong>: 性能和资源使用指标</li><li><strong>dns_query_time</strong>: DNS查询时间统计信息</li></ul><p><br></p><p><strong>Time Servers:</strong></p><ul><li><strong>chrony</strong>: 频率，最后偏移，RMS偏移，残余频率，根延迟，根分散，偏斜，系统时间</li><li><strong>ntpd</strong>: 收集统计信息</li></ul><p><br></p><p><strong>Mail Servers:</strong></p><ul><li><strong>Dovecot</strong>: POP3/IMAP 服务器</li><li><strong>Exim</strong>: 消息队列(电子邮件排队)</li><li><strong>Postfix</strong>: 消息队列(条目，大小)</li></ul><p><br></p><p><strong>Hardware Sensors:</strong></p><ul><li><strong>IPMI</strong>: 企业硬件传感器和事件</li><li><strong>lm-sensors</strong>: 温度，电压，风扇，功率，湿度…</li><li><strong>Nvidia</strong>: 收集Nvidia GPU的信息</li><li><strong>RPi</strong>: Raspberry Pi温度传感器</li><li><strong>w1sensor</strong>: 从连接的1-Wire传感器收集数据</li></ul><p><br></p><p><strong>UPSes:</strong></p><ul><li><strong>apcupsd</strong>: 负载，充电，电池电压，温度，效用指标，输出指标</li><li><strong>NUT</strong>: 负载，充电，电池电压，温度，效用指标，输出指标</li><li><strong>Linux Power Supply</strong>: 收集Linux上电源驱动程序报告的指标</li></ul><p><br></p><p><strong>Social Sharing Servers:</strong></p><ul><li><strong>RetroShare</strong>: 连接到多个retroshare服务器以收集实时性能指标</li></ul><p><br></p><p><strong>Security:</strong></p><ul><li><strong>Fail2Ban</strong>: 监视fail2ban日志文件以检查所有活动jail的所有禁令</li></ul><p><br></p><p><strong>Authentication, Authorization, Accounting (AAA, RADIUS, LDAP) Servers:</strong></p><ul><li><strong>FreeRadius</strong>: 使用radclient命令提供freeradius统计信息（身份验证，账户统计，代理身份验证，代理统计）</li></ul><p><br></p><p><strong>Telephony Servers:</strong></p><ul><li><strong>opensips</strong>: 连接到opensips服务器（仅限localhost）以收集实时性能指标</li></ul><p><br></p><p><strong>Household Appliances:</strong></p><ul><li><strong>SMA webbox</strong>: 连接到多个远程SMA网箱，以收集光伏（太阳能）发电的实时性能指标</li><li><strong>Fronius</strong>: 连接到多个远程Fronius Symo服务器，以收集光伏（太阳能）发电的实时性能指标</li><li><strong>StiebelEltron</strong>: 使用他们的互联网服务网关（ISG网站）从Stiebel Eltron加热系统收集温度和其他指标</li></ul><p><br></p><p><strong>Game Servers:</strong></p><ul><li><strong>SpigotMC</strong>: 使用Minecraft远程控制台监控Spigot Minecraft服务器每秒的滴答数和在线玩家数量</li></ul><p><br></p><p><strong>Distributed Computing:</strong></p><ul><li><strong>BOINC</strong>: 使用远程GUI RPC接口监视本地和远程BOINC客户端软件的任务状态。还为少数错误情况提供警报</li></ul><p><br></p><p><strong>Media Streaming Servers:</strong></p><ul><li><strong>IceCast</strong>: 收集活动源的侦听器数量</li></ul><p><br></p><p><strong>Monitoring Systems:</strong></p><ul><li><strong>Monit</strong>: 收集有关监控目标（文件系统，应用程序，网络）的指标</li></ul><p><br><br><br><br><br></p><h2 id="安全设计"><a href="#安全设计" class="headerlink" title="安全设计"></a>安全设计</h2><p><br><br><br><br><br></p><h2 id="匿名统计"><a href="#匿名统计" class="headerlink" title="匿名统计"></a>匿名统计</h2><p><br><br><br></p><hr><p><br><br><br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub: &lt;a href=&quot;https://github.com/netdata/netdata&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/netdata/netdata&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Netdata: &lt;a href=&quot;https://my-netdata.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://my-netdata.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docs: &lt;a href=&quot;https://docs.netdata.cloud/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.netdata.cloud/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EL7x86_64&lt;/li&gt;
&lt;li&gt;Netdata v1.12&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Monitoring" scheme="https://zhang21.github.io/tags/Monitoring/"/>
    
      <category term="Performance" scheme="https://zhang21.github.io/tags/Performance/"/>
    
  </entry>
  
  <entry>
    <title>OpenLDAP</title>
    <link href="https://zhang21.github.io/2019/01/18/OpenLDAP/"/>
    <id>https://zhang21.github.io/2019/01/18/OpenLDAP/</id>
    <published>2019-01-17T17:18:29.000Z</published>
    <updated>2019-01-18T08:40:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>LDAP维基百科: <a href="https://zh.wikipedia.org/wiki/LDAP" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/LDAP</a></li><li>OpenLDAP维基百科: <a href="https://zh.wikipedia.org/wiki/OpenLDAP" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/OpenLDAP</a></li><li><code>x.500</code>维基百科: <a href="https://zh.wikipedia.org/wiki/X.500" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/X.500</a></li><li>OpenLDAP文档: <a href="http://www.openldap.org/doc/" target="_blank" rel="noopener">http://www.openldap.org/doc/</a></li></ul><p>环境:</p><ul><li>RHEL7.x86_64</li><li>LDAP v2.4.44</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><br></p><h2 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h2><p><strong>LDAP</strong>(轻型目录访问协议, Lightweight Directory Access Protocol）是一个开放的、中立的、工业标准的应用协议，通过IP协议提供访问控制和维护分布式信息的目录信息。<br>LDAP基于<code>X.500</code>标准的子集。因为这个关系，LDAP有时被称为<code>X.500-lite</code>。<br>LDAP在TCP/IP之上定义了一个相对简单的升级和搜索目录的协议。</p><p>LDAP目录与普通数据库的主要不同之处在于数据的组织方式，它是一种有层次的、树形结构。所有条目的属性的定义是对象类<code>object class</code>的组成部分，并组成在一起构成<code>schema</code>；那些在组织内代表个人的<code>schema</code>被命名为<code>white pages schema</code>。数据库内的每个条目都与若干对象类联系，而这些对象类决定了一个属性是否为可选和它保存哪些类型的信息。</p><p>LDAP目录的<strong>条目</strong>（entry）由<strong>属性</strong>（attribute）的一个聚集组成，并由一个唯一性的名字引用，即<strong>专有名称</strong>（distinguished name，DN）。</p><ul><li><strong>DN</strong>: Distinguished Name</li><li><strong>CN</strong>: Common Name</li><li><strong>OU</strong>: Domain Component</li></ul><p><br></p><p>LDAP组织数据方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        dc=org</span><br><span class="line"></span><br><span class="line">     |dc=wikipedia</span><br><span class="line">      /          \</span><br><span class="line">ou=people     ou=groups</span><br></pre></td></tr></table></figure><p><img src="/images/OpenLDAP/LDAP_Structure.png" alt=""></p><p><br></p><p>LDAP主要的应用场景是查询多而修改极少，那就充分发挥LDAP的优势了。因为没有事务处理，那数据库的速度可是比不上。 还有LDAP能存储海量的数据，还可以轻松地在各个系统之间复制，可用性超高。</p><p>目录是一个为查询、浏览和搜索而优化的专业分布式数据库，它呈树状结构组织数据，就好象Linux/Unix系统中的文件目录一样。目录数据库和关系数据库不同，它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。所以目录天生是用来查询的，就好象它的名字一样。</p><p><br><br><br><br><br></p><h2 id="OpenLDAP"><a href="#OpenLDAP" class="headerlink" title="OpenLDAP"></a>OpenLDAP</h2><p><strong>OpenLDAP</strong>是轻型目录访问协议（Lightweight Directory Access Protocol，LDAP）的<strong>自由和开源</strong>的实现，在其OpenLDAP许可证下发行，并已经被包含在众多流行的Linux发行版中。</p><p>OpenLDAP主要包括下述4个部分：</p><ul><li><code>slapd</code>: 独立LDAP守护服务</li><li><code>slurpd</code>: 独立的LDAP更新复制守护服务</li><li>实现LDAP协议的库</li><li>工具软件和示例客户端</li></ul><p><br><br><br><br><br></p><h2 id="Why-OpenLDAP"><a href="#Why-OpenLDAP" class="headerlink" title="Why OpenLDAP"></a>Why OpenLDAP</h2><p>账号是登录系统的唯一入口。要登录系统，首先系统要存在登录所使用的账号（/etc/passwd）及密码信息（/etc/shadow），然后经过系统查找顺序（/etc/nsswith.conf）及认证模块（/etc/pam.d/*）验证，得到授权后方可登录系统。如果多个用户登录系统，就需要在每个系统上创建用户名和密码；否则，就无法登录系统。</p><p>对于账号管理人员而言，维护10 台、100 台机器的账号，或许勉强可以维护、管理。如果机器数量达到1000 以上时，对于账号的创建、回收、权限的分配、密码策略、账号安全审计等一系列操作，账号管理人员就心有余而力不足了。此时OpenLDAP 账号集中管理软件就应用而生，它可以实现账号集中维护、管理，只需要将被管理的机器加入到服务器端即可，此后所有与账号相关的策略均在服务端实现，从而解决了运维案例所产生的众多管理问题。</p><p>关于账号的添加、删除、修改、权限的赋予等一系列操作只需要在服务端操作即可，无须在客户端机器进行单独操作。客户端账号及密码均通过OpenLDAP 服务器进行验证，从而实现账号集中认证管理，此时账号管理员只须维护OpenLDAP 服务器条目即可。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="OpenLDAP目录服务"><a href="#OpenLDAP目录服务" class="headerlink" title="OpenLDAP目录服务"></a>OpenLDAP目录服务</h1><p>Introduction to OpenLDAP Directory Services</p><p>本节介绍如何构建，配置和操作OpenLDAP软件以提供目录服务。这包括有关如何配置和运行standalone LDAP daemon——<code>slapd</code>的详细信息。它适用于系统管理员。本节提供目录服务的基本介绍，特别是<strong>slapd</strong>提供的目录服务。<br>本简介提供足够的信息，以便您可以开始学习<strong>LDAP</strong>，<strong>X.500</strong>和<strong>目录服务</strong>。</p><p><br></p><h2 id="目录服务是什么"><a href="#目录服务是什么" class="headerlink" title="目录服务是什么"></a>目录服务是什么</h2><p>目录是专门用于<strong>搜索</strong>(search)和<strong>浏览</strong>(browse)的专用数据库，另外还支持基本<strong>查找</strong>(lookup)和<strong>更新</strong>(update)功能。</p><p>目录往往包含描述性的，基于属性的信息，并支持复杂的过滤功能。目录通常不支持在为处理大量复杂更新而设计的数据库管理系统中发现的复杂事务或回滚方案。如果允许，目录更新通常是简单的全有或全无更改。目录通常用于快速响应高容量查找或搜索操作。他们可能具有广泛复制信息的能力，以提高可用性和可靠性，同时缩短响应时间。复制目录信息时，只要及时解决不一致问题，副本之间的临时不一致就可以了。</p><p>有许多不同的方法来提供目录服务。不同的方法允许将不同类型的信息存储在目录中，对如何引用，查询和更新信息。一些目录服务是本地的，向受限制的上下文提供服务；其它服务是全球性的，为更广泛的环境提供服务。全局服务通常是分布式的，这意味着它们包含的数据分布在许多机器上，所有机器都协作提供目录服务。通常，全局服务定义统一命名空间(namespace)，无论您在何处与数据本身相关，都可以提供相同的数据视图。</p><p><br><br><br><br><br></p><h2 id="LDAP是什么"><a href="#LDAP是什么" class="headerlink" title="LDAP是什么"></a>LDAP是什么</h2><p>LDAP(Lightweight Directory Access Protocol, 轻型目录访问协议)，顾名思义，它是一种用于访问目录服务的轻量级协议，特别是基于<code>X.500</code>的目录服务。LDAP通过TCP / IP或其他面向连接的传输服务运行。</p><p>哪些种类的信息可以存储在目录中？DAP信息模型基于<strong>条目</strong>(entry)。条目是具有全局唯一<strong>可分辨名称</strong>（DN）的<strong>属性</strong>(attributes)集合。DN用于明确指代Entry，每个条目的属性都有一个<strong>类型</strong>(type)和一个或多个<strong>值</strong>(value)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#这些类型通常是助记符字符串</span><br><span class="line">cn</span><br><span class="line">mail</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#值的语法取决于属性类型</span><br><span class="line">cn: ldap-test</span><br><span class="line">mail: example@test.com</span><br></pre></td></tr></table></figure><p><br></p><p>信息是如何安排的？在LDAP中，目录条目以分层树状结构(tree-like structure)排列。<br>传统上，这种结构反映了地理/组织边界。表示国家/地区的条目显示在树的顶部。下面是代表各州和国家组织的条目。再下面可能是表示组织单位，人员，打印机，文档或您可以想到的任何其他内容的条目。</p><p>传统命名:</p><p><img src="/images/OpenLDAP/intro_tree.png" alt=""></p><p><br></p><p>还可以基于因特网域名来安排树。这种命名方法正变得越来越流行，因为它允许使用DNS定位目录服务。</p><p>基于域名命名:</p><p><img src="/images/OpenLDAP/intro_dctree.png" alt=""></p><p><br></p><p>此外，LDAP允许您通过使用名为<strong>对象类</strong>(objectClass)的特殊属性来控制条目中所需和允许的属性。它的值确定条目必须遵守的模式规则。</p><p><br></p><p>如何引用信息？条目由其可分辨名称(DN)引用，该名称通过获取条目本身的名称来构造(称为Relative Distinguished Name, RDN)，并连接其祖先条目的名称。</p><p><br></p><p>如何保护信息免受未经授权的访问？某些目录服务不提供保护，允许任何人查看信息。LDAP为客户端提供了一种机制，用于对目录服务器进行身份验证或证明其身份。LDAP还支持数据安全性（完整性和机密性）服务。</p><p><br><br><br><br><br></p><h2 id="什么时候应该使用LDAP"><a href="#什么时候应该使用LDAP" class="headerlink" title="什么时候应该使用LDAP"></a>什么时候应该使用LDAP</h2><p>通常，当您需要通过基于标准的方法集中管理、存储、访问数据时，应使用目录服务器。<br>总是有新的方法来使用目录并应用LDAP原则来解决某些问题，因此这个问题没有简单的答案。</p><p>一些常见的栗子：</p><ul><li>机器认证: Machine Authentication</li><li>用户认证: User Authentication</li><li>用户/系统组: User/System Groups</li><li>地址簿: Address book</li><li>组织代表: Organization Representation</li><li>资产追踪: Asset Tracking</li><li>电话信息存储: Telephony Information Store</li><li>用户资源管理: User resource management</li><li>电子邮件查找: E-mail address lookups</li><li>应用配置存储: Application Configuration store</li><li>PBX Configuration store</li><li>…</li></ul><p><br><br><br><br><br></p><h2 id="LDAP如何工作"><a href="#LDAP如何工作" class="headerlink" title="LDAP如何工作"></a>LDAP如何工作</h2><p>LDAP使用C-S模式。一个或多个LDAP服务器包含组成目录信息树（DIT，directory information tree）的数据。客户端连接到服务器并发出请求。服务端响应客户端的请求。无论客户端连接到哪个LDAP服务器，它都会看到相同的目录视图，这是全局目录服务的一个重要特性。</p><p><br><br><br><br><br></p><h2 id="关于x-500"><a href="#关于x-500" class="headerlink" title="关于x.500"></a>关于<code>x.500</code></h2><p><code>X.500</code>是计算机目录服务的标准系列。<code>X.500</code>协议包括:</p><ul><li>DAP (Directory Access Protocol)</li><li>DSP (Directory System Protocol)</li><li>DISP (Directory Information Shadowing Protocol)</li><li>DOP (Directory Operational Bindings Management Protocol)</li><li>LDAP (Lightweight Directory Access Protocol)</li></ul><p><br></p><p>从技术上讲，LDAP是<code>X.500</code>目录服务的目录访问协议。DAP是一种重量级协议，可在完整的OSI协议栈上运行，并且需要大量的计算资源。LDAP旨在通过<code>TCP/IP</code>进行操作，并以更低的成本提供DAP的大部分功能。</p><p>虽然LDAP仍然用于通过网关访问X.500目录服务，但现在更常见的是在X.500服务器中直接实现LDAP。</p><p>可以将 standalone LDAP daemon(slapd) 视为轻量级X.500目录服务器。也就是说，它没有实现X.500的DAP，也不支持完整的X.500模型。</p><p><br><br><br><br><br></p><h2 id="LDAP与RDBMS"><a href="#LDAP与RDBMS" class="headerlink" title="LDAP与RDBMS"></a>LDAP与RDBMS</h2><p>最常见的问题是——为什么OpenLDAP不使用 RDBMS(关系数据库管理系统) 而是使用像 LMDB 那样的嵌入式键/值存储？总的来说，期望商业级 RDBMS 实现的复杂算法可以使 OpenLDAP更 快或更好，并且同时允许与其他应用程序共享数据。</p><p>简而言之，使用嵌入式数据库和自定义索引系统，OpenLDAP可以在不损失可靠性的情况下提供更高的性能和可扩展性。所以OpenLDAP使用 LMDB 并发/事务 数据库软件。</p><p><br></p><p>下面是一个详细而冗长的答案: &lt;&gt;</p><p>很有可能认为在目录中使用RDBMS后端可以解决所有问题。但是，它是一头猪。这是因为数据模型非常不同。使用关系数据库表示目录数据将需要将数据拆分为多个表。<br>现在最大的问题是从一个条目访问数据需要在不同的磁盘区域上进行搜索。在某些应用程序中，这可能没问题但在许多应用程序中性能会受到影响。</p><p><br><br><br><br><br></p><h2 id="slapd"><a href="#slapd" class="headerlink" title="slapd"></a>slapd</h2><p>slapd是OpenLDAP的守护进程， 在许多不同平台上运行的LDAP目录服务器。</p><p>slapd有一些有趣的功能和特性:</p><ul><li><strong>LDAPv3</strong>: slapd实现轻量级目录访问协议的第3版，slapd支持IPv4和IPv6以及Unix IPC上的LDAP。</li><li><strong>Simple Authentication and Security Layer</strong>: slapd通过使用SASL支持强身份验证和数据安全性（完整性和机密性）服务</li><li><strong>Transport Layer Security</strong>: slapd通过使用 TLS/SSL 持基于证书的身份验证和数据安全性（完整性和机密性）服务</li><li><strong>Topology control</strong>: slapd可以配置为根据网络拓扑信息限制 socket 层的访问，基于 TCP wrapper</li><li><strong>Access control</strong>: slapd提供了丰富而强大的访问控制功能，允许您控制对数据库中信息的访问</li><li><strong>Internationalization</strong>: slapd支持Unicode 和 Language tag</li><li><strong>Choice of database backends</strong>: slapd附带了各种不同的数据库后端，您可以从中选择</li><li><strong>Multiple database instances</strong>: slapd可以配置为同时为多个数据库提供服务。这意味着单个slapd服务器可以使用相同或不同的数据库后端响应LDAP树的许多逻辑上不同部分的请求</li><li><strong>Generic modules API</strong>: 如果您需要更多自定义，slapd可让您轻松编写自己的模块</li><li><strong>Threads</strong>: slapd具有高性能的线程</li><li><strong>Replication</strong>: slapd可以配置为维护目录信息的集群副本</li><li><strong>Proxy Cache</strong>: slapd可以配置为缓存LDAP代理服务</li><li><strong>Configuration</strong>: slapd可通过单个配置文件进行高度配置，允许您更改您想要更改的所有内容</li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>A Quick-Start Guide</p><blockquote><p>注意：本快速入门指南不使用强身份验证，也不使用任何完整性或机密保护服务。这些服务在OpenLDAP的其它章节中进行了描述。</p></blockquote><p>以下包括OpenLDAP v2.4软件的快速入门指南。</p><p><br></p><ul><li>获取软件</li><li>打开发行包</li><li>审阅文档</li><li>运行<code>configure</code></li><li>构建软件</li><li>测试构建</li><li>安装软件</li><li>编辑配置文件</li><li>导入配置数据库</li><li>启动SLAPD</li><li>添加初始化条目到目录</li><li>查看是否正常运行</li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="配置选择"><a href="#配置选择" class="headerlink" title="配置选择"></a>配置选择</h1><p>The Big Picture - Configuration Choices</p><p>本节简要概述了各种LDAP目录配置。</p><p><br></p><h2 id="本地目录服务"><a href="#本地目录服务" class="headerlink" title="本地目录服务"></a>本地目录服务</h2><p>Local Directory Service</p><p>在此配置中，您运行 slapd 实例，该实例仅为您的本地域提供目录服务。它不以任何方式与其他目录服务器进行交互。</p><p><img src="/images/OpenLDAp/config_local.png" alt=""></p><p><br><br><br><br><br></p><h2 id="带推荐的本地目录服务"><a href="#带推荐的本地目录服务" class="headerlink" title="带推荐的本地目录服务"></a>带推荐的本地目录服务</h2><p>Local Directory Service with Referrals</p><p>在此配置中，运行 slapd 实例，该实例为本地域提供目录服务，并将其配置为将引用返回到能够处理请求的其它服务器。</p><p>如果要提供本地服务并参与全局目录，或者要将下级条目的责任委派给其他服务器，请使用此配置。</p><p><img src="/images/OpenLDAP/config_ref.png" alt=""></p><p><br><br><br><br><br></p><h2 id="副本目录服务"><a href="#副本目录服务" class="headerlink" title="副本目录服务"></a>副本目录服务</h2><p>Replicated Directory Service</p><p>slapd 包括对基于LDAP Sync 的复制的支持，称为syncrepl。可用于在多个目录服务器上维护目录信息的副本。在其最基本的配置中，master 是 syncrepl provider，slavee 是 syncrepl consumer。<br>集群和提供了可靠性和可用性。</p><p><img src="/images/OpenLDAP/config_repl.png" alt=""></p><p><br><br><br><br><br></p><h2 id="分布式目录服务"><a href="#分布式目录服务" class="headerlink" title="分布式目录服务"></a>分布式目录服务</h2><p>Distributed Local Directory Service</p><p>在此配置中，本地服务被划分为较小的服务，每个服务都可以被复制，并与上级和下级引用粘合在一起。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Building and Installing OpenLDAP Software</p><p>本章详细介绍了如何构建和安装OpenLDAP软件包。</p><p><br></p><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><p>官方文档中是使用源码进行构建和安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#提取软件</span></span><br><span class="line">gunzip -c openldap-VERSION.tgz | tar xf -</span><br><span class="line"><span class="built_in">cd</span> openldap-VERSION</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#依赖软件</span></span><br><span class="line"><span class="comment">#请参考REAME，安装它所需的依赖软件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Transport Layer Security</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Simple Authentication and Security Layer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Kerberos Authentication Service</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Database Software</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Threads</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#TCP Wrappers</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#configure</span></span><br><span class="line">./configure --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">./configure --<span class="built_in">enable</span>-wrappers \</span><br><span class="line">                CPPFLAGS=<span class="string">"-I/usr/local/include"</span> \</span><br><span class="line">                LDFLAGS=<span class="string">"-L/usr/local/lib -Wl,-rpath,/usr/local/lib"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#构建软件</span></span><br><span class="line">make depend</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">make <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line"><span class="comment">#如果未指定安装位置，默认安装到 /usr/local</span></span><br><span class="line"><span class="comment">#通常，安装需要超级用户权限</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置文件</span></span><br><span class="line">/usr/<span class="built_in">local</span>/etc/openldap</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="包安装"><a href="#包安装" class="headerlink" title="包安装"></a>包安装</h2><p>因为在base源里面可直接搜索到<code>openldap</code>软件包，所以就是用软件包进行安装。</p><p><br></p><p>RPM包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#查看</span><br><span class="line">yum search openldap</span><br><span class="line"></span><br><span class="line">openldap.x86_64 : LDAP support libraries</span><br><span class="line">openldap-devel.x86_64 : LDAP development libraries and header files</span><br><span class="line">openldap-servers.x86_64 : LDAP server</span><br><span class="line">openldap-clients.x86_64 : LDAP client utilities</span><br><span class="line">openldap-servers-sql.x86_64 : SQL support module for OpenLDAP server</span><br><span class="line">compat-openldap.x86_64 : OpenLDAP compatibility shared libraries</span><br><span class="line">collectd-openldap.x86_64 : OpenLDAP plugin for collectd</span><br><span class="line">nss-pam-ldapd.x86_64 : An nsswitch module which uses directory servers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#安装</span><br><span class="line">yum install -y openldap.x86_64 openldap-servers.x86_64 openldap-clients.x86_64</span><br><span class="line">#yum install -y collectd-openldap.x86_64 openldap-servers-sql.x86_64 compat-openldap.x86_64 openldap-devel.x86_64 nss-pam-ldapd.x86_64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#验证</span><br><span class="line">rpm -qa | grep openldap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#配置文件</span><br><span class="line">/etc/openldap</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>Configuring slapd</p><p>安装完毕后，你就可以配置并使用它。</p><p>本章介绍 <code>slapd-config</code> 配置系统的一般格式。<br>OpenLDAP v2.3及更高版本已转换为使用动态运行配置引擎<code>slapd-config</code>:</p><ul><li>完全启用LDAP</li><li>使用标准LDAP操作进行管理</li><li>将其配置数据存储在LDIF数据库中(openldap/slap.d/)</li><li>允许所有slapd的配置选项在运行中进行更改，通常无需重新启动服务器即可使更改生效</li></ul><p><br></p><blockquote><p><strong>注意</strong>：<br>虽然 <code>slapd-config</code> 统将其配置存储为（基于文本的）LDIF文件，但您不应直接编辑任何LDIF文件。配置更改应通过LDAP操作执行，如 <code>ldapadd</code>, <code>ldapdelete</code>, <code>ldapmodify</code></p></blockquote><p><br><br><br></p><h2 id="配置的布局"><a href="#配置的布局" class="headerlink" title="配置的布局"></a>配置的布局</h2><p>Configuration Layout</p><p>slapd配置存储为具有预定义模式和DIT的特殊LDAP目录。有特定的<code>objectClasses</code>用于承载全局配置选项，模式定义，后端和数据库定义以及各种其它项。</p><p>栗子配置树:</p><p><img src="/images/OpenLDAP/config_dit.png" alt=""></p><p><br></p><p><code>slapd-config</code> 配置树具有非常特定的结构。树的根名为 <code>cn=config</code> 并包含全局配置设置。其他设置包含在单独的子条目中：</p><ul><li>Dynamically loaded modules</li><li>Schema definitions</li><li>Backend-specific configuration</li><li>Database-specific configuration</li></ul><p><br></p><p>LDIF文件的常用规则适用于配置信息:</p><ul><li><code>#</code>表示注释</li><li>如果一行以单个空格开头，则将其视为前一行的延续（即使前一行是注释），并删除单个前导空格。条目由空行分隔</li></ul><p><br></p><p>配置LDIF的一般布局如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#globalconfigurationsettings</span><br><span class="line">dn:cn=config</span><br><span class="line">objectClass:olcGlobal</span><br><span class="line">cn:config</span><br><span class="line">&lt;globalconfigsettings&gt;</span><br><span class="line"></span><br><span class="line">#schemadefinitions</span><br><span class="line">dn:cn=schema,cn=config</span><br><span class="line">objectClass:olcSchemaConfig</span><br><span class="line">cn:schema</span><br><span class="line">&lt;systemschema&gt;</span><br><span class="line"></span><br><span class="line">dn:cn=&#123;X&#125;core,cn=schema,cn=config</span><br><span class="line">objectClass:olcSchemaConfig</span><br><span class="line">cn:&#123;X&#125;core</span><br><span class="line">&lt;coreschema&gt;</span><br><span class="line"></span><br><span class="line">#additionaluser-specifiedschema</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#backenddefinitions</span><br><span class="line">dn:olcBackend=&lt;typeA&gt;,cn=config</span><br><span class="line">objectClass:olcBackendConfig</span><br><span class="line">olcBackend:&lt;typeA&gt;</span><br><span class="line">&lt;backend-specificsettings&gt;</span><br><span class="line"></span><br><span class="line">#databasedefinitions</span><br><span class="line">dn:olcDatabase=&#123;X&#125;&lt;typeA&gt;,cn=config</span><br><span class="line">objectClass:olcDatabaseConfig</span><br><span class="line">olcDatabase:&#123;X&#125;&lt;typeA&gt;</span><br><span class="line">&lt;database-specificsettings&gt;</span><br><span class="line"></span><br><span class="line">#subsequentdefinitionsandsettings</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="配置指令"><a href="#配置指令" class="headerlink" title="配置指令"></a>配置指令</h2><p>Configuration Directives</p><p>本节详细介绍了常用的配置指令</p><p><br></p><h3 id="cn-config"><a href="#cn-config" class="headerlink" title="cn=config"></a>cn=config</h3><p>本条目中包含的指令通常适用于整个服务器。其中大多数是系统或面向连接，而不是数据库相关。条目必须具有 <code>olcGlobal</code> 对象类(objectClass)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#指定强制关闭空闲客户端连接之前等待的秒数</span><br><span class="line">#默认值为0，表示禁用此功能</span><br><span class="line">olcIdleTimeout: &lt;integer&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#该指令指定syslog（当前记录到syslogd）的调试语句和操作统计信息的级别。您必须已配置OpenLDAP --enable-debug（默认值）才能使用</span><br><span class="line">olcLogLevel: &lt;level&gt;</span><br><span class="line"></span><br><span class="line">#Debugging Levels</span><br><span class="line">LevelKeywordDescription</span><br><span class="line">-1anyenable all debugging</span><br><span class="line">0 no debugging</span><br><span class="line">1(0x1 trace)trace function calls</span><br><span class="line">2(0x2 packets)debug packet handling</span><br><span class="line">4(0x4 args)heavy trace debugging</span><br><span class="line">8(0x8 conns)connection management</span><br><span class="line">16(0x10 BER)print out packets sent and received</span><br><span class="line">32(0x20 filter)search filter processing</span><br><span class="line">64(0x40 config)configuration processing</span><br><span class="line">128(0x80 ACL)access control list processing</span><br><span class="line">256(0x100 stats)stats log connections/operations/results</span><br><span class="line">512(0x200 stats2)stats log entries sent</span><br><span class="line">1024(0x400 shell)print communication with shell backends</span><br><span class="line">2048(0x800 parse)print entry parsing debugging</span><br><span class="line">16384(0x4000 sync)syncrepl consumer processing</span><br><span class="line">32768(0x8000 none)only messages that get logged whatever log level is set</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定当slapd无法找到本地数据库来处理请求时要传回的引用</span><br><span class="line">olcReferral &lt;URI&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子条目</span><br><span class="line">dn: cn=config</span><br><span class="line">objectClass: olcGlobal</span><br><span class="line">cn: config</span><br><span class="line">olcIdleTimeout: 30</span><br><span class="line">olcLogLevel: Stats</span><br><span class="line">olcReferral: ldap://root.openldap.org</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="cn-module"><a href="#cn-module" class="headerlink" title="cn=module"></a>cn=module</h3><p>如果在配置slapd时启用了对动态加载模块的支持，则可以使用 <code>cn=module</code> 条目来指定要加载的模块集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#指定要加载的可动态加载模块的名称</span><br><span class="line">olcModuleLoad: &lt;filename&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定要搜索可加载模块的目录列表</span><br><span class="line">olcModulePath: &lt;pathspec&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子</span><br><span class="line">dn: cn=module&#123;0&#125;,cn=config</span><br><span class="line">objectClass: olcModuleList</span><br><span class="line">cn: module&#123;0&#125;</span><br><span class="line">olcModuleLoad: /usr/local/lib/smbk5pwd.la</span><br><span class="line"></span><br><span class="line">dn: cn=module&#123;1&#125;,cn=config</span><br><span class="line">objectClass: olcModuleList</span><br><span class="line">cn: module&#123;1&#125;</span><br><span class="line">olcModulePath: /usr/local/lib:/usr/local/lib/slapd</span><br><span class="line">olcModuleLoad: accesslog.la</span><br><span class="line">olcModuleLoad: pcache.la</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="cn-schema"><a href="#cn-schema" class="headerlink" title="cn=schema"></a>cn=schema</h3><p>此条目包含在 slapd 中硬编码的所有模式定义。因此，此条目中的值由slapd生成，因此配置文件中不需要提供 schema value。仍必须定义该条目，以作为用户定义的模式添加到下面的基础。schema entry 必须具有 <code>olcSchemaConfig</code> 的对象类 (objectClass)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#定义了一个属性类型</span><br><span class="line">olcAttributeTypes: &lt;RFC4512 Attribute Type Description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#定义一个对象类</span><br><span class="line">olcObjectClasses: &lt;RFC4512 Object Class Description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子条目</span><br><span class="line">dn: cn=schema,cn=config</span><br><span class="line">objectClass: olcSchemaConfig</span><br><span class="line">cn: schema</span><br><span class="line"></span><br><span class="line">dn: cn=test,cn=schema,cn=config</span><br><span class="line">objectClass: olcSchemaConfig</span><br><span class="line">cn: test</span><br><span class="line">olcAttributeTypes: ( 1.1.1</span><br><span class="line">  NAME &apos;testAttr&apos;</span><br><span class="line">  EQUALITY integerMatch</span><br><span class="line">  SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 )</span><br><span class="line">olcAttributeTypes: ( 1.1.2 NAME &apos;testTwo&apos; EQUALITY caseIgnoreMatch</span><br><span class="line">  SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.44 )</span><br><span class="line">olcObjectClasses: ( 1.1.3 NAME &apos;testObject&apos;</span><br><span class="line">  MAY ( testAttr $ testTwo ) AUXILIARY )</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Backend-specific-Directives"><a href="#Backend-specific-Directives" class="headerlink" title="Backend-specific Directives"></a>Backend-specific Directives</h3><p>后端指令适用于所有相同类型的数据库实例，并且可能会被数据库指令覆盖，具体取决于指令。后端条目必须具有 <code>olcBackendConfig</code> 的对象类 (objectClass)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#命名特定于后端的配置条目</span><br><span class="line">olcBackend: &lt;type&gt;</span><br><span class="line"></span><br><span class="line">#Database Backends</span><br><span class="line">TypesDescription</span><br><span class="line">bdb    Berkeley DB transactional backend (deprecated)</span><br><span class="line">configSlapd configuration backend</span><br><span class="line">dnssrvDNS SRV backend</span><br><span class="line">hdb    Hierarchical variant of bdb backend (deprecated)</span><br><span class="line">ldapLightweight Directory Access Protocol (Proxy) backend</span><br><span class="line">ldifLightweight Data Interchange Format backend</span><br><span class="line">mdb    Memory-Mapped DB backend</span><br><span class="line">metaMeta Directory backend</span><br><span class="line">monitorMonitor backend</span><br><span class="line">passwdProvides read-only access to passwd(5)</span><br><span class="line">perlPerl Programmable backend</span><br><span class="line">shellShell (extern program) backend</span><br><span class="line">sql    SQL Programmable backend</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子</span><br><span class="line">dn: olcBackend=bdb,cn=config</span><br><span class="line">objectClass: olcBackendConfig</span><br><span class="line">olcBackend: bdb</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Database-specific-Directives"><a href="#Database-specific-Directives" class="headerlink" title="Database-specific Directives"></a>Database-specific Directives</h3><p>每种类型的数据库都支持本节中的指令。数据库条目必须含有 <code>olcDatabaseConfig</code> 对象类 (objectClass)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#命名特定的数据库实例</span><br><span class="line">#可以提供数字&#123;&lt;index&gt;&#125;以区分相同类型的多个数据库</span><br><span class="line">olcDatabase: [&#123;&lt;index&gt;&#125;]&lt;type&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#权限指令</span><br><span class="line">#如果未指定，默认使用 to * by * read</span><br><span class="line">olcAccess: to &lt;what&gt; [ by &lt;who&gt; [&lt;accesslevel&gt;] [&lt;control&gt;] ]+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#将数据库置于“只读”模式</span><br><span class="line">olcReadonly &#123; TRUE | FALSE &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定不受此访问控制的DN或对此数据库的操作的管理限制</span><br><span class="line">#DN不需要引用此数据库中的条目，甚至不需要引用目录中的条目。</span><br><span class="line">olcRootDN: &lt;DN&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#用于为root dn 指定DN的密码</span><br><span class="line">olcRootPW: &lt;password&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定从搜索操作返回的最大条目数</span><br><span class="line">olcSizeLimit: &lt;integer&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#定将传递给此后端数据库的查询的DN后缀</span><br><span class="line">olcSuffix: &lt;dn suffix&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#将当前 slapd 建立为运行 syncrepl 复制引擎的复制使用者站点，将当前数据库指定为主内容的副本</span><br><span class="line">olcSyncrepl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定slapd将用于回答搜索请求的最大秒数</span><br><span class="line">olcTimeLimit: &lt;integer&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#该指令仅适用于slave slapd</span><br><span class="line">olcUpdateref: &lt;URL&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子条目</span><br><span class="line">dn: olcDatabase=frontend,cn=config</span><br><span class="line">objectClass: olcDatabaseConfig</span><br><span class="line">objectClass: olcFrontendConfig</span><br><span class="line">olcDatabase: frontend</span><br><span class="line">olcReadOnly: FALSE</span><br><span class="line"></span><br><span class="line">dn: olcDatabase=config,cn=config</span><br><span class="line">objectClass: olcDatabaseConfig</span><br><span class="line">olcDatabase: config</span><br><span class="line">olcRootDN: cn=Manager,dc=example,dc=com</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="BDB-and-HDB-Database-Directives"><a href="#BDB-and-HDB-Database-Directives" class="headerlink" title="BDB and HDB Database Directives"></a>BDB and HDB Database Directives</h3><p>此类别中的指令适用于BDB和HDB数据库。除了上面定义的通用数据库指令之外，它们还用在 olcDatabase 条目中。除了<code>olcDatabaseConfig</code> 对象类之外，BDB和HDB数据库条目还必须分别具有 <code>olcBdbConfig</code> 和 <code>olcHdbConfig</code> 对象类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#指定包含数据库和相关索引的BDB文件所在的目录</span><br><span class="line">olcDbDirectory: &lt;directory&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定BDB后端数据库实例维护的内存高速缓存条目的大小</span><br><span class="line">olcDbCachesize: &lt;integer&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定检查BDB事务日志的频率，检查点操作将数据库缓冲区刷新到磁盘，并在日志中写入检查点记录</span><br><span class="line">olcDbCheckpoint: &lt;kbyte&gt; &lt;min&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定要放置在数据库目录的DB_CONFIG文件中的配置指令</span><br><span class="line">olcDbConfig: &lt;DB_CONFIG setting&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#此选项会导致磁盘上的数据库内容在更改时不会立即与内存更改同步</span><br><span class="line">olcDbNosync: &#123; TRUE | FALSE &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在索引槽中指定内存中索引缓存的大小。默认值为零</span><br><span class="line">olcDbIDLcacheSize: &lt;integer&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定要为给定属性维护的索引</span><br><span class="line">olcDbIndex: &#123;&lt;attrlist&gt; | default&#125; [pres,eq,approx,sub,none]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#如果此设置为TRUE，则slapindex将一次索引一个属性。默认设置为FALSE，在这种情况下，条目的所有索引属性将同时处理</span><br><span class="line">olcDbLinearIndex: &#123; TRUE | FALSE &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定新创建的数据库索引文件应具有的文件保护模式</span><br><span class="line">olcDbMode: &#123; &lt;octal&gt; | &lt;symbolic&gt; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定用于搜索过滤器评估的堆栈深度</span><br><span class="line">olcDbSearchStack: &lt;integer&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#为共享内存BDB环境指定 key 。默认情况下，BDB环境使用内存映射文件。如果指定了非零值，则它将用作标识将容纳环境的共享内存区域的键</span><br><span class="line">olcDbShmKey: &lt;integer&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子条目</span><br><span class="line">dn: olcDatabase=hdb,cn=config</span><br><span class="line">objectClass: olcDatabaseConfig</span><br><span class="line">objectClass: olcHdbConfig</span><br><span class="line">olcDatabase: hdb</span><br><span class="line">olcSuffix: &quot;dc=example,dc=com&quot;</span><br><span class="line">olcDbDirectory: /usr/local/var/openldap-data</span><br><span class="line">olcDbCacheSize: 1000</span><br><span class="line">olcDbCheckpoint: 1024 10</span><br><span class="line">olcDbConfig: set_cachesize 0 10485760 0</span><br><span class="line">olcDbConfig: set_lg_bsize 2097152</span><br><span class="line">olcDbConfig: set_lg_dir /var/tmp/bdb-log</span><br><span class="line">olcDbConfig: set_flags DB_LOG_AUTOREMOVE</span><br><span class="line">olcDbIDLcacheSize: 3000</span><br><span class="line">olcDbIndex: objectClass eq</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="slapd配置文件"><a href="#slapd配置文件" class="headerlink" title="slapd配置文件"></a>slapd配置文件</h1><p>The slapd Configuration File</p><p>本章介绍如何通过 <code>slapd.conf</code> 配置文件来配置 <code>slapd</code>。 <code>slapd.conf</code> 已被弃用，建议使用前面介绍的 <code>slapd-config</code>进行配置。</p><p><br></p><p>由于已经被弃用，所以此处我跳过。</p><p>文档: <a href="http://www.openldap.org/doc/admin24/slapdconfig.html" target="_blank" rel="noopener">http://www.openldap.org/doc/admin24/slapdconfig.html</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="运行slapd"><a href="#运行slapd" class="headerlink" title="运行slapd"></a>运行slapd</h1><p><code>slapd</code> 旨在作为独立服务运行。这允许服务器利用缓存，管理底层数据库的并发问题，并节省系统资源。</p><p>由于我使用RPM包进行安装，所以可利用 <code>systemd</code> 进行OpenLDAP的管理。</p><p><br></p><p>ldap默认监听地址:</p><table><thead><tr><th>URL</th><th>Protocol</th><th>Transport</th></tr></thead><tbody><tr><td><code>ldap:///</code></td><td>LDAP</td><td>TCP port 389</td></tr><tr><td><code>ldaps:///</code></td><td>LDAP over SSL</td><td>TCP port 636</td></tr><tr><td><code>ldapi:///</code></td><td>LDAP</td><td>IPC (Unix-domain socket)</td></tr></tbody></table><p><br></p><h2 id="slapd方式"><a href="#slapd方式" class="headerlink" title="slapd方式"></a>slapd方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#查看帮助</span><br><span class="line">#man slapd</span><br><span class="line">slapd --help</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启动</span><br><span class="line">slapd --option</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#停止</span><br><span class="line">kill -INT `cat /usr/local/var/slapd.pid`</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="systemd方式"><a href="#systemd方式" class="headerlink" title="systemd方式"></a>systemd方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">systemctl status slapd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start slapd</span><br><span class="line"></span><br><span class="line">#ps -ef | grep slapd</span><br><span class="line">#/usr/sbin/slapd -u ldap -h ldapi:/// ldap:///</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl stop slapd</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LDAP维基百科: &lt;a href=&quot;https://zh.wikipedia.org/wiki/LDAP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/LDAP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OpenLDAP维基百科: &lt;a href=&quot;https://zh.wikipedia.org/wiki/OpenLDAP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/OpenLDAP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x.500&lt;/code&gt;维基百科: &lt;a href=&quot;https://zh.wikipedia.org/wiki/X.500&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/X.500&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OpenLDAP文档: &lt;a href=&quot;http://www.openldap.org/doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.openldap.org/doc/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RHEL7.x86_64&lt;/li&gt;
&lt;li&gt;LDAP v2.4.44&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="LDAP" scheme="https://zhang21.github.io/tags/LDAP/"/>
    
      <category term="Permission" scheme="https://zhang21.github.io/tags/Permission/"/>
    
      <category term="权限管理" scheme="https://zhang21.github.io/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OpenVPN</title>
    <link href="https://zhang21.github.io/2019/01/16/OpenVPN/"/>
    <id>https://zhang21.github.io/2019/01/16/OpenVPN/</id>
    <published>2019-01-16T00:46:34.000Z</published>
    <updated>2019-01-17T01:07:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>OpenVPN: <a href="https://github.com/OpenVPN/openvpn" target="_blank" rel="noopener">https://github.com/OpenVPN/openvpn</a></li><li>easy-rsa: <a href="https://github.com/OpenVPN/easy-rsa" target="_blank" rel="noopener">https://github.com/OpenVPN/easy-rsa</a></li></ul><p><br></p><p>环境:</p><ul><li>RHEL7</li><li>OpenVPN v2.4.6</li><li>easy-rsa v3.0.3</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br><br><br></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通过在云端VPC， k8s集群内运行OpenVPN Server，让本地可以通过连接OpenVPN进行访问云资源，而不需要将云资源开放公网访问。</p><p>我是将OpenVPN运行在k8s 集群了，对它提供ELB进行公网连接。在S端配置文件中推送对应的路由信息——如集群内节点CIDR， 服务CIDR, VPC CIDR…</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p><br></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>需要安装:</p><ul><li>EPEL</li><li>openvpn</li><li>easy-rsa: 用于制作CA证书，S端证书，C端证书</li></ul><p>安装了EPEL源之后就可以直接安装<code>openvpn</code>和<code>easy-rsa</code>，当然也可以从GitHub上拉取。</p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line"></span><br><span class="line">yum install -y openvpn easy-rsa</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="制作证书"><a href="#制作证书" class="headerlink" title="制作证书"></a>制作证书</h2><p><br></p><h3 id="编辑vars文件"><a href="#编辑vars文件" class="headerlink" title="编辑vars文件"></a>编辑vars文件</h3><p>此处需注意，通过yum安装可能会没有<code>example.vars</code>这个栗子文件。没关系，请在<a href="https://github.com/OpenVPN/easy-rsa/tree/v3.0.6/easyrsa3" target="_blank" rel="noopener">easy-rsa GitHub</a>去下载一份过来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/openvpn/easy-rsa/server</span><br><span class="line">mkdir -p /etc/openvpn/easy-rsa/client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#拷贝easy-rsa文件，用于制作证书</span><br><span class="line">cp -r /usr/share/easy-rsa/3.0.3/  /etc/openvpn/easy-rsa/server/</span><br><span class="line">cp -r /usr/share/easy-rsa/3.0.3/  /etc/openvpn/easy-rsa/client/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#先制作CA和S端证书</span><br><span class="line">cd /etc/openvpn/easy-rsa/server/</span><br><span class="line">cp vars.example vars</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改几个配置</span><br><span class="line">vim vars</span><br><span class="line"></span><br><span class="line">#根据自己的情况进行修改</span><br><span class="line">set_var EASYRSA_REQ_COUNTRY “CN” #国家</span><br><span class="line">set_var EASYRSA_REQ_PROVINCE “Sichuan” #省份</span><br><span class="line">set_var EASYRSA_REQ_CITY “ChengDu” #城市</span><br><span class="line">set_var EASYRSA_REQ_ORG “TianFu” #非盈利组织，此处可填公司之类</span><br><span class="line">set_var EASYRSA_REQ_EMAIL “abc@xyz.com” #邮箱地址</span><br><span class="line">set_var EASYRSA_REQ_OU “My OpenVPN” #组织单元</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="创建证书和秘钥"><a href="#创建证书和秘钥" class="headerlink" title="创建证书和秘钥"></a>创建证书和秘钥</h3><ul><li><strong>CA证书和S端证书</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/openvpn/easy-rsa/server</span><br><span class="line">./easyrsa -h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化，会读取vars文件</span></span><br><span class="line">./easyrsa init-pki</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建根证书</span></span><br><span class="line"><span class="comment">#这里会要求输入PEM pass，这个请记住，后面签名需要此密码</span></span><br><span class="line">./easyrsa build-ca</span><br><span class="line"><span class="comment">#这里生成CA证书</span></span><br><span class="line"><span class="comment">#pki/ca.crt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建S端证书</span></span><br><span class="line"><span class="comment">#nopass选项表示不加密</span></span><br><span class="line">./easyrsa gen-req server nopass</span><br><span class="line"><span class="comment">#这里生成两个文件</span></span><br><span class="line"><span class="comment">#pki/reqs/server.req</span></span><br><span class="line"><span class="comment">#pki/private/server.key</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#签约S端证书</span></span><br><span class="line"><span class="comment">#第一个server表示S端，后面是取的名字</span></span><br><span class="line">./easyrsa sign server server</span><br><span class="line"><span class="comment">#这里需要输入CA证书的PEM pass</span></span><br><span class="line"><span class="comment">#之后会生成S端证书</span></span><br><span class="line"><span class="comment">#pki/issued/server.crt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建Diffie-Hellman</span></span><br><span class="line">./easyrsa gen-dh</span><br><span class="line"><span class="comment">#生成dh.pem文件</span></span><br><span class="line"><span class="comment">#pki/dh.pem</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>C端证书</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/openvpn/easy-rsa/client/</span><br><span class="line"><span class="comment">#./easyrsa -h</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化</span></span><br><span class="line">./easyrsa init-pki</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建C端证书</span></span><br><span class="line">./easyrsa gen-req client nopass</span><br><span class="line"><span class="comment">#这里生成两个文件</span></span><br><span class="line"><span class="comment">#pki/reqs/client.req</span></span><br><span class="line"><span class="comment">#pki/private/client.key</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在CA端导入C端证书</span></span><br><span class="line"><span class="built_in">cd</span> /etc/openvpn/easy-rsa/server</span><br><span class="line">./easy-rsa import-req /etc/openvpn/easy-rsa/client/reqs/client.req client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#签约C端证书</span></span><br><span class="line"><span class="comment">#第一个client表示C端，第二个为定义的名字</span></span><br><span class="line">./easyrsa sign client client</span><br><span class="line"><span class="comment">#这里需要输入CA证书的PEM pass</span></span><br><span class="line"><span class="comment">#之后会生成C端证书</span></span><br><span class="line"><span class="comment">#/etc/openvpn/easy-rsa/server/pki/issued/client.crt</span></span><br><span class="line"><span class="comment">#注意生成的位置，不要搞错了</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>梳理上面生成的文件</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server/pki/ca.crt</span><br><span class="line">server/pki/dh.pem</span><br><span class="line"></span><br><span class="line">server/pki/reqs/server.req</span><br><span class="line">server/pki/reqs/client.req</span><br><span class="line"></span><br><span class="line">server/pki/private/ca.key</span><br><span class="line">server/pki/private/server.key</span><br><span class="line"></span><br><span class="line">server/pki/issued/server.crt</span><br><span class="line">server/pki/issued/client.crt</span><br><span class="line"></span><br><span class="line">#client/pki/reqs/client.req</span><br><span class="line">client/pki/private/client.key</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="拷贝相应证书到openvpn目录下"><a href="#拷贝相应证书到openvpn目录下" class="headerlink" title="拷贝相应证书到openvpn目录下"></a>拷贝相应证书到openvpn目录下</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#S端</span></span><br><span class="line"><span class="built_in">cd</span> /etc/openvpn/server</span><br><span class="line"></span><br><span class="line">cp /etc/openvpn/easy-rsa/server/pki/ca.crt .</span><br><span class="line">cp /etc/openvpn/easy-rsa/server/pki/private/server.key .</span><br><span class="line">cp /etc/openvpn/easy-rsa/server/pki/issued/server.crt .</span><br><span class="line">cp /etc/openvpn/easy-rsa/server/pki/dh.pem .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#C端</span></span><br><span class="line"><span class="built_in">cd</span> /etc/openvpn/client</span><br><span class="line">cp /etc/openvpn/easy-rsa/server/pki/ca.crt .</span><br><span class="line">cp /etc/openvpn/easy-rsa/client/pki/private/client.key .</span><br><span class="line">cp /etc/openvpn/easy-rsa/server/pki/issued/client.crt .</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>在<a href="https://github.com/OpenVPN/openvpn/tree/master/sample" target="_blank" rel="noopener">openvpn GitHub</a>去下载对应配置文件，做相应的修改。</p><p><br></p><h3 id="S端配置文件"><a href="#S端配置文件" class="headerlink" title="S端配置文件"></a>S端配置文件</h3><p>一下只是我的栗子，详细信息请参考自己的项目。具体的每个选项描述，栗子文件里面有解释。</p><p><code>vim server.conf</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">port 1194</span><br><span class="line">proto udp</span><br><span class="line">dev tun</span><br><span class="line"></span><br><span class="line">ca /etc/openvpn/server/ca.crt</span><br><span class="line">cert /etc/openvpn/server/server.crt</span><br><span class="line">key /etc/openvpn/server/server.key</span><br><span class="line">dh /etc/openvpn/server/dh.pem</span><br><span class="line"></span><br><span class="line">#VPN CIDR</span><br><span class="line">server 10.8.0.0 255.255.255.0</span><br><span class="line">ifconfig-pool-persist ipp.txt</span><br><span class="line"></span><br><span class="line">#推送的S端的CIDR给C端路由</span><br><span class="line">push &quot;route 10.0.0.0 255.255.224.0&quot;</span><br><span class="line"></span><br><span class="line">#推送S端DNS</span><br><span class="line">push &quot;dhcp-option DNS 10.247.3.10&quot;</span><br><span class="line">push &quot;dhcp-option DNS 114.114.114.114&quot;</span><br><span class="line"></span><br><span class="line">client-to-client</span><br><span class="line">keepalive 20 120</span><br><span class="line">cipher AES-256-CBC</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">log         /dev/stdout</span><br><span class="line">log-append  /dev/stdout</span><br><span class="line"></span><br><span class="line">verb 3</span><br><span class="line">explicit-exit-notify 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启用用户/密码进行登录需要添加的选项</span><br><span class="line">#栗子文件里面没有这些信息</span><br><span class="line">script-security 3</span><br><span class="line">auth-user-pass-verify /etc/openvpn/checkpsw.sh via-env</span><br><span class="line">#http://openvpn.se/files/other/checkpsw.sh</span><br><span class="line">#去下载这个脚本</span><br><span class="line">#client-cert-not-required</span><br><span class="line">#此选项只使用用户密码，不使用证书</span><br><span class="line">#注释它，使用证书和用户密码双重登录</span><br><span class="line">username-as-common-name</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="C端配置文件"><a href="#C端配置文件" class="headerlink" title="C端配置文件"></a>C端配置文件</h3><p><code>vim client.ovpn</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">client</span><br><span class="line">dev tun</span><br><span class="line"></span><br><span class="line">proto udp</span><br><span class="line">remote addr port</span><br><span class="line"></span><br><span class="line">resolv-retry infinite</span><br><span class="line"></span><br><span class="line">nobind</span><br><span class="line"></span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#此处我将CA证书和C端证书信息写入配置文件</span><br><span class="line">#当然，也可下载证书在指定，但这麻烦了</span><br><span class="line">&lt;ca&gt;</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">xxxxxxxxxxx</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line">&lt;/ca&gt;</span><br><span class="line"></span><br><span class="line">&lt;cert&gt;</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">xxxxxxxxxxxxxxxxx</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line">&lt;/cert&gt;</span><br><span class="line"></span><br><span class="line">&lt;key&gt;</span><br><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">xxxxxxxxxxxxxxxx</span><br><span class="line">-----END PRIVATE KEY-----</span><br><span class="line">&lt;/key&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">remote-cert-tls server</span><br><span class="line">cipher AES-256-CBC</span><br><span class="line">verb 3</span><br><span class="line"></span><br><span class="line">#用户认证</span><br><span class="line">script-security 3</span><br><span class="line">auth-user-pass</span><br><span class="line">#可将用户信息写入文件，用户密码各一行</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="另外几个配置"><a href="#另外几个配置" class="headerlink" title="另外几个配置"></a>另外几个配置</h3><p><code>vi checksw.sh</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"><span class="comment"># checkpsw.sh (C) 2004 Mathias Sundman &lt;mathias@openvpn.se&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script will authenticate OpenVPN users against</span></span><br><span class="line"><span class="comment"># a plain text file. The passfile should simply contain</span></span><br><span class="line"><span class="comment"># one row per user with the username first followed by</span></span><br><span class="line"><span class="comment"># one or more space(s) or tab(s) and then the password.</span></span><br><span class="line">  </span><br><span class="line">PASSFILE=<span class="string">"/etc/openvpn/psw-file"</span></span><br><span class="line">LOG_FILE=<span class="string">"/etc/openvpn/openvpn-password.log"</span></span><br><span class="line">TIME_STAMP=`date <span class="string">"+%Y-%m-%d %T"</span>`</span><br><span class="line">  </span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> [ ! -r <span class="string">"<span class="variable">$&#123;PASSFILE&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;TIME_STAMP&#125;</span>: Could not open password file \"<span class="variable">$&#123;PASSFILE&#125;</span>\" for reading."</span> &gt;&gt; <span class="variable">$&#123;LOG_FILE&#125;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">  </span><br><span class="line">CORRECT_PASSWORD=`awk <span class="string">'!/^;/&amp;&amp;!/^#/&amp;&amp;$1=="'</span><span class="variable">$&#123;username&#125;</span><span class="string">'"&#123;print $2;exit&#125;'</span> <span class="variable">$&#123;PASSFILE&#125;</span>`</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;CORRECT_PASSWORD&#125;</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;TIME_STAMP&#125;</span>: User does not exist: username=\"<span class="variable">$&#123;username&#125;</span>\", password=\"<span class="variable">$&#123;password&#125;</span>\"."</span> &gt;&gt; <span class="variable">$&#123;LOG_FILE&#125;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;password&#125;</span>"</span> = <span class="string">"<span class="variable">$&#123;CORRECT_PASSWORD&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;TIME_STAMP&#125;</span>: Successful authentication: username=\"<span class="variable">$&#123;username&#125;</span>\"."</span> &gt;&gt; <span class="variable">$&#123;LOG_FILE&#125;</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;TIME_STAMP&#125;</span>: Incorrect password: username=\"<span class="variable">$&#123;username&#125;</span>\", password=\"<span class="variable">$&#123;password&#125;</span>\"."</span> &gt;&gt; <span class="variable">$&#123;LOG_FILE&#125;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><p><br></p><p><code>vi psw-file</code>: 这为可登录的用户密码</p><p>直接往这个文件写入用户和密码即可，并不需要重启openvpn服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user1    pass-user1</span><br><span class="line"></span><br><span class="line">#comment</span><br><span class="line">user2   pass-user2</span><br></pre></td></tr></table></figure><p><br></p><p><code>vi start_openvpn.sh</code>: 启动脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">mkdir -p /dev/net</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -c /dev/net/tun ]; <span class="keyword">then</span></span><br><span class="line">    mknod /dev/net/tun c 10 200</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'net.ipv4.ip_forward=1'</span> &gt;&gt; /etc/sysctl.conf &amp;&amp; sysctl -p</span><br><span class="line"></span><br><span class="line"><span class="comment">#此处一定要记得写iptables，否则后面连上了VPN也无法正常访问</span></span><br><span class="line"><span class="comment">#我也是找了好久才找到这个问题</span></span><br><span class="line"><span class="comment">#这个网段为openvpn里面定义的网段</span></span><br><span class="line">iptables -t nat -A POSTROUTING -s 10.8.0.0/24  -j MASQUERADE</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /etc/openvpn</span><br><span class="line"></span><br><span class="line"><span class="comment">#--daemon，放入后台</span></span><br><span class="line">/sbin/openvpn --config /etc/openvpn/server/server.conf</span><br></pre></td></tr></table></figure><p><br></p><p>由于我是运行在k8s集群容器内，所有还有几个文件:</p><ul><li><code>Dockerfile</code></li><li><code>.dockerignore</code></li><li><code>k8s.yaml</code>: 由于它需要创建和使用系统资源，所以请使用特权容器运行</li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><ul><li>启动S端</li><li>客户端连接<ul><li>Windows客户端</li><li>Linux客户端</li><li>Mac客户端</li></ul></li></ul><p>启动之后应该就能正常访问了，如果不能正常访问，请查看你推送的CIDR和DNS，还有ipv4转发和iptables等。</p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#S端</span><br><span class="line">#由于需要使用和创建系统资源，所以请用特权容器进行运行，不然会提示没有权限</span><br><span class="line">/sbin/openvpn --config /etc/openvpn/server/server.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#C端</span><br><span class="line"></span><br><span class="line">#Windows下载Openvpn GUI，制定客户端配置文件进行连接，之后输入用户名和面膜</span><br><span class="line"></span><br><span class="line">#Linux下</span><br><span class="line">#/sbin/openvpn --config /etc/openvpn/client/client.ovpn</span><br><span class="line"></span><br><span class="line">#Mac下，下载对应Openvpn软件，指定配置文件进行连接</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OpenVPN: &lt;a href=&quot;https://github.com/OpenVPN/openvpn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/OpenVPN/openvpn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;easy-rsa: &lt;a href=&quot;https://github.com/OpenVPN/easy-rsa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/OpenVPN/easy-rsa&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RHEL7&lt;/li&gt;
&lt;li&gt;OpenVPN v2.4.6&lt;/li&gt;
&lt;li&gt;easy-rsa v3.0.3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="OpenVPN" scheme="https://zhang21.github.io/tags/OpenVPN/"/>
    
  </entry>
  
  <entry>
    <title>Apollo</title>
    <link href="https://zhang21.github.io/2019/01/09/Apollo/"/>
    <id>https://zhang21.github.io/2019/01/09/Apollo/</id>
    <published>2019-01-09T11:11:22.000Z</published>
    <updated>2019-01-10T10:10:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>Apollo官方文档: <a href="https://github.com/ctripcorp/apollo/wiki" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo/wiki</a></li></ul><p><br></p><p>环境:</p><ul><li>Apollo v1.2</li><li>Docker v1.18</li><li>K8s v1.11</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br><br><br></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>基本上按照官方文档都没什么问题，说几点我在配置过程中容易出错的地方。</p><p>总的来说就是一个<code>portal</code>，多个<code>config+admin</code>，而<code>Eruea</code>注册的<code>Meta Server</code>是和<code>config</code>在一起的，每个环境的<code>admin</code>注册到对应环境的<code>Meta Server(config)</code>。</p><p>我是将其放入k8s集群中运行，所以针对官方给出的<code>Dockerfile</code>和<code>k8s.yaml</code>文件做了对应的修改。</p><p><br></p><p>看一下我画的架构图和官方架构图:</p><p><img src="/images/Apollo/Apollo.png" alt=""></p><p><br></p><p><img src="/images/Apollo/apollo-deployment.png" alt=""></p><p><br></p><p><strong>我自己画的一个Apollo项目架构图：</strong></p><p><img src="/images/Apollo/apollo_arch.jpg" alt=""></p><p><br><br><br><br><br></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>为不同环境创建不同数据库</li></ul><p>官方已经给出了创建数据库的sql语句，一个<code>portadb</code>, 多个<code>configdb-project-env</code>。我们需要修改数据库名，为不同的环境建立不同的数据库，所以需要在使用官方sql的时候把数据库名修改为自定义的即可，这样创建的各个环境数据库的表结构都是一样的。</p><p><br></p><ul><li>配置了一个环境变量，它也就是部署服务的集群内访问地址(不在同一VPC可能需要外部访问地址)</li></ul><p>官方是写入了Dockerfile里面作为环境变量，我是将其写入k8s yaml中的环境变量。当然，也可以写入启动脚本中。<br>以下配置，随便用哪一个。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Dockerfile中</span></span><br><span class="line"><span class="string">ENV</span> <span class="string">APOLLO_CONFIG_SERVICE_NAME="&#123;service-name&#125;.&#123;namespace&#125;.svc.cluster.local"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#k8s yaml container中</span></span><br><span class="line"><span class="attr">          env:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">APOLLO_CONFIG_SERVICE_NAME</span></span><br><span class="line"><span class="attr">              value:</span> <span class="string">&#123;service_name&#125;.&#123;namespace&#125;.svc.cluster.local</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动脚本</span></span><br><span class="line"><span class="comment">#scripts/startup-kubernetes.sh</span></span><br><span class="line"><span class="comment">#SERVER_URL="http://$&#123;APOLLO_ADMIN_SERVICE_NAME&#125;:$&#123;SERVER_PORT&#125;"</span></span><br><span class="line"><span class="string">SERVER_URL="http://&#123;service_name&#125;.&#123;namespace&#125;.svc.cluster.local:$&#123;SERVER_PORT&#125;"</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li>将数据库和注册地址写入<code>config/application-github.properties</code>配置文件</li></ul><p>官方是写入<code>Dockerfile</code>中作为环境变量，然后通过<code>entrypoint.sh</code>进行相应的替换。我直接将其写入此配置文件，并删除<code>entrypoint.sh</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.datasource.url</span> <span class="string">=</span> <span class="attr">jdbc:mysql://&#123;mysql-ip&#125;:&#123;mysql-port&#125;/&#123;mysql-db&#125;?characterEncoding=utf8</span></span><br><span class="line"><span class="string">spring.datasource.username</span> <span class="string">=</span> <span class="string">user</span></span><br><span class="line"><span class="string">spring.datasource.password</span> <span class="string">=</span> <span class="string">passwd</span></span><br><span class="line"><span class="string">eureka.service.url</span> <span class="string">=</span> <span class="attr">http://&#123;service-name&#125;.&#123;namespace&#125;.svc.cluster.local:8080/eureka/</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li>portal服务的默认环境是DEV，请注意</li></ul><p>如果配置的第一个环境并不是DEV，请记得先修改数据库中的这个值，不然portal读取config, admin会失败。<br><code>portaldb.serverconfig</code>的<code>apollo.portal.envs</code>这个key，多个环境使用<code>,</code>分割，后面可以在UI上配置。其它环境请修改为其它环境名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> serverconfig <span class="keyword">SET</span> <span class="keyword">Value</span>=<span class="string">'uat'</span> <span class="keyword">WHERE</span> <span class="keyword">Key</span>=<span class="string">'apollo.portal.envs'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">config/apollo-env.properties</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#dev.meta=http://DEV_META_SERVICE_NAME:8080</span></span><br><span class="line"><span class="comment">#fat.meta=http://TEST_ALPHA_META_SERVICE_NAME:8080</span></span><br><span class="line"><span class="comment">#uat.meta=http://TEST_BETA_META_SERVICE_NAME:8080</span></span><br><span class="line"><span class="comment">#pro.meta=http://PROD_META_SERVICE_NAME:8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#某个环境的config</span></span><br><span class="line"><span class="string">uat.meta=http://&#123;service-name&#125;.&#123;namespace&#125;.svc.cluster.local:8080</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li>将日志输出到标准输出<code>/dev/stdout</code></li></ul><p>由于我是运行在容器中，所以需要将日志输出到标准输出。</p><p><br></p><ul><li>登录Web UI后可修改配置</li></ul><p>如组织里面的部门名，管理员等等参数，在系统参数里面更新<code>Key</code>对应的<code>Value</code>。<br>具体这个Key可参考文档 —— <a href="https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97#213-%E8%B0%83%E6%95%B4%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">调整服务端配置</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apollo官方文档: &lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ctripcorp/apollo/wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apollo v1.2&lt;/li&gt;
&lt;li&gt;Docker v1.18&lt;/li&gt;
&lt;li&gt;K8s v1.11&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Apollo" scheme="https://zhang21.github.io/tags/Apollo/"/>
    
      <category term="分布式" scheme="https://zhang21.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="配置中心" scheme="https://zhang21.github.io/tags/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>税收与债务</title>
    <link href="https://zhang21.github.io/2019/01/01/%E6%94%BF%E5%BA%9C%E6%94%B6%E5%85%A5%E4%B8%8E%E5%80%BA%E5%8A%A1/"/>
    <id>https://zhang21.github.io/2019/01/01/政府收入与债务/</id>
    <published>2019-01-01T05:09:38.000Z</published>
    <updated>2019-01-01T06:45:39.769Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li><a href="http://www.mof.gov.cn/zhuantihuigu/zhongguocaizhengjibenqingkuang/caizhengshouru/200905/t20090505_139500.html" target="_blank" rel="noopener">财政部</a></li><li><a href="http://www.stats.gov.cn/tjsj/zbjs/201310/t20131029_449523.html" target="_blank" rel="noopener">国家统计局</a></li></ul><p><br></p><a id="more"></a><hr><p><br><br><br></p><p>最近观《雍正王朝》、《李卫当官》，对政府收入和政务债务想做一个了解，故此收集整理相关资料。</p><p><br><br><br></p><h1 id="财政"><a href="#财政" class="headerlink" title="财政"></a>财政</h1><ul><li>财政收入<ul><li>中央政府财政收入</li><li>地方政府财政收入</li></ul></li><li>财政支出<ul><li>中央政府财政支出</li><li>地方政府财政支出</li></ul></li><li>外债<ul><li>外债负载率</li><li>外债债务率</li><li>外债偿债率</li></ul></li></ul><p><br></p><h2 id="财政收入"><a href="#财政收入" class="headerlink" title="财政收入"></a>财政收入</h2><p>指国家财政参与社会产品分配所取得的收入，是实现国家职能的财力保证。<br>主要包括：</p><ul><li>税收收入： 下设增值税等21款。包括国内增值税、国内消费税、进口货物增值税和消费税、出口货物退增值税和消费税、营业税、企业所得税、个人所得税、资源税、城市维护建设税、房产税、印花税、城镇土地使用税、土地增值税、车船税、船舶吨税、车辆购置税、关税、耕地占用税、契税、烟叶税等。</li><li>社会保险基金收入： 下设基本养老保险基金收入等6款。</li><li>非税收入：下设政府性基金收入等7款。包括专项收入、行政事业性收费、罚没收入和其他收入。</li><li>贷款转贷回收本金收入： 下设国内贷款回收本金收入等4款。</li><li>债务收入： 分设国内债务收入、国外债务收入2款。</li><li>转移性收入： 分设返还性收入等10款。</li><li>国资收入</li></ul><p>财政收入按现行分税制财政体制划分为中央本级收入和地方本级收入。</p><p><br></p><h3 id="中央财政收入"><a href="#中央财政收入" class="headerlink" title="中央财政收入"></a>中央财政收入</h3><p>属于中央财政的收入包括关税，进口货物增值税和消费税，出口货物退增值税和消费税，消费税，铁道部门、各银行总行、各保险公司总公司等集中交纳的营业税和城市维护建设税，增值税75%部分，纳入共享范围的企业所得税60%部分，未纳入共享范围的中央企业所得税、中央企业上交的利润，个人所得税60%部分，车辆购置税，船舶吨税，证券交易印花税97%部分，海洋石油资源税，中央非税收入等。</p><p><br><br><br></p><h3 id="地方财政收入"><a href="#地方财政收入" class="headerlink" title="地方财政收入"></a>地方财政收入</h3><p>属于地方财政的收入包括营业税（不含铁道部门、各银行总行、各保险公司总公司集中交纳的营业税），地方企业上交利润，城市维护建设税（不含铁道部门、各银行总行、各保险公司总公司集中交纳的部分），房产税，城镇土地使用税，土地增值税，车船税，耕地占用税，契税，烟叶税，印花税，增值税25%部分，纳入共享范围的企业所得税40%部分，个人所得税40%部分，证券交易印花税3%部分，海洋石油资源税以外的其他资源税，地方非税收入等。</p><p><br><br><br><br><br></p><h2 id="财政支出"><a href="#财政支出" class="headerlink" title="财政支出"></a>财政支出</h2><p>指国家财政将筹集起来的资金进行分配使用，以满足经济建设和各项事业的需要。</p><p>主要包括：一般公共服务、外交、国防、公共安全、教育、科学技术、文化体育与传媒、社会保障和就业、医疗卫生、环境保护、城乡社区事务、农林水事务、交通运输、资源勘探电力信息等事务、商业服务等事务、金融监管支出、国土气象等事务、住房保障支出、粮油物资储备管理等事务、国债付息支出等方面的支出。</p><p>财政支出根据政府在经济和社会活动中的不同职权，划分为中央财政支出和地方财政支出。</p><p><br></p><h3 id="中央财政支出"><a href="#中央财政支出" class="headerlink" title="中央财政支出"></a>中央财政支出</h3><p>中央财政支出包括一般公共服务，外交支出，国防支出，公共安全支出，以及中央政府调整国民经济结构、协调地区发展、实施宏观调控的支出等。</p><p><br><br><br></p><h3 id="地方财政支出"><a href="#地方财政支出" class="headerlink" title="地方财政支出"></a>地方财政支出</h3><p>地方财政支出包括一般公共服务，公共安全支出，地方统筹的各项社会事业支出等。</p><p><br><br><br><br><br></p><h2 id="外债"><a href="#外债" class="headerlink" title="外债"></a>外债</h2><p>外债（或对外债务）（英语：external debt或foreign debt）是一个国家所拥有的、债权人为外国的债务。债务人可以是政府、企业或私人。债权人可以是私人商业银行、其他政府或国际金融机构。</p><p><br></p><h3 id="外债负债率"><a href="#外债负债率" class="headerlink" title="外债负债率"></a>外债负债率</h3><p>指外债余额与当年国内生产总值之比。</p><p><br><br><br></p><h3 id="外债债务率"><a href="#外债债务率" class="headerlink" title="外债债务率"></a>外债债务率</h3><p>指外债余额</p><p><br><br><br></p><h3 id="外债偿债率"><a href="#外债偿债率" class="headerlink" title="外债偿债率"></a>外债偿债率</h3><p>指偿还外债本息与当年贸易和非贸易外汇收入（国际收支口径）之比。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="债务"><a href="#债务" class="headerlink" title="债务"></a>债务</h1><p>政府债务（亦称公债）是指政府在国内外发行的债券或向外国政府和银行借款所形成的政府债务。具体是指政府凭借其信誉，政府作为债务人与债权人之间按照有偿原则发生信用关系来筹集财政资金的一种信用方式，也是政府调度社会资金，弥补财政赤字，并借以调控经济运行的一种特殊分配方式。政府债务是整个社会债务的重要组成部分。</p><p>政府债务（Government debt）分为中央政府债务和地方政府债务。中央政府债务即国债，是中央政府为筹集财政资金而举借的一种债务。除中央政府举债之外，不少国家有财政收入的地方政府及地方公共机构也举借债务，即地方政府债务。由于中国地方政府尚不能举债，因此中国的政府债务即为国债。</p><p><br></p><p>按偿还期限划分： 可分为短期、中期和长期公债。<br>按发行地域划分： 可分为内债和外债。<br>按发行的方式： 可分为强制公债和自愿公债。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mof.gov.cn/zhuantihuigu/zhongguocaizhengjibenqingkuang/caizhengshouru/200905/t20090505_139500.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;财政部&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.stats.gov.cn/tjsj/zbjs/201310/t20131029_449523.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;国家统计局&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Economics" scheme="https://zhang21.github.io/categories/Economics/"/>
    
    
      <category term="经济" scheme="https://zhang21.github.io/tags/%E7%BB%8F%E6%B5%8E/"/>
    
      <category term="财政" scheme="https://zhang21.github.io/tags/%E8%B4%A2%E6%94%BF/"/>
    
      <category term="税收" scheme="https://zhang21.github.io/tags/%E7%A8%8E%E6%94%B6/"/>
    
      <category term="债务" scheme="https://zhang21.github.io/tags/%E5%80%BA%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Helm</title>
    <link href="https://zhang21.github.io/2018/12/25/Helm/"/>
    <id>https://zhang21.github.io/2018/12/25/Helm/</id>
    <published>2018-12-25T01:11:22.000Z</published>
    <updated>2018-12-25T01:23:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>环境：</p><ul><li>EL7x86_64</li></ul><p>参考：</p><ul><li>HELM文档: <a href="https://docs.helm.sh/" target="_blank" rel="noopener">https://docs.helm.sh/</a></li></ul><p><br><br><br></p><a id="more"></a><hr><p><br><br><br></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>Helm</strong>是Kubernetes生态系统中的一个软件包管理工具，主要用来管理<strong>Charts</strong>，有点类似于Ubuntu中的<code>apt</code>或CentOS中的<code>yum</code>。由go编写，是Deis公司发起的一个开源工具，有助于简化部署和管理Kubernetes应用。<br>在Kubernetes中，应用管理是需求最多、挑战最大的领域。Helm项目提供了一个统一软件打包方式，支持版本控制，可以大大简化Kubernetes应用分发与部署中的复杂性。</p><p>Helm Chart是用来封装 Kubernetes 原生应用程序的一系列 YAML 文件。可以在你部署应用的时候自定义应用程序的一些 Metadata，以便于应用程序的分发。<br>对于应用发布者而言，可以通过 Helm 打包应用、管理应用依赖关系、管理应用版本并发布应用到软件仓库。<br>对于使用者而言，使用 Helm 后不用需要编写复杂的应用部署文件，可以以简单的方式在 Kubernetes 上查找、安装、升级、回滚、卸载应用程序。</p><p><br></p><p><img src="/images/Helm/Helm_Logo.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EL7x86_64&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HELM文档: &lt;a href=&quot;https://docs.helm.sh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.helm.sh/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Helm" scheme="https://zhang21.github.io/tags/Helm/"/>
    
      <category term="K8s" scheme="https://zhang21.github.io/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>存储方案</title>
    <link href="https://zhang21.github.io/2018/12/10/%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/"/>
    <id>https://zhang21.github.io/2018/12/10/存储方案/</id>
    <published>2018-12-10T07:11:12.000Z</published>
    <updated>2018-12-10T06:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>维基百科</li><li>Google</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br><br><br></p><p>存储方案分类：</p><ul><li>DAS(Direct-Attached Storage)，直连式存储</li><li>NAS(Network Attached Storage)，网络附加存储</li><li>SAN(Storage Area Network)，存储区域网络</li></ul><p>NAS和SAN既竞争又合作，很多高端NAS的后端存储就是SAN。NAS和SAN的整合也是存储设备的发展趋势。SAN提供的存储单位是LUN，属于block级别的。经过NAS创建成文件系统后，就变成文件级别的了。</p><p><br></p><p><img src="/images/Storage/Das_Nas_San.png" alt=""></p><p><br></p><p>NAS和SAN最本质的区别就是文件管理系统在哪里。</p><p><img src="/images/Storage/Das_Nas_San.jpg" alt=""></p><p><br><br><br></p><h1 id="DAS"><a href="#DAS" class="headerlink" title="DAS"></a>DAS</h1><p><strong>直连式存储</strong>是指直接和计算机相连接的数据储存方式。<br>像固态硬盘、机械硬盘、光盘驱动器与计算机直接相连的设备都是属于直连式存储设备。实际上，直连式存储的名称是后来为了区别于存储区域网络（SAN）和网络附加储存（NAS）而添加的。</p><p><br></p><p>缺点：</p><ul><li>服务器本身容易成为系统瓶颈;</li><li>服务器发生故障，数据不可访问;</li><li>对于存在多个服务器的系统来说，设备分散，不便管理。同时多台服务器使用DAS时，存储空间不能在服务器之间动态分配，可能造成相当的资源浪费;</li><li>数据备份操作复杂。</li></ul><p><br><br><br></p><h1 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h1><p><strong>网络附加存储</strong>是一种专门的数据存储技术的名称，它可以直接连接在计算机网络上面，对异质网络用户提供了集中式数据访问服务。实际上就是网络文件服务器。<br>NAS设备也提供了不止一种文件传输协议。NAS系统通常有一个以上的硬盘，而且和传统的文件服务器一样，通常会把它们组成RAID来提供服务。<br>NAS设备直接连接到TCP/IP网络上，网络服务器通过TCP/IP网络存取管理数据。有了NAS以后，网络上的其他服务器就可以不必再兼任文件服务器的功能。</p><p>NAS是以文件为单位的通信协议，例如像是NFS（在UNIX系统上很常见）或是SMB（常用于Windows系统）。</p><p><br></p><p>缺点：</p><ul><li>由于存储数据通过普通数据网络传输，因此易受网络上其它流量的影响。当网络上有其它大数据流量时会严重影响系统性能;</li><li>由于存储数据通过普通数据网络传输，因此容易产生数据泄漏等安全问题;</li><li>存储只能以文件方式访问，而不能像普通文件系统一样直接访问物理数据块，因此会在某些情况下严重影响系统效率，比如大型数据库就不能使用NAS.</li></ul><p><br><br><br></p><h1 id="SAN"><a href="#SAN" class="headerlink" title="SAN"></a>SAN</h1><p><strong>存储区域网络</strong>是一种连接外接存储设备和服务器的架构。人们采用包括光纤通道技术(FC)、磁盘阵列(RAID)、磁带柜、光盘柜的各种技术进行实现。<br>该架构的特点是，连接到服务器的存储设备，将被操作系统视为直接连接的存储设备。<br>SAN实际是一种专门为存储建立的独立于TCP/IP网络之外的专用网络。<br>SAN由于其基础是一个专用网络，因此扩展性很强，不管是在一个SAN系统中增加一定的存储空间还是增加几台使用存储空间的服务器都非常方便。</p><p>SAN是以区块为单位的通信协议，通常是透过SCSI再转为光纤通道或是iSCSI。还有其他各种不同的SAN通信协议。</p><p><br></p><p>缺点：</p><ul><li>价格昂贵。不论是SAN阵列柜还是SAN必须的光纤通道交换机价格都是十分昂贵的，就连服务器上使用的光通道卡的价格也是不容易被小型商业企业所接受的;</li><li>需要单独建立光纤网络，异地扩展比较困难。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维基百科&lt;/li&gt;
&lt;li&gt;Google&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="数据" scheme="https://zhang21.github.io/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="存储" scheme="https://zhang21.github.io/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>云计算</title>
    <link href="https://zhang21.github.io/2018/12/07/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    <id>https://zhang21.github.io/2018/12/07/云计算/</id>
    <published>2018-12-07T09:11:12.000Z</published>
    <updated>2018-12-07T09:49:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>维基百科</li></ul><p><br><br><br></p><a id="more"></a><p><br><br><br></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>云计算（cloud computing），是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机各种终端和其他设备。</p><p>用户不再需要了解“云”中基础设施的细节，不必具有相应的专业知识，也无需直接进行控制云计算描述了一种基于互联网的新的IT服务增加、使用和交付模式，通常涉及通过互联网来提供动态易扩展而且经常是虚拟化的资源。</p><p><img src="/images/CC/Cloud_computing.svg.png" alt="云计算"></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h1><p>美国国家标准和技术研究院的云计算定义中明确了三种服务模式：</p><ul><li><p><strong>基础环境即服务(IaaS, Infrastructure as a Service)</strong><br>消费者使用“基础计算资源”，如处理能力、存储空间、网络组件或中间件。消费者能掌控操作系统、存储空间、已部署的应用程序及网络组件（如防火墙、负载平衡器等），但并不掌控云基础架构。例如：Amazon AWS、Rackspace。</p></li><li><p><strong>平台即服务(PaaS, Platform as a Service)</strong><br>消费者使用主机操作应用程序。消费者掌控运作应用程序的环境（也拥有主机部分掌控权），但并不掌控操作系统、硬件或运作的网络基础架构。平台通常是应用程序基础架构。例如：Google App Engine。</p></li><li><p><strong>软件即服务(SaaS, Software as a Service)</strong><br>消费者使用应用程序，但并不掌控操作系统、硬件或运作的网络基础架构。是一种服务观念的基础，软件服务供应商，以租赁的概念提供客户服务，而非购买，比较常见的模式是提供一组账号密码。例如：Microsoft CRM与Salesforce.com。</p></li></ul><p><img src="/images/CC/CC_IPS.png" alt=""></p><p><img src="/images/CC/CC_IPS01.png" alt=""></p><p><img src="/images/CC/CC_IPS02.jpg" alt=""></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h1><p>美国国家标准和技术研究院的云计算定义中也涉及了关于云计算的部署模型:</p><ul><li><p>公有云（Public Cloud）<br>简而言之，公用云服务可透过网络及第三方服务供应者，开放给客户使用，“公用”一词并不一定代表“免费”，但也可能代表免费或相当廉价，公用云并不表示用户数据可供任何人查看，公用云供应者通常会对用户实施使用访问控制机制，公用云作为解决方案，既有弹性，又具备成本效益。</p></li><li><p>私有云（Private Cloud）<br>私有云具备许多公用云环境的优点，例如弹性、适合提供服务，两者差别在于私有云服务中，数据与程序皆在组织内管理，且与公用云服务不同，不会受到网络带宽、安全疑虑、法规限制影响；此外，私有云服务让供应者及用户更能掌控云基础架构、改善安全与弹性，因为用户与网络都受到特殊限制。</p></li><li><p>社群云（Community Cloud）<br>社群云由众多利益相仿的组织掌控及使用，例如特定安全要求、共同宗旨等。社群成员共同使用云数据及应用程序。</p></li><li><p>混合云（Hybrid Cloud）<br>混合云结合公用云及私有云，这个模式中，用户通常将非企业关键信息外包，并在公用云上处理，但同时掌控企业关键服务及数据。</p></li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="云技术"><a href="#云技术" class="headerlink" title="云技术"></a>云技术</h1><ul><li>KVM</li><li>XEN</li><li>VMWare</li><li>OpenStack(IaaS, 私有云)</li><li>OpenShift(Paas)</li><li>Docker</li><li>Kubernetes</li><li>Ansible</li><li>Chef</li><li>Puppet</li><li>Salt</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维基百科&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="云计算" scheme="https://zhang21.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="云服务" scheme="https://zhang21.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>GitLab</title>
    <link href="https://zhang21.github.io/2018/12/06/GitLab/"/>
    <id>https://zhang21.github.io/2018/12/06/GitLab/</id>
    <published>2018-12-06T05:11:22.000Z</published>
    <updated>2019-02-01T06:19:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>维基百科</li><li>GitLab文档: <a href="https://docs.gitlab.com/" target="_blank" rel="noopener">https://docs.gitlab.com/</a></li></ul><p><br></p><p>版本:</p><ul><li>GitLib-CE: <code>v11.6.0</code></li><li>GitLab-Runner: <code>v11.6.0</code></li></ul><p><br><br><br></p><a id="more"></a><hr><p><br><br><br></p><p>GitLab是由GitLab Inc.开发，使用MIT许可证的基于网络的Git仓库管理工具。包括Git仓库管理、代码审查、问题跟踪、动态订阅、wiki等功能.以及GitLab内部集成的GitLab CI 更是一个持续集成和交付的好工具。</p><p>它有两个版本：</p><ul><li>CE</li><li>EE</li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="User"><a href="#User" class="headerlink" title="User"></a>User</h1><p>User docs</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h1><p>Administrator documentation</p><p><br></p><h2 id="安装和维护"><a href="#安装和维护" class="headerlink" title="安装和维护"></a>安装和维护</h2><p>Installing and maintaining GitLab</p><p><br></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Installation</p><p>GitLab有多种方式进行安装。</p><p><br></p><p><strong>依赖(requirements)</strong></p><p>在安装之前，请先查看相关依赖文档。</p><p>依赖: <a href="https://docs.gitlab.com/ce/install/requirements.html" target="_blank" rel="noopener">https://docs.gitlab.com/ce/install/requirements.html</a></p><ul><li><p>操作系统</p></li><li><p>Ruby版本</p></li><li><p>硬件</p><ul><li>CPU</li><li>Memory</li><li>Storage</li></ul></li><li><p>数据库</p></li><li><p>Unicorn Workers<br>Unicorn是多进程的Server容器。<br>可以增加unicorn worker的数量，这通常有助于减少应用程序的响应时间并提高处理并行请求的能力。<br>对于大多数情况，我们建议使用:<code>CPU cores + 1 = unicorn workers</code></p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#CPU Cores=2</span></span><br><span class="line">unicorn[<span class="string">'worker_processes'</span>] = 3</span><br><span class="line">unicorn[<span class="string">'worker_timeout'</span>] = 60</span><br></pre></td></tr></table></figure><ul><li><p>Redis and Sidekiq<br>Redis存储所有用户会话和后台任务队列。Redis的存储要求很低，每个用户约25kB。<br>Sidekiq是多线程的异步处理程序，使用多线程进程处理后台作业。 此过程从整个Rails Stack(<code>200MB+</code>)开始，如果存在内存泄漏，它可能会随着时间的推移而增长。 在非常活跃的服务器上（10,000+活动用户），Sidekiq进程可能使用<code>1GB +</code>内存。</p></li><li><p>GitLab Runner<br>我们强烈不要在计划安装GitLab的同一台机器上安装GitLab Runner。根据您决定配置GitLab Runner的方式以及用于在CI环境中运行应用程序的工具，GitLab Runner可能会占用大量可用内存。<br>如果您决定在同一台机器上运行GitLab Runner和GitLab Rails应用程序，则上面提供的内存消耗计算将无效。<br>由于安全原因，将所有内容安装在一台计算机上也是不安全的——特别是当您计划将shell执行程序与GitLab Runner一起使用时。<br>如果您打算使用CI功能，我们建议为每个GitLab Runner使用单独的计算机。</p></li></ul><ul><li><p>Prometheus and its exporters<br>从Omnibus GitLab 9.0开始，Prometheus及其相关的exporter默认启用，一遍轻松、深入地监控GitLab。这些进程大概消耗200MB内存。</p></li><li><p>支持的浏览器</p></li></ul><p><br></p><p><strong>安装方式(Installation methods)</strong></p><ul><li>Omnibus包: <a href="https://about.gitlab.com/install/" target="_blank" rel="noopener">https://about.gitlab.com/install/</a></li><li>源码</li><li>Docker</li></ul><p><br></p><p><strong>数据库(Database)</strong></p><ul><li>PostgreSQL (highly recommended)</li><li>MySQL/MariaDB (strongly discouraged, not all GitLab features are supported, no support for MySQL/MariaDB GTID)</li></ul><p>As of GitLab 10.0, PostgreSQL 9.6 or newer is required, and earlier versions are not supported.</p><p>Users using PostgreSQL must ensure the <code>pg_trgm</code> extension is loaded into every GitLab database. This extension can be enabled (using a PostgreSQL super user) by running the following query for every database:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION pg_trgm;</span><br></pre></td></tr></table></figure><p>在其它系统上，你可能需要安装附加包(e.g. postgresql-contrib)才能使得扩展可用。</p><p>如果你需要使用<strong>GitLab Geo</strong>，则需要<code>postgres_fdw</code>扩展：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION postgres_fdw;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="包安装"><a href="#包安装" class="headerlink" title="包安装"></a>包安装</h4><p><strong>Centos7为栗子</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装依赖Ruby</span></span><br><span class="line"><span class="comment">#因为需要v2.3版本，而yum查找出来的为v2.0，所以不使用yum安装</span></span><br><span class="line"><span class="comment">#yum info ruby.x86_64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里使用Ruby管理工具RVM（“Ruby Version Manager”）进行安装</span></span><br><span class="line">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#开发版</span></span><br><span class="line">\curl -sSL https://get.rvm.io | bash</span><br><span class="line"><span class="comment">#安装稳定版</span></span><br><span class="line">\curl -sSL https://get.rvm.io | bash -s stable --ruby</span><br><span class="line"></span><br><span class="line"><span class="comment">#To start using RVM you need to run source ~/.rvm/scripts/rvm</span></span><br><span class="line"><span class="built_in">source</span> ~/.rvm/scripts/rvm</span><br><span class="line"><span class="comment">#可把它写入profile</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="built_in">source</span> ~/.rvm/scripts/rvm</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">rvm list known</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装ruby2.3</span></span><br><span class="line">rvm install 2.3</span><br><span class="line">ruby --version</span><br><span class="line">ruby 2.3.7p456 (2018-03-28 revision 63024) [x86_64-linux]</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用2.3</span></span><br><span class="line">rvm use 2.3</span><br><span class="line"></span><br><span class="line"><span class="comment">#设为默认</span></span><br><span class="line">rvm use 2.3 --default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Install and configure the necessary dependencies</span></span><br><span class="line">sudo yum install -y curl policycoreutils-python openssh-server</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> sshd</span><br><span class="line">sudo systemctl start sshd</span><br><span class="line"></span><br><span class="line">sudo firewall-cmd --permanent --add-service=http</span><br><span class="line">sudo systemctl reload firewalld</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#install Postfix to send notification emails</span></span><br><span class="line">sudo yum install postfix</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> postfix</span><br><span class="line">sudo systemctl start postfix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Add the GitLab package repository and install the package</span></span><br><span class="line">curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash</span><br><span class="line">sudo EXTERNAL_URL=<span class="string">"http://gitlab.example.com"</span> yum install -y gitlab-ce</span><br><span class="line"><span class="comment">#镜像如无法下载，可使用国内清华，阿里镜像</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重配置GitLab</span></span><br><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line"><span class="comment">#这里GitLab会安装许多软件，如Nginx，Prometheus，Redis...</span></span><br><span class="line"><span class="comment">#首次启动会有很多信息，请稍等</span></span><br><span class="line"><span class="comment">#首次访问GitLab,系统会让你重新设置管理员的密码,设置成功后会返回登录界面.默认的管理员账号是root</span></span><br><span class="line"><span class="comment">#在Web界面修改密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Browse to the hostname and login</span></span><br><span class="line"><span class="comment">#浏览器访问前面定义的URL</span></span><br><span class="line"><span class="comment">##在Web界面修改密码，并登陆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Set up your communication preferences</span></span><br></pre></td></tr></table></figure><p><img src="/images/GitLab/GitLab_login.jpg" alt="GitLab"></p><p><br><br><br></p><h4 id="配置域名或URL"><a href="#配置域名或URL" class="headerlink" title="配置域名或URL"></a>配置域名或URL</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Configuring the external URL for GitLab</span></span><br><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line">external_url <span class="string">"http://gitlab.example.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重载配置</span></span><br><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Configuring a relative URL for Gitlab</span></span><br><span class="line"><span class="comment">#从v8.17以后便不需要再重新编译</span></span><br><span class="line"><span class="comment">#要求：4GB RAM, and 4 or 8 CPU cores</span></span><br><span class="line"><span class="comment">#栗子: https://example.com/gitlab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Enable relative URL in GitLab</span></span><br><span class="line"><span class="comment">#如果资源不够，可临时关闭 Unicorn and Sidekiq以节省资源</span></span><br><span class="line">sudo gitlab-ctl stop unicorn</span><br><span class="line">sudo gitlab-ctl stop sidekiq</span><br><span class="line"></span><br><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line">external_url <span class="string">"https://example.com/gitlab"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重载配置</span></span><br><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新启动服务，以便Unicorn和Sidekiq获取更改</span></span><br><span class="line">sudo gitlab-ctl restart</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Disable relative URL in GitLab</span></span><br><span class="line">external_url后面不包含相对路劲即可</span><br><span class="line"><span class="comment">#之后重载配置</span></span><br><span class="line">sudo gitlab-ctl restart unicorn</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="从non-root用户载入配置"><a href="#从non-root用户载入配置" class="headerlink" title="从non-root用户载入配置"></a>从non-root用户载入配置</h4><p>Loading external configuration file from non-root user</p><p>Omnibus-gitlab package 从 <code>/etc/gitlab/gitlab.rb file</code>载入所有配置。它属于root用户，有严格的权限配置。它通过root用户由ruby代码执行<code>gitlab-ctl reconfigure</code>。</p><p>指定其它配置:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">from_file <span class="string">"/home/admin/external_gitlab.rb"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="将Git数据存储在备用目录中"><a href="#将Git数据存储在备用目录中" class="headerlink" title="将Git数据存储在备用目录中"></a>将Git数据存储在备用目录中</h4><p>Storing Git data in an alternative directory</p><p>默认情况下，<code>omnibus-gitlab</code>将repository数据存放于<code>/var/opt/gitlab/git-data</code>目录下。repository存储在此目录下的repositories子目录中。<br>可在<code>/etc/gitlab/gitlab.rb</code>中修改<code>git-data</code>来添加备用数据目录。<br>请注意，目录和子目录的路径必须不是链接。</p><p>如果还运行了Gitaly，请为每个git数据目录包含<code>gitaly_address</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">git_data_dirs(&#123; <span class="string">"default"</span> =&gt; &#123; <span class="string">"path"</span> =&gt; <span class="string">"/mnt/nas/git-data"</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#你可以添加不止一个数据目录</span></span><br><span class="line">git_data_dirs(&#123;</span><br><span class="line">  <span class="string">"default"</span> =&gt; &#123; <span class="string">"path"</span> =&gt; <span class="string">"/var/opt/gitlab/git-data"</span> &#125;,</span><br><span class="line">  <span class="string">"alternative"</span> =&gt; &#123; <span class="string">"path"</span> =&gt; <span class="string">"/mnt/nas/git-data"</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重载配置，使得更改生效</span></span><br><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">sudo ls /var/opt/gitlab/git-data</span><br><span class="line">repositories</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果你的/var/opt/gitlab/git-data已有Git repositories，则</span></span><br><span class="line"><span class="comment"># Prevent users from writing to the repositories while you move them.</span></span><br><span class="line">sudo gitlab-ctl stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># Note there is _no_ slash behind 'repositories', but there _is_ a</span></span><br><span class="line"><span class="comment"># slash behind 'git-data'.</span></span><br><span class="line">sudo rsync -av /var/opt/gitlab/git-data/repositories /mnt/nas/git-data/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start the necessary processes and run reconfigure to fix permissions</span></span><br><span class="line"><span class="comment"># if necessary</span></span><br><span class="line">sudo gitlab-ctl upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># Double-check directory layout in /mnt/nas/git-data. Expected output:</span></span><br><span class="line"><span class="comment"># repositories</span></span><br><span class="line">sudo ls /mnt/nas/git-data/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Done! Start GitLab and verify that you can browse through the repositories in</span></span><br><span class="line"><span class="comment"># the web interface.</span></span><br><span class="line">sudo gitlab-ctl start</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>####　修改Git用户/组</p><p>Changing the name of the Git user / group</p><p>默认情况下，<code>omnibus-gitLab</code>使用<code>git</code>用户登录<code>gitlab-shell</code>和远程Web接口。不推荐改变已安装的User/Group。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"><span class="comment">#用户名/组名</span></span><br><span class="line">user[<span class="string">'username'</span>] = <span class="string">"git"</span></span><br><span class="line">user[<span class="string">'group'</span>] = <span class="string">"git"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##! The shell for the git user</span></span><br><span class="line"><span class="comment"># user['shell'] = "/bin/sh"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##! The home directory for the git user</span></span><br><span class="line"><span class="comment"># user['home'] = "/var/opt/gitlab"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#uid/gid</span></span><br><span class="line"><span class="comment">#omnibus-gitlab creates users for GitLab, PostgreSQL, Redis and NGINX.你可以指定他们的ID</span></span><br><span class="line">user[<span class="string">'uid'</span>] = 1234</span><br><span class="line">user[<span class="string">'gid'</span>] = 1234</span><br><span class="line">postgresql[<span class="string">'uid'</span>] = 1235</span><br><span class="line">postgresql[<span class="string">'gid'</span>] = 1235</span><br><span class="line">redis[<span class="string">'uid'</span>] = 1236</span><br><span class="line">redis[<span class="string">'gid'</span>] = 1236</span><br><span class="line">web_server[<span class="string">'uid'</span>] = 1237</span><br><span class="line">web_server[<span class="string">'gid'</span>] = 1237</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="禁用用户和组的账号管理"><a href="#禁用用户和组的账号管理" class="headerlink" title="禁用用户和组的账号管理"></a>禁用用户和组的账号管理</h4><p>Disable user and group account management</p><p>默认情况下，omnibus-gitlab会创建系统用户/组账户，这些系统账户运行包的各种组件。大多数用户都不需要去改变这些行为。然而，如果你的系统账户由其它软件管理，你或许需要禁用此功能。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">manage_accounts[<span class="string">'enable'</span>] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#omnibus-gitlab依然保留之前创建的账户</span></span><br><span class="line"><span class="comment">#默认创建以下用户</span></span><br><span class="line"><span class="comment"># GitLab user (required)</span></span><br><span class="line">git</span><br><span class="line"></span><br><span class="line"><span class="comment"># Web server user (required)</span></span><br><span class="line">gitlab-www</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis user for GitLab (only when using packaged Redis)</span></span><br><span class="line">gitlab-redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># Postgresql user (only when using packaged Postgresql)</span></span><br><span class="line">gitlab-psql</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prometheus user for prometheus monitoring and various exporters</span></span><br><span class="line">gitlab-prometheus</span><br><span class="line"></span><br><span class="line"><span class="comment"># GitLab Mattermost user (only when using GitLab Mattermost)</span></span><br><span class="line">mattermost</span><br><span class="line"></span><br><span class="line"><span class="comment"># GitLab Registry user (only when using GitLab Registry)</span></span><br><span class="line">registry</span><br><span class="line"></span><br><span class="line"><span class="comment"># GitLab Consul user (only when using GitLab Consul)</span></span><br><span class="line">gitlab-consul</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看用户</span></span><br><span class="line">sudo awk -F<span class="string">':'</span> <span class="string">'&#123;print $1&#125;'</span> /etc/passwd</span><br></pre></td></tr></table></figure><p><br></p><p>你也可以在GitLab配置文件里面更改:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do not manage user/group accounts</span></span><br><span class="line">manage_accounts[<span class="string">'enable'</span>] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GitLab</span></span><br><span class="line">user[<span class="string">'username'</span>] = <span class="string">"custom-gitlab"</span></span><br><span class="line">user[<span class="string">'group'</span>] = <span class="string">"custom-gitlab"</span></span><br><span class="line">user[<span class="string">'shell'</span>] = <span class="string">"/bin/sh"</span></span><br><span class="line">user[<span class="string">'home'</span>] = <span class="string">"/var/opt/custom-gitlab"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Web server</span></span><br><span class="line">web_server[<span class="string">'username'</span>] = <span class="string">'webserver-gitlab'</span></span><br><span class="line">web_server[<span class="string">'group'</span>] = <span class="string">'webserver-gitlab'</span></span><br><span class="line">web_server[<span class="string">'shell'</span>] = <span class="string">'/bin/false'</span></span><br><span class="line">web_server[<span class="string">'home'</span>] = <span class="string">'/var/opt/gitlab/webserver'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Postgresql (not needed when using external Postgresql)</span></span><br><span class="line">postgresql[<span class="string">'username'</span>] = <span class="string">"postgres-gitlab"</span></span><br><span class="line">postgresql[<span class="string">'group'</span>] = <span class="string">"postgres-gitlab"</span></span><br><span class="line">postgresql[<span class="string">'shell'</span>] = <span class="string">"/bin/sh"</span></span><br><span class="line">postgresql[<span class="string">'home'</span>] = <span class="string">"/var/opt/postgres-gitlab"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis (not needed when using external Redis)</span></span><br><span class="line">redis[<span class="string">'username'</span>] = <span class="string">"redis-gitlab"</span></span><br><span class="line">redis[<span class="string">'group'</span>] = <span class="string">"redis-gitlab"</span></span><br><span class="line">redis[<span class="string">'shell'</span>] = <span class="string">"/bin/false"</span></span><br><span class="line">redis[<span class="string">'home'</span>] = <span class="string">"/var/opt/redis-gitlab"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># And so on for users/groups for GitLab Mattermost1</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="禁用存储目录管理"><a href="#禁用存储目录管理" class="headerlink" title="禁用存储目录管理"></a>禁用存储目录管理</h4><p>Disable storage directories management</p><p>omnibus-gitlab负责使用正确的所有权与权限创建所必须的目录，并保持更新。一种一些目录在配置时可能会包含大量数据，也可能会挂载到NFS。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果已挂在/etc/gitlab，则可关闭此目录的管理</span></span><br><span class="line">manage_storage_directories[<span class="string">'manage_etc'</span>] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果要挂载GitLab的所有存储目录，并且每个目录都是单独地挂载，则应完全禁用存储目录的管理</span></span><br><span class="line">manage_storage_directories[<span class="string">'enable'</span>] = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>GitLab所有数据目录：</strong></p><table><thead><tr><th>Default location</th><th>Permissions</th><th>Ownership</th><th>Purpose</th></tr></thead><tbody><tr><td>/var/opt/gitlab/git-data</td><td>0700</td><td>git:root</td><td>Holds repositories directory</td></tr><tr><td>/var/opt/gitlab/git-data/repositories</td><td>2770</td><td>git:git</td><td>Holds git repositories</td></tr><tr><td>/var/opt/gitlab/gitlab-rails/shared</td><td>0751</td><td>git:gitlab-www</td><td>Holds large object directories</td></tr><tr><td>/var/opt/gitlab/gitlab-rails/shared/artifacts</td><td>0700</td><td>git:root</td><td>Holds CI artifacts</td></tr><tr><td>/var/opt/gitlab/gitlab-rails/shared/lfs-objects</td><td>0700</td><td>git:root</td><td>Holds LFS objects</td></tr><tr><td>/var/opt/gitlab/gitlab-rails/uploads</td><td>0700</td><td>git:root</td><td>Holds user attachments</td></tr><tr><td>/var/opt/gitlab/gitlab-rails/shared/pages</td><td>0750</td><td>git:gitlab-www</td><td>Holds user pages</td></tr><tr><td>/var/opt/gitlab/gitlab-ci/builds</td><td>0700</td><td>git:root</td><td>Holds CI build logs</td></tr><tr><td>/var/opt/gitlab/.ssh</td><td>0700</td><td>git:git</td><td>Holds authorized keys</td></tr></tbody></table><p><br><br><br></p><h4 id="仅在挂载给定文件系统后启动Omnibus-GitLab服务"><a href="#仅在挂载给定文件系统后启动Omnibus-GitLab服务" class="headerlink" title="仅在挂载给定文件系统后启动Omnibus-GitLab服务"></a>仅在挂载给定文件系统后启动Omnibus-GitLab服务</h4><p>Only start Omnibus-GitLab services after a given filesystem is mounted</p><p>如果你想防止Omnibus-GitLab服务(Nginx，Redis，Unicorn…)在挂载给定文件系统之前启动，则:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># wait for /var/opt/gitlab to be mounted</span></span><br><span class="line">high_availability[<span class="string">'mountpoint'</span>] = <span class="string">'/var/opt/gitlab'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="配置运行时目录"><a href="#配置运行时目录" class="headerlink" title="配置运行时目录"></a>配置运行时目录</h4><p>Configuring runtime directory</p><p>启用Prometheus监控后，GitLab-monitor将对每个Unicorn进程(Rails metrics)进行监控。每个Unicorn进行都需要将度量文件(metrics file)写入每个控制器临时的位置，然后，Prometheus收集这些文件并处理他们的值。</p><p>为了避免创建磁盘I/O，Omnibus-GitLab包将会使用一个运行时目录。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#During reconfigure, package will check if `/run` is a `tmpfs` mount. If it is not, warning will be printed, and Rails metrics will be disabled.</span></span><br><span class="line">Runtime directory <span class="string">'/run'</span> is not a tmpfs mount.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#To enable Rails metrics again, create a tmpfs mount and specify it</span></span><br><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># runtime_dir '/run'</span></span><br><span class="line">runtime_dir <span class="string">'/path/to/tmpfs'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="在安装期间禁用自动缓存清理"><a href="#在安装期间禁用自动缓存清理" class="headerlink" title="在安装期间禁用自动缓存清理"></a>在安装期间禁用自动缓存清理</h4><p>Disabling automatic cache cleaning during installation</p><p>如果安装了大型的GitLab，则你可能不希望运行<code>rake cache:clean</code>，因为它将会耗费很长时间。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is advanced feature used by large gitlab deployments where loading</span></span><br><span class="line"><span class="comment"># whole RAILS env takes a lot of time.</span></span><br><span class="line">gitlab_rails[<span class="string">'rake_cache_clear'</span>] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Enabling/Disabling Rack Attack and setting up basic auth throttling</span></span><br><span class="line">gitlab_rails[<span class="string">'rack_attack_git_basic_auth'</span>] = &#123;</span><br><span class="line">  <span class="string">'enabled'</span> =&gt; <span class="literal">true</span>, <span class="comment"># Enable/Disable Rack Attack</span></span><br><span class="line">  <span class="string">'ip_whitelist'</span> =&gt; [<span class="string">"127.0.0.1"</span>], <span class="comment"># Whitelisted urls</span></span><br><span class="line">  <span class="string">'maxretry'</span> =&gt; 10, <span class="comment"># Limit the number of Git HTTP authentication attempts per IP</span></span><br><span class="line">  <span class="string">'findtime'</span> =&gt; 60, <span class="comment"># Reset the auth attempt counter per IP after 60 seconds</span></span><br><span class="line">  <span class="string">'bantime'</span> =&gt; 3600 <span class="comment"># Ban an IP for one hour (3600s) after too many auth attempts</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Setting up paths to be protected by Rack Attack</span></span><br><span class="line"><span class="comment">#如果你想改变默认保护路径</span></span><br><span class="line"><span class="comment">#警告：此动作将会被Omnibus-GitLab提供的列表所覆盖</span></span><br><span class="line">gitlab_rails[<span class="string">'rack_attack_protected_paths'</span>] = [</span><br><span class="line">  <span class="string">'/users/password'</span>,</span><br><span class="line">  <span class="string">'/users/sign_in'</span>,</span><br><span class="line">  <span class="string">'/api/#&#123;API::API.version&#125;/session.json'</span>,</span><br><span class="line">  <span class="string">'/api/#&#123;API::API.version&#125;/session'</span>,</span><br><span class="line">  <span class="string">'/users'</span>,</span><br><span class="line">  <span class="string">'/users/confirmation'</span>,</span><br><span class="line">  <span class="string">'/unsubscribes/'</span>,</span><br><span class="line">  <span class="string">'/import/github/personal_access_token'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Setting up throttling for ‘paths to be protected’</span></span><br><span class="line">gitlab_rails[<span class="string">'rate_limit_requests_per_period'</span>] = 10</span><br><span class="line">gitlab_rails[<span class="string">'rate_limit_period'</span>] = 60</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li>Nginx</li><li>HTTPS</li><li>Database</li><li>Redis</li><li>SMTP</li><li>…</li></ul><p>具体参考官方文档。</p><p><br><br><br><br><br></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>Update</p><p>更新方式取决你你使用的安装方法。</p><p><br></p><p><strong>不停机升级(Upgrading without downtime)</strong></p><p>从GitLab 9.1.0开始便可以非脱机更新，但要遵循一下依赖：</p><ul><li>You can only upgrade 1 minor release at a time. So from 9.1 to 9.2, not to 9.3.</li><li>You have to use <a href="https://docs.gitlab.com/ce/development/post_deployment_migrations.html" target="_blank" rel="noopener">post-deployment migrations</a></li><li>You are using PostgreSQL. If you are using MySQL please look at the release post to see if downtime is required.</li></ul><p><br></p><p><strong>更新版本(Upgrading between editions)</strong></p><ul><li>CE-&gt;EE</li><li>EE-&gt;CE</li></ul><p><br></p><p><strong>杂项(Miscellaneous)</strong></p><ul><li><a href="https://docs.gitlab.com/ce/update/mysql_to_postgresql.html" target="_blank" rel="noopener">MySQL to PostgreSQL</a></li><li><a href="https://docs.gitlab.com/ce/update/restore_after_failure.html" target="_blank" rel="noopener">Restoring from backup after a failed upgrade</a></li><li><a href="https://docs.gitlab.com/ce/update/upgrading_postgresql_using_slony.html" target="_blank" rel="noopener">Upgrading PostgreSQL Using Slony</a></li></ul><p><br><br><br><br><br></p><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p><strong>High Availability</strong>: Configure multiple servers for scaling or high availability.</p><p>GitLab支持多种不同类型的集群和高可用。方案取决于你所依赖的伸缩和可用的级别。最简单的方式是可伸缩，但并不一定是高可用的。<br>由于Git的分布式特性，即使GitLab不可用，开发人员仍然可以在本地提交代码。 但是，当GitLab关闭时，某些GitLab功能（如issue tracker and Continuous Integration…）不可用。</p><p>请记住，所有高可用性解决方案都需要在成本/复杂性和正常运行时间之间进行权衡。想要正常运行的时间越久，则解决方案就越复杂，则设置和维护它的工作就越多。高可用不是免费的，每个高可用方案都应该考虑成本和收益。</p><p><br><br><br></p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>Architecture</p><p>有两种配置：</p><ul><li>active/active</li><li>active/passive</li></ul><p><br></p><p><strong>Active/Active</strong></p><p>此体系结构可轻松扩展，因为所有应用程序Server可同时处理用户请求。Database、Redis、GitLab都部署在不同的Server上，如果他们配置也是如此，则高度可用。</p><p>配置<code>active/active</code>所遵循的步骤：</p><ul><li><a href="https://docs.gitlab.com/ce/administration/high_availability/database.html" target="_blank" rel="noopener">配置Database</a></li><li><a href="https://docs.gitlab.com/ce/administration/high_availability/redis.html" target="_blank" rel="noopener">配置Redis</a></li><li><a href="https://docs.gitlab.com/ce/administration/high_availability/nfs.html" target="_blank" rel="noopener">配置NFS</a></li><li><a href="https://docs.gitlab.com/ce/administration/high_availability/gitlab.html" target="_blank" rel="noopener">配置GitLab</a></li><li><a href="https://docs.gitlab.com/ce/administration/high_availability/load_balancer.html" target="_blank" rel="noopener">配置LoadBlancer</a></li></ul><p><img src="/images/GitLab/active-active-diagram.png" alt=""></p><p><br></p><p><strong>Active/Passive</strong></p><p>对于没有扩展的高可用/故障转移，你可使用Active/Passive。这利用DRBD（Distributed Replicated Block Device）来保持所有数据同步。DRBD要求低延迟链接保持同步。 不建议尝试在数据中心之间或不同的云可用区域中运行DRBD。</p><p>至少需要两台机器(one active/one passive)。</p><p><img src="/images/GitLab/active-passive-diagram.png" alt=""></p><p><br><br><br><br><br></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Configuring GitLab</p><p><br></p><h4 id="配置时区"><a href="#配置时区" class="headerlink" title="配置时区"></a>配置时区</h4><p>Adjust your instance’s timezone: Customize the default time zone of GitLab.</p><p>GitLab默认时区为<code>UTC</code>，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"><span class="comment"># gitlab_rails['time_zone'] = 'UTC'</span></span><br><span class="line">gitlab_rails[<span class="string">'time_zone'</span>] = <span class="string">'Asia/Shanghai'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重载重启</span></span><br><span class="line">gitlab-ctl reconfigure gitlab-ctl restart</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看时区</span></span><br><span class="line">gitlab-rake time:zones:all</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="系统钩子"><a href="#系统钩子" class="headerlink" title="系统钩子"></a>系统钩子</h4><p>System hook，Notifications when users, projects and keys are changed.</p><p>GitLab实例可对以下事件执行HTTP POST请求：</p><ul><li>project_create</li><li>project_destroy</li><li>project_rename</li><li>project_transfer</li><li>project_update</li><li>user_add_to_team</li><li>user_remove_from_team</li><li>user_create</li><li>user_destroy</li><li>user_failed_login</li><li>user_rename</li><li>key_create</li><li>key_destroy</li><li>group_create</li><li>group_destroy</li><li>group_rename</li><li>user_add_to_group</li><li>user_remove_from_group</li></ul><p>可以使用系统钩子，如用于记录或更改 LDAP Server 中的信息。</p><blockquote><p>注意：<br>我们遵循<code>Webhook</code>中对Push和Tag事件的相同结构，但不会显示commit的信息。Webhook的相同弃用在此有效。</p></blockquote><p><br><br><br></p><h5 id="Hook请求"><a href="#Hook请求" class="headerlink" title="Hook请求"></a>Hook请求</h5><p>Request Header:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Gitlab-Event: System Hook</span><br></pre></td></tr></table></figure></p><p>项目创建栗子，还有删除、重名、更新、用户、组等其它事件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">          <span class="attr">"created_at"</span>: <span class="string">"2012-07-21T07:30:54Z"</span>,</span><br><span class="line">          <span class="attr">"updated_at"</span>: <span class="string">"2012-07-21T07:38:22Z"</span>,</span><br><span class="line">          <span class="attr">"event_name"</span>: <span class="string">"project_create"</span>,</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"StoreCloud"</span>,</span><br><span class="line">         <span class="attr">"owner_email"</span>: <span class="string">"johnsmith@gmail.com"</span>,</span><br><span class="line">          <span class="attr">"owner_name"</span>: <span class="string">"John Smith"</span>,</span><br><span class="line">                <span class="attr">"path"</span>: <span class="string">"storecloud"</span>,</span><br><span class="line"> <span class="attr">"path_with_namespace"</span>: <span class="string">"jsmith/storecloud"</span>,</span><br><span class="line">          <span class="attr">"project_id"</span>: <span class="number">74</span>,</span><br><span class="line">  <span class="attr">"project_visibility"</span>: <span class="string">"private"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="Tag事件"><a href="#Tag事件" class="headerlink" title="Tag事件"></a>Tag事件</h5><p>当向仓库(Repository)创建或删除标记(tag)时触发，它为每个修改过的标记生成一个事件。。</p><p>Request header:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Gitlab-Event: System Hook</span><br></pre></td></tr></table></figure><p>Request body:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"event_name"</span>: <span class="string">"tag_push"</span>,</span><br><span class="line">  <span class="attr">"before"</span>: <span class="string">"0000000000000000000000000000000000000000"</span>,</span><br><span class="line">  <span class="attr">"after"</span>: <span class="string">"82b3d5ae55f7080f1e6022629cdb57bfae7cccc7"</span>,</span><br><span class="line">  <span class="attr">"ref"</span>: <span class="string">"refs/tags/v1.0.0"</span>,</span><br><span class="line">  <span class="attr">"checkout_sha"</span>: <span class="string">"5937ac0a7beb003549fc5fd26fc247adbce4a52e"</span>,</span><br><span class="line">  <span class="attr">"user_id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"user_name"</span>: <span class="string">"John Smith"</span>,</span><br><span class="line">  <span class="attr">"user_avatar"</span>: <span class="string">"https://s.gravatar.com/avatar/d4c74594d841139328695756648b6bd6?s=8://s.gravatar.com/avatar/d4c74594d841139328695756648b6bd6?s=80"</span>,</span><br><span class="line">  <span class="attr">"project_id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"project"</span>:&#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"Example"</span>,</span><br><span class="line">    <span class="attr">"description"</span>:<span class="string">""</span>,</span><br><span class="line">    <span class="attr">"web_url"</span>:<span class="string">"http://example.com/jsmith/example"</span>,</span><br><span class="line">    <span class="attr">"avatar_url"</span>:<span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"git_ssh_url"</span>:<span class="string">"git@example.com:jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"git_http_url"</span>:<span class="string">"http://example.com/jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"namespace"</span>:<span class="string">"Jsmith"</span>,</span><br><span class="line">    <span class="attr">"visibility_level"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">"path_with_namespace"</span>:<span class="string">"jsmith/example"</span>,</span><br><span class="line">    <span class="attr">"default_branch"</span>:<span class="string">"master"</span>,</span><br><span class="line">    <span class="attr">"homepage"</span>:<span class="string">"http://example.com/jsmith/example"</span>,</span><br><span class="line">    <span class="attr">"url"</span>:<span class="string">"git@example.com:jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"ssh_url"</span>:<span class="string">"git@example.com:jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"http_url"</span>:<span class="string">"http://example.com/jsmith/example.git"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"repository"</span>:&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Example"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"ssh://git@example.com/jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"homepage"</span>: <span class="string">"http://example.com/jsmith/example"</span>,</span><br><span class="line">    <span class="attr">"git_http_url"</span>:<span class="string">"http://example.com/jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"git_ssh_url"</span>:<span class="string">"git@example.com:jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"visibility_level"</span>:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"commits"</span>: [],</span><br><span class="line">  <span class="attr">"total_commits_count"</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="Merge请求事件"><a href="#Merge请求事件" class="headerlink" title="Merge请求事件"></a>Merge请求事件</h5><p>在创建一个新的合并(merge)请求时触发，更新、合并、关闭现有合并请求，或在源分支中添加commit。</p><p>Request Header:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Gitlab-Event: System Hook</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"object_kind"</span>: <span class="string">"merge_request"</span>,</span><br><span class="line">  <span class="attr">"user"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Administrator"</span>,</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"root"</span>,</span><br><span class="line">    <span class="attr">"avatar_url"</span>: <span class="string">"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&amp;d=identicon"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"project"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Example"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"web_url"</span>: <span class="string">"http://example.com/jsmith/example"</span>,</span><br><span class="line">    <span class="attr">"avatar_url"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"git_ssh_url"</span>: <span class="string">"git@example.com:jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"git_http_url"</span>: <span class="string">"http://example.com/jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"namespace"</span>: <span class="string">"Jsmith"</span>,</span><br><span class="line">    <span class="attr">"visibility_level"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"path_with_namespace"</span>: <span class="string">"jsmith/example"</span>,</span><br><span class="line">    <span class="attr">"default_branch"</span>: <span class="string">"master"</span>,</span><br><span class="line">    <span class="attr">"ci_config_path"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"homepage"</span>: <span class="string">"http://example.com/jsmith/example"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"git@example.com:jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"ssh_url"</span>: <span class="string">"git@example.com:jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"http_url"</span>: <span class="string">"http://example.com/jsmith/example.git"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"object_attributes"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">90</span>,</span><br><span class="line">    <span class="attr">"target_branch"</span>: <span class="string">"master"</span>,</span><br><span class="line">    <span class="attr">"source_branch"</span>: <span class="string">"ms-viewport"</span>,</span><br><span class="line">    <span class="attr">"source_project_id"</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="attr">"author_id"</span>: <span class="number">51</span>,</span><br><span class="line">    <span class="attr">"assignee_id"</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"MS-Viewport"</span>,</span><br><span class="line">    <span class="attr">"created_at"</span>: <span class="string">"2017-09-20T08:31:45.944Z"</span>,</span><br><span class="line">    <span class="attr">"updated_at"</span>: <span class="string">"2017-09-28T12:23:42.365Z"</span>,</span><br><span class="line">    <span class="attr">"milestone_id"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"state"</span>: <span class="string">"opened"</span>,</span><br><span class="line">    <span class="attr">"merge_status"</span>: <span class="string">"unchecked"</span>,</span><br><span class="line">    <span class="attr">"target_project_id"</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="attr">"iid"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"updated_by_id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"merge_error"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"merge_params"</span>: &#123;</span><br><span class="line">      <span class="attr">"force_remove_source_branch"</span>: <span class="string">"0"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"merge_when_pipeline_succeeds"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"merge_user_id"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"merge_commit_sha"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"deleted_at"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"in_progress_merge_commit_sha"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"lock_version"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"time_estimate"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"last_edited_at"</span>: <span class="string">"2017-09-27T12:43:37.558Z"</span>,</span><br><span class="line">    <span class="attr">"last_edited_by_id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"head_pipeline_id"</span>: <span class="number">61</span>,</span><br><span class="line">    <span class="attr">"ref_fetched"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"merge_jid"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"source"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Awesome Project"</span>,</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"web_url"</span>: <span class="string">"http://example.com/awesome_space/awesome_project"</span>,</span><br><span class="line">      <span class="attr">"avatar_url"</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">"git_ssh_url"</span>: <span class="string">"git@example.com:awesome_space/awesome_project.git"</span>,</span><br><span class="line">      <span class="attr">"git_http_url"</span>: <span class="string">"http://example.com/awesome_space/awesome_project.git"</span>,</span><br><span class="line">      <span class="attr">"namespace"</span>: <span class="string">"root"</span>,</span><br><span class="line">      <span class="attr">"visibility_level"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"path_with_namespace"</span>: <span class="string">"awesome_space/awesome_project"</span>,</span><br><span class="line">      <span class="attr">"default_branch"</span>: <span class="string">"master"</span>,</span><br><span class="line">      <span class="attr">"ci_config_path"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"homepage"</span>: <span class="string">"http://example.com/awesome_space/awesome_project"</span>,</span><br><span class="line">      <span class="attr">"url"</span>: <span class="string">"http://example.com/awesome_space/awesome_project.git"</span>,</span><br><span class="line">      <span class="attr">"ssh_url"</span>: <span class="string">"git@example.com:awesome_space/awesome_project.git"</span>,</span><br><span class="line">      <span class="attr">"http_url"</span>: <span class="string">"http://example.com/awesome_space/awesome_project.git"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"target"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Awesome Project"</span>,</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"Aut reprehenderit ut est."</span>,</span><br><span class="line">      <span class="attr">"web_url"</span>: <span class="string">"http://example.com/awesome_space/awesome_project"</span>,</span><br><span class="line">      <span class="attr">"avatar_url"</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">"git_ssh_url"</span>: <span class="string">"git@example.com:awesome_space/awesome_project.git"</span>,</span><br><span class="line">      <span class="attr">"git_http_url"</span>: <span class="string">"http://example.com/awesome_space/awesome_project.git"</span>,</span><br><span class="line">      <span class="attr">"namespace"</span>: <span class="string">"Awesome Space"</span>,</span><br><span class="line">      <span class="attr">"visibility_level"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"path_with_namespace"</span>: <span class="string">"awesome_space/awesome_project"</span>,</span><br><span class="line">      <span class="attr">"default_branch"</span>: <span class="string">"master"</span>,</span><br><span class="line">      <span class="attr">"ci_config_path"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"homepage"</span>: <span class="string">"http://example.com/awesome_space/awesome_project"</span>,</span><br><span class="line">      <span class="attr">"url"</span>: <span class="string">"http://example.com/awesome_space/awesome_project.git"</span>,</span><br><span class="line">      <span class="attr">"ssh_url"</span>: <span class="string">"git@example.com:awesome_space/awesome_project.git"</span>,</span><br><span class="line">      <span class="attr">"http_url"</span>: <span class="string">"http://example.com/awesome_space/awesome_project.git"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"last_commit"</span>: &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"ba3e0d8ff79c80d5b0bbb4f3e2e343e0aaa662b7"</span>,</span><br><span class="line">      <span class="attr">"message"</span>: <span class="string">"fixed readme"</span>,</span><br><span class="line">      <span class="attr">"timestamp"</span>: <span class="string">"2017-09-26T16:12:57Z"</span>,</span><br><span class="line">      <span class="attr">"url"</span>: <span class="string">"http://example.com/awesome_space/awesome_project/commits/da1560886d4f094c3e6c9ef40349f7d38b5d27d7"</span>,</span><br><span class="line">      <span class="attr">"author"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"GitLab dev user"</span>,</span><br><span class="line">        <span class="attr">"email"</span>: <span class="string">"gitlabdev@dv6700.(none)"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"work_in_progress"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"total_time_spent"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"human_total_time_spent"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"human_time_estimate"</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"labels"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">"repository"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"git-gpg-test"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"git@example.com:awesome_space/awesome_project.git"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"homepage"</span>: <span class="string">"http://example.com/awesome_space/awesome_project"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="库更新事件"><a href="#库更新事件" class="headerlink" title="库更新事件"></a>库更新事件</h5><p>Repository Update events</p><p>当你push到Repository(包括tag)的时候仅触发一次。</p><p>Request Header：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Gitlab-Event: System Hook</span><br></pre></td></tr></table></figure><p>Request body:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"event_name"</span>: <span class="string">"repository_update"</span>,</span><br><span class="line">  <span class="attr">"user_id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"user_name"</span>: <span class="string">"John Smith"</span>,</span><br><span class="line">  <span class="attr">"user_email"</span>: <span class="string">"admin@example.com"</span>,</span><br><span class="line">  <span class="attr">"user_avatar"</span>: <span class="string">"https://s.gravatar.com/avatar/d4c74594d841139328695756648b6bd6?s=8://s.gravatar.com/avatar/d4c74594d841139328695756648b6bd6?s=80"</span>,</span><br><span class="line">  <span class="attr">"project_id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"project"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"Example"</span>,</span><br><span class="line">    <span class="attr">"description"</span>:<span class="string">""</span>,</span><br><span class="line">    <span class="attr">"web_url"</span>:<span class="string">"http://example.com/jsmith/example"</span>,</span><br><span class="line">    <span class="attr">"avatar_url"</span>:<span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"git_ssh_url"</span>:<span class="string">"git@example.com:jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"git_http_url"</span>:<span class="string">"http://example.com/jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"namespace"</span>:<span class="string">"Jsmith"</span>,</span><br><span class="line">    <span class="attr">"visibility_level"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">"path_with_namespace"</span>:<span class="string">"jsmith/example"</span>,</span><br><span class="line">    <span class="attr">"default_branch"</span>:<span class="string">"master"</span>,</span><br><span class="line">    <span class="attr">"homepage"</span>:<span class="string">"http://example.com/jsmith/example"</span>,</span><br><span class="line">    <span class="attr">"url"</span>:<span class="string">"git@example.com:jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"ssh_url"</span>:<span class="string">"git@example.com:jsmith/example.git"</span>,</span><br><span class="line">    <span class="attr">"http_url"</span>:<span class="string">"http://example.com/jsmith/example.git"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"changes"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"before"</span>:<span class="string">"8205ea8d81ce0c6b90fbe8280d118cc9fdad6130"</span>,</span><br><span class="line">      <span class="attr">"after"</span>:<span class="string">"4045ea7a3df38697b3730a20fb73c8bed8a3e69e"</span>,</span><br><span class="line">      <span class="attr">"ref"</span>:<span class="string">"refs/heads/master"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"refs"</span>:[<span class="string">"refs/heads/master"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>Security: Learn what you can do to further secure your GitLab instance.</p><p><br></p><h5 id="密码长度"><a href="#密码长度" class="headerlink" title="密码长度"></a>密码长度</h5><p>Password length limits</p><p>如果要强制使用更长的用户密码，可使用<code>Devise initializer</code>来设置。</p><p>如果未使用<code>devise_password_length.rb</code>初始化程序，则在<code>config/initializers/devise.rb</code>中设置密码长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/git/gitlab</span><br><span class="line">sudo -u git -H cp config/initializers/devise_password_length.rb.example config/initializers/devise_password_length.rb</span><br><span class="line">sudo -u git -H editor config/initializers/devise_password_length.rb   # inspect and edit the new password length limits</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="限制SSH秘钥和长度"><a href="#限制SSH秘钥和长度" class="headerlink" title="限制SSH秘钥和长度"></a>限制SSH秘钥和长度</h5><p>Restrict SSH key technologies and minimum length</p><p><code>ssh-keygen</code>允许用户创建少至768位的RSA密钥，这远低于某些标准组的建议。</p><p>这个功能在Web界面的设置里去设置。</p><p><br><br><br></p><h5 id="机架攻击"><a href="#机架攻击" class="headerlink" title="机架攻击"></a>机架攻击</h5><p>Rack attack</p><p><code>Rack Attack</code>, 也称为<code>Rack::Attack</code>.旨在通过自定义限制和阻止用户IP来保护GitLab。从<code>v 11.2</code>开始，默认禁用此功能。<br>您可以通过限制来自发出大量请求的IP地址的请求来防止暴力密码攻击，抓取程序或任何其他违规者。 如果您发现限制不足以保护您免受滥用客户端的攻击，Rack Attack提供IP白名单，黑名单，Fail2ban样式过滤和跟踪。<br>如果你的实例并未对外有任何传入连接，则建议你禁用此功能。</p><p><br></p><h5 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#启用</span></span><br><span class="line">gitlab_rails[<span class="string">'rack_attack_git_basic_auth'</span>] = &#123;</span><br><span class="line">  <span class="string">'enabled'</span> =&gt; <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'ip_whitelist'</span> =&gt; [<span class="string">"127.0.0.1"</span>],</span><br><span class="line">  <span class="string">'maxretry'</span> =&gt; 10, <span class="comment"># Limit the number of Git HTTP authentication attempts per IP</span></span><br><span class="line">  <span class="string">'findtime'</span> =&gt; 60, <span class="comment"># Reset the auth attempt counter per IP after 60 seconds</span></span><br><span class="line">  <span class="string">'bantime'</span> =&gt; 3600 <span class="comment"># Ban an IP for one hour (3600s) after too many auth attempts</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重载</span></span><br><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="通过Redis冲机架攻击中移除阻止的IP"><a href="#通过Redis冲机架攻击中移除阻止的IP" class="headerlink" title="通过Redis冲机架攻击中移除阻止的IP"></a>通过Redis冲机架攻击中移除阻止的IP</h5><p>Remove blocked IPs from Rack Attack via Redis</p><p>如果想移除阻止的IPs，参考下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#在日志中找出被阻止的IPs</span><br><span class="line">grep &quot;Rack_Attack&quot; /var/log/gitlab/gitlab-rails/production.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#由于黑名单存在Redis中，所以需要连接Redis</span><br><span class="line">/opt/gitlab/embedded/bin/redis-cli -s /var/opt/gitlab/redis/redis.socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除此IP</span><br><span class="line">DEL cache:gitlab:rack::attack:allow2ban:ban:&lt;ip&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">KEYS *rack::attack*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#或者，将其加入白名单</span><br></pre></td></tr></table></figure><p><br></p><p>如果所有流量来自于负载均衡器，请记得把负载均衡器加入白名单。</p><p><br><br><br></p><h5 id="Webhooks和不安全的内部Web服务"><a href="#Webhooks和不安全的内部Web服务" class="headerlink" title="Webhooks和不安全的内部Web服务"></a>Webhooks和不安全的内部Web服务</h5><p>Webhooks and insecure internal web services</p><p>如果您的GitLab Server或其本地网络中运行non-GitLab Web服务，则这些服务可能很容易被Webhooks利用。<br>使用Webhook，你便可以设置项目在发生特定事件时触发的URL。通常，这些请求被发送到专门为此目的设置的外部Web服务，以适当的方式处理请求及其附加数据。</p><p>然而，当Webhook设置的URL不是指向外部服务而是指向内部服务时，可能会在触发webhook并发送POST请求时完全无意中执行操作。<br>因为Webhook请求是由GitLab Server本身发出的，所以它们可以完全访问服务器上运行的所有内容或服务器的本地网络，即使这些服务受到其他方面的保护，无法与外界联系。</p><p>如果一个Web服务不需要身份认证，Webhooks可以通过让GitLab Server向端点(endpoint)发出POST请求来触发破坏性命令，例如<code>http://localhost:123/some-resource/delete</code></p><p>为了防止这种类型的利用，从GitLab v10.6开始，默认禁止对当前GitLab Instance Server Address或private network的所有Webhook请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#这意味着这些地址都被禁止</span><br><span class="line">127.0.0.1</span><br><span class="line">::1</span><br><span class="line">0.0.0.0</span><br><span class="line">10.0.0.0/8</span><br><span class="line">172.16.0.0/12</span><br><span class="line">173.192.168.0.0/16</span><br></pre></td></tr></table></figure><p>可在Web界面的设置里面的<strong>Outbound requests</strong>里启用<strong>Allow requests to the local network from hooks and services</strong>.</p><p><br><br><br></p><h5 id="信息独占性"><a href="#信息独占性" class="headerlink" title="信息独占性"></a>信息独占性</h5><p>Information exclusivity</p><p>Git是一个分布式版本控制系统，这意味着使用源代码的每一个人都拥有完整Repository的本地副本。GitLab有Guest、 Reporter、Developer、Maintainer这些项目用户权限。在获取此Repository后，用户可在任何位置上传此Repository。<br>您无法构建访问控制来阻止有权访问源代码的用户有意共享源代码。这是DVCS的固有特性，所有git管理系统都有此限制。显然你可以采取措施防止无意的共享和信息破坏，这就是为什么只有一些人被允许邀请其他人，没有人可以强制推动受保护的分支。</p><p><br><br><br></p><h5 id="重置root密码"><a href="#重置root密码" class="headerlink" title="重置root密码"></a>重置root密码</h5><p>reset your root password</p><p>使用root权限登录Ruby Rail控制台:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sudo su -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#控制台</span></span><br><span class="line">gitlab-rails console production</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#等待终端的载入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查找用户</span></span><br><span class="line">user = User.where(id: 1).first</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">user = User.find_by(email: <span class="string">'admin@local.host'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改密码</span></span><br><span class="line">user.password = <span class="string">'secret_pass'</span></span><br><span class="line">user.password_confirmation = <span class="string">'secret_pass'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存更改和退出</span></span><br><span class="line">user.save!</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="解锁锁定的用户"><a href="#解锁锁定的用户" class="headerlink" title="解锁锁定的用户"></a>解锁锁定的用户</h5><p>How to unlock a locked user</p><p>使用root权限登录Server，启动Ruby Rail Console:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo su -</span><br><span class="line"></span><br><span class="line">gitlab-rails console production</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user = User.where(id: 1).first</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">user = User.find_by(email: <span class="string">'admin@local.host'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#解锁</span></span><br><span class="line">user.unlock_access!</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="用户文件上传"><a href="#用户文件上传" class="headerlink" title="用户文件上传"></a>用户文件上传</h5><p>User File Uploads</p><p>如果有人知道直接URL，则附加图像到问题，合并请求或评论不需要查看身份验证。此直接URL包含一个随机的32个字符的ID，可防止未经授权的人员将URL猜到包含敏感信息的图像。我们不启用身份验证，因为这些图像需要在通知电子邮件正文中可见，通常从未通过GitLab验证的电子邮件客户端读取，例如Outlook、Gmail..</p><p>请注意，非图像附件确实需要查看身份验证。</p><p><br><br><br></p><h5 id="管理CRIME漏洞"><a href="#管理CRIME漏洞" class="headerlink" title="管理CRIME漏洞"></a>管理CRIME漏洞</h5><p>How we manage the CRIME vulnerability</p><blockquote><p>CRIME(“Compression Ratio Info-leak Made Easy”)是一种针对使用HTTPS和SPDY协议进行连接的秘密Web cookie的安全漏洞，这些协议也使用数据压缩。当用于恢复秘密身份验证cookie的内容时，它允许攻击者在经过身份验证的Web会话上执行会话劫持，从而允许发起进一步的攻击。</p></blockquote><p>TLS协议CRIME漏洞影响HTTPS上的压缩，因此它警告不要使用SSL压缩（例如gzip）或SPDY，它也可以选择使用压缩。<br>虽然在Omnibus安装中启用了SPDY，但CRIME依赖于压缩（’C’），并且NGINX的SPDY模块中的默认压缩级别为0（无压缩）。</p><p>GitLab支持gzip和SPDY，并在启用HTTPS时通过停用gzip来缓解CRIME漏洞。<br>你可以看到问题的来源：</p><ul><li>Source installation NGINX file</li><li>Omnibus installation NGINX file</li></ul><p><br><br><br></p><h5 id="强制双重认证"><a href="#强制双重认证" class="headerlink" title="强制双重认证"></a>强制双重认证</h5><p>Enforce Two-factor Authentication (2FA)</p><p>双因素身份验证（2FA）为GitLab帐户提供了额外的安全级别。启用后，除了提供用户名和密码登录外，还要求在输入应用程序生成的代码。</p><p><br></p><p><strong>为所有账户启用两步认证：</strong></p><p>有两种方式：</p><ul><li>Enforce on next login.</li><li>Suggest on next login, but allow a grace period before enforcing.</li></ul><p>在Web界面里Admin区域里的设置里面的“Sign-in Restrictions”选项。</p><p><br></p><p><strong>为组中的所有用户启用：</strong></p><p>如果你只想对某些特定组启用两步认证，则你需要则群组设置中启用它。</p><p><br></p><p><strong>为所有用户禁用：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Omnibus installations</span></span><br><span class="line">sudo gitlab-rake gitlab:two_factor:disable_for_all_users</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Installations from source</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake gitlab:two_factor:disable_for_all_users RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="注册时用户邮件确认"><a href="#注册时用户邮件确认" class="headerlink" title="注册时用户邮件确认"></a>注册时用户邮件确认</h5><p>User email confirmation at sign-up</p><p>如果您想在所有用户电子邮件登录之前确认，GitLab管理员可以在注册时启用电子邮件确认。</p><p>在Web界面的Admin区域的设置的“ Sign-up Restrictions”里启用“Send confirmation email on sign-up”。</p><p><br><br><br><br><br></p><h4 id="统计、检查和ping"><a href="#统计、检查和ping" class="headerlink" title="统计、检查和ping"></a>统计、检查和ping</h4><p>Usage statistics, version check, and usage ping: Enable or disable information about your instance to be sent to GitLab, Inc.</p><p>GitLab定期从实例收集各种信息。你可在<code>Admin area &gt; Settings</code>去设置他们。</p><p><br></p><p><strong>停止使用ping：</strong></p><p>在设置面板里面取消，并修改配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#omnibus</span><br><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">gitlab_rails[&apos;usage_ping_enabled&apos;] = false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#source</span><br><span class="line">vi ./gitlab.yml</span><br><span class="line"></span><br><span class="line">production: &amp;base</span><br><span class="line">  # ...</span><br><span class="line">  gitlab:</span><br><span class="line">    # ...</span><br><span class="line">    usage_ping_enabled: false</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h4 id="轮询配置"><a href="#轮询配置" class="headerlink" title="轮询配置"></a>轮询配置</h4><p>Polling: Configure how often the GitLab UI polls for updates.</p><p>GitLab UI按照适合资源的计划轮询不同资源的更新(issue notes, issue titles, pipeline statuses, etc.)<br>在Web UI的应用程序使用功能中设置它：</p><ul><li>1(默认值，推荐用于大多数安装)（Issue notes poll every 2 seconds, and issue titles poll every 5 seconds.)</li><li>0(禁用UI轮询)</li><li>大于1(将减慢轮询速度)</li><li>0-1之间(轮询更频繁，不推荐)</li></ul><p><br><br><br><br><br></p><h4 id="GitLab-Page"><a href="#GitLab-Page" class="headerlink" title="GitLab Page"></a>GitLab Page</h4><p>GitLab Pages configuration: Enable and configure GitLab Pages.</p><p>GitLab Pages使用GitLab Pages Daemon，这是一个用Go编写的简单HTTP Server，可以侦听外部IP地址并提供对自定义域和自定义证书的支持。它通过SNI支持动态证书，默认情况下使用HTTP2公开页面。</p><p>对于自定义域（但不是通配符域），Pages Daemon需要侦听端口80/443。因此，您可以灵活设置它：</p><ul><li>在与GitLab相同的Server中运行Pages Daemon，监听 Secondary IP</li><li>在与GitLab相同的Server上运行Pages Daemon，监听同一IP的不同Port</li><li>在单独的Server中运行Pages Daemon</li></ul><p><br><br><br></p><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p>在配置Pages之前，你需要：</p><ul><li>拥有用于提供GitLab Pages的独占根域。请注意，您不能使用GitLab实例域的子域。</li><li>配置wildcard DNS record.</li><li>HTTPS(可选)</li><li>启用shared runner(可选，但推荐)</li></ul><p><br></p><p><strong>将域添加到公共后缀列表</strong><br>Add the domain to the Public Suffix List</p><p><br></p><p><strong>DNS配置</strong></p><p>您需要添加指向GitLab运行的主机的通配符DNS A记录。</p><p><br><br><br></p><p>#####　配置</p><p>根据您的需要，您可以通过4种不同的方式设置GitLab页面。</p><ul><li>Wildcard domains</li><li>Wildcard domains with TLS support</li><li>Custom domains</li><li>Custom domains with TLS support</li><li>Custom domain verification</li><li>Access control</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gitlab_pages</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br></p><p><strong>其它一些配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#日志记录</span><br><span class="line">gitlab_pages[&apos;log_verbose&apos;] = true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#存储路径</span><br><span class="line">gitlab_rails[&apos;pages_path&apos;] = &quot;/mnt/storage/pages&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#监听和代理请求</span><br><span class="line">gitlab_pages[&apos;listen_proxy&apos;] = &quot;localhost:10080&quot;</span><br><span class="line">#禁用</span><br><span class="line">gitlab_pages[&apos;listen_proxy&apos;] = nil</span><br><span class="line"></span><br><span class="line">#安全</span><br><span class="line">#备份</span><br><span class="line">#page size</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>Environment variables: Supported environment variables that can be used to override their defaults values in order to configure GitLab.</p><p>GitLab公开了某些环境变量，这些变量可用于覆盖其默认值。</p><p><strong>支持的环境变量：</strong></p><table><thead><tr><th>Variable</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>GITLAB_CDN_HOST</code></td><td>string</td><td>Sets the base URL for a CDN to serve static assets (e.g. //mycdnsubdomain.fictional-cdn.com)</td></tr><tr><td><code>GITLAB_ROOT_PASSWORD</code></td><td>string</td><td>Sets the password for the root user on installation</td></tr><tr><td><code>GITLAB_HOST</code></td><td>string</td><td>The full URL of the GitLab server (including http:// or https://)</td></tr><tr><td><code>RAILS_ENV</code></td><td>string</td><td>The Rails environment; can be one of production, development, staging or test</td></tr><tr><td><code>DATABASE_URL</code></td><td>string</td><td>The database URL; is of the form: postgresql://localhost/blog_development</td></tr><tr><td><code>GITLAB_EMAIL_FROM</code></td><td>string</td><td>The e-mail address used in the “From” field in e-mails sent by GitLab</td></tr><tr><td><code>GITLAB_EMAIL_DISPLAY_NAME</code></td><td>string</td><td>The name used in the “From” field in e-mails sent by GitLab</td></tr><tr><td><code>GITLAB_EMAIL_REPLY_TO</code></td><td>string</td><td>The e-mail address used in the “Reply-To” field in e-mails sent by GitLab</td></tr><tr><td><code>GITLAB_EMAIL_SUBJECT_SUFFIX</code></td><td>string</td><td>The e-mail subject suffix used in e-mails sent by GitLab</td></tr><tr><td><code>GITLAB_UNICORN_MEMORY_MIN</code></td><td>integer</td><td>The minimum memory threshold (in bytes) for the Unicorn worker killer</td></tr><tr><td><code>GITLAB_UNICORN_MEMORY_MAX</code></td><td>integer</td><td>The maximum memory threshold (in bytes) for the Unicorn worker killer</td></tr><tr><td><code>GITLAB_SHARED_RUNNERS_REGISTRATION_TOKEN</code></td><td>string</td><td>Sets the initial registration token used for GitLab Runners</td></tr></tbody></table><p><br></p><p><strong>完整的数据库变量：</strong></p><p>指定数据库连接信息的推荐方法是设置<code>DATABASE_URL</code>环境变量。此变量仅保存连接信息(adapter, database, username, password, host, port)，没有行为信息(encoding, pool)。</p><p>如果你不想使用<code>DATABASE_URL</code>环境变量或想要使用数据库行为信息，则：</p><ul><li>复制模板文件: <code>cp config/database.yml.env config/database.yml</code></li><li>或，为<code>GITLAB_DATABASE_XXX</code>变量设置值</li></ul><p>你可以设置的<code>GITLAB_DATABASE_XXX</code>变量列表：</p><table><thead><tr><th>Variable</th><th>Default value</th><th>Overridden by <code>DATABASE_URL</code>?</th></tr></thead><tbody><tr><td><code>GITLAB_DATABASE_ADAPTER</code></td><td>postgresql (for MySQL use mysql2)</td><td>Yes</td></tr><tr><td><code>GITLAB_DATABASE_DATABASE</code></td><td>gitlab_#{ENV[‘RAILS_ENV’]</td><td>Yes</td></tr><tr><td><code>GITLAB_DATABASE_USERNAME</code></td><td>root</td><td>Yes</td></tr><tr><td><code>GITLAB_DATABASE_PASSWORD</code></td><td>None</td><td>Yes</td></tr><tr><td><code>GITLAB_DATABASE_HOST</code></td><td>localhost</td><td>Yes</td></tr><tr><td><code>GITLAB_DATABASE_PORT</code></td><td>5432</td><td>Yes</td></tr><tr><td><code>GITLAB_DATABASE_ENCODING</code></td><td>unicode</td><td>No</td></tr><tr><td><code>GITLAB_DATABASE_POOL</code></td><td>10</td><td>No</td></tr></tbody></table><p><br></p><p><strong>添加更多变量：</strong></p><p>我们欢迎合并请求，并通过变量进行更多配置。<br>请在<code>config/initializers/1_settings.rb</code>文件中进行更改，并使用<code>GITLAB_#{name in 1_settings.rb in upper case}</code>这样的命名方案。</p><p><br></p><p><strong>Omnibus设置自定义环境变量：</strong></p><p>如有必要，您可以通过<code>/etc/gitlab/gitlab.rb</code>设置Unicorn，Sidekiq，Rails和Rake使用的自定义环境变量。这在您需要使用代理来访问Internet并且您希望将外部托管的存储库直接克隆到gitlab的情况下非常有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[&apos;env&apos;] = &#123;</span><br><span class="line">    &quot;http_proxy&quot; =&gt; &quot;my_proxy&quot;,</span><br><span class="line">    &quot;https_proxy&quot; =&gt; &quot;my_proxy&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#你还可以覆盖GitLab组件中的其它环境变量</span><br><span class="line"># Needed for proxying Git clones</span><br><span class="line">gitaly[&apos;env&apos;] = &#123;</span><br><span class="line">    &quot;http_proxy&quot; =&gt; &quot;my_proxy&quot;,</span><br><span class="line">    &quot;https_proxy&quot; =&gt; &quot;my_proxy&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gitlab_workhorse[&apos;env&apos;] = &#123;</span><br><span class="line">    &quot;http_proxy&quot; =&gt; &quot;my_proxy&quot;,</span><br><span class="line">    &quot;https_proxy&quot; =&gt; &quot;my_proxy&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># If you use the docker registry</span><br><span class="line">registry[&apos;env&apos;] = &#123;</span><br><span class="line">    &quot;http_proxy&quot; =&gt; &quot;my_proxy&quot;,</span><br><span class="line">    &quot;https_proxy&quot; =&gt; &quot;my_proxy&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#应用更改</span><br><span class="line">#对环境变量所做的任何更改都需要在重新配置后进行硬重启才能使其生效</span><br><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line">sudo gitlab-ctl restart</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>GitLab Plugin System<br>Plugins: With custom plugins, GitLab administrators can introduce custom integrations without modifying GitLab’s source code.</p><p>使用自定义插件，GitLab管理员可以在不修改GitLab源代码的情况下引入自定义集成。<br>你也可以之间修改GitLab源代码而不用编写插件。<br>必须在GitLab Server上配置插件。</p><p>插件将在每个事件上运行，因此您可以在插件代码中过滤事件或项目。你可以拥有任意数量的插件。如果发生事件，每个插件都将由GitLab异步触发。</p><p><br></p><p><strong>配置：</strong></p><p>插件必须直接放在plugin目录中，按照以下步骤自定义hook:</p><ul><li>在GitLab Server上，定位到plugin目录<ul><li>source: <code>/home/git/gitlab/plugins/</code></li><li>omnibus: <code>/opt/gitlab/embedded/service/gitlab-rails/plugins</code></li></ul></li><li>在plugins目录内，创建一个你需要的文件(文件名不要使用特殊字符)</li><li>使hook文件可执行，并有git用户所拥有</li><li>编写代码以使插件功能符合预期。这可以是任何语言</li><li>插件的数据将在STDIN上以JSON的形式提供</li></ul><p><br></p><p><strong>验证：</strong></p><p>编写自己的插件可能会非常棘手，如果您可以在不改变系统的情况下进行检查，则会更容易。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Omnibus installations</span></span><br><span class="line">sudo gitlab-rake plugins:validate</span><br><span class="line"></span><br><span class="line"><span class="comment"># Installations from source</span></span><br><span class="line"><span class="built_in">cd</span> /home/git/gitlab</span><br><span class="line">bundle <span class="built_in">exec</span> rake plugins:validate RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h4 id="规范性"><a href="#规范性" class="headerlink" title="规范性"></a>规范性</h4><p>Compliance: A collection of features from across the application that you may configure to help ensure that your </p><p>您可以配置以下GitLab功能，以帮助确保您的GitLab实例符合通用的规范性标准。</p><table><thead><tr><th>功能</th><th>GitLab tier</th></tr></thead><tbody><tr><td><strong>Restrict SSH Keys</strong> <br> 控制用于访问GitLab的SSH密钥的技术和密钥长度</td><td>Core+</td></tr><tr><td><strong>Granular user roles and flexible permissions</strong> <br> 使用五种不同的用户角色和外部用户设置管理访问权限和权限。根据人员的角色设置权限，而不是对存储库的读取或写入访问权限。不要与只需要访问问题跟踪器的人共享源代码。</td><td>Core+</td></tr><tr><td><strong>Enforce TOS acceptance</strong> <br> 通过阻止GitLab流量强制您的用户接受新的服务条款。</td><td>Core+</td></tr><tr><td><strong>Email all users of a project, group, or entire server</strong> <br> 管理员可以根据项目或组成员身份向用户组发送电子邮件，或使用GitLab实例向每个人发送电子邮件。</td><td>Starter+</td></tr><tr><td><strong>Omnibus package supports log forwarding</strong> <br> 将日志转发到中央系统。</td><td>Starter+</td></tr><tr><td><strong>Lock project membership to group</strong> <br> 组所有者可以阻止将新成员添加到组中的项目。</td><td>Starter+</td></tr><tr><td><strong>LDAP group sync</strong> <br> GitLab企业版使管理员能够自动同步组并管理SSH密钥，权限和身份验证，因此您可以专注于构建产品，而不是配置工具。</td><td>Starter+</td></tr><tr><td><strong>LDAP group sync filters</strong> <br> GitLab企业版Premium可以更灵活地基于过滤器与LDAP同步，这意味着您可以利用LDAP属性来映射GitLab权限。</td><td>Premium+</td></tr><tr><td><strong>Audit logs</strong> <br> 为了保持代码的完整性，GitLab Enterprise Edition Premium使管理员能够在高级审计日志系统中查看GitLab服务器内的任何修改，以便您可以控制，分析和跟踪每个更改。</td><td>Premium+</td></tr><tr><td><strong>Auditor users</strong> <br> 审核员用户是对GitLab实例上的所有项目，组和其他资源具有只读访问权限的用户。</td><td>Premium+</td></tr></tbody></table><p><br><br><br><br><br></p><h4 id="自定义GitLab外观"><a href="#自定义GitLab外观" class="headerlink" title="自定义GitLab外观"></a>自定义GitLab外观</h4><p>Customizing GitLab’s appearance</p><p>这些外观配置请在Web UI里面进行设置：</p><ul><li>Header logo</li><li>Favicon</li><li>Branded login page</li><li>Welcome message</li><li>“New Project” page</li></ul><p><br><br><br><br><br><br><br></p><h3 id="维护GitLab"><a href="#维护GitLab" class="headerlink" title="维护GitLab"></a>维护GitLab</h3><p>Maintaining GitLab</p><p><br></p><h4 id="靶任务"><a href="#靶任务" class="headerlink" title="靶任务"></a>靶任务</h4><p>Raketasks: Perform various tasks for maintenance, backups, automatic webhooks setup, etc.</p><p><br></p><h5 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h5><p>Backing up and restoring GitLab</p><p>应用程序数据备份会创建一个归档文件，其中包含数据库、所有Repository和所有附件。<br>您只能将备份恢复到与其创建的GitLab完全相同的版本和类型（CE / EE）。将Repository从一个服务器迁移到另一个服务器的最佳方法是通过备份还原。</p><p><img src="/images/GitLab/backup_hrz.png" alt=""></p><p><br></p><p><strong>依赖(requirements)</strong><br>为了实现备份和还原，需要在系统上安装两个工具。</p><ul><li><code>rsync</code></li><li><code>tar v1.3+</code></li></ul><p><br></p><p><strong>备份时间戳(Backup timestamp)</strong></p><blockquote><p>Note: In GitLab 9.2 the timestamp format was changed from <code>EPOCH_YYYY_MM_DD</code> to <code>EPOCH_YYYY_MM_DD_GitLab_version</code></p></blockquote><p>备份存档将保存在<code>backup_path</code>中，它在<code>config/gitlab.yml</code>文件中指定。文件名为<code>[TIMESTAMP] _gitlab_backup.tar</code>，其中TIMESTAMP标识每个备份的创建时间以及GitLab版本。如果需要还原GitLab并且有多个备份可用，则需要时间戳。</p><p><br></p><p><strong>创建备份(Creating a backup of the GitLab system)</strong></p><p>GitLab提供了一个简单的命令行接口来备份整个实例。包括：</p><ul><li>Database</li><li>Attachments</li><li>Git repositories data</li><li>CI/CD job output logs</li><li>CI/CD job artifacts</li><li>LFS objects</li><li>Container Registry images</li><li>GitLab Pages content</li></ul><blockquote><p>注意：GitLab不会备份配置文件、SSL证书、系统文件。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#omnibus</span></span><br><span class="line">sudo gitlab-rake gitlab:backup:create</span><br><span class="line"></span><br><span class="line"><span class="comment">#source</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake gitlab:backup:create RAILS_ENV=production</span><br><span class="line"></span><br><span class="line"><span class="comment">#docker</span></span><br><span class="line">docker <span class="built_in">exec</span> -t &lt;container name&gt; gitlab-rake gitlab:backup:create</span><br><span class="line"></span><br><span class="line"><span class="comment">#k8s cluster</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it &lt;gitlab task-runner pod&gt; backup-utility</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出栗子</span></span><br><span class="line">sudo gitlab-rake gitlab:backup:create</span><br><span class="line"></span><br><span class="line">Dumping database ...</span><br><span class="line">Dumping PostgreSQL database gitlabhq_production ... [DONE]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">Dumping repositories ...</span><br><span class="line"> * root/zhangbin-test ... [DONE]</span><br><span class="line">[SKIPPED] Wiki</span><br><span class="line"> * root/test02 ... [SKIPPED]</span><br><span class="line">[SKIPPED] Wiki</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">Dumping uploads ...</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">Dumping builds ...</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">Dumping artifacts ...</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">Dumping pages ...</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">Dumping lfs objects ...</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">Dumping container registry images ...</span><br><span class="line">[DISABLED]</span><br><span class="line">Creating backup archive: 1544578010_2018_12_12_11.5.1_gitlab_backup.tar ... <span class="keyword">done</span></span><br><span class="line">Uploading backup archive to remote storage  ... skipped</span><br><span class="line">Deleting tmp directories ... <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">Deleting old backups ... skipping</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">sudo ls /var/opt/gitlab/backups/</span><br><span class="line">1544578010_2018_12_12_11.5.1_gitlab_backup.tar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo tar -tvf  backups/1544578010_2018_12_12_11.5.1_gitlab_backup.tar</span><br><span class="line">drwx------ git/git           0 2018-12-12 09:26 repositories/</span><br><span class="line">drwxr-xr-x git/git           0 2018-12-12 09:26 repositories/root/</span><br><span class="line">-rw-r--r-- git/git         476 2018-12-12 09:26 repositories/root/zhangbin-test.bundle</span><br><span class="line">drwxr-xr-x git/git           0 2018-12-12 09:26 repositories/root/zhangbin-test/</span><br><span class="line">drwxr-xr-x git/git           0 2018-12-12 09:26 db/</span><br><span class="line">-rw------- git/git       84875 2018-12-12 09:26 db/database.sql.gz</span><br><span class="line">-rw------- git/git         152 2018-12-12 09:26 uploads.tar.gz</span><br><span class="line">-rw------- git/git         151 2018-12-12 09:26 builds.tar.gz</span><br><span class="line">-rw------- git/git         152 2018-12-12 09:26 artifacts.tar.gz</span><br><span class="line">-rw------- git/git         155 2018-12-12 09:26 pages.tar.gz</span><br><span class="line">-rw------- git/git         152 2018-12-12 09:26 lfs.tar.gz</span><br><span class="line">-rw-r--r-- git/git         190 2018-12-12 09:26 backup_information.yml</span><br></pre></td></tr></table></figure><p><br></p><p><strong>保存配置文件(Storing configuration files)</strong></p><ul><li>Omnibus<ul><li><code>/etc/gitlab/gitlab-secrets.json</code></li><li><code>/etc/gitlab/gitlab.rb</code></li></ul></li><li>Source<ul><li><code>/home/git/gitlab/config/secrets.yml</code></li><li><code>/home/git/gitlab/config/gitlab.yml</code></li></ul></li><li>TLS keys and certificates</li><li>SSH key</li><li>…</li></ul><p><br></p><p><strong>备份选项(Backup options)</strong><br>备份策略提供了许多可用选项。</p><ul><li>备份策略(Backup strategy option)<br>默认备份策略是使用Linux命令<code>tar</code>和<code>gzip</code>将数据从相应的数据位置流式传输到备份。这在大多数情况下都可以正常工作，但在数据快速变化时会导致问题。<br>当<code>tar</code>读取数据时数据发生变化，读取文件会发生错误，并导致备份过程失败。为了解决这个问题，<code>v8.17</code>引入了一种名为<code>copy</code>的新备份策略。该策略在调用<code>tar</code>和<code>gzip</code>之前将数据文件复制到临时位置，以避免错误。<br>副作用(side-effect)是备份过程中占用额外的磁盘空间，该过程尽最大努力在每个阶段清理临时文件，因此问题不会复杂化，但对于大型安装而言，这可能是一个相当大的变化。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用</span></span><br><span class="line">sudo gitlab-rake gitlab:backup:create STRATEGY=copy</span><br></pre></td></tr></table></figure><p><br></p><ul><li>从备份中排出特定目录(Excluding specific directories from the backup)<ul><li>db (database)</li><li>uploads (attachments)</li><li>repositories (Git repositories data)</li><li>builds (CI job output logs)</li><li>artifacts (CI job artifacts)</li><li>lfs (LFS objects)</li><li>registry (Container Registry images)</li><li>pages (Pages content)</li></ul></li></ul><p>你可以使用<code>SKIP</code>环境变量来跳过不需要备份的内容，使用逗号来分隔多个</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#栗子</span></span><br><span class="line">sudo gitlab-rake gitlab:backup:create SKIP=db,uploads</span><br></pre></td></tr></table></figure><p><br></p><ul><li>上传到本地挂载来共享(Uploading to locally mounted shares)<br>你也可以使用<code>Fog Local</code>存储提供程序将备份发送到已挂载的共享(NFS/CIFS/SMB…)。<code>local_root</code> key 指向的目录在挂载时必须由git用户拥有。<br>除<code>local_root</code> key 外，还必须设置<code>backup_upload_remote_directory</code>，这是已挂载目录中将要复制备份的子目录，如果不存在则将创建。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#Omnibus</span><br><span class="line">#vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">gitlab_rails[&apos;backup_upload_connection&apos;] = &#123;</span><br><span class="line">  :provider =&gt; &apos;Local&apos;,</span><br><span class="line">  :local_root =&gt; &apos;/mnt/backups&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># The directory inside the mounted folder to copy backups to</span><br><span class="line"># Use &apos;.&apos; to store them in the root directory</span><br><span class="line">gitlab_rails[&apos;backup_upload_remote_directory&apos;] = &apos;gitlab_backups&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#source</span><br><span class="line">#vi home/git/gitlab/config/gitlab.yml</span><br><span class="line"></span><br><span class="line">backup:</span><br><span class="line">  upload:</span><br><span class="line">    # Fog storage connection settings, see http://fog.io/storage/ .</span><br><span class="line">    connection:</span><br><span class="line">      provider: Local</span><br><span class="line">      local_root: &apos;/mnt/backups&apos;</span><br><span class="line">    # The directory inside the mounted folder to copy backups to</span><br><span class="line">    # Use &apos;.&apos; to store them in the root directory</span><br><span class="line">    remote_directory: &apos;gitlab_backups&apos;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>备份归档权限(Backup archive permissions)<br>GitLab创建的备份归档文件的默认所属用户和组为(<code>git:git</code>)，这是为了避免其它系统用户读取GitLab数据。如果你需要备份文件具有其它权限，请在配置文件中修改它：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line"><span class="comment">#/etc/gitlab/gitlab.rb</span></span><br><span class="line"></span><br><span class="line">gitlab_rails[<span class="string">'backup_archive_permissions'</span>] = 0644 <span class="comment"># Makes the backup archives world-readable</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#source</span></span><br><span class="line"><span class="comment">#/home/git/gitlab/config/gitlab.yml:</span></span><br><span class="line">backup:</span><br><span class="line">  archive_permissions: 0644 <span class="comment"># Makes the backup archives world-readable</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li>配置定时备份(Configuring cron to make daily backups)</li></ul><p>请注意，<code>backup_keep_time</code>配置选项仅管理本地文件。 GitLab不会自动清理存储在第三方对象存储（例如，AWS S3）中的旧文件，因为用户可能没有列出和删除文件的权限。建议您为对象存储配置适当的保留策略。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line"><span class="comment">#/etc/gitlab/gitlab.rb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认保留7天</span></span><br><span class="line"><span class="comment">## Limit backup lifetime to 7 days - 604800 seconds</span></span><br><span class="line">gitlab_rails[<span class="string">'backup_keep_time'</span>] = 604800</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#cron</span></span><br><span class="line">sudo su -</span><br><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line"><span class="comment">#每天2AM</span></span><br><span class="line">0 2 * * * /opt/gitlab/bin/gitlab-rake gitlab:backup:create CRON=1</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h5><p>Restore</p><p>GitLab提供了一个简单的命令行界面来恢复整个安装，并且足够灵活，可以满足您的需求。<br>您只能将备份恢复到与其创建的GitLab完全相同的版本和类型（CE / EE）。</p><p><br></p><p><strong>先决条件(prerequisites)</strong><br>在执行还原之前，您需要安装有效的GitLab。这主要是因为通常不允许执行恢复操作（<code>git</code>）的系统用户创建或删除将数据导入（<code>gitlabhq_production</code>）所需的SQL数据库。所有现有数据将被删除或移动到单独的目录。<br>要恢复备份，您还需要恢复<code>/etc/gitlab/gitlab-secrets.json</code>（Omnibus）或 <code>/home/git/gitlab/.secret</code>（Source），它包含了 database encryption key, CI/CD 变量 和 two-factor authentication的变量。如果您无法将此加密密钥文件与应用程序数据备份一起恢复，则启用了双因素身份验证的用户和GitLab Runners将无法访问您的GitLab服务器。<br>你可能还需要还原TLS keys, certificates, or SSH host keys…</p><p>根据你的情况，你可能需要使用如下选项：</p><ul><li><code>BACKUP=timestamp_of_backup</code>: 如果存在多个备份，则必需</li><li><code>force=yes</code>: 不询问<code>authorized_keys</code>文件是否应该重新生成，并假设“yes”表示将删除数据库表，启用“写入<code>authorized_keys</code>文件”设置，并更新LDAP提供程序。</li></ul><blockquote><p>注意: 如果要还原到作为挂载点的目录，则需要在尝试还原之前确保这些目录为空。否则GitLab将在恢复新数据之前尝试移动这些目录，这将导致错误。</p></blockquote><p><br></p><p><strong>还原源码安装(Source)</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Stop processes that are connected to the database</span></span><br><span class="line">sudo service gitlab stop</span><br><span class="line"></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:backup:restore RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>还原包安装(Omnibus)</strong></p><p>此过程假定：</p><ul><li>你已使用包安装相同版本的GitLab</li><li>你至少已经运行了一次<code>sudo gitlab-ctl reconfigure</code></li><li>GitLab已经运行</li></ul><p>首先确保你的备份文件已经放置到了备份目录中(默认为<code>/var/opt/gitlab/backups</code>)，并将其所属用户和组修改为<code>git:git</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#复制备份文件</span></span><br><span class="line">sudo cp 11493107454_2018_04_25_10.6.4-ce_gitlab_backup.tar /var/opt/gitlab/backups/</span><br><span class="line">sudo chown git.git /var/opt/gitlab/backups/11493107454_2018_04_25_10.6.4-ce_gitlab_backup.tar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#暂停程序与数据库的连接</span></span><br><span class="line">sudo gitlab-ctl stop unicorn</span><br><span class="line">sudo gitlab-ctl stop sidekiq</span><br><span class="line"><span class="comment"># Verify</span></span><br><span class="line">sudo gitlab-ctl status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#还原</span></span><br><span class="line"><span class="comment"># This command will overwrite the contents of your GitLab database!</span></span><br><span class="line">sudo gitlab-rake gitlab:backup:restore BACKUP=1493107454_2018_04_25_10.6.4-ce</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重启和检查</span></span><br><span class="line">sudo gitlab-ctl restart</span><br><span class="line">sudo gitlab-rake gitlab:check SANITIZE=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>还原Docker</strong><br>对于使用Docker或可k8s安装的GitLab，还原期望还原的目录为空。然而，使用Docker和k8s volume 挂载时，可能会在Volume根下创建一些系统级的目录(如: <code>lost+found</code>)。这些目录通常由root拥有，可能会导致访问权限错误。因为还原操作是以<code>git</code>用户运行。因此，要还原GitLab，请确保还原的目标目录为空。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Docker</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;name of container&gt; gitlab-rake gitlab:backup:restore</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="其它备份策略"><a href="#其它备份策略" class="headerlink" title="其它备份策略"></a>其它备份策略</h5><p>Alternative backup strategies</p><p>如果您的GitLab服务器包含大量Git Repository数据，您可能会发现GitLab备份脚本太慢。在这种情况下，您可以考虑使用文件系统快照作为备份策略的一部分。</p><ul><li>LVM snapshots + rsync<br>建立一个临时的LVM快照，将它作为只读文件系统挂载到<code>/mnt/gitlab_backup</code>。现在我们可以有一个更长的rsync作业，它将在远程Server创建一致的副本。</li></ul><p><br><br><br></p><h5 id="完整性检查"><a href="#完整性检查" class="headerlink" title="完整性检查"></a>完整性检查</h5><p>Integrity Check</p><p><br></p><p><strong>仓库完整性(Repository Integrity)</strong></p><p>即使Git非常有弹性并试图防止数据完整性问题，但有时候仍会出现问题。以下Rake task 旨在帮助GitLab管理员诊断问题 Repo，以便修复它们。</p><ul><li>Git repository file system check</li><li>Check for <code>config.lock</code> in the repository directory</li><li>Check for any <code>branch/references</code> lock files in <code>refs/heads</code></li></ul><p>以下症状可能表示Repo完整性存在问题：</p><ul><li>Receiving an error when trying to push code - <code>remote: error: cannot lock ref</code></li><li>A 500 error when viewing the GitLab dashboard or when accessing a specific project</li></ul><p><br></p><p><strong>检查所有GitLab Repo完整性</strong></p><p>此任务循环遍历GitLab服务器上的所有存储库，并运行前面描述的完整性检查。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line">sudo gitlab-rake gitlab:git:fsck</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#source</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake gitlab:git:fsck RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>上传的文件完整性(Uploaded Files Integrity)</strong></p><p>用户可以将各种类型的文件上传到GitLab上。此外，这些完整性检查可以检测丢失的文件。对于本地存储的文件，在上传时生成校验和(checksum)并将其存储在数据库中，并且这些检查将针对当前文件验证它们。<br>目前，支持一下类型文件的完整性检查：</p><ul><li>CI artifacts</li><li>LFS objects</li><li>User uploads</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line">sudo gitlab-rake gitlab:artifacts:check</span><br><span class="line">sudo gitlab-rake gitlab:lfs:check</span><br><span class="line">sudo gitlab-rake gitlab:uploads:check</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Source</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake gitlab:artifacts:check RAILS_ENV=production</span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake gitlab:lfs:check RAILS_ENV=production</span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake gitlab:uploads:check RAILS_ENV=production</span><br></pre></td></tr></table></figure><p>这些任务还接受一些环境变量，您可以使用这些变量来覆盖某些值：</p><table><thead><tr><th>Variable</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>BATCH</td><td>integer</td><td>Specifies the size of the batch. Defaults to 200.</td></tr><tr><td>ID_FROM</td><td>integer</td><td>Specifies the ID to start from, inclusive of the value.</td></tr><tr><td>ID_TO</td><td>integer</td><td>Specifies the ID value to end at, inclusive of the value.</td></tr><tr><td>VERBOSE</td><td>boolean</td><td>Causes failures to be listed individually, rather than being summarized.</td></tr></tbody></table><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#栗子</span></span><br><span class="line">sudo gitlab-rake gitlab:artifacts:check BATCH=100 ID_FROM=50 ID_TO=250</span><br><span class="line">sudo gitlab-rake gitlab:lfs:check BATCH=100 ID_FROM=50 ID_TO=250</span><br><span class="line">sudo gitlab-rake gitlab:uploads:check BATCH=100 ID_FROM=50 ID_TO=250</span><br></pre></td></tr></table></figure><p><br></p><p><strong>LDAP检查</strong></p><p><br><br><br></p><h5 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h5><p>Cleanup</p><p><br></p><p><strong>从文件系统移除垃圾(Remove garbage from filesystem. Important! Data loss!)</strong></p><p>如果GitLab数据库中不存在 namespace（dirs），则从所有Repo存储路径中删除它们。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:cleanup:<span class="built_in">dirs</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># installation from source</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:cleanup:<span class="built_in">dirs</span> RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p>如果GitLab数据库中不存在Repo，则从所有Repo存储路径重命名存储库。Repo获得一个<code>+orphaned+TIMESTAMP</code>后缀，以便他们无法阻止新Repo的创建。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:cleanup:repos</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># installation from source</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:cleanup:repos RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p>如果GitLab数据库中不存在本地项目上传文件，请将其清除。该任务尝试修复文件，如果它可以找到它的项目，否则它将文件移动到丢失和找到的目录。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:cleanup:project_uploads</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># installation from source</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:cleanup:project_uploads RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p>如果GitLab数据库中不存在对象存储上载文件，请将其删除。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:cleanup:remote_upload_files</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># installation from source</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:cleanup:remote_upload_files RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>Namespaces</p><p><strong>为用户项目启用用户名和命名空间(Enable usernames and namespaces for user projects)</strong></p><p>此命令启动命名空间，它将移动其命名空间文件夹中的每个项目。<br>注意：</p><ul><li>由于Repo Location发生改变，因此你需要更新git URL以指向新地址</li><li>用户名可在Profile中修改</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#栗子</span><br><span class="line"></span><br><span class="line">#Old path</span><br><span class="line">git@example.org:myrepo.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#new path</span><br><span class="line">git@example.org:username/myrepo.git</span><br><span class="line">#or</span><br><span class="line">git@example.org:groupname/myrepo.git</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h5><p>LDAP Rake Tasks</p><p><strong>检查(Check)</strong></p><p>LDAP检查Rake task 将测试<code>bind_dn</code>和<code>password</code>凭据（如果已配置），并将列出LDAP用户的示例。此任务作为<code>gitlab:check</code>任务的一部分执行，但可以使用以下命令单独运行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibush</span></span><br><span class="line">sudo gitlab-rake gitlab:ldap:check</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Source</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake gitlab:ldap:check RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>重命名提供商(Rename a provider)</strong></p><p>如果更改了配置文件中的LDAP Server ID，则需要更新所有用户标识，否则将无法登录。输入旧的和新的提供商，此任务将更新数据库中的所有匹配标识。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#栗子</span></span><br><span class="line"><span class="comment">#main是LDAP Server ID</span></span><br><span class="line"><span class="attr">main:</span></span><br><span class="line"><span class="attr">  label:</span> <span class="string">'LDAP'</span></span><br><span class="line"><span class="attr">  host:</span> <span class="string">'_your_ldap_server'</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">389</span></span><br><span class="line"><span class="attr">  uid:</span> <span class="string">'sAMAccountName'</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line">sudo gitlab-rake gitlab:ldap:rename_provider[old_provider,new_provider]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Source</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:ldap:rename_provider[old_provider,new_provider] RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="一般维护和自检"><a href="#一般维护和自检" class="headerlink" title="一般维护和自检"></a>一般维护和自检</h5><p><strong>收集有关GitLab及其运行的系统的信息</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line">sudo gitlab-rake gitlab:env:info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Source</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:env:info RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>检查GitLab配置</strong></p><p>运行以下<code>rake tasks</code>：</p><ul><li><code>gitlab:gitlab_shell:check</code></li><li><code>gitlab:gitaly:check</code></li><li><code>gitlab:sidekiq:check</code></li><li><code>gitlab:app:check</code></li></ul><p>它将检查每个组件是否已根据安装指南进行设置，并针对发现的问题提出修复建议。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line">sudo gitlab-rake gitlab:check</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Source</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:check RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>重建authorized_keys文件</strong></p><p>在某些情况下，有必要重建authorized_keys文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line">sudo gitlab-rake gitlab:shell:setup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Source</span></span><br><span class="line"><span class="built_in">cd</span> /home/git/gitlab</span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake gitlab:shell:setup RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>清理Redis缓存</strong></p><p>如果由于某种原因，仪表板显示错误信息，您可能希望清除Redis的缓存。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line">sudo gitlab-rake cache:clear</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Source</span></span><br><span class="line"><span class="built_in">cd</span> /home/git/gitlab</span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake cache:clear RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>跟踪部署(Tracking Deployments)</strong></p><p>GitLab提供了一个Rake task，可以让您跟踪GitLab性能监控中的部署。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line">sudo gitlab-rake gitlab:track_deployment</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Source</span></span><br><span class="line"><span class="built_in">cd</span> /home/git/gitlab</span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake gitlab:track_deployment RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>创建或修复Repo hook符号链接(Create or repair repository hooks symlink)</strong></p><p>如果GitLab shell hooks 目录位置更改或其他情况导致hooks符号链接丢失或无效，请运行此Rake task以创建或修复符号链接。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line">sudo gitlab-rake gitlab:shell:create_hooks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Source</span></span><br><span class="line"><span class="built_in">cd</span> /home/git/gitlab</span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake gitlab:shell:create_hooks RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>检查TCP连接(Check TCP connectivity to a remote site)</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line">sudo gitlab-rake gitlab:tcp_check[example.com,80]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Source</span></span><br><span class="line"><span class="built_in">cd</span> /home/git/gitlab</span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake gitlab:tcp_check[example.com,80] RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h5><p>User management</p><p><strong>将用户作为开发人员添加到所有项目中</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:import:user_to_projects[username@domain.tld]</span><br><span class="line"></span><br><span class="line"><span class="comment"># installation from source</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:import:user_to_projects[username@domain.tld] RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>将所有用户添加到所有项目</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:import:all_users_to_all_projects</span><br><span class="line"></span><br><span class="line"><span class="comment"># installation from source</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:import:all_users_to_all_projects RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>将用户作为开发人员添加到所有组</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:import:user_to_groups[username@domain.tld]</span><br><span class="line"></span><br><span class="line"><span class="comment"># installation from source</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:import:user_to_groups[username@domain.tld] RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>将所有用户添加到所有组</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:import:all_users_to_all_groups</span><br><span class="line"></span><br><span class="line"><span class="comment"># installation from source</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:import:all_users_to_all_groups RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>保持对GitLab上活跃用户数量的严格控制</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启用此设置可以阻止新用户被管理员清除(默认：false)</span></span><br><span class="line">block_auto_created_users: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>禁用所有用户的双重验证（2FA）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:two_factor:disable_for_all_users</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># installation from source</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:two_factor:disable_for_all_users RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>轮询双重认证的加密秘钥(Rotate Two-factor Authentication (2FA) encryption key)</strong></p><p>GitLab存储secret data，使双重认证(2FA)能够在加密的数据库列中工作。此数据的加密密钥称为<code>otp_key_base</code>，存储在<code>config/secrets.yml</code>中。<br>如果该文件被泄露，但个别2FA secret 没有泄露，则可以使用新的加密密钥重新加密这些机密。这允许您更改泄漏的密钥，而不强制所有用户更改其<code>2FA</code>详细信息。</p><ul><li>首先，查找old key。这是在<code>config/secrets.yml</code>文件中，但请确保您正在使用生产部分：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">production:</span></span><br><span class="line"><span class="attr">  otp_key_base:</span> <span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br></pre></td></tr></table></figure><ul><li>生成new secret</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake secret</span><br><span class="line"></span><br><span class="line"><span class="comment"># installation from source</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake secret RAILS_ENV=production</span><br></pre></td></tr></table></figure><ul><li>现在您需要停止GitLab服务器，备份现有的secrets file并更新数据库：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-ctl stop</span><br><span class="line">sudo cp config/secrets.yml config/secrets.yml.bak</span><br><span class="line">sudo gitlab-rake gitlab:two_factor:rotate_key:apply filename=backup.csv old_key=&lt;old key&gt; new_key=&lt;new key&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># installation from source</span></span><br><span class="line">sudo /etc/init.d/gitlab stop</span><br><span class="line">cp config/secrets.yml config/secrets.yml.bak</span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:two_factor:rotate_key:apply filename=backup.csv old_key=&lt;old key&gt; new_key=&lt;new key&gt; RAILS_ENV=production</span><br></pre></td></tr></table></figure><ul><li>最后，将<code>config/secrets.yml</code>中的<code>otp_key_base</code>更改为<code>&lt;new key&gt;</code>并重新启动。再次，确保您在生产部分中运行：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先更改key</span></span><br><span class="line"><span class="comment">#之后重启</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-ctl start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># installation from source</span></span><br><span class="line">sudo /etc/init.d/gitlab start</span><br></pre></td></tr></table></figure><p>如果出现问题，你也可以进行回滚。</p><p><br><br><br></p><h5 id="Webhooks"><a href="#Webhooks" class="headerlink" title="Webhooks"></a>Webhooks</h5><p><strong>为所有项目添加webhook</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:web_hook:add URL=<span class="string">"http://example.com/hook"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># source installations</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:web_hook:add URL=<span class="string">"http://example.com/hook"</span> RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><strong>为给定NAMESPACE中的项目添加webhook</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:web_hook:add URL=<span class="string">"http://example.com/hook"</span> NAMESPACE=acme</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># source installations</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:web_hook:add URL=<span class="string">"http://example.com/hook"</span> NAMESPACE=acme RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>从所有项目中删除webhook</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:web_hook:rm URL=<span class="string">"http://example.com/hook"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># source installations</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:web_hook:rm URL=<span class="string">"http://example.com/hook"</span> RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>从给定NAMESPACE中的项目中删除webhook：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:web_hook:rm URL=<span class="string">"http://example.com/hook"</span> NAMESPACE=acme</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># source installations</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:web_hook:rm URL=<span class="string">"http://example.com/hook"</span> NAMESPACE=acme RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>列出所有webhooks：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:web_hook:list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># source installations</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:web_hook:list RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>列出给定NAMESPACE中项目的webhooks</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># omnibus-gitlab</span></span><br><span class="line">sudo gitlab-rake gitlab:web_hook:list NAMESPACE=acme</span><br><span class="line"><span class="comment"># source installations</span></span><br><span class="line">bundle <span class="built_in">exec</span> rake gitlab:web_hook:list NAMESPACE=acme RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="批量导入git库"><a href="#批量导入git库" class="headerlink" title="批量导入git库"></a>批量导入git库</h5><p>Import of git repositories in bulk</p><p><strong>注意：</strong></p><ul><li>The owner of the project will be the first admin</li><li>The groups will be created as needed, including subgroups</li><li>The owner of the group will be the first admin</li><li>Existing projects will be skipped</li><li>Projects in hashed storage may be skipped</li><li>The existing Git repos will be moved from disk</li></ul><p><br></p><p><strong>如何使用：</strong></p><ul><li>创建一个新文件夹以从中导入您的Git Repo：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注意owner, group, permission</span></span><br><span class="line">sudo -u git mkdir /var/opt/gitlab/git-data/repository-import-&lt;date&gt;/new_group</span><br></pre></td></tr></table></figure><ul><li>将Repo复制到新创建的文件夹中<br>在任何子文件夹中找到的任何<code>.git</code> Repo 都将作为项目导入。<br>将根据需要创建group</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -r /old/git/foo.git /var/opt/gitlab/git-data/repository-import-&lt;date&gt;/new_group/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do this once when you are done copying git repositories</span></span><br><span class="line">sudo chown -R git:git /var/opt/gitlab/git-data/repository-import-&lt;date&gt;</span><br></pre></td></tr></table></figure><ul><li>运行命令</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line">sudo gitlab-rake gitlab:import:repos[<span class="string">'/var/opt/gitlab/git-data/repository-import-&lt;date&gt;'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Source</span></span><br><span class="line"><span class="built_in">cd</span> /home/git/gitlab</span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake gitlab:import:repos[<span class="string">'/var/opt/gitlab/git-data/repository-import-&lt;date&gt;'</span>] RAILS_ENV=production</span><br></pre></td></tr></table></figure><p><br></p><p><strong>从<code>hashed storage</code>导入Repo</strong></p><p>背景： 传统存储中的项目具有一个目录结构，该结构反映了GitLab中的完整项目路径，包括其命名空间结构。Repo导入程序利用此信息将项目导入其适当的位置。每个项目及其父命名空间都有名称。<br>但是，散列存储中的项目的目录结构不包含此信息。这有利于各种原因，尤其是改进的性能和数据完整性。</p><ul><li>GitLab v10.3 or earlier: 不支持导入<code>hashed storage</code></li><li>GitLab v10.4 and later: 为了支持从散列存储导入裸存储库，GitLab将每个存储库的完整项目路径存储在git Repo 配置文件的特殊部分中。</li></ul><p>如果Repo发生以下事件，则可导入：</p><ul><li>Created</li><li>Migrated to hashed storage</li><li>Renamed</li><li>Transferred to another namespace</li><li>Ancestor renamed</li><li>Ancestor transferred to another namespace</li></ul><p>满足以下内容，Repo无法导入：</p><ul><li>It was created in GitLab 10.3 or earlier.</li><li>It was not renamed, transferred, or migrated to hashed storage in GitLab 10.4 and later.</li><li>Its ancestor namespaces were not renamed or transferred in GitLab 10.4 and later.</li></ul><p>你也可以手动使用 Rails console 执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># start a Rails console for GitLab</span><br><span class="line">sudo gitlab-rails console</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">project = Project.find_by_full_path(&apos;gitlab-org/gitlab-ce&apos;)</span><br><span class="line">project.write_repository_config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在Rails控制台会话中，运行以下命令以迁移所有命名空间的项目</span><br><span class="line">namespace = Namespace.find_by_full_path(&apos;gitlab-org&apos;)</span><br><span class="line">namespace.send(:write_projects_repository_config)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h5><p>Uploads</p><blockquote><p><strong>注意：</strong> 上传表示可以作为单个文件(single file)发送到GitLab的所有用户数据。例如，头像和附注的附件是上传的。上传是GitLab功能的组成部分，因此无法禁用。</p></blockquote><p><strong>使用本地存储(Local Storage)</strong><br>这是默认选项。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line"><span class="comment">#上传默认存放位置： /var/opt/gitlab/gitlab-rails/uploads/-/system</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改</span></span><br><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gitlab_rails[<span class="string">'uploads_storage_path'</span>] = <span class="string">"/mnt/storage/"</span></span><br><span class="line">gitlab_rails[<span class="string">'uploads_base_dir'</span>] = <span class="string">"uploads"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Source</span></span><br><span class="line"><span class="comment">#默认存放位置：/home/git/gitlab/public/uploads/-/system</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改</span></span><br><span class="line">vi /home/git/gitlab/config/gitlab.yml</span><br><span class="line"></span><br><span class="line">uploads:</span><br><span class="line">  storage_path: /mnt/storage</span><br><span class="line">  base_dir: uploads</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用对象存储(Object Storage)</strong></p><p>如果不想使用本地存储，可使用对象存储(华为云、阿里云、腾讯云、aws…)。<br>GitLab有几个选项，其它云服务商的配置请参考他们的文档。</p><table><thead><tr><th><code>uploads_object_store_</code></th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>enabled</code></td><td>Enable/disable object storage</td><td>false</td></tr><tr><td><code>remote_directory</code></td><td>The bucket name where Uploads will be stored</td><td></td></tr><tr><td><code>direct_upload</code></td><td>Set to true to enable direct upload of Uploads without the need of local shared storage. Option may be removed once we decide to support only single storage for all files.</td><td>false</td></tr><tr><td><code>background_upload</code></td><td>Set to false to disable automatic upload. Option may be removed once upload is direct to S3</td><td>true</td></tr><tr><td><code>proxy_download</code></td><td>Set to true to enable proxying all files served. Option allows to reduce egress traffic as this allows clients to download directly from remote storage instead of proxying all data</td><td>false</td></tr><tr><td><code>connection</code></td><td>Various connection options described below</td></tr></tbody></table><p><br><br><br></p><p>#####　迁移上传文件</p><p>Migrate Uploads</p><p><strong>迁移到对象存储(Migrate to Object Storage)</strong></p><p>为GitLab的上传配置对象存储之后，您可以使用此任务将现有的上传文件从本地存储迁移到远程存储。</p><ul><li>All-in-one rake task<br>GitLab提供了一个 wrapper rake task，可以将所有上传的文件（头像，徽标，附件，图标等）一次性迁移到对象存储。在此之下，它会调用各个rake task来逐个迁移属于这个类别的文件。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line">gitlab-rake <span class="string">"gitlab:uploads:migrate:all"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Source</span></span><br><span class="line">sudo RAILS_ENV=production -u git -H bundle <span class="built_in">exec</span> rake gitlab:uploads:migrate:all</span><br></pre></td></tr></table></figure><ul><li>Individual rake tasks<br>如果您已经运行了前面提到的rake task，则无需像自动完成那样运行这些单独的rake task。</li></ul><p>rake task使用3个参数来查找要迁移的上传：</p><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>uploader_class</code></td><td>string</td><td>Type of the uploader to migrate from</td></tr><tr><td><code>model_class</code></td><td>string</td><td>Type of the model to migrate from</td></tr><tr><td><code>mount_point</code></td><td>string/symbol</td><td>Name of the model’s column on which the uploader is mounted on.</td></tr></tbody></table><p>注意：这些参数主要是GitLab结构的内部参数，您可能需要在下面引用任务列表。<br>此任务还接受一些可用于覆盖某些值的环境变量：</p><table><thead><tr><th>Variable</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>BATCH</td><td>integer</td><td>Specifies the size of the batch. Defaults to 200.</td></tr></tbody></table><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gitlab-rake gitlab:uploads:migrate[uploader_class, model_class, mount_point]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Avatars</span></span><br><span class="line">gitlab-rake <span class="string">"gitlab:uploads:migrate[AvatarUploader, Project, :avatar]"</span></span><br><span class="line">gitlab-rake <span class="string">"gitlab:uploads:migrate[AvatarUploader, Group, :avatar]"</span></span><br><span class="line">gitlab-rake <span class="string">"gitlab:uploads:migrate[AvatarUploader, User, :avatar]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Attachments</span></span><br><span class="line">gitlab-rake <span class="string">"gitlab:uploads:migrate[AttachmentUploader, Note, :attachment]"</span></span><br><span class="line">gitlab-rake <span class="string">"gitlab:uploads:migrate[AttachmentUploader, Appearance, :logo]"</span></span><br><span class="line">gitlab-rake <span class="string">"gitlab:uploads:migrate[AttachmentUploader, Appearance, :header_logo]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Favicon</span></span><br><span class="line">gitlab-rake <span class="string">"gitlab:uploads:migrate[FaviconUploader, Appearance, :favicon]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Markdown</span></span><br><span class="line">gitlab-rake <span class="string">"gitlab:uploads:migrate[FileUploader, Project]"</span></span><br><span class="line">gitlab-rake <span class="string">"gitlab:uploads:migrate[PersonalFileUploader, Snippet]"</span></span><br><span class="line">gitlab-rake <span class="string">"gitlab:uploads:migrate[NamespaceFileUploader, Snippet]"</span></span><br><span class="line">gitlab-rake <span class="string">"gitlab:uploads:migrate[FileUploader, MergeRequest]"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Source</span></span><br><span class="line"><span class="comment">#Use RAILS_ENV=production for every task.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sudo -u git -H bundle exec rake gitlab:uploads:migrate</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Avatars</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake <span class="string">"gitlab:uploads:migrate[AvatarUploader, Project, :avatar]"</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake <span class="string">"gitlab:uploads:migrate[AvatarUploader, Group, :avatar]"</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake <span class="string">"gitlab:uploads:migrate[AvatarUploader, User, :avatar]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Attachments</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake <span class="string">"gitlab:uploads:migrate[AttachmentUploader, Note, :attachment]"</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake <span class="string">"gitlab:uploads:migrate[AttachmentUploader, Appearance, :logo]"</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake <span class="string">"gitlab:uploads:migrate[AttachmentUploader, Appearance, :header_logo]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Favicon</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake <span class="string">"gitlab:uploads:migrate[FaviconUploader, Appearance, :favicon]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Markdown</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake <span class="string">"gitlab:uploads:migrate[FileUploader, Project]"</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake <span class="string">"gitlab:uploads:migrate[PersonalFileUploader, Snippet]"</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake <span class="string">"gitlab:uploads:migrate[NamespaceFileUploader, Snippet]"</span></span><br><span class="line">sudo -u git -H bundle <span class="built_in">exec</span> rake <span class="string">"gitlab:uploads:migrate[FileUploader, MergeRequest]"</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>Performing Operations in GitLab<br>Operations: Keeping GitLab up and running (clean up Redis sessions, moving repositories, Sidekiq MemoryKiller, Unicorn)</p><p><br></p><h5 id="清理陈旧的Redis回话"><a href="#清理陈旧的Redis回话" class="headerlink" title="清理陈旧的Redis回话"></a>清理陈旧的Redis回话</h5><p>Cleaning up stale Redis sessions</p><p>在GitLab v7.3之前，用户会话不会自动从Redis expire。</p><p><br><br><br></p><h5 id="移动库"><a href="#移动库" class="headerlink" title="移动库"></a>移动库</h5><p>Moving repositories</p><p>将GitLab管理的所有库移动到另一个文件系统或另一个服务器。</p><p><br><br><br></p><h5 id="Sidekiq-MemoryKiller"><a href="#Sidekiq-MemoryKiller" class="headerlink" title="Sidekiq MemoryKiller"></a>Sidekiq MemoryKiller</h5><p>配置Sidekiq MemoryKiller以重启Sidekiq。</p><p>GitLab Rails应用程序代码有内存泄漏。对于Web请求，使用<code>unicorn-worker-killer</code>可以管理这个问题，在需要时会在请求之间重新启动Unicorn工作进程。 <code>Sidekiq MemoryKiller</code>对GitLab用于处理后台作业的Sidekiq进程应用相同的方法。</p><p>与自从GitLab 6.4以来默认启用的所有GitLab安装的<code>unicorn-worker-killer</code>不同，<code>Sidekiq MemoryKiller</code>默认仅对Omnibus软件包启用。原因是MemoryKiller依赖于Runit在内存引发的关闭后重新启动Sidekiq，并且来自源的GitLab安装并不都使用Runit或等效的。</p><p>使用默认设置，<code>MemoryKiller</code>将导致Sidekiq重启频率不超过每15分钟一次，重启会导致传入后台作业延迟大约一分钟。</p><p><br></p><p><strong>配置MemoryKiller</strong><br>MemoryKiller使用环境变量进行控制。</p><ul><li><p><code>SIDEKIQ_MEMORY_KILLER_MAX_RSS</code><br>如果设置了此变量，并且其值大于0，则在每个Sidekiq作业之后，MemoryKiller将检查执行该作业的Sidekiq进程的RSS。如果Sidekiq进程的RSS（KB）超过SIDEKIQ_MEMORY_KILLER_MAX_RSS，则会触发延迟关闭。<br>默认值可在<code>gitlab.rb</code>当中查看。</p></li><li><p><code>SIDEKIQ_MEMORY_KILLER_GRACE_TIME</code><br>默认为900s（15min）。当触发关闭时，Sidekiq进程将继续正常工作15分钟。</p></li><li><p><code>SIDEKIQ_MEMORY_KILLER_SHUTDOWN_WAIT</code><br>默认为30秒。当宽限时间到期时，MemoryKiller告诉Sidekiq停止接受新的工作，现有工作有30s去完成。之后，MemoryKiller告诉Sidekiq去关闭，外部监督机制必须重启Sidekiq</p></li></ul><p><br><br><br></p><h5 id="Unicorn"><a href="#Unicorn" class="headerlink" title="Unicorn"></a>Unicorn</h5><p>Understand Unicorn and unicorn-worker-killer</p><p><strong>Unicorn</strong><br>GitLab使用Unicorn，一个pre-forking的Ruby Web服务器来处理Web请求。Unicorn是一个用Ruby和C编写的Daemon，可以加载和运行Ruby on Rails Application(如GitLab CE/EE)。</p><p>Unicorn具有多进程(multi-process)架构，可以更好地利用可用的CPU核心并具有更强的容错能力。在启动时，Unicorn的Master进程使用GitLab应用程序代码加载一个干净的Ruby环境，然后生成继承这个干净的初始环境的Worker。 Master永远不会处理任何请求，而是留给Worker。操作系统网络堆栈对传入的请求进行排队，并在Worker之间分配它们。</p><p>Unicorn的主要可调参数(Tunables)是工作进程(work process)的数量和请求超时(request timeout)。</p><p><br></p><p><strong>unicorn-worker-killer</strong></p><p>GitLab存在内存泄漏。这些内存泄漏在长期运行的进程中表现出来，如Unicorn worker。<br>为了使这些内存泄漏易于管理，GitLab附带了<code>unicorn-worker-killer</code>。这个gem修补了Unicorn工作人员在每16个请求后进行内存自检。如果Unicorn工作程序的内存超过预设限制，则工作进程退出。然后Unicorn Master自动替换Wroker。<br>这是一种处理内存泄漏的强大方法：Unicorn旨在处理“崩溃”的Worker，因此不会丢弃任何用户请求。<code>unicorn-worker-killer</code> gem旨在仅在请求之间终止工作进程，因此不会影响用户请求。</p><p><br><br><br></p><h5 id="加快SSH操作"><a href="#加快SSH操作" class="headerlink" title="加快SSH操作"></a>加快SSH操作</h5><p>Speed up SSH operations by Authorizing SSH users via a fast, indexed lookup to the GitLab database, and/or by doing away with user SSH keys stored on GitLab entirely in favor of SSH certificates.</p><p><strong>快速查找数据库中的授权SSH密钥(Fast lookup of authorized SSH keys in the database)</strong></p><p><a href="https://docs.gitlab.com/ce/administration/operations/fast_ssh_key_lookup.html" target="_blank" rel="noopener">https://docs.gitlab.com/ce/administration/operations/fast_ssh_key_lookup.html</a></p><p><br></p><p><strong>通过Open SSH查找(User lookup via OpenSSH’s AuthorizedPrincipalsCommand)</strong></p><p><a href="https://docs.gitlab.com/ce/administration/operations/ssh_certificates.html" target="_blank" rel="noopener">https://docs.gitlab.com/ce/administration/operations/ssh_certificates.html</a></p><p><br><br><br></p><h5 id="文件系统性能基准测试"><a href="#文件系统性能基准测试" class="headerlink" title="文件系统性能基准测试"></a>文件系统性能基准测试</h5><p>Filesystem Performance Benchmarking</p><p>文件系统性能对整体GitLab性能有很大影响，特别是对于读取或写入Git Repo的操作。</p><p><strong>写性能(Write Performance)</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入Repo root path</span></span><br><span class="line"><span class="built_in">cd</span> /var/opt/gitlab/git-data/repositories/<span class="built_in">test</span>/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个空目录，便于测试后删除</span></span><br><span class="line">mkdir <span class="built_in">test</span> &amp;&amp; <span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行命令</span></span><br><span class="line">time <span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..1000&#125;; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">'test'</span> &gt; <span class="string">"test<span class="variable">$&#123;i&#125;</span>.txt"</span>; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除测试目录</span></span><br><span class="line"><span class="built_in">cd</span> .. &amp;&amp; rm -rf ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>以下是消耗时间范围：</p><table><thead><tr><th>Rating</th><th>Benchmark result</th></tr></thead><tbody><tr><td>Best</td><td>Less than 10 seconds</td></tr><tr><td>OK</td><td>10-18 seconds</td></tr><tr><td>Poor</td><td>18-25 seconds</td></tr><tr><td>Very poor</td><td>Greater than 25 seconds</td></tr></tbody></table><p><br><br><br><br><br></p><h4 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h4><p>Restart GitLab: Learn how to restart GitLab and its components</p><p>依据安装方式，有几种不同的方式：</p><ul><li>Omnibus GitLab restartGitLab Workhorse<ul><li>Sidekiq</li><li>PostgreSQL (if you are using the bundled one)</li><li>NGINX (if you are using the bundled one)</li><li>Redis (if you are using the bundled one)</li><li>Mailroom</li><li>Logrotate</li></ul></li><li>Omnibus GitLab reconfigure</li><li>Source installation restart</li></ul><p><br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus GitLab restart</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#GitLab</span></span><br><span class="line">sudo gitlab-ctl restart</span><br><span class="line"></span><br><span class="line"><span class="comment">#Nginx组件</span></span><br><span class="line">sudo gitlab-ctl restart nginx</span><br><span class="line"><span class="comment">#其它组件类似</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#GitLab Status</span></span><br><span class="line">sudo gitlab-ctl status</span><br><span class="line"></span><br><span class="line"><span class="comment">#Nginx组件状态</span></span><br><span class="line">sudo gitlab-ctl status nginx</span><br><span class="line"><span class="comment">#其它组件类似</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#有时，组件在重新启动期间会超时，有时会卡住</span></span><br><span class="line"><span class="comment">#你可以发送kill信号</span></span><br><span class="line">gitlab-ctl <span class="built_in">kill</span> &lt;service&gt;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus GitLab reconfigure</span></span><br><span class="line"><span class="comment">#在更改/etc/gitlab/gitlab.rb之后，需要重新配置GitLab</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Installations from source</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo service gitlab restart</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h3><p>Updating GitLab</p><p><br></p><h4 id="GitLab版本和维护策略"><a href="#GitLab版本和维护策略" class="headerlink" title="GitLab版本和维护策略"></a>GitLab版本和维护策略</h4><p>GitLab versions and maintenance policy: Understand GitLab versions and releases (Major, Minor, Patch, Security), as well as update recommendations.</p><p>GitLab releases:</p><ul><li>Major version: 主要版本，重要内容</li><li>Minor verson: 次要版本，小功能</li><li>Patch number: 补丁，fix bug</li><li>Security: 安全，临时添加的安全补丁</li></ul><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#栗子</span><br><span class="line">GitLab v10.5.7</span><br><span class="line"></span><br><span class="line">#10 represents major version</span><br><span class="line">#5 represents minor version</span><br><span class="line">#7 represents patch number</span><br></pre></td></tr></table></figure><p><br></p><p><strong>升级建议:</strong></p><p>GitLab鼓励每个人运行最新的稳定版本(latest stable release)，以确保您可以轻松升级到最安全，功能最丰富的GitLab体验。<br>如果您无法遵循GitLab的月度发布周期，则需要考虑几种情况：</p><p>在一个主要版本(Major)中升级补丁版本(Patch)和次要版本(Minor)被认为是安全的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#Upgrade the patch version:</span><br><span class="line">8.9.0 -&gt; 8.9.7</span><br><span class="line">8.9.0 -&gt; 8.9.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Upgrade the minor version:</span><br><span class="line">8.9.4 -&gt; 8.12.3</span><br><span class="line">9.2.3 -&gt; 9.5.5</span><br></pre></td></tr></table></figure><p>升级主要版本需要多加小心。GitLab无法保证主要版本之间的升级是无缝的。<br>GitLab建议您首先升级到主要版本中的最新可用次要版本。通过执行此操作，您可以解决可能会在下一个主要版本中更改行为的任何弃用消息。</p><table><thead><tr><th>Latest stable version</th><th>Your version</th><th>Recommended upgrade path</th><th>Note</th></tr></thead><tbody><tr><td><code>9.4.5</code></td><td><code>8.13.4</code></td><td><code>8.13.4</code> -&gt; <code>8.17.7</code> -&gt; <code>9.4.5</code></td><td><code>8.17.7</code> is the last version in version 8</td></tr><tr><td><code>10.1.4</code></td><td><code>8.13.4</code></td><td><code>8.13.4</code> -&gt; <code>8.17.7</code> -&gt; <code>9.5.10</code> -&gt; <code>10.1.4</code></td><td><code>8.17.7</code> is the last version in version 8, 9.5.10 is the last version in version 9</td></tr><tr><td><code>11.3.4</code></td><td><code>8.13.4</code></td><td><code>8.13.4</code> -&gt; <code>8.17.7</code> -&gt; <code>9.5.10</code> -&gt; <code>10.8.7</code> -&gt; <code>11.3.4</code></td><td><code>8.17.7</code> is the last version in version 8, 9.5.10 is the last version in version 9, 10.8.7 is the last version in version 10</td></tr></tbody></table><p><br><br><br></p><h4 id="更新GitLab"><a href="#更新GitLab" class="headerlink" title="更新GitLab"></a>更新GitLab</h4><p>Update GitLab: Update guides to upgrade your installation to a new version.</p><p>根据安装方式与GitLab版本，有多种升级方法：</p><ul><li>Omnibus packages</li><li>Source installation</li><li>Docker installation</li></ul><p><br></p><h5 id="使用软件包的方式进行更新"><a href="#使用软件包的方式进行更新" class="headerlink" title="使用软件包的方式进行更新"></a>使用软件包的方式进行更新</h5><p>Updating GitLab installed with the Omnibus GitLab package</p><p><br></p><p><strong>特定版本:</strong></p><ul><li>GitLab 11</li><li>GitLab 10</li><li>GitLab 8</li><li>GitLab 7</li><li>GitLab 6</li></ul><p><br></p><p><strong>升级方法:</strong></p><ul><li>使用官方Repo</li><li>手动下载Package</li></ul><p><br></p><p><strong>零停机更新(Zero downtime updates)</strong></p><blockquote><p>注意：这仅适用于GitLab 9.1.0或更高版本。</p></blockquote><p>地址: <a href="https://docs.gitlab.com/omnibus/update/README.html#zero-downtime-updates" target="_blank" rel="noopener">https://docs.gitlab.com/omnibus/update/README.html#zero-downtime-updates</a></p><p><br></p><p><strong>降级(Downgrading):</strong></p><blockquote><p>注意：本指南假定您在要还原的版本下创建了备份存档。</p></blockquote><p>步骤：</p><ul><li>Download the package of a target version</li><li>Stop GitLab</li><li>Install the old package</li><li>Reconfigure GitLab</li><li>Restoring the backup</li><li>Starting GitLab</li></ul><p><br><br><br></p><h4 id="其它项的更新"><a href="#其它项的更新" class="headerlink" title="其它项的更新"></a>其它项的更新</h4><ul><li>MySQL to PostgreSQL</li><li>PostgreSQL to MySQL</li><li>更新失败之后从备份文件进行还原</li></ul><p><br><br><br><br><br></p><h3 id="CE-EE"><a href="#CE-EE" class="headerlink" title="CE-EE"></a>CE-EE</h3><p>Upgrading or downgrading GitLab</p><ul><li>Upgrade from GitLab CE to GitLab EE</li><li>Downgrade from GitLab EE to GitLab CE</li></ul><p><br><br><br><br><br><br><br></p><h2 id="平台集成"><a href="#平台集成" class="headerlink" title="平台集成"></a>平台集成</h2><p>GitLab platform integrations</p><p><br></p><h3 id="集成Mattermost"><a href="#集成Mattermost" class="headerlink" title="集成Mattermost"></a>集成Mattermost</h3><p>Mattermost是一个开源，可托管的聊天服务。它被设计为组织和公司的内部聊天，并且主要将自己作为Slack的替代品。</p><p><a href="https://docs.gitlab.com/omnibus/gitlab-mattermost/" target="_blank" rel="noopener">https://docs.gitlab.com/omnibus/gitlab-mattermost/</a></p><p><br><br><br><br><br></p><h3 id="集成PlantUML"><a href="#集成PlantUML" class="headerlink" title="集成PlantUML"></a>集成PlantUML</h3><p>PlantUML是一个开源工具，允许用户使用纯文本语言创建UML图表。</p><p><a href="https://docs.gitlab.com/ce/administration/integration/plantuml.html" target="_blank" rel="noopener">https://docs.gitlab.com/ce/administration/integration/plantuml.html</a></p><p><br><br><br><br><br></p><h3 id="集成Web终端"><a href="#集成Web终端" class="headerlink" title="集成Web终端"></a>集成Web终端</h3><p>从GitLab的<code>CI/CD</code>环境中提供对部署到Kubernetes的应用程序的终端访问。<br>随着Kubernetes集成的引入，GitLab获得了为Kubernetes集群存储和使用凭证的能力。它使用这些凭据的一个原因是提供对环境的Web终端的访问。</p><p>Web终端的体系结构及其工作原理：</p><ul><li>GitLab依靠用户提供他们自己的Kubernetes凭据，并在部署时适当地标记他们创建的pod。</li><li>当用户到环境的终端页面时，它们将被提供一个JavaScript应用程序，该应用程序将WebSocket连接返回给GitLab。</li><li>WebSocket在Workhorse中处理，而不是Rails Application Server。</li><li>Workhorse查询Rails的连接细节和用户权限; Rails使用Sidekiq在后台查询Kubernetes</li><li>Workhorse充当用户浏览器和Kubernetes API之间的代理服务器，在两者之间传递WebSocket frame</li><li>Workhorse定期轮询Rails，如果用户不再具有访问终端的权限，或者连接详细信息已更改，则终止WebSocket连接。</li></ul><blockquote><p>ps: WebSocket是一种在单个TCP连接上进行全双工通信的协议。</p></blockquote><p><br></p><p><strong>启用/禁用终端支持(Enabling and disabling terminal support)</strong></p><p>当Web终端使用WebSockets时，Workhorse前面的每个HTTP/HTTPS反向代理都需要配置为将Connection和Upgrade头传递给链中的下一个，在GitLab v8.15+，这是默认选项，不需要你配置。</p><p>但是，如果在GitLab前面运行负载均衡器，则可能需要对配置进行一些更改:</p><ul><li>Apache</li><li>NGINX</li><li>HAProxy</li><li>Varnish</li></ul><p>Workhorse不会让WebSocket请求通过non-WebSocket端点，因此可以安全地在全局范围内启用对这些Header的支持。如果您宁愿使用较窄的规则集，则可以将其限制为以<code>/terminal.ws</code>结尾的URL。</p><p>如果您想在GitLab中禁用Web终端支持，只需停止在链中的第一个HTTP反向代理中传递<code>Connection</code>和<code>Upgrade</code>逐跳Header。对于大多数用户来说，这将是与Omnibus GitLab捆绑在一起的NGINX服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#在gitLab.rb中找到 nginx[&apos;proxy_set_headers&apos;]</span><br><span class="line">#移除或注释 Connection和Upgrade</span><br><span class="line"></span><br><span class="line"># nginx[&apos;proxy_set_headers&apos;] = &#123;</span><br><span class="line">#  &quot;Upgrade&quot; =&gt; &quot;$http_upgrade&quot;,</span><br><span class="line">#  &quot;Connection&quot; =&gt; &quot;$connection_upgrade&quot;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>限制Websocket连接时间(Limiting WebSocket connection time)</strong></p><blockquote><p>ps: GitLab v8.17+</p></blockquote><p>终端会话使用长期连接。默认情况下，这些可能永远持续下去。如果从可伸缩性或安全性角度发现这是不受欢迎的，您可以在GitLab实例的Admin区域中配置最长会话时间。</p><p><br><br><br></p><hr><p><br><br><br></p><h2 id="用户设置和权限"><a href="#用户设置和权限" class="headerlink" title="用户设置和权限"></a>用户设置和权限</h2><p>User settings and permissions</p><p><br></p><h3 id="Libravatar"><a href="#Libravatar" class="headerlink" title="Libravatar"></a>Libravatar</h3><p>Use Libravatar instead of Gravatar for user avatars.</p><p><a href="https://docs.gitlab.com/ce/customization/libravatar.html" target="_blank" rel="noopener">https://docs.gitlab.com/ce/customization/libravatar.html</a></p><p><br><br><br><br><br></p><h3 id="注册限制"><a href="#注册限制" class="headerlink" title="注册限制"></a>注册限制</h3><p>Sign-up restrictions: block email addresses of specific domains, or whitelist only specific domains.</p><p>您可以通过管理区域中的“应用程序设置”阻止特定域的电子邮件地址，或仅将某些特定域列入白名单。</p><ul><li>Whitelist email domains</li><li>Blacklist email domains</li></ul><p>白名单和黑名单支持通配符。<br>如可对白名单加自己信任的域(如：<code>company.com</code>)，再把所有加入黑名单(如： <code>*</code>)</p><p><br><br><br><br><br></p><h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><p>Access restrictions: Define which Git access protocols can be used to talk to GitLab (SSH, HTTP, HTTPS).</p><p><strong>启用Git访问协议</strong></p><ul><li>SSH 和 HTTP(s)</li><li>仅SSH</li><li>仅HTTP(s)</li></ul><p><br><br><br><br><br></p><h3 id="认证和授权"><a href="#认证和授权" class="headerlink" title="认证和授权"></a>认证和授权</h3><p>Authentication/Authorization: Enforce 2FA, configure external authentication with LDAP, SAML, CAS and additional Omniauth providers.</p><p><a href="https://docs.gitlab.com/ce/topics/authentication/index.html" target="_blank" rel="noopener">https://docs.gitlab.com/ce/topics/authentication/index.html</a></p><p><br><br><br><br><br></p><h3 id="传入电子邮件"><a href="#传入电子邮件" class="headerlink" title="传入电子邮件"></a>传入电子邮件</h3><p>Incoming email: Configure incoming emails to allow users to reply by email, create issues by email and merge requests by email, and to enable.</p><p>GitLab有几个基于接收传入电子邮件的功能：</p><ul><li>Reply by Email: 允许GitLab用户通过回复notification电子邮件对issues发表comment并merge request</li><li>New issue by email: 允许GitLab用户通过向用户特定的电子邮件地址发送电子邮件来创建新Issue</li><li>New merge request by email: 允许GitLab用户通过向用户特定的电子邮件地址发送电子邮件来创建新的 merge request</li></ul><p><br></p><p><strong>依赖(Requirements)：</strong></p><ul><li>Email sub-addressing</li><li>Dedicated email address</li><li>Catch-all mailbox</li></ul><p><br></p><p><strong>配置：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在gitlab.rb中找到incoming_email，启用该功能并填写IMAP信息和账户信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### Reply by email</span></span><br><span class="line"><span class="comment">###! Allow users to comment on issues and merge requests by replying to</span></span><br><span class="line"><span class="comment">###! notification emails.</span></span><br><span class="line"><span class="comment">###! Docs: https://docs.gitlab.com/ce/administration/reply_by_email.html</span></span><br><span class="line"><span class="comment"># gitlab_rails['incoming_email_enabled'] = true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Incoming Email Address</span></span><br><span class="line"><span class="comment">####! The email address including the `%&#123;key&#125;` placeholder that will be replaced</span></span><br><span class="line"><span class="comment">####! to reference the item being replied to.</span></span><br><span class="line"><span class="comment">####! **The placeholder can be omitted but if present, it must appear in the</span></span><br><span class="line"><span class="comment">####!   "user" part of the address (before the `@`).**</span></span><br><span class="line"><span class="comment"># gitlab_rails['incoming_email_address'] = "gitlab-incoming+%&#123;key&#125;@gmail.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Email account username</span></span><br><span class="line"><span class="comment">####! **With third party providers, this is usually the full email address.**</span></span><br><span class="line"><span class="comment">####! **With self-hosted email servers, this is usually the user part of the</span></span><br><span class="line"><span class="comment">####!   email address.**</span></span><br><span class="line"><span class="comment"># gitlab_rails['incoming_email_email'] = "gitlab-incoming@gmail.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Email account password</span></span><br><span class="line"><span class="comment"># gitlab_rails['incoming_email_password'] = "[REDACTED]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### IMAP Settings</span></span><br><span class="line"><span class="comment"># gitlab_rails['incoming_email_host'] = "imap.gmail.com"</span></span><br><span class="line"><span class="comment"># gitlab_rails['incoming_email_port'] = 993</span></span><br><span class="line"><span class="comment"># gitlab_rails['incoming_email_ssl'] = true</span></span><br><span class="line"><span class="comment"># gitlab_rails['incoming_email_start_tls'] = false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### Incoming Mailbox Settings</span></span><br><span class="line"><span class="comment">####! The mailbox where incoming mail will end up. Usually "inbox".</span></span><br><span class="line"><span class="comment"># gitlab_rails['incoming_email_mailbox_name'] = "inbox"</span></span><br><span class="line"><span class="comment">####! The IDLE command timeout.</span></span><br><span class="line"><span class="comment"># gitlab_rails['incoming_email_idle_timeout'] = 60</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重载配置和重启</span></span><br><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line">sudo gitlab-ctl restart</span><br><span class="line"></span><br><span class="line"><span class="comment">#验证邮箱配置</span></span><br><span class="line">sudo gitlab-rake gitlab:incoming_email:check</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h2 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h2><p>Project settings</p><p><br></p><h3 id="Repo检查"><a href="#Repo检查" class="headerlink" title="Repo检查"></a>Repo检查</h3><p>Repository checks: Periodic Git repository checks.</p><blockquote><p>在GitLab 8.7中引入。它默认关闭，因为它仍会导致过多的误报。</p></blockquote><p>Git有一个内置机制<code>git fsck</code>，用于验证提交到存储库的所有数据的完整性。GitLab管理员可以通过管理面板下的项目页面触发对项目的检查。检查以异步方式运行，因此可能需要几分钟才能在项目管理页面上显示检查结果。如果检查失败，您可以在<code>repocheck.log</code>下的管理日志页面上看到它们的输出。</p><p><br></p><p><strong>定期检查(Periodic checks)</strong></p><p>启用后，GitLab会定期对所有项目存储库和wiki存储库运行存储库检查，以检测数据损坏。一个项目每月检查不超过一次。如果任何项目未通过其存储库检查，则所有GitLab管理员都将收到有关该情况的电子邮件通知。\</p><p><br></p><p><strong>禁用</strong></p><p>可在管理员面板上禁用定期检查。</p><p><br></p><p><strong>检查失败</strong></p><p>如果某个存储库检查失败，你应该在<code>repocheck.log</code>查找错误信息:</p><ul><li>管理员面板</li><li>磁盘日志文件<ul><li><code>/var/log/gitlab/gitlab-rails</code> for Omnibus installations</li><li><code>/home/git/gitlab/log</code> for installations from source</li></ul></li></ul><p>如果由于某种原因定期检查导致大量错误警报，您可以在管理员设置里来选择清除所有存储库检查状态。</p><p><br><br><br><br><br></p><h3 id="Repo存储路径"><a href="#Repo存储路径" class="headerlink" title="Repo存储路径"></a>Repo存储路径</h3><p>Repository storage paths: Manage the paths used to store repositories.</p><p><strong>GitLab允许您定义多个存储库存储路径，以在多个挂载点之间分配存储负载。</strong></p><p><strong>注意:</strong></p><ul><li>您必须至少有一个名为<code>default</code>的存储路径</li><li>路径以键值对进行定义</li><li>目标目录及其任何子路径都不能是符号链接</li><li>目标目录不能是制定路径的子目录，因为不能嵌套</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#栗子</span><br><span class="line">default:</span><br><span class="line">  path: /mnt/git-storage-1</span><br><span class="line">storage2:</span><br><span class="line">  path: /mnt/git-storage-2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#错误栗子</span><br><span class="line">default:</span><br><span class="line">  path: /mnt/git-storage-1</span><br><span class="line">storage2:</span><br><span class="line">  path: /mnt/git-storage-1/git-storage-2 # &lt;- NOT OK because of nesting</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="配置GitLab"><a href="#配置GitLab" class="headerlink" title="配置GitLab"></a>配置GitLab</h4><blockquote><p><strong>注意:</strong><br>为了使备份正常工作，存储路径不能是挂载点，GitLab用户应具有路径父目录的正确权限。在Omnibus GitLab中，这是自动处理的，但对于Source Code安装，您应该格外小心。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gitlab.rb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git_data_dirs(&#123;</span><br><span class="line">  &quot;default&quot; =&gt; &#123; &quot;path&quot; =&gt; &quot;/var/opt/gitlab/git-data&quot; &#125;,</span><br><span class="line">  &quot;nfs&quot; =&gt; &#123; &quot;path&quot; =&gt; &quot;/mnt/nfs/git-data&quot; &#125;,</span><br><span class="line">  &quot;cephfs&quot; =&gt; &#123; &quot;path&quot; =&gt; &quot;/mnt/cephfs/git-data&quot; &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#Omnibus将存储库数据存储在git-data/repositories子目录下</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="选择新项目存储库的存储位置"><a href="#选择新项目存储库的存储位置" class="headerlink" title="选择新项目存储库的存储位置"></a>选择新项目存储库的存储位置</h4><p>设置了多个存储路径后，可在Admin下Application Setting选择新项目的存储路径。<br>从GitLab 8.13.4开始，可以选择多个路径。新项目将随机放置在其中一个选定路径上。</p><p><br><br><br><br><br></p><h3 id="Repo存储靶任务"><a href="#Repo存储靶任务" class="headerlink" title="Repo存储靶任务"></a>Repo存储靶任务</h3><p>Repository storage rake tasks: A collection of rake tasks to list and migrate existing projects and attachments associated with it from Legacy storage to Hashed storage</p><p>以下靶任务(rake task)，可用于帮助您列出现有项目以及与之关联的附件，从旧存储到新的Hashed存储类型。</p><p><br></p><h4 id="将现有项目迁移到哈希存储"><a href="#将现有项目迁移到哈希存储" class="headerlink" title="将现有项目迁移到哈希存储"></a>将现有项目迁移到哈希存储</h4><p>Migrate existing projects to Hashed storage</p><p>在迁移现有项目之前，还应为新项目启用哈希/散列存储。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line">sudo gitlab-rake gitlab:storage:migrate_to_hashed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># to migrate any non migrated project from ID 20 to 50.</span></span><br><span class="line"><span class="built_in">export</span> ID_FROM=20 </span><br><span class="line"><span class="built_in">export</span> ID_TO=50</span><br></pre></td></tr></table></figure><p>你可在<code>Admin &gt; Monitoring &gt; Background jobs</code>里面进行查看。</p><p>在它达到零之后，您可以通过运行以下命令来确认已迁移每个项目。如果您认为有必要，可以再次运行此迁移脚本以安排缺少的项目。</p><p><br><br><br></p><h4 id="列出旧版存储的项目"><a href="#列出旧版存储的项目" class="headerlink" title="列出旧版存储的项目"></a>列出旧版存储的项目</h4><p>List projects on Legacy storage</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取旧项目存储摘要</span></span><br><span class="line"><span class="comment">#Ominibus</span></span><br><span class="line">sudo gitlab-rake gitlab:storage:legacy_projects</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出项目使用的旧存储</span></span><br><span class="line"><span class="comment">#Ominibus</span></span><br><span class="line">sudo gitlab-rake gitlab:storage:list_legacy_projects</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="列出哈希散列上的项目"><a href="#列出哈希散列上的项目" class="headerlink" title="列出哈希散列上的项目"></a>列出哈希散列上的项目</h4><p>List projects on Hashed storage</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用哈希存储的项目的简单摘要</span></span><br><span class="line"><span class="comment">#Ominibus</span></span><br><span class="line">sudo gitlab-rake gitlab:storage:hashed_projects</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出项目使用的散列存储</span></span><br><span class="line"><span class="comment">#Ominibus</span></span><br><span class="line">sudo gitlab-rake gitlab:storage:list_hashed_projects</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="列出旧版存储上的附件"><a href="#列出旧版存储上的附件" class="headerlink" title="列出旧版存储上的附件"></a>列出旧版存储上的附件</h4><p>List attachments on Legacy storage</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用旧版存储的附件的简单摘要</span></span><br><span class="line"><span class="comment">#Ominibus</span></span><br><span class="line">sudo gitlab-rake gitlab:storage:legacy_attachments</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出使用旧版存储的项目附件</span></span><br><span class="line"><span class="comment">#Ominibus</span></span><br><span class="line">sudo gitlab-rake gitlab:storage:list_legacy_attachments</span><br></pre></td></tr></table></figure><p><br><br><br></p><p>####列出哈希存储上的附件</p><p>List attachments on Hashed storage</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用哈希存储的附件的简单摘要</span></span><br><span class="line"><span class="comment">#Ominibus</span></span><br><span class="line">sudo gitlab-rake gitlab:storage:hashed_attachments</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出使用哈希存储的项目附件</span></span><br><span class="line"><span class="comment">#Ominibus</span></span><br><span class="line">sudo gitlab-rake gitlab:storage:list_hashed_attachments</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="限制Repo大小"><a href="#限制Repo大小" class="headerlink" title="限制Repo大小"></a>限制Repo大小</h3><p>Limit repository size: Set a hard limit for your repositories’ size</p><blockquote><p>Introduced in GitLab Enterprise Edition 8.12.</p></blockquote><p>GitLab实例中的存储库可能会快速增长，尤其是在使用LFS时。它们的大小可以指数级增长，并且可以非常快速地耗尽您的存储设备。为了避免这种情况发生，您可以为存储库的大小设置硬限制。<br>可以全局，按组或按项目设置此限制，每个项目限制具有最高优先级。</p><p>只有GitLab管理员才能设置这些限制。将限制设置为0表示没有限制。</p><p>到目前为止，无法检查新项目的第一次推送的大小，因此第一次推送将允许您上传超过限制规定，但每次后续推送都将被拒绝。但是，LFS对象可以在第一次推送时检查，如果它们的大小总和超过允许的最大存储库大小，则会被拒绝。</p><p><br><br><br></p><hr><p><br><br><br></p><h2 id="CI"><a href="#CI" class="headerlink" title="CI"></a>CI</h2><p>Continuous Integration settings</p><p><img src="/images/GitLab/cicd_pipeline_infograph.png" alt=""></p><p><br></p><h3 id="启用-禁用CICD"><a href="#启用-禁用CICD" class="headerlink" title="启用/禁用CICD"></a>启用/禁用CICD</h3><p>Enable/disable GitLab CI/CD: Enable or disable GitLab CI/CD for your instance.</p><p>您可以在站点范围内禁用GitLab CI/CD，方法是修改配置文件。</p><p>有两点需要注意：</p><ul><li>禁用GitLab CI/CD只会影响新创建的项目。在此修改之前启用它的项目将像以前一样工作</li><li>即使禁用了GitLab CI/CD，用户仍然可以在项目设置中启用它</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#Source</span><br><span class="line">vim gitlab.yml</span><br><span class="line"></span><br><span class="line">## Default project features settings, set build to false</span><br><span class="line">default_projects_features:</span><br><span class="line">  issues: true</span><br><span class="line">  merge_requests: true</span><br><span class="line">  wiki: true</span><br><span class="line">  snippets: false</span><br><span class="line">  builds: false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Omnibus</span><br><span class="line">/etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">gitlab_rails[&apos;gitlab_default_projects_features_builds&apos;] = false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#重载</span><br><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="CI-CD-admin设置"><a href="#CI-CD-admin设置" class="headerlink" title="CI/CD admin设置"></a>CI/CD admin设置</h3><p>GitLab CI/CD admin settings: Enable or disable  DevOps site-wide and define the artifacts’ max size and expiration time.</p><p>在以管理员登录GitLab Web UI，在Admin area里面，您将找到Auto DevOps，Runners和job artifacts的设置。</p><p><br></p><p><strong>Auto DevOps</strong></p><p>要为所有项目启用/禁用 Auto DevOps：</p><ul><li>进入<code>Admin area &gt; Settings &gt; Continuous Integration and Deployment</code></li><li>检查<code>Default to Auto DevOps pipeline for all projects</code></li><li>可为Auto DevOps添加基本域</li><li>保存更改</li></ul><p>从现在开始，每个现有项目和新创建的项目都没有<code>.gitlab-ci.yml</code>，将使用Auto DevOps pipeline。</p><p><br></p><p><strong>Maximum artifacts size</strong></p><p>可为GitLab实例设置<code>[job artifacts][art-yml]</code>的最大大小。它的单位为<code>MB</code>，默认为每个Job设置为<code>100MB</code>。<code>GitLab.com</code>上它被设置为<code>1GB</code>。</p><p><br></p><p><strong>Default artifacts expiration</strong></p><p>可为GitLab实例的<code>job artifacts</code>设置默认到期时间。<code>GitLab.com</code>它<code>never expire</code>。<br>这里面的设置是按Job设置的，可在<code>.gitlab-ci.yml</code>中覆盖它。将其设置为0表示禁用过期，默认单位是秒。</p><p><strong>Archive jobs</strong></p><p>归档作业通过删除作业的一些功能（运行作业所需的元数据）来减少系统上的CI/CD占用空间，但是为了审计目的而保留跟踪(traces)和工件(artifacts)。<br>一旦该时间过去，作业将被存档，不再能够重试。让它变空成为永不过期的工作(它必须不少于1天)。</p><p><br><br><br><br><br></p><h3 id="Jobs-artifacts"><a href="#Jobs-artifacts" class="headerlink" title="Jobs artifacts"></a>Jobs artifacts</h3><p>Job artifacts: Enable, disable, and configure job artifacts (a set of files and directories which are outputted by a job when it completes successfully).</p><p>Artifacts是在成功完成后附加到作业的文件和目录的列表。此功能在所有的安装中默认启用。</p><p><br></p><p><strong>禁用 job artifacts</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line"><span class="comment">#/etc/gitlab/gitlab.rb</span></span><br><span class="line"></span><br><span class="line">gitlab_rails[<span class="string">'artifacts_enabled'</span>] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重载</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>存储 job artifacts</strong><br>成功完成作业后，GitLab Runner将job artifacts的存档上传到GitLab。</p><ul><li>使用本地存储</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#默认路径</span><br><span class="line"># gitlab_rails[&apos;artifacts_path&apos;] = &quot;/var/opt/gitlab/gitlab-rails/shared/artifacts&quot;</span><br></pre></td></tr></table></figure><ul><li>使用对象存储</li></ul><table><thead><tr><th>Setting</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>enabled</td><td>Enable/disable object storage</td><td>false</td></tr><tr><td>remote_directory</td><td>The bucket name where Artifacts will be stored</td><td></td></tr><tr><td>direct_upload</td><td>Set to true to enable direct upload of Artifacts without the need of local shared storage. Option may be removed once we decide to support only single storage for all files.</td><td>false</td></tr><tr><td>background_upload</td><td>Set to false to disable automatic upload. Option may be removed once upload is direct to S3</td><td>true</td></tr><tr><td>proxy_download</td><td>Set to true to enable proxying all files served. Option allows to reduce egress traffic as this allows clients to download directly from remote storage instead of proxying all data</td><td>false</td></tr><tr><td>connection</td><td>Various connection options described below</td><td>-</td></tr></tbody></table><p><br></p><p><strong>Expiring artifacts</strong><br>如果工件使用了失效日期，则在该日期过后立即标记为删除。文件由<code>expire_build_artifacts_worker</code> cron job清理，该作业由Sidekiq每小时的第50分钟（<code>50 * * * *</code>）运行。</p><p>更改工件过期的默认调度计划：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Omnibus</span></span><br><span class="line"><span class="comment">#/etc/gitlab/gitlab.rb</span></span><br><span class="line">gitlab_rails[<span class="string">'expire_build_artifacts_worker_cron'</span>] = <span class="string">"50 * * * *"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重配</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>依赖验证(dependencies validation)</strong><br>要禁用依赖验证，可在Rail Console设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#Omnibus</span><br><span class="line"></span><br><span class="line">#rails console</span><br><span class="line">sudo gitlab-rails console</span><br><span class="line"></span><br><span class="line">#禁用</span><br><span class="line"> Feature.enable(&apos;ci_disable_validates_dependencies&apos;)</span><br></pre></td></tr></table></figure><p><br></p><p><strong>实施细节</strong><br>当GitLab收到工件存档时，GitLab Workhorse也会生成存档元数据文件。此元数据文件描述了工件存档本身中的所有条目。元数据文件采用二进制格式，具有额外的GZIP压缩。</p><p>GitLab不解压工件存档以节省Disk，Mem和I/O。它改为检查包含所有相关信息的元数据文件。当存在大量工件或存档是非常大的文件时，这一点尤为重要。<br>单击特定文件时，GitLab Workhorse会从存档中提取它并开始下载。此实现可节省空间，内存和磁盘I/O.</p><p><br><br><br><br><br></p><h3 id="Job-traces"><a href="#Job-traces" class="headerlink" title="Job traces"></a>Job traces</h3><p>Job traces: Information about the job traces (logs).</p><p>作业跟踪由GitLab Runner在处理作业时发送。您可以在job, pipeline, email notification查看工作踪迹。</p><p><br></p><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>Data flow</p><p>通常，作业踪迹中有两种状态：</p><ul><li>实时跟踪(live trace)</li><li>存档跟踪(archived trace)</li></ul><table><thead><tr><th>Phase</th><th>State</th><th>Condition</th><th>Data flow</th><th>Stored path</th></tr></thead><tbody><tr><td>1: <br> patching</td><td>Live trace</td><td>When a job is running</td><td>GitLab Runner =&gt; Unicorn =&gt; file storage</td><td><code>#{ROOT_PATH}/builds/#{YYYY_mm}/#{project_id}/#{job_id}.log</code></td></tr><tr><td>2: <br> overwriting</td><td>Live trace</td><td>When a job is finished</td><td>GitLab Runner =&gt; Unicorn =&gt; file storage</td><td><code>#{ROOT_PATH}/builds/#{YYYY_mm}/#{project_id}/#{job_id}.log</code></td></tr><tr><td>3: <br> archiving</td><td>Archived trace</td><td>After a job is finished</td><td>Sidekiq moves live trace to artifacts folder</td><td><code>#{ROOT_PATH}/shared/artifacts/#{disk_hash}/#{YYYY_mm_dd}/#{job_id}/#{job_artifact_id}/job.log</code></td></tr><tr><td>4: <br> uploading</td><td>Archived trace</td><td>After a trace is archived</td><td>Sidekiq moves archived trace to object storage (if configured)</td><td><code>#{bucket_name}/#{disk_hash}/#{YYYY_mm_dd}/#{job_id}/#{job_artifact_id}/job.log</code></td></tr></tbody></table><p><br><br><br></p><h4 id="修改工作踪迹本地位置"><a href="#修改工作踪迹本地位置" class="headerlink" title="修改工作踪迹本地位置"></a>修改工作踪迹本地位置</h4><p>Changing the job traces local location</p><p>更改存储Job Log的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#Omnibus</span><br><span class="line">#/etc/gitlab/gitlab.rb</span><br><span class="line">gitlab_ci[&apos;builds_directory&apos;] = &apos;/mnt/to/gitlab-ci/builds&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Source</span><br><span class="line">#/home/git/gitlab/config/gitlab.yml</span><br><span class="line">gitlab_ci:</span><br><span class="line">  # The location where build traces are stored (default: builds/).</span><br><span class="line">  # Relative paths are relative to Rails.root.</span><br><span class="line">  builds_path: path/to/builds/</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="将踪迹上传到对象存储"><a href="#将踪迹上传到对象存储" class="headerlink" title="将踪迹上传到对象存储"></a>将踪迹上传到对象存储</h4><p>Uploading traces to object storage</p><p>存档的踪迹被视为工作工件。因此，在设置对象存储集成时，作业踪迹会自动与其他作业工件一起迁移到它。</p><p><br><br><br></p><p>####　如何归档旧的作业踪迹文件</p><p>How to archive legacy job trace files</p><p>旧的作业踪迹指的是在GitLab 10.5之前创建的，未定期归档的作业踪迹。那么你可能需要手动进行操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行此任务后，GitLab实例将Sidekiq作业（异步进程）排队，以将作业跟踪文件从本地存储迁移到对象存储。完成所有迁移工作可能需要一些时间。</span></span><br><span class="line">gitlab-rake gitlab:traces:archive</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo gitlab-rails console</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果计数变为零，则归档过程完成</span></span><br><span class="line">[1] pry(main)&gt; Sidekiq::Stats.new.queues[<span class="string">'pipeline_background:archive_trace'</span>]</span><br><span class="line"> =&gt; 100</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="如何将归档的作业踪迹迁移到对象存储"><a href="#如何将归档的作业踪迹迁移到对象存储" class="headerlink" title="如何将归档的作业踪迹迁移到对象存储"></a>如何将归档的作业踪迹迁移到对象存储</h4><p>How to migrate archived job traces to object storage</p><blockquote><p>在GitLab 11.3中引入</p></blockquote><p>如果作业踪迹已存档到本地存储中，并且您希望将这些踪迹迁移到对象存储：</p><ul><li>确保已启用Job Artifacts的对象存储集成</li><li>执行此命令: <code>gitlab-rake gitlab:traces:migrate</code></li></ul><p><br><br><br></p><h4 id="如何删除作业踪迹"><a href="#如何删除作业踪迹" class="headerlink" title="如何删除作业踪迹"></a>如何删除作业踪迹</h4><p>How to remove job traces</p><p>没有办法自动使旧的作业日志过期，但如果它们占用太多空间，则可以安全地删除它们。如果手动删除日志，则UI中的作业输出将为空。</p><p><br><br><br></p><h4 id="新的实时踪迹架构"><a href="#新的实时踪迹架构" class="headerlink" title="新的实时踪迹架构"></a>新的实时踪迹架构</h4><p>New live trace architecture</p><blockquote><p>在GitLab 10.4中引入。在GitLab 11.0中宣布的一般可用性。<br>此功能默认禁用。</p></blockquote><p>这是一个详细的数据流：</p><ul><li>GitLab Runner picks a job from GitLab</li><li>GitLab Runner sends a piece of trace to GitLab</li><li>GitLab appends the data to Redis</li><li>Once the data in Redis reach 128KB, the data is flushed to a persistent store (object storage or the database).</li><li>The above steps are repeated until the job is finished.</li><li>Once the job is finished, GitLab schedules a Sidekiq worker to archive the trace.</li><li>The Sidekiq worker archives the trace to object storage and cleans up the trace in Redis and a persistent store (object storage or the database)</li></ul><p><br></p><p><strong>Enabling live trace</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#console</span><br><span class="line"></span><br><span class="line"># Omnibus GitLab</span><br><span class="line">gitlab-rails console</span><br><span class="line"></span><br><span class="line"># Installation from source</span><br><span class="line">cd /home/git/gitlab</span><br><span class="line">sudo -u git -H bin/rails console RAILS_ENV=production</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#检查实时踪迹</span><br><span class="line">Feature.enabled?(&apos;ci_enable_live_trace&apos;)</span><br><span class="line"></span><br><span class="line">#启用</span><br><span class="line">Feature.enable(&apos;ci_enable_live_trace&apos;)</span><br><span class="line"></span><br><span class="line">#禁用</span><br><span class="line">Feature.disable(&apos;ci_enable_live_trace&apos;)</span><br></pre></td></tr></table></figure><p><br></p><p><strong>潜在影响(Potential implications)</strong></p><p>在某些情况下，将数据存储在Redis上可能会导致数据丢失：</p><ul><li><p><strong>Case 1: When all data in Redis are accidentally flushed</strong><br>可以通过重新发送追踪来恢复实时踪迹。未归档的已完成作业的实时踪迹将丢失踪迹数据的最后一部分。</p></li><li><p><strong>Case 2: When Sidekiq workers fail to archive</strong><br>目前，Redis中的所有踪迹数据将在一周后删除。如果Sidekiq Worker无法在过期之前完成，则踪迹数据的一部分将丢失。</p></li><li><p>可能出现的另一个问题是它可能占用Redis实例上的所有内存<br>如果作业数为1000，则消耗128MB（<code>128KB*1000</code>）。</p></li></ul><p><br><br><br><br><br></p><h3 id="配置GitLab-Runner"><a href="#配置GitLab-Runner" class="headerlink" title="配置GitLab Runner"></a>配置GitLab Runner</h3><p>Configuring GitLab Runners<br>Register Shared and specific Runners: Learn how to register and configure Shared and specific Runners to your own instance.</p><p>在GitLab CI中，Runners运行<code>.gitlab-ci.yml</code>中定义的代码。它们是隔离(虚拟)机器，通过GitLab CI的协调器API获取作业。<br>Runner可以特定于某个项目，也可以为GitLab CI中的任何项目提供服务。为所有项目提供服务的Runner称为<strong>shared Runner</strong>。<br>理想情况下，GitLab Runner不应与GitLab安装在同一台机器上。你可以为GitLab实例配置多个Runner。</p><p><br><br><br></p><h4 id="Runner的状态"><a href="#Runner的状态" class="headerlink" title="Runner的状态"></a>Runner的状态</h4><p>Shared, specific and group Runners</p><p>安装Runner后，您可以将其注册为共享的或特定的。如果您具有GitLab实例的管理员访问权限，则只能注册shared Runner。</p><p>每个Runner可处于一下状态；</p><ul><li><code>shared</code>: Runner runs jobs from all unassigned projects</li><li><code>group</code>: Runner runs jobs from all unassigned projects in its group</li><li><code>specific</code>: Runner runs jobs from assigned projects</li><li><code>locked</code>: Runner cannot be assigned to other projects</li><li><code>paused</code>: Runner will not receive any new jobs</li></ul><p><br><br><br></p><h4 id="注册共享的Runner"><a href="#注册共享的Runner" class="headerlink" title="注册共享的Runner"></a>注册共享的Runner</h4><p>Registering a shared Runner</p><p>如果您是GitLab实例的管理员，则只能注册shared Runner。</p><p>在Web UI -&gt; Admin Area -&gt; Runner里面用它提供的URL和Token进行Runner注册。<br><img src="/images/GitLab/Register_Runner.png" alt=""></p><p><br></p><p>默认情况下启用shared runner，但可在 Admin Area -&gt; CI/CD里面禁用。</p><p><img src="/images/Disable_SharedRunner.png" alt=""></p><p><br><br><br></p><h4 id="注册特定的Runner"><a href="#注册特定的Runner" class="headerlink" title="注册特定的Runner"></a>注册特定的Runner</h4><p>Registering a specific Runner</p><p>注册特定的Runner有两种方式：</p><ul><li>使用project registration token来注册Runner</li><li>将shared Runner 转换为 specific Runner(单向，仅限管理员)</li></ul><p><br></p><p><strong>使用项目Token注册特定的Runner：</strong><br>创建一个没有GitLab实例管理员权限的特定Runner。进入此项目， Setting -&gt; CI/CD -&gt; Runner进行配置。</p><p><img src="/images/GitLab/Register_SpecificRunner.png" alt=""></p><p><br><br><br></p><h4 id="注册一个组Runner"><a href="#注册一个组Runner" class="headerlink" title="注册一个组Runner"></a>注册一个组Runner</h4><p>Registering a group Runner</p><p>创建一个group Runner，然后访问词组，Setting -&gt; CI/CD -&gt; Runner。</p><p><img src="/images/GitLab/Register_GroupRunner.png" alt=""></p><p><br></p><p><strong>将共享的Runner特定化(Making an existing shared Runner specific)</strong></p><p>如果您是GitLab实例的管理员，则可以将任何shared Runner转换为specific Runner。请记住，这是一种单向转换，不能逆向转换。</p><ul><li>Admin Ares -&gt; Overview -&gt; Runner -&gt; 需要的Runner</li><li>对项目启用Restrict projects for this Runner</li></ul><p>这样，shared Runner便特定于某些项目。</p><p><img src="/images/GitLab/Convert_Shared_Specific.png" alt=""></p><p><img src="/images/GitLab/Convert_Shared_Specific_View.png" alt=""></p><p>之后此Runner的状态便发生了改变。</p><p><br><br><br></p><h4 id="锁定特定Runner"><a href="#锁定特定Runner" class="headerlink" title="锁定特定Runner"></a>锁定特定Runner</h4><p>Locking a specific Runner from being enabled for other projects</p><p>您可以配置Runner以将其专门分配给一个项目。当Runner以这种方式锁定时，不能再为其他项目启用它。</p><ul><li>Visit your project’s Settings &gt; CI/CD</li><li>Find the Runner you wish to lock/unlock and make sure it’s enabled</li><li>Click the pencil button</li><li>Check the Lock to current projects option</li><li>Click Save changes for the changes to take effect</li></ul><p><img src="/images/GitLab/Lock_Runner.png" alt=""></p><p><br><br><br></p><h4 id="将Runner分配给另外的项目"><a href="#将Runner分配给另外的项目" class="headerlink" title="将Runner分配给另外的项目"></a>将Runner分配给另外的项目</h4><p>Assigning a Runner to another project</p><p>如果您是分配了特定Runner的项目的维护人员，并且Runner未仅锁定到该项目(not locked only to that project)，则还可以在具有Maintainer权限的任何其他项目上启用Runner。</p><blockquote><p>请注意，如果您没有将特定的Runner锁定到特定项目，那么您项目中具有Maintainer角色的任何用户都可以将Runner分配给另一个任意项目，而无需您的授权，因此请谨慎使用。</p></blockquote><p>启用：</p><ul><li>Visit your project’s Settings &gt; CI/CD</li><li>Find the Runner you wish to enable/disable</li><li>Click Enable for this project or Disable for this project</li></ul><p>管理员可以为项目启用/禁用特定的Runner：</p><ul><li>Navigate to Admin &gt; Runners</li><li>Find the Runner you wish to enable/disable</li><li>Click edit on the Runner</li><li>Click Enable or Disable on the project</li></ul><p><br><br><br></p><h4 id="受保护的Runner"><a href="#受保护的Runner" class="headerlink" title="受保护的Runner"></a>受保护的Runner</h4><p>Protected Runners</p><blockquote><p>在GitLab 10.0中引入。</p></blockquote><p>你可以保护Runner免于泄露敏感信息。每当Runner受到保护时，Runner仅选择在<strong>受保护的分支</strong>或<strong>受保护的标签</strong>上创建的作业，并忽略其他作业。</p><p>protect/unprotect:</p><ul><li>Visit your project’s Settings &gt; CI/CD</li><li>Find a Runner you want to protect/unprotect and make sure it’s enabled</li><li>Click the pencil button besides the Runner name</li><li>Check the Protected option</li><li>Click Save changes for the changes to take effect</li></ul><p><img src="/images/GitLab/Protected_Runner.png" alt=""></p><p><br><br><br></p><h4 id="手动清理Runner缓存"><a href="#手动清理Runner缓存" class="headerlink" title="手动清理Runner缓存"></a>手动清理Runner缓存</h4><p>Manually clearing the Runners cache</p><ul><li>Navigate to your project’s CI/CD &gt; Pipelines page.</li><li>Click on the Clear Runner caches button to clean up the cache.</li><li>On the next push, your CI/CD job will use a new cache.</li></ul><p><br><br><br></p><h4 id="共享Runner如何选择作业"><a href="#共享Runner如何选择作业" class="headerlink" title="共享Runner如何选择作业"></a>共享Runner如何选择作业</h4><p>How shared Runners pick jobs</p><p>共享的Runner遵守我们称之为合理使用的进程队列(process queue)。公平的使用算法尝试从当前在shared Runners上运行的作业数量最少的项目中将作业分配给shared Runners。</p><p><br><br><br></p><h4 id="有效地使用共享Runner"><a href="#有效地使用共享Runner" class="headerlink" title="有效地使用共享Runner"></a>有效地使用共享Runner</h4><p>Using shared Runners effectively</p><p>如果您打算使用共享的Runners，您应该记住几件事。</p><p><br></p><p><strong>使用tags</strong></p><p>您必须设置一个Runner才能运行所有不同类型的作业，它可能会在共享的项目中遇到。如果不使用tags，则对于大型项目可能会出现问题。<br>通过为Runner打tag来标记它可以处理的作业类型，您可以确保shared Runners只运行它们配备的作业(only run the jobs they are equipped to run)。</p><p>例如，在GitLab中，如果Runners包含运行Rails测试套件的相应依赖项，那么我们将Runners标记为“rails”</p><p><br></p><p><strong>Preventing Runners with tags from picking jobs without tags</strong><br>您可以配置Runner以防止在Runner没有分配tag时使用tag选择作业。</p><p>Runner pick tagged/untagged jobs:</p><ul><li>Visit your project’s Settings ➔ CI/CD</li><li>Find the Runner you wish and make sure it’s enabled</li><li>Click the pencil button</li><li>Check the Run untagged jobs option</li><li>Click Save changes for the changes to take effect</li></ul><p><img src="/images/GitLab/Tagged_Runner.png" alt=""></p><p><br></p><p><strong>为Runner设置做大作业超时</strong></p><p>对于每个Runner，您可以指定最大作业超时时间。如果小于项目定义的超时，则此类超时将优先。</p><p><br></p><p><strong>小心敏感信息</strong></p><p>对于一些Runner Executors，如果您可以在Runner上运行作业，您就可以访问它运行的任何代码并获取Runner的Token。使用shared Runners，这意味着在Runner上运行作业的任何人都可以访问在Runner上运行的任何其他人的代码。</p><p>通过在大型公共GitLab实例上限制shared Runners的使用，控制对GitLab实例的访问以及使用更安全的Runner Executor，可以轻松避免上述情况。</p><p><br></p><p><strong>Forks</strong></p><p>每当项目forked时，它都会复制与其相关的作业的设置。这意味着如果您为项目设置了shared Runners并且有人fork该项目，则shated Runners也将为该项目的作业提供服务。</p><p><br><br><br></p><h4 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h4><p>tags用于从允许运行此项目的所有Runner列表中选择特定的Runner。你可以制定Runner的tag.</p><p>tags允许您使用分配了指定tag的Runners运行作业：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">job:</span><br><span class="line">  tags:</span><br><span class="line">    - ruby</span><br><span class="line">    - postgres</span><br></pre></td></tr></table></figure><p><br></p><p>例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">windows</span> <span class="attr">job:</span></span><br><span class="line"><span class="attr">  stage:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">windows</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">echo</span> <span class="string">Hello,</span> <span class="string">%USERNAME%!</span></span><br><span class="line"></span><br><span class="line"><span class="string">osx</span> <span class="attr">job:</span></span><br><span class="line"><span class="attr">  stage:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">osx</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">echo</span> <span class="string">"Hello, $USER!"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="共享Runner的管道配额"><a href="#共享Runner的管道配额" class="headerlink" title="共享Runner的管道配额"></a>共享Runner的管道配额</h4><p>Shared Runners pipelines quota: Limit the usage of pipeline minutes for Shared Runners.</p><p>在Web UI的Admin Area下的Auto DevOps里面进行配置。</p><p><br><br><br></p><h3 id="Auto-DevOps"><a href="#Auto-DevOps" class="headerlink" title="Auto DevOps"></a>Auto DevOps</h3><p>Enable/disable Auto DevOps: Enable or disable Auto DevOps for your instance</p><blockquote><p>在GitLab 10.0中引入。一般在GitLab 11.0上可用。</p></blockquote><p>Auto DevOps提供预定义的<code>CI/CD</code>配置，允许您自动检测(detect)，构建(build)，测试(test)，部署(deploy)和监控(monitor)应用程序。利用<code>CI/CD</code>最佳实践和工具，Auto DevOps旨在简化成熟和现代软件开发生命周期的设置和执行。</p><p><br></p><h4 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h4><blockquote><p>从<code>GitLab v11.3</code>开始，默认情况下为所有项目启用Auto DevOps pipeline。如果尚未为项目显式启用，则会在第一个管道故障时自动禁用Auto DevOps。如果找到一个，您的项目将继续使用备用<code>CI/CD</code>配置文件。</p></blockquote><p>借助Auto DevOps，软件开发过程变得更容易设置，因为每个项目都可以拥有从验证到监控的完整工作流程，并且配置最少。只需推送您的代码，GitLab就会处理其他所有事情。这样可以更轻松地启动新项目，并使整个公司的应用程序设置更加一致。</p><p><br><br><br></p><h4 id="与应用程序平台和PaaS相比较"><a href="#与应用程序平台和PaaS相比较" class="headerlink" title="与应用程序平台和PaaS相比较"></a>与应用程序平台和PaaS相比较</h4><p>Comparison to application platforms and PaaS</p><p>Auto DevOps提供通常包含在应用程序平台或PaaS的功能。它有多个灵感：</p><ul><li>Auto DevOps适用于任何k8s集群;你不仅限于在GitLab的基础设施上运行。</li><li>没有额外成本，你可在任何公共云上使用自托管的k8s集群。</li><li>Auto DevOps包括了安全测试，性能测试和代码质量测试等众多功能。</li><li>Auto DevOps提供增量分级路径。如果您需要高级自定义，则可以开始修改模板，而无需在完全不同的平台上重新开始。</li></ul><p><br><br><br></p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>特性(Features):</p><ul><li>Auto Build</li><li>Auto Test</li><li>Auto Code Quality</li><li>Auto SAST (Static Application Security Testing)</li><li>Auto Dependency Scanning</li><li>Auto License Management</li><li>Auto Container Scanning</li><li>Auto Review Apps</li><li>Auto DAST (Dynamic Application Security Testing)</li><li>Auto Deploy</li><li>Auto Browser Performance Testing</li><li>Auto Monitoring</li></ul><p><br></p><p>由于Auto DevOps依赖于许多不同的组件，因此最好具备以下基本知识：</p><ul><li>Kubernetes</li><li>Helm</li><li>Docker</li><li>GitLab Runner</li><li>Prometheus</li></ul><p><br></p><p>Auto DevOps为所有阶段提供了很好的默认值;但是，您可以根据需要自定义几乎所有内容。</p><p><br><br><br></p><h4 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h4><p>Requirements</p><p>要充分利用Auto DevOps，您需要:</p><ul><li><p><strong>GitLab Runner</strong>(所有阶段都需要)<br>Runner需要配置为能够运行Docker(通常，这意味着使用Docker或Kubernetes executor，并启用特权模式)。Runner不需要安装在k8s集群中，但k8s executor易于使用并且可以自动进行自动伸缩。基于Docker的Runner也可以使用Docker Machine配置为自动伸缩。应将Runners注册为整个GitLab实例的shared Runners，或分配给特定项目的specific Runner。</p></li><li><p><strong>Base domain</strong>(自动审阅和自动部署所需)<br>您将需要一个配置了通配符DNS的域，该域将由您的所有Auto DevOps应用程序使用。</p></li><li><p><strong>K8s</strong>(自动审阅、自动部署和自动监控所需)<br>要启用部署，您需要<code>k8s v1.5+</code>。您需要项目的Kubernetes集群，或整个GitLab安装的Kubernetes默认服务模板。<br>负载均衡器——您可以使用nginx-ingress Helm Chart将NGINX Ingress部署到Kubernetes集群，从而使用NGINX ingress。</p></li><li><p><strong>Prometheus</strong>(自动监控所需)<br>要启用自动监控，您需要在某处（集群内部或外部）安装Prometheus并配置为刮取您的Kubernetes集群。要获得除系统指标外的响应指标(Metrics)，您还需要配置Prometheus。</p></li></ul><p><br></p><blockquote><p><strong>注意</strong>：<br>如果您没有安装Kubernetes或Prometheus，则将自动跳过自动审阅，自动部署和自动监控。</p></blockquote><p><br><br><br></p><h4 id="自动化运维基本域"><a href="#自动化运维基本域" class="headerlink" title="自动化运维基本域"></a>自动化运维基本域</h4><p>Auto DevOps base domain</p><p>如果要使用自动审阅和自动部署，则需要启用Auto DevOps base domain。它可在三个地方定义：</p><ul><li>在项目下的<code>CI/CD</code></li><li>在Admin Area -&gt; Setting -&gt; CI/CD</li><li>在项目下配置变量: <code>AUTO_DEVOPS_DOMAIN</code></li><li>在组级别配置变量: <code>AUTO_DEVOPS_DOMAIN</code></li></ul><p><br></p><p>需要一个与基本域匹配的通配符DNS A记录，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*.example.com   3600     A     1.2.3.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在这种情况下，`example.com`是用于部署应用程序的域名，`1.2.3.4`是负载均衡器的IP地址(通常是NGINX)。如何设置DNS记录超出了本文档的范围;您应该咨询您的DNS提供商。</span><br><span class="line">#设置完成后，所有请求都会到达负载均衡器，然后负载均衡器会将它们路由到运行应用程序的Kubernetes pod</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用多个k8s集群"><a href="#使用多个k8s集群" class="headerlink" title="使用多个k8s集群"></a>使用多个k8s集群</h4><p>Using multiple Kubernetes clusters</p><p>使用Auto DevOps时，您可能希望将不同的环境部署到不同的Kubernetes集群。<br>在Auto DevOps template中，您需要知道3个已定义的环境名称：</p><ul><li><code>review/</code> (从<code>review/</code>开始每个环境)</li><li><code>staging</code></li><li><code>production</code></li></ul><p><br></p><p>这些环境与使用自动部署的作业相关联，因此除了环境范围之外，它们还需要具有部署到的不同域。这就是您需要根据环境为上述所有内容定义单独的<code>AUTO_DEVOPS_DOMAIN</code>变量的原因。</p><p><br></p><p>下表是如何配置三个不同群集的示例:</p><table><thead><tr><th>集群名</th><th>集群环境范围</th><th><code>AUTO_DEVOPS_DOMAIN</code>变量值</th><th>环境变量范围</th><th>备注</th></tr></thead><tbody><tr><td>review</td><td><code>review/*</code></td><td><code>review.example.com</code></td><td><code>review/*</code></td><td>The review cluster which will run all Review Apps. <code>*</code> is a wildcard, which means it will be used by every environment name starting with <code>review/.</code></td></tr><tr><td>staging</td><td><code>staging</code></td><td><code>staging.example.com</code></td><td><code>staging</code></td><td>(Optional) The staging cluster which will run the deployments of the staging environments. You need to enable it first.</td></tr><tr><td>production</td><td><code>production</code></td><td><code>example.com</code></td><td><code>production</code></td><td>The production cluster which will run the deployments of the production environment. You can use incremental rollouts.</td></tr></tbody></table><p><br></p><p>要为每个环境添加不同的群集：</p><ul><li>项目的Operations -&gt; Kubernetes并使用各自的环境范围创建Kubernetes集群，如上表所述</li><li>创建群集后，到每个群集并安装Helm Tiller和Ingress</li><li>确保已使用指定的自动化运维域配置DNS</li><li>到项目的Settings -&gt; CI/CD -&gt; Variables，添加<code>AUTO_DEVOPS_DOMAIN</code>变量及其各自的环境范围。</li></ul><p><br></p><blockquote><p><strong>注意：</strong><br>具有多个群集的组不支持自动DevOps，因为无法在组级别上为每个环境设置<code>AUTO_DEVOPS_DOMAIN</code>。</p></blockquote><p><br><br><br></p><h4 id="启用-禁用Auto-DevOps"><a href="#启用-禁用Auto-DevOps" class="headerlink" title="启用/禁用Auto DevOps"></a>启用/禁用Auto DevOps</h4><p>首次使用Auto Devops时，请查看要求以确保可以使用所有必要的组件来充分利用Auto DevOps。</p><p><br></p><p><strong>在实例级别启用/禁用Auto DevOps（仅限管理员）</strong></p><ul><li>Admin area -&gt; Settings -&gt; Continuous Integration and Deployment</li><li><code>Default to Auto DevOps pipeline for all projects</code></li><li><code>base domain</code></li></ul><p><br></p><p><strong>在项目级别启用/禁用 Auto DevOps</strong></p><ul><li>project’s Settings -&gt; CI/CD -&gt; Auto DevOps</li><li><code>Default to Auto DevOps pipeline</code></li><li><code>Domain</code></li><li><code>Deployment strategy</code></li></ul><p><br></p><p><strong>部署策略(Deployment strategy)</strong></p><blockquote><p>Introduced in GitLab 11.0</p></blockquote><p>你可以更改项目的部署策略。有三种策略:</p><ul><li><strong>Continuous deployment to production</strong>: 允许<code>master</code>分支启用Auto Deploy来直接部署到生产环境</li><li><strong>Continuous deployment to production using timed incremental rollout</strong>: 将<code>INCREMENTAL_ROLLOUT_MODE</code>变量设置为<code>timed</code>，并且将在<code>rollout</code>的每个增量之间延迟5分钟执行生产部署</li><li><strong>Automatic deployment to staging, manual deployment to production</strong>: 设置<code>STAGING_ENABLED</code>为1，<code>INCREMENTAL_ROLLOUT_MODE</code>为<code>manual</code>。提供手动操作以部署到生产环境</li></ul><p><br><br><br></p><h4 id="自动化运维的阶段"><a href="#自动化运维的阶段" class="headerlink" title="自动化运维的阶段"></a>自动化运维的阶段</h4><p>Stages of Auto DevOps</p><p>以下部分描述了Auto DevOps的各个阶段。仔细阅读它们以了解每个工作原理。</p><p><br></p><h5 id="Auto-Build"><a href="#Auto-Build" class="headerlink" title="Auto Build"></a>Auto Build</h5><p>自动化构建有两种方式创建应用程序的构建：</p><ul><li>如果有<code>Dockerfile</code>, 则使用<code>docker build</code>来创建镜像</li><li>否则，它将使用Herokuish和Heroku buildpacks自动检测并将应用程序构建到Docker镜像中</li></ul><p>无论哪种方式，生成的Docker镜像都会自动推送到Container Registry并使用commit SHA进行标记。</p><blockquote><p><strong>重要提示：</strong><br>如果您还使用Auto Review和Auto Deploy并选择提供自己的<code>Dockerfile</code>，请确保将应用程序expose到端口5000，因为这是默认Helm图表所假定的端口。</p></blockquote><p><br></p><h5 id="Auto-Test"><a href="#Auto-Test" class="headerlink" title="Auto Test"></a>Auto Test</h5><p>Auto Test通过分析您的项目来检测语言和框架，使用Herokuish和Heroku buildpacket自动为您的应用程序运行相应的测试。自动检测多种语言和框架，但如果未检测到您的语言，您可以使用自定义构建包(Custom buildpacks)。可检查当前支持的语言。</p><blockquote><p><strong>注意：</strong><br>自动测试使用您在应用程序中已有的测试。如果没有测试，则由您来添加它们。</p></blockquote><p><br></p><h5 id="Auto-Code-Quality"><a href="#Auto-Code-Quality" class="headerlink" title="Auto Code Quality"></a>Auto Code Quality</h5><blockquote><p>GitLab STARTER BRONZE</p></blockquote><p>Auto Code Quality使用<code>Code Quality image</code>对当前代码运行静态分析和其他代码检查。报告已创建，并作为工件上传，您可以在以后下载和检查。<br>源分支和目标分支之间的任何差异也会显示在合并请求窗口小部件中。</p><p><br></p><h5 id="Auto-SAST"><a href="#Auto-SAST" class="headerlink" title="Auto SAST"></a>Auto SAST</h5><blockquote><p>GitLab ULTIMATE GOLD</p></blockquote><p>Static Application Security Testing(SAST)使用<code>SAST Docker image</code>对当前代码运行静态分析并检查潜在的安全问题。创建报告后，它将作为工件上载，您可以在以后下载和检查。</p><p><br></p><h5 id="Auto-Dependency-Scanning"><a href="#Auto-Dependency-Scanning" class="headerlink" title="Auto Dependency Scanning"></a>Auto Dependency Scanning</h5><blockquote><p>GitLab ULTIMATE GOLD</p></blockquote><p>Dependency Scanning使用<code>Dependency Scanning Docker image</code>对项目依赖关系进行分析并检查潜在的安全问题。创建报告后，它将作为工件上载，您可以在以后下载和检查。</p><p><br><br><br></p><h5 id="Auto-License-Management"><a href="#Auto-License-Management" class="headerlink" title="Auto License Management"></a>Auto License Management</h5><blockquote><p>GitLab ULTIMATE GOLD</p></blockquote><p>License Management使用<code>License Management Docker image</code>搜索项目依赖项以获取其许可证。创建报告后，它将作为工件上载，您可以在以后下载和检查。</p><p><br></p><h5 id="Auto-Container-Scanning"><a href="#Auto-Container-Scanning" class="headerlink" title="Auto Container Scanning"></a>Auto Container Scanning</h5><blockquote><p>GitLab ULTIMATE</p></blockquote><p>容器的漏洞静态分析使用<code>Clair</code>在Docker image上运行静态分析并检查潜在的安全问题。创建报告后，它将作为工件上载，您可以在以后下载和检查。</p><p><br></p><h5 id="Auto-Review-Apps"><a href="#Auto-Review-Apps" class="headerlink" title="Auto Review Apps"></a>Auto Review Apps</h5><blockquote><p><strong>注意：</strong> 这是一个可选步骤，因为许多项目没有可用的Kubernetes集群。如果不满足要求，将默默跳过作业。<br><strong>警告</strong>：不应在Helm之外操作您的应用程序(直接使用Kubernetes)。这可能会导致Helm无法检测到更改，并且随后使用Auto DevOps进行部署可以撤消您的更改。此外，如果您更改某些内容并希望通过再次部署来撤消它，Helm可能无法检测到任何更改，因此没有意识到它需要重新应用旧配置。</p></blockquote><p>Review App 是基于分支代码的临时应用程序环境，因此开发人员，设计人员，QA，产品经理和其他审阅者可以在审阅过程中实际查看代码更改并与之交互。Auto Review Apps为每个分支创建一个Review App。</p><p>Auto Review Apps 仅将您的应用部署到您的Kubernetes群集。如果没有可用的群集，则不会进行部署。<br>Review App将具有基于项目名，分支名、唯一编号以及Auto DevOps基本域的唯一URL。如：<code>user-project-branch-1234.example.com</code>。审阅应用程序的链接显示在合并请求窗口小部件中，以便于发现。删除分支时，例如合并合并请求后，将自动删除Review App。</p><p><br></p><h5 id="Auto-DAST"><a href="#Auto-DAST" class="headerlink" title="Auto DAST"></a>Auto DAST</h5><blockquote><p>GitLab Ultimate</p></blockquote><p>Dynamic Application Security Testing (DAST)使用流行的开源工具<code>OWASP ZAProxy</code>对当前代码执行分析并检查潜在的安全问题。创建报告后，它将作为工件上载，您可以在以后下载和检查。</p><p><br></p><h5 id="Auto-Browser-Performance-Testing"><a href="#Auto-Browser-Performance-Testing" class="headerlink" title="Auto Browser Performance Testing"></a>Auto Browser Performance Testing</h5><blockquote><p>GitLab Premium</p></blockquote><p>自动浏览器性能测试利用<code>Sitespeed.io</code>容器来衡量网页的性能。创建JSON报告并将其作为工件上载，其中包括每个页面的整体性能分数。默认情况下，将测试Review和Production环境的根页面。如果要添加其他URL以进行测试，只需将路径添加到根目录中名为<code>.gitlab-urls.txt</code>的文件中，每行一个。</p><p>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">/features</span><br><span class="line">/direction</span><br></pre></td></tr></table></figure><p><br></p><h5 id="Auto-Deploy"><a href="#Auto-Deploy" class="headerlink" title="Auto Deploy"></a>Auto Deploy</h5><blockquote><p><strong>注意</strong>：这是一个可选步骤，因为许多项目没有可用的Kubernetes集群。如果不满足要求，将默默跳过作业。<br><strong>警告</strong>：不应在Helm之外操作您的应用程序（直接使用Kubernetes）。这可能会导致Helm无法检测到更改，并且随后使用Auto DevOps进行部署可以撤消您的更改。此外，如果您更改某些内容并希望通过再次部署来撤消它，Helm可能无法检测到任何更改，因此没有意识到它需要重新应用旧配置。</p></blockquote><p>将branch或merge request合并到项目的默认分支（通常是master）后，Auto Deploy将应用程序部署到Kubernetes集群中的生产环境，其中包含基于项目名称和唯一项目ID的命名空间。<br>您可以使用环境变量自动伸缩pod副本。</p><p>值得注意的是，当项目部署到Kubernetes集群时，它依赖于已推送到GitLab Container Registry的Docker image。k8s获取此镜像并运行应用。如果项目是公共的，Kubernetes可以在不进行任何身份验证的情况下访问该映像，从而使我们可以使部署更加可用。如果项目是私有/内部的，则注册表需要凭据才能提取镜像。目前，通过提供<code>CI_JOB_TOKEN</code>作为可以使用的密码来解决此问题，但是一旦部署作业完成，此标记将不再有效。这意味着Kubernetes可以运行应用程序，但是如果它应该重新启动或在其他地方执行，则无法再次访问。</p><p><br></p><h5 id="Auto-Monitoring"><a href="#Auto-Monitoring" class="headerlink" title="Auto Monitoring"></a>Auto Monitoring</h5><blockquote><p><strong>注意</strong>：检查自动监控的要求以使此阶段工作。</p></blockquote><p>部署应用程序后，自动监控可以立即监控应用程序的服务器和响应指标。自动监控使用Prometheus直接从Kubernetes获取系统指标，如CPU和内存使用情况，以及来自NGINX服务器的响应指标，如HTTP错误率，延迟和吞吐量。</p><p>指标有：</p><ul><li><strong>Response Metrics</strong>: latency, throughput, error rate</li><li><strong>System Metrics</strong>: CPU utilization, memory utilization</li></ul><p>为了使用监控，你需要：</p><ul><li>将Prometheus部署到k8s集群中</li><li>配置Prometheus以获取想要的指标</li></ul><p><br><br><br></p><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>Customizing</p><p>虽然Auto DevOps提供了很好的默认设置来帮助您入门，但您可以自定义几乎所有内容以满足您的需求;从自定义buildpacks到Dockerfiles，Helm chart，甚至将完整的CI/CD配置复制到项目中进行部署。</p><p><br></p><h5 id="Custom-buildpacks"><a href="#Custom-buildpacks" class="headerlink" title="Custom buildpacks"></a>Custom buildpacks</h5><p>如果项目的自动buildpack检测失败，或者您想使用自定义buildpack，则可以使用项目变量或项目中的<code>.buildpacks</code>文件覆盖buildpack:</p><ul><li><strong>Project variable</strong>: 使用要使用的buildpack的URL创建项目变量<code>BUILDPACK_URL</code></li><li><code>.buildpacks</code>文件: 在项目中添加一个名为<code>.buildpacks</code>的文件，并添加要在文件中的一行使用的buildpack的URL(多个使用多行，一行一个)</li></ul><blockquote><p><strong>警告</strong>：Auto DevOps尚不支持使用多个buildpack</p></blockquote><p><br></p><h5 id="Custom-Dockerfile"><a href="#Custom-Dockerfile" class="headerlink" title="Custom Dockerfile"></a>Custom <code>Dockerfile</code></h5><p>如果您的项目的根目录中有一个<code>Dockerfile</code>，则Auto DevOps将基于Dockerfile而不是使用buildpacks构建Docker镜像。这可以更快，并导致更小的图像，尤其是如果您的Dockerfile基于Alpine。</p><p><br></p><h5 id="Custom-Helm-Chart"><a href="#Custom-Helm-Chart" class="headerlink" title="Custom Helm Chart"></a>Custom Helm Chart</h5><p>Auto DevOps使用Helm将您的应用程序部署到Kubernetes。您可以通过将chart捆绑到项目仓库中或通过指定项目变量来覆盖使用的Helm chart：</p><ul><li><strong>Bundled chart</strong>: 如果您的项目有一个带有<code>Chart.yaml</code>文件的<code>./chart</code>目录，Auto DevOps将检测chart并使用它而不是默认chart。这可以很好地控制应用程序的部署方式</li><li><strong>Project variable</strong>: 使用要使用的自定义chart的URL创建项目变量<code>AUTO_DEVOPS_CHART</code></li></ul><p><br></p><h5 id="Customizing-gitlab-ci-yml"><a href="#Customizing-gitlab-ci-yml" class="headerlink" title="Customizing .gitlab-ci.yml"></a>Customizing <code>.gitlab-ci.yml</code></h5><p>如果要修改Auto DevOps使用的CI/CD pipeline，可以将<a href="https://gitlab.com/gitlab-org/gitlab-ce/blob/master/lib/gitlab/ci/templates/Auto-DevOps.gitlab-ci.yml" title="Template" target="_blank" rel="noopener">Auto DevOps template</a>复制到项目的repo中并根据需要进行编辑。</p><p>假设您的项目是新的或者没有<code>.gitlab-ci.yml</code>文件：</p><ul><li>在项目 CI/CD里面新建文件</li><li>选择<code>.gitlab-ci.yml</code>模板</li><li>选择Auto-DevOps</li><li>编辑此模板</li><li>提交</li></ul><blockquote><p><strong>提示</strong>：Auto DevOps模板包含有用的注释，可帮助您自定义它。如果您希望部署转到临时(staging)环境而不是直接转到生产(production)环境，则可以通过将<code>.staging</code>重命名为<code>staging</code>来启用<code>staging</code>作业；然后确保取消注释生产作业的<code>when</code>，将其转换为手动操作，而不是自动部署。</p></blockquote><p><br></p><h5 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h5><p>为了支持需要数据库的应用程序，默认情况下会配置PostgreSQL。访问数据库的凭据已预先配置，但可以通过设置关联的变量进行自定义。这些凭据可用于定义<code>DATABASE_URL</code>的格式：<code>postgres://user:password@postgres-host:postgres-port/postgres-database</code></p><p><br></p><h5 id="Environment-variables"><a href="#Environment-variables" class="headerlink" title="Environment variables"></a>Environment variables</h5><p>以下变量可用于设置Auto DevOps domain，提供自定义Helm chart或扩展应用程序。 PostgreSQL也可以自定义，您可以轻松使用自定义buildpack。</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>AUTO_DEVOPS_DOMAIN</code></td><td>Auto DevOps domain</td></tr><tr><td><code>AUTO_DEVOPS_CHART</code></td><td>用于部署应用的Helm Chart</td></tr><tr><td><code>REPLICAS</code></td><td>要部署的副本数，默认为1</td></tr><tr><td><code>PRODUCTION_REPLICAS</code></td><td>要在生产环境中部署的副本数。这优先于<code>REPLICAS</code>;默认为1</td></tr><tr><td><code>CANARY_REPLICAS</code></td><td>Canary Deployments部署的副本数，默认为1</td></tr><tr><td><code>CANARY_PRODUCTION_REPLICAS</code></td><td>生产环境的，优先于<code>CANARY_REPLICAS</code>，默认为1</td></tr><tr><td><code>POSTGRES_ENABLED</code></td><td>是否启用PostgreSQL,默认为<code>true</code></td></tr><tr><td><code>POSTGRES_USER</code></td><td>PostgreSQL用户，默认为<code>user</code></td></tr><tr><td><code>POSTGRES_PASSWORD</code></td><td>PostgreSQL密码，默认为<code>testing-password</code></td></tr><tr><td><code>POSTGRES_DB</code></td><td>PostgreSQL数据库名称;默认值为<code>$CI_ENVIRONMENT_SLUG</code></td></tr><tr><td><code>BUILDPACK_URL</code></td><td>buildpack的完整URL</td></tr><tr><td><code>SAST_CONFIDENCE_LEVEL</code></td><td>您希望报告的安全问题的最低置信度; 1为低，2为中，3为高;默认为3</td></tr><tr><td><code>DEP_SCAN_DISABLE_REMOTE_CHECKS</code></td><td>是否禁用远程依赖扫描检查;默认为<code>false</code></td></tr><tr><td><code>DB_INITIALIZE</code></td><td>从GitLab 11.4开始，此变量可用于指定运行以初始化应用程序的PostgreSQL数据库的命令。它在应用程序pod内运行</td></tr><tr><td><code>DB_MIGRATE</code></td><td>从GitLab 11.4开始，此变量可用于指定运行以迁移应用程序的PostgreSQL数据库的命令。它在应用程序pod内运行</td></tr><tr><td><code>STAGING_ENABLED</code></td><td>可用于定义部署策略</td></tr><tr><td><code>CANARY_ENABLED</code></td><td>定义canary部署策略</td></tr><tr><td><code>INCREMENTAL_ROLLOUT_MODE</code></td><td>从GitLab 11.4开始，此变量（如果存在）可用于为生产环境启用应用程序的增量部署</td></tr><tr><td><code>TEST_DISABLED</code></td><td>从GitLab 11.0开始，此变量可用于禁用测试作业</td></tr><tr><td><code>CODE_QUALITY_DISABLED</code></td><td>从GitLab 11.0开始，此变量可用于禁用代码质量作业</td></tr><tr><td><code>SAST_DISABLED</code></td><td>从GitLab 11.0开始，此变量可用于禁用sast作业</td></tr><tr><td><code>DEPENDENCY_SCANNING_DISABLED</code></td><td>从GitLab 11.0开始，此变量可用于禁用<code>dependency_scanning</code>作业</td></tr><tr><td><code>CONTAINER_SCANNING_DISABLED</code></td><td>从GitLab 11.0开始，此变量可用于禁用<code>sast：container</code>作业</td></tr><tr><td><code>REVIEW_DISABLED</code></td><td>从GitLab 11.0开始，此变量可用于禁用审核和手动审核：停止作业</td></tr><tr><td><code>PERFORMANCE_DISABLED</code></td><td>从GitLab 11.0开始，此变量可用于禁用性能作业</td></tr></tbody></table><p><br></p><blockquote><p><strong>提示</strong>：使用项目变量设置副本变量，并通过重新部署来扩展应用程序！<br><strong>小心</strong>: 你不应该直接使用k8s来扩展你的应用程序，这可能会导致Helm异常。</p></blockquote><p><br></p><p><strong>高级副本变量设置(Advanced replica variables setup)</strong></p><p>除了上面提到的两个与副本相关的生产变量之外，您还可以将其它变量用于不同的环境。</p><p><br><br><br></p><h4 id="目前支持的语言"><a href="#目前支持的语言" class="headerlink" title="目前支持的语言"></a>目前支持的语言</h4><p>Currently supported languages</p><p>从GitLab 10.0开始，支持的构建包是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">heroku-buildpack-multi</span>     <span class="string">v1.0.0</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">heroku-buildpack-ruby</span>      <span class="string">v168</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">heroku-buildpack-nodejs</span>    <span class="string">v99</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">heroku-buildpack-clojure</span>   <span class="string">v77</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">heroku-buildpack-python</span>    <span class="string">v99</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">heroku-buildpack-java</span>      <span class="string">v53</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">heroku-buildpack-gradle</span>    <span class="string">v23</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">heroku-buildpack-scala</span>     <span class="string">v78</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">heroku-buildpack-play</span>      <span class="string">v26</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">heroku-buildpack-php</span>       <span class="string">v122</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">heroku-buildpack-go</span>        <span class="string">v72</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">heroku-buildpack-erlang</span>    <span class="string">fa17af9</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">buildpack-nginx</span>            <span class="string">v8</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Auto-DevOps-template"><a href="#Auto-DevOps-template" class="headerlink" title="Auto DevOps template"></a>Auto DevOps template</h3><p>各种模板: <a href="https://gitlab.com/gitlab-org/gitlab-ce/tree/master/lib/gitlab/ci/templates" target="_blank" rel="noopener">https://gitlab.com/gitlab-org/gitlab-ce/tree/master/lib/gitlab/ci/templates</a></p><p>在项目也可选择新建<code>.gitlab-ci.yml</code>模板文件，然后根据需要就行适当的修改。</p><p><br><br><br><br><br></p><h3 id="CI-CD环境变量"><a href="#CI-CD环境变量" class="headerlink" title="CI/CD环境变量"></a><code>CI/CD</code>环境变量</h3><p>CI/CD Variables - Learn how to use variables defined in your <code>.gitlab-ci.yml</code> or the ones defined in your project’s settings</p><p>当从GitLab CI接收作业时，Runner准备构建环境。首先，设置预定义变量列表<strong>predefined variables</strong>（环境变量）和用户定义变量列表<strong>user-defined variables</strong>。</p><p><br><br><br></p><h4 id="变量优先级"><a href="#变量优先级" class="headerlink" title="变量优先级"></a>变量优先级</h4><p>Priority of variables</p><p>变量可以被覆盖，并且它们按此顺序优先于彼此：</p><ol><li>Trigger variables / scheduled pipeline variables</li><li>Project-level variables / protected variables</li><li>Group-level variables / protected variables</li><li>YAML-defined job-level variables</li><li>YAML-defined global variables</li><li>Deployment variables</li><li>Predefined variables</li></ol><p><br><br><br></p><h4 id="不支持的变量"><a href="#不支持的变量" class="headerlink" title="不支持的变量"></a>不支持的变量</h4><p>在某些情况下，某些变量无法在<code>.gitlab-ci.yml</code>定义的上下文中使用——如在<code>script</code>下定义的变量。</p><p><br><br><br></p><h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>Predefined variables (Environment variables)</p><blockquote><p><strong>注意：</strong><br>从<code>GitLab 9.0</code>开始，我们已经弃用了一些变量。阅读<code>9.0</code>重命名部分以找出它们的替代品。强烈建议您使用新变量，因为我们将在以后的GitLab版本中删除旧变量。</p></blockquote><table><thead><tr><th>Variable</th><th>GitLab</th><th>Runner</th><th>Description</th></tr></thead><tbody><tr><td><code>ARTIFACT_DOWNLOAD_ATTEMPTS</code></td><td>8.15</td><td>1.9</td><td>Number of attempts to download artifacts running a job</td></tr><tr><td><code>CI</code></td><td>all</td><td>0.4</td><td>Mark that job is executed in CI environment</td></tr><tr><td><code>CI_COMMIT_BEFORE_SHA</code></td><td>11.2</td><td>all</td><td>The previous latest commit present on a branch before a push request.</td></tr><tr><td><code>CI_COMMIT_DESCRIPTION</code></td><td>10.8</td><td>all</td><td>The description of the commit: the message without first line, if the title is shorter than 100 characters; full message in other case.</td></tr><tr><td><code>CI_COMMIT_MESSAGE</code></td><td>10.8</td><td>all</td><td>The full commit message.</td></tr><tr><td><code>CI_COMMIT_REF_NAME</code></td><td>9.0</td><td>all</td><td>The branch or tag name for which project is built</td></tr><tr><td><code>CI_COMMIT_REF_SLUG</code></td><td>9.0</td><td>all</td><td>$CI_COMMIT_REF_NAME lowercased, shortened to 63 bytes, and with everything except 0-9 and a-z replaced with -. No leading / trailing -. Use in URLs, host names and domain names.</td></tr><tr><td><code>CI_COMMIT_SHA</code></td><td>9.0</td><td>all</td><td>The commit revision for which project is built</td></tr><tr><td><code>CI_COMMIT_SHORT_SHA</code></td><td>11.7</td><td>all</td><td>The first eight characters of CI_COMMIT_SHA</td></tr><tr><td><code>CI_COMMIT_TAG</code></td><td>9.0</td><td>0.5</td><td>The commit tag name. Present only when building tags.</td></tr><tr><td><code>CI_COMMIT_TITLE</code></td><td>10.8</td><td>all</td><td>The title of the commit - the full first line of the message</td></tr><tr><td><code>CI_CONFIG_PATH</code></td><td>9.4</td><td>0.5</td><td>The path to CI config file. Defaults to .gitlab-ci.yml</td></tr><tr><td><code>CI_DEBUG_TRACE</code></td><td>all</td><td>1.7</td><td>Whether debug tracing is enabled</td></tr><tr><td><code>CI_DEPLOY_PASSWORD</code></td><td>10.8</td><td>all</td><td>Authentication password of the GitLab Deploy Token, only present if the Project has one related.</td></tr><tr><td><code>CI_DEPLOY_USER</code></td><td>10.8</td><td>all</td><td>Authentication username of the GitLab Deploy Token, only present if the Project has one related.</td></tr><tr><td><code>CI_DISPOSABLE_ENVIRONMENT</code></td><td>all</td><td>10.1</td><td>Marks that the job is executed in a disposable environment (something that is created only for this job and disposed of/destroyed after the execution - all executors except shell and ssh). If the environment is disposable, it is set to true, otherwise it is not defined at all.</td></tr><tr><td><code>CI_ENVIRONMENT_NAME</code></td><td>8.15</td><td>all</td><td>The name of the environment for this job</td></tr><tr><td><code>CI_ENVIRONMENT_SLUG</code></td><td>8.15</td><td>all</td><td>A simplified version of the environment name, suitable for inclusion in DNS, URLs, Kubernetes labels, etc.</td></tr><tr><td><code>CI_ENVIRONMENT_URL</code></td><td>9.3</td><td>all</td><td>The URL of the environment for this job</td></tr><tr><td><code>CI_JOB_ID</code></td><td>9.0</td><td>all</td><td>The unique id of the current job that GitLab CI uses internally</td></tr><tr><td><code>CI_JOB_MANUAL</code></td><td>8.12</td><td>all</td><td>The flag to indicate that job was manually started</td></tr><tr><td><code>CI_JOB_NAME</code></td><td>9.0</td><td>0.5</td><td>The name of the job as defined in .gitlab-ci.yml</td></tr><tr><td><code>CI_JOB_STAGE</code></td><td>9.0</td><td>0.5</td><td>The name of the stage as defined in .gitlab-ci.yml</td></tr><tr><td><code>CI_JOB_TOKEN</code></td><td>9.0</td><td>1.2</td><td>Token used for authenticating with the GitLab Container Registry and downloading dependent repositories</td></tr><tr><td><code>CI_JOB_URL</code></td><td>11.1</td><td>0.5</td><td>Job details URL</td></tr><tr><td><code>CI_MERGE_REQUEST_ID</code></td><td>11.6</td><td>all</td><td>The ID of the merge request if it’s pipelines for merge requests</td></tr><tr><td><code>CI_MERGE_REQUEST_IID</code></td><td>11.6</td><td>all</td><td>The IID of the merge request if it’s pipelines for merge requests</td></tr><tr><td><code>CI_MERGE_REQUEST_PROJECT_ID</code></td><td>11.6</td><td>all</td><td>The ID of the project of the merge request if it’s pipelines for merge requests</td></tr><tr><td><code>CI_MERGE_REQUEST_PROJECT_PATH</code></td><td>11.6</td><td>all</td><td>The path of the project of the merge request if it’s pipelines for merge requests (e.g. namespace/awesome-project)</td></tr><tr><td><code>CI_MERGE_REQUEST_PROJECT_URL</code></td><td>11.6</td><td>all</td><td>The URL of the project of the merge request if it’s pipelines for merge requests (e.g. <a href="http://192.168.10.15:3000/namespace/awesome-project" target="_blank" rel="noopener">http://192.168.10.15:3000/namespace/awesome-project</a>)</td></tr><tr><td><code>CI_MERGE_REQUEST_REF_PATH</code></td><td>11.6</td><td>all</td><td>The ref path of the merge request if it’s pipelines for merge requests. (e.g. refs/merge-requests/1/head)</td></tr><tr><td><code>CI_MERGE_REQUEST_SOURCE_BRANCH_NAME</code></td><td>11.6</td><td>all</td><td>The source branch name of the merge request if it’s pipelines for merge requests</td></tr><tr><td>CI_MERGE_REQUEST_SOURCE_PROJECT_ID</td><td>11.6</td><td>all</td><td>The ID of the source project of the merge request if it’s pipelines for merge requests</td></tr><tr><td>CI_MERGE_REQUEST_SOURCE_PROJECT_PATH</td><td>11.6</td><td>all</td><td>The path of the source project of the merge request if it’s pipelines for merge requests</td></tr><tr><td>CI_MERGE_REQUEST_SOURCE_PROJECT_URL</td><td>11.6</td><td>all</td><td>The URL of the source project of the merge request if it’s pipelines for merge requests</td></tr><tr><td>CI_MERGE_REQUEST_TARGET_BRANCH_NAME</td><td>11.6</td><td>all</td><td>The target branch name of the merge request if it’s pipelines for merge requests</td></tr><tr><td>CI_NODE_INDEX</td><td>11.5</td><td>all</td><td>Index of the job in the job set. If the job is not parallelized, this variable is not set.</td></tr><tr><td>CI_NODE_TOTAL</td><td>11.5</td><td>all</td><td>Total number of instances of this job running in parallel. If the job is not parallelized, this variable is set to 1.</td></tr><tr><td>CI_API_V4_URL</td><td>11.7</td><td>all</td><td>The GitLab API v4 root URL</td></tr><tr><td>CI_PIPELINE_ID</td><td>8.10</td><td>all</td><td>The unique id of the current pipeline that GitLab CI uses internally</td></tr><tr><td>CI_PIPELINE_IID</td><td>11.0</td><td>all</td><td>The unique id of the current pipeline scoped to project</td></tr><tr><td>CI_PIPELINE_SOURCE</td><td>10.0</td><td>all</td><td>Indicates how the pipeline was triggered. Possible options are: push, web, trigger, schedule, api, and pipeline. For pipelines created before GitLab 9.5, this will show as unknown</td></tr><tr><td>CI_PIPELINE_TRIGGERED</td><td>all</td><td>all</td><td>The flag to indicate that job was triggered</td></tr><tr><td>CI_PIPELINE_URL</td><td>11.1</td><td>0.5</td><td>Pipeline details URL</td></tr><tr><td>CI_PROJECT_DIR</td><td>all</td><td>all</td><td>The full path where the repository is cloned and where the job is run</td></tr><tr><td>CI_PROJECT_ID</td><td>all</td><td>all</td><td>The unique id of the current project that GitLab CI uses internally</td></tr><tr><td>CI_PROJECT_NAME</td><td>8.10</td><td>0.5</td><td>The project name that is currently being built (actually it is project folder name)</td></tr><tr><td>CI_PROJECT_NAMESPACE</td><td>8.10</td><td>0.5</td><td>The project namespace (username or groupname) that is currently being built</td></tr><tr><td>CI_PROJECT_PATH</td><td>8.10</td><td>0.5</td><td>The namespace with project name</td></tr><tr><td>CI_PROJECT_PATH_SLUG</td><td>9.3</td><td>all</td><td>$CI_PROJECT_PATH lowercased and with everything except 0-9 and a-z replaced with -. Use in URLs and domain names.</td></tr><tr><td>CI_PROJECT_URL</td><td>8.10</td><td>0.5</td><td>The HTTP address to access project</td></tr><tr><td>CI_PROJECT_VISIBILITY</td><td>10.3</td><td>all</td><td>The project visibility (internal, private, public)</td></tr><tr><td>CI_REGISTRY</td><td>8.10</td><td>0.5</td><td>If the Container Registry is enabled it returns the address of GitLab’s Container Registry</td></tr><tr><td>CI_REGISTRY_IMAGE</td><td>8.10</td><td>0.5</td><td>If the Container Registry is enabled for the project it returns the address of the registry tied to the specific project</td></tr><tr><td>CI_REGISTRY_PASSWORD</td><td>9.0</td><td>all</td><td>The password to use to push containers to the GitLab Container Registry</td></tr><tr><td>CI_REGISTRY_USER</td><td>9.0</td><td>all</td><td>The username to use to push containers to the GitLab Container Registry</td></tr><tr><td>CI_REPOSITORY_URL</td><td>9.0</td><td>all</td><td>The URL to clone the Git repository</td></tr><tr><td>CI_RUNNER_DESCRIPTION</td><td>8.10</td><td>0.5</td><td>The description of the runner as saved in GitLab</td></tr><tr><td>CI_RUNNER_EXECUTABLE_ARCH</td><td>all</td><td>10.6</td><td>The OS/architecture of the GitLab Runner executable (note that this is not necessarily the same as the environment of the executor)</td></tr><tr><td>CI_RUNNER_ID</td><td>8.10</td><td>0.5</td><td>The unique id of runner being used</td></tr><tr><td>CI_RUNNER_REVISION</td><td>all</td><td>10.6</td><td>GitLab Runner revision that is executing the current job</td></tr><tr><td>CI_RUNNER_TAGS</td><td>8.10</td><td>0.5</td><td>The defined runner tags</td></tr><tr><td>CI_RUNNER_VERSION</td><td>all</td><td>10.6</td><td>GitLab Runner version that is executing the current job</td></tr><tr><td>CI_SERVER</td><td>all</td><td>all</td><td>Mark that job is executed in CI environment</td></tr><tr><td>CI_SERVER_NAME</td><td>all</td><td>all</td><td>The name of CI server that is used to coordinate jobs</td></tr><tr><td>CI_SERVER_REVISION</td><td>all</td><td>all</td><td>GitLab revision that is used to schedule jobs</td></tr><tr><td>CI_SERVER_VERSION</td><td>all</td><td>all</td><td>GitLab version that is used to schedule jobs</td></tr><tr><td>CI_SERVER_VERSION_MAJOR</td><td>11.4</td><td>all</td><td>GitLab version major component</td></tr><tr><td>CI_SERVER_VERSION_MINOR</td><td>11.4</td><td>all</td><td>GitLab version minor component</td></tr><tr><td>CI_SERVER_VERSION_PATCH</td><td>11.4</td><td>all</td><td>GitLab version patch component</td></tr><tr><td>CI_SHARED_ENVIRONMENT</td><td>all</td><td>10.1</td><td>Marks that the job is executed in a shared environment (something that is persisted across CI invocations like shell or ssh executor). If the environment is shared, it is set to true, otherwise it is not defined at all.</td></tr><tr><td>GET_SOURCES_ATTEMPTS</td><td>8.15</td><td>1.9</td><td>Number of attempts to fetch sources running a job</td></tr><tr><td>GITLAB_CI</td><td>all</td><td>all</td><td>Mark that job is executed in GitLab CI environment</td></tr><tr><td>GITLAB_USER_EMAIL</td><td>8.12</td><td>all</td><td>The email of the user who started the job</td></tr><tr><td>GITLAB_USER_ID</td><td>8.12</td><td>all</td><td>The id of the user who started the job</td></tr><tr><td>GITLAB_USER_LOGIN</td><td>10.0</td><td>all</td><td>The login username of the user who started the job</td></tr><tr><td>GITLAB_USER_NAME</td><td>10.0</td><td>all</td><td>The real name of the user who started the job</td></tr><tr><td>RESTORE_CACHE_ATTEMPTS</td><td>8.15</td><td>1.9</td><td>Number of attempts to restore the cache running a job</td></tr></tbody></table><p><br></p><p><strong>GitLab 9.0 renaming</strong></p><table><thead><tr><th>8.x name</th><th>9.0+ name</th></tr></thead><tbody><tr><td>CI_BUILD_ID</td><td>CI_JOB_ID</td></tr><tr><td>CI_BUILD_REF</td><td>CI_COMMIT_SHA</td></tr><tr><td>CI_BUILD_TAG</td><td>CI_COMMIT_TAG</td></tr><tr><td>CI_BUILD_BEFORE_SHA</td><td>CI_COMMIT_BEFORE_SHA</td></tr><tr><td>CI_BUILD_REF_NAME</td><td>CI_COMMIT_REF_NAME</td></tr><tr><td>CI_BUILD_REF_SLUG</td><td>CI_COMMIT_REF_SLUG</td></tr><tr><td>CI_BUILD_NAME</td><td>CI_JOB_NAME</td></tr><tr><td>CI_BUILD_STAGE</td><td>CI_JOB_STAGE</td></tr><tr><td>CI_BUILD_REPO</td><td>CI_REPOSITORY_URL</td></tr><tr><td>CI_BUILD_TRIGGERED</td><td>CI_PIPELINE_TRIGGERED</td></tr><tr><td>CI_BUILD_MANUAL</td><td>CI_JOB_MANUAL</td></tr><tr><td>CI_BUILD_TOKEN</td><td>CI_JOB_TOKEN</td></tr></tbody></table><p><br><br><br></p><h4 id="gitlab-ci-yml定义的变量"><a href="#gitlab-ci-yml定义的变量" class="headerlink" title=".gitlab-ci.yml定义的变量"></a><code>.gitlab-ci.yml</code>定义的变量</h4><p>GitLab CI允许您添加在构建环境中设置的<code>.gitlab-ci.yml</code>变量。因此，变量保存在存储库中，它们用于存储非敏感项目配置。</p><p><br><br><br></p><h4 id="组-库级别变量"><a href="#组-库级别变量" class="headerlink" title="组/库级别变量"></a>组/库级别变量</h4><p>这个变量在Web UI上进行配置。</p><p><br><br><br><br><br></p><h3 id="gitlab-ci-yml配置"><a href="#gitlab-ci-yml配置" class="headerlink" title=".gitlab-ci.yml配置"></a><code>.gitlab-ci.yml</code>配置</h3><p>使用<code>.gitlab-ci.yml</code>配置你的Jobs，该文件是GitLab Runner用来管理项目作业的文件。</p><p><br></p><h4 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h4><p>YAML文件定义了一组具有约束的作业，说明应该何时运行它们。您可以指定无限数量的作业，这些作业被定义为具有任意名称的顶级元素，并且始终必须至少包含<code>script</code>子句。<br>可以是直接运行命令，也可以写成<code>xxx.sh</code>脚本，然后执行此脚本。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#两个单独的作业，执行各自的命令</span></span><br><span class="line"><span class="attr">job1:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">"execute-script-for-job1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job2:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">"execute-script-for-job2"</span></span><br></pre></td></tr></table></figure><p>Runner选择Job并在Runner的环境中执行。重要的是，每项工作都是相互独立运作的，这里可对比Jenkins里面的workspace。</p><p>每个作业必须具有唯一的名称，但有一些<strong>保留的关键字(keywords)</strong>不能用作作业名称:</p><ul><li><code>image</code></li><li><code>services</code></li><li><code>stages</code></li><li><code>types</code></li><li><code>before_script</code></li><li><code>after_script</code></li><li><code>variables</code></li><li><code>cache</code></li></ul><p><br></p><p><strong>作业由定义作业行为的参数列表定义:</strong></p><table><thead><tr><th>Keyword</th><th>Required</th><th>Description</th></tr></thead><tbody><tr><td><code>script</code></td><td>yes</td><td>Defines a shell script which is executed by Runner</td></tr><tr><td><code>extends</code></td><td>no</td><td>Defines a configuration entry that this job is going to inherit from</td></tr><tr><td><code>image</code></td><td>no</td><td>Use docker image, covered in Using Docker Images</td></tr><tr><td><code>services</code></td><td>no</td><td>Use docker services, covered in Using Docker Images</td></tr><tr><td><code>stage</code></td><td>no</td><td>Defines a job stage (default: <code>test</code>)</td></tr><tr><td><code>type</code></td><td>no</td><td>Alias for <code>stage</code></td></tr><tr><td><code>variables</code></td><td>no</td><td>Define job variables on a job level</td></tr><tr><td><code>only</code></td><td>no</td><td>Defines a list of git refs for which job is created</td></tr><tr><td><code>except</code></td><td>no</td><td>Defines a list of git refs for which job is not created</td></tr><tr><td><code>tags</code></td><td>no</td><td>Defines a list of tags which are used to select Runner</td></tr><tr><td><code>allow_failure</code></td><td>no</td><td>Allow job to fail. Failed job doesn’t contribute to commit status</td></tr><tr><td><code>when</code></td><td>no</td><td>Define when to run job. Can be <code>on_success</code>, <code>on_failure</code>, <code>always</code> or `manual</td></tr><tr><td><code>dependencies</code></td><td>no</td><td>Define other jobs that a job depends on so that you can pass artifacts between them</td></tr><tr><td><code>artifacts</code></td><td>no</td><td>Define list of job artifacts</td></tr><tr><td><code>cache</code></td><td>no</td><td>Define list of files that should be cached between subsequent runs</td></tr><tr><td><code>before_script</code></td><td>no</td><td>Override a set of commands that are executed before job</td></tr><tr><td><code>after_script</code></td><td>no</td><td>Override a set of commands that are executed after job</td></tr><tr><td><code>environment</code></td><td>no</td><td>Defines a name of environment to which deployment is done by this job</td></tr><tr><td><code>coverage</code></td><td>no</td><td>Define code coverage settings for a given job</td></tr><tr><td><code>retry</code></td><td>no</td><td>Define when and how many times a job can be auto-retried in case of a failure</td></tr><tr><td><code>parallel</code></td><td>no</td><td>Defines how many instances of a job should be run in parallel</td></tr></tbody></table><p><br><br><br></p><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a><code>extends</code></h4><p><code>extends</code>定义了一个使用<code>extends</code>的作业将继承的条目名称。</p><p>这是使用YAML锚点(anchor)的替代方案，并且更加灵活和可读：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.tests:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">rake</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="attr">    refs:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">branches</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line"><span class="attr">  extends:</span> <span class="string">.tests</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">rake</span> <span class="string">rspec</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">$RSPEC</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，rspec作业继承自<code>.tests</code>模板作业。GitLab将根据键执行反向深度合并。GitLab将:</p><ul><li>将<code>rspec</code>内容以递归方式合并到<code>.tests</code>中</li><li>Not merge the values of the keys</li></ul><p>这导致以下<code>rspec</code>作业:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注意，script: rake test将被script: rake rspec覆盖</span></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">rake</span> <span class="string">rspec</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="attr">    refs:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">branches</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">$RSPEC</span></span><br></pre></td></tr></table></figure><p>如果想要包含<code>rake test</code>, 请查看<code>before_script-and-after_script</code>.<br><code>extends</code>支持多级继承，但不建议使用三级以上。支持的最大嵌套级别为10。</p><p>一下栗子具有两级继承:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.tests:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">pushes</span></span><br><span class="line"></span><br><span class="line"><span class="string">.rspec:</span></span><br><span class="line"><span class="attr">  extends:</span> <span class="string">.tests</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">rake</span> <span class="string">rspec</span></span><br><span class="line"></span><br><span class="line"><span class="string">rspec</span> <span class="number">1</span><span class="string">:</span></span><br><span class="line"><span class="attr">  variables:</span></span><br><span class="line"><span class="attr">    RSPEC_SUITE:</span> <span class="string">'1'</span></span><br><span class="line"><span class="attr">  extends:</span> <span class="string">.rspec</span></span><br><span class="line"></span><br><span class="line"><span class="string">rspec</span> <span class="number">2</span><span class="string">:</span></span><br><span class="line"><span class="attr">  variables:</span></span><br><span class="line"><span class="attr">    RSPEC_SUITE:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">  extends:</span> <span class="string">.rspec</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spinach:</span></span><br><span class="line"><span class="attr">  extends:</span> <span class="string">.tests</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">rake</span> <span class="string">spinach</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="pages"><a href="#pages" class="headerlink" title="pages"></a><code>pages</code></h4><p><code>pages</code>是一项特殊工作，用于将静态内容上传到GitLab，可用于为您的网站提供服务。它有一个特殊的语法，因此必须满足以下两个要求：</p><ul><li>任何静态内容都必须放在<code>public/</code>目录下</li><li>须定义具有<code>public/</code>目录路径的<code>artifacts</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pages:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">mkdir</span> <span class="string">.public</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">cp</span> <span class="bullet">-r</span> <span class="string">*</span> <span class="string">.public</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">mv</span> <span class="string">.public</span> <span class="string">public</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">public</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>更多详细信息请参考GitLab Pages。</p><p><br><br><br></p><h4 id="image-and-services"><a href="#image-and-services" class="headerlink" title="image and services"></a><code>image</code> and <code>services</code></h4><p>这允许指定自定义Docker镜像和可用于作业时间的服务列表。</p><p><br><br><br></p><h4 id="before-script-and-after-script"><a href="#before-script-and-after-script" class="headerlink" title="before_script and after_script"></a><code>before_script</code> and <code>after_script</code></h4><p><code>before_script</code>用于定义应在所有作业（包括部署作业）之前，在恢复工件(artifacts)之后，运行的命令；这可以是数组或多行字符串。<br><code>after_script</code>用于定义将在所有作业（包括失败的作业）之后运行的命令。这必须是数组或多行字符串。</p><p><code>before_script</code>和<code>main script</code>连接在一个上下文/容器中运行。<code>after_script</code>是单独运行的，因此根据执行程序，在工作树之外完成的更改可能不可见。</p><p>如果在每个工作中定义了<code>before_script</code>和<code>after_script</code>，则可以覆盖全局定义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">global</span> <span class="string">before</span> <span class="string">script</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  before_script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">execute</span> <span class="string">this</span> <span class="string">instead</span> <span class="string">of</span> <span class="string">global</span> <span class="string">before</span> <span class="string">script</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">my</span> <span class="string">command</span></span><br><span class="line"><span class="attr">  after_script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">execute</span> <span class="string">this</span> <span class="string">after</span> <span class="string">my</span> <span class="string">script</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="stages"><a href="#stages" class="headerlink" title="stages"></a><code>stages</code></h4><p><code>stages</code>用于在全局范围定义可由作业使用的阶段。<br><code>stages</code>规范允许具有灵活的多级阶段管道(multi stage pipeline)。<code>stages</code>元素的排序定义了作业执行的顺序:</p><ul><li>同一阶段的作业是并行运行的</li><li>下一阶段的作业在上一阶段的作业成功完成之后运行</li></ul><p>让我们考虑以下示例，它定义了3个阶段：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">test</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#首先，build阶段的所有作业都是并行执行的</span></span><br><span class="line"><span class="comment">#如果build阶段的所有作业都成功，则test阶段的作业将并行执行</span></span><br><span class="line"><span class="comment">#如果test阶段的所有作业都成功，则deploy阶段的作业将并行执行</span></span><br><span class="line"><span class="comment">#如果deploy阶段的所有作业都成功，则commit将被标记为passwd</span></span><br><span class="line"><span class="comment">#如果任何先前的作业失败，则commit被标记为failed，并且不执行其他阶段的作业</span></span><br></pre></td></tr></table></figure><p>有两个边缘案例值得注意：</p><ul><li>如果在<code>.gitlab-ci.yml</code>文件中没有定义<code>stages</code>，<code>build</code>、<code>test</code>和<code>deploy</code>用作默认情况允许的作业阶段；</li><li>如果作业未指定<code>stage</code>，则为作业分配<code>test</code>阶段</li></ul><p><br><br><br></p><h4 id="stage"><a href="#stage" class="headerlink" title="stage"></a><code>stage</code></h4><p><code>stage</code>是按工作定义的，依赖于全局定义的<code>stages</code>。它允许将作业分组到不同的阶段，并且同一阶段的作业并行执行:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">test</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="string">job</span> <span class="number">1</span><span class="string">:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="string">build</span> <span class="string">dependencies</span></span><br><span class="line"></span><br><span class="line"><span class="string">job</span> <span class="number">2</span><span class="string">:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="string">build</span> <span class="string">artifacts</span></span><br><span class="line"></span><br><span class="line"><span class="string">job</span> <span class="number">3</span><span class="string">:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="string">job</span> <span class="number">4</span><span class="string">:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="types"><a href="#types" class="headerlink" title="types"></a><code>types</code></h4><p>不推荐使用<code>types</code>，可以在以后的某个版本中删除。请使用<code>stages</code>替代它。</p><p><br><br><br></p><h4 id="script"><a href="#script" class="headerlink" title="script"></a><code>script</code></h4><p><code>script</code>是作业所需的唯一必需关键字。这是一个由Runner执行的shell script。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#栗子</span></span><br><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">"bundle exec rspec"</span></span><br></pre></td></tr></table></figure><p>此参数还可以包含使用数组的多个命令：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">uname</span> <span class="bullet">-a</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure><p>有时，脚本命令需要用单引号或双引号括起来，例如命令中有特殊字符的时候。</p><p><br><br><br></p><h4 id="only和except-简单"><a href="#only和except-简单" class="headerlink" title="only和except(简单)"></a><code>only</code>和<code>except</code>(简单)</h4><p><code>only</code>和<code>except</code>两个参数，用于创建作业时设置作业策略来限制它:</p><ul><li><code>only</code>定义作业将运行的branch和tag的名称</li><li><code>except</code>定义作业不会运行的branch和tag的名称</li></ul><p>有一些适用于作业策略的规则：</p><ul><li><code>only</code>和<code>except</code>是包容性的，如果在作业规范中定义了<code>only</code>和<code>except</code>，则ref被<code>only</code>和<code>except</code>过滤</li><li><code>only</code>和<code>except</code>允许使用正则表达式: <a href="https://ruby-doc.org/core-2.6/Regexp.html" target="_blank" rel="noopener">Ruby regexp syntax</a></li><li><code>only</code>和<code>except</code>允许指定一个Repo path来为forks过滤作业</li></ul><p>另外，<code>only</code>和<code>except</code>允许使用如下关键字:</p><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody><tr><td><code>branches</code></td><td>When a git reference of a pipeline is a branch</td></tr><tr><td><code>tags</code></td><td>When a git reference of a pipeline is a tag</td></tr><tr><td><code>api</code></td><td>When pipeline has been triggered by a second pipelines API (not triggers API)</td></tr><tr><td><code>external</code></td><td>When using CI services other than GitLab</td></tr><tr><td><code>pipelines</code></td><td>For multi-project triggers, created using the API with <code>CI_JOB_TOKEN</code></td></tr><tr><td><code>pushes</code></td><td>Pipeline is triggered by a <code>git push</code> by the user</td></tr><tr><td><code>schedules</code></td><td>For scheduled pipelines</td></tr><tr><td><code>triggers</code></td><td>For pipelines created using a trigger token</td></tr><tr><td><code>web</code></td><td>For pipelines created using Run pipeline button in GitLab UI (under your project’s Pipelines)</td></tr><tr><td><code>merge_requests</code></td><td>When a merge request is created or updated</td></tr></tbody></table><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#job将仅针对以issue-开头的refs运行，而所有分支都将被跳过</span></span><br><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="comment"># use regexp</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/^issue-.*$/</span></span><br><span class="line">  <span class="comment"># use special keyword</span></span><br><span class="line"><span class="attr">  except:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">branches</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#job将仅对tagged refs</span></span><br><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="comment"># use special keywords</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">tags</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">triggers</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">schedules</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#repo path可用于仅为parent repo而不是forks执行作业</span></span><br><span class="line"><span class="comment">#将为除了master的gitlab-org/gitlab-ce上的所有分支运行job</span></span><br><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">branches@gitlab-org/gitlab-ce</span></span><br><span class="line"><span class="attr">  except:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master@gitlab-org/gitlab-ce</span></span><br></pre></td></tr></table></figure><p><br></p><p>如果作业既没有<code>only</code>也没有<code>except</code>规则，则默认设置为<code>only: [&#39;branches&#39;, &#39;tags&#39;]</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#未配置</span></span><br><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">echo</span> <span class="string">'test'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#它被转换为下面这个样子</span></span><br><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">echo</span> <span class="string">'test'</span></span><br><span class="line"><span class="attr">  only:</span> <span class="string">['branches',</span> <span class="string">'tags'</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="only和except-复杂"><a href="#only和except-复杂" class="headerlink" title="only和except(复杂)"></a><code>only</code>和<code>except</code>(复杂)</h4><blockquote><ul><li><code>refs</code> and <code>kubernetes</code> policies introduced in GitLab 10.0.</li><li><code>variables</code> policy introduced in GitLab 10.7.</li><li><code>changes</code> policy introduced in GitLab 11.4.</li></ul><p>这是一个alpha功能，它可能随时更改，恕不另行通知！</p></blockquote><p>GitLab支持简单和复杂的策略，因此可以使用数组和哈希配置方案。<br>提供了4个key:</p><ul><li>refs</li><li>variables</li><li>changes</li><li>kubernetes</li></ul><p>可以使用<code>AND</code>组合多可键。</p><p><br></p><ul><li><code>only: refs</code></li><li><code>except: refs</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="attr">    refs:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">master</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">schedules</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li><code>only: kubernetes</code></li><li><code>except: kubernetes</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#kubernetes策略只接受active关键字</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="attr">    kubernetes:</span> <span class="string">active</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li><code>only: variables</code></li><li><code>except: variables</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#variables关键字用于定义变量表达式</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">cap</span> <span class="string">staging</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="attr">    refs:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">branches</span></span><br><span class="line"><span class="attr">    variables:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">$RELEASE</span> <span class="string">==</span> <span class="string">"staging"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">$STAGING</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li><code>only: changes</code></li><li><code>except: changes</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#是否应该根据git push事件修改的文件来创建作业</span></span><br><span class="line"><span class="string">docker</span> <span class="attr">build:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">docker</span> <span class="string">build</span> <span class="bullet">-t</span> <span class="attr">my-image:$CI_COMMIT_REF_SLUG</span> <span class="string">.</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="attr">    changes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">docker/scripts/*</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">dockerfiles/**/*</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">more_scripts/*.&#123;rb,py,sh&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这个例子中，只要有上面几个文件或文件夹内的内容发生了commit push</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="tags-1"><a href="#tags-1" class="headerlink" title="tags"></a><code>tags</code></h4><p><code>tags</code>从允许运行此项目的所有Runner中选择特定Runner。在注册Runner期间，您可以指定Runner的tag。<br><code>tags</code>允许你使用分配了特定标签的Runner运行作业。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ruby</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">postgres</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#栗子</span></span><br><span class="line"><span class="string">windows</span> <span class="attr">job:</span></span><br><span class="line"><span class="attr">  stage:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">windows</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">echo</span> <span class="string">Hello,</span> <span class="string">%USERNAME%!</span></span><br><span class="line"></span><br><span class="line"><span class="string">osx</span> <span class="attr">job:</span></span><br><span class="line"><span class="attr">  stage:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">osx</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">echo</span> <span class="string">"Hello, $USER!"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="allow-failure"><a href="#allow-failure" class="headerlink" title="allow_failure"></a><code>allow_failure</code></h4><p><code>allow_failure</code>允许作业失败而不会影响CI套件的其余部分。除手动作业外，默认值为<code>false</code>。<br>启用并且作业失败后，作业将在UI中显示橙色警告。但是，管道的逻辑流程将认为作业成功/通过，并且不会被阻止。假设所有其它作业都成功，作业的阶段及其管道将显示相同的橙色警告。但是，关联的提交将被标记为<code>passed</code>，而不会发出警告。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job1:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">execute_script_that_will_fail</span></span><br><span class="line"><span class="attr">  allow_failure:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job2:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">execute_script_that_will_succeed</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job3:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">deploy_to_staging</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="when"><a href="#when" class="headerlink" title="when"></a><code>when</code></h4><p><code>when</code>用于实现在发生故障或尽管失败时运行的作业，它有以下值:</p><ul><li><code>on_success</code>： 只有当前几个阶段的所有工作都成功时才执行工作</li><li><code>on_failure</code>： 仅当前一阶段中的至少一个作业失败时才执行作业</li><li><code>always</code>： 无论先前阶段的工作状态如何，都可以执行工作</li><li><code>manual</code>： 手动执行作业</li><li><code>delayed</code>： 延迟执行作业(GitLab v11.4)</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cleanup_build</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">test</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">deploy</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cleanup</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build_job:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">make</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cleanup_build_job:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">cleanup_build</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">cleanup</span> <span class="string">build</span> <span class="string">when</span> <span class="string">failed</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">on_failure</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test_job:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">make</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy_job:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">make</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">manual</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cleanup_job:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">cleanup</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">cleanup</span> <span class="string">after</span> <span class="string">jobs</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><p>手动操作是一种特殊类型的作业，不会自动执行，需要由用户明确启动。(例如，部署到生产环境)<br>手动操作可以是可选的也可以是阻止的。阻止手动操作将在定义此操作的阶段阻止管道的执行。当有人通过单击播放按钮执行阻止手动操作时，可以继续执行管道。默认情况下，手动操作是非阻止的。如果要阻止手动操作，则需要添加<code>allow_failure：false</code>。<br>手动操作被视为写入操作，因此当用户想要触发操作时，将使用受保护分支的权限。换句话说，为了触发分配给管道运行的分支的手动操作，用户需要具有合并到该分支的能力。</p><p><br></p><p><code>when: delayed</code>，延迟作业用于在一段时间后执行脚本。如果要避免作业立即进入暂挂(<code>pending</code>)状态，这非常有用。<br>你可以使用<code>start_in</code>键来设置时期，它的值是以秒(s)为单位的经过时间，或者你提供时间单位，它的值必须小于等于一小时。<br>当阶段中的作业延迟时，管道将不会进展，直到延迟作业完成。这意味着此关键字也可用于在不同阶段之间插入延迟。<br>延迟作业的计时器在前一阶段完成后立即开始。与其他类型的作业类似，除非前一阶段过去，否则延迟作业的计时器将无法启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#10 seconds</span><br><span class="line">#30 minutes</span><br><span class="line">#1 hour</span><br><span class="line"></span><br><span class="line">#栗子</span><br><span class="line">timed rollout 10%:</span><br><span class="line">  stage: deploy</span><br><span class="line">  script: echo &apos;Rolling out 10% ...&apos;</span><br><span class="line">  when: delayed</span><br><span class="line">  start_in: 30 minutes</span><br></pre></td></tr></table></figure><p>您可以通过单击<strong>Unschedule</strong>按钮来停止延迟作业的活动计时器。除非您手动执行作业，否则将来不会执行此作业。<br>您可以通过单击<strong>Play</strong>按钮立即开始延迟作业。 GitLab Runner很快就会选择你的工作并开始工作。</p><p><br><br><br></p><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p><code>environment</code>用于定义作业部署到特定环境。如果指定了<code>environment</code>且该名称下没有环境，则将自动创建一个新环境。<br>它有如下几个值:</p><ul><li><code>name</code></li><li><code>url</code></li><li><code>on_stop</code></li><li><code>action</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#常见的名字有qa, staging, production</span></span><br><span class="line"><span class="comment">#但你可以为你的工作流使用任何名称</span></span><br><span class="line"><span class="string">deploy</span> <span class="string">to</span> <span class="attr">production:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">git</span> <span class="string">push</span> <span class="string">production</span> <span class="attr">HEAD:master</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">production</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#url是一个可选值</span></span><br><span class="line"><span class="comment">#在设置时，它会在GitLab中的各个位置公开按钮，单击这些按钮会转到定义的URL</span></span><br><span class="line"><span class="comment">#如果作业成功完成，它将在合并请求和environments/deployments页面中创建指向url的按钮</span></span><br><span class="line"><span class="string">deploy</span> <span class="string">to</span> <span class="attr">production:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">git</span> <span class="string">push</span> <span class="string">production</span> <span class="attr">HEAD:master</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">production</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">https://prod.example.com</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#on_stop来实现closing(stopping)环境。它声明了一个不同的工作，以便关闭环境</span></span><br><span class="line"><span class="comment">#action与on_stop一起使用，在被调用以关闭环境的作业中定义</span></span><br><span class="line"><span class="attr">review_app:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="string">deploy-app</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">review</span></span><br><span class="line"><span class="attr">    on_stop:</span> <span class="string">stop_review_app</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stop_review_app:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="string">delete-app</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">manual</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">review</span></span><br><span class="line"><span class="attr">    action:</span> <span class="string">stop</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Dynamic-environments"><a href="#Dynamic-environments" class="headerlink" title="Dynamic environments"></a>Dynamic environments</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">deploy</span> <span class="string">as</span> <span class="string">review</span> <span class="attr">app:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">review/$CI_COMMIT_REF_NAME</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">https://$CI_ENVIRONMENT_SLUG.example.com/</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a><code>cache</code></h4><blockquote><p><strong>Notes:</strong></p><ul><li>Introduced in GitLab Runner v0.7.0</li><li>cache can be set globally and per-job</li><li>From GitLab 9.0, caching is enabled and shared between pipelines and jobs by default<br>-From GitLab 9.2, caches are restored before artifacts</li></ul></blockquote><p><code>cache</code>用于指定应在作业之间缓存的文件和目录列表，您只能使用项目工作区内的路径。<br>如果在作业范围之外定义了<code>cache</code>，则表示它是全局设置的，并且所有作业都将使用该定义。</p><p>它的几个值:</p><ul><li><code>paths</code></li><li><code>key</code></li><li><code>untracked</code></li><li><code>policy</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#paths指令选择要缓存的文件或目录。支持通配符</span></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  cache:</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">binaries/*.apk</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">.config</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于cache是在作业之间共享的，如果对不同的作业使用不同的路径，则还应设置不同的cache:key，否则缓存内容可以被覆盖</span></span><br><span class="line"><span class="comment">#key指令允许您定义作业之间的缓存关联，允许为所有作业提供single cache，cache per-job，cache per-branch或适合您工作流的任何其他方式</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">"$CI_COMMIT_REF_SLUG"</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">binaries/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#untracked：true缓存Git存储库中未跟踪的所有文件</span></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  cache:</span></span><br><span class="line"><span class="attr">    untracked:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">binaries/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#policy的默认行为是在执行开始时下载文件，并在结束时重新上载它们</span></span><br><span class="line"><span class="comment">#这允许将作业所做的任何更改保留以供将来运行，并称为pull-push缓存策略</span></span><br><span class="line"><span class="comment">#这有助于加快作业执行速度并减少缓存服务器上的负载，尤其是当您有大量并行执行缓存的作业时。</span></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">setup</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">prepare:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">setup</span></span><br><span class="line"><span class="attr">  cache:</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">gems</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">vendor/bundle</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">bundle</span> <span class="string">install</span> <span class="bullet">--deployment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  cache:</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">gems</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">vendor/bundle</span></span><br><span class="line"><span class="attr">    policy:</span> <span class="string">pull</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span> <span class="string">...</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="artifacts"><a href="#artifacts" class="headerlink" title="artifacts"></a><code>artifacts</code></h4><blockquote><p><strong>Notes:</strong></p><ul><li>Introduced in GitLab Runner v0.7.0 for non-Windows platforms.</li><li>Windows support was added in GitLab Runner v.1.0.0.</li><li>From GitLab 9.2, caches are restored before artifacts.</li><li>Not all executors are supported.</li><li>Job artifacts are only collected for successful jobs by default.</li></ul></blockquote><p><code>artifacts</code>用于指定成功后应附加到作业的文件和目录列表。作业成功完成后，工件将被发送到GitLab，并可在GitLab UI中下载。</p><p>有以下值:</p><ul><li><code>paths</code></li><li><code>name</code></li><li><code>untracked</code></li><li><code>when</code><ul><li><code>when: on_success</code></li><li><code>when: on_failure</code></li><li><code>when: always</code></li></ul></li><li><code>expire_in</code></li><li><code>reports</code><ul><li><code>reports:junit</code></li><li><code>reports:codequality</code></li><li><code>reports:sast</code></li><li><code>reports:dependency_scanning</code></li><li><code>reports:container_scanning</code></li><li><code>reports:dast</code></li><li><code>reports:license_management</code></li><li><code>reports:performance</code></li></ul></li></ul><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#artifacts:paths</span></span><br><span class="line"><span class="comment">#要在不同作业之间传递工件，只能使用项目工作区内的路径</span></span><br><span class="line"><span class="attr">default-job:</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">mvn</span> <span class="string">test</span> <span class="bullet">-U</span></span><br><span class="line"><span class="attr">  except:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">tags</span></span><br><span class="line"></span><br><span class="line"><span class="attr">release-job:</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">mvn</span> <span class="string">package</span> <span class="bullet">-U</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">target/*.war</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">tags</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#artifacts:name</span></span><br><span class="line"><span class="comment">#定义创建的工件归档的名称</span></span><br><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"$CI_JOB_NAME"</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">binaries/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#artifacts:untracked</span></span><br><span class="line"><span class="comment">#用于将所有Git未跟踪文件添加为工件</span></span><br><span class="line"><span class="attr">artifacts:</span></span><br><span class="line"><span class="attr">  untracked:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">binaries/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#artifacts:when</span></span><br><span class="line"><span class="comment">#用于在作业失败时上传工件</span></span><br><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    when:</span> <span class="string">on_failure</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#artifacts:expire_in</span></span><br><span class="line"><span class="comment">#允许您指定工件在到期之前应该存在多长时间并因此被删除，从它们上载和存储在GitLab上的时间开始计算</span></span><br><span class="line"><span class="comment">#如果未定义到期时间，则默认为实例范围设置(默认30天)</span></span><br><span class="line"><span class="comment">#到期后，每小时定时任务删除工件</span></span><br><span class="line"><span class="comment">#默认单位是秒，支持提供时间单位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#‘42’</span></span><br><span class="line"><span class="comment">#‘3 mins 4 sec’</span></span><br><span class="line"><span class="comment">#‘2 hrs 20 min’</span></span><br><span class="line"><span class="comment">#‘2h20min’</span></span><br><span class="line"><span class="comment">#‘6 mos 1 day’</span></span><br><span class="line"><span class="comment">#‘47 yrs 6 mos and 4d’</span></span><br><span class="line"><span class="comment">#‘3 weeks and 2 days’</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job:</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    expire_in:</span> <span class="number">1</span> <span class="string">week</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#artifacts:reports</span></span><br><span class="line"><span class="comment">#用于从工作中收集测试报告并在GitLab UI中公开它们</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a><code>dependencies</code></h4><p>此功能应与<code>artifacts</code>结合使用，并允许您定义要在不同作业之间传递的工件<br>要使用此功能，请在作业上下文中定义<code>dependencies</code>，并传递应从中下载工件的所有先前作业的列表。</p><p>如果作为依赖项设置的作业的工件已过期或已擦除，则相关作业将失败。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当执行test:osx时，将在构建的上下文中下载并提取build:osx中的工件</span></span><br><span class="line"><span class="comment">#test:linux也是如此，要从build: linux拉取工件</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span><span class="attr">osx:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="attr">build:osx</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">binaries/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span><span class="attr">linux:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="attr">build:linux</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">binaries/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span><span class="attr">osx:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="attr">test:osx</span></span><br><span class="line"><span class="attr">  dependencies:</span></span><br><span class="line"><span class="attr">    - build:</span><span class="string">osx</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span><span class="attr">linux:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="attr">test:linux</span></span><br><span class="line"><span class="attr">  dependencies:</span></span><br><span class="line"><span class="attr">    - build:</span><span class="string">linux</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">make</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="coverage"><a href="#coverage" class="headerlink" title="coverage"></a><code>coverage</code></h4><p>允许您配置从作业输出中提取代码覆盖率的方式，正则表达式是此处唯一有效的值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">job1:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">rspec</span></span><br><span class="line"><span class="attr">  coverage:</span> <span class="string">'/Code coverage: \d+\.\d+/'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="retry"><a href="#retry" class="headerlink" title="retry"></a><code>retry</code></h4><p>允许您配置在发生故障时重试作业的次数。如果重试作业成功完成，则不会再进行剩余的重试。它的值为<code>2&gt;=retry&gt;=0</code>的正整数。</p><p>要更好的控制retry，可使用以下key:</p><ul><li><code>max</code>: 最大重试次数</li><li><code>when</code>: 败的情况下重试<ul><li><code>always</code>: 重试任何失败 (default)</li><li><code>unknown_failure</code>: 失败原因未知时重试</li><li><code>script_failure</code>: 脚本失败时重试</li><li><code>api_failure</code>: API失败重试</li><li><code>stuck_or_timeout_failure</code>: 当作业卡住或超时时重试<ul><li><code>runner_system_failure</code>: 如果Runner故障，重试</li></ul></li><li><code>missing_dependency_failure</code>: 如果缺少依赖项，重试</li><li><code>runner_unsupported</code>: 如果Runner不受支持，重试</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">test:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">rspec</span></span><br><span class="line"><span class="attr">  retry:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">rspec</span></span><br><span class="line"><span class="attr">  retry:</span></span><br><span class="line"><span class="attr">    max:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    when:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">runner_system_failure</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">stuck_or_timeout_failure</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="parallel"><a href="#parallel" class="headerlink" title="parallel"></a><code>parallel</code></h4><p>允许您配置并行运行的作业实例数，它的值<code>50&gt;=parallel&gt;=2</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#简单栗子</span></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">rspec</span></span><br><span class="line"><span class="attr">  parallel:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="include"><a href="#include" class="headerlink" title="include"></a><code>include</code></h4><blockquote><p>Introduced in GitLab Premium 10.5</p></blockquote><p>使用<code>include</code>，可以允许包含外部YAML文件(本地Repo或远程URL)，但也需要为<code>.yml</code>和<code>.yaml</code>扩展格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Content of .gitlab-ci.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">include:</span> <span class="string">'https://gitlab.com/awesome-project/raw/master/.before-script-template.yml'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rspec:</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">bundle</span> <span class="string">exec</span> <span class="string">rspec</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="variables"><a href="#variables" class="headerlink" title="variables"></a><code>variables</code></h4><blockquote><p>整数(浮点数)对于变量是有效的，浮点数无效。</p></blockquote><p>GitLab CI/CD允许你在<code>.gitlab-ci.yml</code>中定义变量，然后在作业环境中传递。变量可以是全局的，也可以是基于每个作业的。当在作业级别定义了与全局或项目相同名称的变量时，则作业级别的变量会覆盖它们。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line"><span class="attr">  DATABASE_URL:</span> <span class="string">"postgres://postgres@postgres/my_database"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="特殊YAML功能"><a href="#特殊YAML功能" class="headerlink" title="特殊YAML功能"></a>特殊YAML功能</h4><p>可使用特殊的YAML功能，如锚点(anchors<code>&amp;</code>)、别名(aliases<code>*</code>)、map merging (<code>&lt;&lt;</code>)等，这大大降低了<code>.gitlab-ci.yml</code>的复杂性。</p><p><br></p><h5 id="Hidden-keys-jobs"><a href="#Hidden-keys-jobs" class="headerlink" title="Hidden keys (jobs)"></a>Hidden keys (jobs)</h5><p>如果要暂时禁用作业，而不是注释掉定义作业的所有行，你可是在作业名前加一个点(<code>.</code>)，这样GitLab CI将会忽略它。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#hidden_job:</span></span><br><span class="line"><span class="comment">#  script:</span></span><br><span class="line"><span class="comment">#    - run test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">.hidden_job:</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">run</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h5><p>YAML的锚点功能此处就不赘述了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用锚点和map merging</span></span><br><span class="line"><span class="string">.job_template:</span> <span class="meta">&amp;job_definition</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">test</span> <span class="string">project</span></span><br><span class="line"></span><br><span class="line"><span class="string">.postgres_services:</span></span><br><span class="line"><span class="attr">  services:</span> <span class="meta">&amp;postgres_definition</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">postgres</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ruby</span></span><br><span class="line"></span><br><span class="line"><span class="string">.mysql_services:</span></span><br><span class="line"><span class="attr">  services:</span> <span class="meta">&amp;mysql_definition</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">mysql</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ruby</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span><span class="attr">postgres:</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*job_definition</span></span><br><span class="line"><span class="attr">  services:</span> <span class="meta">*postgres_definition</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span><span class="attr">mysql:</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*job_definition</span></span><br><span class="line"><span class="attr">  services:</span> <span class="meta">*mysql_definition</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展应该为这个样子</span></span><br><span class="line"><span class="string">.job_template:</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">test</span> <span class="string">project</span></span><br><span class="line"></span><br><span class="line"><span class="string">.postgres_services:</span></span><br><span class="line"><span class="attr">  services:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">postgres</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ruby</span></span><br><span class="line"></span><br><span class="line"><span class="string">.mysql_services:</span></span><br><span class="line"><span class="attr">  services:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">mysql</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ruby</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span><span class="attr">postgres:</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">test</span> <span class="string">project</span></span><br><span class="line"><span class="attr">  services:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">postgres</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ruby</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span><span class="attr">mysql:</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">test</span> <span class="string">project</span></span><br><span class="line"><span class="attr">  services:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">mysql</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ruby</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="GitLab-CI-CD栗子"><a href="#GitLab-CI-CD栗子" class="headerlink" title="GitLab CI/CD栗子"></a>GitLab CI/CD栗子</h3><p>各种语言、框架 、操作系统 CI/CD栗子: <a href="https://docs.gitlab.com/ce/ci/examples/README.html" target="_blank" rel="noopener">https://docs.gitlab.com/ce/ci/examples/README.html</a></p><ul><li>PHP</li><li>Ruby</li><li>Python</li><li>Java</li><li>Scala</li><li>Clojure</li><li>Elixir</li><li>IOS and MacOS</li><li>Android</li><li>Debian</li><li>Maven</li></ul><p><br></p><p><br><br><br></p><hr><p><br><br><br></p><h2 id="Git配置项"><a href="#Git配置项" class="headerlink" title="Git配置项"></a>Git配置项</h2><p>Git configuration options</p><p><br></p><h3 id="自定Git-hooks"><a href="#自定Git-hooks" class="headerlink" title="自定Git hooks"></a>自定Git hooks</h3><p>Custom Git hooks: Custom Git hooks (on the filesystem) for when webhooks aren’t enough</p><blockquote><p><strong>注意</strong>：必须在GitLab服务器的文件系统上配置自定义Git hooks。只有GitLab服务器管理员才能完成这些任务。</p></blockquote><p>Git本身支持在不同操作上执行的hooks。服务器端git hooks的示例包括预接收，后接收和更新。从gitlab-shell 2.2.0版（需要GitLab 7.5+）开始，GitLab管理员可以为任何GitLab项目添加自定义git hooks。</p><p><br><br><br></p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>通常，Githooks放在存储库或项目的hooks目录中。 GitLab从每个项目的hooks目录创建一个符号链接到<code>gitlab-shell</code> hooks目录，以便于<code>gitlab-shell</code>升级之间的维护。因此，自定义挂钩的实现方式略有不同。但是，一旦创建了钩子，行为就完全相同了。</p><p>请按照以下步骤设置自定义hooks：</p><ul><li>选择一个需要自定义Git hook的项目</li><li>在GitLab Server，导航到项目的存储库目录(如: <code>/var/opt/gitlab/git-data/repositories/user/xx.git</code>)</li><li>此位置创建名为<code>custom_hooks</code>的新目录</li><li>在<code>custom_hooks</code>目录中，创建一个名称与hook类型匹配的文件(如: <code>pre-hook</code>)</li><li>修改hook文件属主为git，添加可执行权限</li><li>编写代码以使Git hook函数按预期方式运行，可以是任何语言。确保顶部的<code>shebang</code>(<code>#!/bin/python3</code>)正确反映语言类型</li></ul><p>假设正确实现了hook代码，hook将适当地触发。</p><p><br><br><br></p><h4 id="链式hook"><a href="#链式hook" class="headerlink" title="链式hook"></a>链式hook</h4><p>Chained hooks support</p><blockquote><p>在GitLab Shell 4.1.0和GitLab 8.15中引入</p></blockquote><p>hook也可以放在<code>hook/&lt;hook_name&gt;.d</code>（全局）或<code>custom_hooks/&lt;hook_name&gt;.d</code>（每个项目）目录中，支持钩子的链式执行。<br>注意：<code>&lt;hook_name&gt;.d</code>需要<code>pre-receive.d</code>，<code>post-receive.d</code>或<code>update.d</code>才能正常工作。任何其他名称都将被忽略</p><p>要查看全局自定义hook（<code>hook/&lt;hook_name.d&gt;</code>）中的不同目录，请在<code>gitlab-shell config</code>中设置<code>custom_hooks_dir</code>。对于Omnibus安装，可在<code>gitlab.rb</code>中设置。</p><p>按以下顺序搜索并执行hook：</p><ul><li><code>gitlab-shell/hooks</code> directory as known to Gitaly</li><li><code>&lt;project&gt;.git/hooks/&lt;hook_name&gt;</code> - executed by <code>git</code> itself, this is <code>gitlab-shell/hooks/&lt;hook_name&gt;</code></li><li><code>&lt;project&gt;.git/custom_hooks/&lt;hook_name&gt;</code> - per project hook</li><li><code>&lt;project&gt;.git/custom_hooks/&lt;hook_name&gt;.d/*</code> - per project hooks</li><li><code>&lt;project&gt;.git/hooks/&lt;hook_name&gt;.d/* OR &lt;custom_hooks_dir&gt;/&lt;hook_name.d&gt;/*</code> - global hooks: all executable files</li></ul><p><br><br><br></p><h4 id="自定义错误信息"><a href="#自定义错误信息" class="headerlink" title="自定义错误信息"></a>自定义错误信息</h4><p>Custom error messages</p><blockquote><p>在GitLab 8.10中引入</p></blockquote><p>如果commit被拒绝或在Git hook检查期间发生错误，则钩子的STDERR或STDOUT消息将出现在GitLab的UI中，STDERR优先于STDOUT。</p><p><br><br><br><br><br></p><h3 id="Git-LFS"><a href="#Git-LFS" class="headerlink" title="Git LFS"></a>Git LFS</h3><ul><li>Git LFS: <a href="https://docs.gitlab.com/ce/workflow/lfs/manage_large_binaries_with_git_lfs.html" target="_blank" rel="noopener">https://docs.gitlab.com/ce/workflow/lfs/manage_large_binaries_with_git_lfs.html</a></li><li>Git LFS config: <a href="https://docs.gitlab.com/ce/workflow/lfs/lfs_administration.html" target="_blank" rel="noopener">https://docs.gitlab.com/ce/workflow/lfs/lfs_administration.html</a></li></ul><p><br></p><p>管理音频，视频和图形文件等大文件一直是Git的缺点之一。一般建议是不要让Git存储库大于1GB以保持性能。</p><p><br><br><br><br><br></p><h3 id="Housekeeping"><a href="#Housekeeping" class="headerlink" title="Housekeeping"></a>Housekeeping</h3><p>Housekeeping(管家): Keep your Git repositories tidy and fast</p><blockquote><p>在GitLab 8.4中引入</p></blockquote><p><br></p><h4 id="Automatic-housekeeping"><a href="#Automatic-housekeeping" class="headerlink" title="Automatic housekeeping"></a>Automatic housekeeping</h4><p>在Git push后，GitLab会自动在存储库上运行<code>git gc</code>和<code>git repack</code>命令。如果需要，您可以更改这种情况发生的频率，或者将其关闭。在Admin ares -&gt; Setting</p><p><br><br><br></p><h4 id="Manual-housekeeping"><a href="#Manual-housekeeping" class="headerlink" title="Manual housekeeping"></a>Manual housekeeping</h4><p>housekeeping功能将运行<code>gc</code>还是<code>repack</code>，取决于你的设置。</p><p><br><br><br><br><br></p><h3 id="Git协议"><a href="#Git协议" class="headerlink" title="Git协议"></a>Git协议</h3><p>Configuring Git Protocol v2: Git protocol version 2 support</p><blockquote><p>在GitLab 11.4中引入</p></blockquote><p>Git第二版协议以多种方式改进了第一版协议，并且在GitLab中默认为HTTP请求启用。要为SSH启用，管理员需要进一步配置。</p><p><br></p><p><strong>Requirements：</strong></p><ul><li>客户端，git v2.18.0+</li><li>服务端，如果要配置SSH，需要设置sshd以接受<code>GIT_PROTOCOL</code>环境变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#/etc/ssh/sshd_config</span><br><span class="line">AcceptEnv GIT_PROTOCOL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo service ssh restart</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#配置新协议</span><br><span class="line"></span><br><span class="line">#局部</span><br><span class="line">git -c protocol.version=2</span><br><span class="line"></span><br><span class="line">#全局</span><br><span class="line">git config --global protocol.version 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#验证</span><br><span class="line"></span><br><span class="line">#HTTP</span><br><span class="line"></span><br><span class="line">#C端</span><br><span class="line">GIT_TRACE_CURL=1 git -c protocol.version=2 ls-remote https://your-gitlab-instance.com/group/repo.git 2&gt;&amp;1 | grep Git-Protocol</span><br><span class="line"></span><br><span class="line">#S端</span><br><span class="line">GIT_TRACE_PACKET=1 git -c protocol.version=2 ls-remote https://your-gitlab-instance.com/group/repo.git 2&gt;&amp;1 | head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#SSH</span><br><span class="line"></span><br><span class="line">#C端</span><br><span class="line">GIT_SSH_COMMAND=&quot;ssh -v&quot; git -c protocol.version=2 ls-remote ssh://your-gitlab-instance.com:group/repo.git 2&gt;&amp;1 |grep GIT_PROTOCOL</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>Monitoring GitLab</p><p><br><br><br></p><hr><p><br><br><br></p><h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><p>Troubleshooting</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Runner"><a href="#Runner" class="headerlink" title="Runner"></a>Runner</h1><p><strong>Runner</strong>是<code>GitLab CI</code>的客户端。 作为GitLab持续集成和持续部署(CI/CD)的一部分，主要用来配置和运行构建脚本以及其他的任务。<br>GitLab Runner 是一个开源项目， 它用来运行你定制的任务（jobs）并把结果返回给 GitLab。 GitLab Runner配合GitLab CI（GitLab 内置的持续集成服务）协调完成任务。</p><p><br></p><p><strong>要求(Requirements)</strong></p><p>GitLab Runner是用Go编写的，可以作为单个二进制文件运行，不需要语言特定的要求。它可在多个操作系统上运行，只要你在此平台上编译成二进制文件。支持Docker v1.5+。</p><p><br></p><p><strong>特点(Feature)</strong></p><ul><li>Allows to run:<ul><li>multiple jobs concurrently(同时)</li><li>use multiple tokens with multiple server (even per-project)</li><li>limit number of concurrent(并发) jobs per-token</li></ul></li><li>Jobs can be run:<ul><li>locally</li><li>using Docker containers</li><li>using Docker containers and executing job over SSH</li><li>using Docker containers with autoscaling on different clouds and virtualization hypervisors</li><li>connecting to remote SSH server</li></ul></li><li>Is written in Go and distributed as single binary without any other requirements</li><li>Supports Bash, Windows Batch and Windows PowerShell</li><li>Works on GNU/Linux, OS X and Windows (pretty much anywhere you can run Docker)</li><li>Allows to customize the job running environment</li><li>Automatic configuration reload without restart</li><li>Easy to use setup with support for Docker, Docker-SSH, Parallels or SSH running environments</li><li>Enables caching of Docker containers</li><li>Easy installation as a service for GNU/Linux, OSX and Windows</li><li>Embedded Prometheus metrics HTTP server</li></ul><p><br></p><p><strong>兼容性图表(Compatibility chart)</strong></p><p>GitLab Runner的版本应该与GitLab同步。如果存在版本差异，则功能可能无法使用或无法正常工作。</p><p><br><br><br><br><br></p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>Install GitLab Runner</p><ul><li>Install using GitLab’s repository for Debian/Ubuntu/CentOS/RedHat (preferred)</li><li>Install on GNU/Linux manually (advanced)</li><li>Install on macOS</li><li>Install on Windows</li><li>Install as a Docker service</li><li>Install in autoscaling mode using Docker machine</li><li>Install on FreeBSD</li><li>Install on Kubernetes</li><li>Install the nightly binary manually (development)</li></ul><p><br></p><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p>Install GitLab Runner using the official GitLab repositories</p><p><strong>安装：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加镜像库</span></span><br><span class="line"><span class="comment"># For Debian/Ubuntu/Mint</span></span><br><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># For RHEL/CentOS/Fedora</span></span><br><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装最新版</span></span><br><span class="line"><span class="comment"># For Debian/Ubuntu/Mint</span></span><br><span class="line">sudo apt-get install gitlab-runner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># For RHEL/CentOS/Fedora</span></span><br><span class="line">sudo yum install gitlab-runner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装制定版本</span></span><br><span class="line"><span class="comment"># for DEB based systems</span></span><br><span class="line">apt-cache madison gitlab-runner</span><br><span class="line">sudo apt-get install gitlab-runner=10.0.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># for RPM based systems</span></span><br><span class="line">yum list gitlab-runner --showduplicates | sort -r</span><br><span class="line">sudo yum install gitlab-runner-10.0.0-1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#注册Runner</span></span><br><span class="line"><span class="comment">#注册Runner参考后面</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>更新：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For Debian/Ubuntu/Mint</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gitlab-runner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># For RHEL/CentOS/Fedora</span></span><br><span class="line">sudo yum update</span><br><span class="line">sudo yum install gitlab-runner</span><br></pre></td></tr></table></figure><p><br></p><p><strong>手动下载包安装</strong></p><p>下载地址: <a href="https://packages.gitlab.com/runner/gitlab-runner" target="_blank" rel="noopener">https://packages.gitlab.com/runner/gitlab-runner</a></p><p><br></p><p><strong>升级到GitLab Runner 10</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移除旧库</span></span><br><span class="line"><span class="comment"># For Debian/Ubuntu/Mint</span></span><br><span class="line">sudo rm /etc/apt/sources.list.d/runner_gitlab-ci-multi-runner.list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># For RHEL/CentOS/Fedora</span></span><br><span class="line">sudo rm /etc/yum.repos.d/runner_gitlab-ci-multi-runner.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装新库</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#再安装</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载二进制包</span></span><br><span class="line"><span class="comment"># Linux x86-64</span></span><br><span class="line">sudo wget -O /usr/<span class="built_in">local</span>/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux x86</span></span><br><span class="line">sudo wget -O /usr/<span class="built_in">local</span>/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-386</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux arm</span></span><br><span class="line">sudo wget -O /usr/<span class="built_in">local</span>/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-arm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加可执行权限</span></span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/gitlab-runner</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果想使用Docker</span></span><br><span class="line">curl -sSL https://get.docker.com/ | sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Create a GitLab CI user:</span></span><br><span class="line">sudo useradd --comment <span class="string">'GitLab Runner'</span> --create-home gitlab-runner --shell /bin/bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Install and run as service:</span></span><br><span class="line">sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner</span><br><span class="line">sudo gitlab-runner start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Register the Runner</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#更新的话重新下载二进制包安装</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#挂载运行</span><br><span class="line"> docker run -d --name gitlab-runner --restart always \</span><br><span class="line">   -v /srv/gitlab-runner/config:/etc/gitlab-runner \</span><br><span class="line">   -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">   gitlab/gitlab-runner:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Register the Runner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#更新的话，停止旧容器，拉取新镜像</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#GitLab Runner Logs</span><br><span class="line">#可以把Runner Logs目录挂载到宿主机，也可是使用docker 读取</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><p><br><br><br><br><br></p><h3 id="Autoscale"><a href="#Autoscale" class="headerlink" title="Autoscale"></a>Autoscale</h3><p><br><br><br><br><br></p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>Register GitLab Runner</p><p>安装GitLab Runner后，需要将其注册到GitLab。注册Runner是将Runner与GitLab实例绑定的过程。</p><p><br></p><p><strong>要求(Requirements)</strong>，在注册Runner之前，你需要：</p><ul><li>将其安装在与安装GitLab位置不同的Server上</li><li>通过GitLab的界面获取共享或特定Runner的Token</li></ul><p><br></p><p><strong>注册环境：</strong></p><ul><li>GNU/Linux</li><li>macOS</li><li>Windows</li><li>FreeBSD</li><li>Docker</li><li>…</li></ul><p><br><br><br></p><h3 id="GNU-Linux"><a href="#GNU-Linux" class="headerlink" title="GNU/Linux"></a>GNU/Linux</h3><p>在GNU / Linux下注册Runner：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#URL和Token在GitLab实例的runner里面去看</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行命令</span></span><br><span class="line">sudo gitlab-runner register</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入GitLab 实例 URL</span></span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</span><br><span class="line">https://gitlab.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入获得的token</span></span><br><span class="line">Please enter the gitlab-ci token <span class="keyword">for</span> this runner</span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入Runner的描述，之后可在Web UI下更改</span></span><br><span class="line">Please enter the gitlab-ci description <span class="keyword">for</span> this runner</span><br><span class="line">[hostame] my-runner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入与Runner相关联的tag，之后可在Web UI下更改</span></span><br><span class="line">Please enter the gitlab-ci tags <span class="keyword">for</span> this runner (comma separated):</span><br><span class="line">my-tag,another-tag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入Runner executor</span></span><br><span class="line">Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:</span><br><span class="line">docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果您选择Docker作为执行程序，则会要求您未在.gitlab-ci.yml中定义的用于项目的默认image</span></span><br><span class="line">Please enter the Docker image (eg. ruby:2.1):</span><br><span class="line">alpine:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动runner</span></span><br><span class="line">sudo systemctl start gitlab-runner</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="单行注册命令"><a href="#单行注册命令" class="headerlink" title="单行注册命令"></a>单行注册命令</h3><p>One-line registration command</p><p>如果要使用非交互模式注册Runner，可以使用register子命令或使用其等效的环境变量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看帮助</span></span><br><span class="line">gitlab-runner register -h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#注册</span></span><br><span class="line">sudo gitlab-runner register \</span><br><span class="line">  --non-interactive \</span><br><span class="line">  --url <span class="string">"https://gitlab.com/"</span> \</span><br><span class="line">  --registration-token <span class="string">"PROJECT_REGISTRATION_TOKEN"</span> \</span><br><span class="line">  --executor <span class="string">"docker"</span> \</span><br><span class="line">  --docker-image alpine:3 \</span><br><span class="line">  --description <span class="string">"docker-runner"</span> \</span><br><span class="line">  --tag-list <span class="string">"docker,aws"</span> \</span><br><span class="line">  --run-untagged \</span><br><span class="line">  --locked=<span class="string">"false"</span> \</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>Executors</p><p>GitLab Runner实现了许多执行程序，可用于在不同的场景中运行构建。</p><p>执行器：</p><ul><li>Shell</li><li>Docker</li><li>Docker Machine and Docker Machine SSH (autoscaling)</li><li>Parallels</li><li>VirtualBox</li><li>SSH</li><li>Kubernetes</li></ul><p><br><br><br></p><h3 id="选择执行器"><a href="#选择执行器" class="headerlink" title="选择执行器"></a>选择执行器</h3><p>Selecting the executor</p><p>GitLab Runner实现了许多执行程序，可用于在不同的场景中运行构建。如果您不确定要选择什么，请阅读“我不确定”部分。访问兼容性图表，了解每个执行程序支持哪些功能，哪些功能不支持。</p><p>执行器支持不同平台和方法的项目构建：</p><table><thead><tr><th>Executor</th><th>SSH</th><th>Shell</th><th>VirtualBox</th><th>Parallels</th><th>Docker</th><th>Kubernetes</th></tr></thead><tbody><tr><td>Clean build environment for every build</td><td>✗</td><td>✗</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>Migrate runner machine</td><td>✗</td><td>✗</td><td>partial</td><td>partial</td><td>✓</td><td>✓</td></tr><tr><td>Zero-configuration support for concurrent builds</td><td>✗</td><td>✗ (1)</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>Complicated build environments</td><td>✗</td><td>✗ (2)</td><td>✓ (3)</td><td>✓ (3)</td><td>✓</td><td>✓</td></tr><tr><td>Debugging build problems</td><td>easy</td><td>easy</td><td>hard</td><td>hard</td><td>medium</td><td>medium</td></tr></tbody></table><p><br><br><br></p><h4 id="不清楚该选择哪个执行器"><a href="#不清楚该选择哪个执行器" class="headerlink" title="不清楚该选择哪个执行器"></a>不清楚该选择哪个执行器</h4><p>I am not sure</p><ul><li><p><strong>Shell</strong><br>Shell是最简单的配置执行器。需要在安装Runner的同一台机器上手动安装构建的所有必需依赖项。</p></li><li><p><strong>Virtual Machine</strong><br>此类执行器允许您使用已创建的虚拟机，该虚拟机已克隆并用于运行构建。我们提供两种完整的系统虚拟化选项：VirtualBox和Parallels。如果您希望在不同的操作系统上运行构建，它们可以证明是有用的，因为它允许在Windows，Linux，OSX或FreeBSD上创建虚拟机，然后GitLab Runner连接到虚拟机并在其上运行构建。它的使用对于降低基础设施成本也很有用。</p></li><li><p><strong>Docker</strong><br>一个很好的选择是使用Docker，因为它允许一个干净的构建环境，并且易于依赖管理（构建项目的所有依赖项都可以放在Docker镜像中）。 Docker执行程序允许您轻松创建具有依赖服务的构建环境，如MySQL</p></li><li><p><strong>Kubernetes</strong><br>Kubernetes执行程序允许您使用现有的Kubernetes集群进行构建。执行程序将调用Kubernetes集群API并为每个GitLab CI作业创建一个新的Pod（带有构建容器和服务容器）。</p></li><li><p><strong>SSH</strong><br>添加SSH执行程序是为了完整性，但它是所有执行程序中支持最少的。它使GitLab Runner连接到外部服务器并在那里运行构建。(通常建议使用其它案例)</p></li></ul><p><br><br><br></p><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>Compatibility</p><p>不同执行器支持的功能：</p><table><thead><tr><th>Executor</th><th>SSH</th><th>Shell</th><th>VirtualBox</th><th>Parallels</th><th>Docker</th><th>Kubernetes</th></tr></thead><tbody><tr><td>Secure Variables</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>GitLab Runner Exec command</td><td>✗</td><td>✓</td><td>✗</td><td>✗</td><td>✓</td><td>✓</td></tr><tr><td>gitlab-ci.yml: image</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✓</td><td>✓</td></tr><tr><td>gitlab-ci.yml: services</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✓</td><td>✓</td></tr><tr><td>gitlab-ci.yml: cache</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>gitlab-ci.yml: artifacts</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>Absolute paths: caching, artifacts</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✓</td></tr><tr><td>Passing artifacts between stages</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>Use GitLab Container Registry private images</td><td>n/a</td><td>n/a</td><td>n/a</td><td>n/a</td><td>✓</td><td>✓</td></tr><tr><td>Interactive Web terminal</td><td>✗</td><td>✓ (bash)</td><td>✗</td><td>✗</td><td>✓</td><td>✓</td></tr></tbody></table><p><br></p><p>不同shell支持的系统：</p><table><thead><tr><th>Shells</th><th>Bash</th><th>Windows Batch</th><th>PowerShell</th></tr></thead><tbody><tr><td>Windows</td><td>✓</td><td>✓ (default)</td><td>✓</td></tr><tr><td>Linux</td><td>✓ (default)</td><td>✗</td><td>✗</td></tr><tr><td>OSX</td><td>✓ (default)</td><td>✗</td><td>✗</td></tr><tr><td>FreeBSD</td><td>✓ (default)</td><td>✗</td><td>✗</td></tr></tbody></table><p><br></p><p>不同shell支持的交互式Web终端：</p><table><thead><tr><th>Shells</th><th>Bash</th><th>Windows Batch</th><th>PowerShell</th></tr></thead><tbody><tr><td>Windows</td><td>✗</td><td>✗</td><td>✗</td></tr><tr><td>Linux</td><td>✓</td><td>✗</td><td>✗</td></tr><tr><td>OSX</td><td>✓</td><td>✗</td><td>✗</td></tr><tr><td>FreeBSD</td><td>✓</td><td>✗</td><td>✗</td></tr></tbody></table><p><br><br><br><br><br></p><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>Shell executor 是一个简单的执行程序，它允许您在运行Runner的机器上本地执行构建。它支持可以安装Runner的所有系统。这意味着它可使用Bash和PowerShell。</p><p>在Bash中，在<code>gitlab-runner command</code>命令之后加上<code>--user</code>，表示使用非特权用户运行。</p><p><br></p><p>源项目被切换到: <code>&lt;working-directory&gt;/builds/&lt;short-token&gt;/&lt;concurrent-id&gt;/&lt;namespace&gt;/&lt;project-name&gt;</code><br>项目的缓存放于: <code>&lt;working-directory&gt;/cache/&lt;namespace&gt;/&lt;project-name&gt;</code></p><p>这些都在GitLab-runner的配置: <code>/etc/gitlab-runner/atom.config.toml</code></p><p><br></p><p><strong>以非特权用户运行(Running as unprivileged user)</strong></p><p>在Linux上(rpm/dpk)，安装程序将尝试使用<code>gitlab_ci_multi_runner</code>用户(如果找到)；如果找不到，它将创建一个<code>gitlab-runner</code>用户并改为使用它。<br>然后，所有shell build都将使用<code>gitlab-runner</code>或<code>gitlab_ci_multi_runner</code>用户执行。</p><p><br></p><p>在某些场景中，您的构建可能需要访问某些特权资源，例如Docker Engine或VirtualBox。在这种情况下，您需要将gitlab-runner用户添加到相应的组：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG docker gitlab-runner</span><br><span class="line">usermod -aG vboxusers gitlab-runner</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="Docker-1"><a href="#Docker-1" class="headerlink" title="Docker"></a>Docker</h3><p>The Docker executor</p><p>文档: <a href="https://docs.gitlab.com/runner/executors/docker.html" target="_blank" rel="noopener">https://docs.gitlab.com/runner/executors/docker.html</a></p><p><br><br><br><br><br></p><h3 id="K8s"><a href="#K8s" class="headerlink" title="K8s"></a>K8s</h3><p>The Kubernetes executor</p><p>文档: <a href="https://docs.gitlab.com/runner/executors/kubernetes.html" target="_blank" rel="noopener">https://docs.gitlab.com/runner/executors/kubernetes.html</a></p><p><br><br><br><br><br><br><br></p><h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><p>Advanced Configuration</p><p><br></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Advanced configuration options Learn how to use the TOML configuration file that GitLab Runner uses.</p><p>GitLab Runner配置使用TOML格式，配置文件可能在如下位置:</p><ul><li><code>/etc/gitlab-runner/config.toml</code></li><li><code>~/.gitlab-runner/config.toml</code></li><li><code>./config.toml</code></li></ul><p><br></p><h4 id="global部分"><a href="#global部分" class="headerlink" title="global部分"></a>global部分</h4><p>这定义了GitLab Runner的全局配置。</p><table><thead><tr><th>配置</th><th>描述</th></tr></thead><tbody><tr><td><code>concurrent</code></td><td>限制全局可以同时运行多少个作业，0并不意味着无限制</td></tr><tr><td><code>log_level</code></td><td>日志级别(debug, info, warn, error, fatal, panic)</td></tr><tr><td><code>log_format</code></td><td>日志格式(runner, text, json)</td></tr><tr><td><code>check_interval</code></td><td>定义新作业检查之间的间隔长度(s)。默认值为3，如果设置为0或更低，将使用默认值</td></tr><tr><td><code>sentry_dsn</code></td><td>启用追踪所有系统级错误</td></tr><tr><td><code>listen_address</code></td><td><code>host:port</code>，Prometheus应该在其上进行监听</td></tr></tbody></table><p><br></p><p><strong><code>check_interval</code> 如何工作:</strong></p><p>如果<code>config.toml</code>配置文件中有多个<code>[[runner]]</code>(称之为worker)，那么GitLab请求之间的间隔比人们预期的要频繁。GitLab Runner包含一个循环，该循环不断地为worker针对其配置的GitLab实例调度请求。</p><p><br><br><br></p><h4 id="session-server-部分"><a href="#session-server-部分" class="headerlink" title="[session_server]部分"></a><code>[session_server]</code>部分</h4><p><code>[session_server]</code>是系统运行程序级别的配置，因此应该在根级别指定，而不是每个执行器指定，即它应该在<code>[[runners]]</code>部分之外。session server允许用户与Runner负责的作业进行交互。<br>如果想要禁用<code>[session_server]</code>部分，删掉它即可。</p><table><thead><tr><th>配置</th><th>描述</th></tr></thead><tbody><tr><td><code>listen_address</code></td><td>用于session server的内部URL</td></tr><tr><td><code>advertise_address</code></td><td>向GitLab公开的用于访问Runner的URL</td></tr><tr><td><code>session_timeout</code></td><td>作业完成后，会话可以在多长时间内保持活动状态(默认1800s)</td></tr></tbody></table><p><br><br><br></p><h4 id="runners-部分"><a href="#runners-部分" class="headerlink" title="[[runners]]部分"></a><code>[[runners]]</code>部分</h4><p>如下定义了Runner entry:</p><table><thead><tr><th>配置</th><th>描述</th></tr></thead><tbody><tr><td><code>name</code></td><td>Runner的描述</td></tr><tr><td><code>url</code></td><td>GitLab URL</td></tr><tr><td><code>token</code></td><td>Runner指定的token</td></tr><tr><td><code>tls-ca-file</code></td><td>HTTPS的CA证书</td></tr><tr><td><code>tls-cert-file</code></td><td>HTTP的S端证书</td></tr><tr><td><code>tls-key-file</code></td><td>HTTPS的S端Key</td></tr><tr><td><code>limit</code></td><td>限制此token可同时处理的作业数，0为不限制</td></tr><tr><td><code>executor</code></td><td>执行器</td></tr><tr><td><code>shell</code></td><td>用于生成脚本的shell的名称</td></tr><tr><td><code>builds_dir</code></td><td>构建将存储在所选执行器的上下文中的目录(local, docker, ssh)</td></tr><tr><td><code>cache_dir</code></td><td>构建缓存将存储在所选执行器的上下文中的目录(local, docker, ssh)</td></tr><tr><td><code>environment</code></td><td>附加或覆盖环境变量</td></tr><tr><td><code>request_concurrency</code></td><td>限制GitLab新作业的并发请求数（默认值为1）</td></tr><tr><td><code>output_limit</code></td><td>最大构建日志大小(默认4096KB)</td></tr><tr><td><code>pre_clone_script</code></td><td>在克隆Git存储库之前要在Runner上执行的命令</td></tr><tr><td><code>pre_build_script</code></td><td>克隆Git存储库之后但在执行构建之前要在Runner上执行的命令</td></tr><tr><td><code>post_build_script</code></td><td>在执行构建之后但在执行<code>after_script</code>之前在Runner上执行的命令</td></tr><tr><td><code>clone_url</code></td><td>覆盖GitLab实例的URL</td></tr></tbody></table><p><br></p><p><strong><code>clone_url</code>怎样工作:</strong></p><p>如果GitLab实例公开给Runner无法使用的URL，则可以配置<code>clone_url</code>。</p><p><br><br><br></p><p>####　EXECUTORS</p><ul><li>shell</li><li>docker</li><li>docker-ssh</li><li>ssh</li><li>parallels</li><li>virtualbox</li><li>docker+machine</li><li>docker-ssh+machine</li><li>kubernetes</li></ul><p><br><br><br></p><h4 id="SHELLS"><a href="#SHELLS" class="headerlink" title="SHELLS"></a>SHELLS</h4><ul><li>bash</li><li>sh</li><li>cmd</li><li>powershell</li></ul><p><br><br><br></p><p>####　<code>[runners.docker]</code>部分</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>host</code></td><td>指定Docker endpoint (默认 <code>$DOCKER_HOST</code>或<code>unix:///var/run/docker.sock</code>)</td></tr><tr><td><code>hostname</code></td><td>为Docker容器指定主机名</td></tr><tr><td><code>runtime</code></td><td>为Docker容器指定一个运行环境</td></tr><tr><td><code>tls_cert_path</code></td><td>证书路径</td></tr><tr><td><code>image</code></td><td>使用此镜像进行构建</td></tr><tr><td><code>memory</code></td><td>容器内存限制</td></tr><tr><td><code>memory_swap</code></td><td>总内存限制</td></tr><tr><td><code>memory_reservation</code></td><td>容器内存soft limit</td></tr><tr><td><code>oom_kill_disable</code></td><td>容器OOM后也不kill进程</td></tr><tr><td><code>cpuset_cpus</code></td><td>容器使用的CPU</td></tr><tr><td><code>cpus</code></td><td>CPU数量</td></tr><tr><td><code>dns</code></td><td>容器使用的DNS列表</td></tr><tr><td><code>dns_search</code></td><td>DNS搜索域列表</td></tr><tr><td><code>privileged</code></td><td>特权容器</td></tr><tr><td><code>disable_entrypoint_overwrite</code></td><td>禁用镜像端点覆盖</td></tr><tr><td><code>userns_mode</code></td><td>启用usernamespace重映射选项时，为容器设置usernamespace模式</td></tr><tr><td><code>cap_add</code></td><td>向容器添加其他Linux功能</td></tr><tr><td><code>cap_drop</code></td><td>从容器中移除其他Linux功能</td></tr><tr><td><code>security_opt</code></td><td>设置安全选项(key: value)</td></tr><tr><td><code>devices</code></td><td>与容器共享其他主机设备</td></tr><tr><td><code>cache_dir</code></td><td>指定缓存目录</td></tr><tr><td><code>disable_cache</code></td><td>禁用缓存</td></tr><tr><td><code>network_mode</code></td><td>将容器添加到一个自定义的网络</td></tr><tr><td><code>wait_for_services_timeout</code></td><td>等待docker的时间，0为禁用(默认30)</td></tr><tr><td><code>volumes</code></td><td>docker挂载卷</td></tr><tr><td><code>extra_hosts</code></td><td>指定应在容器环境中定义的主机</td></tr><tr><td><code>shm_size</code></td><td>指定镜像共享的内存大小(Byte))</td></tr><tr><td><code>volumes_from</code></td><td>指定从其它容器继承的卷(格式: `\<container name\="">[:\&lt;ro</container></td><td>rw>]`)</td></tr><tr><td><code>volume_driver</code></td><td>指定容器使用的卷的驱动</td></tr><tr><td><code>links</code></td><td>指定与其建立链接的容器</td></tr><tr><td><code>services</code></td><td>指定使用build运行的其它服务</td></tr><tr><td><code>allowed_images</code></td><td>指定可在<code>.gitlab-ci.ym</code>l中指定的通配符图像列表</td></tr><tr><td><code>allowed_services</code></td><td>指定可在<code>.gitlab-ci.yml</code>中指定的通配符服务列表</td></tr><tr><td><code>pull_policy</code></td><td>指定镜像拉取策略</td></tr><tr><td><code>sysctls</code></td><td>指定sysctl options</td></tr><tr><td><code>helper_image</code></td><td>覆盖用于克隆repos和上载工件的默认帮助程序镜像</td></tr></tbody></table><p><br><br><br></p><h4 id="runners-parallels-部分"><a href="#runners-parallels-部分" class="headerlink" title="[runners.parallels]部分"></a><code>[runners.parallels]</code>部分</h4><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>base_name</code></td><td>将克隆的Parallels VM的名称</td></tr><tr><td><code>template_name</code></td><td>Parallels VM链接模板的自定义名称</td></tr><tr><td><code>disable_snapshots</code></td><td>如果禁用，则在构建之后将摧毁VM</td></tr></tbody></table><p><br><br><br></p><h4 id="runners-virtualbox-部分"><a href="#runners-virtualbox-部分" class="headerlink" title="[runners.virtualbox]部分"></a><code>[runners.virtualbox]</code>部分</h4><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>base_name</code></td><td>要克隆的VirtualBox VM的名称</td></tr><tr><td><code>base_snapshot</code></td><td>要从中创建链接克隆的VM的特定快照的名称或UUID</td></tr><tr><td><code>disable_snapshots</code></td><td>如果禁用，则在构建之后将摧毁VM</td></tr></tbody></table><p><br><br><br></p><h4 id="runners-ssh-部分"><a href="#runners-ssh-部分" class="headerlink" title="[runners.ssh]部分"></a><code>[runners.ssh]</code>部分</h4><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>host</code></td><td>指定主机</td></tr><tr><td><code>port</code></td><td>指定端口</td></tr><tr><td><code>user</code></td><td>指定用户</td></tr><tr><td><code>password</code></td><td>指定密码</td></tr><tr><td><code>identity_file</code></td><td>指定私钥</td></tr></tbody></table><p><br><br><br></p><h4 id="runners-machine-部分"><a href="#runners-machine-部分" class="headerlink" title="[runners.machine]部分"></a><code>[runners.machine]</code>部分</h4><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td><code>IdleCount</code></td><td>Number of machines, that need to be created and waiting in Idle state.</td></tr><tr><td><code>IdleTime</code></td><td>Time (in seconds) for machine to be in Idle state before it is removed.</td></tr><tr><td><code>OffPeakPeriods</code></td><td>Time periods when the scheduler is in the OffPeak mode. An array of cron-style patterns (described below).</td></tr><tr><td><code>OffPeakTimezone</code></td><td>Time zone for the times given in OffPeakPeriods. A timezone string like Europe/Berlin (defaults to the locale system setting of the host if omitted or empty).</td></tr><tr><td><code>OffPeakIdleCount</code></td><td>Like IdleCount, but for Off Peak time periods.</td></tr><tr><td><code>OffPeakIdleTime</code></td><td>Like IdleTime, but for Off Peak time mperiods.</td></tr><tr><td><code>MaxBuilds</code></td><td>Builds count after which machine will be removed.</td></tr><tr><td><code>MachineName</code></td><td>Name of the machine. It must contain %s, which will be replaced with a unique machine identifier.</td></tr><tr><td><code>MachineDriver</code></td><td>Docker Machine driver to use</td></tr><tr><td><code>MachineOptions</code></td><td>Docker Machine options</td></tr></tbody></table><p><br><br><br></p><h4 id="runners-cache-部分"><a href="#runners-cache-部分" class="headerlink" title="[runners.cache]部分"></a><code>[runners.cache]</code>部分</h4><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>Type</code></td><td>string</td><td>One of: <code>s3</code>, <code>gcs</code></td></tr><tr><td><code>Path</code></td><td>string</td><td>Name of the path to prepend to the cache URL</td></tr><tr><td><code>Shared</code></td><td>boolean</td><td>Enables cache sharing between runners, <code>false</code> by default</td></tr></tbody></table><p><br><br><br></p><h4 id="runners-kubernetes-部分"><a href="#runners-kubernetes-部分" class="headerlink" title="[runners.kubernetes]部分"></a><code>[runners.kubernetes]</code>部分</h4><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>host</code></td><td>k8s master url</td></tr><tr><td><code>cert_file</code></td><td>k8s master认证证书</td></tr><tr><td><code>key_file</code></td><td>k8s master 私钥</td></tr><tr><td><code>ca_file</code></td><td>k8s master CA</td></tr><tr><td><code>image</code></td><td>当未指定时，用于构建的默认docker镜像</td></tr><tr><td><code>namespace</code></td><td>命名空间</td></tr><tr><td><code>privileged</code></td><td>特权容器(true/false)</td></tr><tr><td><code>node_selector</code></td><td>节点选择器</td></tr><tr><td><code>image_pull_secrets</code></td><td>镜像拉取秘钥</td></tr></tbody></table><p><br><br><br><br><br></p><h3 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h3><p>Use self-signed certificates Configure certificates that are used to verify TLS peer when connecting to the GitLab server.</p><p>这允许在注册runner时解决由未知权限问题签名的证书(<code>x509</code>)。</p><p><br></p><p><strong>支持自签名的证书:</strong></p><ol><li>默认情况下： GitLab Runner读取系统存储的证书并根据存储在系统中的CA验证GitLab服务器</li><li>GitLab Runner从预定义文件中读取PEM（不支持DER格式）证书: 如<code>/etc/gitlab-runner/certs/</code></li><li>GitLab Runner在注册期间和<code>[[runners]]</code>部分下的<code>config.toml</code>配置中公开<code>tls-ca-file</code>选项，允许您指定带证书的自定义文件。每当Runner尝试访问GitLab服务器时，都会读取此文件。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维基百科&lt;/li&gt;
&lt;li&gt;GitLab文档: &lt;a href=&quot;https://docs.gitlab.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.gitlab.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;版本:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitLib-CE: &lt;code&gt;v11.6.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;GitLab-Runner: &lt;code&gt;v11.6.0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Git" scheme="https://zhang21.github.io/tags/Git/"/>
    
      <category term="GitLab" scheme="https://zhang21.github.io/tags/GitLab/"/>
    
      <category term="CI" scheme="https://zhang21.github.io/tags/CI/"/>
    
      <category term="CD" scheme="https://zhang21.github.io/tags/CD/"/>
    
  </entry>
  
  <entry>
    <title>大明官职</title>
    <link href="https://zhang21.github.io/2018/12/05/%E6%98%8E%E6%9C%9D%E5%AE%98%E8%81%8C/"/>
    <id>https://zhang21.github.io/2018/12/05/明朝官职/</id>
    <published>2018-12-05T07:53:04.000Z</published>
    <updated>2018-12-05T10:09:42.357Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>维基百科</li><li>《万历十五年》</li><li>《南明史》</li><li>《中国历史地图集》</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br><br><br></p><p>最近看《万历十五年》、《南明史》及电视剧“大明王朝1566”有感，想详细地了解一下大明王朝的官职制度。</p><p><br><br><br></p><hr><p><br><br><br></p><p>朱明王朝是以<strong>“驱逐胡虏，恢复中华”</strong>为号召北伐中原。</p><p>1368年正月，朱元璋于南京称帝，即明太祖，年号洪武，明朝建立。大明朝（1368年1月23日）是中国历史上最后一个由汉人建立的大一统王朝。<br>如按照李自成大顺军攻破北京，崇祯皇帝于煤山自缢(1644年)来算，历经十二世、十六位皇帝，国祚二百七十六年；<br>如加上南明永历皇帝被吴三桂勒死于昆明(1662年)来算，历经十九位皇帝，国祚二百九十四年。</p><blockquote><p>注：本文将按照万历时期来查看大明疆域和体制。</p></blockquote><p><br><br><br></p><p><strong>大明君主列表：</strong></p><table><thead><tr><th>庙号</th><th>谥号</th><th>名讳</th><th>在世时间</th><th>年号</th><th>在位时间</th></tr></thead><tbody><tr><td>太祖</td><td>高皇帝</td><td>朱元璋</td><td>1328年－1398年</td><td>洪武</td><td>1368年－1398年</td></tr><tr><td>惠宗</td><td>让皇帝</td><td>朱允炆</td><td>1377年－？</td><td>建文</td><td>1398年－1402年</td></tr><tr><td>成祖</td><td>文皇帝</td><td>朱棣(di)</td><td>1360年－1424年</td><td>永乐</td><td>1402年－1424年</td></tr><tr><td>仁宗</td><td>昭皇帝</td><td>朱高炽(chi)</td><td>1378年－1425年</td><td>洪熙</td><td>1424年－1425年</td></tr><tr><td>宣宗</td><td>章皇帝</td><td>朱瞻基</td><td>1399年－1435年</td><td>宣德</td><td>1425年－1435年</td></tr><tr><td>英宗</td><td>睿皇帝</td><td>朱祁镇</td><td>1427年－1464年</td><td>正统 <br> 天顺(复辟)</td><td>1435年－1449年 <br> 1457年－1464年</td></tr><tr><td>代宗</td><td>景皇帝</td><td>朱祁钰</td><td>1428年－1457年</td><td>景泰</td><td>1449年－1457年</td></tr><tr><td>宪宗</td><td>纯皇帝</td><td>朱见深</td><td>1447年－1487年</td><td>成化</td><td>1464年－1487年</td></tr><tr><td>孝宗</td><td>敬皇帝</td><td>朱佑樘(cheng)</td><td>1470年－1505年</td><td>弘治</td><td>1487年－1505年</td></tr><tr><td>武宗</td><td>毅皇帝</td><td>朱厚照</td><td>1491年－1521年</td><td>正德</td><td>1505年－1521年</td></tr><tr><td>世宗</td><td>肃皇帝</td><td>朱厚熜</td><td>1507年－1567年</td><td>嘉靖</td><td>1521年－1567年</td></tr><tr><td>穆宗</td><td>庄皇帝</td><td>朱载坖(ji)</td><td>1537年－1572年</td><td>隆庆</td><td>1567年－1572年</td></tr><tr><td>神宗</td><td>显皇帝</td><td>朱翊钧</td><td>1563年－1620年</td><td>万历</td><td>1572年－1620年</td></tr><tr><td>光宗</td><td>贞皇帝</td><td>朱常洛</td><td>1582年－1620年</td><td>泰昌</td><td>1620年</td></tr><tr><td>熹宗</td><td>悊皇帝</td><td>朱由校</td><td>1605年－1627年</td><td>天启</td><td>1620年－1627年</td></tr><tr><td>怀宗</td><td>烈皇帝</td><td>朱由检</td><td>1611年－1644年</td><td>崇祯</td><td>1627年－1644年</td></tr><tr><td>南明</td><td>福王</td><td>朱由崧</td><td>1607年－1646年</td><td>弘光</td><td>1644年6月－1645年6月</td></tr><tr><td>南明</td><td>唐王</td><td>朱聿键</td><td>1602年－1646年</td><td>隆武</td><td>1645年8月－1646年10月</td></tr><tr><td>南明</td><td>桂王</td><td>朱由榔</td><td>1623年－1662年</td><td>永历</td><td>1646年12月－1661年8月</td></tr></tbody></table><p><br><br><br></p><p>明一代为直隶二、布政使司十三。流俗称为两京一十三省。二直隶又称京师、南京二京，十三布政使司俗称十三省。</p><ul><li>二京<ul><li>京师顺天府(北直隶)</li><li>南京应天府(南直隶)</li></ul></li><li>十三布政使司<ul><li>陕西</li><li>山西</li><li>山东</li><li>河南</li><li>浙江</li><li>江西</li><li>湖广</li><li>四川</li><li>广东</li><li>福建</li><li>广西</li><li>贵州</li><li>云南</li></ul></li></ul><p><br></p><p>万历时期大明地图：</p><p><img src="/images/Ming/Map_wanli.jpg" alt=""></p><p><br><br><br></p><p><strong>行政：</strong></p><p>明朝一级地方行政区分置承宣布政使司（布政司）、提刑按察使司（按察司）与都指挥使司（都司）的都布按三司制度，分别掌管行政、司法与军事等三种治权，防止地方权力集中。</p><p>布政司通称省，底下依序有道、府州与县。道是明朝特别设置介于省和府州之间的行政单位，分为分守道和分巡道两种，分守道为布政司的派出机构，负责监督协调府州行政，分巡道为按察司的派出机构，负责监督协调府州司法治安。府为明朝最主要的统县政区，原为元朝的路，以税粮多寡为划分标准，粮廿万石以上为上府，廿万以下十万以上为中府，十万以下为下府。州与府同样是统县政区，但人口税收比府少，地位也比府低。州按照其行政隶属分为两类，直辖于布政司的州称直隶州，隶属于府的称散州或属州。军事区划有卫、所两级，但部分位于少数民族聚居区或边疆军屯区的卫所具有类似内地州县的行政职能，行政上分别相当于府与县。明代宗、明英宗时设有中央派出管理行政的巡抚与管理军事的总督，地位在布政司与都司之上。为限制巡抚与总督的权力，又设有都御史制衡之。明朝最后有140府，193州，1138县，493卫，359所。</p><p>巡抚主理民政，原本是明宣宗时期派六部、都察院大臣以此为名义督抚地方行政，到明代宗时正式形成一级行政区。总督于明英宗时设置，分短期与长期两种，管辖数个布政司的军务。</p><p><br><br><br></p><p><strong>内阁</strong></p><p>洪武十三年（1380年），明太祖以丞相胡惟庸谋反伏诛，于是废去中书省和丞相一职。秦、汉以降实行一千六百余年的宰相制度自此废除，六部直接向皇帝负责，相权与君权合而为一，大权独揽，施行军权、行政权、监察权三权分立的国家体制。由于国家事务繁多，皇帝无法处理，而明太祖也一度深感疲惫，于是设立四辅制度来辅佐政事。但这项制度效能不彰。洪武十七年（1384年）后被废。之后朱元璋请来几位翰林学士帮忙辅佐，这些翰林学士的官职效仿唐宋馆阁学士旧制，被命为“某某殿（阁）大学士”[注 24]，官阶只有正五品。明成祖登基后，特派解缙、胡广、杨荣等入午门值文渊阁，参预机务，由此始设内阁</p><p>内阁最初只是皇帝的咨询机构，相当于今日秘书或幕僚的职务，奏章的批答为皇帝的专责。到后来成为明朝实际上最高决策机构，首辅地位有时可比丞相，有票拟之权明朝内阁由始至终都不是明朝中枢的一级行政机构，所谓内阁只是文渊阁的别称。内阁大学士一职多以硕德宿儒或朝中大臣担任，只照皇帝的意旨写出，称“传旨当笔”，权力及地位远远不及过去的宰相，只有有实无名之地位，而没有法定地位。宣宗时期，由于杨溥、杨士奇、杨荣等三杨入阁，宣宗批准内阁在奏章上以条旨陈述己见，称为“票拟”制度，又授予宦官机构司礼监“批红”。票拟之法补救可君主不愿面见阁臣之弊，但内阁大臣与皇帝沟通，全赖司礼监（宦官）。</p><p><br><br><br></p><p><strong>六部</strong></p><p>明朝在中央设置吏、户、礼、工、刑、兵六部，与前代相比，明朝最初在每部增加尚书、侍郎各一。胡惟庸案之后，朱元璋废丞相之职，取消中书省。六部因此地位得到提高。每部只设一个尚书，两个侍郎，原有的各科尚书降为郎中。各部尚书和侍郎的官阶也上升。<br>其中以礼部（主管教育，负责领导儒家学术，以及祭祀，外交等）和吏部（主管文官升迁）最为重要，户部（主管财政，土地和人口）人员最多。兵部（主管国防），刑部（主管司法，有对较大刑事案件的审判权）与工部（主管公共建设）地位较低。</p><p>在拟诏审议机构上，明朝开始只设给事中与中书舍人，不复设中书门下二省。明朝的审议机构为六科给事中，到洪武廿四年，设都给事中六人，分吏、户、礼、工、刑、兵六科，每科一人，每科都给事中下设左右给事中各一人及给事中若干。六科给事中制度基本是继承唐朝的门下省制度，但官位下降，机构更为精简，也失去了自魏晋以来皇帝内臣（皇室的收发站）和礼官的职责。六科官职品级虽低，然职权很高，他们可以批驳皇帝的意旨， 也能充当谏官的职责，对六部吏僚则具有分科对应的监察权，故该制度也发挥一定的改善朝政作用。明朝的拟诏机构为中书舍人官署，因其制度源流源于与门下并立的中书，故与六科相对俗称 “中书科”，但是其地位大为下降，职能也大幅削弱，事实上只是内阁与翰林院的誊抄机构。中央的重要事务执行机构为五寺，包括大理寺、太常寺、光禄寺、太仆寺、鸿胪寺，与唐宋相比，减省了四寺：宗正寺被并入宗人府，卫尉寺被并入兵部，司农寺与太府寺被并入户部。大理寺与刑部和都察院合为三法司，负责重大刑事案件的复审与复核。大理寺的首长称为大理寺卿，也是九卿之一。其余四个寺的卿职权较低。太常寺负责祭祀；太仆寺管理马匹与全国牧政；光禄寺负责寿宴；鸿胪寺负责接待外宾。</p><p><br><br><br></p><p><strong>监察机构</strong></p><p>在洪武十三年前，明朝还沿袭元的监察制度，设立御史台，有左右御史大夫各一名。洪武十三年后，朱元璋废御史台。两年之后，朱元璋设立新的监察机构—都察院。都察院下面设立监察御史若干人，分巡全国各省，称为十二道监察御史。每道有监察御史三至五人，范围大体为一省。但监察御史都驻在京师，有事带印出巡，事毕回京缴印。到明末，监察御史分为十三道，共有一百一十人。都察院与六科同样具有谏官的职能和风闻言事的职责，故合称“科道言官”。</p><p><br><br><br></p><p><strong>厂卫制度</strong></p><p>明初还实行特务机构，主要包括锦衣卫、东厂和西厂，武宗时期还一度设有内行厂。锦衣卫设立于洪武十五年，直接听命于皇上，可以逮捕任何人，并进行不公开的审讯。但是朱元璋晚年逐步废除了锦衣卫及其特权，还有一些比较残酷的刑法。<br>在东厂设立后，锦衣卫权力受到削弱。东厂成立于永乐十八年，是明成祖为镇压政治上的反对力量而成立。地点位于京师东安门北。东厂的主要职责就是监视政府官员、社会名流、学者等各种政治力量，并有权将监视结果直接向皇帝汇报。依据监视得到的情报，对于那些地位较低的政治反对派，东厂可以直接逮捕、审讯；而对于担任政府高级官员或者有皇室贵族身份的反对派，东厂在得到皇帝的授权后也能够对其执行逮捕、审讯。东厂在设立之初，就由宦官担任提督，后来通常以司礼监秉笔太监中位居第二、第三者担任。西厂设立于宪宗时期，首领为汪直。1482年后被废。其后又被武宗短暂恢复。内厂设置于武宗时期，首领为宦官刘瑾，刘瑾伏诛后，内厂与西厂同时被废除，仅留东厂。</p><p><br><br><br></p><p><strong>其它机构</strong></p><p>公孤官包括三公与三孤，是名义上的诸臣之首，但这些官职都是虚衔，一般授予功劳相当大的大臣以示荣耀。三公为太师、太傅、太保，三孤则是辅弼他们的少师、少傅、少保。其中太保和太傅名义上是太子的老师，而太师则是皇帝名义上的老师，但实际上辅导太子的机构是詹事府。詹事府下设两坊、一局、一厅。此外还有太医院，专门负责皇室人员的健康和医疗。太医院附属有生药库和惠民药局。翰林院作为政府的官方学术最高机构，地位相当重要，甚至在政府中都有相当大的影响力。翰林院首长是翰林大学士，此职位者经常会同时兼任内阁大臣。</p><p>诸司指不属于各部院的司。主要指通政司和行人司。通政司负责传递公文，公告周知。行人司负责到地方上颁诏谕及赴外国作使臣。</p><p>外三监包括国子监、钦天监、上林苑监。钦天监负责观测星象。国子监是最高官方教育机构，也是全国官学的领导机构，有祭酒一人，司业一人，监丞一人，博士五人，助教十五人，学正十人，学录七人，典簿一人，典籍一人，典馔两人。上林苑监负责掌管皇帝的御花园，畜牧场与菜圃。</p><p>内十二监为宦官衙门。事实上只有在这些衙门工作的宦官才是太监。包括司礼监、内宫监、御用监、司设监、御马监、神宫监、尚膳监、尚宝监、印绶监、直殿监、尚衣监、都知监。以司礼监最为重要，监内的提督太监主管宫内一切宦官礼仪刑名。而秉笔太监在宦官极端专权时竟代替皇帝批公文。此外宫内还设有四个司（惜薪、钟鼓、宝钞、混堂），八个局（兵仗、银作、浣衣、巾帽、针工、内织染、酒醋面，司苑），合为内官廿四衙门。宫女也有六个局（尚宫、尚仪、尚服、尚食、尚寝、尚工），每个局下设四个司。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维基百科&lt;/li&gt;
&lt;li&gt;《万历十五年》&lt;/li&gt;
&lt;li&gt;《南明史》&lt;/li&gt;
&lt;li&gt;《中国历史地图集》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="History" scheme="https://zhang21.github.io/categories/History/"/>
    
    
      <category term="大明" scheme="https://zhang21.github.io/tags/%E5%A4%A7%E6%98%8E/"/>
    
      <category term="历史" scheme="https://zhang21.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>一战二战武器</title>
    <link href="https://zhang21.github.io/2018/11/18/%E4%B8%80%E6%88%98%E4%BA%8C%E6%88%98%E6%AD%A6%E5%99%A8/"/>
    <id>https://zhang21.github.io/2018/11/18/一战二战武器/</id>
    <published>2018-11-18T15:35:49.000Z</published>
    <updated>2018-11-22T05:28:33.909Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://zh.wikipedia.org/wiki/Category:%E5%90%84%E5%9B%BD%E4%B8%80%E6%88%98%E6%AD%A6%E5%99%A8" target="_blank" rel="noopener">各国一战武器，维基百科</a></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%96%E7%95%8C%E5%A4%A7%E6%88%98%E5%86%9B%E4%BA%8B%E8%A3%85%E5%A4%87" target="_blank" rel="noopener">第一次世界大战武器装备，维基百科</a></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E5%90%84%E5%9B%BD%E4%BA%8C%E6%88%98%E6%AD%A6%E5%99%A8" target="_blank" rel="noopener">各国二战武器，维基百科</a></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E4%BA%8C%E6%88%98%E6%AD%A6%E5%99%A8" target="_blank" rel="noopener">第二次世界大战武器装备，维基百科</a></li></ul><p><br><br><br></p><hr><p><br><br><br></p><p>最近玩<strong>battlefield I</strong>(一战)有感，一时兴起，顺带在<strong>battlefield V</strong>(二战)发布前夕做一个一战二战各国使用的武器装备归纳总结。</p><p>玩了战地1，才体会到战争的残酷性，使我对战争的感觉从光辉转变为厌恶。没有什么英雄在我心中，你不知道自己何时会死去，或即将死去。<br>战场上每个人都一样，都是一条鲜活的生命，有家人有朋友。从战争游戏来反思战争，这点DICE studio做的不错。</p><p><br></p><p><strong>衷心祝愿世界和平！</strong></p><p><br><br><br></p><a id="more"></a><hr><p><br><br><br></p><h1 id="一战"><a href="#一战" class="headerlink" title="一战"></a>一战</h1><p>第一次世界大战（简称一次大战、一战，或称欧战；英语：World War I、WWI、Great War、First World War；法语：la première Guerre Mondiale、la Grande Guerre）是一场于1914年7月28日至1918年11月11日主要发生在欧洲的大战，然而战火最终延烧至全球，当时世界上大多数国家都被卷入这场战争，史称“第一次世界大战”。</p><p><br></p><p>主要介绍国家：</p><ul><li>德国</li><li>法国</li><li>俄国</li><li>英国</li><li>美国</li></ul><p><br></p><p>主要武器分类：</p><ul><li>枪械</li><li>大炮</li><li>坦克</li><li>飞机</li><li>船舰</li></ul><p><br><br><br></p><h2 id="德国"><a href="#德国" class="headerlink" title="德国"></a>德国</h2><p>第一次世界大战德国主要武器</p><p><br></p><h3 id="手榴弹"><a href="#手榴弹" class="headerlink" title="手榴弹"></a>手榴弹</h3><p>hand grenade</p><p><br></p><ul><li><strong>柄式手榴弹</strong></li></ul><p>柄式手榴弹（德语：Stielhandgranate）为德国陆军自第一次世界大战中期至第二次世界大战末期所使用之手榴弹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重量595克</span><br><span class="line">长度365毫米</span><br><span class="line">直径70毫米</span><br><span class="line">填充三硝基甲苯（TNT）</span><br><span class="line">引爆机制5秒</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Stielhandgranate.png" alt=""></p><p><br><br><br></p><h3 id="手枪"><a href="#手枪" class="headerlink" title="手枪"></a>手枪</h3><p>pistol</p><p><br></p><ul><li><strong>毛瑟C96(Mauser C96)</strong></li></ul><p>由毛瑟在1896年推出的手枪，在中国还有驳壳枪、快慢机、自来得、大镜面等别称。<br>毛瑟（德语：Mauser）是一个德国的枪械制造商。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">重量        1.130公斤（空枪）</span><br><span class="line">长度        288毫米</span><br><span class="line">枪管长度     140毫米</span><br><span class="line">子弹        7.63×25mm毛瑟弹</span><br><span class="line">           9×19mm鲁格弹</span><br><span class="line">           .45 ACP</span><br><span class="line">           9×25mm毛瑟弹</span><br><span class="line">枪机      枪管短行程后座作用</span><br><span class="line">           单动</span><br><span class="line">发射模式    C96：半自动</span><br><span class="line">           M712速射型：半自动、全自动</span><br><span class="line">枪口初速    425米/秒</span><br><span class="line">有效射程100米</span><br><span class="line">最大射程200米</span><br><span class="line">供弹方式C96：10发内置弹仓</span><br><span class="line">M712速射型：10发或20发弹匣</span><br><span class="line">瞄具V型照门上刻度最大可调至1000米</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Mauser_C96.png" alt="毛瑟C96"></p><p><br></p><ul><li><strong>鲁格手枪（Pistole 08 Luger)</strong></li></ul><p>简称P08<br>该枪由奥地利人格奥尔格·鲁格于1898年设计，并由以德国武器及弹药兵工厂及毛瑟为首等多间工厂于1900年投入生产。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">重量        1.92磅（871克）</span><br><span class="line">长度      8.75英寸（222毫米）</span><br><span class="line">枪管长度     98毫米–203毫米</span><br><span class="line">           （3.9 -8.02英寸）</span><br><span class="line">子弹        7.65×21毫米帕拉贝伦弹</span><br><span class="line">           9毫米鲁格弹</span><br><span class="line">           .45 ACP（相当罕见）</span><br><span class="line">枪机     枪管短行程后座作用，肘节式起落闭锁（Toggle Lock）</span><br><span class="line">枪口初速    350 - 400米/秒</span><br><span class="line">有效射程    50米</span><br><span class="line">供弹方式    8发弹匣、32发弹鼓</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/P08.png" alt="P08"></p><p><br></p><ul><li><strong>帝国转轮手枪（Reichsrevolver）</strong></li></ul><p>该枪后来被著名的鲁格P08半自动手枪所取代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">重量1040克</span><br><span class="line">长度310毫米</span><br><span class="line">子弹10.6×25mmR</span><br><span class="line">口径10.6mm</span><br><span class="line">射速单动式</span><br><span class="line">枪口初速205米/秒</span><br><span class="line">供弹方式6发弹巢</span><br><span class="line">瞄具V型缺口及准星</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/M1879.png" alt="帝国轮转手枪"></p><p><br></p><ul><li><strong>贝格曼1896型手枪</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">重量1.13 kg</span><br><span class="line">长度254 mm</span><br><span class="line">枪管长度102 mm</span><br><span class="line">子弹5毫米贝格曼弹</span><br><span class="line">6.5毫米贝格曼弹</span><br><span class="line">8×22毫米贝格曼弹</span><br><span class="line">枪机反冲作用</span><br><span class="line">枪口初速380米/秒</span><br><span class="line">供弹方式5发载入内置弹仓内</span><br><span class="line">瞄具固定式瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Bergmann1896.png" alt="贝格曼1896型"></p><p><br></p><ul><li><strong>费罗梅尔停止手枪()Frommer Stop</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">重量610 g（22 oz）</span><br><span class="line">长度165 mm（6.5英寸）</span><br><span class="line">枪管长度95毫米（3.7英寸）</span><br><span class="line">子弹.32 ACP</span><br><span class="line">.380 ACP</span><br><span class="line">枪机长行程后座作用</span><br><span class="line">枪口初速280 m/s（919 ft/s）</span><br><span class="line">供弹方式7发弹匣</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/FrommerStop.png" alt=""></p><p><br><br><br></p><h3 id="冲锋枪"><a href="#冲锋枪" class="headerlink" title="冲锋枪"></a>冲锋枪</h3><p>Submachine Guns</p><p><br></p><ul><li><strong>MP18</strong></li></ul><p>MP18冲锋枪是第一次世界大战时期由德国的胡戈·施梅瑟所开发的冲锋枪。MP18冲锋枪因其生产厂Bergmann也被称为伯格曼冲锋枪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">重量4.18公斤</span><br><span class="line">长度832毫米</span><br><span class="line">枪管长度200 毫米</span><br><span class="line">子弹9毫米鲁格弹</span><br><span class="line">7.63×25毫米毛瑟弹</span><br><span class="line">枪机反冲作用、开放式枪机</span><br><span class="line">发射模式MP18：全自动</span><br><span class="line">MP28：半自动、全自动</span><br><span class="line">射速500发/分</span><br><span class="line">枪口初速380米/秒</span><br><span class="line">供弹方式32发弹匣 TM 08 （一战）；20，30 和 50 发弹匣（二战前）</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/MP18.png" alt="MP18"></p><p><br><br><br></p><h3 id="机枪"><a href="#机枪" class="headerlink" title="机枪"></a>机枪</h3><p>machine gun</p><p><br></p><ul><li><strong>MG08重机枪</strong></li></ul><p>Maschinengewehr 08（也称MG08，Maschinengewehr意为机枪）由海勒姆·马克沁1884年开发的马克沁机枪发展而来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">重量     连冷却水一共 69 kg ，除去冷却水65 kg 枪身26.5 kg 4 kg水 三脚架38.5 kg</span><br><span class="line">        MG08/15：连同两脚架17.8kg 水 3KG</span><br><span class="line">        MG08/18：不含两脚架14.5KG</span><br><span class="line">长度   1175 mm</span><br><span class="line">        MG08/15、MG08/18：1445 mm</span><br><span class="line">枪管长度720mm</span><br><span class="line">操作人数4人班组</span><br><span class="line">子弹7.92×57毫米毛瑟</span><br><span class="line">枪机枪管短后座，肘节式起落闭锁</span><br><span class="line">射速450-500 发/分</span><br><span class="line">枪口初速900米每秒（3,000英尺每秒）</span><br><span class="line">有效射程2,000米（2,200码）</span><br><span class="line">最大射程3,500米（3,800码）</span><br><span class="line">供弹方式250 发弹链</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/MG08.png" alt=""></p><p><br></p><ul><li><strong>麦德森轻机枪(Madsen machine gun)</strong></li></ul><p>这也是全世界上第一种大量生产的真正实用化的轻机枪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">重量空枪：9.07 千克（20 磅）</span><br><span class="line">长度1,143 毫米（45 英寸）</span><br><span class="line">枪管长度584.2 毫米（23 英寸）</span><br><span class="line">子弹</span><br><span class="line">6.5×55毫米瑞典子弹</span><br><span class="line">7×57毫米毛瑟子弹</span><br><span class="line">7.65×53毫米阿根廷子弹</span><br><span class="line">7.62×51毫米NATO</span><br><span class="line">7.62×54毫米R</span><br><span class="line">.303英式子弹[1]</span><br><span class="line">7.92×57毫米毛瑟子弹</span><br><span class="line">枪管1 根，膛线4 条，右旋，枪管装上风冷式枪管套和消焰器</span><br><span class="line">枪机枪管长行程后座作用</span><br><span class="line">发射模式全自动</span><br><span class="line">射速450发／分钟</span><br><span class="line">枪口初速6.5×55毫米瑞典子弹：700—870米／秒（2,296.59—2,854.33英尺／秒）</span><br><span class="line">供弹方式25、30、40发可拆卸式弹匣</span><br><span class="line">瞄具机械瞄具：Ｖ型缺口式照门及柱状准星</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Madsen_MachineGun.png" alt=""></p><p><br><br><br></p><h3 id="步枪"><a href="#步枪" class="headerlink" title="步枪"></a>步枪</h3><p>rifle</p><p><br></p><ul><li><strong>Gewehr 98步枪</strong></li></ul><p>Gewehr 98步枪（又称：G98、Gew 98、毛瑟M1898或M98）是德国毛瑟枪厂在德国军方采用Gewehr 88步枪后，为了夺回在德国枪械市场的地位而研制的步枪。Gew 98在1898年到1935年间为德国军队的制式步枪，直到它在1935年被毛瑟Kar98k步枪取代为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">重量4.09千克（9.0磅） Gewehr 98（空枪）</span><br><span class="line">        3.50千克（7.7磅） Karabiner 98a</span><br><span class="line">长度1,250 mm（49.2英寸） Gewehr 98</span><br><span class="line">        1,090 mm（42.9英寸） Karabiner 98a</span><br><span class="line">枪管长度740 mm（29.1英寸） Gewehr 98</span><br><span class="line">        590 mm（23.2英寸） Karabiner 98a</span><br><span class="line">子弹7.92×57mm毛瑟</span><br><span class="line">枪机旋转后拉式枪机</span><br><span class="line">枪口初速878 m/s（2,881 ft/s）</span><br><span class="line">有效射程500米（550 yd） （机械瞄具）</span><br><span class="line">        ≥800米（870 yd）（瞄准镜）</span><br><span class="line">供弹方式5发内置弹仓（能够以弹夹条压入）</span><br><span class="line">瞄具机械瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Gewehr98.png" alt=""></p><p><br></p><ul><li><strong>蒙德拉贡步枪</strong></li></ul><p>蒙德拉贡步枪（西班牙语：Fusil Mondragón）是一种由墨西哥上将曼努埃尔·蒙德拉贡(Manuel Mondragón)设计，瑞士工业公司（SIG）生产的半自动步枪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">重量4.18 公斤</span><br><span class="line">长度1105 毫米</span><br><span class="line">枪管长度577 毫米</span><br><span class="line">子弹7 × 57 毫米毛瑟弹/7.92 × 57 毫米毛瑟弹</span><br><span class="line">枪机气动式</span><br><span class="line">        转拴式枪机</span><br><span class="line">枪口初速760 米/秒</span><br><span class="line">有效射程800 米</span><br><span class="line">最大射程2,000 米</span><br><span class="line">供弹方式8、10、20、30 发可拆式弹匣</span><br><span class="line">        100 发弹鼓</span><br><span class="line">瞄具机械瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Mondragon_rifle.png" alt=""></p><p><br></p><ul><li><strong>毛瑟13.2毫米反坦克步枪</strong></li></ul><p>毛瑟13.2毫米反坦克步枪为德意志帝国陆军于第一次世界大战中针对协约国（主要是英国）的装甲车辆所研发生产的反装甲武器，初次登场时间是1918年2月。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">重量15.8公斤</span><br><span class="line">长度1.68米</span><br><span class="line">枪管长度0.98米</span><br><span class="line">子弹13.2mm TuF</span><br><span class="line">枪机旋转后拉式枪机</span><br><span class="line">枪口初速805米/秒</span><br><span class="line">供弹方式单发装填</span><br><span class="line">瞄具传统铁制照门</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/AntiTank_132mm.png" alt=""></p><p><br><br><br></p><h3 id="装甲车"><a href="#装甲车" class="headerlink" title="装甲车"></a>装甲车</h3><ul><li><strong>埃尔哈特E-V/4装甲车</strong></li></ul><p>埃尔哈特E-V/4装甲车是德国二战前研发用于轻度战斗和警务的装甲车。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">重量7.12 - 7.75 吨</span><br><span class="line">长度5.3 m</span><br><span class="line">宽度2 m</span><br><span class="line">高度2.85 m</span><br><span class="line">操作人数8 - 9人</span><br><span class="line">装甲约9 mm</span><br><span class="line">主武器三挺机枪</span><br><span class="line">发动机汽油</span><br><span class="line">80 hp (59 kw)</span><br><span class="line">功率/重量10.3 hp/tonne</span><br><span class="line">悬挂四轮驱动</span><br><span class="line">作战范围250 km</span><br><span class="line">速度61.3 km/h</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Panzer_EV4.png" alt=""></p><p><br><br><br></p><h3 id="坦克"><a href="#坦克" class="headerlink" title="坦克"></a>坦克</h3><p>Tank</p><p><br></p><ul><li><strong>A7V坦克</strong></li></ul><p>A7V（Sturmpanzerwagen A7V）是德意志帝国在第一次世界大战时开发的坦克。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">重量30 至33 吨</span><br><span class="line">长度7.34 米（24 尺 1 寸）</span><br><span class="line">宽度3.1 米（10 尺）</span><br><span class="line">高度3.3 米（10 尺 10 寸）</span><br><span class="line">操作人数18人</span><br><span class="line">装甲侧面20 毫米，正面50 毫米</span><br><span class="line">主武器57 毫米主炮</span><br><span class="line">副武器6挺7.92毫米机枪</span><br><span class="line">发动机2具戴姆勒4汽缸汽油引擎</span><br><span class="line">100匹／800-900转（149 千瓦）x2</span><br><span class="line">功率/重量6.5 匹／吨</span><br><span class="line">悬挂履带、立式弹簧</span><br><span class="line">作战范围30-80 公里（20-50 英里）</span><br><span class="line">速度9 公里／小时</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/A7V.png" alt=""></p><p><br></p><ul><li><strong>LK I</strong></li></ul><p>Leichter Kampfwagen (中文：轻型战斗车辆) 或“LK I”是第一次世界大战期间德国制造的原型轻型坦克。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">重量6.9 吨</span><br><span class="line">长度5.1 米</span><br><span class="line">宽度1.9 米</span><br><span class="line">高度2.5 米</span><br><span class="line">操作人数3 人</span><br><span class="line">装甲8-14 毫米</span><br><span class="line">主武器7.92 毫米 机枪</span><br><span class="line">发动机戴姆勒-奔驰4缸发动机</span><br><span class="line">60 匹/44.7 千瓦</span><br><span class="line">悬挂非悬挂</span><br><span class="line">作战范围70 千米</span><br><span class="line">速度14-18 千米/小时</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/LK1.png" alt=""></p><p><br><br><br></p><h3 id="飞机"><a href="#飞机" class="headerlink" title="飞机"></a>飞机</h3><p>aircraft</p><p><br></p><ul><li><strong>AEG B.I侦察机</strong></li></ul><p>AEG B.I侦察机是德国的双座双翼侦察机，于1914年小批量生产。它为AEG公司更成功的后继机型——B型和C型的设计提供了基础。</p><p><img src="/images/Weapons/AEG_BI.png" alt=""></p><p><br></p><ul><li><strong>J.I攻击机</strong></li></ul><p>J.I攻击机（制造厂商将其定为“J 4”，以防止与1915年开发的“J 1”机混淆）是德意志帝国陆军航空队于第一次世界大战所使用的一款地面攻击机、侦察机和连络机，由容克斯所研制，属德国“J系列”装甲航空机之一。</p><p><img src="/images/Weapons/JI.png" alt=""></p><p><br></p><ul><li><strong>信天翁C侦察机</strong></li></ul><p>信天翁C侦察机是由信天翁飞机公司研制的双翼侦察机，在第一次世界大战期间不单作为侦察机，还以其机载机枪件为战斗机和对地攻击机，信天翁飞机公司以此为基础推出信天翁D战斗机。</p><p><img src="/images/Weapons/C-VII.png" alt=""></p><p><br></p><ul><li><strong>信天翁D战斗机</strong></li></ul><p>信天翁D战斗机是由信天翁飞机公司以信天翁C侦察机的基础和参考了法国纽波特11战斗机而研制的双翼战斗机，在第一次世界大战期间是继福克E单翼战斗机后德国空军的主力战斗机。</p><p><img src="/images/Weapons/D-Va.png" alt=""></p><p><br></p><ul><li><strong>戈塔G轰炸机</strong></li></ul><p>戈塔G轰炸机是德国在第一次世界大战时的重型轰炸机，在大战期间主要用于轰炸英国，把死亡和恐惧带给英国民众。</p><p><img src="/images/Weapons/G-IV.png" alt=""></p><p><br></p><ul><li><strong>巨人机</strong></li></ul><p>巨人机（德语：Riesenflugzeug，複數時寫作：Riesenflugzeuge），英语有时简称为R型飞机，是指一次世界大战中德意志帝国所使用的重型轰炸机。</p><p><br></p><ul><li><strong>柏法茨战斗机</strong></li></ul><p>柏法茨双翼战斗机是在第一次世界大战时由德国柏法茨飞机公司(德文:Pfalz Flugzeugwerke)研制的双翼战斗机。</p><p><img src="/images/Weapons/D-IIIa.png" alt=""></p><p><img src="/images/Weapons/D-XII.png" alt=""></p><p><br></p><ul><li><strong>汉诺威CL攻击机</strong></li></ul><p>汉诺威CL攻击机是在第一次世界大战时由德国汉诺威飞机公司(德文:Hannoversche Waggonfabrik)研制的双翼攻击机，CL原本是指比一般侦察机（代号为C）轻巧的双座机，原本是用作为侦察机提供直接的护航，但后来发展成为对地攻击机尤其以其后座机枪作为居高临下的机枪火力点。</p><p><img src="/images/Weapons/CL-III.png" alt=""></p><p><br></p><ul><li><strong>福克战斗机</strong></li></ul><p>是福克飞机公司为了参加德国空军的“新型战斗机比赛”而提出的战斗机设计。</p><p><img src="/images/Weapons/D-VIII.png" alt=""></p><p><img src="/images/Weapons/D-VII.png" alt=""></p><p><img src="/images/Weapons/E-III.png" alt=""></p><p><br></p><ul><li><strong>罗兰C-II侦察机</strong></li></ul><p>罗兰C-II侦察机是由LFG公司（Luft-Fahrzeug-Gesellschaft）研制的双翼侦察机，它被誉为第一次世界大战当中最漂亮的德国侦察机，它也因此被称为“鲸鱼”。</p><p><img src="/images/Weapons/C-II.png" alt=""></p><p><br></p><ul><li><strong>齐柏林-斯塔肯R-VI轰炸机</strong></li></ul><p>齐柏林-斯塔肯R-VI轰炸机是德国在第一次世界大战时的重型轰炸机，在大战期间主要和戈塔G轰炸机一起轰炸英国，把死亡和恐惧带给英国民众。</p><p><img src="/images/Weapons/R-VI.png" alt=""></p><p><br></p><ul><li><strong>鸽式单翼机</strong></li></ul><p>鸽式单翼机是由奥地利(当时的“奥匈帝国)飞机工程师埃高．艾垂奇发明的，在第一次世界大战期间除了奥匈帝国，其同盟国盟友德意志帝国也大量采用作为侦察机、轰炸机和教练机等多种用途，虽然在1914年此机已算落伍，但毫无疑问的此后德国所有震惊世界的优秀军用飞机都是从鸽式单翼机开始的。</p><p><img src="/images/Weapons/geshi.png" alt=""></p><p><br><br><br></p><h3 id="巡洋舰"><a href="#巡洋舰" class="headerlink" title="巡洋舰"></a>巡洋舰</h3><p>一次世界大战德国巡洋舰： <a href="https://zh.wikipedia.org/wiki/Category:%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%96%E7%95%8C%E5%A4%A7%E6%88%B0%E5%BE%B7%E5%9C%8B%E5%B7%A1%E6%B4%8B%E8%89%A6" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Category:%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%96%E7%95%8C%E5%A4%A7%E6%88%B0%E5%BE%B7%E5%9C%8B%E5%B7%A1%E6%B4%8B%E8%89%A6</a></p><p><br></p><p>巡洋舰（英语：Cruiser）指在排水量、火力、装甲防护等方面仅次于战列舰的大型水面舰艇，拥有同时对付多个作战目标的能力，以及能胜任多种任务的多样性。历史上，巡洋舰由于吨位大、火力强、性能佳，一开始是指可以独立行动的战舰 ; 而与此相对的驱逐舰则需要其它船只（比如补给船只）的协助，才能执行任务。不过随着现今驱逐舰被大型化后的综合作战能力的提升，何潬吨位其实超过早年的巡洋舰，所以这个区分已经不明显了，很多新式的大型军舰都不再冠以巡洋舰之名了。</p><p>巡洋舰的用途顾名思义确实是用来巡逻的。</p><p><br><br><br></p><h3 id="战列舰"><a href="#战列舰" class="headerlink" title="战列舰"></a>战列舰</h3><p>一次大战德国战列舰: <a href="https://zh.wikipedia.org/wiki/Category:%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%96%E7%95%8C%E5%A4%A7%E6%88%98%E5%BE%B7%E5%9B%BD%E6%88%98%E5%88%97%E8%88%B0" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Category:%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%96%E7%95%8C%E5%A4%A7%E6%88%98%E5%BE%B7%E5%9B%BD%E6%88%98%E5%88%97%E8%88%B0</a></p><p><br></p><p>战列舰（英语：Battleship），是装有厚重装甲和大口径主炮的大型军舰，是人类创造的最庞大和复杂的武器系统之一，大舰巨炮主义时代的极致产物。</p><p><br><br><br></p><hr><p><br></p><h2 id="法国"><a href="#法国" class="headerlink" title="法国"></a>法国</h2><h3 id="手枪-1"><a href="#手枪-1" class="headerlink" title="手枪"></a>手枪</h3><ul><li><strong>FN M1900手枪(勃朗宁)</strong></li></ul><p>FN M1900是一款由著名枪械设计师约翰·勃朗宁于1896年设计，交由比利时Fabrique Nationale生产的单动式半自动手枪。该枪亦是史上第一款使用套筒设计的手枪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">重量625克（空枪）</span><br><span class="line">长度172亳米</span><br><span class="line">枪管长度102亳米</span><br><span class="line">子弹.32 ACP（7.65×17亳米）</span><br><span class="line">枪机反冲作用，单动</span><br><span class="line">供弹方式7 + 1发弹匣</span><br><span class="line">瞄具固定式瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/FN_M1900.jpg" alt=""></p><p><br></p><ul><li><strong>M1892转轮手枪</strong></li></ul><p>M1892转轮手枪（或称：勒贝尔转轮手枪或圣埃蒂安8毫米）是法国采用的一种制式手枪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">重量0.85公斤（空枪）</span><br><span class="line">长度24厘米</span><br><span class="line">子弹8毫米法国军械弹</span><br><span class="line">口径8毫米</span><br><span class="line">枪机双动式</span><br><span class="line">枪口初速220米/秒</span><br><span class="line">供弹方式6发弹巢</span><br><span class="line">瞄具机械瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/M1892.jpg" alt=""></p><p><br></p><ul><li><strong>M1911手枪</strong></li></ul><p>M1911（45手枪）是一种在1911年起生产的.45 ACP口径半自动手枪，由约翰·勃朗宁设计。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">重量空枪连弹匣：2.437磅（1,105克）[1]</span><br><span class="line">长度8.25吋（210毫米）</span><br><span class="line">枪管长度</span><br><span class="line">政府型：5.03吋（127毫米）</span><br><span class="line">指挥官型：4.25吋（108毫米）</span><br><span class="line">军官ACP型：3.5吋（89毫米）</span><br><span class="line">子弹.45 ACP</span><br><span class="line">枪机枪管短行程后座作用、单动式板机</span><br><span class="line">枪口初速251.46米/秒、〔825英尺/秒〕</span><br><span class="line">有效射程50米</span><br><span class="line">供弹方式7发（标准弹匣），膛室1发</span><br><span class="line">瞄具机械瞄具：金属缺口式照门及准星</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/M1911.png" alt=""></p><p><br></p><ul><li><strong>MAS 1873转轮手枪</strong></li></ul><p>MAS 1873（或称：Chamelot-Delvigne）是法国军队采用的第一种双动式转轮手枪，此枪不久便被更新的M1892转轮手枪所取代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">重量1.04 kg</span><br><span class="line">长度240 mm</span><br><span class="line">枪管长度115 mm</span><br><span class="line">子弹11毫米M1873</span><br><span class="line">口径11 mm</span><br><span class="line">枪机双动式</span><br><span class="line">射速20 - 30发/分钟</span><br><span class="line">最大射程50米</span><br><span class="line">供弹方式6发弹巢</span><br><span class="line">瞄具V型缺口及准星</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/MAS1873.png" alt=""></p><p><br><br><br></p><h3 id="冲锋枪-1"><a href="#冲锋枪-1" class="headerlink" title="冲锋枪"></a>冲锋枪</h3><p><br><br><br></p><h3 id="机枪-1"><a href="#机枪-1" class="headerlink" title="机枪"></a>机枪</h3><ul><li><strong>圣艾蒂安M1907中型机枪</strong></li></ul><p>圣艾蒂安M1907（法语：St. Étienne Mle 1907）是法国军队于第一次世界大战及第二次世界大战期间所装备的一种中型机枪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">重量26公斤</span><br><span class="line">长度1,180毫米</span><br><span class="line">枪管长度710毫米</span><br><span class="line">子弹8×50毫米勒贝尔弹</span><br><span class="line">枪管1根</span><br><span class="line">枪机气动式</span><br><span class="line">射速可调整：8 - 650发/分钟</span><br><span class="line">枪口初速724米/秒</span><br><span class="line">供弹方式25、30发金属弹链</span><br><span class="line">300发布制弹链（1916年）</span><br><span class="line">瞄具机械瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/M1907.png" alt=""></p><p><br></p><ul><li><strong>绍沙轻机枪</strong></li></ul><p>绍沙轻机枪，是在一战（1914年–1918年）时法国军队装备的制式轻机枪。官方名”Fusil Mitrailleur Modele 1915 CSRG”（机关步枪1915年型CSRG）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">重量9.07千克（20.0英磅）</span><br><span class="line">长度1,143毫米（45.0英寸）</span><br><span class="line">枪管长度470毫米（19英寸）</span><br><span class="line">子弹8×50毫米勒贝尔弹</span><br><span class="line">其他</span><br><span class="line">枪机长行程后座作用、气动式、开放式枪机</span><br><span class="line">发射模式半自动、全自动</span><br><span class="line">射速约240发/分钟</span><br><span class="line">枪口初速630米/秒</span><br><span class="line">有效射程200米</span><br><span class="line">最大射程2,000米</span><br><span class="line">供弹方式20发弹匣</span><br><span class="line">瞄具机械瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/CSRG1915.png" alt=""></p><p><br></p><ul><li><strong>刘易斯机枪</strong></li></ul><p>刘易斯机枪（Lewis Gun）由美国陆军上校艾萨克·牛顿·刘易斯发明，但美国陆军并未采用，而是在英国发扬光大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">重量12公斤（空枪）</span><br><span class="line">长度1,125 mm</span><br><span class="line">枪管长度660 mm</span><br><span class="line">子弹.303英式弹</span><br><span class="line">口径7.7 mm</span><br><span class="line">枪机气动式、开放式枪机</span><br><span class="line">发射模式半自动、全自动</span><br><span class="line">射速500 - 600发/分钟</span><br><span class="line">枪口初速747米/秒</span><br><span class="line">有效射程800 m</span><br><span class="line">最大射程3,200 m</span><br><span class="line">供弹方式47发、97发弹鼓</span><br><span class="line">瞄具刀片式瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/LewisGun.png" alt=""></p><p><br></p><ul><li><strong>霍奇克斯M1914重机枪</strong></li></ul><p>霍奇克斯M1914重机枪（法语：Hotchkiss Mle 1914）由美国人班杰明·霍奇克斯所开设的霍奇克斯公司研发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">重量24.4公斤</span><br><span class="line">46.8公斤（连三脚架）</span><br><span class="line">长度1,390毫米</span><br><span class="line">枪管长度800毫米</span><br><span class="line">子弹8×50毫米勒贝尔子弹</span><br><span class="line">7×57毫米毛瑟子弹</span><br><span class="line">6.5×50毫米有坂子弹</span><br><span class="line">11毫米Gras子弹</span><br><span class="line">6.5×55毫米</span><br><span class="line">枪机导气式</span><br><span class="line">射速450发/分钟</span><br><span class="line">枪口初速724米/秒</span><br><span class="line">供弹方式24发保弹板</span><br><span class="line">250发铰接式弹链</span><br><span class="line">瞄具机械瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/M1914.png" alt=""></p><p><br><br><br></p><h3 id="步枪-1"><a href="#步枪-1" class="headerlink" title="步枪"></a>步枪</h3><ul><li><strong>M1917RSC半自动步枪</strong></li></ul><p>M1917式RSC半自动步枪（法语：Fusil Automatique Modèle 1917，别名RSC M1917）是一种半自动气动式军用步枪，于第一次世界大战末期（1918年）装备法国军队。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">重量5,25公斤（11,6磅）</span><br><span class="line">长度1331毫米（52,4英寸）</span><br><span class="line">枪管长度798毫米（31,4英寸）</span><br><span class="line">子弹8×50mm勒贝尔弹</span><br><span class="line">枪机长行程导气式活塞，滚转式枪机</span><br><span class="line">枪口初速701米/秒</span><br><span class="line">有效射程标尺最低射程250米，最大有效1200米</span><br><span class="line">供弹方式5发内装漏夹供弹</span><br><span class="line">瞄具铁质标尺，标尺直立射程2400米</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/M1917RSC.png" alt=""></p><p><br></p><ul><li><strong>Mle 1918 全自动卡宾枪</strong></li></ul><p>Mle 1918 利贝罗勒全自动卡宾枪（英语：Ribeyrolles 1918 automatic carbine ，法语：Carabine Mitrailleuse 1918）是法国的一款自动步枪，亦是世界首型应用突击步枪概念的枪械。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">重量5.1公斤（空枪）</span><br><span class="line">长度1090毫米</span><br><span class="line">枪管长度450毫米</span><br><span class="line">子弹8 × 35 毫米利贝罗勒弹</span><br><span class="line">口径8 毫米</span><br><span class="line">枪机直接反冲</span><br><span class="line">射速550~600发/分钟</span><br><span class="line">枪口初速570 米/秒</span><br><span class="line">有效射程400 米</span><br><span class="line">供弹方式25 发弹匣</span><br><span class="line">瞄具机械瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Mle1918.jpg" alt=""></p><p><br></p><ul><li><strong>勒贝尔M1886步枪</strong></li></ul><p>勒贝尔M1886（法语：Fusil Lebel Modèle 1886）或勒贝尔步枪（法语：Fusil Lebel）是法国于1886年推出的栓式步枪，由尼古拉斯·勒贝尔上校研制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">重量4.41 kg（上弹）</span><br><span class="line">4.18 kg（空枪）</span><br><span class="line">长度130 cm</span><br><span class="line">枪管长度80 cm</span><br><span class="line">子弹8×50毫米勒贝尔弹</span><br><span class="line">口径8 mm</span><br><span class="line">枪机旋转后拉式枪机</span><br><span class="line">枪口初速610 - 700米/秒</span><br><span class="line">有效射程400米</span><br><span class="line">最大射程1,800米</span><br><span class="line">供弹方式8发管状弹仓（若算上托弹板上和膛室内的额外两发子弹为10发）</span><br><span class="line">瞄具机械瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/M1886.png" alt=""></p><p><br></p><ul><li><strong>温彻斯特1907型半自动步枪</strong></li></ul><p>温彻斯特1907型是由美国枪械设计师托马斯·克罗斯利.约翰逊设计的一种半自动步枪，它在1906年到1958年期间由温彻斯特连发武器公司生产。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">重量3.6 kg - 4.1 kg</span><br><span class="line">长度1,000 mm</span><br><span class="line">枪管长度510 mm</span><br><span class="line">子弹.351 Winchester Self-Loading</span><br><span class="line">口径.351</span><br><span class="line">枪机后座作用</span><br><span class="line">供弹方式5 发、10 发弹匣</span><br><span class="line">瞄具机械瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Winchester1907.png" alt=""></p><p><br></p><ul><li><strong>双管霰弹枪</strong></li></ul><p>双管霰弹枪（英语：Double-barreled shotgun，或称双管猎枪），是一种有两根枪管的猎枪，可分为水平排列或上下排列，可算是最早期的猎枪之一，前身为镇暴枪。</p><p><img src="/images/Weapons/Double-barreled_shotgun.png" alt=""></p><p><br><br><br></p><h3 id="炮"><a href="#炮" class="headerlink" title="炮"></a>炮</h3><ul><li><strong>皮托SA-18坦克炮</strong></li></ul><p>皮托SA-18坦克炮是法国在一战期间由设计的一种战车炮，主要装备于雷诺FT-17坦克上。</p><p><img src="/images/Weapons/SA18.png" alt=""></p><p><br><br><br></p><h3 id="坦克-1"><a href="#坦克-1" class="headerlink" title="坦克"></a>坦克</h3><ul><li><strong>2C超级重战车</strong></li></ul><p>2C超重型坦克，又名Char 2C，是法国于一战时设计的超重型坦克。但是，它并没有参加一战。不过，这辆坦克是所有被正式量产的坦克中吨位第二大的，仅次于猎虎式驱逐战车。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">重量69 t（68 long ton；76 short ton）</span><br><span class="line">长度10.27米（33英尺8英寸）</span><br><span class="line">宽度3米（9英尺10英寸）</span><br><span class="line">高度4.09米（13英尺5英寸）</span><br><span class="line">操作人数11人[注 1]</span><br><span class="line">装甲45 mm（1.8英寸） max.</span><br><span class="line">主武器75 mm 火炮</span><br><span class="line">副武器4挺8 mm 机枪 (有一门在后炮塔上)</span><br><span class="line">发动机双引擎</span><br><span class="line">        2 x 250 马力</span><br><span class="line">作战范围150 km（93 mi）</span><br><span class="line">速度15 km/h（9.3 mph）</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/2C.png" alt=""></p><p><br></p><ul><li><strong>施耐德CA1坦克</strong></li></ul><p>施耐德CA1坦克（法语：Char Schneider CA1）是法国研制的第一种坦克，研发的主要目的是破坏战场上的铁丝网。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">重量13.6 吨</span><br><span class="line">长度6.32 米</span><br><span class="line">宽度2.05 米</span><br><span class="line">高度2.30 米</span><br><span class="line">操作人数6人</span><br><span class="line">装甲5.5-11毫米钢板</span><br><span class="line">主武器施耐德75mm迫击炮</span><br><span class="line">副武器2门8mm霍奇基斯M1914机枪</span><br><span class="line">发动机施耐德4缸55hp汽油引擎</span><br><span class="line">悬挂弹簧</span><br><span class="line">作战范围45 公里</span><br><span class="line">速度8.1 公里／小时</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/CA1.png" alt=""></p><p><br></p><ul><li><strong>雷诺FT-17坦克</strong></li></ul><p>雷诺FT-17，是一款法国轻型坦克。它于一战时由法国研发，是世界上第一款安装旋转炮塔的坦克。截至一战结束时，一共生产了3187辆。甚至在二战爆发时，还有1800辆FT-17坦克在法国军队中服役。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">重量7吨</span><br><span class="line">长度5米</span><br><span class="line">宽度1.74米</span><br><span class="line">高度2.14米</span><br><span class="line">操作人数2（车长及驾驶员）</span><br><span class="line">装甲6-22毫米</span><br><span class="line">主武器皮托SA-18 37mmL/21战车炮</span><br><span class="line">或8mm哈奇开斯M1914机枪</span><br><span class="line">发动机雷诺直立式4缸水冷汽油机</span><br><span class="line">35匹</span><br><span class="line">功率/重量6马力/吨</span><br><span class="line">变速机械式（4前进档，1倒车档）</span><br><span class="line">悬挂垂直弹簧</span><br><span class="line">作战范围35公里</span><br><span class="line">速度7.7公里/时</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/FT-17.png" alt=""></p><p><br><br><br></p><h3 id="飞机-1"><a href="#飞机-1" class="headerlink" title="飞机"></a>飞机</h3><ul><li><strong>纽波特战斗机</strong></li></ul><p>纽波特11战斗机是法国在第一次世界大战早期推出的双翼战斗机，因其机体细小而被称为“婴儿”，它是由纽波特飞机公司研制的，成立于1902年的纽波特飞机公司由1909年开始造飞机，该公司由纽波特兄弟创立但两兄弟后来都在飞行事故当中死去，公司由他人接手，而在推出纽波特11战斗机后该公司才在航空界打响名堂并开创了“纽波特皇朝”。</p><p><img src="/images/Weapons/NBT11.png" alt=""></p><p><img src="/images/Weapons/NBT17.png" alt=""></p><p><img src="/images/Weapons/NBT28.png" alt=""></p><p><br></p><ul><li><em>莫兰-索尼耶L单翼机**</em></li></ul><p>莫兰-索尼耶L单翼机是法国莫兰-索尼耶飞机公司在1913年研制的单翼多用途飞机，该型机在当年12月的就在巴黎的航空展览上公开，在第一次世界大战爆发后就成为法国空军的侦察机，也是第一种在螺旋桨上加上钢铁制子弹偏导片而实现机枪安装在机头并开火，估计这样有大约1/4的子弹会被它挡住不伤到螺旋桨，其余3/4可穿过螺旋桨射击目标，此种做法是在同步射击系统出现前唯一的可行办法。<br>莫兰-索尼耶L单翼机也因此被称为“历史上第一种战斗机”。</p><p><img src="/images/Weapons/MS-L.png" alt=""></p><p><br><br><br></p><hr><p><br></p><h2 id="俄国"><a href="#俄国" class="headerlink" title="俄国"></a>俄国</h2><ul><li><strong>M1911手枪</strong></li></ul><p><br></p><ul><li><strong>毛瑟C96手枪</strong></li></ul><p><br></p><ul><li><strong>纳甘M1895转轮手枪</strong></li></ul><p>纳甘M1895（俄语：Револьвер системы Нагана，意为：纳甘系统转轮手枪）是由比利时工业家莱昂·纳甘为俄罗斯帝国所研发的7发双动式转轮手枪，发射7.62×38mmR弹药。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">重量0.8 kg（空枪）</span><br><span class="line">长度235 mm</span><br><span class="line">枪管长度114 mm</span><br><span class="line">子弹7.62×38mmR</span><br><span class="line">口径7.62 mm</span><br><span class="line">枪机单动式、双动式</span><br><span class="line">射速14 - 21发/分钟</span><br><span class="line">枪口初速272米/秒</span><br><span class="line">有效射程22米</span><br><span class="line">供弹方式7发转轮式弹巢</span><br><span class="line">瞄具V型照门及准星</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/M1895.png" alt=""></p><p><br></p><ul><li><strong>三八式步枪</strong></li></ul><p>三八式步枪（日语：三八式歩兵銃；さんぱちしきほへいじゅう，Sanpachi-shiki hohei-juu）为手动步枪，日本陆军于日俄战争同年（1905年，明治38年）正式采用为制式武器，一直到第二次世界大战。三八式步枪在中国一向俗称为三八大盖，由于其枪机上有一个随枪机连动的防尘盖以及机匣上刻有“三八式”字样而得名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">重量3,730g（加上刺刀重4,100g）</span><br><span class="line">长度127.6cm（上刺刀可达166.3cm）</span><br><span class="line">枪管长度797毫米</span><br><span class="line">子弹6.5×50mm有阪（Arisaka）</span><br><span class="line">口径6.5毫米</span><br><span class="line">枪机旋转后拉式枪机</span><br><span class="line">枪口初速765米／秒</span><br><span class="line">有效射程460米</span><br><span class="line">供弹方式5发弹匣，内置弹仓</span><br><span class="line">瞄具铁制直立式表尺</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/38shi.png" alt=""></p><p><br></p><ul><li><strong>温彻斯特步枪</strong></li></ul><p>温彻斯特步枪（Winchester Rifle），有时亦称温彻斯特连发步枪（Winchester Repeating Rifle），是由美国温彻斯特连发武器公司研制及生产的一系列步枪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">重量4.3 kg</span><br><span class="line">长度125.2 cm</span><br><span class="line">枪管长度76.2 cm</span><br><span class="line">子弹.44-40温彻斯特</span><br><span class="line">.38-40温彻斯特</span><br><span class="line">.32-20温彻斯特</span><br><span class="line">.30-30温彻斯特</span><br><span class="line">.22 LR</span><br><span class="line">其他</span><br><span class="line">枪机杠杆式</span><br><span class="line">供弹方式8（M1894）、10（M1866）、13（M1866）、15发内置管状弹仓</span><br><span class="line">瞄具后方缺口及前准星</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/WinchesterRifle.png" alt=""></p><p><br></p><ul><li><strong>莫辛-纳甘步枪</strong></li></ul><p>莫辛-纳甘（法文：Mosin-Nagant）步枪是由设计者俄国陆军上校谢尔盖·伊凡诺维奇·莫辛和比利时枪械设计师李昂·纳甘共同命名的手动步枪，在俄语圈国家也被普遍的称为莫辛步枪 （俄文：Винтовка Мосина），官方名称为”三线M1891步枪”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">重量4.22公斤（空枪），各型号不同</span><br><span class="line">长度1306毫米，各型号不同</span><br><span class="line">枪管长度800毫米，各型号不同</span><br><span class="line">子弹7.62×54毫米R枪弹</span><br><span class="line">口径7.62毫米</span><br><span class="line">枪机旋转后拉式枪机</span><br><span class="line">枪口初速615米/秒（M1891）</span><br><span class="line">860米/秒（M1891/30）</span><br><span class="line">有效射程548.64米（600码）</span><br><span class="line">最大射程1828.8米（2000码）</span><br><span class="line">供弹方式5发内置弹仓</span><br><span class="line">10发可拆式弹匣（现代化改版限定）</span><br><span class="line">瞄具机械瞄具：后方可调式缺口表尺及前方柱状准星</span><br><span class="line">PU 3.5倍光学瞄准镜</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/MosinNagant.png" alt=""></p><p><br></p><ul><li><strong>费德洛夫M1916自动步枪</strong></li></ul><p>费德洛夫M1916 （俄语：Автомат Фёдорова）是一种战斗步枪，由弗拉基米尔·格里高利耶维奇·费德洛夫（Vladimir Grigoryevich Fyodorov）设计，1916年在沙俄境内生产。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">重量4.4公斤 (全重：5.2公斤)</span><br><span class="line">长度1,045毫米</span><br><span class="line">枪管长度520 毫米</span><br><span class="line">子弹6.5×50毫米有坂子弹</span><br><span class="line">口径6.5毫米</span><br><span class="line">枪机枪管短行程后座作用</span><br><span class="line">发射模式半自动、全自动</span><br><span class="line">射速600发/分钟[1]</span><br><span class="line">枪口初速654米每秒（2,150英尺每秒）[1]</span><br><span class="line">供弹方式25发可拆卸式弹匣</span><br><span class="line">瞄具机械瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/FyodorovM1916.png" alt=""></p><p><br></p><ul><li><strong>绍沙轻机枪</strong></li></ul><p><br></p><ul><li><strong>麦德森轻机枪</strong></li></ul><p><br></p><ul><li><strong>刘易斯机枪</strong></li></ul><p><br></p><ul><li><strong>维克斯机枪</strong></li></ul><p>维克斯机枪（Vickers），是第一次世界大战与第二次世界大战期间英国军队所使用的中型机枪。基于维克斯机枪优异的设计，使它成为世界上著名的战争武器之一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">重量15 kg</span><br><span class="line">长度1,100 mm</span><br><span class="line">枪管长度720 mm</span><br><span class="line">操作人数3人</span><br><span class="line">子弹.303英式弹</span><br><span class="line">口径7.7毫米</span><br><span class="line">枪机后坐式，水冷却</span><br><span class="line">射速450 - 500发/分钟</span><br><span class="line">枪口初速744米/秒</span><br><span class="line">有效射程2,000米</span><br><span class="line">最大射程4,100米</span><br><span class="line">供弹方式250发布制弹链</span><br><span class="line">瞄具机械瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Vickers.png" alt=""></p><p><br></p><ul><li><strong>马克沁M1910重机枪</strong></li></ul><p>马克沁M1910重机枪（Пулемёт Максима на станке Соколова）又名PM M1910马克沁，是海勒姆·马克沁开发的马克沁机枪之衍生型，发射7.62×54毫米R弹药，配有轮式射架。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">重量64.3公斤（139.6磅）</span><br><span class="line">长度1067毫米</span><br><span class="line">枪管长度721毫米</span><br><span class="line">子弹7.62×54毫米R</span><br><span class="line">口径7.62毫米</span><br><span class="line">枪机后座作用</span><br><span class="line">射速600发/分</span><br><span class="line">枪口初速740米/秒（2,427.2尺/秒）</span><br><span class="line">供弹方式250发布制弹链</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/PM_M1910.png" alt=""></p><p><br><br><br></p><hr><p><br></p><h2 id="英国"><a href="#英国" class="headerlink" title="英国"></a>英国</h2><ul><li><strong>M1911手槍</strong></li></ul><p><br></p><ul><li><strong>毛瑟C96手槍</strong></li></ul><p><br></p><ul><li><strong>M1917左轮手枪</strong></li></ul><p>M1917左轮手枪（M1917 Revolver），官方正式名称为M1917 .45英寸美国左轮手枪（英语：United States Revolver, Caliber .45, M1917）是一把美国六发式左轮手枪，主要发射.45 ACP口径手枪子弹。</p><p><img src="/images/Weapons/M1917Revolver.png" alt=""></p><p><br></p><ul><li><strong>史密斯威森军警型左轮手枪</strong></li></ul><p>史密斯威森军警型（Smith &amp; Wesson Military &amp; Police，缩写：S&amp;W MP；简称：点三八），是一种.38口径的美国制左轮手枪。</p><p><img src="/images/Weapons/SW_MP.png" alt=""></p><p><br></p><ul><li><strong>韦伯利转轮手枪</strong></li></ul><p>韦伯利转轮手枪（英语：Webley Revolver）是由英国生产的一系列军用和警用转轮手枪。当中最著名的版本为韦伯利MK VI， 它在一次大战期间成为了英国军队以及其殖民地军队的制式手枪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">重量1.1公斤（空枪）</span><br><span class="line">长度286毫米</span><br><span class="line">枪管长度106毫米</span><br><span class="line">子弹.455韦伯利</span><br><span class="line">.38/200</span><br><span class="line">口径.455英寸（11.6×19毫米）、.38英寸</span><br><span class="line">枪机单/双动式板机</span><br><span class="line">射速20-30发/分钟</span><br><span class="line">枪口初速190米/秒</span><br><span class="line">有效射程50码</span><br><span class="line">供弹方式6发弹巢</span><br><span class="line">瞄具缺口式机械瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/MK_VI.png" alt=""></p><p><br></p><ul><li><p><strong>三八步枪</strong></p></li><li><p><strong>温彻斯特步枪</strong></p></li></ul><p><br></p><ul><li><strong>恩菲尔德M1917步枪</strong></li></ul><p>恩菲尔德M1917步枪（M1917 Enfield，又名P17、P1917或Pattern 1917）是“美国恩菲尔德”（American Enfield）于1917至1918年间生产的.30-06口径手动步枪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">重量4.17 公斤（9磅3安士）</span><br><span class="line">长度1175 毫米（3尺10.25寸）</span><br><span class="line">枪管长度26 寸（660毫米）</span><br><span class="line">子弹.30-06（7.62 x 63毫米）</span><br><span class="line">枪机旋转后拉式枪机</span><br><span class="line">枪口初速823 米/秒（2700尺/秒）</span><br><span class="line">供弹方式5发弹夹、6发内置弹仓</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/M1917_Enfield.jpg" alt=""></p><p><br></p><ul><li><strong>李-恩菲尔德步枪</strong></li></ul><p>李-恩菲尔德步枪（Lee-Enfield）也译李恩飞步枪是1895年至1956年英军的制式手动步枪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">重量4.19公斤（MLE Mk.I）</span><br><span class="line">3.96公斤（SMLE No.1 Mk.III）</span><br><span class="line">长度1257毫米（MLE Mk.I）</span><br><span class="line">        1138毫米（SMLE No.1 Mk.III）</span><br><span class="line">        1130毫米（No.4 Mk.I）</span><br><span class="line">枪管长度767毫米（MLE Mk.I）</span><br><span class="line">        640毫米（SMLE No.1 Mk.III）</span><br><span class="line">子弹.303 British（7.7×56mm R）</span><br><span class="line">        7.92×57毫米尖头弹(为适应中国战场所改膛的)</span><br><span class="line">枪机旋转后拉式枪机</span><br><span class="line">枪口初速744米／秒</span><br><span class="line">有效射程914米（1000码）</span><br><span class="line">最大射程1828米（2000码）</span><br><span class="line">供弹方式10发内置弹仓（两个5发弹夹）</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Lee-Enfield.png" alt=""></p><p><br></p><ul><li><strong>马提尼-亨利步枪</strong></li></ul><p>马提尼-亨利”（Martini-Henry）是一种英国陆军曾经装备的起落式枪机步枪。它于1871年首度投入服役，最终取代了原有的史奈德步枪，一款改良至发射定装弹的前装枪。马提尼-亨利的衍生型在大英帝国中一共服役了三十年。它采用了由亨利·O·皮博迪为其皮博迪步枪设计的起落式枪机，并由瑞士设计师里德里希·冯·马提尼进行改良，结合由苏格兰人亚历山大·亨利设计的多边形膛线。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">重量3.827 kg（空枪）</span><br><span class="line">长度1245 mm</span><br><span class="line">子弹.577/450 Boxer-Henry</span><br><span class="line">        .577/450马提尼-亨利</span><br><span class="line">        .303英式弹</span><br><span class="line">        11.43×55R（奥斯曼帝国）</span><br><span class="line">        11.43×59R（罗马尼亚）</span><br><span class="line">        7.65×53毫米（奥斯曼帝国）</span><br><span class="line">枪机起落式枪机（Martini Falling Block）</span><br><span class="line">射速12发/分钟</span><br><span class="line">枪口初速400米/秒</span><br><span class="line">有效射程370米</span><br><span class="line">最大射程1,700米</span><br><span class="line">供弹方式1发装在膛室内</span><br><span class="line">瞄具可滑动式表尺及准星</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Martini-Henry.png" alt=""></p><p><br></p><ul><li><p><strong>维克斯机枪</strong></p></li><li><p><strong>刘易斯机枪</strong></p></li><li><p><strong>马克沁机枪</strong></p></li><li><p><strong>双管霰弹枪</strong></p></li></ul><p><br></p><ul><li><strong>勃朗宁M1917重机枪</strong></li></ul><p>M1917重机枪是由约翰·勃朗宁设计，美军在一战，二战及韩战中采用的重机枪，并有限延伸至越战，同时它也被其他国家使用。这是一种班组操作，弹链供弹的水冷重机枪，与同时期的M1919风冷中型机枪共同服役。该型机枪以营为单位配发同时也经常装备于各种载具之上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">重量47公斤</span><br><span class="line">长度980毫米</span><br><span class="line">枪管长度609毫米</span><br><span class="line">子弹.30-06春田</span><br><span class="line">口径7.62毫米</span><br><span class="line">枪机短行程后座作用式</span><br><span class="line">射速450发/分钟</span><br><span class="line">        600发/分钟（M1917A1）</span><br><span class="line">枪口初速853.6米/秒</span><br><span class="line">最大射程900米</span><br><span class="line">供弹方式250发布制弹链</span><br><span class="line">瞄具机械瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Browning_M1917.png" alt=""></p><p><br></p><ul><li><strong>Template:V及W級驱逐舰</strong></li></ul><p><br></p><ul><li><strong>步行者号驱逐舰</strong></li></ul><p>步行者号驱逐舰（舷号D27）是一艘英国皇家海军建造的驱逐舰，为W级驱逐舰的3号舰。她是英军第一艘以步行者（Walker）为名的军舰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">标准排水量设计：1,100吨</span><br><span class="line">全长整体：300呎</span><br><span class="line">全宽水线：26.75呎</span><br><span class="line">吃水9呎</span><br><span class="line">最高速度34节</span><br><span class="line">武器装备4门4吋Mk V速射炮</span><br><span class="line">        2门单装2磅砰砰炮</span><br><span class="line">        2座3联装鱼雷发射管</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Walker_D27.jpg" alt=""></p><p><br></p><ul><li><strong>范诺克号驱逐舰</strong></li></ul><p>范诺克号驱逐舰（舷号H33）是一艘英国皇家海军建造的驱逐舰，为V级驱逐舰的1号舰。她是英军第一艘以范诺克（Vanoc）为名的军舰，舰名取自圆桌骑士团的范诺克骑士。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">标准排水量设计：1,272吨至1,339吨</span><br><span class="line">全长整体：300呎</span><br><span class="line">全宽水线：26呎9吋</span><br><span class="line">吃水9呎</span><br><span class="line">最高速度34节</span><br><span class="line">武器装备4门4吋Mk V速射炮</span><br><span class="line">        2门单装2磅砰砰炮</span><br><span class="line">        2座双联装鱼雷发射管</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Vanoc_H33.png" alt=""></p><p><br></p><ul><li><strong>Mark I 坦克</strong></li></ul><p>Mark I 坦克由英国研制并在第一次世界大战于英国军队服役，是世界上第一种正式参与战争的坦克。[1] Mark I 坦克在1916年8月开始服役，并于1916年9月15日首次应用在索姆河战役上。它的主要作用是破坏战场上的铁丝网、越过战壕、亦能抵御小型武器的射击。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">重量雄性：28.4公吨（28.0长吨）</span><br><span class="line">雌性：27.4公吨（27.0长吨）</span><br><span class="line">长度9.94米（32英尺7英寸）</span><br><span class="line">宽度4.33米（14英尺2英寸）</span><br><span class="line">高度2.44米（8英尺0英寸）</span><br><span class="line">操作人数8人</span><br><span class="line">装甲6-12 毫米</span><br><span class="line">主武器雄性：2 × 霍奇基斯QF 6磅炮</span><br><span class="line">        雌性：4 × 维克斯机枪</span><br><span class="line">副武器雄性：3 × 霍奇基斯轻机枪</span><br><span class="line">        雌性：1 × 霍奇基斯轻机枪</span><br><span class="line">发动机戴姆勒-奈特6缸 13升 汽油引擎</span><br><span class="line">        105匹马力（78千瓦特）</span><br><span class="line">功率/重量雄性：3.7匹马力每公吨（2.8千瓦每公吨）</span><br><span class="line">        雌性：4.0匹马力每公吨（3.0千瓦每公吨）</span><br><span class="line">悬挂履带</span><br><span class="line">作战范围23.6英里（38.0千米），巡航6.2小时</span><br><span class="line">速度5.9千米每小时（3.7英里每小时）</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Mark-I.png" alt=""></p><p><br><br><br></p><hr><p><br></p><h2 id="美国"><a href="#美国" class="headerlink" title="美国"></a>美国</h2><ul><li><strong>Mk 2手榴弹</strong></li></ul><p>Mk 2手榴弹（或写作Mk II）是一种反人员破片手榴弹，美军于1918年导入，用以取代Mk 1手榴弹，在二战、韩战至越战中所使用。由于外型相似凤梨又名凤梨手榴弹，因保险片的形状被称为“鸭嘴手榴弹”，因外观被称为“卵形手榴弹”、“凤梨手榴弹”或“癞瓜手榴弹”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重量595克</span><br><span class="line">长度111毫米</span><br><span class="line">填充TNT</span><br><span class="line">填充量2安士</span><br><span class="line">引爆机制4-5秒</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/MK2.png" alt=""></p><p><br></p><ul><li><p><strong>M1911手枪</strong></p></li><li><p><strong>M1917左轮手枪</strong></p></li><li><p><strong>史密斯威森军警型左轮手枪</strong></p></li></ul><p><br></p><ul><li><p><strong>恩菲尔德M1917步枪</strong></p></li><li><p><strong>李-恩菲尔德步枪</strong></p></li><li><p><strong>温彻斯特步枪</strong></p></li><li><p><strong>温彻斯特1907型半自动步枪</strong></p></li><li><p><strong>莫辛-纳甘步枪</strong></p></li></ul><p><br></p><ul><li><strong>M1903春田步枪</strong></li></ul><p>M1903春田步枪是一种旋转后拉式枪机弹仓式手动步枪，1903年定型称为“0.30口径M1903式步枪”，因其由春田（Springfield）兵工厂研制而得名M1903春田步枪（Springfield rifle）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">重量3.95公斤</span><br><span class="line">长度1,098毫米（44.9寸）</span><br><span class="line">枪管长度610毫米（24寸）</span><br><span class="line">子弹.30-03</span><br><span class="line">       .30-06（7.62×63毫米）</span><br><span class="line">        7.92×57毫米尖头弹(为适应中国与欧洲战场所改膛的)</span><br><span class="line">枪机旋转后拉式枪机</span><br><span class="line">枪口初速823 - 853米／秒</span><br><span class="line">有效射程550米</span><br><span class="line">供弹方式5发弹夹，内置弹仓</span><br><span class="line">瞄具片状准星；带&quot;U&quot;形缺口折叠式框形表尺</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/SpringField_M1903.png" alt=""></p><p><br></p><ul><li><strong>温彻斯特M1897泵动式霰弹枪</strong></li></ul><p>温彻斯特M1897（英语：Winchester Model (M) 1897，俗称：Model 97或M97）是一枝由著名的美国枪械设计师约翰·勃朗宁设计、美国温彻斯特连发武器公司生产的泵动式及外置击锤型设计霰弹枪。</p><p><img src="/images/Weapons/Winchester_M1897.png" alt=""></p><p><br></p><ul><li><strong>温彻斯特M1912泵动式霰弹枪</strong></li></ul><p>温彻斯特M1912（英语：Winchester Model（M） 1912，俗称：Model 12或M12）是一枝由美国温彻斯特连发武器公司生产的泵动式、内置式击锤设计及外部管式弹仓供弹的霰弹枪。此枪在推出后不久被流行地命名为完美的连发枪（英语：Perfect Repeater），基本奠定了此枪对泵动霰弹枪超过51年的高效率生产的生涯的标准。</p><p><img src="/images/Weapons/Winchester_M1912.png" alt=""></p><p><br></p><ul><li><strong>勃朗宁Auto-5半自动霰彈槍</strong></li></ul><p>勃朗宁Auto-5（英语：Browning Automatic 5，简称：Auto-5、A-5，意为：勃朗宁自动五发式霰弹枪）是一枝由美国著名轻兵器设计家约翰·勃朗宁所研制、后座作用操作的半自动霰弹枪，可发射12铅径霰弹、16铅径霰弹或20铅径霰弹。</p><p><img src="/images/Weapons/Auto-5.png" alt=""></p><p><br></p><ul><li><strong>勃朗宁自动步枪</strong></li></ul><p>勃朗宁自动步枪（英语：Browning Automatic Rifle，简称：BAR），是美军在20世纪上半叶使用的一种自动步枪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">重量空枪重：7.2公斤（A1）</span><br><span class="line">空枪重：8.8公斤（A2）</span><br><span class="line">长度1,214毫米（47.8寸）</span><br><span class="line">枪管长度610毫米（24寸）</span><br><span class="line">子弹.30-06 Springfield </span><br><span class="line">       （7.62×63毫米）</span><br><span class="line">        7.92×57毫米尖头弹(为适应中国战场所改膛的)</span><br><span class="line">口径7.62毫米（.30寸）</span><br><span class="line">枪机长行程导气式活塞、开放式枪机</span><br><span class="line">发射模式半自动、全自动</span><br><span class="line">射速300-450发/分；</span><br><span class="line">        500-650发/分（A2）</span><br><span class="line">枪口初速805米/秒</span><br><span class="line">有效射程548米</span><br><span class="line">供弹方式20发弹匣</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/BAR.png" alt=""></p><p><br></p><ul><li><p><strong>刘易斯机枪</strong></p></li><li><p><strong>勃朗宁机枪</strong></p></li><li><p><strong>绍沙轻机枪</strong></p></li><li><p><strong>霍奇科斯重机枪</strong></p></li></ul><p><br></p><ul><li><strong>勃朗宁M1919中型机枪</strong></li></ul><p>勃朗宁M1919（M1919 Browning machine gun），俗称（Browning Machine Gun，30 Cal ），是由约翰·勃朗宁在一战后设计的机枪，主要是把水冷式M1917改为风冷式，采用.30-06 Springfield 步枪弹药。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">重量14公斤</span><br><span class="line">长度964毫米（37.94英寸）</span><br><span class="line">操作人数2至3名</span><br><span class="line">子弹.30-06 Springfield（U.S.）</span><br><span class="line">        7.62×51mm NATO（U.S.）</span><br><span class="line">        .303 British</span><br><span class="line">口径7.62毫米/7.7毫米</span><br><span class="line">枪机后坐作用</span><br><span class="line">射速400–600发／分</span><br><span class="line">枪口初速853米／秒</span><br><span class="line">有效射程1,400米</span><br><span class="line">供弹方式M9弹链供弹</span><br><span class="line">瞄具可调机械照门</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Browning_M1919.png" alt=""></p><p><br></p><ul><li><strong>D级潜艇</strong></li></ul><p>D级潜艇是美国海军一战中建造的潜艇级，子合约由格罗昆的电船公司签订，由昆西的佛尔河船厂建造。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">舰型Submarine</span><br><span class="line">排水量288 long ton（293 t） surfaced</span><br><span class="line">        337 long ton（342 t） submerged</span><br><span class="line">全长134英尺10英寸（41.10米）</span><br><span class="line">全宽13英尺11英寸（4.24米）</span><br><span class="line">吃水11英尺8英寸（3.56米）</span><br><span class="line">动力来源2 x NELSECO gasoline engines, 600 hp（450 kW） total[1]</span><br><span class="line">        2 x electric motors, 260 hp（190 kW） total</span><br><span class="line">        2 x 60-cell batteries</span><br><span class="line">        2 shafts</span><br><span class="line">速度12节（22千米每小时；14英里每小时） surfaced, 9.5节（17.6千米每小时；10.9英里每小时） submerged</span><br><span class="line">续航距离1,240海里（2,300千米；1,430英里） (surfaced)</span><br><span class="line">潜航深度200英尺（61米）</span><br><span class="line">乘员15 officers and men</span><br><span class="line">武器装备4 × 18 inch (457 mm) bow torpedo tubes, (4 torpedoes)[3]</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/USS_D1.png" alt=""></p><p><br></p><ul><li><strong>美国一战驱逐舰</strong></li></ul><p>维基百科： <a href="https://zh.wikipedia.org/wiki/Category:%E7%BE%8E%E5%9B%BD%E4%B8%80%E6%88%98%E9%A9%B1%E9%80%90%E8%88%B0" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Category:%E7%BE%8E%E5%9B%BD%E4%B8%80%E6%88%98%E9%A9%B1%E9%80%90%E8%88%B0</a></p><p>驱逐舰（英语：destroyer）是一种多用途的军舰。驱逐舰的用途是保护舰队，驱逐和消灭鱼雷艇和潜艇等以鱼雷为主要武器的舰只，为舰队提供保护。</p><p><br><br><br></p><hr><p><br></p><h2 id="化学武器"><a href="#化学武器" class="headerlink" title="化学武器"></a>化学武器</h2><ul><li><strong>三氯硝基甲烷</strong></li></ul><p>三氯硝基甲烷，俗称氯化苦（英语：Chloropicrin），是一种化学式为Cl3CNO2的有机氯化合物。这种高毒性的物质曾被用作代号为PS的化学武器；现在则主要用作熏蒸剂和杀线虫剂。</p><p><br></p><ul><li><strong>二氯甲基胂</strong></li></ul><p>二氯甲基胂，亦可简写为MD，是一种有机化合物，化学式为CH3AsCl2。它是一种无色、易挥发的液体，具有很强的毒性，是一种糜烂性毒剂，可作为化学武器使用。</p><p><br></p><ul><li><strong>氯丙酮</strong></li></ul><p>氯丙酮，结构式ClCH2COCH3。无色有极强刺激性臭味液体，对生物体有强刺激性，在日光下分解产生强催泪性气体。见光变为暗黄的琥珀色。</p><p><br></p><ul><li><strong>溴乙酸乙酯</strong></li></ul><p>溴乙酸乙酯是一种有机化合物，化学式为CH2BrCO2C2H5。它可由乙酸为原料合成。它是一种催泪剂，具有果味和刺激性气味。它是毒性很高的烷基化试剂。吸入、吞咽或与皮肤接触可能致命。</p><p><br></p><ul><li><strong>绿十字毒气</strong></li></ul><p>绿十字毒气（德语：Grünkreuz)是在第一次世界大战时使用的化学武器，属于窒息性毒剂，是由三氯硝基甲烷，光气或/和双光气的混合物。</p><p><br></p><ul><li><strong>芥子毒气</strong></li></ul><p>芥子毒气（英语：mustard gas），亦简称为芥子气，学名二氯二乙硫醚，是一种重要的糜烂性毒剂，因味道与芥末相似而得名。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="二战"><a href="#二战" class="headerlink" title="二战"></a>二战</h1><p>第二次世界大战（又简称二次大战、二战、WWII等；英语：World War II；法语：Seconde Guerre mondiale；德语：Zweiter Weltkrieg；俄语：Вторая мировая война；日语：第二次世界大戰）是一次自1939年至1945年所爆发的全球军事冲突，整场战争涉及到全球绝大多数的国家，包括所有的大国，并最终分成两个彼此对立的军事同盟─同盟国和轴心国。这次战争是人类史上最大的战争，动员了1亿多名军人参与这次军事冲突。主要的参战国纷纷宣布进入总体战状态，几乎将自身国家的全部经济、工业和科学技术用于战争之上，同时将民用和军用的资源合并以便规划。包括有犹太人大屠杀、南京大屠杀、战争中日军对中国军民进行细菌战、以及最终美国对日本首次使用原子弹等事件，使第二次世界大战也是有纪录以来最多大规模民众死亡的军事冲突，全部将近有5,000万至7,000万人因而死亡，这让第二次世界大战成了人类历史上死伤人数最多的战争[2]。第二次世界大战改变了世界局势，英国、法国等欧洲殖民帝国衰落，美国和苏联取代了欧洲殖民帝国的地位成了新的超级大国并在战后形成了两极格局直到1991年。</p><p><br></p><p>二战装备比一战更加多样化，如坦克、飞机、潜艇、航空母舰…</p><p><br><br><br></p><h2 id="德国-1"><a href="#德国-1" class="headerlink" title="德国"></a>德国</h2><p>此列表将列出所有纳粹德国在二次大战中使用过的武器（包括在占领地生产和缴获的武器，但从盟军缴获的武器除外）。</p><p><br></p><h3 id="坦克-2"><a href="#坦克-2" class="headerlink" title="坦克"></a>坦克</h3><p>德国第二次世界大战装甲战斗车辆:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">輕型坦克一号坦克 二号坦克 35(t)坦克 38(t)坦克</span><br><span class="line">中型坦克三号坦克 四号坦克 五号坦克豹式</span><br><span class="line">重型坦克六号坦克 虎I 虎II</span><br><span class="line">突击炮三号突击炮 四号突击炮 10.5厘米突击榴弹炮42 33B突击步兵炮 灰熊式 突击虎式</span><br><span class="line">驅逐戰車／坦克驱逐车一号反坦克自走炮 黄鼠狼I式／II式／III式 追猎者式 四号驅逐戰車 犀牛式 猎豹式 猎虎式 象式</span><br><span class="line">自走炮一号自走重步兵炮 二号自走重步兵炮 黄蜂式 野蜂式 蟋蟀式 装甲机动车 40型发射架 卡尔自走臼炮</span><br><span class="line">防空坦克38(t)防空坦克 一号防空坦克 四号防空坦克 家具车式 旋风式 东风式 球状闪电</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>LT-35坦克</strong></li></ul><p>LT-35或LT vz. 35是捷克斯洛伐克制造的轻型坦克，在二战中被纳粹德国采用，德军称为Panzerkampfwagen 35(t)（Pz.Kpfw. 35(t)）或Panzer 35(t)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">乘员4人</span><br><span class="line">长度4.9米</span><br><span class="line">宽度2.16米</span><br><span class="line">高度2.2米</span><br><span class="line">重量11吨</span><br><span class="line">发动机斯科达汽油T11</span><br><span class="line">功率120匹 ( 89千瓦)</span><br><span class="line">功率重量比10.9匹/吨</span><br><span class="line">悬挂系统leaf spring bogie</span><br><span class="line">速度34公里/小时</span><br><span class="line">最大行程193公里</span><br><span class="line"></span><br><span class="line">装甲25毫米</span><br><span class="line">主要武器1 x Skoda 37毫米M1934炮</span><br><span class="line">辅助武器2 x 7.92毫米MG34机枪</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/LT-35.png" alt=""></p><p><br></p><ul><li><strong>LT-38坦克</strong></li></ul><p>LT-38是捷克斯洛伐克斯柯达厂制造的LTvz-38轻型坦克，德军编号Sd.Kfz140 Pz.38(t)，由著名的斯科达（Skoda）兵工厂所制造，于1938年末起服役于捷军，1939年3月德国并吞捷克之后，鉴于此车设计优良，遂以Pz.38(t)的名号继续使用，一直到大战后期都还能看到此车的变种继续为德国在各地奋战。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">乘员4人</span><br><span class="line">长度4.61 米</span><br><span class="line">宽度2.14 米</span><br><span class="line">高度2.40 米</span><br><span class="line">重量9.5吨</span><br><span class="line">发动机汽油Praga EPA 6-cylinder</span><br><span class="line">功率126匹 ( 95千瓦)</span><br><span class="line">功率重量比13匹/吨</span><br><span class="line">悬挂系统钢板弹簧</span><br><span class="line">速度42公里/小时（公路）</span><br><span class="line">15公里/小时（非公路）</span><br><span class="line">最大行程160至250公里</span><br><span class="line"></span><br><span class="line">装甲A-D型：8-30毫米</span><br><span class="line">E型：50毫米</span><br><span class="line">主要武器1 x 37毫米 L/47.8炮</span><br><span class="line">辅助武器2 x 7.92毫米ZB53机枪</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/LT-38.png" alt=""></p><p><br></p><ul><li><strong>一号坦克</strong></li></ul><p>一号坦克（德语：Panzerkampfwagen I，意为一号装甲战斗车辆）是德国于1930年代研制的一款轻型坦克，缩写为“PzKpfw I”，其官方军械署赋予的编号为SdKfz 101（“第101号特殊用途车辆”）。一号坦克自1932年开始设计，并于1934年开始大量生产，它原先仅作为德军建构新一代的装甲战斗与技术时所使用的训练车辆，但后来将其投入了西班牙内战、二战的波兰、法国、苏联、北非战场以及中国在抗日战争中使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">重量5.4(A型)/5.8(B型)吨</span><br><span class="line">长度4.02(A型)/4.42(B型)米</span><br><span class="line">宽度2.06米</span><br><span class="line">高度1.72米</span><br><span class="line">操作人数2人；车长及驾驶员</span><br><span class="line">装甲7至13毫米</span><br><span class="line">主武器两门7.92毫米MG13机枪（A型和B型）</span><br><span class="line">发动机克虏伯M 305 4汽缸气冷汽油引擎（A型）</span><br><span class="line">梅巴赫NL 38 TR 6汽缸液冷汽油引擎（B型以后）</span><br><span class="line">60PS（59匹，44千瓦）</span><br><span class="line">100PS（98匹马力、73千瓦）</span><br><span class="line">功率/重量11.1PS／吨</span><br><span class="line">悬挂椭圆钢板弹簧</span><br><span class="line">作战范围140千米（A型）</span><br><span class="line">170千米（B型）</span><br><span class="line">速度37千米／小时（A型）</span><br><span class="line">40千米／小时（B型）</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/PzKpfw-I.png" alt=""></p><p><br></p><ul><li><strong>二号坦克</strong></li></ul><p>二号坦克（德语：Panzer II）是第二次世界大战纳粹德国的坦克，这型坦克是用来填补其他设计中坦克的空隙, 它在第二次世界大战中的波兰战役与法国战役扮演了一个很重要的角色。到1942年底前绝大多数二号坦克已经离开第一线单位，生产线到1943年终止，然而车体继续被改良回其他种类装甲车辆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">乘员3人</span><br><span class="line">(车长/炮手、装填手、驾驶)</span><br><span class="line">长度4.8米</span><br><span class="line">宽度2.2米</span><br><span class="line">高度2.0米</span><br><span class="line">重量7.2吨</span><br><span class="line">发动机6-cyl汽油梅巴赫HL</span><br><span class="line">功率140匹 (105千瓦)</span><br><span class="line">功率重量比15匹/吨</span><br><span class="line">悬挂系统钢板弹簧</span><br><span class="line">速度40千米/小时</span><br><span class="line">最大行程200千米</span><br><span class="line"></span><br><span class="line">装甲5-14.5毫米</span><br><span class="line">主要武器20毫米 KwK 30 L/55 Ausf.A-f</span><br><span class="line">20毫米 KwK 38 L/55 Ausf.J-L</span><br><span class="line">辅助武器7.92毫米MG34机枪</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Panzer-II.png" alt=""></p><p><br></p><ul><li><strong>三号坦克</strong></li></ul><p>三号坦克（德语：Panzerkampfwagen III），是一款德军二战坦克。三号坦克拥有多种衍生及改进型，并由德军在二战中广泛使用，其改进和衍生型号一直服役到二战结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">重量19.5 吨</span><br><span class="line">长度5.38米 17ft 8in</span><br><span class="line">宽度2.91米 9ft 7in</span><br><span class="line">高度2.59米 8ft</span><br><span class="line">操作人数5名</span><br><span class="line"></span><br><span class="line">装甲30mm</span><br><span class="line">主武器37mm KwK L/46.5（A、B、C、D、E型、部分F、G型）</span><br><span class="line">50mm KwK L/42（部分F、G、J型，H型）</span><br><span class="line">50mm KwK L/60（部分J型、L型）</span><br><span class="line">75mm L/24（部分L型，M型，N型）</span><br><span class="line">副武器3挺MG34（A-H型）</span><br><span class="line">2挺MG34（G型以后）</span><br><span class="line">发动机迈巴赫HL108TR（A、B、C、D型）</span><br><span class="line">迈巴赫HL120TR V形12缸（E型以后）</span><br><span class="line">320匹（迈巴赫HL120TR）</span><br><span class="line">变速SRG 328-145型（E-G型）</span><br><span class="line">迈巴赫SSG77（H型）</span><br><span class="line">悬挂扭力杆悬挂[2]</span><br><span class="line">作战范围200公里[6]</span><br><span class="line">速度42公里/时[6]</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/PzKpfw-III.png" alt=""></p><p><br></p><ul><li><strong>四号坦克</strong></li></ul><p>四号坦克（德语：Panzerkampfwagen IV，或称IV号坦克）为纳粹德国在第二次世界大战中生产的一款中型坦克。它原本设计目的是支援步兵，并且与专门执行反坦克任务的三号坦克协同作战。在三号坦克的整体性能逐渐不敷二次大战中期装甲战斗需要时，四号坦克因所使用的技术较为成熟而比三号坦克有更大的改良空间，因此在不断改进的过程中，四号坦克逐渐成为装甲师装备的主力车种。四号坦克较大的改良空间亦使其较为容易改装，既有改造为突击炮、自行反坦克炮，也有改造为弹药运送车、架桥坦克等，成为用途最广泛的坦克。从投产至二战结束，德国共制造了逾8,800辆四号坦克或其改造型。四号坦克参加了几乎所有战役，而且表现出相当的可靠性，没有像豹式坦克初期型号有大量的技术问题，就数量、服役时间来看，这型坦克才是德国装甲兵的主力，因此被德军装甲兵昵称为“军马”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">乘员5人（车长、炮手、装填手、驾驶员及无线电操作员）</span><br><span class="line">长度7.02米</span><br><span class="line">宽度2.88米</span><br><span class="line">高度2.68米</span><br><span class="line">重量B型：16吨；C型：18.14吨</span><br><span class="line">D型：20吨；F型：22.3吨</span><br><span class="line">G型：23.6吨；H型：25吨</span><br><span class="line">发动机梅巴赫A型：HL108TR 12缸汽油引擎</span><br><span class="line">B型：HL120TR 12缸汽油引擎</span><br><span class="line">C型：HL120TRM 12缸汽油引擎</span><br><span class="line">功率A型：250hp；B型：300hp</span><br><span class="line">功率重量比12匹/吨</span><br><span class="line">悬挂系统弹簧悬挂（C型开始使用板簧悬挂系统）</span><br><span class="line">速度A型：31公里/小时〔道路〕</span><br><span class="line">B型：39公里/小时〔道路〕</span><br><span class="line">42公里/小时（道路）</span><br><span class="line">16公里/小时（越野）</span><br><span class="line">最大行程200公里</span><br><span class="line">J型：320公里</span><br><span class="line"></span><br><span class="line">装甲炮塔正面50毫米/10°</span><br><span class="line">炮塔两侧30毫米/26°</span><br><span class="line">炮塔后方30毫米/10°</span><br><span class="line">炮塔顶10毫米</span><br><span class="line">车体正面80毫米/11°</span><br><span class="line">车体侧面30毫米（后期型号加5毫米裙甲）</span><br><span class="line">车体后面20毫米</span><br><span class="line">主要武器坦克炮-KwK40 75毫米43倍径炮（KwK-40 75mm）</span><br><span class="line">辅助武器2×7.92毫米MG34</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/PzKpfw-IV.png" alt=""></p><p><br></p><ul><li><strong>五号坦克 </strong></li></ul><p>五号坦克 黑豹式（德语：Panzerkampfwagen V Panther）是第二次世界大战中纳粹德国所制造的中型坦克。制式编号为Sd.Kfz.171。其后，由于“五号坦克（V号坦克）”这个名称被废除，所以在后来以“黑豹式坦克（Pz.Kpfw. Panther）”作为制式名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">乘员5人</span><br><span class="line">车长、炮手、驾驶、通讯员、装填手[3]</span><br><span class="line">长度6.87米（车身）</span><br><span class="line">8.66米（全长）</span><br><span class="line">宽度3.27米</span><br><span class="line">高度2.995米</span><br><span class="line">重量44.8吨（战斗重量）</span><br><span class="line">发动机梅巴赫230P30</span><br><span class="line">水冷V型12汽缸汽油引擎</span><br><span class="line">功率700匹</span><br><span class="line">功率重量比15.625匹／吨</span><br><span class="line">悬挂系统双扭力杆</span><br><span class="line">速度55公里／小时（平地）</span><br><span class="line">30公里／小时（越野）</span><br><span class="line">最大行程250公里（平地）、100公里（越野）</span><br><span class="line"></span><br><span class="line">装甲前方80毫米，倾斜装甲139.48毫米</span><br><span class="line">侧面及后方40毫米</span><br><span class="line">主要武器7.5厘米Kwk42L/70炮（炮弹79发后期81发）</span><br><span class="line">辅助武器7.92毫米MG34机枪 ×2</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Panther.png" alt=""></p><p><br></p><ul><li><strong>六号坦克</strong></li></ul><p>六号坦克（德语：Panzerkampfwagen VI）是纳粹德国在第二次世界大战期间所使用的重坦克。<br>被称为六号坦克的坦克共有2款，分别是I型与II型，即为“虎I”与“虎II”。在当时被评为其中一系列世界上最强的坦克。一般称其为“虎式坦克”，或者以英文“Tiger Tank”来称呼。</p><p><br></p><ul><li><strong>虎I坦克</strong></li></ul><p>虎I坦克（德语：Panzerkampfwagen VI Ausf. E (Sd Kfz 181) Tiger），是第二次世界大战中德意志国防军及武装党卫队所使用的坦克，正式名称为六号坦克（VI号坦克）。一般称为虎式坦克，简称“虎式”或“Tiger”。从1942年下半年服役起至1945年纳粹德国投降为止，一直是活跃于第一线的重型坦克。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">乘员5人</span><br><span class="line">车长、炮手、装填手、驾驶员、通讯员</span><br><span class="line">长度8.45米（全长）</span><br><span class="line">6.316米（车身）</span><br><span class="line">宽度3.705米</span><br><span class="line">高度3米</span><br><span class="line">重量57吨（战斗重量）</span><br><span class="line">发动机梅巴赫HL230 P45</span><br><span class="line">水冷4冲程V型12汽缸汽油引擎[2]</span><br><span class="line">功率700匹</span><br><span class="line">功率重量比12.3匹／吨</span><br><span class="line">悬挂系统扭力杆</span><br><span class="line">速度40公里／小时（平地）</span><br><span class="line">20-25公里／小时（越野）</span><br><span class="line">最大行程100公里（平地）、60公里（越野）</span><br><span class="line"></span><br><span class="line">装甲前方100毫米</span><br><span class="line">侧面及后方80毫米</span><br><span class="line">车顶25毫米</span><br><span class="line">主要武器8.8厘米Kwk 36 L/56炮（炮弹92发）</span><br><span class="line">辅助武器7.92毫米MG34机枪 ×2</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Tiger-I.png" alt=""></p><p><br></p><ul><li><strong>虎II坦克</strong></li></ul><p>六号坦克B型 （德语：Panzerkampfwagen VI Ausf.B Tiger II，通称“虎王坦克”或“虎II坦克”），是一款纳粹德国在二战期间研发的重型坦克。<br>虎王坦克是虎I坦克的继任者，它继承了虎I坦克的重装甲风格，还有着豹式坦克那样的倾斜装甲。虎王坦克重达70公吨，前装甲有100到180毫米厚，装配一门88毫米KwK 43 L/71式坦克炮。没有炮塔的猎虎式坦克歼击车与虎王坦克共用同一种底盘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">重量68.5公吨（装备保时捷炮塔）</span><br><span class="line">69.8公吨（装备亨舍尔炮塔）</span><br><span class="line">长度7.38米（车体）</span><br><span class="line">10.286米（33英尺9英寸）（炮向前）</span><br><span class="line">宽度3.755米</span><br><span class="line">高度3.09米</span><br><span class="line">操作人数五人（车长、炮手、装填手、通信兵、驾驶员）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">装甲25～185毫米（1～7英寸）</span><br><span class="line">主武器1门KwK43 88毫米坦克炮</span><br><span class="line">保时捷型炮塔可携带80发炮弹</span><br><span class="line">亨舍尔型炮塔可携带86发炮弹</span><br><span class="line">副武器2挺7.92毫米MG 34 携带5850发弹药</span><br><span class="line">发动机V-12 迈巴赫HL 230 P30汽油机 690匹</span><br><span class="line">功率/重量8.97匹/公吨</span><br><span class="line">变速迈巴赫OLVAR EG 40 12 16 B（8个前进档、4个倒车档）</span><br><span class="line">悬挂扭力杆悬挂</span><br><span class="line">底盘高度495至510毫米</span><br><span class="line">燃料容量860升（190英制加仑）</span><br><span class="line">作战范围于公路上行驶：170千米</span><br><span class="line">越野时：120千米</span><br><span class="line">速度公路上最大速度：41.5千米/时</span><br><span class="line">能允许持续行进：38千米/时</span><br><span class="line">越野时：15-20千米/时</span><br></pre></td></tr></table></figure><p>!()[/images/Weapons/Tiger-II.png]</p><p><br></p><ul><li><strong>七号狮式坦克</strong></li></ul><p>七号狮式超重型坦克（Panzerkampfwagen VII Löwe）为二战纳粹德国研发的一款超重型坦克。<br>制造数量    从未被制造出来。</p><p><br></p><ul><li><strong>八号坦克鼠式</strong></li></ul><p>八号坦克鼠式（Panzerkampfwagen VIII Maus），是德国在第二次世界大战设计并制造的超重型坦克。<br>产量    2（原型车，其中只有一台完工）。</p><p><br></p><ul><li><strong>九/十号坦克</strong></li></ul><p>九号坦克（Panzerkampfwagen IX）及十号坦克（Panzerkampfwagen X），为纳粹德国在第二次世界大战晚期故意散布欺敌的虚构坦克开发计划。</p><p><br></p><ul><li><strong>陆地巡航者P. 1000老鼠</strong></li></ul><p>P. 1000 巨鼠重型巡航坦克（Landkreuzer P. 1000 Ratte）是纳粹德国计划开发的一种重量达1000吨的超重型坦克，由德国的克虏伯公司研制，但计划在1943年被放弃，没有一辆P-1000被生产出来。此超重型坦克非常巨大，高度有11米，炮台也有两个平常人的高度。<br>制造数量    0（完全从未实际投产）</p><p><br></p><ul><li><strong>陆地巡航者P.1500怪物</strong></li></ul><p>P. 1500 怪物陆行舰（Landkreuzer P. 1500 Monster）外型和古斯塔夫超重型铁道炮相似，是纳粹德国计划开发的一种重量达1,500吨的超重型坦克。<br>制造数量    0（完全从未实际投产）</p><p><br><br><br></p><h3 id="潜艇"><a href="#潜艇" class="headerlink" title="潜艇"></a>潜艇</h3><p>submarine</p><p><br></p><ul><li><strong>U-47潜艇</strong></li></ul><p>U-47号潜艇是一艘于第二次世界大战时于纳粹德国海军服役的VIIB型U-潜艇。它在1937年2月25日开始建造并于1938年10月29日在基尔的克虏伯造船厂下水。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">舰型VIIB型</span><br><span class="line">排水量761吨</span><br><span class="line">865吨（潜入海底）</span><br><span class="line">全长66.6米（219英尺）</span><br><span class="line">全宽6.2米（20英尺）</span><br><span class="line">深度220米（720英尺）</span><br><span class="line">动力来源2 × 1400 马力的柴油机</span><br><span class="line">2 × 375 PS （280 kW） 的电动马达</span><br><span class="line">速度</span><br><span class="line">最大17.7节（海面）</span><br><span class="line">最大7.6节（潜入海底）</span><br><span class="line">续航距离6,500海里（12,000千米）</span><br><span class="line">乘员44-48</span><br><span class="line">船员47</span><br><span class="line">武器装备</span><br><span class="line">鱼雷发射管：前4后1，共5个533mm发射管</span><br><span class="line">8.8厘米 SK C/35舰炮（虽同为88毫米口径但是与8.8 cm Flak 18/36/37高射炮不同），2厘米 MG C/30 机炮</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/U-47.png" alt=""></p><p><br></p><ul><li><strong>U-2365</strong></li></ul><p>U-2365号潜艇为纳粹德国海军XXIII级潜艇（德语：Klasse XXIII、或称Typ XXIII）的一艘，属于近海小型攻击潜艇。<br>U-2365号潜艇于1945年3月2日服役。由于服役时已临近战争尾声，该艇并未取得任何战果，最终于1945年5月8日中被凿沉在卡特加特海峡。</p><p><br><br><br></p><h3 id="火炮"><a href="#火炮" class="headerlink" title="火炮"></a>火炮</h3><p>第二次世界大战期间德国陆军所用火炮:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">坦克主炮</span><br><span class="line">2厘米KwK 30炮 3.7厘米KwK 36炮 3.7厘米KwK 38炮(t) 5厘米KwK 38炮 5厘米KwK 39炮 7.5厘米KwK 37炮 7.5厘米KwK 40炮 7.5厘米KwK 42炮 8.8厘米 KwK 36炮 8.8厘米 KwK 43炮</span><br><span class="line"></span><br><span class="line">反坦克炮</span><br><span class="line">sPzB 41反坦克炮 PaK 36反坦克炮 4.2厘米Pak 41反坦克炮 Pak 38反坦克炮 Pak 97/38反坦克炮 Pak 39反坦克炮 Pak 40反坦克炮 7.5厘米Pak 41反坦克炮 7.5厘米Pak 42反坦克炮 7.62厘米PaK 36反坦克炮(r) 8公分PAW 600反坦克炮 Pak 43反坦克炮 PaK 44反坦克炮</span><br><span class="line"></span><br><span class="line">步兵支援火炮</span><br><span class="line">le.IG 1步兵支援火炮 IG 37步兵支援火炮 IG 42步兵支援火炮 sIG 33步兵支援火炮 GebH 34步兵支援火炮 GebG 36步兵支援火炮 GebH 40步兵支援火炮</span><br><span class="line"></span><br><span class="line">无后座力炮</span><br><span class="line">7.5厘米LG 40无后座力炮 105毫米LG 40无后座力炮 LG 42无后座力炮</span><br><span class="line"></span><br><span class="line">重型迫击炮</span><br><span class="line">10公分35年式喷烟者 10公分40年式喷烟者 leLdgW迫击炮 GrW 69迫击炮 schwerer Ladungswerfer迫击炮</span><br><span class="line"></span><br><span class="line">火箭炮</span><br><span class="line">7.3厘米Föhn-Gerät 7.3厘米41年式Propagandawerfer 8厘米Raketen-Vielfachwerfer 15厘米Do-Gerät 15公分41年式喷烟者 21公分42年式喷烟者 28/32公分41年式喷烟者 30公分42年式喷烟者 30 cm Raketenwerfer 56 Wurfrahmen 40多管火箭炮</span><br><span class="line"></span><br><span class="line">中重型野战炮</span><br><span class="line">FK 16 nA野战炮 FK 18野战炮 FK 38野战炮 FK 7M85野战炮 10 cm K 17野战炮 sK 18野战炮 leFH 16榴弹炮 leFH 18榴弹炮 leFH 18M榴弹炮 leFH 18/40榴弹炮 sK 18/40野战炮 sFH 13榴弹炮 SFH 18榴弹炮 K 16野战炮 K 18重炮 K 39重炮 SK C/28重炮 K 18重榴弹炮 Mrs 16重榴弹炮 Mrs 18重榴弹炮</span><br><span class="line"></span><br><span class="line">超重炮及攻城武器</span><br><span class="line">K 38重炮 K 39重炮 H 39攻城榴弹炮 K(t)超重型攻城炮 Kanone L/46 K 3重型攻城炮 H L/12重型攻城榴弹炮 Haubitze M1攻城榴弹炮 Gamma Mörser攻城榴弹炮 卡尔臼炮 古斯塔夫超重型铁道炮</span><br><span class="line"></span><br><span class="line">列车炮</span><br><span class="line">15厘米K列车炮 17厘米K列车炮 20.3厘米K列车炮 21厘米K 12列车炮 24厘米Th K列车炮 24厘米ThBr K列车炮 28厘米kzBr K列车炮 28厘米lgBr K列车炮 28厘米sBr K列车炮 28厘米Br NK列车炮 K5列车炮 38厘米Siegfried K列车炮 古斯塔夫超重型铁道炮</span><br><span class="line"></span><br><span class="line">防空炮</span><br><span class="line">2厘米30/38年式高射炮 2厘米Gebirgsflak 38高射炮 3.7厘米18/36/37/43年式高射炮 5厘米41年式高射炮 8.8厘米18/36/37年式高射炮 8.8厘米41年式高射炮 10.5厘米38年式高射炮 12.8厘米40年式高射炮</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>Mrs 18重榴弹炮</strong></li></ul><p>Mrs 18重榴弹炮（21公分Mrs 18式）是纳粹德国于第二次世界大战中所使用的一种重型榴弹炮。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">重量16,700 公斤（36,817 磅）</span><br><span class="line">枪管长度6.51米L/30（30倍径）</span><br><span class="line">炮弹分离装填式弹药</span><br><span class="line">炮弹重量113公斤（高爆弹）</span><br><span class="line">口径211 毫米</span><br><span class="line">后膛水平滑契式炮栓</span><br><span class="line">后坐力液压机械复合式</span><br><span class="line">载具box trail</span><br><span class="line">射击仰角-6° to +70°</span><br><span class="line">回旋角度16°（于轮上）</span><br><span class="line">360°（于平台上）</span><br><span class="line">枪口初速550 米/秒</span><br><span class="line">有效射程14,500 米</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/Mrs-18.png" alt=""></p><p><br></p><ul><li><strong>3.7厘米KwK 36炮</strong></li></ul><p>3.7 cm KwK 36 L/45 (3.7 公分战车炮36 45倍径)是第二次世界大战时由德国所生产的3.7cm火炮，主要用做三号战车的主炮，亦见于其他德军装甲车辆上。</p><p><br></p><ul><li><strong>5厘米KwK 38炮</strong></li></ul><p>5 cm KwK 38 L/42(5公分战车炮 42倍径)是二战时德军所用的50毫米火炮，仅见于三号战车上使用。</p><p><br></p><ul><li><strong>5厘米KwK 39炮</strong></li></ul><p>5 cm KwK 39 L/60 (5公分战车炮 60倍径)是二战时德军所用的50毫米火炮，主要作为1941年以后，三号战车后续型号的主炮。</p><p><br></p><ul><li><strong>7.5厘米KwK 37炮</strong></li></ul><p>7.5 cm KwK 37 L/24(7.5公分战车炮24倍径)是一种二战时，德军所使用的75mm，类似榴弹炮的短管战车炮。主要用于四号战车的早期型号和三号突击炮的早期型号。</p><p><br></p><ul><li><strong>7.5厘米KwK 40炮</strong></li></ul><p>7.5 cm KwK 40是在二战时，德军所使用的战车炮。主要搭载于于四号战车（F2型以后）、三号突击炮以及四号突击炮上。</p><p><br></p><ul><li><strong>7.5厘米LG 40无后座力炮</strong></li></ul><p>7.5厘米LG 40无后座力炮是由德国军队在第二次世界大战期间使用的无后座力炮。</p><p><br></p><ul><li><strong>7.5厘米Pak 41反坦克炮</strong></li></ul><p>7.5 cm Pak 41是第二次世界大战后期进入服役，由德国制造的反坦克炮。</p><p><br></p><ul><li><strong>7.5厘米 Pak 39炮</strong></li></ul><p>7.5厘米Pak39(L/48)（德语：7.5 cm Panzerjägerkanone 39），是一款德国于第二次世界大战期间所使用的反坦克火炮。该火炮于1942年1月开始装备于四号驱逐战车和追猎者式驱逐战车等驱逐战车。</p><p><br></p><ul><li><strong>KwK36 88毫米战车炮</strong></li></ul><p>88 mm KwK 36 L/56 (德语：8.8 cm KampfwagenKanone 36 L/56) 是在第二次世界大战中德意志国防军所使用的88毫米坦克炮。由克鲁伯所研制，是虎I坦克的主武器。</p><p><br></p><ul><li><strong>KwK43 88毫米战车炮</strong></li></ul><p>8.8 cm KwK 43 L/71 (德语：KampfWagenKanone—坦克炮) 是在第二次世界大战中，克鲁伯公司所设计，德意志国防军所使用的一门坦克炮。它是虎II坦克的主武器，并且是在第二次世界大战中作为放在拥有可转动炮塔的战车上最具威力的一门炮。</p><p><br><br><br></p><h3 id="装甲战斗车"><a href="#装甲战斗车" class="headerlink" title="装甲战斗车"></a>装甲战斗车</h3><p><br><br><br></p><h3 id="飞机-2"><a href="#飞机-2" class="headerlink" title="飞机"></a>飞机</h3><p><br><br><br></p><h3 id="船舰"><a href="#船舰" class="headerlink" title="船舰"></a>船舰</h3><p><br><br><br></p><h3 id="武器"><a href="#武器" class="headerlink" title="武器"></a>武器</h3><ul><li><strong>39型卵状手榴弹</strong></li></ul><p>39型卵状手榴弹（德语：Eihandgranate 39）是第二次世界大战期间德军所产的手榴弹。</p><p><br></p><ul><li><strong>柄式手榴弹</strong></li></ul><p>柄式手榴弹（德语：Stielhandgranate）为德国陆军自第一次世界大战中期至第二次世界大战末期所使用之手榴弹。</p><p><br></p><ul><li><strong>铁拳</strong></li></ul><p>铁拳（德语：Panzerfaust）又称作装甲拳或反坦克榴弹发射器，是第二次世界大战时由德国研发与制造的火药推进无后座力反装甲武器。</p><p><img src="/images/Weapons/Panzerfaust.png" alt=""></p><p><br></p><ul><li><strong>防空铁拳</strong></li></ul><p>防空铁拳(德文:Fliegerfaust)是第二次世界大战末期德国士兵使用的手提防空火箭弹，由于在二战末期，德军失去制空权(尤其在西线)，而研制出来的步兵手提防空火箭弹。</p><p><img src="/images/Weapons/Fliegerfaust.png" alt=""></p><p><br></p><ul><li><strong>装甲投掷雷</strong></li></ul><p>装甲投掷雷（德语：Panzerwurfmine，也缩写为PWM）是一种由纳粹德国开发并在二战中生产使用的反坦克碰炸手榴弹。</p><p><br></p><ul><li><strong>坦克杀手</strong></li></ul><p>Panzerschreck（德语）是二战中，纳粹德国的Raketenpanzerbüchse（“反战车火箭步枪”，缩写为RPzB）的昵称，它是一种口径为88毫米，可重复使用的反战车火箭发射器。</p><p><img src="/images/Weapons/Panzerschreck.png" alt=""></p><p><br></p><ul><li><strong>LeGrW 36型50毫米迫击炮</strong></li></ul><p>LeGrW 36型50毫米迫击炮（德语：5cm leichter Granatenwerfer 36 ）是纳粹德国在第二次世界大战中使用的一种轻型迫击炮。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">重量14 kg (31 lb)</span><br><span class="line">枪管长度465 mm (18 in)</span><br><span class="line">操作人数2</span><br><span class="line">炮弹0.9 kg (2 lb) TNT 装药</span><br><span class="line">口径50 mm (1.97 in)</span><br><span class="line">射击仰角42°到 90°</span><br><span class="line">回旋角度33°到 45°</span><br><span class="line">射速15-25 发/每分钟</span><br><span class="line">枪口初速75 m/s (246 ft/s)</span><br><span class="line">有效射程50 m (54.7 yd) 最小</span><br><span class="line">510 m (557.7 yd) 最大</span><br><span class="line">最大射程520 m (568.7 yd)</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/LeGrW-36.png" alt=""></p><p><br></p><ul><li><strong>GrW 34型81毫米迫击炮</strong></li></ul><p>GrW 34型81毫米迫击炮（德语：8 cm Granatwerfer 34）是纳粹德国陆军在第二次世界大战使用的一种迫击炮，这种迫击炮的射速和射程都颇为优秀，在训练有素的士兵手中可以发挥出更大的威力。在单兵携带时，这种迫击炮可以分解为炮筒、底座和支架三个部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">重量62 kg (136.6 lbs) 钢炮筒</span><br><span class="line">57 kg (125.6 lbs)合金炮筒</span><br><span class="line">枪管长度1,143 mm (45 in)</span><br><span class="line">操作人数8</span><br><span class="line">炮弹3.5 kg (7.71 lbs)</span><br><span class="line">口径81.4 mm (3.20 in)</span><br><span class="line">射击仰角45°到90°</span><br><span class="line">回旋角度10°到23°</span><br><span class="line">射速15-25 发/每分钟</span><br><span class="line">枪口初速174 m/s (571 ft/s)</span><br><span class="line">最大射程2,400 m (2,624 yds)</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/GrW-34.png" alt=""></p><p><br></p><ul><li><strong>GrW 42型81毫米迫击炮</strong></li></ul><p>GrW 42型81毫米迫击炮（德语：kurzer 8 cm Granatwerfer 42 ）是纳粹德国在第二次世界大战中使用的一种前装式滑膛迫击炮。是GrW 34型81毫米迫击炮使用短炮筒后的轻量化版本，最初计划是供伞兵使用的。然而由于50毫米口径的LeGrW 36型50毫米迫击炮射程太近，此款迫击炮也常被用来替换前者。GrW 42发射的炮弹重量是前者的3.5倍，射程则为两倍，迫击炮的重量则不到前者两倍，同时还可分解为三个部分携带。</p><p><br></p><ul><li><p><strong>鲁格手枪</strong></p></li><li><p><strong>M1879帝国转轮手枪</strong></p></li><li><p><strong>毛瑟C96手枪</strong></p></li></ul><p><br></p><ul><li><strong>瓦尔特P38手枪</strong></li></ul><p>瓦尔特P38（德语：Walther P38）是由德国瓦尔特武器公司在1930年代为德意志国防军研制的一种9毫米口径半自动手枪，此枪在二战期间被广泛采用。尽管该枪的出现原先是为了取代成本昂贵的鲁格P08手枪，然而直到二战结束时也没有完全取代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">重量800克</span><br><span class="line">长度216毫米</span><br><span class="line">枪管长度125毫米</span><br><span class="line">子弹9毫米鲁格弹</span><br><span class="line">枪机短行程后座</span><br><span class="line">单动/双动</span><br><span class="line">枪口初速365米/秒</span><br><span class="line">有效射程50米</span><br><span class="line">供弹方式8发可拆式单排弹匣</span><br><span class="line">瞄具凹形照门，刀片形准星</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/P38.png" alt=""></p><p><br></p><ul><li><strong>ViS wz. 35手枪</strong></li></ul><p>Pistolet ViS wz. 35是由波兰枪工Piotr Wilniewczyc研制的一款半自动手枪，于1935年成为波兰军队的制式手枪。ViS wz. 35一直都被认为是有史以来最好的手枪之一，更是一些枪械收藏家的珍藏之一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">重量1.123 kg（上弹）</span><br><span class="line">0.950 kg（空枪）</span><br><span class="line">长度205 mm</span><br><span class="line">枪管长度115 mm</span><br><span class="line">子弹9毫米鲁格弹</span><br><span class="line">口径9×19毫米</span><br><span class="line">枪机枪管短行程后座作用、单动</span><br><span class="line">枪口初速345米/秒</span><br><span class="line">供弹方式8发弹匣</span><br><span class="line">瞄具金属缺口式照门及准星</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/ViSwz-35.png" alt=""></p><p><br></p><ul><li><p><strong>MP18冲锋枪</strong></p></li><li><p><strong>MP28冲锋枪</strong></p></li></ul><p><br></p><ul><li><strong>MP3008冲锋枪</strong></li></ul><p>MP 3008是纳粹德国在1945年二战末期制造的冲锋枪。主要目的是提供给在战争末期扩编的国民突击队使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">重量3.18公斤</span><br><span class="line">长度760毫米</span><br><span class="line">枪管长度196毫米</span><br><span class="line">子弹9×19毫米</span><br><span class="line">口径9毫米</span><br><span class="line">枪机反冲作用，开放式枪机</span><br><span class="line">发射模式全自动</span><br><span class="line">射速450发/分锺</span><br><span class="line">枪口初速365米/秒</span><br><span class="line">供弹方式32发MP40可拆卸式弹匣</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/MP3008.png" alt=""></p><p><br></p><ul><li><strong>MP34冲锋枪</strong></li></ul><p>MP34（德语：Maschinenpistole 34，意为：34型冲锋枪）是一枝由奥地利斯泰尔兵工厂生产的冲锋枪，在1930年代至二战期间被奥地利警察以及随后的德国国防军和武装党卫队所采用。</p><p><img src="/images/Weapons/MP34.png" alt=""></p><p><br></p><ul><li><strong>MP35冲锋枪</strong></li></ul><p>MP35（德语：Maschinenpistole 35，意为：35型冲锋枪）是一枝由纳粹德国生产的冲锋枪，在二战以前和期间被德国国防军、武装党卫队和德国警察所采用。</p><p><img src="/images/Weapons/MP35.png" alt=""></p><p><br></p><ul><li><strong>MP40冲锋枪</strong></li></ul><p>MP40冲锋枪（Maschinenpistole 40），常被称为“施迈瑟冲锋枪”，是一种为方便大量生产而设计，与传统枪械制造观念不同的冲锋枪，亦是第二次世界大战期间德国军队使用最广泛、性能最优良的冲锋枪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">重量4公斤（8.82磅）</span><br><span class="line">长度收起枪托：630毫米</span><br><span class="line">展开枪托：833毫米</span><br><span class="line">枪管长度251毫米</span><br><span class="line">子弹9×19毫米鲁格弹</span><br><span class="line">枪机提前击发底火式反冲作用及开放式枪机</span><br><span class="line">发射模式全自动</span><br><span class="line">射速500发／分钟</span><br><span class="line">枪口初速约380米／秒</span><br><span class="line">有效射程约100米</span><br><span class="line">供弹方式32发弹匣</span><br><span class="line">瞄具机械瞄具</span><br></pre></td></tr></table></figure><p><img src="/images/Weapons/MP40.png" alt=""></p><p><br></p><ul><li><strong>MP41冲锋枪</strong></li></ul><p>MP41（德语：Maschinenpistole 41，意为：41型冲锋枪）是一款由纳粹德国枪械设计师胡戈·施迈瑟所研发、黑内尔公司生产的冲锋枪，外观而言是MP40冲锋枪改用MP28冲锋枪的木制枪托的修改型，发射9×19毫米鲁格手枪子弹。<br>MP41是专门为出口和警察部门而生产。</p><p><img src="/images/Weapons/MP41.png" alt=""></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Category:%E5%90%84%E5%9B%BD%E4%B8%80%E6%88%98%E6%AD%A6%E5%99%A8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;各国一战武器，维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Category:%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%96%E7%95%8C%E5%A4%A7%E6%88%98%E5%86%9B%E4%BA%8B%E8%A3%85%E5%A4%87&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第一次世界大战武器装备，维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Category:%E5%90%84%E5%9B%BD%E4%BA%8C%E6%88%98%E6%AD%A6%E5%99%A8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;各国二战武器，维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Category:%E4%BA%8C%E6%88%98%E6%AD%A6%E5%99%A8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第二次世界大战武器装备，维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;最近玩&lt;strong&gt;battlefield I&lt;/strong&gt;(一战)有感，一时兴起，顺带在&lt;strong&gt;battlefield V&lt;/strong&gt;(二战)发布前夕做一个一战二战各国使用的武器装备归纳总结。&lt;/p&gt;
&lt;p&gt;玩了战地1，才体会到战争的残酷性，使我对战争的感觉从光辉转变为厌恶。没有什么英雄在我心中，你不知道自己何时会死去，或即将死去。&lt;br&gt;战场上每个人都一样，都是一条鲜活的生命，有家人有朋友。从战争游戏来反思战争，这点DICE studio做的不错。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;衷心祝愿世界和平！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Weapon" scheme="https://zhang21.github.io/categories/Weapon/"/>
    
    
      <category term="武器" scheme="https://zhang21.github.io/tags/%E6%AD%A6%E5%99%A8/"/>
    
      <category term="战争" scheme="https://zhang21.github.io/tags/%E6%88%98%E4%BA%89/"/>
    
  </entry>
  
  <entry>
    <title>英语语法</title>
    <link href="https://zhang21.github.io/2018/11/14/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/"/>
    <id>https://zhang21.github.io/2018/11/14/英语语法/</id>
    <published>2018-11-14T13:06:24.000Z</published>
    <updated>2019-02-03T13:07:30.302Z</updated>
    
    <content type="html"><![CDATA[<p>参考: 《新概念英语语法手册》</p><p><br><br><br></p><hr><p>&lt;–more–&gt;</p><p><br><br><br></p><h1 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>名词是指人或事物的名称，也包括一些具有抽象概念的名词。</p><p><br><br><br></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul><li><strong>充当动词的主语</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Our &apos;agent&apos; in Cairo sent a telex this morning.</span><br><span class="line">#今天早晨我们在开罗的代理人发来一封电传。</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>作动词的直接宾语</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Frank sent an urgent &apos;telex&apos; from Cairo this morning.</span><br><span class="line">#弗兰克今天早上从开罗发来一份加急电传。</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>作动词的间接宾语</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Frank sent his &apos;boss&apos; a telex.</span><br><span class="line">#弗兰克给他的老板发了一份电传。</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>作介词的宾语</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I read about it in &apos;the China Daily&apos;.</span><br><span class="line">#我在中国日报上看到了这个消息。</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>作be、seem等系动词的表语</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Jones is our &apos;guest&apos;.</span><br><span class="line">#琼斯是我们的客人</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>作同位语</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Laura, &apos;a BBC reporter&apos;, asked for an interview.</span><br><span class="line">#劳拉，BBC的记者，要求采访。</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="复合名词"><a href="#复合名词" class="headerlink" title="复合名词"></a>复合名词</h2><p>由两个或两个以上的名词部分组合而成的名词，称为复合名词。</p><p><br></p><ul><li><strong>复合名词通常有四种构成形式</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 名词+名词</span><br><span class="line">a keyboard(键盘)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 形容词+名词</span><br><span class="line">a greenhouse(温室)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 动名词+名词</span><br><span class="line">drinking water(饮用水)</span><br><span class="line"></span><br><span class="line">4. 名词+动名词</span><br><span class="line">sight-seeing(观光)</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>还有一些复合名词表示特定含义</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Oxford Road, Beijing Capital International Airport</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><strong>专有名词</strong></li></ul><p>专有名词指特定的人、地方、事物或概念，他们被认为是独一无二的。专有名词的开头字母要大写，前面一般不用冠词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#人名</span><br><span class="line">Parker</span><br><span class="line">Mr. Parker</span><br><span class="line"></span><br><span class="line">#称呼</span><br><span class="line">Mum</span><br><span class="line"></span><br><span class="line">#地名</span><br><span class="line">Asia</span><br><span class="line"></span><br><span class="line">#月份、星期、节日、季节</span><br><span class="line">April</span><br><span class="line">Monday</span><br><span class="line">Christmas</span><br><span class="line">spring(季节一般不大写)</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>普通名词</strong></li></ul><p>普通名词又可分为<strong>可数名词</strong>和<strong>不可数名词</strong>。<br>在普通名词前通常要使用冠词a, an, the…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#可数名词</span><br><span class="line">a book, an envelop</span><br><span class="line">how many stamps do you have?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#不可数名词</span><br><span class="line">water, milk, air</span><br><span class="line">how much milk do you have?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#既是可数又是不可数</span><br><span class="line">He ate much fish yesterday.</span><br><span class="line">There are a large variety of fishes in the pond.</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>复形名词</strong></li></ul><p>有些名词虽然形式上是复数形式，即以<code>-s</code>结尾，但实际上却表示单数意义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The news is at six.</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="名词的数"><a href="#名词的数" class="headerlink" title="名词的数"></a>名词的数</h2><ul><li><strong>名词的单数形式和复数形式</strong></li></ul><table><thead><tr><th>拼写规则</th><th>单数</th><th>复数</th></tr></thead><tbody><tr><td>一般情况下加<code>-s</code></td><td>cat</td><td>cats</td></tr><tr><td>以 -o, -x, -ch, -sh  结尾的加 <code>-es</code></td><td>potato <br> class <br> box <br> watch <br> brush</td><td>potatoes <br> classes <br> boxes <br> watches <br> brushes</td></tr><tr><td>以 辅音字母加 -y结尾，去-y加-ies <br> 元音字母加 -y 结尾的加 -s</td><td>country <br> boys</td><td>countries <br> boys</td></tr><tr><td>以 -y 结尾的专有名词加 -s</td><td>Fry</td><td>Frys</td></tr><tr><td>以 -f, -fe 结尾的名词， 把-f, -fe变为 -ves</td><td>wife</td><td>wives</td></tr><tr><td>不规则变化</td><td>man <br> sheep</td><td>men <br> sheep</td></tr></tbody></table><p><br></p><ul><li><strong>以 -o 结尾一般要在后面加 -es</strong></li></ul><p>但元音字母加 -o 结尾的名词则只能加 -s。</p><p><br></p><ul><li><strong>不规则拼写法</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foot/feet</span><br><span class="line">mouse/mice</span><br><span class="line">tooth/teeth</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>单/复数形式相同</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sheep</span><br><span class="line">deer</span><br><span class="line">aricraft</span><br><span class="line">Chinese</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="名词的性"><a href="#名词的性" class="headerlink" title="名词的性"></a>名词的性</h2><ul><li>阳性</li><li>阴性</li><li>中性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acrot(男演员)</span><br><span class="line">actress(女演员)</span><br><span class="line">guest(客人)</span><br></pre></td></tr></table></figure><p><br></p><p>有些名词可以不加思索的用阳性代词he、阴性代词she、中性代词it来指代。<br>表示动物性别相对的名词一般可用it指代。</p><p><br><br><br></p><h2 id="名词的格"><a href="#名词的格" class="headerlink" title="名词的格"></a>名词的格</h2><ul><li><strong>名词所有格的构成</strong></li></ul><table><thead><tr><th>说明</th><th>栗子</th></tr></thead><tbody><tr><td>单数名词末尾加<code>&#39;s</code></td><td>child’s</td></tr><tr><td>以 -s结尾的单数名词末尾加<code>&#39;s</code>或加<code>&#39;</code></td><td>actress’s/actress’</td></tr><tr><td>不规则的复数名词末尾加 <code>&#39;s</code></td><td>children’s</td></tr><tr><td>以-s结尾的复数名词末尾加 <code>&#39;</code></td><td>girls’</td></tr><tr><td>一些以 -s 结尾的人名末尾加 <code>&#39;s</code></td><td>James’s</td></tr></tbody></table><p><br></p><p>所有格一般表示人或事物的所属概念，通常可以回答<code>Whose...?</code>的问句。</p><p>通常来说<code>&#39;s/s&#39;</code>和<code>of</code>的作用是一样的，但<code>&#39;s/s&#39;</code>一般不和无生命的名词连用，而有生命的名词则两者通用。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="冠词"><a href="#冠词" class="headerlink" title="冠词"></a>冠词</h1><p>有若干个词可以用在名词或形容词+名词的前面，我们把这类词统称为限定词(determiners)，因为它们影响或限定着这个名词的意义。<br>冠词就是其中一种。</p><p><br><br><br></p><h2 id="限定词"><a href="#限定词" class="headerlink" title="限定词"></a>限定词</h2><p>限定词分为两种：</p><ul><li>有助于分类或确认的词</li><li>表数量的词</li></ul><p><br></p><h3 id="有助于分类或确认的词"><a href="#有助于分类或确认的词" class="headerlink" title="有助于分类或确认的词"></a>有助于分类或确认的词</h3><ul><li>不定冠词</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I bought &apos;a&apos; new shirt yesterday.</span><br><span class="line"></span><br><span class="line">&apos;A&apos; girl came in and put &apos;an&apos; envelope on his desk.</span><br></pre></td></tr></table></figure><p><br></p><ul><li>定冠词</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;The&apos; shirt I am wearing is new.</span><br></pre></td></tr></table></figure><p><br></p><ul><li>指示代词</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I bought &apos;this/that&apos; shirt yesterday.</span><br></pre></td></tr></table></figure><p><br></p><ul><li>物主代词</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;My&apos; shirt is blue.</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="表示数量的词"><a href="#表示数量的词" class="headerlink" title="表示数量的词"></a>表示数量的词</h3><ul><li>数词</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I bought &apos;two&apos; shirts yesterday.</span><br></pre></td></tr></table></figure><p><br></p><ul><li>量词</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I didn&apos;t buy &apos;many&apos; new shirts yesterday.</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="冠词的基本用法"><a href="#冠词的基本用法" class="headerlink" title="冠词的基本用法"></a>冠词的基本用法</h2><p>冠词分为：</p><ul><li>不定冠词(a/an)</li><li>定冠词(the)</li><li>零冠词</li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="代词"><a href="#代词" class="headerlink" title="代词"></a>代词</h1><p>代词是用来代替名词或名词短语的。</p><p>代词可分为：</p><ul><li>人称代词: I, me, he…</li><li>物主代词: my, their, yours…</li><li>反身代词: myself, herself, themselves…</li><li>指示代词: this, that, those…</li><li>不定代词: some, many, each, any, all…</li><li>疑问代词: what, which…</li><li>关系代词: which, who(m), as, that…</li><li>…</li></ul><p><br></p><h2 id="人称代词"><a href="#人称代词" class="headerlink" title="人称代词"></a>人称代词</h2><ul><li>主格人称代词在句子中一般用在谓语动词前面，充当句子的主语</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I think, therefore I am.</span><br></pre></td></tr></table></figure><p><br></p><ul><li>it也可以用来表示人，它一般表示要确认什么人，或在表示弄不清楚小孩儿的性别的时候</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There&apos;s a knock at the door. Who is &apos;it&apos;?</span><br></pre></td></tr></table></figure><p><br></p><ul><li>宾格人称代词可代替处于宾语位置上的名词，充当动词或介词的宾语。有些动词接两个宾语：直接宾语和间接宾语。直接宾语指动作的承受者，间接宾语指动作所向的人或物。间接宾语必须与直接宾语连用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I gave &apos;him&apos; a glass of water.</span><br><span class="line">#him 为间接宾语</span><br><span class="line">#a glass of water 为直接宾语</span><br></pre></td></tr></table></figure><p><br></p><ul><li>使用人称代词时无论主格还是宾格，都应考虑到其所处的具体位置，在系动词be后也可以使用宾格，但不强调</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Who is &apos;it&apos;?</span><br></pre></td></tr></table></figure><p><br></p><ul><li>当人称代词处于同位结构中时，应与其同位的部分保持一致。也就是说当其同位的部分为主语时，其同位代词也为主语(用主格)，而当其同位的部分为宾语时，所用代词也为宾语(用宾格)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Both Jack an &apos;I&apos; can swim very well.</span><br></pre></td></tr></table></figure><p><br></p><ul><li>有时候，尤其在口语中，宾格人称代词me也可用作主语</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Me/Not me!</span><br></pre></td></tr></table></figure><p><br></p><ul><li>注意祈使句中可用宾格人称代词作主语，起强调作用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">She&apos;s been promoted. Lucky &apos;her&apos;!</span><br></pre></td></tr></table></figure><p><br></p><ul><li>关于动物、东西和国家，人们通常将其人格化，这样它们也就具有了<strong>阴/阳性</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The cuckoo lays &apos;her&apos; eggs in other birds&apos; nests.</span><br></pre></td></tr></table></figure><p><br></p><ul><li>当我们谈论汽车、船、摩托及其它机械时，常常把它们看做阴性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My car&apos;s not fast, but &apos;she&apos; does 50 miles to the gallon.</span><br></pre></td></tr></table></figure><p><br></p><ul><li>国家通常也人格化，经常看成阴性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In 1941, America assumed &apos;her&apos; role as a world power.</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="不定代词"><a href="#不定代词" class="headerlink" title="不定代词"></a>不定代词</h2><ul><li>不定代词指的是some, any, no, every…以及与之组成的复合词<br>不定代词常常表示不确定的人、物或量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">someone, anyone, none, everyone</span><br><span class="line">somebody...</span><br><span class="line">something...</span><br></pre></td></tr></table></figure><p><br></p><ul><li>在表示一些时，some一般用于肯定陈述句中，而any则一般用于疑问句和否定句中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">There are &apos;some&apos; frogs in the pond.</span><br><span class="line"></span><br><span class="line">There aren&apos;t &apos;any&apos; frogs in the pod.</span><br></pre></td></tr></table></figure><p><br></p><ul><li>当表示建议或请求的时候，仍用some或something等</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Would you like &apos;something&apos; to drink?</span><br></pre></td></tr></table></figure><p><br></p><ul><li>any或anything用于陈述句的肯定形式的时候，表示泛指概念，指任何</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You can choose &apos;anything&apos; you like here.</span><br></pre></td></tr></table></figure><p><br></p><ul><li>复合不定代词(如something, anything)等的定语一般应后置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is &apos;something&apos; special.</span><br><span class="line"></span><br><span class="line">Is there &apos;anything&apos; for me to sit on?</span><br></pre></td></tr></table></figure><p><br></p><ul><li>当需要<strong>排除</strong>概念时，经常将else与不定代词连用，构成如下组合词，表示<strong>另外的，别的</strong>之意</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">everyone else, someone else, anyone else, anything else, nothing else...</span><br><span class="line"></span><br><span class="line">We need one more helper. Can you find &apos;anyone else&apos;?</span><br></pre></td></tr></table></figure><p><br></p><ul><li>指代a/an + 可数名词时，则必须用one作宾语</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Would you like a drink?</span><br><span class="line">I&apos;d love &apos;one&apos;. Thank you.</span><br></pre></td></tr></table></figure><p><br></p><ul><li>当不可数名词或复数名词用于非特指时，则必须使用some或any作宾语</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Have you got &apos;any&apos; sugar? Can you lend me &apos;some&apos;?</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="物主代词"><a href="#物主代词" class="headerlink" title="物主代词"></a>物主代词</h2><p>物主代词分为:</p><ul><li>形容词性物主代词(或所有格形容词)</li><li>名词性物主代词(或所有格代词)</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">形容词性:</span> <span class="string">my,</span> <span class="string">your,</span> <span class="string">his,</span> <span class="string">her,</span> <span class="string">its,</span> <span class="string">one's,</span> <span class="string">our,</span> <span class="string">your,</span> <span class="string">their</span></span><br><span class="line"><span class="string">名词性:</span> <span class="string">mine,</span> <span class="string">yours,</span> <span class="string">his,</span> <span class="string">hers,ours,</span> <span class="string">theirs</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>形容词性物主代词和名词性物主代词都表示所有，即某人或某物属于某个人，回答Whose…?的问题。形容词性物主代词是限定词，因此必须放在名词之前，不可单独使用。它们的形式取决于所有者，而不是被拥有的东西。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">John&apos;s daugther = his daugther</span><br><span class="line"></span><br><span class="line">Jane&apos;s son = her son</span><br><span class="line"></span><br><span class="line">the cat&apos;s milk = its milk</span><br></pre></td></tr></table></figure><p><br></p><p><strong>my, your, their可表示男性所有，也可表示女性所有。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;My house is there,&quot; Sally/John said.</span><br><span class="line"></span><br><span class="line">Your passports, please.</span><br></pre></td></tr></table></figure><p><br></p><p><strong>their也可表示动物或物品所有。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dogs should have their own kennels outside the house.</span><br><span class="line"></span><br><span class="line">Cars with their engines at the back are very noisy.</span><br></pre></td></tr></table></figure><p><br></p><p><strong>one’s 可用作非人称形容词性物主代词，但不能用作名词性物主代词。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One&apos;s first duty is to one&apos;s family.</span><br></pre></td></tr></table></figure><p><br></p><p><strong>所有格代词mine, yours不能用在名词之前，且在说话时要加重语气。它们在指人或物时，单数或复数都一样。its从来不作所有格代词用。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">There are my children. These children are mine.</span><br><span class="line"></span><br><span class="line">I can&apos;t find my pen. Can you lend me yours?</span><br></pre></td></tr></table></figure><p><br></p><p><strong>名词性所有格可以放在句首。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is my cup. Yours is the one ttat&apos;s chipped.</span><br></pre></td></tr></table></figure><p><br></p><p><strong>在特别强调所有关系时，通常用one’s own。可以在任何形容词性物主代词而不是名词性物主代词后面加上own，这样形成的词组既可以起形容词性物主代词的作用，也可以起名词性物主代词的作用。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I&apos;d love to have my own room / a room of my own.</span><br><span class="line"></span><br><span class="line">Our cat has its own corner / a corner of its own in this room.</span><br></pre></td></tr></table></figure><p><br></p><p><strong>如果需要再进一步强调则可以加上very。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I&apos;d love to have my very own room /a room of my very own.</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="反身代词"><a href="#反身代词" class="headerlink" title="反身代词"></a>反身代词</h2><p><strong>反身代词属于所有格形容词，其构成为”形容词性物主代词+self”组成的复合词，或”人称代词宾格+self”。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单数: myself, yourself, himself, herself, itself, oneself</span><br><span class="line">复数: ourselves, yourselves, themselves</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="指示代词"><a href="#指示代词" class="headerlink" title="指示代词"></a>指示代词</h2><p><strong>指示代词包括this, that, these, those。 其中， this, these为近指指示代词，与here对应； that, those为远指指示代词，与there对应。它们一般与名词连用。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this girl, that boy, these teachers, those students</span><br></pre></td></tr></table></figure><p><br></p><p><strong>通常来说，单独用指示代词时，不指人而指物；但在Who…?问句中，也可指人。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I found this watch. I found this.</span><br><span class="line"></span><br><span class="line">Who&apos;s this? Who&apos;s that?</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>数量词或数量词组常用来修饰名词，表示我们所说的事物的数与量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有些数量词修饰可数名词复数，如 many, (a) few, several...</span><br><span class="line"></span><br><span class="line">有些数量词修饰不可数名词，如 much, (a) little...</span><br><span class="line"></span><br><span class="line">有些两者皆可修饰，如 a lot of, lots of, some...</span><br></pre></td></tr></table></figure><p><br></p><p><strong>修饰可数名词时，用来回答How many…?</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">How many eggs are there in the fridge?</span><br><span class="line">There are a few.</span><br></pre></td></tr></table></figure><p><br></p><p><strong>数量词修饰不可数名词时，用来回答How much…?</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">How much milk is there in the fridge?</span><br><span class="line">There&apos;s a little.</span><br></pre></td></tr></table></figure><p><br></p><p><strong>两者皆可修饰，因此既能回答How many…? 也能回答How much…?</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">How many eggs are there in the fridge?</span><br><span class="line">There are plenty.</span><br><span class="line"></span><br><span class="line">How much milk is there in the fridge?</span><br><span class="line">There is plenty.</span><br></pre></td></tr></table></figure><p><br></p><p><strong>数量词+名词 的组合形式</strong></p><table><thead><tr><th>搭配形式分类</th><th>同类数量词</th></tr></thead><tbody><tr><td>数量词+复数可数名词 <br> 如: many books</td><td>both, a couple of, hundreds of, (a) few, a number of, serval …</td></tr><tr><td>数量词+不可数名词 <br> 如: much sugar</td><td>a amount of, a bit of, a drop of, a deal of, (a) little of …</td></tr><tr><td>数量词+复数可数名词,不可数名词 <br> 如: some books, some sugar</td><td>some, any, all, hardly, a lot of, lots of, the other …</td></tr><tr><td>数量词+单数可数名词 <br> 如: each book</td><td>another, each, either, the other, some, the whole …</td></tr></tbody></table><p><br><br><br></p><h2 id="不是不确定的数量"><a href="#不是不确定的数量" class="headerlink" title="不是不确定的数量"></a>不是不确定的数量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#数量可以是确定的，也就是可确切地说出到底有多少</span><br><span class="line">We need six eggs and half a kilo of butter.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#更多的时候，数量是不确定的，它只说明了一个大致的情况</span><br><span class="line">Are there (any) apples in the bag?</span><br><span class="line"></span><br><span class="line">There is some milk in the fridge.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#数量词后常和more连用</span><br><span class="line">I&apos;d like some more chips</span><br><span class="line"></span><br><span class="line">I&apos;d like some more milk.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#数量词后也常和less连用</span><br><span class="line">Much less soup, please.</span><br><span class="line"></span><br><span class="line">I want mush less, please.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#数量词前用not</span><br><span class="line">Not enough is known about this subject.</span><br><span class="line"></span><br><span class="line">It has given not a little trouble.</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="数词的分类"><a href="#数词的分类" class="headerlink" title="数词的分类"></a>数词的分类</h2><p>数词可分为:</p><ul><li>基数词</li><li>序数词</li><li>分数</li><li>小数</li><li>百分数</li><li>…</li></ul><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#基数词</span><br><span class="line">one, two, three...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#序数词</span><br><span class="line">first, sixth, tenth...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#分数</span><br><span class="line">#英语中分数的构成为: 一个基数词加一个序数词</span><br><span class="line"></span><br><span class="line">#分子为1时，分母直接使用序数词；分子大于1时，分母序数词+s</span><br><span class="line">one third, nine sixteenths</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#小数</span><br><span class="line">0.5, nought point five, point five</span><br><span class="line">2.5, two point five</span><br><span class="line">2.05, two nought five, two point o five</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#百分数</span><br><span class="line">8%, eight percent</span><br><span class="line">99%, ninety-nine percent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#近似的数量</span><br><span class="line">about, almost, exactly, fewer than, at least, less than, nearly ...</span><br><span class="line"></span><br><span class="line">There wrer over seventy people at the party.</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="not-no-none-little与bit等的区别"><a href="#not-no-none-little与bit等的区别" class="headerlink" title="not, no, none, little与bit等的区别"></a>not, no, none, little与bit等的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#not, no, none的区别</span><br><span class="line"></span><br><span class="line">#构成否定句的方式可以用not来否定动词，也可用no来否定后面的名词</span><br><span class="line">#none可以直接作为一个代词来用，而no则不可</span><br><span class="line"></span><br><span class="line">There aren&apos;t buses after midnight.</span><br><span class="line"></span><br><span class="line">There are no buses after midnight.</span><br><span class="line"></span><br><span class="line">Do you have any diaries? We&apos;ve got none at the moment.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考: 《新概念英语语法手册》&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&amp;lt;–more–&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;名词&quot;&gt;&lt;a href=&quot;#名词&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="English" scheme="https://zhang21.github.io/categories/English/"/>
    
    
      <category term="English" scheme="https://zhang21.github.io/tags/English/"/>
    
      <category term="Grammar" scheme="https://zhang21.github.io/tags/Grammar/"/>
    
  </entry>
  
  <entry>
    <title>国际音标</title>
    <link href="https://zhang21.github.io/2018/11/13/%E5%9B%BD%E9%99%85%E9%9F%B3%E6%A0%87/"/>
    <id>https://zhang21.github.io/2018/11/13/国际音标/</id>
    <published>2018-11-13T03:25:44.000Z</published>
    <updated>2018-11-13T10:02:31.590Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%8B%B1%E8%AA%9E%E5%9C%8B%E9%9A%9B%E9%9F%B3%E6%A8%99" target="_blank" rel="noopener">国际音标维基</a></li><li>巴士英语网: <a href="https://en-yinbiao.xiao84.com/yinbiaofayin/" target="_blank" rel="noopener">https://en-yinbiao.xiao84.com/yinbiaofayin/</a></li><li>知乎<code>@姜枣茶茶母</code>的回答: <a href="https://www.zhihu.com/question/19913374" target="_blank" rel="noopener">https://www.zhihu.com/question/19913374</a></li></ul><p><br><br><br></p><a id="more"></a><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>英语发音有多个国家的区别，我们重点了解两个：</p><ul><li>公认发音，英国标准（Received pronunciation, RP）</li><li>通用美式英语（General American, GA）</li></ul><p><br></p><p>国际音标(International Phonetic Alphabet，缩写：IPA)旁边的分隔号和括号并非音标的一部分，它们是语言专家用以分辨两个主要标音方法：音位标音和语音学标音。</p><p>48个国际音标通常是国内学生学习英语、学好英语发音必须掌握的发音基础，48个国际音标表也被称作48个音标表、48个英语音标表、48个英语国际英标表，48个国际英语音标表，这些称呼通常都是指48个英语国际英标表。<br>48个国际音标中有20个元音、28个辅音。</p><p><br></p><p><strong>元音</strong>，又称母音。</p><p>元音是在发音过程中由气流通过口腔而不受阻碍发出的音。<br>按前后分类为高 、中、低元音。<br>按音节分，可分为单元音和双元音。</p><p><br></p><p>气流在口腔或咽头受到阻碍而形成的音叫做<strong>辅音</strong>，辅音又叫子音。</p><p>共分为清辅音、浊辅音、鼻音、舌侧音 、半元音五种不同类型。<br>其中鼻音、舌侧音 、半元音为浊辅音。</p><p><br></p><p>英语元音和辅音在英语发音中扮演着重要的角色，英语元音和辅音组合起来就成为英语音标，共48个音位，是英语发音的基础。</p><p><br></p><p><img src="/images/English/IPA.jpg" alt="国际音标"></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="发音与技巧"><a href="#发音与技巧" class="headerlink" title="发音与技巧"></a>发音与技巧</h1><p>巴士英语网有每个音标的发音: <a href="https://en-yinbiao.xiao84.com/yinbiaofayin/" target="_blank" rel="noopener">https://en-yinbiao.xiao84.com/yinbiaofayin/</a></p><p><br></p><p>国际音标：</p><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>元音</td><td>单元音 <br><br> 双元音</td><td>前元音 <br> 中元音 <br> 后元音 <br> 开合双元音 <br> 集中双元音</td><td><code>/iː/</code>, <code>/ɪ/</code>, <code>/e/</code>, <code>/æ/</code> <br> <code>/ɜː/</code>, <code>/ə/</code>, <code>/ʌ/</code> <br> <code>/uː/</code>, <code>/ʊ/</code>, <code>/ɔː/</code>, <code>/ɒ/</code>, <code>/ɑː/</code> <br> <code>/eɪ/</code>, <code>/aɪ/</code>, <code>/ɔɪ/</code>, <code>/aʊ/</code>, <code>/əʊ/</code> <br> <code>/ɪə/</code>, <code>/eə/</code>, <code>/ʊə/</code></td></tr><tr><td>辅音</td><td>爆破音 <br><br> 摩擦音 <br><br> 破擦音 <br><br> 鼻音 <br> 舌则音 <br> 半元音</td><td>清辅音 <br> 浊辅音 <br> 清辅音 <br> 浊辅音 <br> 清辅音 <br> 浊辅音 <br> 浊辅音 <br> 浊辅音 <br> 浊辅音 <br></td><td><code>/p/</code>, <code>/t/</code>, <code>/k/</code> <br> <code>/b/</code>, <code>/d/</code>, <code>/ɡ/</code> <br> <code>/f/</code>, <code>/s/</code>, <code>/ʃ/</code>, <code>/θ/</code>, <code>/h/</code> <br> <code>/v/</code>, <code>/z/</code>, <code>/ʒ/</code>, <code>/ð/</code>, <code>/r/</code> <br> <code>/tʃ/</code>, <code>/tr/</code>, <code>/ts/</code> <br> <code>/dʒ/</code>, <code>/dr/</code>, <code>/dz/</code> <br> <code>/m/</code>, <code>/n/</code>, <code>/ŋ/</code> <br> <code>/l/</code> <br> <code>/j/</code>, <code>/w/</code></td></tr></tbody></table><p><br></p><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>元音20个</td><td>长元音 <br> 短元音 <br> 双元音</td><td><code>/iː/</code>, <code>/ɑː/</code>, <code>/ɔː/</code>, <code>/uː/</code>, <code>/ɜː/</code> <br> <code>/ɪ/</code>, <code>/ʌ/</code>, <code>/ɒ/</code>, <code>/ʊ/</code>, <code>/ə/</code>, <code>/æ/</code>, <code>/e/</code> <br> <code>/eɪ/</code>, <code>/aɪ/</code>, <code>/ɔɪ/</code>, <code>/ɪə/</code>, <code>/eə/</code>, <code>/ʊə/</code>, <code>/aʊ/</code>, <code>/əʊ/</code></td></tr><tr><td>辅音28个</td><td>轻辅音 <br> 浊辅音 <br> 轻辅音 <br> 浊辅音 <br> 鼻音 <br> 半元音 <br> 边音</td><td><code>/p/</code>, <code>/t/</code>, <code>/k/</code>, <code>/f/</code>, <code>/θ/</code>, <code>/s/</code> <br> <code>/b/</code>, <code>/d/</code>, <code>/ɡ/</code>, <code>/v/</code>, <code>/ð/</code>, <code>/z/</code> <br> <code>/ʃ/</code>, <code>/h/</code>, <code>/ts/</code>, <code>/tʃ/</code>, <code>/tr/</code> <br> <code>/ʒ/</code>, <code>/r/</code>, <code>/dz/</code>, <code>/dʒ/</code>, <code>/dr/</code> <br> <code>/m/</code>, <code>/n/</code>, <code>/ŋ/</code> <br> <code>/j/</code>, <code>/w/</code> <br> <code>/l/</code></td></tr></tbody></table><p><br><br><br><br><br></p><h2 id="知识点讲解"><a href="#知识点讲解" class="headerlink" title="知识点讲解"></a>知识点讲解</h2><p><strong>长短元音的区别在于——是否有<code>:</code></strong></p><ul><li>有，则拖长音节</li><li>无，则短促音结尾</li></ul><p><br></p><p><strong>双元音就是把两个单元音拼到一起</strong></p><p>发音也是两个拼到一起的，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/iə/= /i/ + /ə/</span><br><span class="line"></span><br><span class="line">/uə/= /u/ + /ə/</span><br><span class="line"></span><br><span class="line">/εə/= /e/ + /ə/</span><br></pre></td></tr></table></figure><p><br></p><p><strong>清浊辅音的区别在于——喉结是否震动</strong></p><ul><li>震动，浊辅音</li><li>不震动，清辅音</li></ul><p><br></p><p><strong>鼻音–鼻腔发出</strong></p><p><br><br><br><br><br></p><h2 id="难读的音标"><a href="#难读的音标" class="headerlink" title="难读的音标"></a>难读的音标</h2><p>易出问题的地方：</p><p><img src="/images/English/IPA_difficulty.jpg" alt=""></p><p><br></p><p><strong>核心技巧：</strong></p><ul><li>用中文的<strong>音近字</strong>代替</li><li>用简单的<strong>英文字母或单词</strong>进行备注</li></ul><p>中文字很挫，两种方法结合使用，哪个好记用哪个。</p><p><br><br><br></p><p><strong>元音</strong>部分发音讲解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ei/ ：A</span><br><span class="line">/ai/ ：I</span><br><span class="line">/ɔi/ ：“噢一”</span><br><span class="line">/iə/ : /i/ + /ə/ = ear</span><br><span class="line">/eə/ : /e/ + /ə/ = air</span><br><span class="line">/uə/ : /u/ + /ə/ = 污饿</span><br><span class="line">/əu/ ：O</span><br><span class="line">/au/ ：嗷（张大嘴）</span><br></pre></td></tr></table></figure><p><br><br><br></p><p><strong>辅音</strong>部分发音讲解：</p><p>第一组：<code>/s/, /z/</code> 和 <code>/θ/, /ð/</code><br>这两组发音听起来差不多，唯一的区别在于：舌头是否看得见</p><ul><li>看不见，<code>/s/, /z/</code></li><li>看得见，<code>/θ/, /ð/</code></li></ul><p><br></p><p>第二组：<code>/ʃ/, /ʒ/</code> <strong>“屎” “日”</strong></p><p>第三组：<code>/h/, /r/</code> <strong>“喝” “弱”</strong></p><p>第四组：<code>/ts/, /dz/</code> <strong>“此” “滋”</strong></p><p>第五组：<code>/tʃ/, /dʒ/</code> <strong>“尺” “之”</strong></p><p>第六组：<code>/tr/, /dr/</code> <strong>“戳” “捉”</strong></p><p>第七组：<code>/m/, /n/, /ŋ/</code> 都是发<strong>“嗯”</strong>的音，只是嘴型大小不一样。</p><ul><li><code>/m/</code>, 闭紧</li><li><code>/n/</code>, 半张开</li><li><code>/ŋ/</code>, 张大嘴</li></ul><p><br></p><p>第八组：<code>/l/</code><br>这个音最难发，因为声音有点奇怪，像大舌头。发音技巧在于，把舌尖抵在上门牙底端，然后自然发出声音，就是这个音标啦。</p><p><br><br><br></p><p><strong>知识点讲解</strong></p><p><code>/m/, /n/, /l/</code> 分别有两个发音，一个是上面讲解的发音，另一个是他们的本来音，即英文字母m/n/l的发音（么，讷，勒）。</p><ul><li>本身发音： 出现在每个音节的开头</li><li>奇怪音： 出现在每个音节的中间</li></ul><p><br><br><br><br><br></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>自己找单词书进行测试和练习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%8B%B1%E8%AA%9E%E5%9C%8B%E9%9A%9B%E9%9F%B3%E6%A8%99&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;国际音标维基&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;巴士英语网: &lt;a href=&quot;https://en-yinbiao.xiao84.com/yinbiaofayin/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://en-yinbiao.xiao84.com/yinbiaofayin/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;知乎&lt;code&gt;@姜枣茶茶母&lt;/code&gt;的回答: &lt;a href=&quot;https://www.zhihu.com/question/19913374&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/19913374&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://zhang21.github.io/categories/English/"/>
    
    
      <category term="English" scheme="https://zhang21.github.io/tags/English/"/>
    
      <category term="国际音标" scheme="https://zhang21.github.io/tags/%E5%9B%BD%E9%99%85%E9%9F%B3%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>劳动法</title>
    <link href="https://zhang21.github.io/2018/10/26/%E5%8A%B3%E5%8A%A8%E6%B3%95/"/>
    <id>https://zhang21.github.io/2018/10/26/劳动法/</id>
    <published>2018-10-25T17:01:44.000Z</published>
    <updated>2018-10-25T18:39:34.264Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>中华人民共和国劳动法（2009年修正本）</li></ul><p><br><br><br></p><a id="more"></a><p><br><br><br></p><p>《中华人民共和国劳动法》是为了保护劳动者的合法权益，调整劳动关系，建立和维护适应社会主义市场经济的劳动制度，促进经济发展和社会进步，根据宪法，制定本法。1994年7月5日第八届全国人民代表大会常务委员会第八次会议通过，自1995年1月1日起施行。</p><p>（1994年7年5日第八届全国人民代表大会常务委员会第八次会议通过　1994年7月5日中华人民共和国主席令第28号公布 根据2009年8月27日中华人民共和国主席令第18号《全国人民代表大会常务委员会关于修改部分法律的决定》修正 自公布之日起施行）</p><p><br><br><br></p><h1 id="总则"><a href="#总则" class="headerlink" title="总则"></a>总则</h1><p>第一条： 为了保护劳动者的合法权益，调整劳动关系，建立和维护适应社会主义市场经济的劳动制度，促进经济发展和社会进步，根据宪法，制定本法。</p><p><br></p><p>第二条： 在中华人民共和国境内的企业、个体经济组织（以下统称用人单位）和与之形成劳动关系的劳动者，适用本法。</p><p>国家机关、事业组织、社会团体和与之建立劳动合同关系的劳动者，依照本法执行。</p><p><br></p><p>第三条: 劳动者享有平等就业和选择职业的权利、取得劳动报酬的权利、休息休假的权利、获得劳动安全卫生保护的权利、接受职业技能培训的权利、享受社会保险和福利的权利、提请劳动争议处理的权利以及法律规定的其他劳动权利。</p><p>劳动者应当完成劳动任务，提高职业技能，执行劳动安全卫生规程，遵守劳动纪律和职业道德。</p><p><br></p><p>第四条: 用人单位应当依法建立和完善规章制度，保障劳动者享有劳动权利和履行劳动义务。</p><p><br></p><p>第五条: 国家采取各种措施，促进劳动就业，发展职业教育，制定劳动标准，调节社会收人，完善社会保险，协调劳动关系，逐步提高劳动者的生活水平。</p><p><br></p><p>第六条: 国家提倡劳动者参加社会义务劳动，开展劳动竞赛和合理化建议活动，鼓励和保护劳动者进行科学研究、技术革新和发明创造，表彰和奖励劳动模范和先进工作者。</p><p><br></p><p>第七条: 劳动者有权依法参加和组织工会。</p><p>工会代表和维护劳动者的合法权益，依法独立自主地开展活动。</p><p><br></p><p>第八条: 劳动者依照法律规定，通过职工大会、职工代表大会或者其他形式，参与民主管理或者就保护劳动者合法权益与用人单位进行平等协商。</p><p><br></p><p>第九条: 国务院劳动行政部门主管全国劳动工作。</p><p>县级以上地方人民政府劳动行政部门主管本行政区域内的劳动工作。</p><p><br><br><br><br><br></p><h1 id="促进就业"><a href="#促进就业" class="headerlink" title="促进就业"></a>促进就业</h1><p>第十条: 国家通过促进经济和社会发展，创造就业条件，扩大就业机会。</p><p>国家鼓励企业、事业组织、社会团体在法律、行政法规规定的范围内兴办产业或者拓展经营，增加就业。<br>国家支持劳动者自愿组织起来就业和从事个体经营实现就业。</p><p><br></p><p>第十一条: 地方各级人民政府应当采取措施，发展多种类型的职业介绍机构，提供就业服务。</p><p><br></p><p>第十二条: 劳动者就业，不因民族、种族、性别、宗教信仰不同而受歧视。</p><p><br></p><p>第十三条: 妇女享有与男子平等的就业权利，在录用职工时，除国家规定的不适合妇女的工种或者岗位外，不得以性别为由拒绝录用妇女或者提高对妇女的录用标准。</p><p><br></p><p>第十四条: 残疾人、少数民族人员、退出现役的军人的就业，法律、法规有特别规定的，从其规定。</p><p><br></p><p>第十五条: 禁止用人单位招用未满十六周岁的未成年人。</p><p>文艺、体育和特种工艺单位招用未满十六周岁的未成年人，必须依照国家有关规定，履行审批手续，并保障其接受义务教育的权利。</p><p><br><br><br><br><br></p><h1 id="劳动合同和集体合同"><a href="#劳动合同和集体合同" class="headerlink" title="劳动合同和集体合同"></a>劳动合同和集体合同</h1><p>第十六条: 劳动合同是劳动者与用人单位确立劳动关系、明确双方权利和义务的协议。</p><p>建立劳动关系应当订立劳动合同。</p><p><br></p><p>第十七条: 订立和变更劳动合同，应当遵循平等自愿、协商一致的原则，不得违反法律、行政法规的规定。</p><p>劳动合同依法订立即具有法律约束力，当事人必须履行劳动合同规定的义务。</p><p><br></p><p>第十八条: 下列劳动合同无效：<br>（一）违反法律、行政法规的劳动合同；<br>（二）采取欺诈、威胁等手段订立的劳动合同。</p><p>无效的劳动合同，从订立的时候起，就没有法律约束力。确认劳动合同部分无效的，如果不影响其余部分的效力，其余部分仍然有效。<br>劳动合同的无效，由劳动争仪仲裁委员会或者人民法院确认。</p><p><br></p><p>第十九条: 劳动合同应当以书面形式订立，并具备以下条款：<br>（一）劳动合同期限；<br>（二）工作内容；<br>（三）劳动保护和劳动条件；<br>（四）劳动报酬；<br>（五）劳动纪律；<br>（六）劳动合同终止的条件；<br>（七）违反劳动合同的责任。</p><p>劳动合同除前款规定的必备条款外，当事人可以协商约定其他内容。</p><p><br></p><p>第二十条: 劳动合同的期限分为有固定期限、无固定期限和以完成一定的工作为期限。</p><p>劳动者在同一用人单位连续工作满十年以上，当事人双方同意续延劳动合同的，如果劳动者提出订立无固定期限的劳动合同，应当订立无固定期限的劳动合同。</p><p><br></p><p>第二十一条: 劳动合同可以约定试用期。试用期最长不得超过六个月。</p><p><br></p><p>第二十二条: 劳动合同当事人可以在劳动合同中约定保守用人单位商业秘密的有关事项。</p><p><br></p><p>第二十三条: 劳动合同期满或者当事人约定的劳动合同终止条件出现，劳动合同即行终止。</p><p><br></p><p>第二十四条: 经劳动合同当事人协商一致，劳动合同可以解除。</p><p><br></p><p>第二十五条: 劳动者有下列情形之一的，用人单位可以解除劳动合同：<br>（一）试用期间被证明不符合录用条件的；<br>（二）严重违反劳动纪律或者用人单位规章制度的；<br>（三）严重失职，营私舞弊，对用人单位利益造成重大损害的；<br>（四）被依法追究刑事责任的。</p><p><br></p><p>第二十六条： 有下列情形之一的，用人单位可以解除劳动合同，但是应当提前三十日以书面形式通知劳动者本人：<br>（一）劳动者患病或者非因工负伤，医疗期满后，不能从事原工作也不能从事由用人单位另行安排的工作的；<br>（二）劳动者不能胜任工作，经过培训或者调整工作岗位，仍不能胜任工作的。<br>（三）劳动合同订立时所依据的客观情况发生重大变化，致使原劳动合同无法履行，经当事人协商不能就变更劳动合同达成协议的。</p><p><br></p><p>第二十七条: 用人单位濒临破产进行法定整顿期间或者生产经营状况发生严重困难，确需裁减人员的，应当提前三十日向工会或者全体职工说明情况，听取工会或者职工的意见，经向劳动行政部门报告后，可以裁减人员。</p><p>用人单位依据本条规定裁减人员，在六个月内录用人员的，应当优先录用被裁减的人员。</p><p><br></p><p>第二十八条: 用人单位依据本法第二十四条、第二十六条、第二十七条的规定解除劳动合同的，应当依照国家有关规定给予经济补偿。</p><p><br></p><p>第二十九条: 劳动者有下列情形之一的，用人单位不得依据本法第二十六条、第二十七条的规定解除劳动合同：<br>（一）患职业病或者因工负伤并被确认丧失或者部分丧失劳动能力的；<br>（二）患病或者负伤，在规定的医疗期内的；<br>（三）女职工在孕期、产期、哺乳期内的；<br>（四）法律、行政法规规定的其他情形。</p><p><br></p><p>第三十条: 用人单位解除劳动合同，工会认为不适当的，有权提出意见。如果用人单位违反法律、法规或者劳动合同，工会有权要求重新处理；劳动者申请仲裁或者提起诉讼的，工会应当依法给予支持和帮助。</p><p><br></p><p>第三十一条: 劳动者解除劳动合同，应当提前三十日以书面形式通知用人单位。</p><p><br></p><p>第三十二条: 有下列情形之一的，劳动者可以随时通知用人单位解除劳动合同：<br>（一）在试用期内的；<br>（二）用人单位以暴力、威胁或者非法限制人身自由的手段强迫劳动的；<br>（三）用人单位未按照劳动合同约定支付劳动报酬或者提供劳动条件的。</p><p><br></p><p>第三十三条: 企业职工一方与企业可以就劳动报酬、工作时间、休息休假、劳动安全卫生、保险福利等事项，签订集体合同。集体合同草案应当提交职工代表大会或者全体职工讨论通过。</p><p>集体合同由工会代表职工与企业签订；没有建立工会的企业，由职工推举的代表与企业签订。</p><p><br></p><p>第三十四条: 集体合同签订后应当报送劳动行政部门；劳动行政部门自收到集体合同文本之日起十五日内未提出异议的，集体合同即行生效。</p><p><br></p><p>第三十五条: 依法签订的集体合同对企业和企业全体职工具有约束力，职工个人与企业订立的劳动合同中劳动条件和劳动报酬等标准不得低于集体合同的规定。</p><h1 id="工资"><a href="#工资" class="headerlink" title="工资"></a>工资</h1><p>第三十六条: 国家实行劳动者每日工作时间不超过八小时、平均每周工作时间不超过四十四小时的工时制度。</p><p><br></p><p>第三十七条: 对实行计件工作的劳动者，用人单位应当根据本法第三十六条规定的工时制度合理确定其劳动定额和计件报酬标准。</p><p><br></p><p>第三十八条: 用人单位应当保证劳动者每周至少休息一日。</p><p><br></p><p>第三十九条: 企业因生产特点不能实行本法第三十六条、第三十八条规定的，经劳动部门批准，可以实行其他工作和休息办法。</p><p><br></p><p>第四十条: 用人单位在下列节日期间应当依法安排劳动者休假：<br>（一）元旦；<br>（二）春节；<br>（三）国际劳动节；<br>（四）国庆节；<br>（五）法律、法规规定的其他休假节日。</p><p><br></p><p>第四十一条: 用人单位由于生产经营需要，经与工会和劳动者协商后可以延长工作时间，一般每日不得超过一小时；因特殊原因需要延长工作时间的，在保障劳动者身体健康的条件下延长工作时间每日不得超过三小时，但是每月不得超过三十六小时。</p><p><br></p><p>第四十二条: 有下列情形之一的，延长工作时间不受本法第四十一条规定的限制：<br>（一）发生自然灾害、事故或者因其他原因，威胁劳动者生命健康和财产安全，需要紧急处理的；<br>（二）生产设备、交通运输线路、公共设施发生故障，影响生产和公众利益，必须及时抢修的；<br>（三）法律、行政法规规定的其他情形。</p><p><br></p><p>第四十三条: 用人单位不得违反本法规定延长劳动者的工作时间。</p><p><br></p><p>第四十四条: 有下列情形之一的，用人单位应当按照下列标准支付高于劳动者正常工作时间工资的工资报酬；<br>（一）安排劳动者延长工作时间的，支付不低于工资的百分之一百五十的工资报酬；<br>（二）休息日安排劳动者工作又不能安排补休的，支付不低于工资的百分之二百的工资报酬；<br>（三）法定休假日安排劳动者工作的，支付不低于工资的百分之三百的工资报酬。</p><p><br></p><p>第四十五条: 国家实行带薪年休假制度。</p><p>劳动者连续工作一年以上的，享受带薪年休假。具体办法由国务院规定。</p><p><br></p><p>第四十六条: 工资分配应当遵循按劳分配原则，实行同工同酬。</p><p>工资水平在经济发展的基础上逐步提高。国家对工资总量实行宏观调控。</p><p><br></p><p>第四十七条: 用人单位根据本单位的生产经营特点和经济效益，依法自主确定本单位的工资分配方式和工资水平。</p><p><br></p><p>第四十八条: 国家实行最低工资保障制度。最低工资的具体标准由各省、自治区直辖市人民政府规定，报国务院备案。</p><p>用人单位支付劳动者的工资不得低于当地最低工资标准。</p><p><br></p><p>第四十九条: 确定和调整最低工资标准应当综合参考下列因素：<br>（一）劳动者本人及平均赡养人口的最低生活费用；<br>（二）社会平均工资水平；<br>（三）劳动生产率；<br>（四）就业状况；<br>（五）地区之间经济发展水平的差异。</p><p><br></p><p>第五十条: 工资应当以货币形式按月支付给劳动者本人。不得克扣或者无故拖欠劳动者的工资。</p><p><br></p><p>第五十一条: 劳动者在法定休假日和婚丧假期间以及依法参加社会活动期间，用人单位应当依法支付工资。</p><p><br><br><br><br><br></p><h1 id="劳动安全卫生"><a href="#劳动安全卫生" class="headerlink" title="劳动安全卫生"></a>劳动安全卫生</h1><p>第五十二条: 用人单位必须建立、健全劳动安全卫生制度，严格执行国家劳动安全卫生规程和标准，对劳动者进行劳动安全卫生教育，防止劳动过程中的事故，减少职业危害。</p><p><br></p><p>第五十三条: 劳动安全卫生设施必须符合国家规定的标准。</p><p>新建、改建、扩建工程的劳动安全卫生设施必须与主体工程同时设计、同时施工、同时投入生产和使用。</p><p><br></p><p>第五十四条: 用人单位必须为劳动者提供符合国家规定的劳动安全卫生条件和必要的劳动防护用品，对从事有职业危害作业的劳动者应当定期进行健康检查。</p><p><br></p><p>第五十五条: 从事特种作业的劳动者必须经过专门培训并取得特种作业资格。</p><p><br></p><p>第五十六条: 劳动者在劳动过程中必须严格遵守安全操作规程。</p><p>劳动者对用人单位管理人员违章指挥、强令冒险作业，有权拒绝执行；对危害生命安全和身体健康的行为，有权提出批评、检举和控告。</p><p><br></p><p>第五十七条: 国家建立伤亡事故和职业病统计报告和处理制度。县级以上各级人民政府劳动行政部门、有关部门和用人单位应当依法对劳动者在劳动过程中发生的伤亡事故和劳动者　的职业病状况，进行统计、报告和处理。</p><p><br><br><br><br><br></p><h1 id="女职工和未成年工特殊保护"><a href="#女职工和未成年工特殊保护" class="headerlink" title="女职工和未成年工特殊保护"></a>女职工和未成年工特殊保护</h1><p>第五十八条: 国家对女职工和未成年工实行特殊劳动保护。</p><p>未成年工是指年满十六周岁未满十八周岁的劳动者。</p><p><br></p><p>第五十九条: 禁止安排女职工从事矿山井下、国家规定的第四级体力劳动强度的劳动和其他禁忌从事的劳动。</p><p><br></p><p>第六十条: 不得安排女职工在经期从事高处、低温、冷水作业和国家规定的第三级体力劳动强度的劳动。</p><p><br></p><p>第六十一条: 不得安排女职工在怀孕期间从事国家规定的第三级体力劳动强度的劳动和孕期禁忌从事的劳动，对怀孕七个月以上的女职工，不得安排其延长工作时间和夜班劳动。</p><p><br></p><p>第六十二条: 女职工生育享受不少于九十天的产假。</p><p><br></p><p>第六十三条: 不得安排女职工在哺乳未满一周岁的婴儿期间从事国家规定的第三级体力劳动强度的劳动和哺乳期禁忌从事的其他劳动，不得安排其延长工作时间和夜班劳动。</p><p><br></p><p>第六十四条: 不得安排未成年工从事矿山井下、有毒有害、国家规定的第四级体力劳动强度的劳动和其他禁忌从事的劳动。</p><p><br></p><p>第六十五条: 用人单位应当对未成年工定期进行健康检查。</p><p><br><br><br><br><br></p><h1 id="职业培训"><a href="#职业培训" class="headerlink" title="职业培训"></a>职业培训</h1><p>第六十六条: 国家通过各种途径，采取各种措施，发展职业培训事业，开发劳动者的职业技能，提高劳动者素质，增强劳动者的就业能力和工作能力。</p><p><br></p><p>第六十七条: 各级人民政府应当把发展职业培训纳入社会经济发展的规划，鼓励和支持有条件的企业、事业组织、社会团体和个人进行各种形式的职业培训。</p><p><br></p><p>第六十八条: 用人单位应建立职业培训制度，按照国家规定提取和使用职业培训经费，根据本单位实际，有计划地对劳动者进行职业培训。</p><p>从事技术工种的劳动者，上岗前必须经过培训。</p><p><br></p><p>第六十九条: 国家确定职业分类，对规定的职业制定职业技能标准，实行职业资格证书制度，由经过政府批准的考核鉴定机构负责对劳动者实施职业技能考核鉴定。</p><p><br><br><br><br><br></p><h1 id="社会保险和福利"><a href="#社会保险和福利" class="headerlink" title="社会保险和福利"></a>社会保险和福利</h1><p>第七十条: 国家发展社会保险事业，建立社会保险制度，设立社会保险基金，使劳动者在年老、患病、工伤、失业、生育等情况下获得帮助和补偿。</p><p><br></p><p>第七十一条: 社会保险水平应当与社会经济发展水平和社会承受能力相适应。</p><p><br></p><p>第七十二条: 社会保险基金按照保险类型确定资金来源，逐步实行社会统筹。用人单位和劳动者必须依法参加社会保险，缴纳社会保险费。</p><p><br></p><p>第七十三条: 劳动者在下列情形下，依法享受社会保险待遇：<br>（一）退休；<br>（二）患病、负伤；<br>（三）因工伤残或者患职业病；<br>（四）失业；<br>（五）生育。</p><p>劳动者死亡后，其遗属依法享受遗属津贴。<br>劳动者享受社会保险待遇的条件和标准由法律、法规规定。<br>劳动者享受的社会保险金必须按时足额支付。</p><p><br></p><p>第七十四条: 社会保险基金经办机构依照法律规定收支、管理和运营社会保险基金，并负有使社会保险基金保值增值的责任。</p><p>社会保险基金监督机构依照法律规定、对社会保险基金的收支、管理和运营实施监督。<br>社会保险基金经办机构和社会保险基金监督机构的设立和职能由法律规定。<br>任何组织和个人不得挪用社会保险基金。</p><p><br></p><p>第七十五条: 国家鼓励用人单位根据本单位实际情况为劳动者建立补充保险。</p><p>国家提倡劳动者个人进行储蓄性保险。</p><p><br></p><p>第七十六条: 国家发展社会福利事业，兴建公共福利设施、为劳动者休息、休养和疗养提供条件。</p><p>用人单位应当创造条件，改善集体福利，提高劳动者的福利待遇。</p><p><br><br><br><br><br></p><h1 id="劳动争议"><a href="#劳动争议" class="headerlink" title="劳动争议"></a>劳动争议</h1><p>第七十七条: 用人单位与劳动者发生劳动争议，当事人可以依法申请调解、仲裁、提起诉讼，也可以协商解决。</p><p>调解原则适用于仲裁和诉讼程序。</p><p><br></p><p>第七十八条: 解决劳动争议、应当根据合法、公正、及时处理的原则，依法维护劳动争议当事人的合法权益。</p><p><br></p><p>第七十九条: 劳动争议发生后，当事人可以向本单位劳动争议调解委员会申请调解；调解不成，当事人一方要求仲裁的，可以向劳动争议仲裁委员会申请仲裁。当事人一方也可以直接向劳动争议仲裁委员会申请仲裁。对仲裁裁决不服的，可以向人民法院提起诉讼。</p><p><br></p><p>第八十条: 在用人单位内，可以设立劳动争议调解委员会。劳动争议调解委员会由职工代表、用人单位代表和工会代表组成。劳动争议调解委员会主任由工会代表担任。</p><p>劳动争议经调解达成协议的，当事人应当履行。</p><p><br></p><p>第八十一条: 劳动争议仲裁委员会由劳动行政部门代表、同级工会代表、用人单位方面的代表组成，劳动争议仲裁委员会主任由劳动行政部门代表担任。</p><p><br></p><p>第八十二条: 提出仲裁要求的一方应当自劳动争议发生之日起六十日内向劳动争议仲裁委员会提出书面申请。仲裁裁决一般应在收到仲裁申请的六十日内作出。对仲裁裁决无异议的，当事人必须履行。</p><p><br></p><p>第八十三条: 劳动争议当事人对仲裁裁决不服的，可以自收到仲裁裁决书之日起十五日内向人民法院提起诉讼。一方当事人在法定期限内不起诉又不履行仲裁裁决的，另一方当事人可以申请人民法院强制执行。</p><p><br></p><p>第八十四条: 因签订集体合同发生争议，当事人协商解决不成的，当地人民政府劳动行政部门可以组织有关各方协调处理。</p><p>因履行集体合同发生争议，当事人协商解决不成的，可以向劳动争议仲裁委员会申请仲裁；对仲裁裁决不服的，可以自收到仲裁裁决书之日起十五日内向人民法院提起诉讼。</p><p><br><br><br><br><br></p><h1 id="监督检查"><a href="#监督检查" class="headerlink" title="监督检查"></a>监督检查</h1><p>第八十五条: 县级以上各级人民政府劳动行政部门依法对用人单位遵守劳动法律、法规的情况进行监督检查，对违反劳动法律、法规的行为有权制止，并责令改正。</p><p><br></p><p>第八十六条: 县级以上各级人民政府劳动行政部门监督检查人员执行公务，有权进入用人单位了解执行劳动法律、法规的情况，查阅必要的资料，并对劳动场所进行检查。</p><p>县级以上各级人民政府劳动行政部门监督检查人员执行公务，必须出示证件，秉公执法并遵守有关规定。</p><p><br></p><p>第八十七条: 县级以上各级人民政府有关部门在各自职责范围内，对用人单位遵守劳动法律、法规的情况进行监督。</p><p><br></p><p>第八十八条: 各级工会依法维护劳动者的合法权益，对用人单位遵守劳动法律、法规的情况进行监督。</p><p>任何组织和个人对于违反劳动法律、法规的行为有权检举和控告。</p><p><br><br><br><br><br></p><h1 id="法律责任"><a href="#法律责任" class="headerlink" title="法律责任"></a>法律责任</h1><p>第八十九条: 用人单位制定的劳动规章制度违反法律、法规规定的，由劳动行政部门给予警告，责令改正；对劳动者造成损害的，应当承担赔偿责任。</p><p><br></p><p>第九十条: 用人单位违反本法规定，延长劳动者工作时间的，由劳动行政部门给予警告，责令改正，并可以处以罚款。</p><p><br></p><p>第九十一条: 用人单位有下列侵害劳动者合法权益情形之一的，由劳动行政部门责令支付劳动者的工资报酬、经济补偿，并可以责令支付赔偿金：<br>（一）克扣或者无故拖欠劳动者工资的；<br>（二）拒不支付劳动者延长工作时间工资报酬的；<br>（三）低于当地最低工资标准支付劳动者工资的；<br>（四）解除劳动合同后，未依照本法规定给予劳动者经济补偿的。</p><p><br></p><p>第九十二条: 用人单位的劳动安全设施和劳动卫生条件不符合国家规定或者未向劳动者提供必要的劳动防护用品和劳动保护设施的，由劳动行政部门或者有关部门责令改正，可以处以罚款；情节严重的，提请县级以上人民政府决定责令停产整顿；对事故隐患不采取措施，致使发生重大事故，造成劳动者生命和财产损失的，对责任人员比照刑法第一百八十七条的规定追究刑事责任。</p><p><br></p><p>第九十三条: 用人单位强令劳动者违章冒险作业、发生重大伤亡事故，造成严重后果的，对责任人员依法追究刑事责任。</p><p><br></p><p>第九十四条: 用人单位非法招用未满十六周岁的未成年人的，由劳动行政部门责令改正，处以罚款；情节严重的，由工商行政管理部门吊销营业执照。</p><p><br></p><p>第九十五条: 用人单位违反本法对女职工和未成年工的保护规定，侵害其合法权益的，由劳动行政部门责令改正，处以罚款；对女职工或者未成年工造成损害的，应当承担赔偿责任。</p><p><br></p><p>第九十六条: 用人单位有下列行为之一，由公安机关对责任人员处以十五日以下拘留、罚款或者警告；构成犯罪的，对责任人员依法追究刑事责任：</p><p>（一）以暴力、威胁或者非法限制人身自由的手段强迫劳动的。<br>（二）侮辱、体罚、殴打、非法搜查和拘禁劳动者的。</p><p><br></p><p>第九十七条: 由于用人单位的原因订立的无效合同，对劳动者造成损害的，应当承担赔偿责任。</p><p><br></p><p>第九十八条: 用人单位违反本法规定的条件解除劳动合同或者故意拖延不订立劳动合同的，由劳动行政部门责令改正；对劳动者造成损害的，应当承担赔偿责任。</p><p><br></p><p>第九十九条: 用人单位招用尚未解除劳动合同的劳动者，对原用人单位造成经济损失的，该用人单位应当依法承担连带赔偿责任。</p><p><br></p><p>第一百条: 用人单位无故不缴纳社会保险费的，由劳动行政部门责令其限期缴纳，逾期不缴的，可以加收滞纳金。</p><p><br></p><p>第一百零一条: 用人单位无理阻挠劳动行政部门、有关部门及其工作人员行使监督检查权，打击报复举报人员的，由劳动行政部门或者有关部门处以罚款；构成犯罪的，对责任人员依法追究刑事责任。</p><p><br></p><p>第一百零二条: 劳动者违反本法规定的条件解除劳动合同或者违反劳动合同中约定的保密事项，对用人单位造成经济损失的，应当依法承担赔偿责任。</p><p><br></p><p>第一百零三条: 劳动行政部门或者有关部门的工作人员滥用职权、玩忽职守、徇私舞弊、构成犯罪的，依法追究刑事责任；不构成犯罪的，给予行政处分。</p><p><br></p><p>第一百零四条:国家工作人员和社会保险基金经办机构的工作人员挪用社会保险基金，构成犯罪的，依法追究刑事责任。</p><p><br></p><p>第一百零五条: 违反本法规定侵害劳动者合法权益，其他法律、行政法规已规定处罚的，依照该法律、行政法规的规定处罚。</p><p><br><br><br><br><br></p><h1 id="附则"><a href="#附则" class="headerlink" title="附则"></a>附则</h1><p>第一百零六条: 省、自治区、直辖市人民政府根据本法和本地区的实际情况，规定劳动合同制度的实施步骤，报国务院备案。</p><p><br></p><p>第一百零七条: 本法自1995年1月1日起施行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中华人民共和国劳动法（2009年修正本）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="法律" scheme="https://zhang21.github.io/categories/%E6%B3%95%E5%BE%8B/"/>
    
    
      <category term="劳动法" scheme="https://zhang21.github.io/tags/%E5%8A%B3%E5%8A%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>劳动合同法</title>
    <link href="https://zhang21.github.io/2018/10/26/%E5%8A%B3%E5%8A%A8%E5%90%88%E5%90%8C%E6%B3%95/"/>
    <id>https://zhang21.github.io/2018/10/26/劳动合同法/</id>
    <published>2018-10-25T17:01:33.000Z</published>
    <updated>2018-10-25T18:45:25.204Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>全国人民代表大会常务委员会关于修改《中华人民共和国劳动合同法》的决定（附2012年修正本）</li></ul><p><br></p><p>网址：</p><ul><li>中华人民共和国中央人民政府： <a href="http://www.gov.cn/" target="_blank" rel="noopener">http://www.gov.cn/</a></li><li>中国政府法制信息网： <a href="http://www.chinalaw.gov.cn" target="_blank" rel="noopener">http://www.chinalaw.gov.cn</a></li><li>百度百科</li></ul><p><br><br><br></p><a id="more"></a><p><br><br><br></p><p>《中华人民共和国劳动合同法》是为了完善劳动合同制度，明确劳动合同双方当事人的权利和义务，保护劳动者的合法权益，构建和发展和谐稳定的劳动关系，制定本法。由第十届全国人民代表大会常务委员会第二十八次会议于2007年6月29日修订通过，自2008年1月1日起施行。（2012年12月28日第十一届全国人民代表大会常务委员会第三十次会议通过 2012年12月28日中华人民共和国主席令第73号公布 自2013年7月1日起施行）</p><p><br><br><br></p><h1 id="总则"><a href="#总则" class="headerlink" title="总则"></a>总则</h1><p>第一条： 为了完善劳动合同制度，明确劳动合同双方当事人的权利和义务，保护劳动者的合法权益，构建和发展和谐稳定的劳动关系，制定本法。</p><p><br></p><p>第二条： 中华人民共和国境内的企业、个体经济组织、民办非企业单位等组织（以下称用人单位）与劳动者建立劳动关系，订立、履行、变更、解除或者终止劳动合同，适用本法。</p><p>国家机关、事业单位、社会团体和与其建立劳动关系的劳动者，订立、履行、变更、解除或者终止劳动合同，依照本法执行。</p><p><br></p><p>第三条：　订立劳动合同，应当遵循合法、公平、平等自愿、协商一致、诚实信用的原则。</p><p>依法订立的劳动合同具有约束力，用人单位与劳动者应当履行劳动合同约定的义务。</p><p><br></p><p>第四条　用人单位应当依法建立和完善劳动规章制度，保障劳动者享有劳动权利、履行劳动义务。</p><p>用人单位在制定、修改或者决定有关劳动报酬、工作时间、休息休假、劳动安全卫生、保险福利、职工培训、劳动纪律以及劳动定额管理等直接涉及劳动者切身利益的规章制度或者重大事项时，应当经职工代表大会或者全体职工讨论，提出方案和意见，与工会或者职工代表平等协商确定。<br>在规章制度和重大事项决定实施过程中，工会或者职工认为不适当的，有权向用人单位提出，通过协商予以修改完善。<br>用人单位应当将直接涉及劳动者切身利益的规章制度和重大事项决定公示，或者告知劳动者。</p><p><br></p><p>第五条：　县级以上人民政府劳动行政部门会同工会和企业方面代表，建立健全协调劳动关系三方机制，共同研究解决有关劳动关系的重大问题。</p><p><br></p><p>第六条：　工会应当帮助、指导劳动者与用人单位依法订立和履行劳动合同，并与用人单位建立集体协商机制，维护劳动者的合法权益。</p><p><br><br><br><br><br></p><h1 id="劳动合同的订立"><a href="#劳动合同的订立" class="headerlink" title="劳动合同的订立"></a>劳动合同的订立</h1><p>第七条:　用人单位自用工之日起即与劳动者建立劳动关系。用人单位应当建立职工名册备查。</p><p><br></p><p>第八条:　用人单位招用劳动者时，应当如实告知劳动者工作内容、工作条件、工作地点、职业危害、安全生产状况、劳动报酬，以及劳动者要求了解的其他情况；用人单位有权了解劳动者与劳动合同直接相关的基本情况，劳动者应当如实说明。</p><p><br></p><p>第九条：　用人单位招用劳动者，不得扣押劳动者的居民身份证和其他证件，不得要求劳动者提供担保或者以其他名义向劳动者收取财物。</p><p><br></p><p>第十条：　建立劳动关系，应当订立书面劳动合同。</p><p>已建立劳动关系，未同时订立书面劳动合同的，应当自用工之日起一个月内订立书面劳动合同。<br>用人单位与劳动者在用工前订立劳动合同的，劳动关系自用工之日起建立。</p><p><br></p><p>第十一条：　用人单位未在用工的同时订立书面劳动合同，与劳动者约定的劳动报酬不明确的，新招用的劳动者的劳动报酬按照集体合同规定的标准执行；没有集体合同或者集体合同未规定的，实行同工同酬。</p><p><br></p><p>第十二条　劳动合同分为固定期限劳动合同、无固定期限劳动合同和以完成一定工作任务为期限的劳动合同。</p><p><br></p><p>第十三条　固定期限劳动合同，是指用人单位与劳动者约定合同终止时间的劳动合同。</p><p>用人单位与劳动者协商一致，可以订立固定期限劳动合同。</p><p><br></p><p>第十四条　无固定期限劳动合同，是指用人单位与劳动者约定无确定终止时间的劳动合同。</p><p>用人单位与劳动者协商一致，可以订立无固定期限劳动合同。有下列情形之一，劳动者提出或者同意续订、订立劳动合同的，除劳动者提出订立固定期限劳动合同外，应当订立无固定期限劳动合同：<br>（一）劳动者在该用人单位连续工作满十年的；<br>（二）用人单位初次实行劳动合同制度或者国有企业改制重新订立劳动合同时，劳动者在该用人单位连续工作满十年且距法定退休年龄不足十年的；<br>（三）连续订立二次固定期限劳动合同，且劳动者没有本法第三十九条和第四十条第一项、第二项规定的情形，续订劳动合同的。</p><p>用人单位自用工之日起满一年不与劳动者订立书面劳动合同的，视为用人单位与劳动者已订立无固定期限劳动合同。</p><p><br></p><p>第十五条：　以完成一定工作任务为期限的劳动合同，是指用人单位与劳动者约定以某项工作的完成为合同期限的劳动合同。</p><p>用人单位与劳动者协商一致，可以订立以完成一定工作任务为期限的劳动合同。</p><p><br></p><p>第十六条： 劳动合同由用人单位与劳动者协商一致，并经用人单位与劳动者在劳动合同文本上签字或者盖章生效。</p><p>劳动合同文本由用人单位和劳动者各执一份。</p><p><br></p><p>第十七条：　劳动合同应当具备以下条款：<br>（一）用人单位的名称、住所和法定代表人或者主要负责人；<br>（二）劳动者的姓名、住址和居民身份证或者其他有效身份证件号码；<br>（三）劳动合同期限；<br>（四）工作内容和工作地点；<br>（五）工作时间和休息休假；<br>（六）劳动报酬；<br>（七）社会保险；<br>（八）劳动保护、劳动条件和职业危害防护；<br>（九）法律、法规规定应当纳入劳动合同的其他事项。</p><p>劳动合同除前款规定的必备条款外，用人单位与劳动者可以约定试用期、培训、保守秘密、补充保险和福利待遇等其他事项。</p><p><br></p><p>第十八条：　劳动合同对劳动报酬和劳动条件等标准约定不明确，引发争议的，用人单位与劳动者可以重新协商；协商不成的，适用集体合同规定；没有集体合同或者集体合同未规定劳动报酬的，实行同工同酬；没有集体合同或者集体合同未规定劳动条件等标准的，适用国家有关规定。</p><p><br></p><p>第十九条：　劳动合同期限三个月以上不满一年的，试用期不得超过一个月；劳动合同期限一年以上不满三年的，试用期不得超过二个月；三年以上固定期限和无固定期限的劳动合同，试用期不得超过六个月。</p><p>同一用人单位与同一劳动者只能约定一次试用期。<br>以完成一定工作任务为期限的劳动合同或者劳动合同期限不满三个月的，不得约定试用期。<br>试用期包含在劳动合同期限内。劳动合同仅约定试用期的，试用期不成立，该期限为劳动合同期限。</p><p><br></p><p>第二十条：　劳动者在试用期的工资不得低于本单位相同岗位最低档工资或者劳动合同约定工资的百分之八十，并不得低于用人单位所在地的最低工资标准。</p><p><br></p><p>第二十一条：　在试用期中，除劳动者有本法第三十九条和第四十条第一项、第二项规定的情形外，用人单位不得解除劳动合同。用人单位在试用期解除劳动合同的，应当向劳动者说明理由。</p><p><br></p><p>第二十二条：　用人单位为劳动者提供专项培训费用，对其进行专业技术培训的，可以与该劳动者订立协议，约定服务期。</p><p>劳动者违反服务期约定的，应当按照约定向用人单位支付违约金。违约金的数额不得超过用人单位提供的培训费用。用人单位要求劳动者支付的违约金不得超过服务期尚未履行部分所应分摊的培训费用。<br>用人单位与劳动者约定服务期的，不影响按照正常的工资调整机制提高劳动者在服务期期间的劳动报酬。</p><p><br></p><p>第二十三条：　用人单位与劳动者可以在劳动合同中约定保守用人单位的商业秘密和与知识产权相关的保密事项。</p><p>对负有保密义务的劳动者，用人单位可以在劳动合同或者保密协议中与劳动者约定竞业限制条款，并约定在解除或者终止劳动合同后，在竞业限制期限内按月给予劳动者经济补偿。劳动者违反竞业限制约定的，应当按照约定向用人单位支付违约金。</p><p><br></p><p>第二十四条：　竞业限制的人员限于用人单位的高级管理人员、高级技术人员和其他负有保密义务的人员。竞业限制的范围、地域、期限由用人单位与劳动者约定，竞业限制的约定不得违反法律、法规的规定。</p><p>在解除或者终止劳动合同后，前款规定的人员到与本单位生产或者经营同类产品、从事同类业务的有竞争关系的其他用人单位，或者自己开业生产或者经营同类产品、从事同类业务的竞业限制期限，不得超过二年。</p><p><br></p><p>第二十五条：　除本法第二十二条和第二十三条规定的情形外，用人单位不得与劳动者约定由劳动者承担违约金。</p><p><br></p><p>第二十六条：　下列劳动合同无效或者部分无效：</p><p>（一）以欺诈、胁迫的手段或者乘人之危，使对方在违背真实意思的情况下订立或者变更劳动合同的；<br>（二）用人单位免除自己的法定责任、排除劳动者权利的；<br>（三）违反法律、行政法规强制性规定的。</p><p>对劳动合同的无效或者部分无效有争议的，由劳动争议仲裁机构或者人民法院确认。</p><p><br></p><p>第二十七条：　劳动合同部分无效，不影响其他部分效力的，其他部分仍然有效。</p><p><br></p><p>第二十八条：　劳动合同被确认无效，劳动者已付出劳动的，用人单位应当向劳动者支付劳动报酬。劳动报酬的数额，参照本单位相同或者相近岗位劳动者的劳动报酬确定。</p><p><br><br><br></p><h1 id="劳动合同的履行和变更"><a href="#劳动合同的履行和变更" class="headerlink" title="劳动合同的履行和变更"></a>劳动合同的履行和变更</h1><p>第二十九条：　用人单位与劳动者应当按照劳动合同的约定，全面履行各自的义务。</p><p><br></p><p>第三十条：　用人单位应当按照劳动合同约定和国家规定，向劳动者及时足额支付劳动报酬。</p><p>用人单位拖欠或者未足额支付劳动报酬的，劳动者可以依法向当地人民法院申请支付令，人民法院应当依法发出支付令。</p><p><br></p><p>第三十一条：　用人单位应当严格执行劳动定额标准，不得强迫或者变相强迫劳动者加班。用人单位安排加班的，应当按照国家有关规定向劳动者支付加班费。</p><p><br></p><p>第三十二条：　劳动者拒绝用人单位管理人员违章指挥、强令冒险作业的，不视为违反劳动合同。</p><p>劳动者对危害生命安全和身体健康的劳动条件，有权对用人单位提出批评、检举和控告。</p><p><br></p><p>第三十三条：　用人单位变更名称、法定代表人、主要负责人或者投资人等事项，不影响劳动合同的履行。</p><p><br></p><p>第三十四条：　用人单位发生合并或者分立等情况，原劳动合同继续有效，劳动合同由承继其权利和义务的用人单位继续履行。</p><p><br></p><p>第三十五条：　用人单位与劳动者协商一致，可以变更劳动合同约定的内容。变更劳动合同，应当采用书面形式。</p><p>变更后的劳动合同文本由用人单位和劳动者各执一份。</p><h1 id="劳动合同的解除和终止"><a href="#劳动合同的解除和终止" class="headerlink" title="劳动合同的解除和终止"></a>劳动合同的解除和终止</h1><p>第三十六条：　用人单位与劳动者协商一致，可以解除劳动合同。</p><p><br></p><p>第三十七条：　劳动者提前三十日以书面形式通知用人单位，可以解除劳动合同。劳动者在试用期内提前三日通知用人单位，可以解除劳动合同。</p><p><br></p><p>第三十八条：　用人单位有下列情形之一的，劳动者可以解除劳动合同：<br>（一）未按照劳动合同约定提供劳动保护或者劳动条件的；<br>（二）未及时足额支付劳动报酬的；<br>（三）未依法为劳动者缴纳社会保险费的；<br>（四）用人单位的规章制度违反法律、法规的规定，损害劳动者权益的；<br>（五）因本法第二十六条第一款规定的情形致使劳动合同无效的；<br>（六）法律、行政法规规定劳动者可以解除劳动合同的其他情形。</p><p>用人单位以暴力、威胁或者非法限制人身自由的手段强迫劳动者劳动的，或者用人单位违章指挥、强令冒险作业危及劳动者人身安全的，劳动者可以立即解除劳动合同，不需事先告知用人单位。</p><p><br></p><p>第三十九条：　劳动者有下列情形之一的，用人单位可以解除劳动合同：<br>（一）在试用期间被证明不符合录用条件的；<br>（二）严重违反用人单位的规章制度的；<br>（三）严重失职，营私舞弊，给用人单位造成重大损害的；<br>（四）劳动者同时与其他用人单位建立劳动关系，对完成本单位的工作任务造成严重影响，或者经用人单位提出，拒不改正的；<br>（五）因本法第二十六条第一款第一项规定的情形致使劳动合同无效的；<br>（六）被依法追究刑事责任的。</p><p><br></p><p>第四十条：　有下列情形之一的，用人单位提前三十日以书面形式通知劳动者本人或者额外支付劳动者一个月工资后，可以解除劳动合同：<br>（一）劳动者患病或者非因工负伤，在规定的医疗期满后不能从事原工作，也不能从事由用人单位另行安排的工作的；<br>（二）劳动者不能胜任工作，经过培训或者调整工作岗位，仍不能胜任工作的；<br>（三）劳动合同订立时所依据的客观情况发生重大变化，致使劳动合同无法履行，经用人单位与劳动者协商，未能就变更劳动合同内容达成协议的。</p><p><br></p><p>第四十一条：　有下列情形之一，需要裁减人员二十人以上或者裁减不足二十人但占企业职工总数百分之十以上的，用人单位提前三十日向工会或者全体职工说明情况，听取工会或者职工的意见后，裁减人员方案经向劳动行政部门报告，可以裁减人员：<br>（一）依照企业破产法规定进行重整的；<br>（二）生产经营发生严重困难的；<br>（三）企业转产、重大技术革新或者经营方式调整，经变更劳动合同后，仍需裁减人员的；<br>（四）其他因劳动合同订立时所依据的客观经济情况发生重大变化，致使劳动合同无法履行的。</p><p>裁减人员时，应当优先留用下列人员：<br>（一）与本单位订立较长期限的固定期限劳动合同的；<br>（二）与本单位订立无固定期限劳动合同的；<br>（三）家庭无其他就业人员，有需要扶养的老人或者未成年人的。</p><p>用人单位依照本条第一款规定裁减人员，在六个月内重新招用人员的，应当通知被裁减的人员，并在同等条件下优先招用被裁减的人员。</p><p><br></p><p>第四十二条：　劳动者有下列情形之一的，用人单位不得依照本法第四十条、第四十一条的规定解除劳动合同：<br>（一）从事接触职业病危害作业的劳动者未进行离岗前职业健康检查，或者疑似职业病病人在诊断或者医学观察期间的；<br>（二）在本单位患职业病或者因工负伤并被确认丧失或者部分丧失劳动能力的；<br>（三）患病或者非因工负伤，在规定的医疗期内的；<br>（四）女职工在孕期、产期、哺乳期的；<br>（五）在本单位连续工作满十五年，且距法定退休年龄不足五年的；<br>（六）法律、行政法规规定的其他情形。</p><p><br></p><p>第四十三条：　用人单位单方解除劳动合同，应当事先将理由通知工会。用人单位违反法律、行政法规规定或者劳动合同约定的，工会有权要求用人单位纠正。用人单位应当研究工会的意见，并将处理结果书面通知工会。</p><p><br></p><p>第四十四条：　有下列情形之一的，劳动合同终止：<br>（一）劳动合同期满的；<br>（二）劳动者开始依法享受基本养老保险待遇的；<br>（三）劳动者死亡，或者被人民法院宣告死亡或者宣告失踪的；<br>（四）用人单位被依法宣告破产的；<br>（五）用人单位被吊销营业执照、责令关闭、撤销或者用人单位决定提前解散的；<br>（六）法律、行政法规规定的其他情形。</p><p><br></p><p>第四十五条：　劳动合同期满，有本法第四十二条规定情形之一的，劳动合同应当续延至相应的情形消失时终止。但是，本法第四十二条第二项规定丧失或者部分丧失劳动能力劳动者的劳动合同的终止，按照国家有关工伤保险的规定执行。</p><p><br></p><p>第四十六条：　有下列情形之一的，用人单位应当向劳动者支付经济补偿：<br>（一）劳动者依照本法第三十八条规定解除劳动合同的；<br>（二）用人单位依照本法第三十六条规定向劳动者提出解除劳动合同并与劳动者协商一致解除劳动合同的；<br>（三）用人单位依照本法第四十条规定解除劳动合同的；<br>（四）用人单位依照本法第四十一条第一款规定解除劳动合同的；<br>（五）除用人单位维持或者提高劳动合同约定条件续订劳动合同，劳动者不同意续订的情形外，依照本法第四十四条第一项规定终止固定期限劳动合同的；<br>（六）依照本法第四十四条第四项、第五项规定终止劳动合同的；<br>（七）法律、行政法规规定的其他情形。</p><p><br></p><p>第四十七条：　经济补偿按劳动者在本单位工作的年限，每满一年支付一个月工资的标准向劳动者支付。六个月以上不满一年的，按一年计算；不满六个月的，向劳动者支付半个月工资的经济补偿。</p><p>劳动者月工资高于用人单位所在直辖市、设区的市级人民政府公布的本地区上年度职工月平均工资三倍的，向其支付经济补偿的标准按职工月平均工资三倍的数额支付，向其支付经济补偿的年限最高不超过十二年。<br>本条所称月工资是指劳动者在劳动合同解除或者终止前十二个月的平均工资。</p><p><br></p><p>第四十八条：　用人单位违反本法规定解除或者终止劳动合同，劳动者要求继续履行劳动合同的，用人单位应当继续履行；劳动者不要求继续履行劳动合同或者劳动合同已经不能继续履行的，用人单位应当依照本法第八十七条规定支付赔偿金。</p><p><br></p><p>第四十九条：　国家采取措施，建立健全劳动者社会保险关系跨地区转移接续制度。</p><p><br></p><p>第五十条：　用人单位应当在解除或者终止劳动合同时出具解除或者终止劳动合同的证明，并在十五日内为劳动者办理档案和社会保险关系转移手续。</p><p>劳动者应当按照双方约定，办理工作交接。用人单位依照本法有关规定应当向劳动者支付经济补偿的，在办结工作交接时支付。<br>用人单位对已经解除或者终止的劳动合同的文本，至少保存二年备查。</p><p><br><br><br><br><br></p><h1 id="特别规定"><a href="#特别规定" class="headerlink" title="特别规定"></a>特别规定</h1><h2 id="第一节-集体合同"><a href="#第一节-集体合同" class="headerlink" title="第一节　集体合同"></a>第一节　集体合同</h2><p>第五十一条：　企业职工一方与用人单位通过平等协商，可以就劳动报酬、工作时间、休息休假、劳动安全卫生、保险福利等事项订立集体合同。集体合同草案应当提交职工代表大会或者全体职工讨论通过。</p><p>集体合同由工会代表企业职工一方与用人单位订立；尚未建立工会的用人单位，由上级工会指导劳动者推举的代表与用人单位订立。</p><p><br></p><p>第五十二条：　企业职工一方与用人单位可以订立劳动安全卫生、女职工权益保护、工资调整机制等专项集体合同。</p><p><br></p><p>第五十三条：　在县级以下区域内，建筑业、采矿业、餐饮服务业等行业可以由工会与企业方面代表订立行业性集体合同，或者订立区域性集体合同。</p><p><br></p><p>第五十四条：　集体合同订立后，应当报送劳动行政部门；劳动行政部门自收到集体合同文本之日起十五日内未提出异议的，集体合同即行生效。</p><p>依法订立的集体合同对用人单位和劳动者具有约束力。行业性、区域性集体合同对当地本行业、本区域的用人单位和劳动者具有约束力。</p><p><br></p><p>第五十五条：　集体合同中劳动报酬和劳动条件等标准不得低于当地人民政府规定的最低标准；用人单位与劳动者订立的劳动合同中劳动报酬和劳动条件等标准不得低于集体合同规定的标准。</p><p><br></p><p>第五十六条：　用人单位违反集体合同，侵犯职工劳动权益的，工会可以依法要求用人单位承担责任；因履行集体合同发生争议，经协商解决不成的，工会可以依法申请仲裁、提起诉讼。</p><p><br><br><br></p><p>##　第二节　劳务派遣</p><p>第五十七条：　经营劳务派遣业务应当具备下列条件：<br>（一）注册资本不得少于人民币二百万元；<br>（二）有与开展业务相适应的固定的经营场所和设施；<br>（三）有符合法律、行政法规规定的劳务派遣管理制度；<br>（四）法律、行政法规规定的其他条件。</p><p>经营劳务派遣业务，应当向劳动行政部门依法申请行政许可；经许可的，依法办理相应的公司登记。未经许可，任何单位和个人不得经营劳务派遣业务。</p><p><br></p><p>第五十八条：　劳务派遣单位是本法所称用人单位，应当履行用人单位对劳动者的义务。劳务派遣单位与被派遣劳动者订立的劳动合同，除应当载明本法第十七条规定的事项外，还应当载明被派遣劳动者的用工单位以及派遣期限、工作岗位等情况。</p><p>劳务派遣单位应当与被派遣劳动者订立二年以上的固定期限劳动合同，按月支付劳动报酬；被派遣劳动者在无工作期间，劳务派遣单位应当按照所在地人民政府规定的最低工资标准，向其按月支付报酬。</p><p><br></p><p>第五十九条：　劳务派遣单位派遣劳动者应当与接受以劳务派遣形式用工的单位（以下称用工单位）订立劳务派遣协议。劳务派遣协议应当约定派遣岗位和人员数量、派遣期限、劳动报酬和社会保险费的数额与支付方式以及违反协议的责任。</p><p>用工单位应当根据工作岗位的实际需要与劳务派遣单位确定派遣期限，不得将连续用工期限分割订立数个短期劳务派遣协议。</p><p><br></p><p>第六十条：　劳务派遣单位应当将劳务派遣协议的内容告知被派遣劳动者。</p><p>劳务派遣单位不得克扣用工单位按照劳务派遣协议支付给被派遣劳动者的劳动报酬。<br>劳务派遣单位和用工单位不得向被派遣劳动者收取费用。</p><p><br></p><p>第六十一条：　劳务派遣单位跨地区派遣劳动者的，被派遣劳动者享有的劳动报酬和劳动条件，按照用工单位所在地的标准执行。</p><p><br></p><p>第六十二条　用工单位应当履行下列义务：<br>（一）执行国家劳动标准，提供相应的劳动条件和劳动保护；<br>（二）告知被派遣劳动者的工作要求和劳动报酬；<br>（三）支付加班费、绩效奖金，提供与工作岗位相关的福利待遇；<br>（四）对在岗被派遣劳动者进行工作岗位所必需的培训；<br>（五）连续用工的，实行正常的工资调整机制。</p><p>用工单位不得将被派遣劳动者再派遣到其他用人单位。</p><p><br></p><p>第六十三条：　被派遣劳动者享有与用工单位的劳动者同工同酬的权利。用工单位应当按照同工同酬原则，对被派遣劳动者与本单位同类岗位的劳动者实行相同的劳动报酬分配办法。用工单位无同类岗位劳动者的，参照用工单位所在地相同或者相近岗位劳动者的劳动报酬确定。</p><p>劳务派遣单位与被派遣劳动者订立的劳动合同和与用工单位订立的劳务派遣协议，载明或者约定的向被派遣劳动者支付的劳动报酬应当符合前款规定。</p><p><br></p><p>第六十四条：　被派遣劳动者有权在劳务派遣单位或者用工单位依法参加或者组织工会，维护自身的合法权益。</p><p><br></p><p>第六十五条：　被派遣劳动者可以依照本法第三十六条、第三十八条的规定与劳务派遣单位解除劳动合同。</p><p>被派遣劳动者有本法第三十九条和第四十条第一项、第二项规定情形的，用工单位可以将劳动者退回劳务派遣单位，劳务派遣单位依照本法有关规定，可以与劳动者解除劳动合同。</p><p><br></p><p>第六十六条：　劳动合同用工是我国的企业基本用工形式。劳务派遣用工是补充形式，只能在临时性、辅助性或者替代性的工作岗位上实施。</p><p>前款规定的临时性工作岗位是指存续时间不超过六个月的岗位；辅助性工作岗位是指为主营业务岗位提供服务的非主营业务岗位；替代性工作岗位是指用工单位的劳动者因脱产学习、休假等原因无法工作的一定期间内，可以由其他劳动者替代工作的岗位。<br>用工单位应当严格控制劳务派遣用工数量，不得超过其用工总量的一定比例，具体比例由国务院劳动行政部门规定。</p><p><br></p><p>第六十七条：　用人单位不得设立劳务派遣单位向本单位或者所属单位派遣劳动者。</p><p><br><br><br></p><p>##　第三节　非全日制用工</p><p>第六十八条:　非全日制用工，是指以小时计酬为主，劳动者在同一用人单位一般平均每日工作时间不超过四小时，每周工作时间累计不超过二十四小时的用工形式。</p><p><br></p><p>第六十九条:　非全日制用工双方当事人可以订立口头协议。</p><p>从事非全日制用工的劳动者可以与一个或者一个以上用人单位订立劳动合同；但是，后订立的劳动合同不得影响先订立的劳动合同的履行。</p><p><br></p><p>第七十条:　非全日制用工双方当事人不得约定试用期。</p><p><br></p><p>第七十一条:　非全日制用工双方当事人任何一方都可以随时通知对方终止用工。终止用工，用人单位不向劳动者支付经济补偿。</p><p><br></p><p>第七十二条:　非全日制用工小时计酬标准不得低于用人单位所在地人民政府规定的最低小时工资标准。</p><p>非全日制用工劳动报酬结算支付周期最长不得超过十五日。</p><p><br><br><br><br><br></p><p>#　监督检查</p><p>第七十三条：　国务院劳动行政部门负责全国劳动合同制度实施的监督管理。</p><p>县级以上地方人民政府劳动行政部门负责本行政区域内劳动合同制度实施的监督管理。<br>县级以上各级人民政府劳动行政部门在劳动合同制度实施的监督管理工作中，应当听取工会、企业方面代表以及有关行业主管部门的意见。</p><p><br></p><p>第七十四条：　县级以上地方人民政府劳动行政部门依法对下列实施劳动合同制度的情况进行监督检查：<br>（一）用人单位制定直接涉及劳动者切身利益的规章制度及其执行的情况；<br>（二）用人单位与劳动者订立和解除劳动合同的情况；<br>（三）劳务派遣单位和用工单位遵守劳务派遣有关规定的情况；<br>（四）用人单位遵守国家关于劳动者工作时间和休息休假规定的情况；<br>（五）用人单位支付劳动合同约定的劳动报酬和执行最低工资标准的情况；<br>（六）用人单位参加各项社会保险和缴纳社会保险费的情况；<br>（七）法律、法规规定的其他劳动监察事项。</p><p><br></p><p>第七十五条：　县级以上地方人民政府劳动行政部门实施监督检查时，有权查阅与劳动合同、集体合同有关的材料，有权对劳动场所进行实地检查，用人单位和劳动者都应当如实提供有关情况和材料。</p><p>劳动行政部门的工作人员进行监督检查，应当出示证件，依法行使职权，文明执法。</p><p><br></p><p>第七十六条：　县级以上人民政府建设、卫生、安全生产监督管理等有关主管部门在各自职责范围内，对用人单位执行劳动合同制度的情况进行监督管理。</p><p><br></p><p>第七十七条：　劳动者合法权益受到侵害的，有权要求有关部门依法处理，或者依法申请仲裁、提起诉讼。</p><p><br></p><p>第七十八条：　工会依法维护劳动者的合法权益，对用人单位履行劳动合同、集体合同的情况进行监督。用人单位违反劳动法律、法规和劳动合同、集体合同的，工会有权提出意见或者要求纠正；劳动者申请仲裁、提起诉讼的，工会依法给予支持和帮助。</p><p><br></p><p>第七十九条：　任何组织或者个人对违反本法的行为都有权举报，县级以上人民政府劳动行政部门应当及时核实、处理，并对举报有功人员给予奖励。</p><p><br><br><br><br><br></p><p>#　法律责任</p><p>第八十条：　用人单位直接涉及劳动者切身利益的规章制度违反法律、法规规定的，由劳动行政部门责令改正，给予警告；给劳动者造成损害的，应当承担赔偿责任。</p><p><br></p><p>第八十一条：　用人单位提供的劳动合同文本未载明本法规定的劳动合同必备条款或者用人单位未将劳动合同文本交付劳动者的，由劳动行政部门责令改正；给劳动者造成损害的，应当承担赔偿责任。</p><p><br></p><p>第八十二条：　用人单位自用工之日起超过一个月不满一年未与劳动者订立书面劳动合同的，应当向劳动者每月支付二倍的工资。</p><p>用人单位违反本法规定不与劳动者订立无固定期限劳动合同的，自应当订立无固定期限劳动合同之日起向劳动者每月支付二倍的工资。</p><p><br></p><p>第八十三条：　用人单位违反本法规定与劳动者约定试用期的，由劳动行政部门责令改正；违法约定的试用期已经履行的，由用人单位以劳动者试用期满月工资为标准，按已经履行的超过法定试用期的期间向劳动者支付赔偿金。</p><p><br></p><p>第八十四条：　用人单位违反本法规定，扣押劳动者居民身份证等证件的，由劳动行政部门责令限期退还劳动者本人，并依照有关法律规定给予处罚。</p><p>用人单位违反本法规定，以担保或者其他名义向劳动者收取财物的，由劳动行政部门责令限期退还劳动者本人，并以每人五百元以上二千元以下的标准处以罚款；给劳动者造成损害的，应当承担赔偿责任。<br>劳动者依法解除或者终止劳动合同，用人单位扣押劳动者档案或者其他物品的，依照前款规定处罚。</p><p><br></p><p>第八十五条：　用人单位有下列情形之一的，由劳动行政部门责令限期支付劳动报酬、加班费或者经济补偿；劳动报酬低于当地最低工资标准的，应当支付其差额部分；逾期不支付的，责令用人单位按应付金额百分之五十以上百分之一百以下的标准向劳动者加付赔偿金：<br>（一）未按照劳动合同的约定或者国家规定及时足额支付劳动者劳动报酬的；<br>（二）低于当地最低工资标准支付劳动者工资的；<br>（三）安排加班不支付加班费的；<br>（四）解除或者终止劳动合同，未依照本法规定向劳动者支付经济补偿的。</p><p><br></p><p>第八十六条：　劳动合同依照本法第二十六条规定被确认无效，给对方造成损害的，有过错的一方应当承担赔偿责任。</p><p><br></p><p>第八十七条：　用人单位违反本法规定解除或者终止劳动合同的，应当依照本法第四十七条规定的经济补偿标准的二倍向劳动者支付赔偿金。</p><p><br></p><p>第八十八条：　用人单位有下列情形之一的，依法给予行政处罚；构成犯罪的，依法追究刑事责任；给劳动者造成损害的，应当承担赔偿责任：<br>（一）以暴力、威胁或者非法限制人身自由的手段强迫劳动的；<br>（二）违章指挥或者强令冒险作业危及劳动者人身安全的；<br>（三）侮辱、体罚、殴打、非法搜查或者拘禁劳动者的；<br>（四）劳动条件恶劣、环境污染严重，给劳动者身心健康造成严重损害的。</p><p><br></p><p>第八十九条：　用人单位违反本法规定未向劳动者出具解除或者终止劳动合同的书面证明，由劳动行政部门责令改正；给劳动者造成损害的，应当承担赔偿责任。</p><p><br></p><p>第九十条：　劳动者违反本法规定解除劳动合同，或者违反劳动合同中约定的保密义务或者竞业限制，给用人单位造成损失的，应当承担赔偿责任。</p><p><br></p><p>第九十一条：　用人单位招用与其他用人单位尚未解除或者终止劳动合同的劳动者，给其他用人单位造成损失的，应当承担连带赔偿责任。</p><p><br></p><p>第九十二条：　违反本法规定，未经许可，擅自经营劳务派遣业务的，由劳动行政部门责令停止违法行为，没收违法所得，并处违法所得一倍以上五倍以下的罚款；没有违法所得的，可以处五万元以下的罚款。</p><p>劳务派遣单位、用工单位违反本法有关劳务派遣规定的，由劳动行政部门责令限期改正；逾期不改正的，以每人五千元以上一万元以下的标准处以罚款，对劳务派遣单位，吊销其劳务派遣业务经营许可证。用工单位给被派遣劳动者造成损害的，劳务派遣单位与用工单位承担连带赔偿责任。</p><p><br></p><p>第九十三条：　对不具备合法经营资格的用人单位的违法犯罪行为，依法追究法律责任；劳动者已经付出劳动的，该单位或者其出资人应当依照本法有关规定向劳动者支付劳动报酬、经济补偿、赔偿金；给劳动者造成损害的，应当承担赔偿责任。</p><p><br></p><p>第九十四条：　个人承包经营违反本法规定招用劳动者，给劳动者造成损害的，发包的组织与个人承包经营者承担连带赔偿责任。</p><p><br></p><p>第九十五条：　劳动行政部门和其他有关主管部门及其工作人员玩忽职守、不履行法定职责，或者违法行使职权，给劳动者或者用人单位造成损害的，应当承担赔偿责任；对直接负责的主管人员和其他直接责任人员，依法给予行政处分；构成犯罪的，依法追究刑事责任。</p><p><br><br><br><br><br></p><p>#　附则</p><p>第九十六条：　事业单位与实行聘用制的工作人员订立、履行、变更、解除或者终止劳动合同，法律、行政法规或者国务院另有规定的，依照其规定；未作规定的，依照本法有关规定执行。</p><p><br></p><p>第九十七条：　本法施行前已依法订立且在本法施行之日存续的劳动合同，继续履行；本法第十四条第二款第三项规定连续订立固定期限劳动合同的次数，自本法施行后续订固定期限劳动合同时开始计算。</p><p>本法施行前已建立劳动关系，尚未订立书面劳动合同的，应当自本法施行之日起一个月内订立。<br>本法施行之日存续的劳动合同在本法施行后解除或者终止，依照本法第四十六条规定应当支付经济补偿的，经济补偿年限自本法施行之日起计算；本法施行前按照当时有关规定，用人单位应当向劳动者支付经济补偿的，按照当时有关规定执行。</p><p><br></p><p>第九十八条：　本法自2008年1月1日起施行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全国人民代表大会常务委员会关于修改《中华人民共和国劳动合同法》的决定（附2012年修正本）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;网址：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中华人民共和国中央人民政府： &lt;a href=&quot;http://www.gov.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.gov.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中国政府法制信息网： &lt;a href=&quot;http://www.chinalaw.gov.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.chinalaw.gov.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;百度百科&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="法律" scheme="https://zhang21.github.io/categories/%E6%B3%95%E5%BE%8B/"/>
    
    
      <category term="劳动合同法" scheme="https://zhang21.github.io/tags/%E5%8A%B3%E5%8A%A8%E5%90%88%E5%90%8C%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>文体格式</title>
    <link href="https://zhang21.github.io/2018/10/12/%E6%96%87%E4%BD%93%E6%A0%BC%E5%BC%8F/"/>
    <id>https://zhang21.github.io/2018/10/12/文体格式/</id>
    <published>2018-10-12T09:44:22.000Z</published>
    <updated>2018-10-12T09:44:22.922Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Grafana</title>
    <link href="https://zhang21.github.io/2018/09/13/Grafana/"/>
    <id>https://zhang21.github.io/2018/09/13/Grafana/</id>
    <published>2018-09-13T08:01:12.000Z</published>
    <updated>2018-09-14T08:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>Grafana 文档: <a href="http://docs.grafana.org/" target="_blank" rel="noopener">http://docs.grafana.org/</a></li><li>GitHub: <a href="https://github.com/grafana/" target="_blank" rel="noopener">https://github.com/grafana/</a></li></ul><p>环境：</p><ul><li>CentOS7x86_64</li><li>Grafana v5.2</li></ul><p><br></p><a id="more"></a><p><br><br><br></p><hr><p><br><br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Grafana 文档: &lt;a href=&quot;http://docs.grafana.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://docs.grafana.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub: &lt;a href=&quot;https://github.com/grafana/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/grafana/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7x86_64&lt;/li&gt;
&lt;li&gt;Grafana v5.2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Grafana" scheme="https://zhang21.github.io/tags/Grafana/"/>
    
      <category term="Monitoring" scheme="https://zhang21.github.io/tags/Monitoring/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus</title>
    <link href="https://zhang21.github.io/2018/09/11/Prometheus/"/>
    <id>https://zhang21.github.io/2018/09/11/Prometheus/</id>
    <published>2018-09-11T03:01:12.000Z</published>
    <updated>2018-09-14T09:43:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>Prometheus文档： <a href="https://prometheus.io/docs" target="_blank" rel="noopener">https://prometheus.io/docs</a></li><li>GitHub: <a href="https://github.com/prometheus/" target="_blank" rel="noopener">https://github.com/prometheus/</a></li></ul><p>环境：</p><ul><li>CentOS7x86_64</li><li>Prometheus v2.3</li></ul><p><br></p><a id="more"></a><p><img src="/images/Prometheus/prometheus.jpg" alt="Prometheus"></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Introduction</p><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><br></p><h3 id="Prometheus是什么"><a href="#Prometheus是什么" class="headerlink" title="Prometheus是什么"></a>Prometheus是什么</h3><p>What is Prometheus?</p><p>Prometheus是一个最初在SoundCloud上构建的<strong>开源监控系统和报警工具包</strong>。现在是一个独立的开源项目，由社区进行维护。</p><p><br></p><p><strong>功能(Features)</strong><br>Prometheus的主要特点：</p><ul><li>具有由度量名称(metric name)和键值对(key-value)标识的时间序列(time series)数据的多维(multi-dimensional)数据模型</li><li>灵活的查询语言，以利用此维度</li><li>不依赖分布式存储(distributed storage)，单个服务器节点是自治的(autonomous)</li><li>时间序列集合通过HTPP的<code>pull model</code>发生</li><li><code>push</code>时间序列通过中间网关(intermediary gateway)的支持</li><li>通过服务发现或静态配置来发现目标</li><li>图形和仪表盘支持多种模式</li></ul><p><br></p><p><strong>组件(Components)</strong><br>Prometheus系统由多个组件构成，其中某些组件是可选的：</p><ul><li>主要的<strong>Prometheus Server</strong>，用于存储时间序列数据</li><li><strong>client libraries</strong>，用于检测应用程序代码</li><li><strong>push gateway</strong>，用于支持短暂的(short-lived)工作</li><li><strong>exporters</strong>，用于服务的特殊目的</li><li><strong>alertmanager</strong>，用于处理报警</li><li>各种支持工具</li></ul><p><br></p><p><strong>架构(Architecture)</strong><br>Prometheus的体系结构和系统组件图：</p><p><img src="/images/Prometheus/architecture.png" alt="Prometheus架构图"></p><p><br><br><br></p><h3 id="什么时候适合"><a href="#什么时候适合" class="headerlink" title="什么时候适合"></a>什么时候适合</h3><p>When does it fit?</p><p>Prometheus适用于记录任何纯数字时间序列。它既适用于以机器为中心的监控，也适用于高度动态的面向服务架构的监控。在微服务的世界中，它对多维数据收集和查询的支持是一种特殊的优势。<br>Prometheus专为提高可靠性而设计，是你在断电期间可以快速诊断问题的系统。每个Prometheus Server都是独立的，不依赖于网络存储或其它远程服务。当基础架构其它部分损坏时，你仍可以依赖它，并且你不需要设置大量的基础架构来使用它。</p><p><br><br><br></p><h3 id="什么时候不适合"><a href="#什么时候不适合" class="headerlink" title="什么时候不适合"></a>什么时候不适合</h3><p>When does it not fit?</p><p>Prometheus重视可靠性。即使在系统故障情况下，你也可以随时查看有关系统的可用统计信息。如果你需要100%的准确度，Prometheus不是一个好的选择，你可能需要使用其它系统。</p><p><br><br><br><br><br></p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>步骤：</p><ul><li>下载</li><li>配置</li><li>运行</li><li>使用表达式浏览器</li><li>使用图形接口</li><li>监控其它目标</li></ul><p><br><br><br><br><br></p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>GLOSSARY</p><ul><li><p><strong>Alert</strong><br>是Prometheus正在开火的警报规则的结果。警报从Prometheus发送到AlterManger。</p></li><li><p><strong>Alertmanager</strong><br>接收警报，将它们聚合成组，删除重复数据，应用静音、限制，然后发送电子邮件等通知。</p></li><li><p><strong>Bridge</strong><br>是一个从Client Library中获取样本并将它们暴露给 non-Prometheus 监控系统的组件。例如，Python、Java、Go…客户端可将指标导出到Graphite。</p></li><li><p><strong>Client library</strong><br>是某种语言的库(Go, Java, Python…)，可以直接检测代码，编写自定义收集器以从其它系统中收集指标并将指标公开给Prometheus。</p></li><li><p><strong>Collector</strong><br>是表示一组度量标准的 exporter 的一部分。如果它是直接检测的一部分，则可以是单个度量，如果是从另一个系统提取度量，则可以是许多度量。</p></li><li><p><strong>Direct instrumentation</strong><br>作为源代码程序的一部分内联添加的检测。</p></li><li><p><strong>Endpoint</strong></p></li><li><p><strong>Exporter</strong><br>是一个公开Prometheus指标的程序，通常将 non-prometheus 格式的指标转换为 Prometheus 支持的格式。</p></li><li><p><strong>Instance</strong><br>唯一标识作业中目标的标签</p></li><li><p><strong>Job</strong><br>具有相同目的的目标集合</p></li><li><p><strong>Notification</strong><br>代表一组多个警报</p></li><li><p><strong>Promdash</strong><br>原生Prometheus仪表盘构建器。它已被弃用，并被 Grafana 取代</p></li><li><p><strong>Prometheus</strong><br>通常指的是Prometheus System的核心程序，也可指整个监控系统。</p></li><li><p><strong>PromQL</strong><br>Prometheus Query Language</p></li><li><p><strong>Pushgateway</strong><br>持续从批量作业中最新推出的指标</p></li><li><p><strong>Remote Read</strong><br>允许从其它系统透明读取时间序列作为查询的一部分</p></li><li><p><strong>Remote Read Adapter</strong><br>并非所有系统都支持远程读取。远程读取适配器便是用于此。</p></li><li><p><strong>Remote Read Endpoint</strong><br>Prometheus进行远程读取时的对象</p></li><li><p><strong>Remote Write</strong><br>允许动态地将采集的样本发送到其它系统</p></li><li><p><strong>Remote Write Adapter</strong></p></li><li><p><strong>Remote Write Endpoint</strong></p></li><li><p><strong>Sample</strong><br>时间序列中某个时间点的单个值，Prometheus中，每个样本都包含一个<code>float64</code>和<code>ms</code>精度的时间戳。</p></li><li><p><strong>Silence</strong><br>防止报警</p></li><li><p><strong>Target</strong><br>抓取对象的定义</p></li></ul><p><br><br><br><br><br></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>faq: <a href="https://prometheus.io/docs/introduction/faq/" target="_blank" rel="noopener">https://prometheus.io/docs/introduction/faq/</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>CONCEPTS</p><p><br></p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Data model</p><p>Prometheus从根本上将所有数据存储为<strong>时间序列(time series)</strong>: 属于同一指标和同一标记维度的带时间戳值的流。除了存储时间序列，Prometheus还可以临时生成时间序列作为查询的结果。</p><p><br><br><br></p><h3 id="指标名称和标签"><a href="#指标名称和标签" class="headerlink" title="指标名称和标签"></a>指标名称和标签</h3><p>Metric names and labels</p><p>每个时间序列都是有<strong>指标名称(metric name)</strong>和一组键值对(也称为<strong>标签(label)</strong>)来唯一标识。</p><p>指标名称： 可能包含ASCII字母，下划线，冒号。它必须匹配正则: <code>[a-zA-Z_:][a-zA-Z0-9_:]*</code>。<br>标签启用Prometheus的维度数据模型：</p><p><br><br><br><br><br></p><h2 id="指标类型"><a href="#指标类型" class="headerlink" title="指标类型"></a>指标类型</h2><p>metric types</p><p><br><br><br><br><br></p><h2 id="工作和实例"><a href="#工作和实例" class="headerlink" title="工作和实例"></a>工作和实例</h2><p>Job and Instance</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h1><p><br></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>GETTING STARTED</p><p>本节介绍如何安装，配置，使用Prometheus的简单例子。你将在本地安装和运行Prometheus，将其配置为自我填充和示例应用程序，然后使用查询，规则和图表来使用收集的序列数据。</p><p><br></p><p><strong>下载</strong></p><p>下载地址: <a href="https://prometheus.io/download/" target="_blank" rel="noopener">https://prometheus.io/download/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xvfz prometheus-*.tar.gz</span><br><span class="line"></span><br><span class="line">cd prometheus-*</span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置和监控</strong><br>Prometheus通过在目标上通过HTTP endPoints来抓取指标，来收集受监控目标的指标。由于Prometheus也以相同的方式公开自身数据，它也可以获取和监测自身的健康状况。<br>虽然Prometheus Server只收集有关自身的数据在实践中不是很有用，但它是一个很好的示例。如<code>prometheus.yml</code>示例配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">15</span><span class="string">s</span> <span class="comment"># By default, scrape targets every 15 seconds.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Attach these labels to any time series or alerts when communicating with</span></span><br><span class="line">  <span class="comment"># external systems (federation, remote storage, Alertmanager).</span></span><br><span class="line"><span class="attr">  external_labels:</span></span><br><span class="line"><span class="attr">    monitor:</span> <span class="string">'codelab-monitor'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it's Prometheus itself.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Override the global default and scrape targets from this job every 5 seconds.</span></span><br><span class="line"><span class="attr">    scrape_interval:</span> <span class="number">5</span><span class="string">s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">['localhost:9090']</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>启动</strong><br>启动后，可访问9090端口查看状态。可访问<code>localhost:9090/metrics</code>查看有关自身的相关指标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd prometheus-2.3.2.linux-amd64</span><br><span class="line">./prometheus --config.file=&quot;prometheus.yml&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/Prometheus/9090.png" alt="9090"></p><p><br></p><p><strong>使用表达式浏览器</strong><br>让我们看一下Prometheus收集的一些数据。要使用Prometheus的内建表达式浏览器(expression browser)，请跳转到<code>http://localhost:9090/graph</code>并选择<code>Graph -&gt; Console</code>，在其中输入表达式。<br>绘制表达式图形同样在此操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#表达式</span><br><span class="line">prometheus_target_interval_length_seconds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#表达式</span><br><span class="line">prometheus_target_interval_length_seconds&#123;quantile=&quot;0.99&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#计算返回的时间序列数</span><br><span class="line">count(prometheus_target_interval_length_seconds)</span><br></pre></td></tr></table></figure><p><img src="/images/Prometheus/expression01.png" alt="表达式结果"></p><p><img src="/images/Prometheus/expression02.png" alt="表达式图形"></p><p><br></p><p><strong>启动简单的目标</strong><br>启动一些示例目标让Prometheus获取。<br>确保已安装Go表一起并设置了正常的GO PATH。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mkdir ./sample &amp;&amp; cd sample</span><br><span class="line"></span><br><span class="line">git clone https://github.com/prometheus/client_golang.git</span><br><span class="line">cd client_golang/examples/random</span><br><span class="line">go get -d</span><br><span class="line">go build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Start 3 example targets in separate terminals:</span><br><span class="line">./random -listen-address=:9091</span><br><span class="line">./random -listen-address=:9092</span><br><span class="line">./random -listen-address=:9093</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#访问</span><br><span class="line">http://localhost:9091/metrices</span><br><span class="line">http://localhost:9092/metrices</span><br><span class="line">http://localhost:9093/metrices</span><br></pre></td></tr></table></figure><p><br></p><p><strong>监控示例目标</strong><br>现在需要配置Prometheus来抓取目标。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span>       <span class="string">'example-random'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Override the global default and scrape targets from this job every 5 seconds.</span></span><br><span class="line"><span class="attr">    scrape_interval:</span> <span class="number">5</span><span class="string">s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">['localhost:8080',</span> <span class="string">'localhost:8081'</span><span class="string">]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          group:</span> <span class="string">'production'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">['localhost:8082']</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          group:</span> <span class="string">'canary'</span></span><br></pre></td></tr></table></figure><p>重启Prometheus，检测<code>rpc_durations_seconds</code> metric来验证。</p><p><br></p><p><strong>配置规则</strong><br>Configure rules for aggregating scraped data into new time series</p><p>聚合超过数千个时间序列的查询在计算<code>ad-hoc</code>时会变慢。为了提高效率，Prometheus允许你通过配置的规则将预录表达式预先记录到全新的持久时间序列中。</p><p>创建规则文件<code>prometheus.rules.yml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#job_service:rpc_durations_seconds_count:avg_rate5m</span><br><span class="line">groups:</span><br><span class="line">- name: example</span><br><span class="line">  rules:</span><br><span class="line">  - record: job_service:rpc_durations_seconds_count:avg_rate5m</span><br><span class="line">    expr: avg(rate(rpc_durations_seconds_count[5m])) by (job, service)</span><br></pre></td></tr></table></figure></p><p>要是Prometheus选择此新规则，需要修改Prometheus配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval:     15s # By default, scrape targets every 15 seconds.</span><br><span class="line">  evaluation_interval: 15s # Evaluate rules every 15 seconds.</span><br><span class="line"></span><br><span class="line">  # Attach these extra labels to all timeseries collected by this Prometheus instance.</span><br><span class="line">  external_labels:</span><br><span class="line">    monitor: &apos;codelab-monitor&apos;</span><br><span class="line"></span><br><span class="line">rule_files:</span><br><span class="line">  - &apos;prometheus.rules.yml&apos;</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &apos;prometheus&apos;</span><br><span class="line"></span><br><span class="line">    # Override the global default and scrape targets from this job every 5 seconds.</span><br><span class="line">    scrape_interval: 5s</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&apos;localhost:9090&apos;]</span><br><span class="line"></span><br><span class="line">  - job_name:       &apos;example-random&apos;</span><br><span class="line"></span><br><span class="line">    # Override the global default and scrape targets from this job every 5 seconds.</span><br><span class="line">    scrape_interval: 5s</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&apos;localhost:8091&apos;, &apos;localhost:8092&apos;]</span><br><span class="line">        labels:</span><br><span class="line">          group: &apos;production&apos;</span><br><span class="line"></span><br><span class="line">      - targets: [&apos;localhost:9093&apos;]</span><br><span class="line">        labels:</span><br><span class="line">          group: &apos;canary&apos;</span><br></pre></td></tr></table></figure><p>重启Prometheus，使用<code>job_service:rpc_durations_seconds_count:avg_rate5m</code> metric验证。</p><p><br><br><br></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><br></p><h3 id="使用预编译的二进制文件"><a href="#使用预编译的二进制文件" class="headerlink" title="使用预编译的二进制文件"></a>使用预编译的二进制文件</h3><p><br><br><br></p><h3 id="使用源码"><a href="#使用源码" class="headerlink" title="使用源码"></a>使用源码</h3><p><br><br><br></p><h3 id="使用Docker"><a href="#使用Docker" class="headerlink" title="使用Docker"></a>使用Docker</h3><p>所有的Prometheus服务都可以作为 Docker image 来使用。<br>Prometheus image 使用 volume 来存储实际的指标。对于生产部署，强烈建议使用 Data Volume Container 来升级数据的管理。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#bind-mount</span><br><span class="line">docker run -p 9090:9090 -v /tmp/prometheus.yml:/etc/prometheus.yml  prom/prometheus</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#volume</span><br><span class="line">docker run -p 9090:9090 -v /promethe-data  prom/prometheus  --config.file=/prometheus-data/prometheus.yml</span><br></pre></td></tr></table></figure><p><br></p><p><strong>自定义镜像</strong></p><p>Dockerfile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM prom/prometheus</span><br><span class="line">ADD prometheus.yml /etc/prometheus/</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure><p>构建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-prometheus .</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用配置管理系统"><a href="#使用配置管理系统" class="headerlink" title="使用配置管理系统"></a>使用配置管理系统</h3><ul><li>Ansible</li><li>Chef</li><li>Puppet</li><li>SaltStack</li></ul><p><br><br><br><br><br></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Configuration</p><p>Prometheus通过命令行标志(flag)和配置文件进行配置。使用<code>./prometheus -h</code>查看所有命令行标志。<br>Prometheus可在运行时重新加载配置。</p><p><br></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>configuration file: <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/" target="_blank" rel="noopener">https://prometheus.io/docs/prometheus/latest/configuration/configuration/</a></p><p>使用<code>--config.file</code>标志指定配置文件。配置文件使用<code>YAML</code>格式。</p><p>一个配置文件栗子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="comment"># How frequently to scrape targets by default.</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">scrape_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = 1m ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # How long until a scrape request times out.</span></span><br><span class="line"><span class="string">  [ scrape_timeout: &lt;duration&gt; | default = 10s ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # How frequently to evaluate rules.</span></span><br><span class="line"><span class="string">  [ evaluation_interval: &lt;duration&gt; | default = 1m ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # The labels to add to any time series or alerts when communicating with</span></span><br><span class="line"><span class="string">  # external systems (federation, remote storage, Alertmanager).</span></span><br><span class="line"><span class="string"></span><span class="attr">  external_labels:</span></span><br><span class="line">    <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Rule files specifies a list of globs. Rules and alerts are read from</span></span><br><span class="line"><span class="comment"># all matching files.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;filepath_glob&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A list of scrape configurations.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;scrape_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alerting specifies settings related to the Alertmanager.</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line"><span class="attr">  alert_relabel_configs:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="attr">  alertmanagers:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;alertmanager_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings related to the remote write feature.</span></span><br><span class="line"><span class="attr">remote_write:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;remote_write&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings related to the remote read feature.</span></span><br><span class="line"><span class="attr">remote_read:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;remote_read&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p><br></p><p>各个配置项：</p><ul><li><code>scrape_config</code></li><li><code>tls_config</code></li><li><code>azure_sd_config</code></li><li><code>consul_sd_config</code></li><li><code>dns_sd_config</code></li><li><code>ec2_sd_config</code></li><li><code>openstack_sd_config</code></li><li><code>file_sd_config</code></li><li><code>gce_sd_config</code></li><li><code>kubernetes_sd_config</code></li><li><code>marathon_sd_config</code></li><li><code>nerve_sd_config</code></li><li><code>serverset_sd_config</code></li><li><code>triton_sd_config</code></li><li><code>static_config</code></li><li><code>relabel_config</code></li><li><code>metric_relabel_configs</code></li><li><code>alert_relabel_configs</code></li><li><code>alertmanager_config</code></li><li><code>remote_write</code></li><li><code>remote_read</code></li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><p>Visualization</p><p><br></p><h2 id="表达式浏览器"><a href="#表达式浏览器" class="headerlink" title="表达式浏览器"></a>表达式浏览器</h2><p>Expression browser</p><p>表达其浏览器在 Prometheus Server 的 <code>/graph</code> 处。<br>对于图形，请使用 Grafana 或 Console template。</p><p><br><br><br><br><br></p><h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>Grafana: <a href="https://grafana.com/" target="_blank" rel="noopener">https://grafana.com/</a></p><p>Grafana，美丽的分析和监控的开放平台，时序分析的开源那软件。</p><p>Grafana 支持查询 Prometheus。如下是一个Grafana仪表盘，用于查询Prometheus的数据：</p><p><img src="/images/Prometheus/grafana_prometheus.png" alt=""></p><p><br></p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>完整的安装说明，请查看Grafana Docs。</p><p><br></p><h4 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h4><p><strong>RPM</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#sudo yum install &lt;rpm package url&gt;</span><br><span class="line">sudo yum install https://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-5.1.4-1.x86_64.rpm</span><br></pre></td></tr></table></figure><p><strong>repo</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[grafana]</span><br><span class="line">name=grafana</span><br><span class="line">baseurl=https://packagecloud.io/grafana/stable/el/7/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://packagecloud.io/gpg.key https://grafanarel.s3.amazonaws.com/RPM-GPG-KEY-grafana</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo yum install -y grafana</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启动</span><br><span class="line">systemctl start grafana-server</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#命令行工具</span><br><span class="line">grafana-cli</span><br></pre></td></tr></table></figure><p><strong>包详情</strong></p><ul><li>Installs binary to <code>/usr/sbin/grafana-server</code></li><li>Copies init.d script to <code>/etc/init.d/grafana-server</code></li><li>Installs default file (environment vars) to <code>/etc/sysconfig/grafana-server</code></li><li>Copies configuration file to <code>/etc/grafana/grafana.ini</code></li><li>Installs systemd service (if systemd is available) name <code>grafana-server.service</code></li><li>The default configuration uses a log file at <code>/var/log/grafana/grafana.log</code></li><li>The default configuration specifies an sqlite3 database at <code>/var/lib/grafana/grafana.db</code></li></ul><p><br></p><p><strong>二进制tar文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Download and unpack Grafana from binary tar (adjust version as appropriate).</span><br><span class="line">curl -L -O https://grafanarel.s3.amazonaws.com/builds/grafana-2.5.0.linux-x64.tar.gz</span><br><span class="line">tar zxf grafana-2.5.0.linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"># Start Grafana.</span><br><span class="line">cd grafana-2.5.0/</span><br><span class="line">./bin/grafana-server web</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#基础栗子</span><br><span class="line">docker run -d -p 3000:3000 grafana/grafana</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#配置化</span><br><span class="line">docker run \</span><br><span class="line">  -d \</span><br><span class="line">  -p 3000:3000 \</span><br><span class="line">  --name=grafana \</span><br><span class="line">  -e &quot;GF_SERVER_ROOT_URL=http://grafana.server.name&quot; \</span><br><span class="line">  -e &quot;GF_SECURITY_ADMIN_PASSWORD=secret&quot; \</span><br><span class="line">  grafana/grafana:version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#默认环境变量值</span><br><span class="line">GF_PATHS_CONFIG/etc/grafana/grafana.ini</span><br><span class="line">GF_PATHS_DATA/var/lib/grafana</span><br><span class="line">GF_PATHS_HOME/usr/share/grafana</span><br><span class="line">GF_PATHS_LOGS/var/log/grafana</span><br><span class="line">GF_PATHS_PLUGINS/var/lib/grafana/plugins</span><br><span class="line">GF_PATHS_PROVISIONING/etc/grafana/provisioning</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>默认情况下，访问<code>http://localhost:3000</code>来访问Grafana。默认登录的用户名和密码： <code>admin/admin</code>。</p><p><img src="/images/Prometheus/grafana_login.png" alt="Grafana"></p><p><br></p><p><strong>创建Prometheus数据源</strong></p><p><img src="/images/Prometheus/add_prometheus_datasource.png" alt=""></p><p><br></p><p><strong>创建Prometheus图表</strong></p><p><br><br><br><br><br></p><h2 id="Console-template"><a href="#Console-template" class="headerlink" title="Console template"></a>Console template</h2><p>控制台模板允许使用Go templating language创建任意控制台。这些都是从Prometheus Server提供的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Prometheus文档： &lt;a href=&quot;https://prometheus.io/docs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://prometheus.io/docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub: &lt;a href=&quot;https://github.com/prometheus/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/prometheus/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7x86_64&lt;/li&gt;
&lt;li&gt;Prometheus v2.3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Monitoring" scheme="https://zhang21.github.io/tags/Monitoring/"/>
    
      <category term="Prometheus" scheme="https://zhang21.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Fluentd</title>
    <link href="https://zhang21.github.io/2018/07/19/Fluentd/"/>
    <id>https://zhang21.github.io/2018/07/19/Fluentd/</id>
    <published>2018-07-19T08:38:33.000Z</published>
    <updated>2018-07-31T01:13:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>Fluentd文档: <a href="https://docs.fluentd.org/v1.0/articles/quickstart" target="_blank" rel="noopener">https://docs.fluentd.org/v1.0/articles/quickstart</a></li></ul><p><br></p><p>环境：</p><ul><li>CentOS7x86_64</li><li>Fluentd v1.0</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p><img src="/images/Fluentd/fluentd.png" alt="Fluentd"></p><p><br></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>getting started</p><p>Fluentd是一个完全免费且开源的日志收集器，支持多种事件类型。<br>Fluentd将日志视为JSON(一种机器可读格式)，它主要用C语言编写，扩展部分使用Ruby。</p><p><br><br><br></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于我使用CentOS7，所以查看了此平台文档。</p><p><br></p><h3 id="安装前"><a href="#安装前" class="headerlink" title="安装前"></a>安装前</h3><p>在安装Fluentd前，请配置环境，避免一些问题。</p><ul><li>设置ntp</li><li>增加<code>max file descriptors</code></li><li>优化网络内核参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#ntp</span><br><span class="line">/sbin/ntpdate 1.cn.pool.ntp.org</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#文件描述符</span><br><span class="line">ulimit -n</span><br><span class="line">#1024</span><br><span class="line">#LimitNOFILE=65536</span><br><span class="line">vim /etc/security/limits.conf</span><br><span class="line">root    soft    nofile  65536</span><br><span class="line">root    hard    nofile  65536</span><br><span class="line">*       soft    nofile  65536</span><br><span class="line">*       hard    nofile  65536</span><br><span class="line">#之后重启机器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#优化网络内核参数</span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line">net.core.somaxconn = 1024</span><br><span class="line">net.core.netdev_max_backlog = 5000</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line">net.ipv4.tcp_wmem = 4096 12582912 16777216</span><br><span class="line">net.ipv4.tcp_rmem = 4096 12582912 16777216</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 8096</span><br><span class="line">net.ipv4.tcp_slow_start_after_idle = 0</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.ip_local_port_range = 10240 65535</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p><br></p><h3 id="rpm安装"><a href="#rpm安装" class="headerlink" title="rpm安装"></a>rpm安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此脚本会自动安装td.repo，并安装td-agent</span></span><br><span class="line"><span class="comment">#non-root</span></span><br><span class="line">curl -L https://toolbelt.treasuredata.com/sh/install-redhat-td-agent3.sh | sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#你也可以将脚本内容复制下来执行</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="启动daemon"><a href="#启动daemon" class="headerlink" title="启动daemon"></a>启动daemon</h3><p>自动支持systemd:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/lib/systemd/system/td-agent.service</span><br><span class="line"></span><br><span class="line">#默认配置文件</span><br><span class="line">ls /etc/td-agent/td-agent.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start|stop|status td-agent</span><br></pre></td></tr></table></figure><p><br></p><h3 id="通过HTTP发送示例日志"><a href="#通过HTTP发送示例日志" class="headerlink" title="通过HTTP发送示例日志"></a>通过HTTP发送示例日志</h3><p>我们可通过POST发送日志栗子。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d <span class="string">'json=&#123;"json": "message"&#125;'</span> http://localhost:8888/debug.txt</span><br></pre></td></tr></table></figure><p><br></p><h3 id="安装后"><a href="#安装后" class="headerlink" title="安装后"></a>安装后</h3><ul><li>系统管理<ul><li>配置文件</li><li>日志</li></ul></li><li>连接到其它服务<ul><li>如何工作</li><li>插件管理</li></ul></li><li>配置语法<ul><li>数据源</li><li>输出点</li></ul></li></ul><p><br></p><p><strong>系统管理</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#配置文件</span><br><span class="line">ls /etc/td-agent/td-agent.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#日志</span><br><span class="line">ls /var/log/td-agent/td-agent.log</span><br></pre></td></tr></table></figure><p><br></p><p><strong>连接到其它服务</strong><br>在Fluentd中，数据 input/output 最重要的部分由插件来管理。每个插件都知道如何与外部端点连接，并负责管理传输数据流的通道。<br>插件以某种约定命名。如<code>in_kafka</code>, <code>out_mongo</code>。</p><p>配置栗子：<br><code>in_forward</code>插件作为输入源，<code>out_file</code>插件作为输出点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;source&gt;</span><br><span class="line">  @type forward</span><br><span class="line">  port 9999</span><br><span class="line">&lt;/source&gt;</span><br><span class="line">&lt;match app.**&gt;</span><br><span class="line">  @type file</span><br><span class="line">  path /var/log/app/data.log</span><br><span class="line">  compress gzip</span><br><span class="line">&lt;/match&gt;</span><br></pre></td></tr></table></figure><p>插件管理：<br>Fluentd将插件作为Ruby gems来管理。所以你需要使用<code>td-agent-gem</code>来管理Fluentd插件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装s3插件</span></span><br><span class="line"><span class="comment">#查看插件: &lt;https://www.fluentd.org/plugins&gt;</span></span><br><span class="line">sudo /usr/sbin/td-agent-gem install fluent-plugin-s3</span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置语法</strong><br>配置文件由许多块组成，每个块包含一组特定数据端点设置。</p><p>数据源:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;source&gt;</span><br><span class="line">  @type syslog</span><br><span class="line">  port 5140</span><br><span class="line">  tag system</span><br><span class="line">&lt;/source&gt;</span><br><span class="line"></span><br><span class="line">#@type确定要使用的插件，你就不需要再去加上前缀in</span><br></pre></td></tr></table></figure><p>输出点：<br>添加一个数据流输出端点，你需要定义一个<code>&lt;match&gt;</code>块。<br>你可在过滤器汇表达式中使用通配符<code>*</code>来匹配多个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;match debug.log&gt;</span><br><span class="line">  @type syslog</span><br><span class="line">  prot 5140</span><br><span class="line">  tag system</span><br><span class="line">&lt;/source&gt;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Fluentd事件的生命"><a href="#Fluentd事件的生命" class="headerlink" title="Fluentd事件的生命"></a>Fluentd事件的生命</h2><p>Life of a Fluentd event</p><p><br></p><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><p>使用<code>in_http</code>和<code>out_stdout</code>插件作为示例，来描述事件周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;source&gt;</span><br><span class="line">  @type http</span><br><span class="line">  port 8888</span><br><span class="line">  bind 0.0.0.0</span><br><span class="line">&lt;/source&gt;</span><br><span class="line"></span><br><span class="line">&lt;match test.cycle&gt;</span><br><span class="line">  @type stdout</span><br><span class="line">&lt;/match&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -i -X POST -d &apos;json=&#123;&apos;action&apos;: &apos;login&apos;, &apos;user&apos;: 2&#125;&apos; http://localhost:8888/test.cycle</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><p><br></p><h3 id="事件结构"><a href="#事件结构" class="headerlink" title="事件结构"></a>事件结构</h3><p>Event structure</p><p>Fluentd事件结构：</p><ul><li>tag: 事件来自何处</li><li>time: 事件发生事件(原子时间)</li><li>record: log内容(json)</li></ul><p><br><br><br></p><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>Processing Events</p><ul><li>Filters</li><li>Labels</li><li>Buffers</li></ul><p><br></p><p>定义好配置时，路由引擎对输入数据应用配置规则。</p><p><strong>Filters</strong><br>过滤的目的在于传递(pass)或拒绝(reject)事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#栗子过滤 排除任何logout操作</span><br><span class="line">&lt;source&gt;</span><br><span class="line">  @type http</span><br><span class="line">  port 8888</span><br><span class="line">  bind 0.0.0.0</span><br><span class="line">&lt;/source&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter test.cycle&gt;</span><br><span class="line">  @type grep</span><br><span class="line">  &lt;exclude&gt;</span><br><span class="line">    key action</span><br><span class="line">    pattern ^logout$</span><br><span class="line">  &lt;/exclude&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;match test.cycle&gt;</span><br><span class="line">  @type stdout</span><br><span class="line">&lt;/match&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -i -X POST -d &apos;json=&#123;&quot;action&quot;:&quot;login&quot;,&quot;user&quot;:2&#125;&apos; http://localhost:8888/test.cycle</span><br><span class="line">curl -i -X POST -d &apos;json=&#123;&quot;action&quot;:&quot;logout&quot;,&quot;user&quot;:2&#125;&apos; http://localhost:8888/test.cycle</span><br><span class="line"></span><br><span class="line">#查看fluentd日志的过滤情况</span><br><span class="line">vim /var/log/td-agent/td-agent.log</span><br></pre></td></tr></table></figure><p>Fluentd允许继承许多过滤器，同时考虑到配置文件的增长会让读者觉得有点复杂。所以添加了一个Label功能，用于解决这个问题。</p><p><br></p><p><strong>Labels</strong><br>Label这个功能，用于解决配置文件的复杂性，并允许定义不遵循从上到下的新路由部分，而是像链接引用一样。</p><p>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;source&gt;</span><br><span class="line">  @type http</span><br><span class="line">  bind 0.0.0.0</span><br><span class="line">  port 8888</span><br><span class="line">  @label @STAGING</span><br><span class="line">&lt;/source&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter test.cycle&gt;</span><br><span class="line">  @type grep</span><br><span class="line">  &lt;exclude&gt;</span><br><span class="line">    key action</span><br><span class="line">    pattern ^login$</span><br><span class="line">  &lt;/exclude&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;label @STAGING&gt;</span><br><span class="line">  &lt;filter test.cycle&gt;</span><br><span class="line">    @type grep</span><br><span class="line">    &lt;exclude&gt;</span><br><span class="line">      key action</span><br><span class="line">      pattern ^logout$</span><br><span class="line">    &lt;/exclude&gt;</span><br><span class="line">  &lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">  &lt;match test.cycle&gt;</span><br><span class="line">    @type stdout</span><br><span class="line">  &lt;/match&gt;</span><br><span class="line">&lt;/label&gt;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Buffers</strong><br>前面的栗子中，我们使用<code>non-buffered stdout</code>。但是在生产环境中，会使用<code>outputs in buffered</code>。<br>缓冲模式下的输出插件首先将接收到的事件存储到缓冲区，并通过满足刷新条件将缓冲区写入目标。</p><p>缓冲区对可靠性和吞吐量都很重要。</p><p><br></p><p><strong>结论</strong><br>一旦事件由源上的Fluentd引擎所上报，就可逐步处理或引用Label内部处理，任何事件都有可能被过滤。新的路由引擎旨在提供更多灵活性，并在输出前使处理更容易。</p><p><br><br><br></p><hr><p><br></p><h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><p>Use cases</p><h2 id="集中式应用程序日志"><a href="#集中式应用程序日志" class="headerlink" title="集中式应用程序日志"></a>集中式应用程序日志</h2><p>Centralized App Logging</p><p><br></p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p><br></p><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><p><br></p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p><br></p><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p><br></p><h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h3><p><br></p><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p><br></p><h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><p><br><br><br></p><h2 id="监控服务日志"><a href="#监控服务日志" class="headerlink" title="监控服务日志"></a>监控服务日志</h2><p>Monitoring Service Logs</p><h3 id="FEK"><a href="#FEK" class="headerlink" title="FEK"></a>FEK</h3><p>Splunk是一个检索日志的好工具，但它的高成本对很对团队来说便不可取了。我们通过结合三个开源项目: Elasticsearch， Kiban， Fluentd来免费替代Splunk。</p><p><img src="/images/Fluentd/fluentd-elasticsearch-kibana.png" alt="FEK"></p><p><br></p><p><strong>请自行安装Elasticsearch和Kibana。</strong></p><p>安装Fluentd的Elasticsearch插件:<br>fluent-plugin-elasticsearch: <a href="https://github.com/uken/fluent-plugin-elasticsearch" target="_blank" rel="noopener">https://github.com/uken/fluent-plugin-elasticsearch</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">td-agent-gem install fluent-plugin-elasticsearch --no-document</span><br><span class="line"></span><br><span class="line">td-agent-gem list</span><br></pre></td></tr></table></figure><p><br></p><p>修改配置文件: <code>/etc/td-agent/td-agent.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># get logs from syslog</span><br><span class="line">&lt;source&gt;</span><br><span class="line">  @type syslog</span><br><span class="line">  port 42185</span><br><span class="line">  tag syslog</span><br><span class="line">&lt;/source&gt;</span><br><span class="line"></span><br><span class="line"># get logs from fluent-logger, fluent-cat or other fluentd instances</span><br><span class="line">&lt;source&gt;</span><br><span class="line">  @type forward</span><br><span class="line">&lt;/source&gt;</span><br><span class="line"></span><br><span class="line">&lt;match syslog.**&gt;</span><br><span class="line">  @type elasticsearch</span><br><span class="line">  logstash_format true</span><br><span class="line">  &lt;buffer&gt;</span><br><span class="line">    flush_interval 10s # for testing</span><br><span class="line">  &lt;/buffer&gt;</span><br><span class="line">&lt;/match&gt;</span><br><span class="line">#fluent-plugin-elasticsearch插件附带一个logstash_format选项</span><br></pre></td></tr></table></figure><p>Elasticsearch用户和密码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;match my.logs&gt;</span><br><span class="line">  @type elasticsearch</span><br><span class="line">  host localhost</span><br><span class="line">  port 9200</span><br><span class="line">  user elastic</span><br><span class="line">  password xxxxx</span><br><span class="line">  index_name fluentd</span><br><span class="line">  type_name fluentd</span><br><span class="line">&lt;/match&gt;</span><br><span class="line"></span><br><span class="line">#hosts host1:port1,host2:port2...</span><br></pre></td></tr></table></figure><p>具体详情请参考GitHub的README。</p><p><br></p><p><strong>配置rsyslogd:</strong><br>将日志从rsyslogd转发到Fluentd。修改<code>/etc/syslog.conf</code>并重启rsyslogd。这将本地syslog转发到Fluentd，而Fluentd会将日志转发给Elasticsearch。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*.* @127.0.0.1:42185</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemcrl restart rsyslog</span><br></pre></td></tr></table></figure><p><br></p><p>存储和查询事件日志：<br>访问Kibana配置索引<code>logstash-*</code>进行查看日志。</p><p>使用<code>logger</code>命令手动发送日志到Elasticsearch。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#logger - a shell command interface to the syslog(3) system log module</span><br><span class="line">logger -t test foobar</span><br><span class="line"></span><br><span class="line">#之后可在kibana索引中查看到ident为test, message为foobar的两个文档</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="邮件报警"><a href="#邮件报警" class="headerlink" title="邮件报警"></a>邮件报警</h3><p>Splunk-like Grep-and-Alert-Email System Using Fluentd</p><p>Splunk的一个主要功能便是能够满足日志在某些条件时发送报警电子邮件。<br>我们将使用Fluentd构建一个类似的系统。例如，当检测到Apache日志中的<code>5xx</code> HTTP status code时编发送报警邮件。</p><p><br></p><p><strong>安装依赖</strong><br>安装两个插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">td-agent-gem install fluent-plugin-grepcounter</span><br><span class="line">td-agent-gem install fluent-plugin-mail</span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/etc/td-agent/td-agent.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;source&gt;</span><br><span class="line">  @type tail</span><br><span class="line">  path /var/log/apache2/access.log</span><br><span class="line">  &lt;parse&gt;</span><br><span class="line">    @type apache2</span><br><span class="line">  &lt;/parse&gt;</span><br><span class="line">  tag apache.access</span><br><span class="line">&lt;/source&gt;</span><br><span class="line"></span><br><span class="line">&lt;match apache.access&gt;</span><br><span class="line">  @type grepcounter</span><br><span class="line">  count_interval 3  # The time window for counting errors (in secs)</span><br><span class="line">  input_key code    # The field to apply the regular expression</span><br><span class="line">  regexp ^5\d\d$    # The regular expression to be applied</span><br><span class="line">  threshold 1       # The minimum number of erros to trigger an alert</span><br><span class="line">  add_tag_prefix error_5xx  # Generate tags like &quot;error_5xx.apache.access&quot;</span><br><span class="line">&lt;/match&gt;</span><br><span class="line"></span><br><span class="line">&lt;match error_5xx.apache.access&gt;</span><br><span class="line">  @type copy</span><br><span class="line">  &lt;store&gt;</span><br><span class="line">    @type stdout  # Print to stdout for debugging</span><br><span class="line">  &lt;/store&gt;</span><br><span class="line">  &lt;store&gt;</span><br><span class="line">    @type mail</span><br><span class="line">    host smtp.gmail.com        # Change this to your SMTP server host</span><br><span class="line">    port 587                   # Normally 25/587/465 are used for submission</span><br><span class="line">    user USERNAME              # Use your username to log in</span><br><span class="line">    password PASSWORD          # Use your login password</span><br><span class="line">    enable_starttls_auto true  # Use this option to enable STARTTLS</span><br><span class="line">    from example@gmail.com     # Set the sender address</span><br><span class="line">    to alert@example.com       # Set the recipient address</span><br><span class="line">    subject &apos;HTTP SERVER ERROR&apos;</span><br><span class="line">    message Total 5xx error count: %s\n\nPlease check your Apache webserver ASAP</span><br><span class="line">    message_out_keys count     # Use the &quot;count&quot; field to replace &quot;%s&quot; above</span><br><span class="line">  &lt;/store&gt;</span><br><span class="line">&lt;/match&gt;</span><br></pre></td></tr></table></figure><p>请确认：</p><ul><li>smtp配置正确</li><li><code>td-agent daemon</code>具有适当权限访问log</li></ul><p><br></p><p><strong>测试配置</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart td-agent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果安装了standalone的Fluentd</span></span><br><span class="line">fluentd -c alert-email.conf</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>Data Analytics</p><p><br></p><h3 id="将数据收集到Hadoop"><a href="#将数据收集到Hadoop" class="headerlink" title="将数据收集到Hadoop"></a>将数据收集到Hadoop</h3><p>Fluentd + HDFS: Instant Big Data Collection</p><p><strong>背景</strong><br>Fluentd专门用于解决大数据日志收集问题。</p><p>HDFS(Hadoop)是一个存储和处理大量数据的选择，但直到最近它才拥有了除Java库之外的可访问的API。<br>本节将展示如何使用Fluentd从HTTP接收数据流并传输到HDFS。</p><p><br></p><p><strong>架构</strong></p><p><img src="/images/Fluentd/http-to-hdfs.png" alt="HDFS"></p><p><br></p><p><strong>安装</strong><br>本节配置一个单节点用于示例。请在同一节点安装如下软件：</p><ul><li>Fluentd</li><li>WebHDFS Output Plug</li><li>HDFS</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装插件</span></span><br><span class="line">sudo td-agent-gem install fluent-plugin-webhdfs</span><br><span class="line">td-agent-gem list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装Hadoop</span></span><br><span class="line"><span class="comment">#http://hadoop.apache.org/releases.html</span></span><br><span class="line"><span class="comment">#在官网上下载对应二进制</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>Fluentd配置</strong></p><p>http input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;source&gt;</span><br><span class="line">  @type http</span><br><span class="line">  port 8888</span><br><span class="line">&lt;/source&gt;</span><br></pre></td></tr></table></figure><p>webHDFS output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;match hdfs.*.*&gt;</span><br><span class="line">  @type webhdfs</span><br><span class="line">  host namenode.your.cluster.local</span><br><span class="line">  port 50070</span><br><span class="line">  path &quot;/log/%Y%m%d_%H/access.log.#&#123;Socket.gethostname&#125;&quot;</span><br><span class="line">  &lt;buffer&gt;</span><br><span class="line">    flush_interval 10s</span><br><span class="line">  &lt;/buffer&gt;</span><br><span class="line">&lt;/match&gt;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>HDFS 配置</strong></p><p><code>hdfs-site.xml</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.support.append&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.support.broken.append&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &apos;json=&#123;&quot;action&quot;:&quot;login&quot;,&quot;user&quot;:2&#125;&apos; \</span><br><span class="line">  http://localhost:8888/hdfs.access.test</span><br><span class="line">kill -USR1 `cat /var/run/td-agent/td-agent.pid`</span><br><span class="line"></span><br><span class="line">sudo -u hdfs hadoop fs -lsr /log/</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="连接到数据存储"><a href="#连接到数据存储" class="headerlink" title="连接到数据存储"></a>连接到数据存储</h2><p>Connecting to Data Storages</p><p><br></p><h3 id="将Apache-logs存储到MongoDB"><a href="#将Apache-logs存储到MongoDB" class="headerlink" title="将Apache logs存储到MongoDB"></a>将Apache logs存储到MongoDB</h3><p>本节使用Fluentd MongoDB Output plugin实时聚合半结构化日志。</p><p><br></p><p><strong>安装插件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo td-agent-gem install fluent-plugin-mongo</span><br><span class="line">td-agent list</span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置</strong></p><p>tail input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;source&gt;</span><br><span class="line">  @type tail</span><br><span class="line">  path /var/log/apache2/access_log</span><br><span class="line">  pos_file /var/log/td-agent/apache2.access_log.pos</span><br><span class="line">  &lt;parse&gt;</span><br><span class="line">    @type apache2</span><br><span class="line">  &lt;/parse&gt;</span><br><span class="line">  tag mongo.apache.access</span><br><span class="line">&lt;/source&gt;</span><br></pre></td></tr></table></figure><p>mongodb output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;match mongo.**&gt;</span><br><span class="line">  # plugin type</span><br><span class="line">  @type mongo</span><br><span class="line"></span><br><span class="line">  # mongodb db + collection</span><br><span class="line">  database apache</span><br><span class="line">  collection access</span><br><span class="line"></span><br><span class="line">  # mongodb host + port</span><br><span class="line">  host localhost</span><br><span class="line">  port 27017</span><br><span class="line"></span><br><span class="line">  # interval</span><br><span class="line">  &lt;buffer&gt;</span><br><span class="line">    flush_interval 10s</span><br><span class="line">  &lt;/buffer&gt;</span><br><span class="line"></span><br><span class="line">  # make sure to include the time key</span><br><span class="line">  &lt;inject&gt;</span><br><span class="line">    time_key time</span><br><span class="line">  &lt;/inject&gt;</span><br><span class="line">&lt;/match&gt;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h2><p>Stream Processing</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fluentd文档: &lt;a href=&quot;https://docs.fluentd.org/v1.0/articles/quickstart&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.fluentd.org/v1.0/articles/quickstart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7x86_64&lt;/li&gt;
&lt;li&gt;Fluentd v1.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Fluentd" scheme="https://zhang21.github.io/tags/Fluentd/"/>
    
      <category term="日志处理" scheme="https://zhang21.github.io/tags/%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes</title>
    <link href="https://zhang21.github.io/2018/06/26/Kubernetes/"/>
    <id>https://zhang21.github.io/2018/06/26/Kubernetes/</id>
    <published>2018-06-26T03:38:33.000Z</published>
    <updated>2019-01-21T08:45:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>Kubernetes: <a href="https://zh.wikipedia.org/wiki/Kubernetes" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Kubernetes</a></li><li>官方文档: <a href="https://kubernetes.io/docs/" target="_blank" rel="noopener">https://kubernetes.io/docs/</a></li><li>中文文档: <a href="http://docs.kubernetes.org.cn/" target="_blank" rel="noopener">http://docs.kubernetes.org.cn/</a></li><li>GitHub: <a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes</a></li><li>etcd: <a href="https://coreos.com/etcd/docs/latest/" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/</a></li><li>flannel: <a href="https://coreos.com/flannel/docs/latest/" target="_blank" rel="noopener">https://coreos.com/flannel/docs/latest/</a></li></ul><p>环境：</p><ul><li>CentOS7x86_64</li><li>Kubernetes v1.11</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><p><img src="/images/K8s/Kubernetes_logo.png" alt="Kubernetes"></p><p><br></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>此章节提供了有关安装k8s和配置k8s集群的相关说明。</p><p><br></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>有几种方式创建k8s集群：</p><ul><li>minikube(自动部署)</li><li>kubeadm(自动部署)</li><li>软件包(建议初学者使用此方式)</li></ul><p><br></p><h3 id="使用minikube创建集群"><a href="#使用minikube创建集群" class="headerlink" title="使用minikube创建集群"></a>使用minikube创建集群</h3><p>Using Minikube to Create a Cluster</p><p>目标：</p><ul><li>了解k8s集群是什么</li><li>了解Minikube是什么</li><li>启动一个k8s集群</li></ul><p><br></p><p><strong>k8s 集群</strong><br>k8s协调一个高度可用的计算机集群，它们连接起来作为一个单元工作 。<br>k8s以更有效的方式自动化跨集群分发和调整应用程序容器。</p><p>k8s集群包含两种类型的资源：</p><ul><li>Master</li><li>Nodes</li></ul><p>Master负责管理集群。它协调集群中的所有活动。<br>Node是工作主机。每个节点有一个Kubelet的Agent，负责管理节点并与Master(API)通信。此外，节点上还应有处理容器操作的工具(如Docker)。生成环境的k8s集群至少有三个节点。<br>用户可通过k8s API直接与集群进行交互。</p><p><br></p><p>使用Minikube部署集群: <a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">https://github.com/kubernetes/minikube</a><br>Minikube是一个工具，它运行一个单节点的k8s集群供开发用户使用。</p><p><strong>Linux平台</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 &amp;&amp; \</span><br><span class="line">chmod +x minikube &amp;&amp; \</span><br><span class="line">sudo mv minikube /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment">##安装kubectl</span></span><br><span class="line">curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v1.10.0/bin/linux/amd64/kubectl &amp;&amp; \</span><br><span class="line">chmod +x kubectl &amp;&amp; \</span><br><span class="line">sudo mv kubectl /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">minikube version</span><br><span class="line">minikube start</span><br><span class="line"></span><br><span class="line">kubectl version</span><br><span class="line">kubectl cluster-info</span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="kubeadm创建集群"><a href="#kubeadm创建集群" class="headerlink" title="kubeadm创建集群"></a>kubeadm创建集群</h3><h4 id="安装kubeadm"><a href="#安装kubeadm" class="headerlink" title="安装kubeadm"></a>安装kubeadm</h4><p>本节介绍了如何安装<strong>kubeadm</strong>工具。</p><p><strong>安装前</strong></p><ul><li>2GB RAM+</li><li>2 cpus+</li><li>集群主机网络互通</li><li>node上唯一的主机名，MAC，UUID</li><li>开放特定端口(防火墙)</li><li>Swap disabled。必须关闭swap才能使kubelet正常工作。</li></ul><p><br></p><p><strong>验证MAC或UUID对每个node都是唯一的</strong></p><ul><li><code>ifconfig -a</code>获取MAC</li><li><code>cat /sys/class/dmi/id/product_uuid</code>查看UUID</li></ul><p><br></p><p><strong>检查网络适配器</strong></p><p>如果k8s组件不可达，请手动添加路由。</p><p><br></p><p><strong>检查需要的端口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#master</span><br><span class="line">Protocol    DirectionPort RangePurposeUsed By</span><br><span class="line">TCP    Inbound6443*Kubernetes API serverAll</span><br><span class="line">TCP    Inbound2379-2380etcd server client APIkube-apiserver, etcd</span><br><span class="line">TCP    Inbound10250Kubelet APISelf, Control plane</span><br><span class="line">TCP    Inbound10251kube-schedulerSelf</span><br><span class="line">TCP   Inbound10252kube-controller-managerSelf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#worker</span><br><span class="line">ProtocolDirectionPort RangePurposeUsed By</span><br><span class="line">TCPInbound10250Kubelet APISelf, Control plane</span><br><span class="line">TCPInbound30000-32767NodePort Services**All</span><br></pre></td></tr></table></figure><p><br></p><p><strong>安装docker</strong><br>使用阿里云镜像。<br><code>kubeadm v1.11.1</code>最高支持<code>Docker 17.03</code>，请注意。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">mv docker-ce.repo /etc/yum.repos.d</span><br><span class="line"></span><br><span class="line">yum install -y docker-ce.x84_64</span><br><span class="line"></span><br><span class="line"><span class="comment">#由于kubeadm不支持最新版的docker，所以需要安装指定版本</span></span><br><span class="line">yum list docker-ce --showduplicates</span><br><span class="line"></span><br><span class="line">yum install -y docker-ce-17.03.2.ce</span><br></pre></td></tr></table></figure><p><br></p><p><strong>安装kubeadm, kubelet, kubectl</strong></p><ul><li>kubeadm: 引导集群</li><li>kubelet: k8s agent</li><li>kubectl: command line</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建repo</span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#国外镜像凉凉，所以换用阿里云</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#禁用防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭selinux</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i <span class="string">"s/^SELINUX=permissive/SELINUX=disabled/g"</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭swap，否则kubelet无法正常使用</span></span><br><span class="line">swapoff -a</span><br><span class="line"><span class="comment">#将/etc/fstab中swap注释掉</span></span><br><span class="line">sed -i <span class="string">'s/.*swap.*/#&amp;/'</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">yum install -y epel-release ebtables ethtool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl start kubelet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#系统配置，开启网络桥接</span></span><br><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#生效</span></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br><span class="line">sysctl --system</span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#各主机时区，时间同步</span></span><br><span class="line">timedatectl <span class="built_in">set</span>-timezone Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment">#crontab -e</span></span><br><span class="line"><span class="comment">#ntp</span></span><br><span class="line">*/30 * * * * /sbin/ntpdate 1.cn.pool.ntp.org &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#hosts</span></span><br><span class="line">&lt;master-ip&gt; master</span><br><span class="line">&lt;node-ip&gt; node</span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置cgroup driver</strong><br>使用docker时，kubelet会将其驱动设置与Docker相同。kubeadm会自动检查kubelet的cgroup驱动，并在运行时将其设置到<code>/var/lib/kubelet/kubeadm-flags.env</code>文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker info | grep -i <span class="string">'cgroup driver'</span></span><br><span class="line">Cgroup Driver: systemd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#此文件是kubeadm init生成的</span></span><br><span class="line">cat /var/lib/kubelet/kubeadm-flags.env</span><br><span class="line">KUBELET_KUBEADM_ARGS=--cgroup-driver=systemd --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --network-plugin=cni</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果此文件未配置此信息，我们手动添加</span></span><br><span class="line"><span class="built_in">cd</span> /etc/systemd/system/kubelet.service.d</span><br><span class="line">vim 10-kubeadm.conf</span><br><span class="line">KUBELET_KUBEADM_ARGS=--cgroup-driver=systemd --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --network-plugin=cni</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="拉取k8s-gcr-io镜像"><a href="#拉取k8s-gcr-io镜像" class="headerlink" title="拉取k8s.gcr.io镜像"></a>拉取k8s.gcr.io镜像</h4><p>链接: <a href="https://console.cloud.google.com/gcr/images/google-containers/GLOBAL?location=GLOBAL&amp;project=google-containers" target="_blank" rel="noopener">https://console.cloud.google.com/gcr/images/google-containers/GLOBAL?location=GLOBAL&amp;project=google-containers</a></p><p>利用某台能上网的主机，拉取Google上kubeadm需要的<code>k8s.gcr.io/image</code>镜像。</p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">#查看kubeadm需要使用的image</span><br><span class="line">kubeadm config images list</span><br><span class="line"></span><br><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.11.1</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.11.1</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.11.1</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.11.1</span><br><span class="line">k8s.gcr.io/pause-amd64:3.1</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.2.18</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#最好把所有镜像都拉下来，否则后面初始化的时候容易报错</span><br><span class="line">#在gcr.io上查找镜像</span><br><span class="line">#浏览器访问: &lt;https://console.cloud.google.com/gcr/images/google-containers/GLOBAL?location=GLOBAL&amp;project=google-containers&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#找一台能用的服务器，将这些image拉下来，推到自己的repo上再在kubeadm机器上拉取镜像，之后tag成kubeadm需要的格式</span><br><span class="line">#写一个脚本自动拉取镜像，更名镜像，推送镜像</span><br><span class="line">#我基本上把全部镜像都拉了</span><br><span class="line">vim k8sImages.sh</span><br><span class="line"></span><br><span class="line">images=(</span><br><span class="line">coredns:1.1.3</span><br><span class="line">etcd-amd64:3.1.15</span><br><span class="line">etcd-amd64:3.1.16</span><br><span class="line">etcd-amd64:3.1.17</span><br><span class="line">etcd-amd64:3.2.17</span><br><span class="line">etcd-amd64:3.2.18</span><br><span class="line">flannel-amd64:0.5.5</span><br><span class="line">heapster-amd64:v1.4.0</span><br><span class="line">heapster-amd64:v1.4.1</span><br><span class="line">heapster-amd64:v1.4.2</span><br><span class="line">heapster-amd64:v1.4.3</span><br><span class="line">heapster-amd64:v1.5.0</span><br><span class="line">heapster-amd64:v1.5.1</span><br><span class="line">heapster-amd64:v1.5.2</span><br><span class="line">heapster-amd64:v1.5.3</span><br><span class="line">heapster-amd64:v1.5.4</span><br><span class="line">heapster-grafana-amd64:v4.4.3</span><br><span class="line">heapster-grafana-amd64:v5.0.4</span><br><span class="line">heapster-influxdb-amd64:v1.3.3</span><br><span class="line">heapster-influxdb-amd64:v1.5.2</span><br><span class="line">k8s-dns-dnsmasq-nanny-amd64:1.14.10</span><br><span class="line">k8s-dns-dnsmasq-nanny-amd64:1.14.6</span><br><span class="line">k8s-dns-dnsmasq-nanny-amd64:1.14.7</span><br><span class="line">k8s-dns-dnsmasq-nanny-amd64:1.14.8</span><br><span class="line">k8s-dns-dnsmasq-nanny-amd64:1.14.9</span><br><span class="line">k8s-dns-kube-dns-amd64:1.14.10</span><br><span class="line">k8s-dns-kube-dns-amd64:1.14.5</span><br><span class="line">k8s-dns-kube-dns-amd64:1.14.6</span><br><span class="line">k8s-dns-kube-dns-amd64:1.14.7</span><br><span class="line">k8s-dns-kube-dns-amd64:1.14.8</span><br><span class="line">k8s-dns-kube-dns-amd64:1.14.9</span><br><span class="line">k8s-dns-sidecar-amd64:1.14.10</span><br><span class="line">k8s-dns-sidecar-amd64:1.14.5</span><br><span class="line">k8s-dns-sidecar-amd64:1.14.6</span><br><span class="line">k8s-dns-sidecar-amd64:1.14.7</span><br><span class="line">k8s-dns-sidecar-amd64:1.14.8</span><br><span class="line">k8s-dns-sidecar-amd64:1.14.9</span><br><span class="line">kube-apiserver-amd64:v1.10.5</span><br><span class="line">kube-apiserver-amd64:v1.10.6</span><br><span class="line">kube-apiserver-amd64:v1.11.0</span><br><span class="line">kube-apiserver-amd64:v1.11.1</span><br><span class="line">kube-apiserver-amd64:v1.9.10</span><br><span class="line">kube-controller-manager-amd64:v1.10.5</span><br><span class="line">kube-controller-manager-amd64:v1.10.6</span><br><span class="line">kube-controller-manager-amd64:v1.11.0</span><br><span class="line">kube-controller-manager-amd64:v1.11.1</span><br><span class="line">kube-controller-manager-amd64:v1.9.10</span><br><span class="line">kube-proxy-amd64:v1.10.6</span><br><span class="line">kube-proxy-amd64:v1.11.0</span><br><span class="line">kube-proxy-amd64:v1.11.1</span><br><span class="line">kube-proxy-amd64:v1.9.10</span><br><span class="line">kubernetes-dashboard-amd64:v1.6.2</span><br><span class="line">kubernetes-dashboard-amd64:v1.6.3</span><br><span class="line">kubernetes-dashboard-amd64:v1.7.0</span><br><span class="line">kubernetes-dashboard-amd64:v1.7.1</span><br><span class="line">kubernetes-dashboard-amd64:v1.8.0</span><br><span class="line">kubernetes-dashboard-amd64:v1.8.1</span><br><span class="line">kubernetes-dashboard-amd64:v1.8.2</span><br><span class="line">kubernetes-dashboard-amd64:v1.8.3</span><br><span class="line">kube-scheduler-amd64:v1.10.6</span><br><span class="line">kube-scheduler-amd64:v1.11.0</span><br><span class="line">kube-scheduler-amd64:v1.11.1</span><br><span class="line">kube-scheduler-amd64:v1.9.10</span><br><span class="line">pause-amd64:3.0</span><br><span class="line">pause-amd64:3.1</span><br><span class="line">pause:3.1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#可能pause与pause-amd64是一个，到时只需拉一个，然后tag</span><br><span class="line"></span><br><span class="line">for image in $&#123;images[@]&#125;</span><br><span class="line">do</span><br><span class="line">    docker pull k8s.gcr.io/$&#123;image&#125;</span><br><span class="line">    docker tag k8s.gcr.io/$&#123;image&#125; zhang21/$&#123;image&#125;</span><br><span class="line">    docker image rm k8s.gcr.io/$&#123;image&#125;</span><br><span class="line">    docker push zhang21/$&#123;image&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line">#到我的docker-hub中查看</span><br><span class="line">#https://hub.docker.com/u/zhang21/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#现在在kubeadm集群机器上操作</span><br><span class="line">#还是写一个脚本来拉取镜像，更名镜像，删除镜像</span><br><span class="line">vim k8sImage.sh</span><br><span class="line"></span><br><span class="line">images=(</span><br><span class="line">coredns:1.1.3</span><br><span class="line">etcd-amd64:3.1.15</span><br><span class="line">etcd-amd64:3.1.16</span><br><span class="line">etcd-amd64:3.1.17</span><br><span class="line">etcd-amd64:3.2.17</span><br><span class="line">etcd-amd64:3.2.18</span><br><span class="line">flannel-amd64:0.5.5</span><br><span class="line">heapster-amd64:v1.4.0</span><br><span class="line">heapster-amd64:v1.4.1</span><br><span class="line">heapster-amd64:v1.4.2</span><br><span class="line">heapster-amd64:v1.4.3</span><br><span class="line">heapster-amd64:v1.5.0</span><br><span class="line">heapster-amd64:v1.5.1</span><br><span class="line">heapster-amd64:v1.5.2</span><br><span class="line">heapster-amd64:v1.5.3</span><br><span class="line">heapster-amd64:v1.5.4</span><br><span class="line">heapster-grafana-amd64:v4.4.3</span><br><span class="line">heapster-grafana-amd64:v5.0.4</span><br><span class="line">heapster-influxdb-amd64:v1.3.3</span><br><span class="line">heapster-influxdb-amd64:v1.5.2</span><br><span class="line">k8s-dns-dnsmasq-nanny-amd64:1.14.10</span><br><span class="line">k8s-dns-dnsmasq-nanny-amd64:1.14.6</span><br><span class="line">k8s-dns-dnsmasq-nanny-amd64:1.14.7</span><br><span class="line">k8s-dns-dnsmasq-nanny-amd64:1.14.8</span><br><span class="line">k8s-dns-dnsmasq-nanny-amd64:1.14.9</span><br><span class="line">k8s-dns-kube-dns-amd64:1.14.10</span><br><span class="line">k8s-dns-kube-dns-amd64:1.14.5</span><br><span class="line">k8s-dns-kube-dns-amd64:1.14.6</span><br><span class="line">k8s-dns-kube-dns-amd64:1.14.7</span><br><span class="line">k8s-dns-kube-dns-amd64:1.14.8</span><br><span class="line">k8s-dns-kube-dns-amd64:1.14.9</span><br><span class="line">k8s-dns-sidecar-amd64:1.14.10</span><br><span class="line">k8s-dns-sidecar-amd64:1.14.5</span><br><span class="line">k8s-dns-sidecar-amd64:1.14.6</span><br><span class="line">k8s-dns-sidecar-amd64:1.14.7</span><br><span class="line">k8s-dns-sidecar-amd64:1.14.8</span><br><span class="line">k8s-dns-sidecar-amd64:1.14.9</span><br><span class="line">kube-apiserver-amd64:v1.10.5</span><br><span class="line">kube-apiserver-amd64:v1.10.6</span><br><span class="line">kube-apiserver-amd64:v1.11.0</span><br><span class="line">kube-apiserver-amd64:v1.11.1</span><br><span class="line">kube-apiserver-amd64:v1.9.10</span><br><span class="line">kube-controller-manager-amd64:v1.10.5</span><br><span class="line">kube-controller-manager-amd64:v1.10.6</span><br><span class="line">kube-controller-manager-amd64:v1.11.0</span><br><span class="line">kube-controller-manager-amd64:v1.11.1</span><br><span class="line">kube-controller-manager-amd64:v1.9.10</span><br><span class="line">kube-proxy-amd64:v1.10.6</span><br><span class="line">kube-proxy-amd64:v1.11.0</span><br><span class="line">kube-proxy-amd64:v1.11.1</span><br><span class="line">kube-proxy-amd64:v1.9.10</span><br><span class="line">kubernetes-dashboard-amd64:v1.6.2</span><br><span class="line">kubernetes-dashboard-amd64:v1.6.3</span><br><span class="line">kubernetes-dashboard-amd64:v1.7.0</span><br><span class="line">kubernetes-dashboard-amd64:v1.7.1</span><br><span class="line">kubernetes-dashboard-amd64:v1.8.0</span><br><span class="line">kubernetes-dashboard-amd64:v1.8.1</span><br><span class="line">kubernetes-dashboard-amd64:v1.8.2</span><br><span class="line">kubernetes-dashboard-amd64:v1.8.3</span><br><span class="line">kube-scheduler-amd64:v1.10.6</span><br><span class="line">kube-scheduler-amd64:v1.11.0</span><br><span class="line">kube-scheduler-amd64:v1.11.1</span><br><span class="line">kube-scheduler-amd64:v1.9.10</span><br><span class="line">pause-amd64:3.0</span><br><span class="line">pause-amd64:3.1</span><br><span class="line">pause:3.1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">for image in $&#123;images[@]&#125;</span><br><span class="line">do</span><br><span class="line">    docker pull zhang21/$&#123;image&#125;</span><br><span class="line">    docker tag zhang21/$&#123;image&#125; k8s.gcr.io/$&#123;image&#125;</span><br><span class="line">    docker image rm zhang21/$&#123;image&#125;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="创建单master集群"><a href="#创建单master集群" class="headerlink" title="创建单master集群"></a>创建单master集群</h4><p><code>kubeadm</code>可帮助你引导符合最佳实践的最小化可行的k8s集群。使用<code>kubeadm</code>，你的集群应通过k8s一致性测试。<code>kubeadm</code>还支持其它集群生命周期功能，如升级、降级和管理引导令牌(bootstrap token)。<br><code>kubeadm</code>旨在成为新用户开始尝试k8s的一种简单方法。可使用deb/rpm软件包在系统上轻松安装<code>kubeadm</code>。<br>因为你可在各种类型的机器上安装<code>kubeadm</code>，所以它非常适合于Ansible/Salt等配置系统集成。</p><p><code>kubeadm</code>的简单性意味着它可以服务于各种用例：</p><ul><li>新用户可以从<code>kubeadm</code>开始，第一次尝试k8s</li><li>熟悉k8s的用户可以使用<code>kubeadm</code>启动集群，并测试他们的应用程序</li><li>较大的项目可以包括<code>kubeadm</code>作为更复杂系统中的构件，也可以包括其它安装程序工具</li></ul><p>kubeadm Maturity(成熟度)</p><table><thead><tr><th>Area</th><th>Maturity Level</th></tr></thead><tbody><tr><td>Command line UX</td><td>beta</td></tr><tr><td>Implementation</td><td>beta</td></tr><tr><td>Config file API</td><td>alpha</td></tr><tr><td>Self-hosting</td><td>alpha</td></tr><tr><td>kubeadm alpha subcommands</td><td>alpha</td></tr><tr><td>CoreDNS</td><td>GA</td></tr><tr><td>DynamicKubeletConfig</td><td>alpha</td></tr></tbody></table><p>kubeadm的整体功能状态为Beta，并将很快添加到GA(General Availability)。一些子功能，如自托管(self-hosting)和配置文件API仍在积极开发中。</p><p>k8s版本通常支持九个月，这也适用于kubeadm。</p><table><thead><tr><th>Kubernetes version</th><th>Release month</th><th>End-of-life-month</th></tr></thead><tbody><tr><td>v1.6.x</td><td>March 2017</td><td>December 2017</td></tr><tr><td>v1.7.x</td><td>June 2017</td><td>March 2018</td></tr><tr><td>v1.8.x</td><td>September 2017</td><td>June 2018</td></tr><tr><td>v1.9.x</td><td>December 2017</td><td>September 2018</td></tr><tr><td>v1.10.x</td><td>March 2018</td><td>December 2018</td></tr><tr><td>v1.11.x</td><td>June 2018</td><td>March 2019</td></tr></tbody></table><p><br></p><p><strong>开始前</strong></p><ul><li>一台或多台主机</li><li>2GB+ RAM(每台机器)</li><li>2CPUs+(master)</li><li>网络互通</li></ul><p><br></p><p><strong>目标</strong></p><ul><li>安装 <strong>单master/高可用性</strong> 的k8s集群</li><li>在集群上安装pod-network，以便pod间可互相通信</li></ul><p><br></p><p><strong>组件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#Master</span><br><span class="line">etcd</span><br><span class="line">kube-apisever</span><br><span class="line">kube-controller-manager</span><br><span class="line">kube-scheduler</span><br><span class="line">kube-flannel</span><br><span class="line">kube-proxy</span><br><span class="line">kube-dns</span><br><span class="line">kubectl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Node</span><br><span class="line">kube-flannel</span><br><span class="line">kube-proxy</span><br><span class="line">kubectl</span><br></pre></td></tr></table></figure><p><br></p><p><strong>说明</strong></p><ul><li>安装kubeadm<br>如已安装，可升级到最新版。</li></ul><p><br></p><ul><li>初始化集群<br>master主机是控制组件运行的地方，包括<code>etcd</code>, <code>API server</code>…</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#1</span><br><span class="line">#选择一个 pod network add-on，并验证是够需要将任何参数传递给kubeadm初始化。你可以使用--pod-network-cidr来指定特定值</span><br><span class="line">#这里使用flannel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2，可选</span><br><span class="line">#除非另有说明，否则kubeadm使用与默认网关关联的网络接口来通告master</span><br><span class="line">#使用kubeadm init --apiserver-advertise-address=&lt;ip-addr&gt;来使用不同网络接口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3，可选</span><br><span class="line">#在kubeadm init之前运行kubeadm config images pull以验证与gcr.io的连接</span><br><span class="line">#或kubeadm config images list查看需要的镜像</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#运行</span><br><span class="line">kubeadm init &lt;args&gt;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>更多信息<br><code>kubeadm init</code>首先运行一系列检查，以确保机器 已准备好运行k8s。这些预检查会显示警告并退出错误。然后<code>kubeadm init</code>下载并安装集群控制组件。这可能需要一些时间。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">kubeadm --help</span><br><span class="line">kubeadm init --help</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#k8s底层环境依赖于Docker</span><br><span class="line">#on master</span><br><span class="line">systemctl enable docker kubelet &amp;&amp; systemctl start docker</span><br><span class="line">kubeadm init</span><br><span class="line"></span><br><span class="line">I0806 14:04:54.415853    2191 feature_gate.go:230] feature gates: &amp;&#123;map[]&#125;</span><br><span class="line">[init] using Kubernetes version: v1.11.1</span><br><span class="line">[preflight] running pre-flight checks</span><br><span class="line">        [WARNING Service-Docker]: docker service is not enabled, please run &apos;systemctl enable docker.service&apos;</span><br><span class="line">I0806 14:04:54.433879    2191 kernel_validator.go:81] Validating kernel version</span><br><span class="line">I0806 14:04:54.433934    2191 kernel_validator.go:96] Validating kernel config</span><br><span class="line">[preflight/images] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight/images] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight/images] You can also perform this action in beforehand using &apos;kubeadm config images pull&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[preflight] Some fatal errors occurred:</span><br><span class="line">        [ERROR ImagePull]: failed to pull image [k8s.gcr.io/kube-apiserver-amd64:v1.11.1]: exit status 1</span><br><span class="line">        [ERROR ImagePull]: failed to pull image [k8s.gcr.io/kube-controller-manager-amd64:v1.11.1]: exit status 1</span><br><span class="line">        [ERROR ImagePull]: failed to pull image [k8s.gcr.io/kube-scheduler-amd64:v1.11.1]: exit status 1</span><br><span class="line">        [ERROR ImagePull]: failed to pull image [k8s.gcr.io/kube-proxy-amd64:v1.11.1]: exit status 1</span><br><span class="line">        [ERROR ImagePull]: failed to pull image [k8s.gcr.io/pause-amd64:3.1]: exit status 1</span><br><span class="line">        [ERROR ImagePull]: failed to pull image [k8s.gcr.io/etcd-amd64:3.2.18]: exit status 1</span><br><span class="line">        [ERROR ImagePull]: failed to pull image [k8s.gcr.io/coredns:1.1.3]: exit status 1</span><br><span class="line">[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#此处错误，由于镜像在Google，国内访问会超时。因此需要额外准备镜像。</span><br><span class="line">#需要做上面一步操作来拉取镜像</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#初始化</span><br><span class="line">#请确保资源满足条件，我就是由于VM内存为1GB而导致初始化失败，找了很久才找到这个错误</span><br><span class="line"></span><br><span class="line">kubeadm init --kubernetes-version=v1.11.1 --pod-network-cidr=10.244.0.0/16</span><br><span class="line"></span><br><span class="line">[init] using Kubernetes version: v1.11.1</span><br><span class="line">[preflight] running pre-flight checks</span><br><span class="line">I0807 14:47:10.658405   10612 kernel_validator.go:81] Validating kernel version</span><br><span class="line">I0807 14:47:10.658484   10612 kernel_validator.go:96] Validating kernel config</span><br><span class="line">[preflight/images] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight/images] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight/images] You can also perform this action in beforehand using &apos;kubeadm config images pull&apos;</span><br><span class="line">[kubelet] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[preflight] Activating the kubelet service</span><br><span class="line">[certificates] Generated ca certificate and key.</span><br><span class="line">[certificates] Generated apiserver certificate and key.</span><br><span class="line">[certificates] apiserver serving cert is signed for DNS names [master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.31.49]</span><br><span class="line">[certificates] Generated apiserver-kubelet-client certificate and key.</span><br><span class="line">[certificates] Generated sa key and public key.</span><br><span class="line">[certificates] Generated front-proxy-ca certificate and key.</span><br><span class="line">[certificates] Generated front-proxy-client certificate and key.</span><br><span class="line">[certificates] Generated etcd/ca certificate and key.</span><br><span class="line">[certificates] Generated etcd/server certificate and key.</span><br><span class="line">[certificates] etcd/server serving cert is signed for DNS names [master localhost] and IPs [127.0.0.1 ::1]</span><br><span class="line">[certificates] Generated etcd/peer certificate and key.</span><br><span class="line">[certificates] etcd/peer serving cert is signed for DNS names [master localhost] and IPs [192.168.31.49 127.0.0.1 ::1]</span><br><span class="line">[certificates] Generated etcd/healthcheck-client certificate and key.</span><br><span class="line">[certificates] Generated apiserver-etcd-client certificate and key.</span><br><span class="line">[certificates] valid certificates and keys now exist in &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/admin.conf&quot;</span><br><span class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/kubelet.conf&quot;</span><br><span class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/controller-manager.conf&quot;</span><br><span class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/scheduler.conf&quot;</span><br><span class="line">[controlplane] wrote Static Pod manifest for component kube-apiserver to &quot;/etc/kubernetes/manifests/kube-apiserver.yaml&quot;</span><br><span class="line">[controlplane] wrote Static Pod manifest for component kube-controller-manager to &quot;/etc/kubernetes/manifests/kube-controller-manager.yaml&quot;</span><br><span class="line">[controlplane] wrote Static Pod manifest for component kube-scheduler to &quot;/etc/kubernetes/manifests/kube-scheduler.yaml&quot;</span><br><span class="line">[etcd] Wrote Static Pod manifest for a local etcd instance to &quot;/etc/kubernetes/manifests/etcd.yaml&quot;</span><br><span class="line">[init] waiting for the kubelet to boot up the control plane as Static Pods from directory &quot;/etc/kubernetes/manifests&quot; </span><br><span class="line">[init] this might take a minute or longer if the control plane images have to be pulled</span><br><span class="line">[apiclient] All control plane components are healthy after 42.001662 seconds</span><br><span class="line">[uploadconfig] storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap &quot;kubelet-config-1.11&quot; in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[markmaster] Marking the node master as master by adding the label &quot;node-role.kubernetes.io/master=&apos;&apos;&quot;</span><br><span class="line">[markmaster] Marking the node master as master by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[patchnode] Uploading the CRI Socket information &quot;/var/run/dockershim.sock&quot; to the Node API object &quot;master&quot; as an annotation</span><br><span class="line">[bootstraptoken] using token: uzdl9x.91uu2p155jczkgb3</span><br><span class="line">[bootstraptoken] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstraptoken] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstraptoken] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstraptoken] creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes master has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join 192.168.31.49:6443 --token uzdl9x.91uu2p155jczkgb3 --discovery-token-ca-cert-hash sha256:bc5af0f4fbee0d0500c9d6782a279ee172ed45547a006136bfbad93d61ad39c7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#root用户</span><br><span class="line">#一定要记得做此步骤，由于kubeadm设置的apiserver的监听端口为6443，而不是8080，所以执行会报错。</span><br><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line">#之后，可将其写入/etc/profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#安装pod-network</span><br><span class="line">#你必须先安装pod network add-on，才能和pod相互通信。</span><br><span class="line">#必须在应用程序之前部署网络。</span><br><span class="line">#配置flannel</span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.10.0/Documentation/kube-flannel.yml</span><br><span class="line">#如果无法访问，可将此文件下载到本地</span><br><span class="line">#kubectl apply -f /etc/kubernetes/kube-flannel.yml</span><br><span class="line"></span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.extensions/kube-flannel-ds created</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#token用于master与node之间相互认证，它是加密的。</span><br><span class="line">#使用kubeadm token列出、创建和删除token</span><br><span class="line">#kubeadm token create</span><br><span class="line">#kubeadm token list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#on node</span><br><span class="line">#kubeadm join</span><br><span class="line">#kubeadm join --token xxxxxxxxxxx host:port</span><br><span class="line">systemctl enable kubelet docker &amp;&amp; systemctl start docker</span><br><span class="line">kubeadm join 192.168.31.49:6443 --token uzdl9x.91uu2p155jczkgb3 --discovery-token-ca-cert-hash sha256:bc5af0f4fbee0d0500c9d6782a279ee172ed45547a006136bfbad93d61ad39c7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#测试</span><br><span class="line">kubectl get node</span><br><span class="line"></span><br><span class="line">NAME      STATUS    ROLES     AGE       VERSION</span><br><span class="line">master    Ready     master    48m       v1.11.1</span><br><span class="line">node      Ready     &lt;none&gt;    15m       v1.11.1</span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">kubectl get pods --all-namespaces -o wide</span><br><span class="line">NAMESPACE     NAME                             READY     STATUS    RESTARTS   AGE       IP               NODE</span><br><span class="line">kube-system   coredns-78fcdf6894-hn46d         1/1       Running   0          52m       10.244.0.3       master</span><br><span class="line">kube-system   coredns-78fcdf6894-wqxbx         1/1       Running   0          52m       10.244.0.2       master</span><br><span class="line">kube-system   etcd-master                      1/1       Running   0          41m       192.168.31.49    master</span><br><span class="line">kube-system   kube-apiserver-master            1/1       Running   0          41m       192.168.31.49    master</span><br><span class="line">kube-system   kube-controller-manager-master   1/1       Running   0          41m       192.168.31.49    master</span><br><span class="line">kube-system   kube-flannel-ds-7gbvd            1/1       Running   0          41m       192.168.31.49    master</span><br><span class="line">kube-system   kube-flannel-ds-ktkxp            1/1       Running   0          19m       192.168.31.174   node</span><br><span class="line">kube-system   kube-proxy-pw7gz                 1/1       Running   0          19m       192.168.31.174   node</span><br><span class="line">kube-system   kube-proxy-rhrks                 1/1       Running   0          52m       192.168.31.49    master</span><br><span class="line">kube-system   kube-scheduler-master            1/1       Running   0          41m       192.168.31.49    master</span><br></pre></td></tr></table></figure><p><br></p><ul><li>master isolation<br>默认情况下，出于安全原因，你的集群不会在master上调度pod。如果你想在master上调度pod，对于单master的k8s集群，执行如下命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#从拥有它的节点删除node-role.kubernetes.io/master污染</span><br><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure><p><br></p><ul><li>加入节点<br>要向集群添加新节点，请为每台计算机执行以下操作：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#node</span><br><span class="line"></span><br><span class="line">#root/sudo</span><br><span class="line"></span><br><span class="line">#kubeadm init后执行下命令</span><br><span class="line">#kubeadm token list</span><br><span class="line">kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</span><br></pre></td></tr></table></figure><p><br></p><ul><li>从master之外控制集群(可选)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp root@&lt;master-ip&gt;:/etc/kubernetes/admin.conf .</span><br><span class="line">kubeclt --kubeconfig ./admin.conf get nodes</span><br></pre></td></tr></table></figure><p><br></p><p><strong>局限性</strong><br>此处创建的集群只有一个master，其上运行一个etcd数据库。这意味着如果master出现故障，你的集群可能会丢失数据。可考虑向k8s添加高可用支持。</p><p><br><br><br></p><h4 id="使用kubeadm配置kubelet"><a href="#使用kubeadm配置kubelet" class="headerlink" title="使用kubeadm配置kubelet"></a>使用kubeadm配置kubelet</h4><p>Configuring each kubelet in your cluster using kubeadm</p><p><code>kubeadm CLI</code>工具的生命周期与<code>Kubernetes Node  Agent(kubelet)</code>相分离，kubelet是运行在k8s集群master/node上的守护进程，它始终在后台运行。而<code>kubeadm CLI</code>工具由用户执行。<br>由于<code>kubelet</code>是一个守护进程，它需要由<code>init system</code>或服务管理器来维护。Redhat7上使用<code>systemd</code>来进行管理。<br>在集群设计的kubelet中，一些kubelet配置细节需相同；而其它方面则需要在每台机器的kubelet上单独配置。你可以手动管理kubelet配置，但kubeadm现在提供了一个<code>MaterConfig API</code>来集中管理kubelet配置。</p><p>注意，本节是利用<code>kubeadm</code>来配置<code>kubelet</code>，而不是手动配置<code>kubelet</code>。</p><p><br></p><p><strong>kubelet配置模式</strong></p><ul><li>将集群级别配置传播到每个kubelet<br>kubelet提供了一个版本化、结构化的API对象，可配置kubelet中大多数参数，并将此配置推送到集群中所有正在运行的kubelet。它被称为  the kubelet’s ComponentConfig(组件配置)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#为kubelet提供默认值。</span><br><span class="line">kubeadm init</span><br><span class="line">kubeadm join</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改服务默认子网</span><br><span class="line">kubeadm init --service-cidr 10.96.0.0/12</span><br><span class="line">#现在服务的VIP由此子网分配</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#还需要设置kubelet使用的DNS地址，每个kubelet必须相同</span><br><span class="line">--cluster-dns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#componentConfig</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">clusterDNS:</span><br><span class="line">  - 10.96.0.10</span><br></pre></td></tr></table></figure><p><br></p><ul><li>提供特定实例的配置细节<br>由于不同硬件、操作系统、网络…，一些主机需要特定的kubelet配置。<br>由于我是使用<code>systemd</code>管理kubelet，所以可相应的修改对应的值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#DNS解析文件路径，如果路径错误，则在kubelet配置错误的节点上DNS将解析失败</span><br><span class="line">--resolve-conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#节点API对象，默认被设置为主机名</span><br><span class="line">.metadata.name</span><br><span class="line">#使用如下标志指定节点名来服务默认值</span><br><span class="line">--hostname-overide</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#目前，kubelet无法自动检查CRI runtime的cgroup driver</span><br><span class="line">#指定的驱动请与docker保持一致</span><br><span class="line">--cgroup-driver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#根据集群使用的CRI runtime，可能需要为kubelet指定不同的标志</span><br><span class="line">#如，当使用Docker时，你需要指定如 --network-plugin=cni</span><br><span class="line">#但，当使用额外runtime，你需要指定 --container-runtime=remote, --container-runtime-path-endpoint=&lt;path&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#systemd</span><br><span class="line">cd /etc/systemd/system/kubelet.service.d/</span><br><span class="line">vim 10-kubeadm.conf</span><br><span class="line">#修改具体配置项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#EnvFile</span><br><span class="line">vim /var/lib/kubelet/kubeadm-flags.env</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl daemon-reload &amp;&amp; systemctl restart kubelet</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用kubeadm配置kubelet</strong><br><code>kubeadm config API</code>的<code>MasterConfiguration</code>类型，嵌入了<code>kubelet&#39;s ComponentConfig</code>到<code>.kubeletConfiguration.baseConfig</code>键下面。任何用户都可编写<code>MasterConfiguration</code>文件使用此配置键为集群中的所有kubelet设置基本配置。</p><ul><li>使用<code>kubeadm init</code>的工作流程(workflow)<br>当调用<code>kubeadm init</code>时，<code>.kubeletConfiguration.baseConfig</code>结构被整理到磁盘<code>/var/lib/kubelet/config.yaml</code>，并且上传到集群中的<code>ConfigMap</code>。ConfigMap名为<code>kubelet-config-1.x</code>，<code>.x</code>表示k8s的次要版本。kubelet配置文件同样被写入<code>/etc/kubernetes/kubelet.conf</code>。此配置文件指向允许kubelet与API server通信的客户端证书。</li></ul><p>为了解决特定实例的配置细节的模式，<code>kubeadm</code>将环境文件写入<code>/var/lib/kubelet/kubeadm-flags.env</code>，它包含了在启动时传递给kubelet的许多标志。它还包含许多动态参数(如cgroup driver)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#标志栗子</span><br><span class="line">KUBELET_KUBEADM_ARGS=&quot;--flag1=value1, --flag2=value2 ...&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在将这两个文件整理到磁盘后，kubeadm会尝试运行如下两个命令</span><br><span class="line">systemctl daemon-reload &amp;&amp; systemctl restart kubelet</span><br><span class="line"></span><br><span class="line">#在上面两个命令执行成功后，初始化会继续</span><br></pre></td></tr></table></figure><p><br></p><ul><li>使用<code>kubeadm join</code>的工作流程<br>当运行<code>kubeadm join</code>命令时，kubeadm使用Bootstrap Token凭据执行TLS bootstrap，它下载<code>kubelet-config-1.x</code> ConfigMap并将其写入<code>/var/lib/kubelet/config.yaml</code>。动态环境文件<code>/vat/lib/kubelet/kubeadm-flags.env</code>的生成方式与<code>kubeadm init</code>完成相同。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#同样，执行这两条命令</span><br><span class="line">systemctl daemon-reload &amp;&amp; systemctl restart kubelet</span><br></pre></td></tr></table></figure><p>在kubelet载入新的配置文件后，kubeadm会写入<code>/etc/kubernetes/bootstrap-kubelet.conf</code> KubeConfig文件，该文件包含CA证书和Bootstrap Token。这些由kubelet用于执行TLS Bootstrap并获得唯一的凭证，该凭证存储在<code>/etc/kubernetes/kubelet.conf</code>中。<br>写入文件后，kubelet完成执行TLS Bootstrap.</p><p><br></p><p><strong>systemd的kubelet管理文件</strong><br>此配置文件在RPM包安装的时候写入<code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code>，它由<code>systemd</code>使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Note: This dropin only works with kubeadm and kubelet v1.11+</span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf&quot;</span><br><span class="line">Environment=&quot;KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml&quot;</span><br><span class="line"># This is a file that &quot;kubeadm init&quot; and &quot;kubeadm join&quot; generates at runtime, populating the KUBELET_KUBEADM_ARGS variable dynamically</span><br><span class="line">EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env</span><br><span class="line"># This is a file that the user can use for overrides of the kubelet args as a last resort. Preferably, the user should use</span><br><span class="line"># the .NodeRegistration.KubeletExtraArgs object in the configuration files instead. KUBELET_EXTRA_ARGS should be sourced from this file.</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/kubelet</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#此文件指定kubeadm为kubelet管理的所有文件的默认位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#TLS Bootstrap</span><br><span class="line">/etc/kubernetes/bootstrap-kubelet.conf</span><br><span class="line"></span><br><span class="line">#unique kubelet identity</span><br><span class="line">/etc/kubernetes/kubelet.conf</span><br><span class="line"></span><br><span class="line">#kubelet&apos;s ComponentConfig</span><br><span class="line">/var/lib/kubelet/config.yaml</span><br><span class="line"></span><br><span class="line">#dynamic env file, KUBELET_KUBEADM_ARGS</span><br><span class="line">/var/lib/kubelt/kubeadm-flags.env</span><br><span class="line"></span><br><span class="line">#user-specified  flag overrides, KUBELET_EXTRA_ARGS, 它具有最高优先级</span><br><span class="line">/etc/sysconfig/kubelet</span><br></pre></td></tr></table></figure><p><br></p><p><strong>k8s 二进制文件和包内容</strong></p><p>k8s release附带的DEB和RPM包：</p><table><thead><tr><th>Package name</th><th>Description</th></tr></thead><tbody><tr><td>kubeadm</td><td>Installs the /usr/bin/kubeadm CLI tool and [The kubelet drop-in file(#the-kubelet-drop-in-file-for-systemd) for the kubelet.</td></tr><tr><td>kubelet</td><td>Installs the /usr/bin/kubelet binary.</td></tr><tr><td>kubectl</td><td>Installs the /usr/bin/kubectl binary.</td></tr><tr><td>kubernetes-cni</td><td>Installs the official CNI binaries into the /opt/cni/bin directory.</td></tr><tr><td>cri-tools</td><td>Installs the /usr/bin/crictl binary from <a href="https://github.com/kubernetes-incubator/cri-tools" target="_blank" rel="noopener">https://github.com/kubernetes-incubator/cri-tools</a>.</td></tr></tbody></table><p><br><br><br></p><h4 id="使用kubeadm自定义控制面板配置"><a href="#使用kubeadm自定义控制面板配置" class="headerlink" title="使用kubeadm自定义控制面板配置"></a>使用kubeadm自定义控制面板配置</h4><p>Customizing control plane configuration with kubeadm</p><p><code>kubeadm</code>配置公开以下字段，这些字段可覆盖传递给控制面板组件的默认标志：</p><ul><li>APIServerExtraArgs</li><li>ControllerManagerExtraArgs</li><li>SchedulerExtraArgs</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#apiserver</span><br><span class="line">#栗子</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1alpha2</span><br><span class="line">kind: MasterConfiguration</span><br><span class="line">kubernetesVersion: v1.11.0</span><br><span class="line">metadata:</span><br><span class="line">  name: 1.11-sample</span><br><span class="line">apiServerExtraArgs:</span><br><span class="line">  advertise-address: 192.168.0.103</span><br><span class="line">  anonymous-auth: false</span><br><span class="line">  enable-admission-plugins: AlwaysPullImages,DefaultStorageClass</span><br><span class="line">  audit-log-path: /home/johndoe/audit.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#controllermanager</span><br><span class="line">#栗子</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1alpha2</span><br><span class="line">kind: MasterConfiguration</span><br><span class="line">kubernetesVersion: v1.11.0</span><br><span class="line">metadata:</span><br><span class="line">  name: 1.11-sample</span><br><span class="line">controllerManagerExtraArgs:</span><br><span class="line">  cluster-signing-key-file: /home/johndoe/keys/ca.key</span><br><span class="line">  bind-address: 0.0.0.0</span><br><span class="line">  deployment-controller-sync-period: 50</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#scheduler</span><br><span class="line">#栗子</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1alpha2</span><br><span class="line">kind: MasterConfiguration</span><br><span class="line">kubernetesVersion: v1.11.0</span><br><span class="line">metadata:</span><br><span class="line">  name: 1.11-sample</span><br><span class="line">schedulerExtraArgs:</span><br><span class="line">  address: 0.0.0.0</span><br><span class="line">  config: /home/johndoe/schedconfig.yaml</span><br><span class="line">  kubeconfig: /home/johndoe/kubeconfig.yaml</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用kubeadm创建高可用集群"><a href="#使用kubeadm创建高可用集群" class="headerlink" title="使用kubeadm创建高可用集群"></a>使用kubeadm创建高可用集群</h4><p>Creating Highly Available Clusters with kubeadm</p><p><br><br><br></p><h4 id="使用kubeadm配置etcd高可用集群"><a href="#使用kubeadm配置etcd高可用集群" class="headerlink" title="使用kubeadm配置etcd高可用集群"></a>使用kubeadm配置etcd高可用集群</h4><p>Set up a Highly Availabile etcd Cluster With kubeadm</p><p><br><br><br></p><h4 id="Troubleshooting-kubeadm"><a href="#Troubleshooting-kubeadm" class="headerlink" title="Troubleshooting kubeadm"></a>Troubleshooting kubeadm</h4><p>官方Troubleshooting: <a href="https://kubernetes.io/docs/setup/independent/troubleshooting-kubeadm/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/independent/troubleshooting-kubeadm/</a></p><p><br></p><p>此外，在我启动<code>kubelet</code>之后，<code>kubelet</code>频繁出现一个错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#错误信息</span><br><span class="line">#journal -u kubelet</span><br><span class="line">kubelet[10720]: E0810 14:32:14.748713   10720 summary.go:102] Failed to get system container stats for &quot;/system.slice/kubelet.service&quot;: failed to get cgroup stats for &quot;/system.slice/kubelet.service&quot;: failed to get container info for &quot;/system.slice/kubelet.service&quot;: unknown container &quot;/system.slice/kubelet.service&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#解决方法</span><br><span class="line">vim /etc/sysconfig/kubelet</span><br><span class="line"></span><br><span class="line">#添加额外参数</span><br><span class="line">KUBELET_EXTRA_ARGS=&quot;--runtime-cgroups=/systemd/system.slice --kubelet-cgroups=/systemd/system.slice&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#重启服务</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用软件包创建集群"><a href="#使用软件包创建集群" class="headerlink" title="使用软件包创建集群"></a>使用软件包创建集群</h3><p>请定义相应的防火墙规则！</p><p>我是CentOS7x86_64，所以只包含了RPM包。</p><p>自带的源安装的k8s可能版本比较老，如需较新版本，可以在网上搜索kubernetes rpm包进行手动安装。<br>Rpmfind: <a href="https://rpmfind.net/" target="_blank" rel="noopener">https://rpmfind.net/</a></p><p><br></p><p><strong>k8s集群组件</strong></p><ul><li>etcd</li><li>flannel</li><li>kube-apiserver</li><li>kube-controller-manager</li><li>kube-scheduler</li><li>kubelet</li><li>kube-proxy</li><li>kube-dns</li><li>kubectl</li></ul><p><br></p><p><strong>Master</strong></p><ul><li>etcd</li><li>flannel</li><li>kube-apiserver</li><li>kube-controller-manager</li><li>kube-scheduler</li><li>kubectl</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认镜像源安装</span></span><br><span class="line">yum install -y etcd flannel kubernetes-master kubernetes-client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置kubernetes-master</span></span><br><span class="line"><span class="comment">#cd /etc/kubernetes</span></span><br><span class="line"><span class="comment">#apiserver  config  controller-manager  scheduler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改监听地址</span></span><br><span class="line">vim apiserver</span><br><span class="line">KUBE_API_ADDRESS=<span class="string">"--insecure-bind-address=0.0.0.0"</span></span><br><span class="line"><span class="comment">#生成环境一定要加上认证，我由于是测试，并未做认证</span></span><br><span class="line"><span class="comment">#未添加认证，去掉 KUBE_ADMISSION_CONTROL中的SecurityContextDeny,ServiceAccount</span></span><br><span class="line"><span class="comment">#Flag --admission-control has been deprecated, Use --enable-admission-plugins or --disable-admission-plugins instead.</span></span><br><span class="line"><span class="comment">#KUBE_ADMISSION_CONTROL="--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,ResourceQuota"</span></span><br><span class="line">KUBE_ADMISSION_CONTROL=<span class="string">"--enable-admission-plugins=NamespaceLifecycle,NamespaceExists,LimitRanger,ResourceQuota"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#此处我修改了cidr</span></span><br><span class="line">KUBE_SERVICE_ADDRESSES=<span class="string">"--service-cluster-ip-range=172.16.0.0/16"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置etcd，可先使用默认值</span></span><br><span class="line"><span class="comment">#后面可创建etcd-cluster</span></span><br><span class="line">vim /etc/etcd/etcd.conf</span><br><span class="line"><span class="comment">#修改监听地址</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">"http://0.0.0.0:2379"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建pod-network，cidr为kube-apiserver中的配置项</span></span><br><span class="line"><span class="comment">#/atomic.io/network为flannel_etcd前缀,之后再启动flannel</span></span><br><span class="line">etcdctl mk /atomic.io/network/config <span class="string">'&#123;"Network":"172.16.0.0/16"&#125;'</span></span><br><span class="line">etcdctl ls</span><br><span class="line">etcdctl get <span class="string">'/atomic.io/network/config'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置flannel</span></span><br><span class="line">vim /etc/sysconfig/flanneld</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置后启动</span></span><br><span class="line">systemctl start etcd flannel kube-apiserver kube-controller-manager kube-scheduler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">[root@master kubernetes]<span class="comment"># kubectl get all</span></span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">service/kubernetes   ClusterIP   172.16.0.1   &lt;none&gt;        443/TCP   4m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#具体参数请根据实际情况来配置</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>Node</strong></p><ul><li>flannel</li><li>kubelet</li><li>kube-porxy</li><li>kubectl</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#epel</span></span><br><span class="line">yum install -y flannel kubernetes-node kubernetes-client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#ls /etc/kubertes</span></span><br><span class="line"><span class="comment">#config  kubelet  proxy</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置etcd的地址</span></span><br><span class="line">vim /etc/sysconfig/flanneld</span><br><span class="line">FLANNEL_ETCD_ENDPOINTS=<span class="string">"http://master:2379</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">vim /etc/kubernertes/config</span></span><br><span class="line"><span class="string">KUBE_MASTER="</span>--master=http://master:8080<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#修改kubelet地址</span></span><br><span class="line"><span class="string">KUBELET_ADDRESS="</span>--address=node_addr<span class="string">"</span></span><br><span class="line"><span class="string">KUBELET_HOSTNAME="</span>--hostname-override=node_addr<span class="string">"</span></span><br><span class="line"><span class="string">KUBELET_API_SERVER="</span>--api-servers=http://master:8080<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#配置后启动</span></span><br><span class="line"><span class="string">systemctl start flanneld kube-proxy kubelet</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#具体参数请根据实际情况来配置</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>验证集群</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Master</span><br><span class="line">#kubectl安装如前</span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><p><br></p><p><strong>安装较新的k8s</strong><br>由于自带的源k8s版本比较低，可能我们需要较新的k8s版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#安装较新的Kubernetes</span><br><span class="line"></span><br><span class="line">浏览器访问 https://rpmfind.net/</span><br><span class="line"></span><br><span class="line">搜索：</span><br><span class="line">kubernetes-master(x86-64)</span><br><span class="line">kubernetes-node(x86-64)</span><br><span class="line">kubernetes-client(x86-64)</span><br><span class="line"></span><br><span class="line">选择合适的版本进行下载，三者版本请一致</span><br><span class="line">安装步骤和下面类似</span><br><span class="line"></span><br><span class="line">请注意，k8s组件安装好后，还需要安装额外组件。</span><br><span class="line">如docker, flannel, etcd...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#master</span><br><span class="line">yum install -y k8s-master k8s-client</span><br><span class="line"></span><br><span class="line">#node</span><br><span class="line">yum install -y k8s-node k8s-client</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="k8s-release生成rpm包"><a href="#k8s-release生成rpm包" class="headerlink" title="k8s-release生成rpm包"></a>k8s-release生成rpm包</h3><p>kubernetes-release: <a href="https://github.com/kubernetes/release" target="_blank" rel="noopener">https://github.com/kubernetes/release</a></p><p>使用k8s-release手动生成rpm/dep包。<br>由于yum源更不上k8s的更新速度，所以才需要我们手动制作。</p><p>需要安装并运行Docker，它要运行一个<code>rpm-builder</code>容器。</p><p>它生成一下rpm包：</p><ul><li>kubeadm</li><li>kubelet</li><li>kubectl</li></ul><p><br></p><p>官方说明：</p><p><img src="/images/K8s/buildingLinuxPackages.png" alt="官方"></p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/kubernetes/release.git</span><br><span class="line"></span><br><span class="line">cd ./release/rpm</span><br><span class="line">./docker-build.sh</span><br><span class="line"></span><br><span class="line">#此处如果连接google下载超时的话，可以在其它主机上下载，然后复制到此目录下</span><br><span class="line"></span><br><span class="line">#成功</span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">RPMs written to:</span><br><span class="line">cri-tools-1.11.0-0.x86_64.rpm  kubectl-1.11.0-0.x86_64.rpm  kubernetes-cni-0.6.0-0.x86_64.rpm</span><br><span class="line">kubeadm-1.11.0-0.x86_64.rpm    kubelet-1.11.0-0.x86_64.rpm  repodata</span><br><span class="line"></span><br><span class="line">Yum repodata written to:</span><br><span class="line">5e470d3c1c28cdd798237a48172b46f753655edee30988f4fde7000fde859d5a-primary.xml.gz</span><br><span class="line">9497c84e5650b15bf6edcffb68900b4f59f7271fa6318d3c0336386c99afd2d8-other.xml.gz</span><br><span class="line">94da9da6abd2dc8364ef51b4ca135b804deef0a37f1f13e4abeee455a8b0e897-primary.sqlite.bz2</span><br><span class="line">971e5af9d861f5ba85b12bad481749aa26546051090fa4e21c2393c21590dd5a-filelists.xml.gz</span><br><span class="line">b752df67070ff5552bd3137f00fb217578f1d810084a3e42579a53eee2a26085-other.sqlite.bz2</span><br><span class="line">f0ec7692c0654c1ec5ad9c8576ebe5b8f135c45b5d5242066df6e2d631a3ef6f-filelists.sqlite.bz2</span><br><span class="line">repomd.xml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#会在./release/rpm/output/x86_64下生成特定版本的rpm包</span><br><span class="line">pwd</span><br><span class="line">#/root/release/rpm/output/x86_64</span><br><span class="line"></span><br><span class="line">ls -l</span><br><span class="line">total 47056</span><br><span class="line">-rw-r--r-- 1 root root  4383318 Aug  3 10:25 cri-tools-1.11.0-0.x86_64.rpm</span><br><span class="line">-rw-r--r-- 1 root root  7906382 Aug  3 10:25 kubeadm-1.11.0-0.x86_64.rpm</span><br><span class="line">-rw-r--r-- 1 root root  7859238 Aug  3 10:25 kubectl-1.11.0-0.x86_64.rpm</span><br><span class="line">-rw-r--r-- 1 root root 19012182 Aug  3 10:25 kubelet-1.11.0-0.x86_64.rpm</span><br><span class="line">-rw-r--r-- 1 root root  9008530 Aug  3 10:25 kubernetes-cni-0.6.0-0.x86_64.rpm</span><br><span class="line">drwxr-xr-x 2 root root     4096 Aug  3 10:25 repodata</span><br></pre></td></tr></table></figure><p>请注意，默认会自动编译所有平台。如果只需要<code>x84_64</code>，可以更改<code>entry.sh</code>文件，将其它平台去掉，以加快编译速度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim ./release/rpm/entry.sh</span><br><span class="line"></span><br><span class="line">  ARCHS=(</span><br><span class="line">    amd64/x86_64</span><br><span class="line">    #arm/armhfp</span><br><span class="line">    #arm64/aarch64</span><br><span class="line">    #ppc64le/ppc64le</span><br><span class="line">    #s390x/s390x</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>后面还是需要使用<code>kubeadm</code>来进行引导！</p><p><br><br><br></p><h3 id="编译源码生成rpm包"><a href="#编译源码生成rpm包" class="headerlink" title="编译源码生成rpm包"></a>编译源码生成rpm包</h3><p>参考：</p><ul><li>How to build Kubernetes RPM: <a href="https://mritd.me/2017/07/12/how-to-build-kubernetes-rpm/" target="_blank" rel="noopener">https://mritd.me/2017/07/12/how-to-build-kubernetes-rpm/</a></li></ul><p>由于墙的原因，使用kubeadm进行引导还是会timeout。使用自带的yum源或网上下载的k8s rpm可能也不是最新的版本。因此需要手动编译源码以生成rpm包。</p><p>生成如下rpm包：</p><ul><li>kubernetes-master</li><li>kubernetes-client</li><li>kubernetes-node</li></ul><p><br><br><br></p><h3 id="k8s-Dashboard"><a href="#k8s-Dashboard" class="headerlink" title="k8s Dashboard"></a>k8s Dashboard</h3><p>说明:</p><ul><li>GitHub: <a href="https://github.com/kubernetes/dashboard" target="_blank" rel="noopener">https://github.com/kubernetes/dashboard</a></li><li>image: kubernetes-dashboard-amd64:v1.8.3</li><li>FAQ: <a href="https://github.com/kubernetes/dashboard/wiki/FAQ" target="_blank" rel="noopener">https://github.com/kubernetes/dashboard/wiki/FAQ</a></li><li>Let’s Encrypt: <a href="https://letsencrypt.org/" target="_blank" rel="noopener">https://letsencrypt.org/</a></li></ul><p>Let’s Encrypt是一个免费，自动化和开放的证书颁发机构。</p><p><br></p><h4 id="快速配置"><a href="#快速配置" class="headerlink" title="快速配置"></a>快速配置</h4><p>Quick setup</p><p>快速部署<code>kubernetes-dashboard</code>的方法请参考README。它适用于k8s新手并希望快速开始使用Dashboard的人。其它配置适用于有一定经验的用户，详情在以下章节。</p><p>k8s Dashboard是k8s集群的基于Web的通用UI。它允许用户管理运行在集群中的应用程序，并对应用程序进行故障排除，以及管理集群本身。</p><p>请注意，Dashboard使用了安全设置。这意味着，默认情况下它具有最小的权限集，并且只能通过https访问。<br>建议在安装和执行Dashboard之前，先阅读<strong><a href="https://github.com/kubernetes/dashboard/wiki/Access-control" target="_blank" rel="noopener">Access Control</a></strong>指南。</p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">#wget https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</span><br><span class="line">#kubectl apply -f /path/kubernetes-dashboard.yaml</span><br><span class="line"></span><br><span class="line">secret/kubernetes-dashboard-certs created</span><br><span class="line">serviceaccount/kubernetes-dashboard created</span><br><span class="line">role.rbac.authorization.k8s.io/kubernetes-dashboard-minimal created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard-minimal created</span><br><span class="line">deployment.apps/kubernetes-dashboard created</span><br><span class="line">service/kubernetes-dashboard created</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">kubectl get pods -n kube-system -o wide |grep dashboard</span><br><span class="line">kubernetes-dashboard-6948bdb78-rnnjp   1/1       Running   1          1d        10.244.1.2       node</span><br><span class="line"></span><br><span class="line"> kubectl get service -n kube-system -o wide |grep dashboard</span><br><span class="line">kubernetes-dashboard   ClusterIP   10.110.83.129   &lt;none&gt;        443/TCP         13m       k8s-app=kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#要从本地访问Dashboard，必须为k8s集群创建安全通道</span><br><span class="line">kubectl apply</span><br><span class="line">Starting to serve on 127.0.0.1:8001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#访问Dashboard</span><br><span class="line">http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/</span><br><span class="line"></span><br><span class="line">#http://localhost:8001/ui已弃用</span><br><span class="line">#&lt;h3&gt;Unauthorized&lt;/h3&gt;</span><br><span class="line">#会直接报403，还需要做前面所说的操作。</span><br><span class="line"></span><br><span class="line">#Heapster必须在集群中运行才能使metric, graphs可用</span><br><span class="line">#Heapster已被弃用，请考虑使用metrics-server和第三方metrics pipeline收集Prometheus格式的指标</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>Installation</p><p><strong>官方版</strong><br>当从旧版Dashboard升级到 <code>v1.7+</code>，请确保删除<code>kubernetes-dashboard</code>服务账户的集群角色绑定，否则Dashboard将具有对集群的完全管理权限。</p><p><br></p><p><strong>快速配置</strong><br>快速部署<code>kubernetes-dashboard</code>的方法请参考README。它适用于k8s新手并希望快速开始使用Dashboard的人。</p><p><br></p><p><strong>推荐配置</strong><br>直接访问Dashboard(不是<code>kubectl proxy</code>)，应该使用有效的证书来建立安全的HTTPS连接。它们可由公共可信证书颁发机构(如<a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s Encrypt</a>)生成，使用它们替代Dashboard自动生成的证书。</p><p>此配置要求证书存储在<code>kube-system</code>命名空间中名为<code>kubernetes-dashboard-certs</code>的证书中。<br>假设你有存储在<code>$HOME/certs</code>目录下的<code>dashboard.crt</code>和<code>dashboard.key</code>文件。你应该使用这些文件创建<code>secret</code>。之后，便可以开始配置Dashboard。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看</span></span><br><span class="line">kubectl get secret -n kube-system | grep dashboard</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">kubectl describe secret/kubernetes-dashboard-certs -n kube-system</span><br><span class="line">Name:         kubernetes-dashboard-certs</span><br><span class="line">Namespace:    kube-system</span><br><span class="line">Labels:       k8s-app=kubernetes-dashboard</span><br><span class="line">Annotations:</span><br><span class="line">Type:         Opaque</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建</span></span><br><span class="line">kubectl create secret generic kubernetes-dashboard-certs --from-file=<span class="variable">$HOME</span>/certs -n kube-system</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#部署Dashboard</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure><p><br></p><p><strong>替代配置</strong><br>此配置并不安全。不使用证书，仅通过HTTP公开Dashboard。在此配置中，只能通过使用<code>Authorization Header</code>功能来确保访问控制。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/alternative/kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure><p><br></p><p><strong>开发版</strong><br>不建议在线上环境使用开发版，请使用稳定的正式版。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#部署</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard-head.yaml</span><br></pre></td></tr></table></figure><p><br></p><p><strong>升级</strong><br>安装后，Deployment不会自动更新。为了更新它，你需要删除部署的pod并等待它重新创建。重新创建之后，它会使用最新的镜像<code>image:latest</code>.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除pod</span></span><br><span class="line">kubectl -n kube-system delete $(kubectl -n kube-system get pod -o name | grep dashboard)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="证书管理"><a href="#证书管理" class="headerlink" title="证书管理"></a>证书管理</h4><p>Certificate management</p><p>本节简短介绍了如何获取可在Dashboard中启用HTTPS的证书。有两个步骤要做：</p><ul><li>生成证书<ul><li>证书认证机构(Certificate Authority)</li><li>自签名证书(Self-signed certificate)</li></ul></li><li>将证书传递给Dashboard<ul><li>按照前面的推荐配置方法</li><li>其它情况，你需要修改Dashboard的YAML部署文件，并将<code>--tls-key-file</code>, <code>--tls-cert-file</code>传递给Dashboard</li></ul></li></ul><p><br></p><p><strong>公众信任的证书认证机构</strong><br>Public trusted Certificate Authority</p><p>有许多公共和免费的证书提供商可供选择。如前面提到的<a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s encrypt</a>，具体操作查看此网站说明。</p><p><br></p><p><strong>自签名证书</strong><br>Self-signed certificate</p><p>如果你打算自己生成证书，你需要像<a href="https://www.openssl.org/" target="_blank" rel="noopener">OpenSSL</a>这样的库来帮助你。</p><ul><li>生成私钥(private key)和证书签名请求(certificate signing request)</li><li>生成SSL证书</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#Generate private key and certificate signing request</span><br><span class="line">#创建SSL证书需要私钥和证书签名请求</span><br><span class="line"></span><br><span class="line">openssl genrsa -des3 -passout pass:x -out dashboard.pass.key 2048</span><br><span class="line"></span><br><span class="line">openssl rsa -passin pass:x -in dashboard.pass.key -out dashboard.key</span><br><span class="line"></span><br><span class="line">rm dashboard.pass.key</span><br><span class="line"></span><br><span class="line">#需要填写一些信息</span><br><span class="line">#A challenge password []请直接按回车，不要填写内容</span><br><span class="line">openssl req -new -key dashboard.key -out dashboard.csr</span><br><span class="line"></span><br><span class="line">Country Name (2 letter code) [XX]:CN</span><br><span class="line">State or Province Name (full name) []:SC</span><br><span class="line">Locality Name (eg, city) [Default City]:CD</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:Student</span><br><span class="line">Organizational Unit Name (eg, section) []:HT</span><br><span class="line">Common Name (eg, your name or your server&apos;s hostname) []:Zhang21</span><br><span class="line">Email Address []:reds@zhang21.cn</span><br><span class="line"></span><br><span class="line">Please enter the following &apos;extra&apos; attributes</span><br><span class="line">to be sent with your certificate request</span><br><span class="line">A challenge password []:</span><br><span class="line">An optional company name []:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Generate SSL certificate</span><br><span class="line">#自签名SSL证书由 .key私钥 和 .csr生成</span><br><span class="line">openssl x509 -req -sha256 -days 1000 -in dashboard.csr -signkey dashboard.key -out dashboard.crt</span><br><span class="line"></span><br><span class="line">Signature ok</span><br><span class="line">subject=/C=CN/ST=SC/L=CD/O=Student/OU=HT/CN=Zhang21/emailAddress=reds@zhang21.cn</span><br><span class="line">Getting Private key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">ls</span><br><span class="line">dashboard.crt  dashboard.csr  dashboard.key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#将密钥和证书移动到需要的目录下</span><br><span class="line">mv ./dashboard.* /etc/kubernetes/pki/dashboard</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#接下来便可以创建secret了</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="访问Dashboard"><a href="#访问Dashboard" class="headerlink" title="访问Dashboard"></a>访问Dashboard</h4><p>Accessing Dashboard</p><p>在集群上安装Dashboard后，可通过几种不同的方式访问它。遇到什么问题，可查看FAQ。</p><ul><li>1.6.x and below</li><li>1.7.x and above</li></ul><p><br></p><h5 id="1-7-x-and-above"><a href="#1-7-x-and-above" class="headerlink" title="1.7.x and above"></a>1.7.x and above</h5><p>Accessing Dashboard 1.7.X and above</p><p>我的Dashboard v1.8.5.</p><p>前面的HTTP/HTTPs都不说了。<br>但请注意，不要把Dashboard使用HTTP公开展示。</p><p><br></p><p><strong>kubectl proxy</strong><br><code>kubectl proxy</code>在你的计算机和k8s APIserver之间创建代理服务器。默认情况下它只能在本地访问。</p><p>注意，不应该使用<code>kubectl proxy</code>命令公开Dashboard，因为它只允许HTTP连接。对于<code>localhost</code>和<code>127.0.0.1</code>以外的域，将无法登录。</p><p>首先让我们检查kubectl是否已正确配置并是否可访问集群:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kubectl cluster-info</span><br><span class="line"></span><br><span class="line"><span class="comment">#Kubernetes master is running at https://192.168.31.49:6443</span></span><br><span class="line"><span class="comment">#KubeDNS is running at https://192.168.31.49:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动代理服务器</span></span><br><span class="line">kubectl proxy</span><br><span class="line"></span><br><span class="line"><span class="comment">#Starting to serve on 127.0.0.1:8001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#之后你便可以从浏览器访问Dashboard</span></span><br><span class="line"><span class="comment">#http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/</span></span><br><span class="line"><span class="comment">#但我访问还是403，应该还需要创建Service Token之类。</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>NodePort</strong><br>这种访问Dashboard的方式，建议用于单节点设置的开发环境中。<br>请注意，此HTTPS方式需要安装前面生成的证书。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编辑 kubernetes-dashboard服务</span></span><br><span class="line">kubectl -n kube-system edit service/kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Please edit the object below. Lines beginning with a '#' will be ignored,</span></span><br><span class="line"><span class="comment"># and an empty file will abort the edit. If an error occurs while saving this file will be</span></span><br><span class="line"><span class="comment"># reopened with the relevant failures.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;<span class="string">"apiVersion"</span>:<span class="string">"v1"</span>,<span class="string">"kind"</span>:<span class="string">"Service"</span>,<span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"labels"</span>:&#123;<span class="string">"k8s-app"</span>:<span class="string">"kubernetes-dashboard"</span>&#125;,<span class="string">"name"</span>:<span class="string">"kubernetes-dashboard"</span>,<span class="string">"namespace"</span>:<span class="string">"kube-system"</span>&#125;,<span class="string">"spec"</span>:&#123;<span class="string">"ports"</span>:[&#123;<span class="string">"port"</span>:443,<span class="string">"targetPort"</span>:8443&#125;],<span class="string">"selector"</span>:&#123;<span class="string">"k8s-app"</span>:<span class="string">"kubernetes-dashboard"</span>&#125;&#125;&#125;</span><br><span class="line">  creationTimestamp: 2018-08-09T01:14:01Z</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  resourceVersion: <span class="string">"200618"</span></span><br><span class="line">  selfLink: /api/v1/namespaces/kube-system/services/kubernetes-dashboard</span><br><span class="line">  uid: 80091845-9b71-11e8-a08a-000c298ee39f</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: 10.110.83.129</span><br><span class="line">  ports:</span><br><span class="line">  - port: 443</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8443</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP</span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将 type: ClusterIP 修改为 type: NodePort</span></span><br><span class="line"><span class="built_in">type</span>: NodePort</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接保存退出(:wq)</span></span><br><span class="line"><span class="comment">#service/kubernetes-dashboard edited</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">kubectl -n kube-system get service/kubernetes-dashboard</span><br><span class="line">NAME                   TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">kubernetes-dashboard   NodePort   10.110.83.129   &lt;none&gt;        443:31965/TCP   6h</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看端口</span></span><br><span class="line">netstat -nltup | grep 31965</span><br><span class="line">tcp6       0      0 :::31965                :::*                    LISTEN      11280/kube-proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Dashboard展示在 31965(HTTPS) 端口上。</span></span><br><span class="line"><span class="comment">#现在可在浏览器访问 &lt;master-ip&gt;:31965</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可使用Nginx做前端代理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#此处注意，需要将dashboard.crt证书安装到你的电脑上</span></span><br><span class="line"><span class="comment">#不然浏览器会拒绝</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果你尝试在多节点集群上使用`NodePort`公开Dashboard，则必须找到运行Dashboard的节点的IP才能访问它。</span></span><br><span class="line">https://&lt;node-ip&gt;:&lt;nodeport&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/K8s/k8s_dashboard_nodeport.png" alt="Dashboard NodePort"></p><p><img src="/images/K8s/k8s_dashboard_forbidden.png" alt="没有权限"></p><p>由图可看出，还需要配置权限才能够正常访问Dashboard！</p><p><br></p><p><strong>API Server</strong><br>如果公开k8s API server并可以从外部访问，则你可直接访问url。<br>Dashboard: <a href="https://master-ip:apiserver-port/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/" target="_blank" rel="noopener">https://master-ip:apiserver-port/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/</a></p><p>注意，只有在浏览器中安装证书时，才能使用这用访问方式。</p><p><br></p><p><strong>Ingress</strong><br>Dashboard可以使用 <code>ingress</code> 进行公开。详情: <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/services-networking/ingress/</a></p><p><br><br><br></p><h4 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h4><p>直接使用<code>NodePort</code>方式访问比较麻烦，所以配置使用Nginx反向代理来访问。</p><p>Nginx配置文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/k8sUI.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name k8s.ui;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/kubernetes/pki/dashboard/dashboard.crt;</span><br><span class="line">    ssl_certificate_key /etc/kubernetes/pki/dashboard/dashboard.key;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass https://127.0.0.1:31965;</span><br><span class="line">      proxy_read_timeout 60s;</span><br><span class="line">      proxy_send_timeout 60s;</span><br><span class="line">      proxy_connect_timeout 60s;</span><br><span class="line">      proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_404;</span><br><span class="line"></span><br><span class="line">      proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">      proxy_set_header Connection &apos;upgrade&apos;;</span><br><span class="line">      proxy_set_header Host $host;</span><br><span class="line">      proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">      proxy_set_header X-Forwarded-Proto https;</span><br><span class="line"></span><br><span class="line">      proxy_buffer_size 64k;</span><br><span class="line">      proxy_buffers 4 64k;</span><br><span class="line">      proxy_busy_buffers_size 128k;</span><br><span class="line">      proxy_temp_file_write_size 128k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nginx -t</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>之后解析DNS，就可直接通过域名访问了。</p><p><br><br><br></p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>Access Control</p><p>安装Dashboard后，我们便可以专注于为用户配置对集群资源的访问控制。从 <code>v1.7</code> 开始，Dashboard默认不再具有完全管理权限(admin privilige)，所有权限都被撤销，并且只授予了Dashboard工作所需的最小权限。所以下面的介绍都只针对于 <code>v1.7+</code> 版本。<br>如果Dashboard只能由受信任的人员访问，你可能希望授予他们完全管理权限，则所有人都具有完全管理的权限。请注意，其它应用程序不应直接访问Dashboard，因为它可能导致权限升级。确保集群内的流量仅限于命名空间，或者只是撤销集群内应用程序对Dashboard的访问权限。</p><p>可查看<code>kubernetst-dashboard.yaml</code>配置文件，里面有<code>minimal</code>的权限。</p><p><br></p><p><strong>介绍</strong><br>k8s支持几种方法来认证(authenticating)和授权(authorizing)用户。授权由k8s API server处理。Dashboard仅充当代理并将所有认证信息传递给API server。在禁止访问的情况下，相应的警告信息会显示到Dashboard上。</p><p><br></p><p><strong>默认Dashboard权限</strong></p><ul><li><p><code>v1.7</code></p><ul><li><code>create</code> and <code>watch</code> permissions for secrets in <code>kube-system</code> namespace required to create and watch for changes of <code>kubernetes-dashboard-key-holder</code> secret.</li><li><code>get</code>, <code>update</code> and <code>delete</code> permissions for secrets named <code>kubernetes-dashboard-key-holder</code> and <code>kubernetes-dashboard-certs</code> in <code>kube-system</code> namespace.</li><li><code>proxy</code> permission to <code>heapster</code> service in <code>kube-system</code> namespace required to allow getting metrics from heapster.</li></ul></li><li><p><code>v1.8</code></p><ul><li><code>create</code> permission for secrets in <code>kube-system</code> namespace required to create <code>kubernetes-dashboard-key-holder</code> secret.</li><li><code>get</code>, <code>update</code> and <code>delete</code> permissions for secrets named <code>kubernetes-dashboard-key-holder</code> and <code>kubernetes-dashboard-certs</code> in <code>kube-system</code> namespace.</li><li><code>get</code> and <code>update</code> permissions for config map named <code>kubernetes-dashboard-settings</code> in <code>kube-system</code> namespace.</li><li><code>proxy</code> permission to <code>heapster</code> service in <code>kube-system</code> namespace required to allow getting metrics from heapster.</li></ul></li></ul><p><br></p><p><strong>Authentication</strong><br>从<code>v1.7</code>版本开始，Dashboard支持的用户认证基于：</p><ul><li><code>Authorization: Bearer &lt;token&gt;</code></li><li><code>Bearer Token</code></li><li><code>Username/password</code></li><li><code>Kubeconfig</code></li></ul><p><br></p><p><strong>Login view</strong><br>要使其显示在Dashboard中，你需要启用HTTPS访问Dashboard。</p><p>使用跳过选项将使Dashboard使用Service Account权限。</p><p><img src="/images/K8s/login_view.png" alt="Login view"></p><p><br></p><p><strong>Authorization header</strong><br>在通过HTTP访问Dashboard时，使用 <code>authorization header</code> 是使Dashboard充当用户的唯一方法。</p><p>要使Dashboard使用<code>authorization header</code>，你只需将每个请求中的<code>Authorization: Bearer &lt;token&gt;</code>传递给Dashboard。这可以通过在Dashboard前端配置反向代理来实现。代理将负责身份提供者的身份验证，并将请求头部中生成的token传递给Dashboard。注意，需要正确配置k8s API server才能接受这些token。</p><p>注意： 如果通过API server proxy访问Dashboard，则<code>authorization header</code>将不起作用。这是因为一旦请求到达API server，所有其它header都将被删除。</p><p><br></p><p><strong>Bearer Token</strong><br>建议先熟悉<a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/" target="_blank" rel="noopener">k8s authentication doc</a>，以了解如何获取可用于登录的token。例如，每个<code>Service Account</code>都有一个具有有效<code>Bearer token</code>，用于登录Dashboard。</p><p>推荐讲座，了解如何创建服务账户并对其进行授权：</p><ul><li><a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#service-account-tokens" target="_blank" rel="noopener">Service Account Tokens</a></li><li><a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole" target="_blank" rel="noopener">Role and  ClusterRole</a></li><li><a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#service-account-permissions" target="_blank" rel="noopener">Service Account Permissions</a></li></ul><p><img src="/images/K8s/bearer_token.png" alt="Bearer Token"></p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#使用kubectl获取token</span><br><span class="line">#默认情况下，k8s创建了许多服务账号。所有都具有不同的访问权限</span><br><span class="line"></span><br><span class="line">kubectl -n kube-system get secret</span><br><span class="line"></span><br><span class="line">NAME                                             TYPE                                  DATA      AGE</span><br><span class="line">attachdetach-controller-token-bszq5              kubernetes.io/service-account-token   3         2d</span><br><span class="line">bootstrap-signer-token-bqv44                     kubernetes.io/service-account-token   3         2d</span><br><span class="line">bootstrap-token-uzdl9x                           bootstrap.kubernetes.io/token         7         2d</span><br><span class="line">certificate-controller-token-rsftn               kubernetes.io/service-account-token   3         2d</span><br><span class="line">clusterrole-aggregation-controller-token-x64f5   kubernetes.io/service-account-token   3         2d</span><br><span class="line">coredns-token-dfmpb                              kubernetes.io/service-account-token   3         2d</span><br><span class="line">cronjob-controller-token-xwtkc                   kubernetes.io/service-account-token   3         2d</span><br><span class="line">daemon-set-controller-token-vxzp4                kubernetes.io/service-account-token   3         2d</span><br><span class="line">default-token-5868t                              kubernetes.io/service-account-token   3         2d</span><br><span class="line">deployment-controller-token-jc6bs                kubernetes.io/service-account-token   3         2d</span><br><span class="line">disruption-controller-token-znghk                kubernetes.io/service-account-token   3         2d</span><br><span class="line">endpoint-controller-token-mnxfh                  kubernetes.io/service-account-token   3         2d</span><br><span class="line">expand-controller-token-6srzj                    kubernetes.io/service-account-token   3         2d</span><br><span class="line">flannel-token-7548k                              kubernetes.io/service-account-token   3         2d</span><br><span class="line">generic-garbage-collector-token-22qd2            kubernetes.io/service-account-token   3         2d</span><br><span class="line">horizontal-pod-autoscaler-token-zs8pj            kubernetes.io/service-account-token   3         2d</span><br><span class="line">job-controller-token-zbfhd                       kubernetes.io/service-account-token   3         2d</span><br><span class="line">kube-proxy-token-xxp9h                           kubernetes.io/service-account-token   3         2d</span><br><span class="line">kubernetes-dashboard-certs                       Opaque                                3         1h</span><br><span class="line">kubernetes-dashboard-key-holder                  Opaque                                2         2d</span><br><span class="line">kubernetes-dashboard-token-sgq5t                 kubernetes.io/service-account-token   3         2d</span><br><span class="line">namespace-controller-token-25n2k                 kubernetes.io/service-account-token   3         2d</span><br><span class="line">node-controller-token-289v8                      kubernetes.io/service-account-token   3         2d</span><br><span class="line">persistent-volume-binder-token-x7t7x             kubernetes.io/service-account-token   3         2d</span><br><span class="line">pod-garbage-collector-token-xxjqp                kubernetes.io/service-account-token   3         2d</span><br><span class="line">pv-protection-controller-token-9s4x7             kubernetes.io/service-account-token   3         2d</span><br><span class="line">pvc-protection-controller-token-l7m7j            kubernetes.io/service-account-token   3         2d</span><br><span class="line">replicaset-controller-token-mszv9                kubernetes.io/service-account-token   3         2d</span><br><span class="line">replication-controller-token-8gl9s               kubernetes.io/service-account-token   3         2d</span><br><span class="line">resourcequota-controller-token-whljw             kubernetes.io/service-account-token   3         2d</span><br><span class="line">service-account-controller-token-h87wp           kubernetes.io/service-account-token   3         2d</span><br><span class="line">service-controller-token-qn5jz                   kubernetes.io/service-account-token   3         2d</span><br><span class="line">statefulset-controller-token-zps2l               kubernetes.io/service-account-token   3         2d</span><br><span class="line">token-cleaner-token-nccrw                        kubernetes.io/service-account-token   3         2d</span><br><span class="line">ttl-controller-token-dmmb9                       kubernetes.io/service-account-token   3         2d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl -n kube-system describe secret/replicaset-controller-token-mszv9</span><br><span class="line">Name:         replicaset-controller-token-mszv9</span><br><span class="line">Namespace:    kube-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name=replicaset-controller</span><br><span class="line">              kubernetes.io/service-account.uid=d18a5f8f-9a0d-11e8-a08a-000c298ee39f</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:     1025 bytes</span><br><span class="line">namespace:  11 bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJyZXBsaWNhc2V0LWNvbnRyb2xsZXItdG9rZW4tbXN6djkiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoicmVwbGljYXNldC1jb250cm9sbGVyIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiZDE4YTVmOGYtOWEwZC0xMWU4LWEwOGEtMDAwYzI5OGVlMzlmIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmUtc3lzdGVtOnJlcGxpY2FzZXQtY29udHJvbGxlciJ9.O6hXQwsXdSXREsaao_V7pmeQkfWGEd4QLDxczxNZVcrT2yN9F1KFJ9IklYVlGSTo1cKA4OxkYqjKWzWPBEn6wVLhVbf6_WqTrFi4qEtj_nmhXwqcwkpioJzyXu7x7wljpH-H32bEaLW1l-y5kQBUztF9fAHZZyv0f9vaRK4u4zVzuq4JzauLB9aVBrgt6rSaOENdr8OGm1yjM_--gQtc1qoF8mLo3RK6qLpFjT70EZKgyys_GXpFrrnhG5maUmlFqCPZ6P0cl8d6SuDfkQIlFxNHxtJmOPSCIE6wjgkOncRtgWHRRVsRPnhDGOp0kbmdLTfpOx2zZEiCD5btXL0OkA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#我们可以使用显示的token登录Dashboard</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Basic</strong><br>默认情况下，禁用基本身份认证，也就是用户密码认证。原因是需要使用授权模式<code>RBAC</code>和<code>--basic-auth-file</code>标志配置k8s API server。没有的话，API server会自动回退到匿名用户(anonymous user)，并且无法检查提供的凭据是否有效。</p><p>修改<code>--authentication-mode=basic</code>标志在Dashboard中启用基本身份认证，默认值为<code>--authentication-mode=token</code>。</p><p><br></p><p><strong>kubeconfig</strong><br>这种登录方法是为了方便起见而提供的。<code>kubeconfig file</code>仅支持<code>--authentication-mode</code>标志指定认证选项。如果它配置为其它方式，Dashboard中将显示错误消息。</p><p><img src="/images/K8s/kubeconfig.png" alt="kubeconfig"></p><p><br></p><p><strong>Admin privileges</strong><br>注意： 在操作之前，请确保你知道自己在做什么。向Dashboard的服务账号赋予管理权限可能会存在安全风险。</p><p>你可以通过创建<code>ClusterRoleBinding</code>来授权Dashboard的服务账号完全的管理权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#栗子</span><br><span class="line">dashboard-admin.yaml</span><br><span class="line"></span><br><span class="line">#官方文档版</span><br><span class="line"></span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#开发版</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: kubernetes-dashboard-head</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard-head</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: kubernetes-dashboard-head</span><br><span class="line">  namespace: kube-system</span><br></pre></td></tr></table></figure><p><br></p><h4 id="创建示例用户"><a href="#创建示例用户" class="headerlink" title="创建示例用户"></a>创建示例用户</h4><p>Creating sample user</p><p>在本节中，我们将了解如何使用k8s Service Account机制创建新用户，授权用户管理权限并使用与此用户关联的<code>Bearer Token</code>进行登录。<br>关于<code>grant/deny</code>权限，请查看文档<a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/" target="_blank" rel="noopener">authentication</a>和<a href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/" target="_blank" rel="noopener">authorization</a>以了解详情。</p><p>创建<code>xxx.yaml</code>文件，并使用<code>kubectl create -f xxx.yaml</code>命令创建它们。</p><p><br></p><p><strong>创建 Service Account</strong><br>在<code>kube-system</code>命名空间中创建名为<code>admin-user</code>的服务账户:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin-user</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建</span></span><br><span class="line">kubectl create -f /etc/kubernetes/auth/admin-user_SA.yaml</span><br><span class="line"><span class="comment">#serviceaccount/admin-user created</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">kubectl -n kube-system get secret | grep admin-user</span><br><span class="line"><span class="comment">#admin-user-token-qj8hj                           kubernetes.io/service-account-token   3         56s</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>创建 ClusterRoleBinding</strong><br>在大多数情况下，在使用<code>kops</code>, <code>kubeadm</code>等管理配置集群后，<code>Role</code>都已存在于集群中。我们可使用它为<code>ServiceAccount</code>仅创建<code>RoleBinding</code>。</p><p>注意: <code>ClusterRoleBinding</code>的<code>apiVersion</code>资源可能不同于k8s version。从<code>v1.8</code>开始，它被提升为<code>rbac.authorization.k8s.io/v1</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin-user</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">- kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">admin-user</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建</span></span><br><span class="line">kubectl create -f /etc/kubernetes/Auth/cluster-admin_CRB.yaml </span><br><span class="line"><span class="comment">#clusterrolebinding.rbac.authorization.k8s.io/admin-user created</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>Bearer Token</strong><br>现在我们需要去找到用于登录的Token。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk &apos;&#123;print $1&#125;&apos;)</span><br><span class="line"></span><br><span class="line">Name:         admin-user-token-qj8hj</span><br><span class="line">Namespace:    kube-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name=admin-user</span><br><span class="line">              kubernetes.io/service-account.uid=58d39b31-9c40-11e8-a08a-000c298ee39f</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:     1025 bytes</span><br><span class="line">namespace:  11 bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLXFqOGhqIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiI1OGQzOWIzMS05YzQwLTExZTgtYTA4YS0wMDBjMjk4ZWUzOWYiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06YWRtaW4tdXNlciJ9.4hCqFj7R7CwAewnFxsy5QC91v6288T7aOCZXae7AbqXECiFb2yB5x7VQs0GjnUj8jbSZamBpI_D6D7p8PoRUmPZg2NOF46TEztsR9wcsEywUr6EHdXMGy6HUtvedy45K1j9h8oFp9nAqvxa6M7hrfV_yy-XlJdqTo7J06VlT_czpWNScCkjejIOlZXFvYL5f5ha0V4L5XCdlFkf7DYbsNV6odquIKavg270g4nAr1ZAJ14SjeFdfRVvimS4N-W7pb9vmOeZBnAmGuotKoqU1OlzZrMfpsPGIXy5GW3zD8PvsbGU9Xn6lyPHH08X0kXCUACQHx4UiaMFzlnhaC2XIMQ</span><br></pre></td></tr></table></figure><p>现在复制Token来登录.</p><p><img src="/images/K8s/admin_user_token.png" alt="Login"></p><p><img src="/images/K8s/admin_user_dashboard.png" alt="Dashboash"></p><p><br><br><br></p><h3 id="Heapster"><a href="#Heapster" class="headerlink" title="Heapster"></a>Heapster</h3><p>GitHub: <a href="https://github.com/kubernetes/heapster" target="_blank" rel="noopener">https://github.com/kubernetes/heapster</a></p><p>注意: Heapster已被启用，考虑使用<code>metric-server</code>和第三方<code>metric pipeline</code>来收集Prometheus格式的指标。</p><p><br></p><p><strong>Heapster 启用时间轴</strong></p><table><thead><tr><th>Kubernetes Release</th><th>Action</th><th>Policy/Support</th></tr></thead><tbody><tr><td>Kubernetes 1.11</td><td>Initial Deprecation</td><td>No new features or sinks are added. Bugfixes may be made.</td></tr><tr><td>Kubernetes 1.12</td><td>Setup Removal</td><td>The optional to install Heapster via the Kubernetes setup script is removed.</td></tr><tr><td>Kubernetes 1.13</td><td>Removal</td><td>No new bugfixes will be made. Move to kubernetes-retired organization.</td></tr></tbody></table><p><br><br><br></p><h3 id="metric-server"><a href="#metric-server" class="headerlink" title="metric-server"></a>metric-server</h3><p>GitHub: <a href="https://github.com/kubernetes-incubator/metrics-server" target="_blank" rel="noopener">https://github.com/kubernetes-incubator/metrics-server</a></p><p>具体详情可参考README。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#下载到本地</span><br><span class="line">git clone https://github.com/kubernetes-incubator/metrics-server.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#移动到管理目录</span><br><span class="line">mv metrics-server/ /etc/kubernetes/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#k8s v1.8+</span><br><span class="line">ls /etc/kubernetes/metrics-server/deploy/v1.8+/</span><br><span class="line">auth-delegator.yaml  auth-reader.yaml  metrics-apiservice.yaml  metrics-server-deployment.yaml  metrics-server-service.yaml  resource-reader.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#注意metrics-server-deployment.yaml文件，需要一个镜像，请准备</span><br><span class="line">#gcr.io/google_containers/metrics-server-amd64:v0.2.1</span><br><span class="line"></span><br><span class="line">docker pull zhang21/metrics-server-amd64:v0.2.1</span><br><span class="line">docker tag zhang21/metrics-server-amd64:v0.2.1 gcr.io/google_containers/metrics-server-amd64:v0.2.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建</span><br><span class="line">#注意，在顶层进行创建</span><br><span class="line">cd /etc/kubernetes/metrics-server</span><br><span class="line">kubectl create -f deploy/v1.8+/</span><br><span class="line"></span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/metrics-server:system:auth-delegator created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/metrics-server-auth-reader created</span><br><span class="line">apiservice.apiregistration.k8s.io/v1beta1.metrics.k8s.io created</span><br><span class="line">serviceaccount/metrics-server created</span><br><span class="line">deployment.extensions/metrics-server created</span><br><span class="line">service/metrics-server created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/system:metrics-server created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/system:metrics-server created</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">kubectl -n kube-system  get deployment</span><br><span class="line"></span><br><span class="line">NAME                   DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">coredns                2         2         2            2           2d</span><br><span class="line">kubernetes-dashboard   1         1         1            1           19h</span><br><span class="line">metrics-server         1         1         1            0           39s</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="pause容器"><a href="#pause容器" class="headerlink" title="pause容器"></a>pause容器</h2><p>参考:</p><ul><li>《Kubernetes之“暂停”容器》: <a href="http://dockone.io/article/2785" target="_blank" rel="noopener">http://dockone.io/article/2785</a></li><li>《Pause容器》: <a href="https://jimmysong.io/kubernetes-handbook/concepts/pause-container.html" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/concepts/pause-container.html</a></li><li>GitHub: <a href="https://github.com/kubernetes/kubernetes/tree/master/build/pause" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/tree/master/build/pause</a></li></ul><p><br></p><p>Pause容器，又叫Infra容器。它不是pod，而是一个容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker ps | grep pause</span><br><span class="line">35c9aaa68a06        k8s.gcr.io/pause:3.1   &quot;/pause&quot;                 18 hours ago        Up 18 hours                             k8s_POD_coredns-78fcdf6894-hn46d_kube-system_daab8e60-9a0d-11e8-a08a-000c298ee39f_0</span><br><span class="line">d22a1baac736        k8s.gcr.io/pause:3.1   &quot;/pause&quot;                 18 hours ago        Up 18 hours                             k8s_POD_coredns-78fcdf6894-wqxbx_kube-system_daac5838-9a0d-11e8-a08a-000c298ee39f_0</span><br><span class="line">4d0cdc392629        k8s.gcr.io/pause:3.1   &quot;/pause&quot;                 18 hours ago        Up 18 hours                             k8s_POD_kube-flannel-ds-7gbvd_kube-system_59129dff-9a0f-11e8-a08a-000c298ee39f_0</span><br><span class="line">4f28747a2044        k8s.gcr.io/pause:3.1   &quot;/pause&quot;                 18 hours ago        Up 18 hours                             k8s_POD_kube-proxy-rhrks_kube-system_da990e28-9a0d-11e8-a08a-000c298ee39f_0</span><br><span class="line">f2bd7bd47eb4        k8s.gcr.io/pause:3.1   &quot;/pause&quot;                 18 hours ago        Up 18 hours                             k8s_POD_kube-scheduler-master_kube-system_537879acc30dd5eff5497cb2720a6d64_0</span><br><span class="line">d732ffba5530        k8s.gcr.io/pause:3.1   &quot;/pause&quot;                 18 hours ago        Up 18 hours                             k8s_POD_kube-controller-manager-master_kube-system_01c36146e2c80849d7b6993e68aa5e67_0</span><br><span class="line">cd7636bac6df        k8s.gcr.io/pause:3.1   &quot;/pause&quot;                 18 hours ago        Up 18 hours                             k8s_POD_kube-apiserver-master_kube-system_1bd24cc043a06bf7e71b96167946c220_0</span><br><span class="line">d4adb3504543        k8s.gcr.io/pause:3.1   &quot;/pause&quot;                 18 hours ago        Up 18 hours                             k8s_POD_etcd-master_kube-system_2cc1c8a24b68ab9b46bca47e153e74c6_0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#或者是这样</span><br><span class="line">#registry.access.redhat.com/rhel7/pod-infrastructure:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#rpm包安装kubelet的默认配置</span><br><span class="line">KUBELET_POD_INFRA_CONTAINER=&quot;--pod-infra-container-image=registry.access.redhat.com/rhel7/pod-infrastructure:latest&quot;</span><br><span class="line"></span><br><span class="line">#kubeadm安装kubelet的默认配置</span><br><span class="line">KUBELET_POD_INFRA_CONTAINER=--pod-infra-container-image=k8s.gcr.io/pause:3.1</span><br></pre></td></tr></table></figure><p><br></p><p><strong>pause容器的作用</strong><br>k8s中的pause容器主要为每个业务提供以下功能：</p><ul><li>在<code>pod</code>中担任Linux命名空间共享的基础</li><li>启用<code>pid</code>命名空间，开启<code>init</code>进程</li></ul><p><img src="/images/K8s/pause-container.png" alt="pause容器"></p><p><br></p><p>使用<code>pause</code>容器和共享命名空间创建pod示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#启动pause，以便可以将容器添加到pod中</span><br><span class="line">docker run -d --name pause k8s.gcr.io/pause-amd64:3.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#nginx</span><br><span class="line">cat &lt;&lt;EOF &gt;&gt; /tmp/nginx.conf</span><br><span class="line">&gt; error_log stderr;</span><br><span class="line">&gt; events &#123; worker_connections  1024; &#125;</span><br><span class="line">&gt; http &#123;</span><br><span class="line">&gt;     access_log /dev/stdout combined;</span><br><span class="line">&gt;     server &#123;</span><br><span class="line">&gt;         listen 80 default_server;</span><br><span class="line">&gt;         server_name example.com www.example.com;</span><br><span class="line">&gt;         location / &#123;</span><br><span class="line">&gt;             proxy_pass http://127.0.0.1:2368;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定网络和命名空间</span><br><span class="line"></span><br><span class="line">docker run -d --name nginx -v /tmp/nginx.conf:/etc/nginc/nginx.conf -p 8880:80 --net=container:pause --ipc=container:pause --pid=container:pause docker.io/nginx:lates</span><br><span class="line"></span><br><span class="line">#ghost博客</span><br><span class="line">docker run -d --name ghost --net=container:pause --ipc=container:pause --pid=container:pause docker.io/ghost:latest</span><br></pre></td></tr></table></figure><p>在这两种情况下，我们将<code>pasue</code>容器指定为我们要加入的<strong>命名空间</strong>容器。这将有效地创建我们的pod。</p><p>访问<localhost:8880>可以看到<code>ghost</code>通过<code>nginx</code>代理运行。因为网络命名空间在<code>pause</code>, <code>nginx</code>, <code>ghost</code>容器之间共享。<br>而这两个容器的<code>init</code>进程都是<code>pause</code>这个容器。</localhost:8880></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f nginx</span><br><span class="line"></span><br><span class="line">192.168.31.28 - - [08/Aug/2018:02:00:49 +0000] &quot;GET / HTTP/1.1&quot; 200 3195 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot;</span><br><span class="line">192.168.31.28 - - [08/Aug/2018:02:00:49 +0000] &quot;GET /assets/built/screen.css?v=0bf822a279 HTTP/1.1&quot; 200 7360 &quot;http://node:8880/&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36&quot;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker logs -f ghost</span><br><span class="line"></span><br><span class="line">[2018-08-08 02:00:30] INFO Creating table: posts</span><br><span class="line">[2018-08-08 02:00:30] INFO Creating table: users</span><br><span class="line">[2018-08-08 02:00:30] INFO Creating table: posts_authors</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看init</span><br><span class="line">docker exec -it ghost /bin/bash</span><br><span class="line"></span><br><span class="line">root@f12a374141a7:/var/lib/ghost# ps  -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 01:55 ?        00:00:00 /pause</span><br><span class="line">root         5     0  0 01:58 ?        00:00:00 nginx: master process nginx -g daemon off;</span><br><span class="line">systemd+     9     5  0 01:58 ?        00:00:00 nginx: worker process</span><br><span class="line">node        10     0  0 02:00 ?        00:00:03 node current/index.js</span><br><span class="line">root       127     0  0 02:37 ?        00:00:00 /bin/bash</span><br><span class="line">root       131   127  0 02:37 ?        00:00:00 ps -ef</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="构建大型集群"><a href="#构建大型集群" class="headerlink" title="构建大型集群"></a>构建大型集群</h2><p>Building Large Clusters</p><p>在k8s v1.11，k8s支持做多5 000个节点的集群。更具体地说，支持满足以下条件的配置：</p><ul><li>不超过5 000个node</li><li>总量不超过150 000个pod</li><li>总量不超过300 000个container</li><li>每个节点不超过100个pod</li></ul><p><br><br><br></p><h2 id="使用salt配置k8s"><a href="#使用salt配置k8s" class="headerlink" title="使用salt配置k8s"></a>使用salt配置k8s</h2><p>Configuring Kubernetes with Salt</p><p>k8s集群能够使用salt进行配置。</p><p><br><br><br></p><h2 id="验证节点配置"><a href="#验证节点配置" class="headerlink" title="验证节点配置"></a>验证节点配置</h2><p>Validate Node Setup</p><p><br></p><p><strong>节点一致性测试</strong><br>Node Conformance Test</p><p>节点一致性测试是一种容器化测试框架，为节点提供系统验证和功能测试。<br>该测试验证节点是够满足k8s的最低要求，通过测试的节点有资格加入k8s集群。</p><p><br></p><p><strong>局限</strong><br>Limitations</p><p>在k8s v1.5中，节点一致性测试具有如下限制：</p><ul><li>节点一致性测试仅支持Docker作为容器runtime</li></ul><p><br></p><p><strong>节点先决条件</strong><br>Node Prerequisite</p><p>要运行节点一致性测试，节点必须满足与标准k8s节点相同的先决条件。该节点至少要安装一下守护进程:</p><ul><li>Container Runtime(Docker)</li><li>Kubelet</li></ul><p><br></p><p><strong>运行节点一致性测试</strong><br>Running Node Conformance Test</p><p>执行如下步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 将kubelet执行localhost，测试框架启动一个master来测试kubelet</span><br><span class="line">#可使用 --pod-cidr, --cloud-provide标志</span><br><span class="line">--api-servers=&quot;http://localhost:8080&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 运行节点一致性测试</span><br><span class="line"># $CONFIG_DIR is the pod manifest path of your Kubelet.</span><br><span class="line"># $LOG_DIR is the test output path.</span><br><span class="line">sudo docker run -it --rm --privileged --net=host \</span><br><span class="line">  -v /:/rootfs -v $CONFIG_DIR:$CONFIG_DIR -v $LOG_DIR:/var/result \</span><br><span class="line">  k8s.gcr.io/node-test:0.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#一致性测试的架构支持</span><br><span class="line">node-test-adm64</span><br><span class="line">node-test-arm</span><br><span class="line">node-test-arm64</span><br></pre></td></tr></table></figure><p><br></p><p><strong>运行选定测试</strong><br>Running Selected Test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#运行指定测试，使用你想要运行的测试的正则表达式 覆盖环境变量FOCUS</span><br><span class="line">sudo docker run -it --rm --privileged --net=host \</span><br><span class="line">  -v /:/rootfs:ro -v $CONFIG_DIR:$CONFIG_DIR -v $LOG_DIR:/var/result \</span><br><span class="line">  -e FOCUS=MirrorPod \ # Only run MirrorPod test</span><br><span class="line">  k8s.gcr.io/node-test:0.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#跳过指定测试，覆盖环境变量SKIP</span><br><span class="line">sudo docker run -it --rm --privileged --net=host \</span><br><span class="line">  -v /:/rootfs:ro -v $CONFIG_DIR:$CONFIG_DIR -v $LOG_DIR:/var/result \</span><br><span class="line">  -e SKIP=MirrorPod \ # Run all conformance tests but skip MirrorPod test</span><br><span class="line">  k8s.gcr.io/node-test:0.2</span><br></pre></td></tr></table></figure><p>强烈建议仅运行一致性测试，因为它需要更复杂的配置来运行不一致性测试。</p><p><br><br><br></p><hr><p><br></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>concepts</p><p>概念部分可帮助你了解k8s系统的各个部分以及k8s用于表示集群的抽象，并帮助你更深入地了解k8s的工作原理。</p><p><br></p><h2 id="标准词汇"><a href="#标准词汇" class="headerlink" title="标准词汇"></a>标准词汇</h2><p>Standardized Glossary</p><p><br></p><ul><li><p><strong>Annotation</strong><br>用于将任意非标识元数据(metadata)附加到随想的键值对。</p></li><li><p><strong>Application Architect</strong><br>负责程序高级设计的人员。</p></li><li><p><strong>Application Developer</strong><br>编写在Kubernetes集群中运行的应用程序的人。</p></li><li><p><strong>Approver</strong><br>可以审批Kubernetes代码贡献的人。</p></li><li><p><strong>CLA(Contributor License Agreement)</strong><br>贡献者向开源项目授予其贡献许可的条款。</p></li><li><p><strong>Certificate</strong><br>一个加密安全文件，用于验证对Kubernetes集群的访问的加密。</p></li><li><p><strong>Cloud Controller Manager</strong></p></li><li><p><strong>Cloud Provider</strong></p></li><li><p><strong>Cluster</strong><br>一组称为节点(node)的机器，运行着由Kubernetes管理的容器化的应用程序。</p></li><li><p><strong>Cluster Architect</strong><br>设计一个或多个Kubernetes集群的基础架构的人。</p></li><li><p><strong>Cluster Operator</strong><br>配置，控制和监控集群的人。</p></li><li><p><strong>Code Contributor</strong><br>为Kubernetes开源代码库开发和共享代码的人。</p></li><li><p><strong>ConfigMap</strong><br>一个API对象，用于在键值对中存储非机密的数据。可认为是环境变量，命令行参数…</p></li><li><p><strong>Container</strong><br>一个轻量化和可移植的包含应用程序及其依赖项的可执行的镜像。</p></li><li><p><strong>Container Environment Variables</strong><br>容器环境变量是<code>name/value</code>对，为Pod中运行的容器提供有用的信息。</p></li><li><p><strong>Contributor</strong><br>捐赠代码，文档或时间来帮助Kubernetes项目或社区的人。</p></li><li><p><strong>Controller</strong><br>一个控制循环，通过APIServer监视集群的共享状态，并进行修改，尝试将当前状态移至理想(desired)状态。</p></li><li><p><strong>CronJob</strong><br>管理一个定期运行的工作。</p></li><li><p><strong>CustomResourceDefinition</strong><br>自定义码，用于定义要添加到Kubernetes APIServer的资源，而无需构建完整的自定义服务器。</p></li><li><p><strong>DaemonSet</strong><br>确保Pod的副本在集群的一组节点上运行。</p></li><li><p><strong>Deployment</strong><br>一个管理副本应用程序的API对象</p></li><li><p><strong>Dynamic Volume Provision</strong><br>允许用户请求自动创建存储卷。</p></li><li><p><strong>etcd</strong><br>一致且高度可用的键值存储，用作Kubernetes所有集群数据的备份存储。</p></li><li><p><strong>Helm Chart</strong><br>可以使用Helm工具管理的预配置Kubernetes资源包。</p></li><li><p><strong>Horizontal Pod Autoscaler</strong><br>一个API资源，可根据目标CPU利用率或自定义的指标自动调整Pod副本数。</p></li><li><p><strong>Image</strong><br>一个容器的存储实例，其中包含运行一个应用程序需要的一组软件。</p></li><li><p><strong>Ingress</strong><br>一个管理集群中服务的外部访问的API对象，通常是HTTP。</p></li><li><p><strong>Init Container</strong><br>一个或多个初始化容器，必须在任意应用程序容器运行之前完成运行。</p></li><li><p><strong>Istio</strong><br>一个开放平台，提供统一的方式来继承微服务，管理流量，实施策略和聚合遥测数据。</p></li><li><p><strong>Job</strong><br>运行完成的 有限/一批 任务。</p></li><li><p><strong>Kops</strong><br>一个命令行工具，可帮助你创建，销毁，升级和维护生产级、高可用性的Kubernetes集群。(仅支持AWS)</p></li><li><p><strong>Kubeadm</strong><br>一个快速安装Kubernetes和设置安全集群的工具。</p></li><li><p><strong>Kubectl</strong><br>用于与Kubernetes APIServer通信的命令行工具。</p></li><li><p><strong>Kubelet</strong><br>在集群的每个节点上运行的Agent。它确保容器运行在Pod中。</p></li><li><p><strong>Kubernetes API</strong><br>通过RESTful接口提供Kubernetes功能的应用程序，用于存储集群的状态。</p></li><li><p><strong>Label</strong><br>标记与用户有意义且相关的标识属性的对象。</p></li><li><p><strong>Minikube</strong><br>一个在本地运行Kubernetes的工具。</p></li><li><p><strong>Name</strong><br>客户端提供的字符串，用于引用资源URL中的对象。如<code>/api/vi/pods/some-name</code>.</p></li><li><p><strong>Namespace</strong><br>一个抽象概念，用于Kubernetes支持同一物理集群上的多个虚拟集群。</p></li><li><p><strong>Network Policy</strong><br>允许Pod组如何与其它网络端点进行通信的规范。</p></li><li><p><strong>Node</strong><br>节点是Kubernetes中的一个工作机器。</p></li><li><p><strong>Persistent Volume</strong><br>一个表示集群中一块存储的API对象。</p></li><li><p><strong>Persistent Volume Claim</strong><br>声明定义在一个PersistentVolume中的存储资源，以便可以作为一个volume挂载到容器中。</p></li><li><p><strong>Pod</strong><br>最小和最简单的Kubernetes对象。Pod表示集群上一组正在运行的容器。</p></li><li><p><strong>Pod Security Policy</strong><br>启用Pod创建和更新的细粒度授权。</p></li><li><p><strong>PodPreset</strong><br>一个API对象，在创建时将信息(secrets, volume, env var…)注入到Pod中。</p></li><li><p><strong>RBAC（role-basesd access control)</strong><br>管理授权决策，允许管理员通过Kubernetes API动态配置访问策略。</p></li><li><p><strong>ReplicaSet</strong><br>副本集是下一代副本控制器。</p></li><li><p><strong>Resource Quotas</strong><br>提供限制每个命名空间的聚合资源消耗的约束。</p></li><li><p><strong>Reviemer</strong><br>在项目的某些部分检查代码质量和正确性的人。</p></li><li><p><strong>Secret</strong><br>存储敏感信息，如密码，token…</p></li><li><p><strong>Security Context</strong><br><code>securityContext</code>字段定义Pod或容器的权限和访问控制设置，包括运行时UID和GID。</p></li><li><p><strong>Selector</strong><br>允许用户根据label过滤资源列表。</p></li><li><p><strong>Service</strong><br>一个API对象，描述如何访问应用程序，并可以描述端口和负载均衡器。</p></li><li><p><strong>Service Account</strong><br>为运行在Pod中的进程提供一个标识。</p></li><li><p><strong>Service Catalog</strong><br>一个扩展API，允许Kubernetes集群中运行的应用程序能够轻松使用外部托管软件，如数据库存储服务。</p></li><li><p><strong>StatefulSet</strong><br>管理一组Pods的部署和伸缩，并提供有关这些Pod的排序和唯一性的保证。</p></li><li><p><strong>UID</strong><br>Kubernetes系统生成的一个字符串，用于唯一标识对象。</p></li><li><p><strong>Volume</strong><br>一个包含数据的目录，可供Pod中的容器访问。</p></li><li><p><strong>Volume Plugin</strong><br>卷插件可在Pod中集成存储。</p></li><li><p><strong>kube-apiserver</strong><br>一个Master组件，用于暴露Kubernetes API。它是Kubernetes控制面的前端。</p></li><li><p><strong>kube-controller-manager</strong><br>一个Master组件，用于运行控制器。</p></li><li><p><strong>kube-proxy</strong><br>运行在集群中的每一个节点上的网络代理。</p></li><li><p><strong>kube-scheduler</strong><br>Master上的组件，用于监测未创建节点新创建的Pod，并选择一个节点供其运行。</p></li></ul><p><br><br><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="K8s是什么"><a href="#K8s是什么" class="headerlink" title="K8s是什么"></a>K8s是什么</h3><p>Kubernetes（常简称为K8s），Kubernetes的名字来自希腊语，意思是“舵手”或“领航员”。K8s是将8个字母“ubernete”替换为“8”的缩写。<br>它用于自动部署、扩展和管理容器化（containerized）应用程序的开源系统。它旨在提供“跨主机集群的自动部署、扩展以及运行应用程序容器的平台”。它支持一系列容器工具, 包括Docker等。</p><p>通过Kubernetes你可以：</p><ul><li>快速部署应用</li><li>快速扩展应用</li><li>无缝对接新的应用功能</li><li>优化硬件资源，降低成本</li></ul><p>Kubernetes特点：</p><ul><li>可移植(portable)</li><li>可扩展( extensible)</li><li>自动化(automatic)</li></ul><p>容器优点：</p><ul><li>快速创建/部署应用</li><li>持续开发、集成和部署(CI/CD)</li><li>开发和运维相分离</li><li>开发、测试、生产环境的一致性</li><li>可移植性</li><li>松耦合、分布式、弹性伸缩、微服务化</li><li>资源隔离</li><li>资源利用</li></ul><p><br></p><p><strong>Kubernetes能做什么</strong><br>Kubernetes还允许开发人员从物理和虚拟机脱离，从以主机为中心的基础架构转移到以容器为中心的基础架构。这样可以使用容器固有的全部优点。</p><p>Kubernetes满足的应用程序常见需求：</p><ul><li>Pod</li><li>挂载外部存储</li><li>分布式secrets</li><li>应用健康检查</li><li>副本应用实例</li><li>横向自动伸缩</li><li>服务发现</li><li>负载均衡</li><li>滚动更新</li><li>资源监控</li><li>日志采集和存储</li><li>自检和调试</li><li>认证和授权</li></ul><p>这提供了<strong>平台即服务(PAAS)</strong>的简单性以及<strong>基础架构即服务(IAAS)</strong>的灵活性，并促进基础设施供应商的可移植性。</p><p><br></p><p><strong>Kubernetes不是什么</strong><br>Kubernetes 不是一个传统意义上，包罗万象的PaaS(平台即服务)系统。</p><ul><li>不限制支持的应用程序类型，不限制应用程序框架</li><li>不提供中间件(如消息中间件)、数据处理框架(如spark)，数据库或集群存储系统</li><li>不提供点击即部署的服务市场</li><li>不部署代码不构建应用</li><li>允许用户选择日志、监控和报警</li><li>不提供或授权一个全面的应用程序配置系统/语言</li><li>不提供任何机器配置、维护、管理或自我修复系统</li></ul><p>你可以自定义你的PAAS，与你选择的CI系统集成，或与Kubernetes一起使用，将你的容器镜像部署到Kubernetes。<br>由于Kubernetes在应用级别而不仅仅在硬件级别上运行，因此它提供了PAAS产品通用的一些功能。如部署、扩展、负载均衡、日志记录、监控等。</p><p><br><br><br></p><h3 id="k8s组件"><a href="#k8s组件" class="headerlink" title="k8s组件"></a>k8s组件</h3><p>Kubernetes Components</p><p>Kubernetes 所需的各种二进制组件, 用于提供齐全的功能。</p><p><br></p><h4 id="Master组件"><a href="#Master组件" class="headerlink" title="Master组件"></a>Master组件</h4><p>Master组件提供的集群控制面(control plane)。Master作出集群的全局决策，以及检测和相应集群事件。<br>Master组件可在集群中任何节点上运行。然而，为了简单，通常在一台机器上启动所有Master组件，并且不会在此机器上运行用户容器。<br>可使用多个机器的设置来构建<strong>高可用性能集群</strong>。</p><p><br></p><p><strong>kube-apiserver</strong><br><code>kube-apiserver</code>对外展示Kubernetes API。它是Kubernetes前端控制层，任何的资源请求/调用都是通过它提供的接口进行。<br>它被设计为水平扩展，即通过部署更多实例来扩展。</p><p><br></p><p><strong>etcd</strong><br>持久化和高可用的K/V存储，用于Kubernetes所有集群数据的后端存储。<br>请始终为k8s集群的etcd数据做备份。</p><p><br></p><p><strong>kube-controller-manager</strong><br>Master上运行的控制器组件，它们是集群中处理常规任务的后台线程。<br>逻辑上讲，每个控制器都是一个单独的进程，但为了降低复杂性，它们都被编译为单个二进制文件并在单个进程中运行。</p><p>这些控制器包含：</p><ul><li>节点控制器(Node Controller): 负责在节点故障时通知和响应</li><li>副本控制器(Replication Controller): 负责维护系统中每个副本控制器对象正确的pod数</li><li>端点控制器(Endpoints Controller): 填入端点对象</li><li>服务账户(service accoute)和令牌控制器(token controller): 为新的命名空间(namespace)创建默认账户和API访问令牌</li></ul><p><br></p><p><strong>cloud-controller-manager</strong><br>云控制器管理器用于与底层云提供商进行交互。它仅运行云提供商特定的控制器循环。你必须在<code>kube-controller-manager</code>中禁用这些controller loops，将<code>--cloud-provider</code>标志设置为<code>external</code>来禁用。</p><p>以下控制器具有云提供商依赖关系：</p><ul><li>节点控制器: 用于检查云服务商提供的程序</li><li>路由控制器: 用于在底层云基础架构中设置路由</li><li>服务控制器: 用于创建，更新，删除云服务商提供的负载均衡器</li><li>数据卷控制器: 用于创建，附件和挂载卷，以及与云服务商提供的卷进行交互</li></ul><p><br></p><p><strong>kube-scheduler</strong><br>监视还未分配节点的新创建的pod，选择一个节点供pod运行。<br>调度决策所考虑的因素包括： 个体/集体的资源需求，硬件/软件/策略的约束，亲和力/反亲和性的规范，工作负载和期限。</p><p><br><br><br></p><h4 id="Node组件"><a href="#Node组件" class="headerlink" title="Node组件"></a>Node组件</h4><p>节点(node)组件运行在每个节点，维护运行的pod并提供Kubernetes运行时环境。</p><p><br></p><p><strong>kubelet</strong><br>在集群中每个节点上运行的Agent，它确保container运行在pod中。<br>kubelet采用通过各种机制提供的一组PodSpecs，并确保这些PodSpecs中描述的容器运行且健康。kubelet不管理不是由k8s创建的容器。</p><p>提供如下功能：</p><ul><li>挂载pod所需的数据卷</li><li>下载pod的secrets</li><li>pod中运行docker容器</li><li>周期性的容器健康检查</li><li>如有需要，通过创建<code>mirror pod</code>将pod的状态报告回系统的其余部分</li><li>将节点的状态报告回系统的其余部分</li></ul><p><br></p><p><strong>kube-proxy</strong><br>通过维护主机上的网络规则并执行连接转发，来实现Kubernetes服务抽象。</p><p><br></p><p><strong>container runtime</strong><br>负责运行容器的软件。k8s支持多种runtimes： docker, rkt, runc…</p><p><br></p><p><strong>docker, rkt, supervisord, fluentd…</strong></p><p><br><br><br></p><h4 id="Addons"><a href="#Addons" class="headerlink" title="Addons"></a>Addons</h4><p>扩展是实现集群功能的Pod和Service。pod可由Deployment， Replication等管理。命名空间扩展对象在<code>kube-system</code>命名空间中创建。</p><p><br></p><p><strong>DNS</strong><br>虽然其它插件并非严格要求，但所有k8s集群都应具有集群DNS，因为许多示例都依赖于它。<br>集群DNS是一个DNS服务器，除了你环境中的DNS服务器，它还为k8s服务提供DNS记录。<br>由k8s启动的容器会在DNS搜索中自动包含此DNS服务器。</p><p><br></p><p><strong>Web UI(dashboard)</strong><br>仪表盘。</p><p><br></p><p><strong>container resource monitoring</strong><br>记录有关中央数据库中容器的通用时间序列度量标准，并提供用于浏览该数据的UI。</p><p><br></p><p><strong>cluster-level logging</strong><br>集群级别的日志记录机制，复制将容器日志保存到具有<code>search/browse</code>界面的中央日志存储。</p><p><br><br><br></p><h3 id="k8s-API"><a href="#k8s-API" class="headerlink" title="k8s API"></a>k8s API</h3><p>k8s API还可作为系统声明性配置架构的基础。<code>kubectl</code>命令行工具可用于创建，更新，删除和获取API对象。<br>k8s还根据API资源存储其序列化状态(etcd中)。k8s自身被分解为多个组件，这些组件通过其API进行交互。</p><p><br></p><p><strong>OpenAPI和Swagger定义</strong><br>完整的API详细信息记录在<code>Swagger v1.2</code>和<code>OpenAPI</code>。k8s apiserver(master)公开了一个API，可用于检索位于<code>/swaggerapi</code>的<code>Swagger v1.2 k8s API</code>.<br>从k8s 1.10开始，OpenAPI规范在单个<code>/openapi/v2</code>端点中提供。单独格式的端点(如<code>swagger.json...</code>)已被弃用，后面会被移除。</p><p>通过设置HTTP header指定请求格式:</p><table><thead><tr><th>Header</th><th>Possible Values</th></tr></thead><tbody><tr><td>Accept</td><td>application/json, application/com.github.proto-openapi.spec.v2@v1.0+protobuf (the default content-type is application/json for <em>/</em> or not passing this header)</td></tr><tr><td>Accept-Encoding</td><td>gzip (not passing this header is acceptable)</td></tr></tbody></table><p>栗子：</p><table><thead><tr><th>Before 1.10</th><th>Starting with Kubernetes 1.10</th></tr></thead><tbody><tr><td>GET /swagger.json</td><td>GET /openapi/v2 Accept: application/json</td></tr><tr><td>GET /swagger-2.0.0.pb-v1</td><td>GET /openapi/v2 Accept: application/com.github.proto-openapi.spec.v2@v1.0+protobuf</td></tr><tr><td>GET /swagger-2.0.0.pb-v1.gz</td><td>GET /openapi/v2 Accept: application/com.github.proto-openapi.spec.v2@v1.0+protobuf Accept-Encoding: gzip</td></tr></tbody></table><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#查看</span><br><span class="line">curl localhost:8080</span><br><span class="line">&#123;</span><br><span class="line">  &quot;paths&quot;: [</span><br><span class="line">    &quot;/api&quot;,</span><br><span class="line">    &quot;/api/v1&quot;,</span><br><span class="line">    &quot;/apis&quot;,</span><br><span class="line">    &quot;/apis/apps&quot;,</span><br><span class="line">    &quot;/apis/apps/v1beta1&quot;,</span><br><span class="line">    &quot;/apis/authentication.k8s.io&quot;,</span><br><span class="line">    &quot;/apis/authentication.k8s.io/v1beta1&quot;,</span><br><span class="line">    &quot;/apis/authorization.k8s.io&quot;,</span><br><span class="line">    &quot;/apis/authorization.k8s.io/v1beta1&quot;,</span><br><span class="line">    &quot;/apis/autoscaling&quot;,</span><br><span class="line">    &quot;/apis/autoscaling/v1&quot;,</span><br><span class="line">    &quot;/apis/batch&quot;,</span><br><span class="line">    &quot;/apis/batch/v1&quot;,</span><br><span class="line">    &quot;/apis/batch/v2alpha1&quot;,</span><br><span class="line">    &quot;/apis/certificates.k8s.io&quot;,</span><br><span class="line">    &quot;/apis/certificates.k8s.io/v1alpha1&quot;,</span><br><span class="line">    &quot;/apis/extensions&quot;,</span><br><span class="line">    &quot;/apis/extensions/v1beta1&quot;,</span><br><span class="line">    &quot;/apis/policy&quot;,</span><br><span class="line">    &quot;/apis/policy/v1beta1&quot;,</span><br><span class="line">    &quot;/apis/rbac.authorization.k8s.io&quot;,</span><br><span class="line">    &quot;/apis/rbac.authorization.k8s.io/v1alpha1&quot;,</span><br><span class="line">    &quot;/apis/storage.k8s.io&quot;,</span><br><span class="line">    &quot;/apis/storage.k8s.io/v1beta1&quot;,</span><br><span class="line">    &quot;/healthz&quot;,</span><br><span class="line">    &quot;/healthz/ping&quot;,</span><br><span class="line">    &quot;/healthz/poststarthook/bootstrap-controller&quot;,</span><br><span class="line">    &quot;/healthz/poststarthook/extensions/third-party-resources&quot;,</span><br><span class="line">    &quot;/healthz/poststarthook/rbac/bootstrap-roles&quot;,</span><br><span class="line">    &quot;/logs&quot;,</span><br><span class="line">    &quot;/metrics&quot;,</span><br><span class="line">    &quot;/swaggerapi/&quot;,</span><br><span class="line">    &quot;/ui/&quot;,</span><br><span class="line">    &quot;/version&quot;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p><br></p><p><strong>API 版本</strong><br>为了更容易消除字段或重构资源表示，k8s支持多个API版本，每个版本位于不同的API路径。如<code>/api/vi</code>或<code>/apis/extensions/v1beta1</code>.</p><p>我们选择在API级别，而不是资源级别/字段级别进行版本控制，以确保API提供干净、一致的系统资源和行为视图，并允许控制对生命末端和实验性API的访问。json和protobuf序列化模式都遵循相同的模式更改指南。请注意，API版本和软件版本仅间接相关。</p><p>不同的API版本意味着不同级别的稳定性和支持：</p><ul><li>Alpha level<ul><li>版本名包含alpha(如 v1aplha1)</li><li>启用该功能可能会暴露bug，默认禁用</li><li>可随时删除对功能的支持，恕不另行通知</li><li>可能会在以后软件版本中以不兼容的方式更改，恕不另行通知</li><li>由于错误风险和缺乏长期支持，建议仅在短期测试集群中使用</li></ul></li><li>Beta level<ul><li>版本名包含beta(如 v2beta3)</li><li>代码经过充分测试，启用该功能被认为是安全的。默认启用</li><li>虽然细节会有所变化，但不会删除对整体功能的支持</li><li>建议仅用于非关键业务，因为后续版本可能会发生不兼容的更改</li><li>请尝试我们测试版功能并提供反馈</li></ul></li><li>Stable level<ul><li>版本名是vx，x为整数</li><li>许多后续版本的软件将出现稳定版的功能</li></ul></li></ul><p><br></p><p><strong>API groups</strong><br>为了更容易扩展k8s API，我们实施了<code>API Groups</code>，它在REST path和序列化对象的apiVersion字段中指定。</p><p>目前在使用的几个API groups:</p><ul><li>核心组(core group)，又称遗留组，位于REST path的<code>/api/v1</code>，并使用<code>apiVersion: v1</code></li><li>命名组(named group)，位于REST path的<code>/apis/$GROUP_NAME/$VERSION</code>，并使用<code>apiVersion: $GROUP_NAME/$VERSION</code></li></ul><p>两种受支持的自定义资源扩展API的路径：</p><ul><li>自定义资源(CustomResourceDefiniton) 适用于具有非常基本CRUD需求的用户</li><li>需要完整k8s API语义的用户可以实现自己的apiserver，并使用聚合器使其无缝连接到客户端</li></ul><p><br></p><p><strong>启用 API groups</strong><br>默认情况下启用某些资源和API groups。通过在apiserver设置<code>--runtime-config</code>可启用/禁用它。此配置接收逗号分隔的KV，描述了apiserver运行时配置。</p><p><br></p><p><strong>在API groups中启用资源</strong><br>默认情况下启动 DeamonSets, Deployments, HorizontalPodAutoscalers, Ingress, Jobs, ReplicaSets。其它扩展资源可通过在apiserver上设置<code>--runtime-config</code>启用或禁用。</p><p><br><br><br></p><h3 id="k8s-对象"><a href="#k8s-对象" class="headerlink" title="k8s 对象"></a>k8s 对象</h3><p>本节解释了如何在k8s API中表示k8s对象，以及如何以<code>.yaml</code>格式表示它们。</p><p><br></p><h4 id="理解k8s对象"><a href="#理解k8s对象" class="headerlink" title="理解k8s对象"></a>理解k8s对象</h4><p>在k8s系统中，k8s对象是持久化的实体。k8s使用这些实体来表示整个集群的状态。特别地，它们描述了如下信息：</p><ul><li>哪些容器化应用程序正在运行(以及运行在哪个节点上)</li><li>可以被这些应用程序使用的资源</li><li>应用程序行为方式的策略(重启、升级、容错)</li></ul><p>k8s 对象是一个<strong>意图记录(record of intent)</strong> —— 一旦创建了对象，k8s系统将持续工作以确保对象存在。通过创建一个对象，你可以有效地告诉k8s系统你希望集群的工作负载看起来像什么，这是你的集群的<strong>期望状态(desired state)</strong>。<br>要使用k8s对象(创建, 修改, 删除)，需要使用k8s API。当你使用<code>kubectl</code>命令行接口时，CLI会为你进行必要的k8s API调用。</p><p><br></p><p><strong>对象规约与状态</strong><br>Object Spec and Status</p><p>每个k8s 对象都包含了两个嵌套的对象字段，用于控制对象的配置：<strong>对象规约</strong>和<strong>对象状态</strong>。<br>在任何时刻，k8s controller plane都会主动管理对象的实际状态，以匹配你提供的期望状态。</p><ul><li>规约(spec)，必须提供。描述了对象的期望状态(diresed state)——你希望对象具有的特征。</li><li>状态(status)，描述对象的实际状态，由k8s系统提供和更新。</li></ul><p>例如，k8s Deployment是一个可以表示你集群上运行的应用程序的对象。当你创建一个Deployment，你可以设置部署规约以指定你希望应用程序运行三个副本。k8s系统读取部署规约并启动应用程序所需的三个实例——更新状态以符合你的规范。如果这些事例中的任何一个失败(状态改变)，k8s系统通过进行校正来响应规约和状态之间的差异。在这种情况下，启动替换实例。</p><p><br></p><p><strong>描述k8s 对象</strong><br>在k8s中创建对象时，必须提供描述其期望状态的对象规约，以及有关对象的一些基本信息(如 名称)。当你使用k8s API来创建对象时，API请求必须在请求正文中将信息作为JSON格式。通常，你在<code>.yaml</code>文件中向<code>kubectl</code>提供信息，<code>kubectl</code>在发出API请求时将信息转换为JSON格式。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># for versions before 1.9.0 use apps/v1beta2</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.7.9</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure><p>使用类似上面的<code>.yaml</code>文件创建部署的方法，是在<code>kubectl</code>命令行工具中使用<code>kubectl create</code>命令，将<code>.yaml</code>文件作为参数传递。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f https://k8s.io/examples/application/deployment.yaml --record</span><br><span class="line">#deployment &quot;nginx-deployment&quot; created</span><br></pre></td></tr></table></figure><p><br></p><p><strong>必填字段</strong><br>在要创建k8s 对象的<code>.yaml</code>文件中，必须配置一下字段：</p><ul><li><code>apiVersion</code>： 创建对象的k8s API版本</li><li><code>kind</code>： 创建的对象类型</li><li><code>metadata</code>： 有助于识别对象唯一性的数据，包括name, uid, namespace…</li></ul><p>你还需要提供<code>spec</code>字段。对于每个k8s对象，对象规约的精确格式是不同的，并且包含特定于该对象的嵌套字段。</p><p><br><br><br></p><h4 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h4><p>Kubernetes REST API中所有对象都用<strong>Name</strong>和<strong>UID</strong>来明确标识。<br>对于用户提供的非唯一的属性，k8s提供<strong>labels</strong>和<strong>annotations</strong>。</p><p><br></p><p><strong>Names</strong><br>客户端提供的字符串，用于引用资源URL中的对象。如<code>/api/v1/pods/some-name</code>.<br>一个给定<code>kind</code>的对象同时只能有一个<code>name</code>。但如果你删除了此对象，便可以为新对象赋予此名字。<br>按照惯例，k8s资源的名称的最大长度应为253个字符，并由<code>小写字母,数字, -, .</code>字符组成。但某些资源可能具有更过限制。</p><p><br></p><p><strong>UIDs</strong><br>k8s 系统生成的字符串，用于唯一标识对象。<br>在k8s集群的整个生命周期中创建的每个对象都具有一个唯一的UID。它旨在区分类似实体的历史事件。</p><p><br><br><br></p><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><p>k8s支持在物理集群中创建多个虚拟集群，这些虚拟机群称为<code>namespaces</code>。命名空间是一种将集群资源划分为多个用途的方法。<br>命名空间名称满足正则表达式，最大长度为63位。</p><p><br></p><p><strong>什么时候使用多个命名空间</strong><br>命名空间旨在用于多个用户分布在多个团队/多个项目的环境中。对于具有几个到几十个用户的集群，你根本不需要创建和考虑命名空间。<br>命名空间提供名称范围。资源名称在命名空间中必须唯一，但不能跨命名空间。<br>命名空间是一种在多个用户之间划分集群资源的方法。<br>在k8s的未来版本中，默认情况下，同一命名空间中的对象将具有相同的访问控制策略(ACP)。<br>没有必要使用多个命名空间仅来分隔略有不同的资源。如同一软件的不同版本，使用<code>labels</code>来区分同一命名空间内的资源。</p><p><br></p><p><strong>操作命名空间</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看</span></span><br><span class="line">kubectl get ns</span><br><span class="line">NAME          STATUS    AGE</span><br><span class="line">default       Active    13d</span><br><span class="line">kube-system   Active    13d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过命令创建</span></span><br><span class="line">kubectl create namespace my-namespace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#或通过文件创建</span></span><br><span class="line">vim my-namespace.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: my-namespace</span><br><span class="line"></span><br><span class="line">kubectl create -f ./my-namespace.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">kubectl get namespace</span><br><span class="line">NAME           STATUS    AGE</span><br><span class="line">default        Active    13d</span><br><span class="line">kube-system    Active    13d</span><br><span class="line">my-namespace   Active    4s</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">kubectl delete namespace my-namespace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置请求的命名空间</span></span><br><span class="line"><span class="comment">#使用--namespace标志临时设置请求的命名空间</span></span><br><span class="line">kubectl kubectl get pods --namespace=default</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置命名空间首选项</span></span><br><span class="line">kubectl config <span class="built_in">set</span>-context $(kubectl config current-context) --namespace=my-namespace</span><br><span class="line">kubectl config view</span><br></pre></td></tr></table></figure><p>Kubernetes有三个初始的命名空间：</p><ul><li><code>default</code>: 没有其它命名空间时，对象的默认命名空间</li><li><code>kube-system</code>: k8s系统创建的对象的命名空间</li><li><code>kube-public</code>: 此命名空间是自动创建的，可供所有用户读取(包括未认证用户)。此命名空间主要用于集群使用，以防止某些资源在整个集群中可见且可公开读取。此命名空间的公共方面只是一个约定，而非要求。</li></ul><p>注意：</p><ul><li>删除一个命名空间会自动删除所有属于该命名空间的资源</li><li>k8s初始化的两个命名空间无法删除</li><li>持久化卷(persistent volume)不属于任何命名空间，但持久化卷声明(persistent volume claim)是属于某个特定命名空间的</li><li>事件(event)是否属于命名空间取决于产生事件的对象</li></ul><p><br></p><p><strong>命名空间和DNS</strong><br>当你创建一个服务(service)，它会创建相应的DNS条目(dns entry)。此条目的格式为<code>&lt;service-name&gt;.&lt;namespace-name&gt;.svc.cluster.local</code>，这表示如果一个容器只是用<code>&lt;service-name&gt;</code>，它将会解析为命名空间本地的服务。这对于在多个命名空间(如 开发/测试/生产)中使用相同的配置非常有用。如果想要扩命名空间访问，则需要使用完全限定的域名(fully qualified domain name)。</p><p><br></p><p><strong>不是所有对象都在命名空间中</strong><br>大多数k8s资源(pods, services, replication controller…)都在某些命名空间中。然而，命名空间资源本身并不在命名空间中。并且，低级资源(node, persistentVolumes)并不在任何命名空间中。</p><p>查看k8s资源是否在命名空间中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl api-resources --namespaced=true</span><br><span class="line">kubectl api-resources --namespaced=false</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Labels和Selectors"><a href="#Labels和Selectors" class="headerlink" title="Labels和Selectors"></a>Labels和Selectors</h4><p>标签是被关联到对象上的<code>key/value</code>对。标签旨在用于指定对用户有意义且相关的对象的标识属性，但不直接按时核心系统的语义。标签可用于组织和选择对象的子集。标签可在创建时附加到对象，随时可以添加和修改。每个对象可拥有多个标签，对于给定的对象，<code>key</code>必须唯一。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">"metadata": &#123;</span><br><span class="line">  "labels": &#123;</span><br><span class="line">    "key1" : "value1",</span><br><span class="line">    "key2" : "value2",</span><br><span class="line">    "keyN" : "valueN"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子</span><br><span class="line">"labels": &#123;</span><br><span class="line">  "release" : "stable",</span><br><span class="line">  "environment" : "dev",</span><br><span class="line">  "track" : "daily"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们最终将<strong>索引(index)</strong>和<strong>反向索引(reverse-index)</strong>标签，用于高效查询和监视，使用它们在UI和CLI中进行排序和分组。我们不希望对非标识(non-identifying)信息使用标签，特别是大型结构化数据。非标识信息应该记录到<code>annorations</code>。</p><p>标签使用户能够以松散耦合的方式将自己的组织结构映射到系统对象中，而无需客户端存储这些映射。</p><p><br></p><p><strong>语法和字符集</strong><br>有效的label key有两个字段: 可选前缀和名称，用斜杆分隔。<br>名字字段是必须的，小于等于63个字符，以字母数字开头和结尾，还可使用<code>-, _, .</code>三个字符。<br>前缀可选。如果指定，前缀必须是DNS子域，不超过253个字符，后跟斜杆<code>/</code>。如果省略，则假定label key对用户是私有的。向最终用户对象添加标签的自动系统组件(kube-scheduler, kube-apserver…)必须制定前缀。<code>kuberneter.io/</code>前缀保留个k8s核心组件。</p><p>有效的label value必须小于等于63个字符，可为空，或以字母数字开头和结尾，还可使用<code>-, _, .</code>三个字符。</p><p><br></p><p><strong>label selectors</strong><br>标签不提供唯一性。通常，我们希望许多对象携带相同的标签。<br>通过<code>label selector</code>，客户端/用户 可以识别一组对象。标签选择器是k8s中的核心分组原语。</p><p>API目前支持两种类型的选择器: <code>equality-based</code>和<code>set-based</code>。标签选择器可由逗号<code>,</code>分隔的多个要求组成。<br>一个空(empty)标签选择器(zero requirements)，选择集合中的每个对象。<br>一个空(null)标签选择器(仅可用于选择器字段)不选择任何对象。</p><p><strong>equality-based requirement</strong><br>基于平等/不平等的要求允许按标签键和值进行过滤。匹配对象必须满足所有指定的标签约束，尽管它们也可能具有其它标签。<br>允许三种运算符:<code>=, ==, !=</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">environment = production</span><br><span class="line">tier != frontend</span><br></pre></td></tr></table></figure><p><strong>set-based requirement</strong><br>基于集合的标签的要求允许根据一组值过滤键。<br>支持三种操作符: <code>in, notin, exists</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">environment in (production, qa)</span><br><span class="line">tier notin (frontend, backend)</span><br><span class="line">partition</span><br><span class="line">!partition</span><br></pre></td></tr></table></figure><p><br></p><p><strong>API</strong></p><p>LIST and WATCH filtering<br><code>LIST</code>和<code>WATCH</code>操作可以指定标签选择器来过滤使用查询参数返回的对象集。两个要求都是允许的。<br>两种标签选择器的样式都可使用通过TEST客户端列出或查看资源。</p><ul><li>equality-based requirements: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li>set-based requirements: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#equality-based</span></span><br><span class="line">kubectl get pods -l environment=production,tier=frontend</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#set-based</span></span><br><span class="line">kubectl get pods -l <span class="string">'environment in (production),tier in (frontend)'</span></span><br><span class="line">kubectl get pods -l <span class="string">'environment in (production, qa)'</span></span><br><span class="line">kubectl get pods -l <span class="string">'environment,environment notin (frontend)'</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>Service and ReplicationController</strong><br>服务所针对的一组pod使用标签选择器进行定义。类似地，副本控制器应该管理的pod数量也使用标签选择器定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#json格式</span><br><span class="line">&quot;selector&quot;: &#123;</span><br><span class="line">  &quot;component&quot;: &quot;redis&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#yaml格式</span><br><span class="line">selector:</span><br><span class="line">  component: redis</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h4><p>你可使用k8s <code>annotation</code>(注释)将任意非标识(non-identifying)元数据附加到对象。工具和库等客户端可以检索此元数据。它也是<code>key/value</code>对。<br>Annotations不会被k8s直接使用，其主要目的是方便用户阅读查找。</p><p><br></p><p><strong>将元数据追加到对象</strong><br>你可使用<code>label</code>或<code>annotations</code>将原数据追加到k8s对象。<br>标签用于选择对象和查找满足特定条件的对象集合。<br>相反，注释不用于识别和选择对象。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"metadata": &#123;</span><br><span class="line">  "annotations": &#123;</span><br><span class="line">    "key1" : "value1",</span><br><span class="line">    "key2" : "value2"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Field-Selectors"><a href="#Field-Selectors" class="headerlink" title="Field Selectors"></a>Field Selectors</h4><p>字段选择器允许你根据一个或多个资源字段的值选择k8s资源。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#三种操作符</span><br><span class="line">=, ==, !=</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">metadata.name=my-service</span><br><span class="line">metadata.namespace!=default</span><br><span class="line">status.phase=Pending</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">kubectl get pods --field-selector status.phase=Running</span><br><span class="line">NAME                           READY     STATUS    RESTARTS   AGE</span><br><span class="line">hello-world-3198537413-138pg   1/1       Running   0          5d</span><br><span class="line">hello-world-3198537413-67g6d   1/1       Running   0          5d</span><br><span class="line">hello-world-3198537413-bf73l   1/1       Running   0          5d</span><br><span class="line">hello-world-3198537413-ddgb3   1/1       Running   0          5d</span><br><span class="line">hello-world-3198537413-ffj90   1/1       Running   0          5d</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">kubectl get  ingress --field-selector foo.bar=baz</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">kubectl get pods --field-selector=status.phase!=Running,spec.restartPolicy=Always</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">kubectl get statefulsets,services --field-selector metadata.namespace!=default</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Recommended-Labels"><a href="#Recommended-Labels" class="headerlink" title="Recommended Labels"></a>Recommended Labels</h4><p>你可以使用比<code>kubectl</code>和<code>dashboard</code>更多的工具来可视化和管理k8s对象。一组通用的标签允许工具以互操作的方式工作，以所有工具都能理解的通用方式描述对象。<br>除了支持工具之外，推荐的标签还以可查询的方式描述应用程序。</p><p><code>shared labels and annotations</code>共享一个通用的前缀: <code>app.kubernetes.io</code>。没有前缀的标签对用户是私有的。共享前缀可确保共享标签不会干扰自定义用户标签。</p><p><br></p><p>为了充分利用这些标签，应将它们应用于每个资源对象。</p><table><thead><tr><th>Key</th><th>Description</th><th>Example</th><th>Type</th></tr></thead><tbody><tr><td>app.kubernetes.io/name</td><td>The name of the application</td><td>mysql</td><td>string</td></tr><tr><td>app.kubernetes.io/instance</td><td>A unique name identifying the instance of an application</td><td>wordpress-abcxzy</td><td>string</td></tr><tr><td>app.kubernetes.io/version</td><td>The current version of the application (e.g., a semantic version, revision hash, etc.)</td><td>5.7.21</td><td>string</td></tr><tr><td>app.kubernetes.io/component</td><td>The component within the architecture</td><td>database</td><td>string</td></tr><tr><td>app.kubernetes.io/part-of</td><td>The name of a higher level application this one is part of</td><td>wordpress</td><td>string</td></tr><tr><td>app.kubernetes.io/managed-by</td><td>The tool being used to manage the operation of an application</td><td>helm</td><td>string</td></tr></tbody></table><p>要说明这些标签的运行情况，请考虑一下<code>StatefulSet</code>对象:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="string">app.kubernetes.io/instance:</span> <span class="string">wordpress-abcxzy</span></span><br><span class="line">    <span class="string">app.kubernetes.io/version:</span> <span class="string">"5.7.21"</span></span><br><span class="line">    <span class="string">app.kubernetes.io/component:</span> <span class="string">database</span></span><br><span class="line">    <span class="string">app.kubernetes.io/part-of:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="string">app.kubernetes.io/managed-by:</span> <span class="string">helm</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用kubectl进行对象管理"><a href="#使用kubectl进行对象管理" class="headerlink" title="使用kubectl进行对象管理"></a>使用kubectl进行对象管理</h3><p><code>kubectl</code>命令行工具支持多种方式来创建和管理k8s对象。<br>应该只使用一种技术来管理k8s对象。对同一个对象的混合和匹配技术会导致未定义的行为。</p><table><thead><tr><th>Management technique</th><th>Operates on</th><th>Recommended environment</th><th>Supported writers</th><th>Learning curve</th></tr></thead><tbody><tr><td>Imperative commands</td><td>Live objects</td><td>Development projects</td><td>1+</td><td>Lowest</td></tr><tr><td>Imperative object configuration</td><td>Individual files</td><td>Production projects</td><td>1</td><td>Moderate</td></tr><tr><td>Declarative object configuration</td><td>Directories of files</td><td>Production projects</td><td>1+</td><td>Highest</td></tr></tbody></table><p><br><br><br></p><h4 id="必要的命令"><a href="#必要的命令" class="headerlink" title="必要的命令"></a>必要的命令</h4><p>Managing Kubernetes Objects Using Imperative Commands</p><p>使用k8s命令行工具内置的必要命令，可直接快速创建、更新、删除k8s对象。</p><p><br></p><p><strong>权衡</strong><br><code>kubectl</code>工具支持三种对象管理：</p><ul><li>Imperative commands(必要的命令)</li><li>Imperative object configuration(必要的对象配置)</li><li>Declarative object configuration(声明的对象配置)</li></ul><p><br><br><br></p><h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><p><code>kubectl</code>工具支持动词驱动的命令，用以创建一些最常见的对象类型。这些命令被命名为即使不熟悉k8s对象类型的用户也能够识别。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个新的Deployment对象，以在一个或多个pod中运行container</span></span><br><span class="line">run</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个新的Service对象，以在pod间对流量进行负载均衡</span></span><br><span class="line">expose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个新的Autoscaler对象，用以自动水平伸缩控制器</span></span><br><span class="line">autoscale</span><br></pre></td></tr></table></figure><p><code>kubectl</code>工具还支持由对象类型驱动的创建命令。这些命令支持更多对象类型，并且更明确地表达了它们的意图，但要求用户知道他们打算创建的对象类型。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create &lt;objecttype&gt; [&lt;subtype&gt;] &lt;instancename&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#栗子</span></span><br><span class="line">kubectl create service nodeport &lt;service-name&gt;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="更新对象"><a href="#更新对象" class="headerlink" title="更新对象"></a>更新对象</h5><p><code>kubectl</code>命令支持动词驱动的命令，用于一些常见的更新操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过更新控制器的副本数，水平伸缩控制器，以添加或删除pod</span></span><br><span class="line">scale</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在对象中添加或删除注释</span></span><br><span class="line">annotate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在对象中添加或删除标签</span></span><br><span class="line">label</span><br></pre></td></tr></table></figure><p><code>kubectl</code>工具还支持由对象的某个驱动的更新命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置对象的一个方面</span></span><br><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure><p><code>kubectl</code>工具支持这些直接地更新实时对象的额外方法，但他们需要更好地裂解k8s对象模式。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过在编辑器中打开其配置，直接编辑实时对象的原始配置文件</span></span><br><span class="line">edit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用补丁字符串，直接修改实时对象的特定字段</span></span><br><span class="line">patch</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从集群中删除对象</span></span><br><span class="line">delete &lt;<span class="built_in">type</span>&gt;/&lt;name&gt;</span><br><span class="line"></span><br><span class="line">kubectl delete deployment/nginx</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="查看对象"><a href="#查看对象" class="headerlink" title="查看对象"></a>查看对象</h5><p>如下这些命令可用于打印除对象信息:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打印有关匹配对象的基本信息</span></span><br><span class="line">get</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#打印有关匹配对象的详细信息</span></span><br><span class="line">describe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#打印运行在pod中容器的stdout和stderr</span></span><br><span class="line">logs</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="创建对象前修改对象"><a href="#创建对象前修改对象" class="headerlink" title="创建对象前修改对象"></a>创建对象前修改对象</h5><p>有些对象字段没有可在<code>create</code>命令汇总使用的标志。在某些情况下，你可使用<code>set</code>和<code>create</code>的组合在对象创建之前为字段指定值。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set命令</span></span><br><span class="line">kubectl create service clusterip my-svc --clusterip=<span class="string">"None"</span> -o yaml --dry-run \</span><br><span class="line">| kubectl <span class="built_in">set</span> selector --<span class="built_in">local</span> -f - <span class="string">'environment=qa'</span> -o yaml \</span><br><span class="line">| kubectl create -f -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#--edit标志</span></span><br><span class="line">kubectl create service clusterip my-svc --clusterip=<span class="string">"None"</span> -o yaml --dry-run &gt; /tmp/srv.yaml</span><br><span class="line">kubectl create --edit -f /tmp/srv.yaml</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>Imperative Management of Kubernetes Objects Using Configuration Files</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#创建对象</span><br><span class="line">kubectl create -f &lt;file | url&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">kubectl replace -f &lt;file | url&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">kubectl delete -f &lt;file | url&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">kubectl get -f &lt;file | url&gt; -o yaml</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用配置文件声明管理的k8s对象"><a href="#使用配置文件声明管理的k8s对象" class="headerlink" title="使用配置文件声明管理的k8s对象"></a>使用配置文件声明管理的k8s对象</h4><p>Declarative Management of Kubernetes Objects Using Configuration Files</p><p>可通过在目录中存储多个对象配置文件来创建、更新、删除k8s对象，并使用<code>kubectl apply</code>根据递归创建和更新这些对象。<br><code>kubectl apply</code>不支持对象配置命令<code>create</code>和<code>replace</code>。</p><p><br></p><p><strong>开始前</strong><br>声明性对象配置需要深入理解k8s对象定义和配置。</p><p><br><br><br></p><h5 id="创建对象-1"><a href="#创建对象-1" class="headerlink" title="创建对象"></a>创建对象</h5><p>使用<code>kubectl apply</code>创建除指定目录中的配置文件定义的已存在的所有对象。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f &lt;directory&gt;/</span><br></pre></td></tr></table></figure><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  minReadySeconds: 5</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.7.9</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建</span><br><span class="line">kubectl apply -f https://k8s.io/examples/application/simple_deployment.yaml</span><br><span class="line">#查看</span><br><span class="line">kubectl get -f https://k8s.io/examples/application/simple_deployment.yaml -o yaml</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="更新对象-1"><a href="#更新对象-1" class="headerlink" title="更新对象"></a>更新对象</h5><p>使用<code>kubectl apply</code>更新目录中定义的所有对象，即使这些对象已经存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f &lt;directory&gt;/</span><br></pre></td></tr></table></figure><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#伸缩</span><br><span class="line">kubectl scale deployment/nginx-deployment --replicas=2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#更新nginx版本，从1.7.9升级到1.11.9</span><br><span class="line">#删除minReadySeconds字段</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.11.9</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#应用更新</span><br><span class="line">kubectl apply -f https://k8s.io/examples/application/update_deployment.yaml</span><br><span class="line">#查看</span><br><span class="line">kubectl get -f https://k8s.io/examples/application/simple_deployment.yaml -o yaml</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="删除对象-1"><a href="#删除对象-1" class="headerlink" title="删除对象"></a>删除对象</h5><p>有两种方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#推荐</span><br><span class="line">kubectl delete -f &lt;filename&gt;</span><br><span class="line"></span><br><span class="line">#选择</span><br><span class="line">kubectl apply -f &lt;directory/&gt; --prune -l &lt;labels&gt;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="查看对象-1"><a href="#查看对象-1" class="headerlink" title="查看对象"></a>查看对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get -f &lt;file | url&gt; -o yaml</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="计算-存储和网络"><a href="#计算-存储和网络" class="headerlink" title="计算,存储和网络"></a>计算,存储和网络</h2><p>Compute, Storage, and Networking Extensions</p><p><br></p><h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><p>Cluster Administration</p><ul><li>规划集群</li><li>管理集群</li><li>保护集群</li><li>集群服务</li></ul><p>详情见配置章节。</p><p><br><br><br></p><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>Certificates</p><p>当使用客户端证书认证时，你可以通过<code>easyras, openssl, cfssl</code>手动生成证书。</p><p><br></p><h4 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Generate a ca.key with 2048bit</span></span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#According to the ca.key generate a ca.crt</span></span><br><span class="line">openssl req -x509 -new -nodes -key ca.key -subj <span class="string">"/CN=<span class="variable">$&#123;MASTER_IP&#125;</span>"</span> -days 10000 -out ca.crt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Generate a server.key with 2048bit</span></span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#reate a config file for generating a Certificate Signing Request (CSR)</span></span><br><span class="line">[ req ]</span><br><span class="line">default_bits = 2048</span><br><span class="line">prompt = no</span><br><span class="line">default_md = sha256</span><br><span class="line">req_extensions = req_ext</span><br><span class="line">distinguished_name = dn</span><br><span class="line"></span><br><span class="line">[ dn ]</span><br><span class="line">C = &lt;country&gt;</span><br><span class="line">ST = &lt;state&gt;</span><br><span class="line">L = &lt;city&gt;</span><br><span class="line">O = &lt;organization&gt;</span><br><span class="line">OU = &lt;organization unit&gt;</span><br><span class="line">CN = &lt;MASTER_IP&gt;</span><br><span class="line"></span><br><span class="line">[ req_ext ]</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[ alt_names ]</span><br><span class="line">DNS.1 = kubernetes</span><br><span class="line">DNS.2 = kubernetes.default</span><br><span class="line">DNS.3 = kubernetes.default.svc</span><br><span class="line">DNS.4 = kubernetes.default.svc.cluster</span><br><span class="line">DNS.5 = kubernetes.default.svc.cluster.local</span><br><span class="line">IP.1 = &lt;MASTER_IP&gt;</span><br><span class="line">IP.2 = &lt;MASTER_CLUSTER_IP&gt;</span><br><span class="line"></span><br><span class="line">[ v3_ext ]</span><br><span class="line">authorityKeyIdentifier=keyid,issuer:always</span><br><span class="line">basicConstraints=CA:FALSE</span><br><span class="line">keyUsage=keyEncipherment,dataEncipherment</span><br><span class="line">extendedKeyUsage=serverAuth,clientAuth</span><br><span class="line">subjectAltName=@alt_names</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Generate the certificate signing request based on the config file</span></span><br><span class="line">openssl req -new -key server.key -out server.csr -config csr.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Generate the server certificate using the ca.key, ca.crt and server.csr</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> server.csr -CA ca.crt -CAkey ca.key \</span><br><span class="line">-CAcreateserial -out server.crt -days 10000 \</span><br><span class="line">-extensions v3_ext -extfile csr.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#View the certificate</span></span><br><span class="line">openssl x509  -noout -text -<span class="keyword">in</span> ./server.crt</span><br></pre></td></tr></table></figure><p><br></p><h4 id="easyrsa"><a href="#easyrsa" class="headerlink" title="easyrsa"></a>easyrsa</h4><p><br></p><h4 id="cfssl"><a href="#cfssl" class="headerlink" title="cfssl"></a>cfssl</h4><p><br></p><h4 id="分发自签名CA证书"><a href="#分发自签名CA证书" class="headerlink" title="分发自签名CA证书"></a>分发自签名CA证书</h4><p>客户端节点可以拒绝将自签名(self-signed)CA 证书识别为有效。对于非生产环境火灾防火墙后面运行的部署，你可以将自签名CA证书分发给客户端，并刷新本地列表以获取有效证书。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo cp ca.crt /usr/<span class="built_in">local</span>/share/ca-certificates/kubernetes.crt</span><br><span class="line">sudo update-ca-certificates</span><br><span class="line"></span><br><span class="line">Updating certificates <span class="keyword">in</span> /etc/ssl/certs...</span><br><span class="line">1 added, 0 removed; <span class="keyword">done</span>.</span><br><span class="line">Running hooks <span class="keyword">in</span> /etc/ca-certificates/update.d....</span><br><span class="line"><span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="云提供商"><a href="#云提供商" class="headerlink" title="云提供商"></a>云提供商</h3><p>跳过！</p><p><br><br><br></p><h3 id="管理资源"><a href="#管理资源" class="headerlink" title="管理资源"></a>管理资源</h3><p>可能，你已经部署应用程序并通过服务公开它。接下来怎么办？k8s提供了许多工具来帮助你管理应用程序部署(包括伸缩和更新)。我们将更深入讨论配置文件和标签。</p><p><br></p><h4 id="组织资源配置"><a href="#组织资源配置" class="headerlink" title="组织资源配置"></a>组织资源配置</h4><p>Organizing resource configurations</p><p>许多应用程序需要创建多个资源，如Deployment和Service。通过将多个资源组合在同一个文件中(在yaml中以<code>---</code>分隔)，可以简化多个资源的管理。</p><p>栗子：<code>nginx-app.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-nginx-svc</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">LoadBalancer</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>使用与单个资源相同的方式创建多个资源。<br>资源将按照它们在文件中出现的顺序创建。因此，最好首先指定Service，因为这将确保Scheduler可以扩展与服务关联的pod，因为它们是由Controller创建的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f https://k8s.io/examples/application/nginx-app.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#service "my-nginx-svc" created</span></span><br><span class="line"><span class="comment">#deployment "my-nginx" created</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#同样也支持多个-f</span></span><br><span class="line">kubectl create -f https://k8s.io/examples/application/nginx/nginx-svc.yaml -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者指定一个目录，读取yaml, yml, json文件</span></span><br><span class="line">kubectl create -f https://k8s.io/examples/application/nginx/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#url</span></span><br><span class="line">kubectl create -f https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/application/nginx/nginx-deployment.yaml</span><br></pre></td></tr></table></figure><p><strong>建议的做法是，将与同一微服务或应用程序相关的资源放入同一配置文件中，或将相关联的配置文件分组到同一目录下。</strong></p><p><br><br><br></p><h4 id="kubectl批量操作"><a href="#kubectl批量操作" class="headerlink" title="kubectl批量操作"></a>kubectl批量操作</h4><p>Bulk operations in kubectl</p><p>资源创建并不是<code>kubectl</code>可执行的唯一操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f https://k8s.io/examples/application/nginx-app.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#deployment "my-nginx" deleted</span></span><br><span class="line"><span class="comment">#service "my-nginx-svc" deleted</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#分开的资源</span></span><br><span class="line">kubectl delete deployments/my-nginx    services/my-nginx-svc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定label(selector)删除</span></span><br><span class="line">kubectl delete deployment,services -l app=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#deployment "my-nginx" deleted</span></span><br><span class="line"><span class="comment">#service "my-nginx-svc" deleted</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#递归删除--recursive -R</span></span><br><span class="line">kubectl create -f project/k8s/development --recursive</span><br><span class="line">kubectl create -f project/k8s/namespaces -f project/k8s/development --recursive</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="高效使用label"><a href="#高效使用label" class="headerlink" title="高效使用label"></a>高效使用label</h4><p>Using labels effectively</p><p>到目前为止，我们使用的示例最多只能将一个标签应用于任意资源。在许多情况下，应该使用多个标签来区分集合。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">     labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">guestbook</span></span><br><span class="line"><span class="attr">        tier:</span> <span class="string">backend</span></span><br><span class="line"><span class="attr">        role:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">get</span> <span class="string">pods</span> <span class="bullet">-Lapp</span> <span class="bullet">-Ltier</span> <span class="bullet">-Lrole</span></span><br><span class="line"></span><br><span class="line"><span class="string">kubectl</span> <span class="string">get</span> <span class="string">pods</span> <span class="bullet">-l</span> <span class="string">app=guestbook,role=master</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Canary-deployments"><a href="#Canary-deployments" class="headerlink" title="Canary deployments"></a>Canary deployments</h4><p>需要多个标签的另一种情况是区分不同版本的部署，或同一组件的配置。通常的做法是将新应用程序版本的canary与先前版本并排部署，以便新版本可以在完全推出前接收实时生产流量。</p><p>例如，你可以使用<code>track</code>标签来区分不同的版本:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#stable version</span></span><br><span class="line"><span class="attr">     name:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">     replicas:</span> <span class="number">3</span></span><br><span class="line">     <span class="string">...</span></span><br><span class="line"><span class="attr">     labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">guestbook</span></span><br><span class="line"><span class="attr">        tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">        track:</span> <span class="string">stable</span></span><br><span class="line">     <span class="string">...</span></span><br><span class="line"><span class="attr">     image:</span> <span class="attr">gb-frontend:v3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#new version</span></span><br><span class="line"><span class="attr">     name:</span> <span class="string">frontend-canary</span></span><br><span class="line"><span class="attr">     replicas:</span> <span class="number">1</span></span><br><span class="line">     <span class="string">...</span></span><br><span class="line"><span class="attr">     labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">guestbook</span></span><br><span class="line"><span class="attr">        tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">        track:</span> <span class="string">canary</span></span><br><span class="line">     <span class="string">...</span></span><br><span class="line"><span class="attr">     image:</span> <span class="attr">gb-frontend:v4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#前端服务将通过选择其标签的公共子集(`track`)来跨越两组副本，以便将流量定向到两个应用程序。</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">     app:</span> <span class="string">guestbook</span></span><br><span class="line"><span class="attr">     tier:</span> <span class="string">frontend</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="更新标签"><a href="#更新标签" class="headerlink" title="更新标签"></a>更新标签</h4><p>Updating labels</p><p>有时，在创建新资源之前，需要重新标记现有的pod和其它资源。这可使用<code>kubectl label</code>来完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#更新</span><br><span class="line">kubectl label pods -l app=nginx tier=fe</span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">kubectl get pods -l app=nginx -L tier</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="更新注释"><a href="#更新注释" class="headerlink" title="更新注释"></a>更新注释</h4><p>Updating annotations</p><p>有时，你会想要将注释附加到资源。这个使用<code>kubectl annotatie</code>来完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl annotate pods my-nginx-v4-9gw19 description=&apos;my frontend running nginx&apos;</span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">kubectl get pod my-nginx-v4-9gw19 -o yaml</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="伸缩应用程序"><a href="#伸缩应用程序" class="headerlink" title="伸缩应用程序"></a>伸缩应用程序</h4><p>Scaling your application</p><p>当应用程序上的负载增大或缩小时，可以使用<code>kubectl</code>轻松扩展。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployment/my-nginx --replicas=2</span><br><span class="line"></span><br><span class="line">kubectl get pods -l app=nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#自动伸缩</span></span><br><span class="line">kubectl autoscale deployment/my-nginx --min=1 --max=3</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="就地更新资源"><a href="#就地更新资源" class="headerlink" title="就地更新资源"></a>就地更新资源</h4><p>In-place updates of resources</p><p>有时，需要对创建的资源进行简单，无中断(non-disruptive)的更新。</p><p><strong>kubectl apply</strong><br>建议在源代码管理中维护一组配置文件，以便可以对它们配置的资源的代码进行维护和版本化。这样，你可以使用<code>kubectl apply</code>将更改的配置推送的集群。<br><code>kubectl apply</code>会将注释附加到资源，以便确定自上次调用以来对配置所做的更改。在调用它是，<code>kubectl apply</code>会在先前的配置，提供的输入和资源的当前配置之间进行差异比较，已确定如何修改资源。</p><p><br></p><p><strong>kubectl edit</strong><br>或者，你可使用<code>kubectl edit</code>来更新资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit deployment/my-nginx</span><br><span class="line">#这样就和vim差不多，可修改此部署</span><br></pre></td></tr></table></figure><p><br></p><p><strong>kubectl patch</strong><br>你可使用<code>kubectl patch</code>来更新API对象。此命令支持JSON patch, JSON merge patch和 strategic merge patch。</p><p><br><br><br></p><h4 id="破坏性更新"><a href="#破坏性更新" class="headerlink" title="破坏性更新"></a>破坏性更新</h4><p>Disruptive updates</p><p>在某些情况下，你可能需要更新初始化后无法更新的资源字段，或者你可能只想立即进行递归更改，例如修复部署创建的损坏的pod。要更改此类资源，请使用<code>replace --force</code>——它将删除并重新创建资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl replace -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml --force</span><br><span class="line">deployment &quot;my-nginx&quot; deleted</span><br><span class="line">deployment &quot;my-nginx&quot; replaced</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="在服务没有中断的情况下更新应用程序"><a href="#在服务没有中断的情况下更新应用程序" class="headerlink" title="在服务没有中断的情况下更新应用程序"></a>在服务没有中断的情况下更新应用程序</h4><p>Updating your application without a service outage</p><p>在某些时候，你最终需要更新已部署的应用程序，通常是指定新的image或image tag。<code>kubectl</code>支持多种更新操作，每种操作都适用于不同的场景。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl run my-nginx --image=nginx:1.7.9 --replicas=3</span><br><span class="line">#deployment &quot;my-nginx&quot; created</span><br><span class="line"></span><br><span class="line">#更新nginx版本为: 1.9.1</span><br><span class="line">kubectl edit deployment/my-nginx</span><br><span class="line">#修改镜像那一行</span><br></pre></td></tr></table></figure><p>部署将以声明的方式逐步更新已部署的nginx应用程序。它确保在更新时只有一定数量的旧副本可能会关闭，并且在所需数量的pod之上只能创建一定数量的新副本。</p><p><br><br><br></p><h3 id="集群网络"><a href="#集群网络" class="headerlink" title="集群网络"></a>集群网络</h3><p>Cluster Networking</p><p>默认情况下，k8s与docker的网络方式有所不同。有4个网络问题需要解决：</p><ul><li><strong>高度耦合的容器到容器的通信</strong>: 这通过pod和localhost通信解决</li><li><strong>pod到pod的通信</strong>： 这是侧重点</li><li><strong>pod到service的通信</strong>： 这包含在Service中</li><li><strong>external到service的通信</strong>： 这包含在service中</li></ul><p>k8s假设pod与pod间是可以通信的，无论它们位于哪个主机。每个pod都有自己的IP地址，因此你无需在pod之间明确创建链接，也几乎不需要处理映射容器端口到主机端口。这创建了一个干净的向后兼容的模型，从端口分配、命名、服务发现、负载均衡、应用程序配置和迁移的角度来看，pod可以像VM或物理主机一样。</p><p>为实现此目的，你需要设置集群网络。</p><p><br></p><h4 id="Docker模型"><a href="#Docker模型" class="headerlink" title="Docker模型"></a>Docker模型</h4><p>在讨论k8s网络方法之前，有必要回顾Docker网络方式。默认情况下，Docker使用<code>host-private</code>网络。它创建一个虚拟网桥(称为docker0)，并从RFC1918中为该网桥定义的一个专用地址块中分配一个子网。对于Docker创建的每个容器，它分配一个连接到网桥的虚拟以太网设备(称为veth)。使用Linux命名空间将<code>veth</code>映射为容器中的<code>eth0</code>。容器内的<code>eth0</code>网口从桥接器的地址范围获取IP地址。<br>为了使Docker容器跨节点进行通信，必须在计算机自己的IP地址上分配端口，然后将这些端口转发/代理到容器。这意味着容器必须小心地使用端口，或动态分配端口。</p><p><br><br><br></p><h4 id="k8s模型"><a href="#k8s模型" class="headerlink" title="k8s模型"></a>k8s模型</h4><p>跨多开发者协调端口非常难以大规模地进行，并使用户暴露在他们无法控制的集群级别问题之外。动态端口分配给系统带来了很多复杂性——每个应用程序都必须将端口作为标志，API server必须知道如何将动态端口号插入配置块，服务必须知道如何找到彼此。与此相关，k8s采取了不同的方法。</p><p>k8s对任何网络实施都强加了一下基本要求：</p><ul><li>容器间可互相通信而无需NAT</li><li>所有节点都可与所有容器通信而无需NAT</li><li>容器看到的IP与其他人看到的IP相同</li></ul><p>实际上，k8s在pod范围应用IP地址，pod中的容器共享其网络命名空间(包括IP地址)。这意味着pod中的容器都可以在localhost上彼此通信。这被称为<code>ip-per-pod</code>模型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#在Docker中查看</span><br><span class="line">docker network inspect bridge</span><br><span class="line"></span><br><span class="line">#可看到副本集的容器，都是pod，而非container</span><br><span class="line">#这也证明container共享pod的网络空间</span><br><span class="line">#注意它的网关便是docker0</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;68bc0cf07a4d7666e1d35f2c1cf179ae8605b431353ba93446abc898de086a9c&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-07-23T17:45:54.42038221+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;10.254.76.0/24&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;10.254.76.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;7d2e6561fa81730ae05743f78871666df75cf5e6f483b71da33137823c172333&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;k8s_POD.24f70ba9_hello-world-3198537413-138pg_default_adb8f0fe-8fea-11e8-b10b-000c29aa7e75_785c4a84&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;bf50c5a71ad26531a370a73ce8da5903d32b9e2f8b8397d7405b914203071c45&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:0a:fe:4c:06&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;10.254.76.6/24&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;ea9fbf660f27943b866759a084dc26457474d73c50082939f157ed1dfe0bc806&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;k8s_POD.24f70ba9_hello-world-3198537413-ddgb3_default_adb90c8c-8fea-11e8-b10b-000c29aa7e75_0452e1f4&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;e83401827e0e6d2896eb46c7b252594c1694ca119d0cbd74c29383209b80a128&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:0a:fe:4c:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;10.254.76.2/24&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="如何实现k8s网络模型"><a href="#如何实现k8s网络模型" class="headerlink" title="如何实现k8s网络模型"></a>如何实现k8s网络模型</h4><p>How to implement the Kubernetes networking model</p><p>有多种方式实现此网络模型，以下做一个概述。</p><ul><li>ACI</li><li>AOS from Apstra</li><li>Big Cloud Fabric from Big Switch Networks</li><li>Cilium</li><li>CNI-Genie from Huawei</li><li>Contiv</li><li>Contrail</li><li>Flannel</li><li>Google Compute Engine</li><li>Kube-router</li><li>L2 networks and linux bridging</li><li>Multus</li><li>NSX-T</li><li>Nuage Networks VCS</li><li>OpenVSwitch</li><li>OVN</li><li>Project Calico</li><li>Romana</li><li>Weave Net from Weaveworks</li></ul><p><br><br><br></p><h3 id="日志架构"><a href="#日志架构" class="headerlink" title="日志架构"></a>日志架构</h3><p>Logging Architecture</p><p>应用程序和系统日志可以帮助你了解集群内部发生的情况。大多数现代应用程序都有某种日志机制，因此，大多数容器化引擎同样设计来支持多种日志。容器化应用程序最简单、最受欢迎的日志方法是写入<code>stdout</code>和<code>stderr</code>。</p><p>但是，容器引擎或<code>runtime</code>提供的本地(native)功能通常不足以构建完整的日志解决方案。例如，如果container crashe、pod evicted、node dies，你通常仍然希望访问应用程序的日志。因此，日志应独立于container、pod、node，并具有单独存储(separate storage)和生命周期(lifecycle)。这个概念称为集群级日志(cluster-level-loggin)。集群级日志需要单独的后端来<strong>存储(store)、分析(analyze)、查询(query)</strong>日志。k8s不提供日志数据的本地存储解决方案，但你可以将许多现有的日志解决方案集成到k8s集群中。</p><p>集群级日志架构假设在集群内部或外部存在日志记录后端。</p><p><br><br><br></p><h4 id="k8s基本日志"><a href="#k8s基本日志" class="headerlink" title="k8s基本日志"></a>k8s基本日志</h4><p>Basic logging in Kubernetes</p><p>本节中，k8s将日志记录到到标准输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/k8s/test/counter-pod.yaml</span><br><span class="line">#此pod每秒输出一条信息</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: counter</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: count</span><br><span class="line">    image: busybox</span><br><span class="line">    args: [/bin/sh, -c,</span><br><span class="line">            &apos;i=0; while true; do echo &quot;$i: $(date)&quot;; i=$((i+1)); sleep 1; done&apos;]</span><br><span class="line"></span><br><span class="line">#创建</span><br><span class="line">#kubectl create -f /etc/k8s/test/counter-pod</span><br><span class="line"></span><br><span class="line">#不指定命名空间，则默认default</span><br><span class="line">#也可在配置文件里指定命名空间</span><br><span class="line">#kubectl create -f /etc/k8s/test/counter-pod --namespace=test</span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">#如果pod有多个容器，则应该指定容器名称</span><br><span class="line">kubectl logs counter</span><br><span class="line"></span><br><span class="line">0: Fri Aug 10 07:43:09 UTC 2018</span><br><span class="line">1: Fri Aug 10 07:43:10 UTC 2018</span><br><span class="line">2: Fri Aug 10 07:43:11 UTC 2018</span><br><span class="line">3: Fri Aug 10 07:43:12 UTC 2018</span><br><span class="line">4: Fri Aug 10 07:43:13 UTC 2018</span><br><span class="line">5: Fri Aug 10 07:43:14 UTC 2018</span><br><span class="line">6: Fri Aug 10 07:43:15 UTC 2018</span><br><span class="line">7: Fri Aug 10 07:43:16 UTC 2018</span><br><span class="line">8: Fri Aug 10 07:43:17 UTC 2018</span><br><span class="line">9: Fri Aug 10 07:43:18 UTC 2018</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="节点级日志记录"><a href="#节点级日志记录" class="headerlink" title="节点级日志记录"></a>节点级日志记录</h4><p>Logging at the node level</p><p><img src="/images/K8s/logging-node-level.png" alt="节点级日志"></p><p><br></p><p>容器化应用程序写入<code>stdout</code>, <code>stderr</code>的所有内容，都由容器引擎处理并重定向到某处。Docker容器引擎可修改日志驱动程序，将日志写入到其它地方(file, json, fluent…)。</p><blockquote><p>注意<br>Docker json日志驱动将每一行视为单独的消息，它没有直接支持多行消息，你需要使用更高级别来处理它。</p></blockquote><p>默认情况下，如果容器重启，<code>kubelet</code>会使用其日志保留一个已终止(terminated)的容器。如果从节点上驱逐pod，则所有相应的容器也会被驱逐(包括日志)。</p><p>节点级日志记录中，一个重要考虑因素是实现日志轮询(log rotation)，以便日志不会占用节点所有可用存储。k8s目前不负责轮询日志，但部署工具应该配置方案来解决日志轮询问题。<br>例如，在k8s集群中，部署一个脚本程序，用于日志轮询。或设置Docker container runtime的<code>log-opt</code>标志已自动轮询应用程序日志。</p><p>当在基本日志记录中运行<code>kubectl logs</code>命令时，节点上的<code>kubelet</code>会处理请求直接从日志文件读取，返回响应的内容。<br>注意： 如果某个外部系统已执行轮询，则<code>kubectl  logs</code>只能获取到最新的日志文件。</p><p><br></p><p><strong>system component logs</strong><br>有两种类型的系统组件:</p><ul><li><strong>run in container</strong>: 如<code>kube-proxy</code></li><li><strong>not run in container</strong>: 如<code>kubelet</code>, Docker</li></ul><p>在使用<code>systemd</code>的机器上，<code>kubelet</code>和<code>container runtime</code>将日志写到<code>journald</code>。如果没有<code>systemd</code>，则写到<code>/var/log/</code>下。容器内的系统组件始终将日志写入<code>/var/log</code>目录下，绕过默认的日志机制。<br>与容器日志类似，在<code>/var/log/</code>目录下的系统组件日志也应该被轮询。</p><p><br><br><br></p><h4 id="集群级日志架构"><a href="#集群级日志架构" class="headerlink" title="集群级日志架构"></a>集群级日志架构</h4><p>Cluster-level logging architectures</p><p>k8s官方没有提供原生的集群级日志记录，但你可以考虑集中常见方法：</p><ul><li>在每个节点上使用<code>node-level logging agent</code></li><li>用于记录应用程序pod的专用<code>sidecar container</code></li><li>将日志直接从应用程序推送到后端</li></ul><p><br></p><p><strong>Using a node logging agent</strong></p><p><img src="/images/K8s/logging-with-node-agent.png" alt=""></p><p>你可以通过在每个节点上包含一个 节点级日志记录代理 来实现集群级日志记录。它是一个用于公开日志或将日志推送到后端的专用工具。<br>通常，此日志代理是一个容器，它可以访问该节点上所有应用程序容器的日志文件的目录。</p><p>由于日志记录代理必须在每个节点上运行，因此，将其实现为节点上的<code>DaemonSet replica</code>, <code>manifest pod</code>, <code>dedicated native process</code>是很常见的。然后，后两种方法已被弃用，并且非常不建议。</p><p>对于k8s集群，使用节点级日志代理是最常见和鼓励的方法，因为它在每个节点上只创建一个Agent，并且不需要对节点上运行的应用程序进行任何更改。然而，节点级日志仅适用于应用程序的<code>stdout</code>和<code>stderr</code>。</p><p>k8s并未指定logging Agent，但有两个可选的日志代理与k8s一同打包。两者都使用<code>fluentd</code>的自定义配置作为节点上的代理。</p><ul><li>Stackdriver Logging: 用于Google Cloud Platform</li><li>Elasticsearch</li></ul><p><br></p><p><strong>Using a sidecar container with the logging agent</strong><br>你可通过以下方式使用<code>sidecar container</code>:</p><ul><li><code>sidecar container</code>将应用程序的日志传输到自己的<code>stdout</code></li><li><code>sidecar container</code>容器运行一个<code>Logging Agent</code>，此代理从应用程序容器中获取日志</li></ul><p><img src="/images/K8s/logging-with-streaming-sidecar.png" alt=""></p><p><br></p><p>通过让<code>sidecar container</code>的stream流向他们自己的<code>stdout/stderr</code>，你可利用已经在每个节点上运行的<code>kubelet</code>和<code>logging agent</code>。<code>sidecat container</code>从file、socket、journald读取日志。每个单独的<code>sidecar container</code>将日志打印到自己的<code>stdout/stderr</code>。<br>此方法允许你从应用程序的不同部分分离多个日志流，其中一些可能缺乏对写入<code>stdout/stderr</code>的支持。重定向日志背后的逻辑是最小的，因此它几乎不是一个重要的开销。此外，因为<code>stdout/stderr</code>由kubelet处理，所以你可以使用如<code>kubectl logs</code>这样的内置工具。</p><p><br></p><p>考虑如下栗子，pod运行单个容器，此容器使用两种不同的日志格式写入两个不同的日志。</p><p>two-files-counter-pod.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">counter</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">count</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    args:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/bin/sh</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">      i=0;</span></span><br><span class="line"><span class="string">      while true;</span></span><br><span class="line"><span class="string">      do</span></span><br><span class="line"><span class="string">        echo "$i: $(date)" &gt;&gt; /var/log/1.log;</span></span><br><span class="line"><span class="string">        echo "$(date) INFO $i" &gt;&gt; /var/log/2.log;</span></span><br><span class="line"><span class="string">        i=$((i+1));</span></span><br><span class="line"><span class="string">        sleep 1;</span></span><br><span class="line"><span class="string">      done</span></span><br><span class="line"><span class="string"></span><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">varlog</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/var/log</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">varlog</span></span><br><span class="line"><span class="attr">    emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>即使你设法将两个组件重定向到容器的<code>stdout</code>，在同一个日志流中包含不同格式的日志条目也会很麻烦。相反，你可以引入两个<code>sidecar container</code>。每个<code>sidecar container</code>可以从共享卷(shared volume)中<code>tail</code>特定的日志文件，然后将日志重定向到自己的<code>stdout</code>。</p><p><br></p><p>这是pod运行两个<code>sidecat container</code>的配置文件。<br>三个容器共享了<code>/var/log</code>。</p><p>two-file-counter-pod-streaming-sidecar.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">counter</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">count</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    args:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/bin/sh</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">      i=0;</span></span><br><span class="line"><span class="string">      while true;</span></span><br><span class="line"><span class="string">      do</span></span><br><span class="line"><span class="string">        echo "$i: $(date)" &gt;&gt; /var/log/1.log;</span></span><br><span class="line"><span class="string">        echo "$(date) INFO $i" &gt;&gt; /var/log/2.log;</span></span><br><span class="line"><span class="string">        i=$((i+1));</span></span><br><span class="line"><span class="string">        sleep 1;</span></span><br><span class="line"><span class="string">      done</span></span><br><span class="line"><span class="string"></span><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">varlog</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/var/log</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">count-log-1</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    args:</span> <span class="string">[/bin/sh,</span> <span class="bullet">-c,</span> <span class="string">'tail -n+1 -f /var/log/1.log'</span><span class="string">]</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">varlog</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/var/log</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">count-log-2</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    args:</span> <span class="string">[/bin/sh,</span> <span class="bullet">-c,</span> <span class="string">'tail -n+1 -f /var/log/2.log'</span><span class="string">]</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">varlog</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/var/log</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">varlog</span></span><br><span class="line"><span class="attr">    emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>现在运行此pod，并单独访问每个日志流:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#run</span></span><br><span class="line">kubectl create -f /etc/k8s/<span class="built_in">test</span>/two-file-counter-pod-streaming-sidecar.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#get</span></span><br><span class="line">kubectl get pod/counter -o wide</span><br><span class="line">NAME      READY     STATUS    RESTARTS   AGE       IP           NODE</span><br><span class="line">counter   3/3       Running   0          9m        10.244.2.9   salt01</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">kubectl logs counter</span><br><span class="line">Error from server (BadRequest): a container name must be specified <span class="keyword">for</span> pod counter, choose one of: [count count-log-1 count-log-2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#logs</span></span><br><span class="line">kubectl logs counter count-log-1</span><br><span class="line"></span><br><span class="line">0: Tue Aug 14 02:58:29 UTC 2018</span><br><span class="line">1: Tue Aug 14 02:58:30 UTC 2018</span><br><span class="line">2: Tue Aug 14 02:58:31 UTC 2018</span><br><span class="line">3: Tue Aug 14 02:58:32 UTC 2018</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl logs counter count-log-2</span><br><span class="line"></span><br><span class="line">Tue Aug 14 02:58:29 UTC 2018 INFO 0</span><br><span class="line">Tue Aug 14 02:58:30 UTC 2018 INFO 1</span><br><span class="line">Tue Aug 14 02:58:31 UTC 2018 INFO 2</span><br><span class="line">Tue Aug 14 02:58:32 UTC 2018 INFO 3</span><br></pre></td></tr></table></figure><p>集群中安装的节点级代理会自动获取这些日志流，而无需进一步配置。如果愿意，可将代理配置为根据源容器解析日志行。</p><p>注意，进错CPU和内存使用率很低，将日志写入文件然后将它们流式传输到<code>stdout</code>会使磁盘使用量增加一倍。如果你有一个应用程序将日志写到单个文件，通常最好将<code>/dev/stdout</code>设置为目标，而不是实现流式<code>sidecar container</code>方法。</p><p><code>sidecar container</code>还可用于应用程序本身日志轮询。然而，建议直接使用<code>stdout/stderr</code>并将日志的轮询和保留交给<code>kubelet</code>。</p><p><br></p><p><strong>Sidecar container wiht a logging agent</strong></p><p><img src="/images/K8s/logging-with-sidecar-agent.png" alt="官方栗子"></p><p><br></p><p><img src="/images/K8s/filebeat-log-collector-arch.png" alt="额外栗子"></p><p><br></p><p>如果节点级日志记录代理对你来说不够灵活，你可以创建一个带有单独日志记录代理程序的<code>sidecar container</code>，该代理可专门配置来与你的程序一起运行。</p><blockquote><p>注意：<br>在<code>sidecar container</code>使用日志记录代理将会消耗大量资源。此外，你将无法使用<code>kubectl logs</code>命令访问这些日志，因为它们不受kubelet控制。</p></blockquote><p>栗子使用<code>fluentd</code>作为<code>logging agent</code>。有两个可用于实现此方法的配置文件：</p><ul><li>ConfigMap<br>使用<code>ConfigMap</code>来配置fluentd。具体配置参考fluentd官方文档。</li></ul><p><code>fluentd-sidecat-config.yaml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: fluentd-config</span><br><span class="line">data:</span><br><span class="line">  fluentd.conf: |</span><br><span class="line">    &lt;source&gt;</span><br><span class="line">      type tail</span><br><span class="line">      format none</span><br><span class="line">      path /var/log/1.log</span><br><span class="line">      pos_file /var/log/1.log.pos</span><br><span class="line">      tag count.format1</span><br><span class="line">    &lt;/source&gt;</span><br><span class="line"></span><br><span class="line">    &lt;source&gt;</span><br><span class="line">      type tail</span><br><span class="line">      format none</span><br><span class="line">      path /var/log/2.log</span><br><span class="line">      pos_file /var/log/2.log.pos</span><br><span class="line">      tag count.format2</span><br><span class="line">    &lt;/source&gt;</span><br><span class="line"></span><br><span class="line">    &lt;match **&gt;</span><br><span class="line">      type google_cloud</span><br><span class="line">    &lt;/match&gt;</span><br></pre></td></tr></table></figure><ul><li>pod<br>运行fluentd的<code>sidecat container</code>的pod。它挂载一个volume让fluentd获取配置数据。<br>下面需要用到<code>k8s.gcr.io/fluentd-gcp:1.30</code>镜像，请提前准备。要挂载目录，请创建。</li></ul><p><code>two-files-counter-pod-agent-sidecar.yaml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: counter</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: count</span><br><span class="line">    image: busybox</span><br><span class="line">    args:</span><br><span class="line">    - /bin/sh</span><br><span class="line">    - -c</span><br><span class="line">    - &gt;</span><br><span class="line">      i=0;</span><br><span class="line">      while true;</span><br><span class="line">      do</span><br><span class="line">        echo &quot;$i: $(date)&quot; &gt;&gt; /var/log/1.log;</span><br><span class="line">        echo &quot;$(date) INFO $i&quot; &gt;&gt; /var/log/2.log;</span><br><span class="line">        i=$((i+1));</span><br><span class="line">        sleep 1;</span><br><span class="line">      done</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: varlog</span><br><span class="line">      mountPath: /var/log</span><br><span class="line">  - name: count-agent</span><br><span class="line">    image: k8s.gcr.io/fluentd-gcp:1.30</span><br><span class="line">    env:</span><br><span class="line">    - name: FLUENTD_ARGS</span><br><span class="line">      value: -c /etc/fluentd-config/fluentd.conf</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: varlog</span><br><span class="line">      mountPath: /var/log</span><br><span class="line">    - name: config-volume</span><br><span class="line">      mountPath: /etc/fluentd-config</span><br><span class="line">  volumes:</span><br><span class="line">  - name: varlog</span><br><span class="line">    emptyDir: &#123;&#125;</span><br><span class="line">  - name: config-volume</span><br><span class="line">    configMap:</span><br><span class="line">      name: fluentd-config</span><br></pre></td></tr></table></figure><p>这仅仅是一个栗子。你可以使用其它<code>logging agent</code>取代<code>fluentd</code>，如<code>filebeat</code>, <code>logstash</code>…</p><p><br></p><p><strong>Exposing logs directly from the application</strong></p><p><img src="/images/K8s/logging-from-application.png" alt=""></p><p><br></p><p>你可以通过直接公开每个应用程序的日志或push日志来实现集群级日志记录。就相当于在写得程序中加入日志收集和处理。<br>但是，这种日志记录机制超出了k8s的范围。</p><p><br><br><br></p><h3 id="kubelet垃圾回收"><a href="#kubelet垃圾回收" class="headerlink" title="kubelet垃圾回收"></a>kubelet垃圾回收</h3><p>Configuring kubelet Garbage Collection</p><p>垃圾回收是一个有用的kubelet功能，它将清理未使用的镜像和容器。每分钟对容器执行垃圾回收，每五分钟对镜像进行垃圾回收。<br>不推荐使用额外的垃圾回收工具，因为这可能会破坏<code>kubelet</code>的行为。</p><p><br></p><h4 id="镜像回收"><a href="#镜像回收" class="headerlink" title="镜像回收"></a>镜像回收</h4><p>Image Collection</p><p>k8s在<code>cadvisor</code>的配合下，通过<code>imageManager</code>管理所有镜像的生命周期。<br>镜像垃圾回收策略考虑了两个要素：</p><ul><li>HighThresholdPercent</li><li>LowThresholdPercent</li></ul><p>磁盘使用率高于高阈值将触发垃圾回收，垃圾回收将删除最近最少使用的镜像，直到满足低阈值。</p><p><br></p><p>镜像垃圾回收的kubelet flag:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#触发镜像垃圾回收的磁盘使用率百分比</span><br><span class="line">#默认值 90%</span><br><span class="line">image-gc-high-threshold</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#镜像垃圾回收尝试释放磁盘使用的百分比</span><br><span class="line">#默认值 80%</span><br><span class="line">image-gc-low-threshold</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="容器回收"><a href="#容器回收" class="headerlink" title="容器回收"></a>容器回收</h4><p>Container Collection</p><p>容器垃圾回收策略考虑了三个用户定义的变量：</p><ul><li>MinAge</li><li>MaxPerPodContainer</li><li>MaxContainers</li></ul><p><code>MinAge</code>是容器可以被垃圾回收的最小年龄。设置为0可禁用。<br><code>MaxPerPodContainer</code>是允许每个pod对允许拥有的最大死容器数。设置小于0可禁用。<br><code>MaxContainers</code>是总死亡容器的最大数量。设置小于0可禁用。</p><p>kubelet将对未识别、删除或标志设置的边界之外的容器起作用。通常首先移除最旧的容器。<br>不受kubelet管理的容器不受容器垃圾回收的限制。</p><p><br></p><p>容器垃圾回收的kubelet flag:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#完成的容器在垃圾回收之前的最低年龄</span><br><span class="line">#默认值 0min，意味着每个完成的容器都将被垃圾回收</span><br><span class="line">minimum-container-ttl-duration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#每个容器要保留的最大旧实例数</span><br><span class="line">#默认值 1</span><br><span class="line">#强烈建议使用足够大的值，以允许每个预期容器保留至少1个死亡容器</span><br><span class="line">maximum-dead-containers-per-container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#全局要保留的最大容器实例数</span><br><span class="line">#默认值 -1，意味着禁用</span><br><span class="line">#处于类似的原因，同样建议使用较大的值</span><br><span class="line">maximum-dead-containers</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h4><p>一些kubelet垃圾回收标志未来将被启用或取代。</p><table><thead><tr><th>Existing Flag</th><th>New Flag</th><th>Rationale</th></tr></thead><tbody><tr><td>–image-gc-high-threshold</td><td>–eviction-hard or –eviction-soft</td><td>existing eviction signals can trigger image garbage collection</td></tr><tr><td>–image-gc-low-threshold</td><td>–eviction-minimum-reclaim</td><td>eviction reclaims achieve the same behavior</td></tr><tr><td>–maximum-dead-containers</td><td>xxx</td><td>deprecated once old logs are stored outside of container’s context</td></tr><tr><td>–maximum-dead-containers-per-container</td><td>xxx</td><td>deprecated once old logs are stored outside of container’s context</td></tr><tr><td>–minimum-container-ttl-duration</td><td>xxx</td><td>deprecated once old logs are stored outside of container’s context</td></tr><tr><td>–low-diskspace-threshold-mb</td><td>–eviction-hard or eviction-soft</td><td>eviction generalizes disk thresholds to other resources</td></tr><tr><td>–outofdisk-transition-frequency</td><td>–eviction-pressure-transition-period</td><td>eviction generalizes disk pressure transition to other resources</td></tr></tbody></table><p><br><br><br></p><h3 id="Federation"><a href="#Federation" class="headerlink" title="Federation"></a>Federation</h3><p>先跳过，后面来学习。</p><p><br><br><br></p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxies in Kubernetes</p><p>使用Kubernetes时可能会遇到几种不同的代理。<br>代理已经取代了重定向功能，重定向已被弃用。</p><p><br></p><h4 id="kubectl-proxy"><a href="#kubectl-proxy" class="headerlink" title="kubectl proxy"></a>kubectl proxy</h4><ol><li>runs on a user’s desktop or in a pod</li><li>proxies from a localhost address to the Kubernetes apiserver</li><li>client to proxy uses HTTP</li><li>proxy to apiserver uses HTTPS</li><li>locates apiserver</li><li>adds authentication headers</li></ol><p><br><br><br></p><h4 id="apiserver-proxy"><a href="#apiserver-proxy" class="headerlink" title="apiserver proxy"></a>apiserver proxy</h4><ol><li>is a bastion built into the apiserver</li><li>connects a user outside of the cluster to cluster IPs which otherwise might not be reachable</li><li>runs in the apiserver processes</li><li>client to proxy uses HTTPS (or http if apiserver so configured)</li><li>proxy to target may use HTTP or HTTPS as chosen by proxy using available information</li><li>can be used to reach a Node, Pod, or Service</li><li>does load balancing when used to reach a Service</li></ol><p><br><br><br></p><h4 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube proxy"></a>kube proxy</h4><ol><li>runs on each node</li><li>proxies UDP and TCP</li><li>does not understand HTTP</li><li>provides load balancing</li><li>is just used to reach services</li></ol><p><br><br><br></p><h4 id="A-Proxy-Load-balancer-in-front-of-apiserver"><a href="#A-Proxy-Load-balancer-in-front-of-apiserver" class="headerlink" title="A Proxy/Load-balancer in front of apiserver"></a>A Proxy/Load-balancer in front of apiserver</h4><ol><li>existence and implementation varies from cluster to cluster(e.g. nginx)</li><li>sits between all clients and one or more apiservers</li><li>acts as load balancer if there are several apiservers</li></ol><p><br><br><br></p><h4 id="云负载均衡器"><a href="#云负载均衡器" class="headerlink" title="云负载均衡器"></a>云负载均衡器</h4><ol><li>由云服务商提供</li><li>当k8s服务有LoadBalancer类型时自动创建</li><li>仅使用udp/tcp</li><li>具体详情因云服务商而异</li></ol><p><br><br><br></p><h3 id="控制器管理器指标"><a href="#控制器管理器指标" class="headerlink" title="控制器管理器指标"></a>控制器管理器指标</h3><p>Controller manager metrics</p><p>控制器管理器指标，提供有关控制器管理器性能和运行状况的重要信息。</p><p>这些指标包括常见的Go语言运行时指标、控制器特定指标。可用于衡量集群的运行状况。</p><p>在集群中，当控制器管理器运行时，可从<code>http://localhost:10252/metrics</code>获取控制器管理器指标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netstat -nltup | grep 10252</span><br><span class="line">tcp        0      0 127.0.0.1:10252         0.0.0.0:*               LISTEN      11088/kube-controll </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl http://localhost:10252/metrics</span><br></pre></td></tr></table></figure><p>这些指标以<code>prometheus format</code>格式发出，并且是人类可读的。</p><p><br><br><br></p><h3 id="附加组件"><a href="#附加组件" class="headerlink" title="附加组件"></a>附加组件</h3><p>Installing Addons</p><p>附加组件扩展了k8s的功能。</p><p><br></p><h4 id="网络和网络策略"><a href="#网络和网络策略" class="headerlink" title="网络和网络策略"></a>网络和网络策略</h4><p>Networking and Network Policy</p><ul><li>ACI： 通过 Cisco ACI提供集成的容器网络和网络完全</li><li>Calico： 是一个安全的L3网络和网络策略提供商</li><li>Canal: 将Flannel和Calico联合起来，提供网络和网络策略</li><li>Cilium： 是一个L3网络和网络策略插件</li><li>CNI-Genie： 使k8s能够无缝连接到各种CNI插件</li><li>Contiv： 提供可配置的网络，用于各种用例和丰富的策略框架</li><li>Flannel： 是一个可以与k8s一起使用的overlay网络提供商</li><li>Knitter： 是一个支持k8s多个网络的网络解决方案</li><li>Multus： 是一个用于k8s中多个网络支持，以支持所有CNI插件的多插件</li><li>NSX-T： 提供VMware NSX-T与容器协调器之间的集成</li><li>Nuage： 是一个SDN平台，可在k8s Pod和non-k8s环境之间提供基于策略的网络，并提供可见性和安全性监控</li><li>Romana： 用于Pod网络的L3网络解决方案</li><li>Weave Net： 提供网络和网络策略，将在网络分区的两侧进行工作，而不需要外部数据库</li></ul><p><br><br><br></p><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>Service Discovery</p><ul><li><a href="https://coredns.io/" target="_blank" rel="noopener">CoreDNS</a>： 是一个灵活，可扩展的DNS服务器，可作为用于pod的集群DNS。</li></ul><p><br><br><br></p><h4 id="可视化，控制"><a href="#可视化，控制" class="headerlink" title="可视化，控制"></a>可视化，控制</h4><p>Visualization, Control</p><ul><li><a href="https://github.com/kubernetes/dashboard#kubernetes-dashboard" target="_blank" rel="noopener">Dashboard</a>： k8s的Dashboard Web Interface</li><li><a href="https://www.weave.works/docs/scope/latest/installing/#k8s" target="_blank" rel="noopener">Weave Scope</a>： 是一个用于以图形可视化显示container, pod, service…</li></ul><p><br><br><br><br><br></p><h2 id="k8s架构"><a href="#k8s架构" class="headerlink" title="k8s架构"></a>k8s架构</h2><p>Kubernetes Architecture</p><p><br></p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>node是k8s中的工作机器，以前称为minion。也就是集群中的一台主机。节点可以是VM或物理机。每个节点都具有用于运行pod所需的服务，并由master组件管理。节点上的服务包括<code>docker</code>, <code>kubelet</code>, <code>kube-proxy</code>。</p><p><br></p><h4 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h4><p>Node Status</p><p>节点的状态包含以下信息：</p><ul><li>地址(Address)</li><li>条件(Condition)</li><li>容量(Capacity)</li><li>信息(Info)</li></ul><p><br></p><p><strong>地址</strong><br>这些字段的使用取决于机器配置。</p><ul><li>HostName： 节点内核报告的主机名</li><li>ExternalIP： 通常是可从外部路由的节点IP地址</li><li>InternalIP： 通常是仅在集群内可路由的节点IP地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node -o wide</span><br><span class="line">NAME      STATUS    ROLES     AGE       VERSION   INTERNAL-IP      EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION              CONTAINER-RUNTIME</span><br><span class="line">master    Ready     master    7d        v1.11.1   192.168.31.49    &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-862.9.1.el7.x86_64   docker://1.13.1</span><br><span class="line">node      Ready     &lt;none&gt;    7d        v1.11.1   192.168.31.174   &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-862.9.1.el7.x86_64   docker://1.13.1</span><br><span class="line">salt01    Ready     &lt;none&gt;    1d        v1.11.1   192.168.31.159   &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-862.9.1.el7.x86_64   docker://1.13.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl describe node/salt01</span><br><span class="line">Addresses:</span><br><span class="line">  InternalIP:  192.168.31.159</span><br><span class="line">  Hostname:    salt01</span><br></pre></td></tr></table></figure><p><br></p><p><strong>条件</strong><br>该字段描述了所有运行中节点的状态。节点条件使用JSON对象表示。</p><table><thead><tr><th>条件</th><th>描述</th></tr></thead><tbody><tr><td>OutOfDisk</td><td>True(节点上的可用空间不足以添加新pod), 否则为False</td></tr><tr><td>Ready</td><td>True(节点健康并准备好接受pod) <br> False(节点不健康且不接受pod) <br> Unknown(节点控制器在最后一个<code>node-monitor-grace-period</code>期限内没有从节点收到消息。默认40s)</td></tr><tr><td>MemoryPressure</td><td>True(节点内存有压力，即内存不足)，否则为False</td></tr><tr><td>PIDPressure</td><td>True(进程存在压力，即节点上有太多进程)，否则为False</td></tr><tr><td>DiskPressure</td><td>True(磁盘大小存在压力，即磁盘容量较低), 否则为False</td></tr><tr><td>NetworkUnavailable</td><td>True(节点网络配置错误)，否则为False</td></tr><tr><td>ConfigOK</td><td>True(kubelet配置正确)，否则为False</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node/salt01</span><br><span class="line">Conditions:</span><br><span class="line">  Type             Status  LastHeartbeatTime                 LastTransitionTime                Reason                       Message</span><br><span class="line">  ----             ------  -----------------                 ------------------                ------                       -------</span><br><span class="line">  OutOfDisk        False   Wed, 15 Aug 2018 11:10:49 +0800   Mon, 13 Aug 2018 15:51:40 +0800   KubeletHasSufficientDisk     kubelet has sufficient disk space available</span><br><span class="line">  MemoryPressure   False   Wed, 15 Aug 2018 11:10:49 +0800   Mon, 13 Aug 2018 15:51:40 +0800   KubeletHasSufficientMemory   kubelet has sufficient memory available</span><br><span class="line">  DiskPressure     False   Wed, 15 Aug 2018 11:10:49 +0800   Mon, 13 Aug 2018 15:51:40 +0800   KubeletHasNoDiskPressure     kubelet has no disk pressure</span><br><span class="line">  PIDPressure      False   Wed, 15 Aug 2018 11:10:49 +0800   Mon, 13 Aug 2018 15:51:40 +0800   KubeletHasSufficientPID      kubelet has sufficient PID available</span><br><span class="line">  Ready            True    Wed, 15 Aug 2018 11:10:49 +0800   Mon, 13 Aug 2018 15:53:00 +0800   KubeletReady                 kubelet is posting ready status</span><br></pre></td></tr></table></figure><p><br></p><p><strong>容量</strong><br>描述节点上的可用资源：CPU，内存，可调度到节点上的最大pods数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node/salt01</span><br><span class="line">Capacity:</span><br><span class="line"> cpu:                2</span><br><span class="line"> ephemeral-storage:  49250820Ki</span><br><span class="line"> hugepages-2Mi:      0</span><br><span class="line"> memory:             3881332Ki</span><br><span class="line"> pods:               110</span><br></pre></td></tr></table></figure><p><br></p><p><strong>信息</strong><br>关于节点的一般信息，如Kernel版本，Kubernetes版本，Docker版本，OS…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node/salt01</span><br><span class="line">System Info:</span><br><span class="line"> Machine ID:                 e48d6bf22f9b4c8da5cb1a07b2fec730</span><br><span class="line"> System UUID:                564D1413-905B-64D6-E9A2-92E37F9B5BDA</span><br><span class="line"> Boot ID:                    1df89a81-77a4-44a0-9241-e6d766795e32</span><br><span class="line"> Kernel Version:             3.10.0-862.9.1.el7.x86_64</span><br><span class="line"> OS Image:                   CentOS Linux 7 (Core)</span><br><span class="line"> Operating System:           linux</span><br><span class="line"> Architecture:               amd64</span><br><span class="line"> Container Runtime Version:  docker://1.13.1</span><br><span class="line"> Kubelet Version:            v1.11.1</span><br><span class="line"> Kube-Proxy Version:         v1.11.1</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h4><p>Management</p><p>与Pod与Service不同，k8s本身并不创建节点： 它由云服务商创建，或存在于物理机/虚拟机的pool中。<br>当k8s创建节点时，它实际上只是创建了一个表示节点的对象。创建之后，k8s将检查节点是否有效。</p><p>栗子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"kind"</span>: <span class="string">"Node"</span>,</span><br><span class="line">  <span class="attr">"apiVersion"</span>: <span class="string">"v1"</span>,</span><br><span class="line">  <span class="attr">"metadata"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"10.240.79.157"</span>,</span><br><span class="line">    <span class="attr">"labels"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"my-first-k8s-node"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>k8s将在内部创建节点对象，并通过基于<code>metadata.name</code>字段的运行状况检查来验证节点。<br>如果节点有效(valid)，即所有必要的服务都已运行，它就符合了运行pod的条件。否则它将被所有的集群动作忽略，直到它变为有效。请注意，Kubernetes将保持无效(invalide)节点的对象，除非它被手动删除。Kubernetes将持续检查节点是否变得可用。</p><p>目前，有3个组件与k8s节点接口交互：</p><ul><li>Node Controller</li><li>kubelet</li><li>kubectl</li></ul><p><br></p><p><strong>节点控制器</strong><br>节点控制器是一个k8s Master组件，用于管理节点的各个方面。</p><p>节点控制器在节点的生命周期中具有多个角色(role)。第一个便是在节点注册时为其分配CIDR地址块。<br>第二个是使节点控制器的内部节点列表与可用机器保持一致。只要节点不健康，节点控制器就会询问该节点是否仍然可用。如果不是，则节点控制器从其节点列表中删除该节点。<br>第三个是监控节点的健康状况。当节点不可达时，节点控制器负责更新节点的条件(condition)状态，从<code>Ready</code>变为<code>Unknown</code>。如果节点继续无法访问，则稍后从节点中驱逐(evict)所有pod(graceful termination)。默认超时时间为40s开始上报<code>Unknown</code>，然后5min之后开始驱逐pods。节点控制器通过<code>--node-nonitor-period</code>秒检查每个节点的状态。</p><p>在大多数情况下，节点控制器将驱逐率(evication rate)限制为<code>--node-eviction-rate</code>(默认值 0.1)每秒。这意味着它将不会每10s从超过1个节点驱逐pod。</p><p>当给定可用区域中的节点变得不健康时，节点驱逐行为会发生变化。同时，节点控制器检查此区域中不健康节点的百分比。<br>如果节点不健康比例至少为<code>--unhealthy-zone-threshold</code>(默认值 0.55)，那么驱逐率会降低；<br>如果集群很小，小于或等于<code>--large-cluster-size-threshold</code>(默认值 50)，则停止驱逐；<br>否则，驱逐率减小到每秒<code>--secondary-node-eviction-rate</code>(默认值 0.01)。<br>每个可用区域实施这些策略的原因是，一个可用区域可能与其它可用区域保持连接。</p><p>在可用区域之间传播节点的一个关键原因是，当整个区域出现故障时，工作负载可以转移到健康区域。因此，如果区域中的全部节点都不健康，则节点控制器以正常速率<code>--node-eviction-rate</code>驱逐。<br>The corner case是当所有区域都不健康时。在这种情况下，节点控制器假定Master连接存在一些问题，并在某些连接恢复之前停止所有驱逐。</p><p><br></p><p><strong>节点自注册</strong><br>Self-Registration of Nodes</p><p>当<code>kubelet</code>标志<code>--register-node</code>为true(默认)时，它会尝试向API server注册自己。这是大多数发行版使用的首选模式。</p><p>对于自注册，kubelet使用如下选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#向API server验证自身的凭据路径</span><br><span class="line">--kubeconfig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#r如何与云服务商交流</span><br><span class="line">--cloud-provider</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#向API server自动注册</span><br><span class="line">--register-node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#节点IP地址</span><br><span class="line">--node-ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#集群中注册节点时要添加的标签</span><br><span class="line">--node-labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定kubelet将节点状态发送到master的频率</span><br><span class="line">--node-status-update-frequency</span><br></pre></td></tr></table></figure><p>目前，任何kubelet都有权 create/modify 任何节点资源，但实际上它只 创建/修改 自己的节点资源。(将来，k8s打算只允许kubelet修改自己的节点资源)</p><p><strong>手动管理节点</strong></p><p>如果希望手动创建节点对象，请设置<code>kubelet</code>标志<code>--register-node=false</code>。<br>修改包括在节点上设置标签(label)并将其标记为不可调度(unschedulable)。</p><p><br></p><p><strong>节点容量</strong><br>Node Capacity</p><p>节点容量(cpu, memory)是节点对象的一部分。通常，当创建节点对象时，节点注册自己并上报其容量。如果是手动管理节点，则需要你在添加节点时设置节点容量。<br>k8s调度器确保节点上的所有pod都有足够的资源。它检查节点上容器请求的总和不大于节点容量。它包括由kubelet启动的所有容器，但不包括由容器运行时直接启动的容器，也不包括容器外部的任何进程。所以，尽量不要在k8s集群节点上运行额外进程。</p><p>如果要为<code>non-pod</code>进程保留资源，你可以创建保留(placeholder)pod。将内存和CPU的值设置为要保留的资源量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">resource-reserver</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">sleep-forever</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8s.gcr.io/pause:0.8.0</span></span><br><span class="line"><span class="attr">  - resources:</span></span><br><span class="line"><span class="attr">      requests:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">memory:</span> <span class="number">100</span><span class="string">Mi</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="API对象"><a href="#API对象" class="headerlink" title="API对象"></a>API对象</h4><p>Node is a top-level resource in the Kubernetes REST API.</p><p><br><br><br></p><h3 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h3><p>Master-Node communication</p><p>Master(APIserver)与k8s cluster之间的通信。<br>目的是允许用户自定义其安装以强化网络配置，以便集群可在不受信任的网络上运行。</p><p><br></p><h4 id="Cluster-gt-Master"><a href="#Cluster-gt-Master" class="headerlink" title="Cluster-&gt;Master"></a>Cluster-&gt;Master</h4><p>从Cluster到Master的所有通信路径都终止于API server。在典型部署中，API server配置为在安全的HTTPS(443)端口上监听远程连接，并启用一种或多种形式的Client认证。<br>应该为节点配置集群的公共根证书，以便他们可以使用有效证书安全地连接到API server。<br>希望连接到API server的Pod可以利用Service Account安全地执行此操作，这样k8s在实例化时自动将公共根证书和有效bearer token注入到Pod中。<code>the kubernetes service</code>配置了一个虚拟IP地址，该地址被重定向到API server的HTTPS endpoint。<br>Master组件还通过安全端口与Cluster API server通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get service</span><br><span class="line">NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)                         AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1     &lt;none&gt;        443/TCP                         8d</span><br></pre></td></tr></table></figure><p>因此，默认情况下，从Cluster到Master的连接的默认操作模式是安全的，可在不受信任网络/公共网络上运行。</p><p><br><br><br></p><h4 id="Master-gt-Cluster"><a href="#Master-gt-Cluster" class="headerlink" title="Master-&gt;Cluster"></a>Master-&gt;Cluster</h4><p>从Master(API server)到Cluster有两条主要通信路径：</p><ul><li>API server <code>-&gt;</code> kubelet</li><li>API server <code>-&gt;</code> node, pod, service</li></ul><p><br></p><p><strong>API server -&gt; kubelet</strong><br>从API server到kubelet(它运行在集群中的每个节点上)。</p><p>从API server到kubelet的连接用于：</p><ul><li>获取Pod的日志</li><li>附加到运行的Pod</li><li>提供kubelet的端口转发功能</li></ul><p>这些连接终止于kubelet的HTTPS endpoint。默认情况下，API server不会验证kubelet的证书，这会使连接可能受到中间人工具，并且不安全地运行在不受信任/公共的网络上。<br>要验证此连接，使用<code>--kubelet-certificate-authority</code>标志位API server提供根证书，用于验证kubelet的证书。</p><p>如果无法做到，请在API server和kubelet之间使用SSH隧道保障连接安全。</p><p><br></p><p><strong>API server -&gt; node, pod, service</strong><br>从API server到node, pod, service的连接默认为纯HTTP，因此既不需要认证也未加密。他们可以通过在API URI的前缀使用<a href="https://" target="_blank" rel="noopener">https://</a>来运行安全的HTTPS，但他们不会验证HTTPS endpoint提供的证书，也不会提供客户端凭据。因此连接将被加密，它不会提供任何完整性保证。</p><p><br><br><br></p><h3 id="云控制器管理器"><a href="#云控制器管理器" class="headerlink" title="云控制器管理器"></a>云控制器管理器</h3><p>Cloud Controller Manager</p><p>暂时跳过！</p><p><br><br><br><br><br></p><h2 id="扩展k8s"><a href="#扩展k8s" class="headerlink" title="扩展k8s"></a>扩展k8s</h2><p><br></p><h3 id="扩展k8s集群"><a href="#扩展k8s集群" class="headerlink" title="扩展k8s集群"></a>扩展k8s集群</h3><p>Extending your Kubernetes Cluster</p><p>k8s具有高度可配置化和可扩展化。</p><p>定制方法可大致分为配置，只涉及更改标志，本地配置文件或API资源；扩展，设计运行其它程序或服务。</p><p><br></p><h4 id="扩展模式"><a href="#扩展模式" class="headerlink" title="扩展模式"></a>扩展模式</h4><p>Extensions Patterns</p><p>k8s旨在通过编写客户端程序实现自动化。任意 read/write k8s API的程序都可以提供有用的自动化。自动化可在集群上启用或关闭。自动化通常适用于k8s集群，包括托管集群和管理安装。</p><p>有一种编写与k8s一起使用的称为控制器模式(Controller Pattern)客户端程序的特定模式。控制器通常读取对象的<code>.spec</code>，可能做些事情，然后更新对象的<code>.status</code>。<br>控制器(Controller)是一个k8s client。当k8s为client并调用远程服务时，它被称为<code>Webhook</code>。远程服务被称为<code>Webhook Backend</code>。与控制器一样，<code>Webhook</code>确实增加了一个失败点。</p><p>在webhook模式中，k8s 向远程服务发出网络请求。在二进制插件模型中，k8s执行二进制程序。二进制插件由kubelet和kubectl使用。</p><p><img src="/images/K8s/k8s_extensions.png" alt="k8s扩展"></p><p><br></p><h4 id="扩展点"><a href="#扩展点" class="headerlink" title="扩展点"></a>扩展点</h4><p>Extension Points</p><p>k8s 系统的扩展点:</p><p><img src="/images/K8s/k8s_extension_points.png" alt="k8s 扩展点"></p><p><br></p><ol><li>用户使用<code>kubectl</code>与k8s API进行交互</li><li>API server处理所有请求</li><li>API server提供各种资源</li><li>k8s调度器决定将pod放在哪个节点上</li><li>k8s大部分行为都是由控制器实现的</li><li>kubelet帮助pod在集群网络上显示为具有自己IP的虚拟服务</li><li>kubelet还可挂载和解挂容器的卷</li></ol><p><br></p><p>如果你不确定如何开始，查看如下流程图：</p><p><img src="/images/K8s/k8s_extensions_start.png" alt=""></p><p><br></p><h4 id="API扩展"><a href="#API扩展" class="headerlink" title="API扩展"></a>API扩展</h4><p>API Extensions</p><p><br></p><p><strong>User-Defined Types</strong><br>如果想要定义新的控制器、应用程序配置对象、声明性API并管理他们，请考虑向k8s添加自定义资源。<br>不要讲自定义资源用作应用程序、用户、监控数据的数据存储。</p><p><br></p><p><strong>Combining New APIs with Automation</strong><br>通常，当添加新API时，还会添加一个 read/write 新API的控制循环。当自定义API和控制循环的组合用于管理特定的，通常是有状态的应用程序时，这被称为操作者模式(Operator Pattern)。</p><p><br></p><p><strong>Changing Built-in Resources</strong><br>通过自定义资源添加扩展k8s API时，添加的资源始终属于新的API组。你无法替换或修改已经存在的API组。添加API不会直接影响现有API的行为，但API Access Extensions会影响现有API的行为。</p><p><br></p><p><strong>API Access Extensions</strong><br>当请求到达k8s API server时，它首先进行身份验证，然后授权，然后进行各种准入控制。每个步骤都提供了扩展点。</p><p><br></p><p><strong>Authentication</strong><br>身份验证将所有请求中的Header或证书映射到发出请求的客户端的用户名中。</p><p><br></p><p><strong>Authorization</strong><br>授权确定特定用户是否可以对API资源进行读写和其它操作。它只是在整个资源的层面上工作，不基于任意对象字段进行区分。</p><p><br></p><p><strong>Dynamic Admission Control</strong><br>当请求授权之后，如果它是一个写操作，它还需要通过<code>Admission Control</code>步骤。除了内建步骤之外，还有其它扩展：</p><ul><li><code>Image Policy webhook</code>限制可在容器中运行的镜像</li><li>为了做出任意的<code>admission control</code>决策，可使用普通<code>admission webhook</code></li><li>初始化程序可在创建对象之前修改对象的控制器</li></ul><p><br></p><h4 id="基础设施扩展"><a href="#基础设施扩展" class="headerlink" title="基础设施扩展"></a>基础设施扩展</h4><p>Infrastructure Extensions</p><p><br></p><p><strong>Storage Plugins</strong><br><code>Flex Volumes</code>允许用户通过<code>kubelet</code>调用二进制插件来安装卷，来安装没有内置支持的卷类型</p><p><br></p><p><strong>Device Plugins</strong><br>设备插件允许节点通过设备发现插件发现新的节点资源</p><p><br></p><p><strong>Network Plugins</strong><br>支持不同的网络结构</p><p><br></p><p><strong>Scheduler Extensions</strong><br>调度器是一种特殊类型的控制器，用于监视Pod，并将Pod分配给节点。</p><p><br><br><br></p><h3 id="扩展k8s-API"><a href="#扩展k8s-API" class="headerlink" title="扩展k8s API"></a>扩展k8s API</h3><p>Extending the Kubernetes API</p><p><br></p><h4 id="在聚合层扩展k8s-API"><a href="#在聚合层扩展k8s-API" class="headerlink" title="在聚合层扩展k8s API"></a>在聚合层扩展k8s API</h4><p>Extending the Kubernetes API with the aggregation layer</p><p>聚合层允许在集群中安装其它k8s-style的API。</p><p><br></p><h4 id="自定义资源"><a href="#自定义资源" class="headerlink" title="自定义资源"></a>自定义资源</h4><p>Custom Resources</p><p>自定义资源是k8s API的扩展，包括何时向k8s集群添加自定义资源以及何时使用独立服务。</p><p>资源是k8s API中的端点(endpoint)，用于存储某种API对象的集合。如，内建的pods资源包含了Pod对象的集合。<br>自定义资源是k8s API的扩展，不一定在每个k8s集群上都可用。换句话说，它代表了特定k8s的定制安装。<br>自定义资源可通过动态注册在正在运行的集群中出现和消失，集群管理员可独立于集群本身更新自定义资源。安装自定义资源后，用户可使用<code>kubectl</code>创建和访问其对象。</p><p><br></p><p>Custom controllers</p><p>自定义字段本身可让你存储和检索结构化数据。只有与控制器结合使用才能成为真正的声明性API。declare API允许你声明或指定资源的所需状态，并尝试将实际状态与此期望状态相匹配。这里，控制器将结构化的数据解释为用户期望状态的记录，并且不断采取行动以实现和维护该状态。<br>自定义控制器是一种用户可在正在运行的集群上进行部署和更新，而与集群自身的生命周期无关的控制器。自定义控制器可使用任何类型的资源，但与自定义资源结合使用时，它们更有效。</p><p><br></p><p>Should I add a custom resource to my Kubernetes Cluster?</p><p>当创建新的API时，考虑是使用k8s cluster API还是让API独立运行。</p><table><thead><tr><th>Consider API aggregation if:</th><th>Prefer a stand-alone API if:</th></tr></thead><tbody><tr><td>Your API is Declarative.</td><td>Your API does not fit the Declarative model.</td></tr><tr><td>You want your new types to be readable and writable using kubectl.</td><td>kubectl support is not required</td></tr><tr><td>You want to view your new types in a Kubernetes UI, such as dashboard, alongside built-in types.</td><td>Kubernetes UI support is not required.</td></tr><tr><td>You are developing a new API.</td><td>You already have a program that serves your API and works well.</td></tr><tr><td>You are willing to accept the format restriction that Kubernetes puts on REST resource paths, such as API Groups and Namespaces. (See the API Overview.)</td><td>You need to have specific REST paths to be compatible with an already defined REST API.</td></tr><tr><td>Your resources are naturally scoped to a cluster or to namespaces of a cluster.</td><td>Cluster or namespace scoped resources are a poor fit; you need control over the specifics of resource paths.</td></tr><tr><td>You want to reuse Kubernetes API support features.</td><td>You don’t need those features</td></tr></tbody></table><p><br></p><p><strong>声明性API</strong><br>Declarative APIs</p><p>在一个声明性API中，通常：</p><ul><li>你的API由相对较少的相对较小的对象组成</li><li>应用程序或基础结构的对象定义配置</li><li>对象很少更新</li><li>人们通常需要读写对象</li><li>对象的主要操作时CRUD</li><li>跨对象的事务不是必需的：API表示期望状态，而不是精确的状态</li></ul><p>imperative API不是声明性的，你的API可能不是声明性的标志包括：</p><ul><li>客户端说执行此操作，完成后获得同步响应</li><li>客户端说执行此操作，然后获取操作ID，并且必须检查单独的Operation对象以确定请求的完成</li><li>谈论Remote Procedure Calls(RPCs)</li><li>直接存储大量数据</li><li>需要高带宽访问</li><li>存储最终用户数据，或应用程序处理的其它大规模数据</li><li>对象非CRUD的自然操作</li><li>API不容易建模为对象</li><li>使用操作ID或操作对象表示挂起的操作</li></ul><p><br></p><p>Should I use a configMap or a custom resource?</p><p>如果符合以下任意条件，请使用ConfigMap:</p><ul><li>存在现有的，记录完备的配置文件格式</li><li>你希望将整个配置文件放入ConfigMap的一个key中</li><li>配置文件的主要用途是在集群上的Pod中运行的程序使用该文件来配置自身</li><li>文件的消费者更喜欢使用Pod中的文件或环境变量，而不是k8s API</li><li>你希望在文件更新时通过部署执行滚动升级</li></ul><p>如果符合以下大部分情况，请使用自定义资源：</p><ul><li>你希望使用k8s client library和CLI来创建和更新新资源</li><li>你希望来自<code>kubectl</code>的顶级支持</li><li>你希望构建新的自动化，监视新对象的更新，然后CRUD其它对象</li><li>你希望编写处理对象更新的自动化</li><li>你希望使用k8s API约定，如<code>.spec, .status, .metadata</code></li><li>你希望对象是受控资源集合的抽象，或其它资源的汇总</li></ul><p><br></p><p><strong>添加自定义资源</strong><br>k8s提供了两种方式来向你的集群中添加自定义资源：</p><ul><li>CRD很简单，无需任何编程即可创建</li><li>API聚合需要编程，但允许更多控制API行为，如数据的存储方式和API版本间的转换</li></ul><p>聚合API是位于主API server后面的从属API server，它充当代理。这种安排称为API聚合(AA, API Aggregation)。<br>CRD允许用户添加新类型的资源，而无需添加其它API server，你无需了解API聚合即可使用CRD。<br>无论如何安装，新资源都成为自定义资源，以区别于内置的k8s 资源。</p><p><br></p><p><strong>自定义资源定义</strong><br>自定义资源定义 API资源允许你去定义自定义资源。定义CRD对象会创建一个新的自定义资源，其中包含指定的名称和架构。k8s API提供并处理自定义资源的存储。<br>这使你无需编写自己的API server来处理自定义资源，但实现的一般特性意味着你的灵活性低于API server聚合。</p><p><br></p><p><strong>API server aggregation</strong><br>通常，k8s API中的每个资源都需要处理REST 请求的代码并管理对象的持久化存储。k8s API server处理pod等内建资源，还可通过CRD处理自定义资源。<br>聚合层允许你通过编写和部署自己的独立API server为自定义资源提供专门的实现。API server将请求委托给你处理的自定义资源，使其对所有客户端可用。</p><p>为添加自定义资源选择一个方法<br>通常情况下，CRD很适合，如果：</p><ul><li>你有少数几个领域</li><li>你正在使用公司内的资源，或作为小型开源项目的一部分</li></ul><p><br></p><p>易用性比较：</p><table><thead><tr><th>CRDs</th><th>Aggregated API</th></tr></thead><tbody><tr><td>Do not require programming. Users can choose any language for a CRD controller.</td><td>Requires programming in Go and building binary and image. Users can choose any language for a CRD controller.</td></tr><tr><td>No additional service to run; CRs are handled by API Server.</td><td>An additional service to create and that could fail.</td></tr><tr><td>No ongoing support once the CRD is created. Any bug fixes are picked up as part of normal Kubernetes Master upgrades.</td><td>May need to periodically pickup bug fixes from upstream and rebuild and update the Aggregated APIserver.</td></tr><tr><td>No need to handle multiple versions of your API. For example: when you control the client for this resource, you can upgrade it in sync with the API.</td><td>You need to handle multiple versions of your API, for example: when developing an extension to share with the world.</td></tr></tbody></table><p><br></p><p>高级功能和灵活性：</p><table><thead><tr><th>Feature</th><th>Description</th><th>CRDs</th><th>Aggregated API</th></tr></thead><tbody><tr><td>Validation</td><td>Help users prevent errors and allow you to evolve your API independently of your clients. These features are most useful when there are many clients who can’t all update at the same time.</td><td>Yes. Most validation can be specified in the CRD using OpenAPI v3.0 validation. Any other validations supported by addition of a Validating Webhook.</td><td>Yes, arbitrary validation checks</td></tr><tr><td>Defaulting</td><td>See above</td><td>Yes, via a Mutating Webhook; Planned, via CRD OpenAPI schema.</td><td>Yes</td></tr><tr><td>Multi-versioning</td><td>Allows serving the same object through two API versions. Can help ease API changes like renaming fields. Less important if you control your client versions.</td><td>No, but planned</td><td>Yes</td></tr><tr><td>Custom Storage</td><td>If you need storage with a different performance mode (for example, time-series database instead of key-value store) or isolation for security (for example, encryption secrets or different</td><td>No</td><td>Yes</td></tr><tr><td>Custom Business Logic</td><td>Perform arbitrary checks or actions when creating, reading, updating or deleting an object</td><td>Yes, using Webhooks.</td><td>Yes</td></tr><tr><td>Scale Subresource</td><td>Allows systems like HorizontalPodAutoscaler and PodDisruptionBudget interact with your new resource</td><td>Yes</td><td>Yes</td></tr><tr><td>Status Subresource</td><td></td></tr><tr><td>Finer-grained access control: user writes spec section, controller writes status section.</td></tr><tr><td>Allows incrementing object Generation on custom resource data mutation (requires separate spec and status sections in the resource)</td></tr><tr><td>Yes</td><td>Yes</td></tr><tr><td>Other Subresources</td><td>Add operations other than CRUD, such as “logs” or “exec”.</td><td>No</td><td>Yes</td></tr><tr><td>strategic-merge-patch</td><td>The new endpoints support PATCH with Content-Type: application/strategic-merge-patch+json. Useful for updating objects that may be modified both locally, and by the server. For more information, see “Update API Objects in Place Using kubectl patch”</td><td>No, but similar functionality planned</td><td>Yes</td></tr><tr><td>Protocol Buffers</td><td>The new resource supports clients that want to use Protocol Buffers</td><td>No</td><td>Yes</td></tr><tr><td>OpenAPI Schema</td><td>Is there an OpenAPI (swagger) schema for the types that can be dynamically fetched from the server? Is the user protected from misspelling field names by ensuring only allowed fields are set? Are types enforced (in other words, don’t put an int in a string field?)</td><td>No, but planned</td><td>Yes</td></tr></tbody></table><p><br></p><p>一般功能：</p><table><thead><tr><th>Feature</th><th>What it does</th></tr></thead><tbody><tr><td>CRUD</td><td>The new endpoints support CRUD basic operations via HTTP and kubectl</td></tr><tr><td>Watch</td><td>The new endpoints support Kubernetes Watch operations via HTTP</td></tr><tr><td>Discovery</td><td>Clients like kubectl and dashboard automatically offer list, display, and field edit operations on your resources</td></tr><tr><td>json-patch</td><td>The new endpoints support PATCH with Content-Type: application/json-patch+json</td></tr><tr><td>merge-patch</td><td>The new endpoints support PATCH with Content-Type: application/merge-patch+json</td></tr><tr><td>HTTPS</td><td>The new endpoints uses HTTPS</td></tr><tr><td>Built-in Authentication</td><td>Access to the extension uses the core apiserver (aggregation layer) for authentication</td></tr><tr><td>Built-in Authorization</td><td>Access to the extension can reuse the authorization used by the core apiserver (e.g. RBAC)</td></tr><tr><td>Finalizers</td><td>Block deletion of extension resources until external cleanup happens.</td></tr><tr><td>Admission Webhooks</td><td>Set default values and validate extension resources during any create/update/delete operation.</td></tr><tr><td>UI/CLI Display</td><td>Kubectl, dashboard can display extension resources.</td></tr><tr><td>Unset vs Empty</td><td>Clients can distinguish unset fields from zero-valued fields.</td></tr><tr><td>Client Libraries Generation</td><td>Kubernetes provides generic client libraries, as well as tools to generate type-specific client libraries.</td></tr><tr><td>Labels and annotations</td><td>Common metadata across objects that tools know how to edit for core and custom resources</td></tr></tbody></table><p><br></p><p><strong>安装自定义资源</strong><br>在向集群添加自定义资源之前，需要注意几点</p><ul><li>第三方代码和新的失败点</li><li>存储</li><li>认证，授权，审计</li></ul><p><br></p><p><strong>访问自定义资源</strong><br>k8s client library可用于访问自定义资源。并非所有client library都支持自定义资源，但go和python client library可以。</p><p>当你添加一个自定义资源时，你可以使用如下方式访问：</p><ul><li>kubectl</li><li>k8s dynamic client</li><li>REST client</li><li>由k8s client 生成工具生成的client</li></ul><p><br><br><br></p><h3 id="计算，存储和网络插件"><a href="#计算，存储和网络插件" class="headerlink" title="计算，存储和网络插件"></a>计算，存储和网络插件</h3><p>Compute, Storage, and Networking Extensions</p><p><br></p><h4 id="网络插件"><a href="#网络插件" class="headerlink" title="网络插件"></a>网络插件</h4><p>Network Plugins</p><blockquote><p>Notice:<br>FEATURE STATE: Kubernetes v1.11 alpha<br>Alpha features change rapidly</p></blockquote><p>k8s中的网络插件有几种风格：</p><ul><li>CNI plugins: 遵守appc/CNI规范，旨在实现互操作性</li><li>Kubenet plugin: 使用<code>bridge</code>和<code>host-local</code> CNI plugins实现基本的<code>cbr0</code></li></ul><p><br></p><p><strong>安装</strong><br>kubelet有一个默认的网络插件，以及整个集群的默认网络。它在启动时探测插件，记住它找到的内容，并在pod声明周期中的适当时间执行所选插件。<br>使用插件时，请记住两个<code>kubelet</code>命令行参数：</p><ul><li><code>cni-bin-dir</code>: kubelet在启动时检测此目录以获取插件</li><li><code>network-plugin</code>： 从<code>cni-bin-dir</code>使用的网络插件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep kubelet</span><br><span class="line"></span><br><span class="line">/usr/bin/kubelet xxx --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --network-plugin=cni</span><br></pre></td></tr></table></figure><p><br></p><p><strong>网络插件需求</strong><br>除了提供网络插件接口来配置和清理pod网络外，该插件还可能需要对kube-proxy提供特定支持。iptables proxy依赖于iptables，插件可能需要确保容器流量可用于iptables。<br>默认情况下，如果未指定kubelet网络插件，则使用noop插件，它设置<code>net/bridge-nf-call-iptables=1</code>来确保简单配置与iptables proxy正常工作。</p><p><strong>CNI</strong><br>通过kubelet传递<code>--network-plugin=cni</code>选项来选择CNI插件。kubelet从<code>cni-conf-dir</code>(默认<code>/etc/cni/net.d</code>)中读取文件，并使用该文件中的CNI配置来设置每个pod的网络。引用的插件必须存在于<code>--cni-bin-dir</code>(默认<code>/opt/cni/bin</code>)中。<br>如果目录中有多个CNI配置文件，则使用文件名的词典顺序的第一个。<br>除了配置文件指定的CNI插件外，k8s还需要标准的CNI lo插件(loopback)，最低版本 v0.2.0</p><p><strong>kubenet</strong><br>kubelet是一个仅使用与Linux的基本和简单的网络插件。它本身并不实现高级的功能，如跨节点网络或网络策略。kubenet创建一个名为<code>cbr0</code>的Linux bridge，并为每个pod创建一个<code>veth</code>对，每对的主机端连接到连接到<code>cbr0</code>。通过配置或控制器管理器为该对的pod端分配范围内的IP地址。为cbr0分配一个MTU，该MTU与主机上启用的普通接口的最小MTU相匹配。</p><p>此插件需要一些东西：</p><ul><li>需要标准的CNI <code>bridge</code>, <code>lo</code>, <code>host-local</code>插件，最小版本 v0.2.0。首先从<code>/opt/cni/bin</code>查找。</li><li>kubelet必须使用<code>--network-plugin=kubenet</code>参数来启用此插件</li><li>kubelet应该指定<code>--non-masquerade-cidr=&lt;clusterCidr&gt;</code>参数确保超出范围的IP流量将使用IP masquerade。</li><li>必须通过kubelet的<code>--pod-cidr</code>选项或控制器管理器的<code>--allocate-node-cidrs=true --cluster-cidr=&lt;cidr&gt;</code>选项来为节点分配IP子网</li></ul><p><strong>自定义MTU(kubenet)</strong><br>应该始终正确配置MTU以获得最佳网络性能。网络插件通常会推断合理的MTU，但有时不会产生最佳的MTU。<br>如果需要，你可使用kubenet的<code>network-plugin-mtu</code>选项来明确指定MTU，仅有kubenet插件支持此选项。</p><p><br></p><p><strong>使用摘要</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--network-plugin=cni</span><br><span class="line">--network-plugin=kubenet</span><br><span class="line">--network-plugin-mtu=9001</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="设备插件"><a href="#设备插件" class="headerlink" title="设备插件"></a>设备插件</h4><p>Device Plugins</p><p>从v1.8开始，k8s为Vendors提供了设备插件框架，以便在不更改k8s核心代码的情况下将资源通知到kubelet，Vendor可实现手动部署或作为DaemonSet部署的设备插件，而不是编写自定义的k8s插件。目标设备包括GPU，高性能NIC， FPGA， InfiniBand和其它计算资源。</p><p><br></p><p><strong>设备插件注册</strong><br>设备插件功能由<code>DevicePlugins</code>功能控制，默认在 v1.10之前禁用。当启用设备插件功能，kubelet将导出Registration gRPC服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service Registration &#123;</span><br><span class="line">  rpc Register(RegisterRequest) returns (Empty) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设备插件可通过gRPC服务向kubelet注册自己。在注册中，它需要发送：</p><ul><li>Unix socket名</li><li>设备插件API版本</li><li>想要告知的ResourceName</li></ul><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: demo-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: demo-container-1</span><br><span class="line">      image: k8s.gcr.io/pause:2.0</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          vendor-domain/resource: 2 # requesting 2 vendor-domain/resource</span><br></pre></td></tr></table></figure><p><br></p><p><strong>设备插件实现</strong><br>设备插件的一般工作流包括如下步骤：</p><ul><li>初始化</li><li>插件启动gRPC服务</li><li>插件使用kubelet的Unix socket注册自己</li><li>注册成功之后，设备插件以服务模式运行，在此期间，它会持续监控设备运行状况，并在任何设备状况发生变化时向kubelet报告</li></ul><p><br></p><p><strong>设备插件部署</strong><br>设备插件可手动或作为DaemonSet来部署。<br>k8s 设备插件的支持人处于alpha状态。</p><p><br><br><br></p><h3 id="服务目录"><a href="#服务目录" class="headerlink" title="服务目录"></a>服务目录</h3><p>Service Catalog</p><p>服务目录是一种扩展API，它使在k8s集群中运行的应用程序能够轻松使用外部托管软件。<br>它提供了从Service Broker 列出，配置和绑定外部托管服务的方法，而无需详细了解如何创建或管理这些服务。<br>使用服务目录，集群操作人员可以浏览服务代理提供的托管服务列表，配置托管服务的实例，并与其绑定以使其可供k8s集群中应用程序使用。</p><p><br><br><br><br><br></p><h2 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h2><p><br></p><h3 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h3><p>你创建Docker image并将其push到registry，然后在k8s pod中引用它。<br>容器的镜像属性支持与Docker命令相同的语法，包括私有注册表和标记。</p><p><br></p><p><strong>更新镜像</strong><br>默认的拉取策略是<code>ifNotPresent</code>，这会导致kubelet跳过拉取镜像(如果镜像已存在)。所以在网络不好时，我们可以首先将镜像拉取下来。<br>如果你总想强制拉取镜像，可以执行如下操作：</p><ul><li>设置容器<code>imagePullPolicy</code>为<code>Always</code></li><li>使用<code>:latest</code>作为镜像的标记</li><li>启用<code>AlwaysPullImages</code>准入控制器</li></ul><p>如果没有对镜像指定标记，则假定为<code>:latest</code>标记。</p><p><br></p><p><strong>使用私有注册表</strong><br>Using a Private Registry</p><p>私有注册表有：</p><ul><li>Docker Hub</li><li>Aliyun</li><li>Tencent yun</li><li>Google Container Registry</li><li>AWS Container Registry</li><li>Azure Container Registry</li><li>…</li></ul><p>以下是配置节点已使用私有注册表的推荐步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1. 运行 docker login</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 查看 ~/.docker/config.json</span><br><span class="line">&#123;</span><br><span class="line">        &quot;auths&quot;: &#123;</span><br><span class="line">                &quot;https://index.docker.io/v1/&quot;: &#123;</span><br><span class="line">                        &quot;auth&quot;: &quot;xxxxxxxxxxxxxxx&quot;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;HttpHeaders&quot;: &#123;</span><br><span class="line">                &quot;User-Agent&quot;: &quot;Docker-Client/18.03.1-ce (linux)&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 获取节点列表</span><br><span class="line">#name</span><br><span class="line">nodes=$(kubectl get nodes -o jsonpath=&apos;&#123;range.items[*].metadata&#125;&#123;.name&#125; &#123;end&#125;&apos;)</span><br><span class="line"></span><br><span class="line">#IPs</span><br><span class="line">nodes=$(kubectl get nodes -o jsonpath=&apos;&#123;range .items[*].status.addresses[?(@.type==&quot;ExternalIP&quot;)]&#125;&#123;.address&#125; &#123;end&#125;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 复制 .docker/config.json 到上面的搜索路径列表</span><br><span class="line"></span><br><span class="line">for n in $nodes; do scp ~/.docker/config.json root@$n:/var/lib/kubelet/config.json; done</span><br></pre></td></tr></table></figure><p><br></p><p>通过创建pod来验证私有镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f - &lt;&lt;EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: private-image-test-1</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: uses-private-image</span><br><span class="line">      image: $PRIVATE_IMAGE_NAME</span><br><span class="line">      imagePullPolicy: Always</span><br><span class="line">      command: [ &quot;echo&quot;, &quot;SUCCESS&quot; ]</span><br><span class="line">EOF</span><br><span class="line">pod &quot;private-image-test-1&quot; created</span><br></pre></td></tr></table></figure><p><br></p><p><strong>预拉取镜像</strong><br>Pre-pulling Images</p><p>默认情况下，kubelet将尝试从指定的注册表中拉取镜像。但是，如果容器的<code>imagePullPolicy</code>属性为<code>ifNotPresent</code>或<code>Never</code>，则会使用本地镜像。<br>如果你希望依赖于预先拉取的镜像作为注册表身份验证的替代，则必须确保集群中的所有节点都具有相同的预拉取镜像。<br>这可以用于预加载某些镜像以提高速度，或者作为对私有注册表进行身份认证的替代方法。<br>请确保所有的pods都对预拉取的镜像由访问权限。</p><p><br></p><p><strong>Specifying ImagePullSecrets on a Pod</strong><br>k8s支持在pod上指定registry keys。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#使用Docker config创建secret</span><br><span class="line">kubectl create secret docker-registry -h</span><br><span class="line">#Create a new secret for use with Docker registries.</span><br><span class="line"></span><br><span class="line">kubectl create secret docker-registry zhang21-secret --docker-server=DOCKER_REGISTRY_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL</span><br><span class="line">secret &quot;myregistrykey&quot; created.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl get secret</span><br><span class="line">NAME                  TYPE                                  DATA      AGE</span><br><span class="line">zhang21-secret        kubernetes.io/dockerconfigjson        1         22s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看和修改</span><br><span class="line">kubectl edit secret/zhang21-secret</span><br></pre></td></tr></table></figure><p>如果需要访问多个注册表，你可以为每个注册表创建一个secret。当为pod来取镜像时，kubelet会将<code>imagePullSecret</code>合并到 一个虚拟的<code>.docker/config.json</code>文件中。<br>pod只能在自己的命名空间中引用image pull secret，因此每个命名空间都需要执行一次此过程。</p><p><br></p><p>pod上的imagePullSecret</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion:</span><br><span class="line">kind: Pod</span><br><span class="line">xxx</span><br><span class="line">spec:</span><br><span class="line">  container:</span><br><span class="line">    xxx</span><br><span class="line">  imagePullSecretes:</span><br><span class="line">    name: zhang21-secret</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="容器环境变量"><a href="#容器环境变量" class="headerlink" title="容器环境变量"></a>容器环境变量</h3><p>Container Environment Variables</p><p>k8s容器环境为容器提供了几个重要资源：</p><ul><li>文件系统(是镜像和卷的组合)</li><li>容器自身信息</li><li>集群中对象的信息</li></ul><p><br><br><br></p><h3 id="容器生命周期钩子"><a href="#容器生命周期钩子" class="headerlink" title="容器生命周期钩子"></a>容器生命周期钩子</h3><p>Container Lifecycle Hooks</p><p>本节描述了kubelet如何使用容器生命周期钩子框架来运行在管理生命周期中由事件触发的代码。<br>与许多具有组件生命周期钩子的编程语言框架类似，k8s为容器提供了生命周期钩子。钩子使容器能够了解其生命周期中的事件，并在执行相应的生命周期钩子时运行在处理程序中实现的代码。</p><p><br></p><h4 id="容器钩子"><a href="#容器钩子" class="headerlink" title="容器钩子"></a>容器钩子</h4><p>有两个公开给容器的钩子：</p><ul><li><p><strong>PostStart</strong><br>此钩子在容器创建后立即执行。但是，无法保证钩子将在容器<code>ENTRYPOINT</code>之前执行。没有参数传递给处理程序。</p></li><li><p><strong>PreStop</strong><br>此钩子在容器终止前立即调用。它是阻塞的，意味着它是同步的。所以它必须在调用删除容器之前完成才能发送。没有参数传递给处理程序。</p></li></ul><p><br></p><p><strong>Hook handler implementations</strong><br>容器可以通过实施和注册该钩子的处理程序来访问钩子。可为容器实施两种类型的钩子处理程序：</p><ul><li>Exec： 在cgroup和namespace内执行特定的命令</li><li>HTTP： 在容器的特定端点上执行一个HTTP请求</li></ul><p><br></p><p><strong>Hook handler exection</strong><br>调用容器生命周期管理钩子时，k8s管理系统会在为钩子注册的容器中执行处理程序。</p><p>钩子处理程序调用包含在容器的Pod的上下文中是同步的。这意味着对<strong>PostStart钩子</strong>，容器<code>ENTRYPOINT</code>和钩子异步启动。但是，如果钩子 运行/挂起 太长时间，则容器无法达到<code>running state</code>。<br><strong>PreStop钩子</strong>的行为类似。如果钩子在执行期间挂起，则pod阶段将保持在<code>Terminating state</code>，并在pod结束的<code>terminationGracePeriodSeconds</code>之后被杀掉。<br>如果<strong>PostStart</strong>或<strong>PreStop</strong>钩子失败，则会杀掉容器。</p><p>用户应该使他们的钩子处理程序尽可能的轻量化。</p><p><br></p><p><strong>Hook delivery guarantees</strong><br>钩子交付至少是一次，这意味着对于任何给定的事件可以多次调用钩子。由钩子实现来正确处理这个问题。<br>通常，只进行当次交付。在一些罕见的情况下，可能会发生双重交付。</p><p><br></p><p><strong>Debugging Hook handlers</strong><br>钩子处理程序的日志并不会在Pod事件中公开。如果处理程序由于某种原因失败，它会广播这个事件。</p><p><br><br><br><br><br></p><h2 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a>工作负载</h2><p>Workloads</p><h3 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h3><p>Pod是k8s的基本构建块，是你创建和部署k8s对象模型中最小和最简单的单元。Pod代表了集群上正在运行的进程。<br>Pod封装了(encapsulates) 一个/多个 应用程序容器，存储资源，唯一的IP地址(集群内)以及控制容器运行需要的选项。Pod代表了一个部署单元，k8s中的单个应用程序实例可能包含单个或少量紧密耦合且共享资源的容器。<br>Docker是k8s Pod中最常使用的容器运行环境(runtime)，Pod同样也支持其它容器运行环境。</p><p>k8s 集群中的Pods可以用两种主要方法来使用：</p><ul><li><p><strong>运行单个容器的Pod</strong><br>Pods that run a single container<br><code>one-container-per-pod</code>模型时最常见的k8s用例。在这种情况下，你可将Pod视为单个容器的包装，而k8s直接管理Pod而不是容器。</p></li><li><p><strong>运行多个需要协同工作的容器的Pod</strong><br>Pods that run multiple containers that need to work together<br>Pod可能封装了由多个协同定位(co-located)容器组成的应用程序，这些容器紧密耦合并且需要共享资源。这些协同的容器可能形成一个统一的服务单元——一个容器从共享卷向公众提供文件，而一个单独的<code>sidecar</code>容器刷新或更新这些文件。Pod将这些容器和资源作为单个可管理的实体包装在一起。</p></li></ul><p><br></p><p>每个Pod都用于运行给定应用程序的单个实例。如果你想要水平扩展应用程序，你可以使用多个Pods(每个实例一个)。在k8s中，这通常称为<strong>副本(replication)</strong>。 <code>Replicated Pods</code>通常通过称为<strong>控制器(Controller)</strong>的抽象来创建和管理。</p><p><br></p><p><strong>Pod如何管理多个容器</strong><br>Pods旨在支持多个协作进程(as container)，形成一个具有凝聚力的服务单元。Pod中的容器将自动协同定位(co-located)，并在集群中的同一主机上协同调度(co-scheduled)。容器可以共享资源和依赖，彼此通信，并协调它们何时以及如何终止。</p><p>注意，将多个协同定位和协同管理的容器分组到一个Pod中是一个相对高级的栗子。你应该仅在容器紧密耦合的特定实例中使用此模式。<br>例如，你可能有一个容器充当共享卷中文件的Web Server，以及一个单独的<code>sidecat</code>容器——用于从远程更新这个文件：</p><p><img src="/images/K8s/pod_multi_container.png" alt="多容器Pod"></p><p><br></p><p><strong>Pod共享资源</strong><br>Pod为其组成容器提供了两种共享资源：</p><ul><li><p><strong>Networking</strong><br>每个Pod都被分配了一个唯一的IP地址(within cluster)。Pod中的每个容器都共享网络命名空间，包括IP地址和网络端口。Pod内的容器可使用<code>localhost</code>相互通信。当Pod内的容器与Pod外的实体通信时，它们必须协调如何使用共享网络资源。</p></li><li><p><strong>Storage</strong><br>Pod可以指定一组共享存储卷。Pod中的所有容器都可以访问这个共享卷，允许这些容器共享数据。还是关于数据持久化的卷。</p></li></ul><p><br></p><p><strong>使用Pods</strong><br>你很少直接在k8s(甚至是单例Pod)中创建单独的Pod。这是因为Pod被设计为相对短暂的一次性实体，即用后即焚。当Pod被创建后，都会被调度到集群中的节点上运行。Pod保留在该节点上，知道进程终止，Pod对象被删除，Pod因资源不足而被驱逐，或节点失效。Pod不会自愈。<br>注意： 重启Pod中的容器与重启Pod不是一回事。Pod本身不运行，它只提供容器的运行环境并保持容器的运行状态。但是容器运行的环境会持续存在，直到删除为止。</p><p>Pod本身不提供自我修复(self-heal)。如果将Pod调度到一个失败的节点，或调度操作本身失败，则会删除Pod。同样，由于缺乏资源或节点维护中，Pod将无法在驱逐中存活。k8s使用一个高更级别的抽象，称为控制器(Controller)。它管理相对可处理的Pod实例的工作。因此，尽管可以直接使用Pod，但在k8s中使用控制器管理Pod更为常见。<br>控制器可为你创建和管理多个Pod，处理副本和上线，并在集群范围内提供自我修复功能。例如，如果节点故障，控制器可能会通过在不同节点上安排相同的替换来自动替换Pod。<br>通常，控制器使用你提供的Pod模板来创建它负责的Pod。</p><p><br></p><p><strong>Pod Templates</strong><br>Pod模板是Pod规范，包含在其它对象中。控制器使用Pod模板制作实际的Pod。</p><p>栗子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: myapp-pod</span><br><span class="line">  labels:</span><br><span class="line">    app: myapp</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: myapp-container</span><br><span class="line">    image: busybox</span><br><span class="line">    command: ['sh', '-c', 'echo Hello Kubernetes! &amp;&amp; sleep 3600']</span><br></pre></td></tr></table></figure><p>Pod模板不是指定所有副本的当前所需状态，而是像饼干切割器。饼干被切割后，饼干与切割器无关。</p><p><br><br><br></p><h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><p>Pod是可在k8s中创建和管理的最小可部署的计算单元。</p><p><br></p><p><strong>Pod是什么</strong><br>Pod是一组 一个/多个容器，具有共享存储/网络，以及如何运行容器的规范。Pod中的容器总是<code>co-located</code>和<code>co-scheduler</code>，并在共享上下文中运行。一个pod模拟特定应用程序的逻辑主机，它包含一个/多个紧密耦合的应用程序容器。<br>Pod的共享上下文十一组Linux namespace， cgroup，以及隔离方面。在Pod的上下文中，各个应用程序科恩能够回应用进一步的子隔离。<br>Pod中的容器共享IP地址和端口空间，并且可通过<code>localhsot</code>找到彼此。它们还可使用IPC相互通信。不同Pod中的容器具有不同的IP地址，默认情况下无法通信，需要进行额外配置。<br>Pod中的应用程序还可访问共享卷，共享卷被定义为Pod的一部分，可挂载到每个应用程序的文件系统中。<br>就Docker构造而言，Pod被建模为一组具有共享命名空间和共享卷的Docker容器。<br>与单个应用程序容器类似，Pod被认为是相对短暂(非持久)的实体。</p><p><br></p><p><strong>Pod动机</strong></p><ul><li><p>管理(Management)<br>Pod是多个协作过程进程模式的模型，形成了一个有凝聚力的服务单元。它们通过提供更高级别的抽象来简化应用程序部署和管理。Pod提供用于部署，水平扩展，副本的单元。对于Pod中的容器，它们将自动处理协同调度， 共享命运， 协同副本，资源共享和依赖管理…</p></li><li><p>资源共享和交流<br>Pod可以实现成员之间的数据共享和通信。<br>Pod中的应用程序都是用相同的网络命名空间，因此可通过<code>localhost</code>进行通信。因此，Pod中的应用程序必须协调对端口的使用。<br>主机名设置为Pod中应用程序容器的Pod名。<br>除了定义在Pod中运行的应用程序容器，Pod还制定了一组共享存储卷(持久化)。</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system get pod -o wide</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE       IP               NODE</span><br><span class="line">kubernetes-dashboard-6948bdb78-tdh5v   1/1       Running   0          8d        10.244.2.3       salt01</span><br><span class="line">metrics-server-85ff8f7b84-72rd4        1/1       Running   0          9d        10.244.2.2       salt01</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl -n kube-system <span class="built_in">exec</span> -it metrics-server-85ff8f7b84-72rd4 /bin/sh</span><br><span class="line">/ <span class="comment"># hostname</span></span><br><span class="line">metrics-server-85ff8f7b84-72rd4</span><br><span class="line">/ <span class="comment"># ifconfig</span></span><br><span class="line">eth0 10.244.2.2</span><br><span class="line">/ <span class="comment"># ping 10.244.2.3</span></span><br><span class="line">PING 10.244.2.3 (10.244.2.3): 56 data bytes</span><br><span class="line">64 bytes from 10.244.2.3: seq=0 ttl=64 time=0.115 ms</span><br><span class="line">64 bytes from 10.244.2.3: seq=1 ttl=64 time=0.062 ms</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Pod使用</strong><br>Pod可用于托管垂直集成的应用程序栈，但主要动机是用于支持协同共处，协同管理的应用程序。如：</p><ul><li>内容管理系统，文件和数据加载器，本地缓存管理器</li><li>日志和检查点的备份、压缩、轮询、快照</li><li>数据变更观察器，日志和监控适配器，事件发布器</li><li>代理，网桥和适配器</li><li>控制器，管理器，配置器和更新器</li></ul><p>通常，单个Pod不用于运行同一程序的多个实例。</p><p><br></p><p><strong>替代考虑</strong><br>为什么不在单个容器中运行多个程序？</p><ol><li>透明度</li><li>解耦软件依赖关系</li><li>使用方便</li><li>效率</li></ol><p><br></p><p><strong>Pod耐久性</strong><br>Pod不应被视为耐用实体。它们不会在 调度失败，节点故障，驱逐，节点维护等情况下存活。<br>通常，用户不需要直接创建Pod。而应该(几乎总是)使用控制器。控制器提供了集群范围内的自修复(self-healing)，副本和上线管理。</p><p>Pod公开为一个原语以便于使用：</p><ul><li>调度器和控制器可插拔</li><li>支持Pod级操作，而无需通过控制器API代理</li><li>将Pod寿命与控制器寿命分离</li><li>控制器和服务的分离</li><li>kubelet实际是Pod控制器</li><li>高可用应用程序</li></ul><p><br></p><p><strong>Pod终止</strong><br>由于Pod表示集群中节点上正在运行的进程，因此允许这些进程在不需要时优雅地终止(gracefully terminate)非常重要。用户应该能够请求并指导进程何时终止，但也要确保删除最终完成。当用户请求删除Pod时，系统会在允许Pod强制终止之前记录预期的宽限期(grace period)，并将<code>TERM</code>信号(-15)发送到每个容器的主进程中。宽限期到期后，<code>KILL</code>信号(-9)发送到这些进程，然后从API server中删除该Pod。如果在等待进程终止时Kubelet或容器管理器重启了，则将在完整的宽限期内重试终止。</p><p>流程：</p><ol><li>用户发送删除Pod的命令，默认宽限期(30s)</li><li>API server中的Pod随着时间的推移而更新，在此之后，除了宽限期外，Pod被认为死亡</li><li>列出客户端命令时，Pod显示为<code>Terminating</code></li><li>当Kubelet发现Pod被标记为<code>Terminating</code>，它将开始Pod关闭过程<br> 4.1 如果Pod定义了<code>preStop hook</code>，则会在Pod内调用<br> 4.2 Pod中的进程发送<code>TERM</code>信号</li><li>Pod将从端点列表中删除，并且不再被视为副本控制器中运行的Pod的一部分。缓慢关闭的Pod无法继续为流量提供服务，因为负载均衡器会将其从轮询中删除</li><li>当宽限期到期后，仍在Pod中运行的任何进程都将被<code>KILL</code>信号杀死</li><li>Kubelet通过设置宽限期0（立即删除）完成删除API server上的Pod。Pod从API中消失，客户端不在可见</li></ol><p>默认情况下，所有删除都有30s的宽限期。<code>kubectl delete</code>命令支持指定<code>--grace-period=</code>选项。设置为0表示强制删除Pod。<code>--force --grace-period=0</code>强制删除。</p><p><strong>强制删除Pod</strong><br>强制删除Pod被定义为立即从集群状态和etcd中删除Pod。当执行强制删除时，API server不会等待来自Kubelet的确认——确认该Pod已在运行的节点上终止。它会立即删除API中的Pod，以便可使用相同的名称创建新的Pod。在节点上，设置为立即终止的Pod在被强制终止之前仍被授予一个小的宽限期。<br>强制删除可能会对某些Pod有潜在危险，请谨慎执行。</p><p><br></p><p><strong>Pod容器的特权模式(Privileged mode)</strong><br>在容器 spec的<code>SecurityContext</code>中使用<code>privileged</code>标志，来启用Pod中容器的特权模式。这对于想要使用Linux功能的容器非常有用。容器内的进程获得与可访问的容器外进程几乎相同的权限。使用特权模式，可以更容易的编写网络和卷插件，而不需要编译到kubelet。</p><p><br></p><p><strong>API对象</strong><br>Pod是k8s REST API中的顶级资源, <code>/pod/xxx</code>。</p><p><br><br><br></p><h4 id="Pod生命周期"><a href="#Pod生命周期" class="headerlink" title="Pod生命周期"></a>Pod生命周期</h4><p>Pod Lifecycle</p><p><br></p><p><strong>阶段(phase)</strong><br>Pod的<code>status</code>字段是一个<code>PodStatus</code>对象，它有一个<code>phase</code>字段。</p><p>阶段可能的值：</p><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>Pending</td><td>The Pod has been accepted by the Kubernetes system, but one or more of the Container images has not been created. This includes time before being scheduled as well as time spent downloading images over the network, which could take a while.</td></tr><tr><td>Running</td><td>The Pod has been bound to a node, and all of the Containers have been created. At least one Container is still running, or is in the process of starting or restarting.</td></tr><tr><td>Succeeded</td><td>All Containers in the Pod have terminated in success, and will not be restarted.</td></tr><tr><td>Failed</td><td>All Containers in the Pod have terminated, and at least one Container has terminated in failure. That is, the Container either exited with non-zero status or was terminated by the system.</td></tr><tr><td>Unknown</td><td>For some reason the state of the Pod could not be obtained, typically due to an error in communicating with the host of the Pod.</td></tr></tbody></table><p><br></p><p><strong>状况(conditions)</strong><br>Pod有一个<code>PodStatus</code>，它有一个<code>PodConditions</code>数组，表示Pod是否通过。每个<code>PodCondition</code>数字的每个元素都有六个可能的字段：</p><ul><li><code>lastProbeTime</code>: 最后一次探测Pod状况的字段</li><li><code>lastTransitionTime</code>: Pod最后从一个状态转换到另一个状态的时间戳的字段</li><li><code>message</code>: 有关转换的人类可读的详细信息的字段</li><li><code>reason</code>: 一个独特的，单字的最后转换的原因的字段</li><li><code>status</code>: 字段值可能为<code>True, False, Unknown</code></li><li><code>type</code>: 字段可能有如下值:<ul><li><code>PodScheduled</code>: Pod已被调度到一个节点</li><li><code>Ready</code>: Pod能提供请求，并应该添加到所有匹配服务的负载均衡池中</li><li><code>Initialized</code>: 所有的初始化容器已成功启动</li><li><code>Unschedulable</code>: 调度器现在无法调度Pod，如缺乏资源…</li><li><code>ContainersReady</code>: Pod中的所有容器都已准备好了</li></ul></li></ul><p><br></p><p><strong>探测(probes)</strong><br>探测是由容器上的kubelet定期执行的诊断。为了执行诊断，kubelet调用容器执行处理器(Handler)。有三种类型的处理器:</p><ul><li><code>ExecAction</code>: 在容器内执行指定命令。如果状态码为0，则认为诊断成功</li><li><code>TCPSocketAction</code>: 在指定端口的容器IP地址执行TCP检查。如果端口打开，则认为诊断成功</li><li><code>HTTPGetAction</code>: 在容器IP的特定端口的路径下执行HTTP GET请求。如果请求成功，则认为诊断成功</li></ul><p>每个探测可能有三种结果:</p><ul><li>Success</li><li>Failure</li><li>Unknown</li></ul><p>kubelet可选择在运行容器上执行两种探测并对其作出反应:</p><ul><li><code>livenessProbe</code>: 确定容器是否正在运行</li><li><code>readinessProbe</code>: 确定容器是否准备好为请求提供服务</li></ul><p>什么时候使用这两中探测？<br>When should you use liveness or readiness probes?</p><p>如果容器中的进程在遇到问题或变得不健康时会自行崩溃(crash)，则你不一定需要<code>livenessProbe</code>。kubelet将根据Pod的<code>restartPolicy</code>自动执行正确的操作。<br>如果希望在探测失败时杀死并重启容器，则请指定<code>livenessPorbe</code>和指定<code>restartPolicy</code>为<code>Always</code></p><p>如果只想在探测成功时向Pod发送流量，请指定<code>readinessProbe</code>。<br>如果容器需要在启动期间除了大型数据，配置文件或迁移，请指定<code>readnessProbe</code>。<br>如果你希望容器能够自行维护，你可指定一个<code>readnessProbe</code>，它检查特定端点。</p><p>注意，如果你只想在删除Pod时排除请求，则不一定需要<code>readnessProbe</code>。无论是否存在<code>readnessProbe</code>，Pod都会自动将其置于未准备状态。Pod在等待Pod中容器停止时仍处于未准备状态。</p><p><br></p><p><strong>Pod readiness gate</strong><br>FEATURE STATE: Kubernetes v1.11 alpha</p><p>为了通过向PodStatus调价额外的反馈或信号来增加<code>Pod readness</code>的可扩展性，k8s v1.11引入了一个名为<code>Pod ready++</code>的功能。你可在<code>PodSpec</code>中使用新字段<code>ReadinessGate</code>来指定要为Pod准备情况评估的其它条件。如果k8s在Pod的<code>status.conditions</code>字段找不到这样的状况，则状况的状态默认为<code>False</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Kind: Pod</span><br><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  readinessGates:</span><br><span class="line">    - conditionType: &quot;www.example.com/feature-1&quot;</span><br><span class="line">status:</span><br><span class="line">  conditions:</span><br><span class="line">    - type: Ready  # this is a builtin PodCondition</span><br><span class="line">      status: &quot;True&quot;</span><br><span class="line">      lastProbeTime: null</span><br><span class="line">      lastTransitionTime: 2018-01-01T00:00:00Z</span><br><span class="line">    - type: &quot;www.example.com/feature-1&quot;   # an extra PodCondition</span><br><span class="line">      status: &quot;False&quot;</span><br><span class="line">      lastProbeTIme: null</span><br><span class="line">      lastTransitionTime: 2018-01-01T00:00:00Z</span><br><span class="line">  containerStatuses:</span><br><span class="line">    - containerID: docker://abcd...</span><br><span class="line">      ready: true</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br></p><p><strong>重启策略</strong><br><code>PodSpec</code>有一个<code>restartPolicy</code>字段，其值可能是<code>Always(默认值), OnFailure, Never</code>。此策略应用于Pod中的所有容器，它仅指由同一节点上的kubelet重启的容器。退出的容器将由kubelet以指定退避延迟(10s, 20s, 40s…)重新启动，上限5分钟，并在成功执行十分钟后重置。</p><p><br></p><p><strong>寿命(lifetime)</strong><br>一般来说，Pod不会消失，直到有人摧毁它们。唯一的例外是，具有成功或失败超过一段时间的阶段的Pod将过期并自动销毁。</p><p>有三种类型的控制器可用：</p><ul><li>Use a Job for Pod</li><li>Use a  ReplicationController/ReplicaSet/Deployment for Pod</li><li>Use a DaemonSet for Pod</li></ul><p>所有三种类型的控制器都包含了PodTemplate。推荐创建适当的控制器并让它创建Pod，而不是自己直接创建Pod。这是因为Pod单独对机器故障没有弹性，但控制器不会。<br>如果节点死亡或与集群的其余部分断开连接，k8s会应用策略将丢失节点上的所有Pod的阶段设置为Failed。</p><p><br><br><br></p><h4 id="Init-Containers"><a href="#Init-Containers" class="headerlink" title="Init Containers"></a>Init Containers</h4><p>本节提供了初始容器(init container)的概述，它是在应用程序容器运行之前的专用容器，可包含应用程序镜像中不存在的实用程序或脚本设置。</p><p><br></p><p><strong>理解初始容器</strong><br>Pod可以有多个容器在其中运行应用程序，但它同样可以有一个或多个初始容器——它在应用程序容器启动前运行。<br>初始容器与常规容器一样，除了：</p><ul><li>They always run to completion.</li><li>每一个必须在下一个启动之前成功完成</li></ul><p>如果Pod的初始容器失败，则k8s会重复重启直到初始容器成功。但是，如果Pod的<code>restartPolicy</code>为<code>Never</code>，则不会重启。<br>要将容器指定为初始容器，请将<code>PodSpec</code>上的<code>initContainers</code>字段添加为应用程序<code>container</code>数组旁边的容器类型对象的JSON数组。初始容器的状态在<code>.status.initContainerStatuses</code>字段中作为容器状态数据返回。</p><p><strong>与常规容器的不同</strong><br>初始容器支持应用程序容器的所有字段和功能，包括资源限制，卷和安全设置。但资源请求和处理方式略有不同。此外，初始容器不支持<code>readiness probes</code>，因为它必须在Pod准备好之前运行完成。<br>如果为Pod指定了多个初始容器，则按顺序依次运行一个容器。每个必须在下一个运行之前完成。当所有初始容器都运行完毕时，k8s会初始化Pod并像往常一样运行应用程序容器。</p><p><br></p><p><strong>初始容器可用于什么</strong><br>由于初始容器具有来自应用程序容器的单独镜像，因此它们对于启动相关代码具有一些优势：</p><ul><li>出于安全原因，它们可以包含并运行不希望包含在应用程序容器镜像中的使用程序</li><li>它可以包含应用程序镜像中不存在的实用程序或自定义代码。例如，在配置过程中，无需为了使用其他工具(sed, awk, dig…)而专门使用<code>FROM</code>创建一个镜像</li><li>应用程序镜像构建器和部署器角色可独立工作，而无需共同构建单个应用程序镜像</li><li>它们使用Linux命名空间，以便从应用程序容器中获得不同的文件系统视图。因此，它们可以访问应用程序容器无法访问的<code>Secrets</code></li><li>它们在应用程序容器启动前运行完成，因此初始容器提供了一种简单的方法来阻止或延迟应用程序容器的启动，知道满足一组前置条件。</li></ul><p><br></p><p><strong>栗子</strong><br>这有些初始容器的使用案例:</p><ul><li>等待使用shell命令创建服务: <code>for in in {1..100}; do sleep 1; if dig myservice; then exit 0; fi; done; exit 1</code></li><li>使用API从远程服务器注册此Pod: <code>curl -XPOST http://host:port/register -d &#39;instance=$()&amp;ip=$()&#39;</code></li><li>在启动应用程序之前等待一段时间: <code>sleep 60</code></li><li>克隆一个git repo到某个卷</li><li>替换配置文件中的值并运行模板来动态生成应用程序容器的配置文件</li></ul><p><br></p><p><strong>使用初始容器</strong><br>两个初始容器。第一个等待<code>myservice</code>，第二个等待<code>mydb</code>。一旦两个容器完成，Pod将开始。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myapp-pod</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">myapp-container</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">['sh',</span> <span class="string">'-c'</span><span class="string">,</span> <span class="string">'echo The app is running! &amp;&amp; sleep 3600'</span><span class="string">]</span></span><br><span class="line"><span class="attr">  initContainers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">init-myservice</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">['sh',</span> <span class="string">'-c'</span><span class="string">,</span> <span class="string">'until nslookup myservice; do echo waiting for myservice; sleep 2; done;'</span><span class="string">]</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">init-mydb</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">['sh',</span> <span class="string">'-c'</span><span class="string">,</span> <span class="string">'until nslookup mydb; do echo waiting for mydb; sleep 2; done;'</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>创建:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f /etc/k8s/test/init-container.yaml</span><br><span class="line">pod/myapp-pod created</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl get pod</span><br><span class="line">NAME             READY     STATUS     RESTARTS   AGE</span><br><span class="line">init-container   0/1       Init:0/2   0          6s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl describe -f /etc/k8s/test/init-container.yaml</span><br><span class="line">Init Containers:</span><br><span class="line">  init-myservice:</span><br><span class="line">    Container ID:  docker://f9ca73d4d2c8903a1fe84937e34ae27b909a691d2e524254b8f4aec9d5cc754c</span><br><span class="line">    Image:         busybox</span><br><span class="line">    Image ID:      docker-pullable://docker.io/busybox@sha256:cb63aa0641a885f54de20f61d152187419e8f6b159ed11a251a09d115fdff9bd</span><br><span class="line">    Port:          &lt;none&gt;</span><br><span class="line">    Host Port:     &lt;none&gt;</span><br><span class="line">    Command:</span><br><span class="line">      sh</span><br><span class="line">      -c</span><br><span class="line">      until nslookup myservice; do echo waiting for myservice; sleep 2; done;</span><br><span class="line">    State:          Terminated</span><br><span class="line">      Reason:       Completed</span><br><span class="line">      Exit Code:    0</span><br><span class="line">      Started:      Fri, 24 Aug 2018 16:31:13 +0800</span><br><span class="line">      Finished:     Fri, 24 Aug 2018 16:31:18 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-69vgk (ro)</span><br><span class="line">  init-mydb:</span><br><span class="line">    Container ID:  docker://a9946122976ff70ff1dd874299e3e63f4b07f2758f5e6518b84343c58daa3506</span><br><span class="line">    Image:         busybox</span><br><span class="line">    Image ID:      docker-pullable://docker.io/busybox@sha256:cb63aa0641a885f54de20f61d152187419e8f6b159ed11a251a09d115fdff9bd</span><br><span class="line">    Port:          &lt;none&gt;</span><br><span class="line">    Host Port:     &lt;none&gt;</span><br><span class="line">    Command:</span><br><span class="line">      sh</span><br><span class="line">      -c</span><br><span class="line">      until nslookup mydb; do echo waiting for mydb; sleep 2; done;</span><br><span class="line">    State:          Terminated</span><br><span class="line">      Reason:       Completed</span><br><span class="line">      Exit Code:    0</span><br><span class="line">      Started:      Fri, 24 Aug 2018 16:31:24 +0800</span><br><span class="line">      Finished:     Fri, 24 Aug 2018 16:31:29 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-69vgk (ro)</span><br><span class="line">Containers:</span><br><span class="line">  myapp-container:</span><br><span class="line">    Container ID:  docker://b2c7a1f32d65dd41fa439d1f6879824b40c3014b32b15d61fed0cda171144a1b</span><br><span class="line">    Image:         busybox</span><br><span class="line">    Image ID:      docker-pullable://docker.io/busybox@sha256:cb63aa0641a885f54de20f61d152187419e8f6b159ed11a251a09d115fdff9bd</span><br><span class="line">    Port:          &lt;none&gt;</span><br><span class="line">    Host Port:     &lt;none&gt;</span><br><span class="line">    Command:</span><br><span class="line">      sh</span><br><span class="line">      -c</span><br><span class="line">      echo The app is running! &amp;&amp; sleep 3600</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Fri, 24 Aug 2018 16:31:34 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-69vgk (ro)</span><br></pre></td></tr></table></figure><p><img src="/images/K8s/init_container.png" alt="初始容器"></p><p><br></p><p><strong>详细行为</strong><br>在Pod启动期间，初始化网络和卷后，初始容器将按顺序启动。每个容器必须在下一个容器启动前成功退出。如果容器由于运行环境未能启动或失败退出而启动失败，则它根据Pod的<code>restartPolicy</code>重试。如果Pod的<code>restartPolicy</code>为<code>Always(默认)</code>，则初始容器使用<code>restartPolicy</code>为<code>OnFailure</code>。<br>在所有初始容器都成功之前，Pod无法变为<code>Ready</code>。初始容器上的端口无法聚合到服务下。正在初始化的Pod处于<code>Pending</code>状态，但应该具有<code>Initializing</code>设置为<code>true</code>的条件。<br>如果Pod重启，则所有初始都要执行一遍。<br><code>init container spec</code>的更改仅限于容器镜像字段。更改初始容器镜像字段相当于重启Pod。<br>由于初始容器可重启，重试或重新执行，因此初始容器代码应该是幂等的。In particular, code that writes to files on EmptyDirs should be prepared for the possibility that an output file already exists.<br>在Pod上使用<code>activeDeadlineSeconds</code>，在容器上使用<code>livenessProbe</code>，以防止初始容器永远失败。<br>Pod中每个应用程序和初始容器的名称必须是唯一的，否则会引发验证错误。</p><p><strong>资源</strong><br>给定初始容器的排序和执行，适用一下资源使用规则：</p><ul><li>在所有初始容器上定义的任何特定资源请求或限制的最高值是有效的初始 请求/限制</li><li>Pod对资源的有效请求/限制是以下值中的较高者:<ul><li>所有的应用程序容器对资源请求/限制的总和</li><li>对资源的有效初始请求/限制</li></ul></li><li>调度是基于有效请求/限制完成的，这意味着初始容器可以保留在Pod生命周期内未使用的初始化资源</li><li>Pod的有效QoS层与初始容器和应用程序容器一样</li></ul><p>Pod级别的cgroup基于有效的Pod请求和限制，与调度程序相同。</p><p><br></p><p><strong>Pod重启原因</strong><br>由于以下原因，Pod可重新启动，导致重新执行初始容器：</p><ul><li>用户更新了<code>PodSpec</code>，导致初始容器镜像发生噶变。应用程序容器镜像的更改仅重启应用程序容器</li><li>Pod的基础架构容器重启</li><li>Pod的所有容器都终止，而<code>restartPolicy</code>设置为<code>Always</code>，强制重启，并且初始容器完成记录由于垃圾回收而丢失</li></ul><p><br><br><br></p><h4 id="Pod预设"><a href="#Pod预设" class="headerlink" title="Pod预设"></a>Pod预设</h4><p>Pod Preset</p><p>Pod Presets是对象，在创建时将特定信息注入Pod。<br>Pod Preset是一种API资源，用于在创建时将其它运行时的需求写入到Pod。你可使用<code>label selectors</code>指定应用于Pod的给定Pod Preset。<br>使用Pod Preset允许pod template作者不必显示提供每个pod的所有信息。这样，作者不需要知道有关该服务的所有详细信息。</p><p><br></p><p><strong>它如何工作</strong><br>k8s提供了一个<code>admission controller(Pod Preset)</code>，启用后，会将Pod Preset应用于传入的pod创建请求。当Pod创建请求发生时，系统会执行一下操作：</p><ol><li>检索所有可供使用的Pod Preset</li><li>检查任何Pod Preset的<code>label selector</code>是否与正在创建的Pod上的标签匹配</li><li>尝试将Pod Preset定义的各种资源合并到正在创建的Pod中</li><li>出错时，抛出一个记录Pod 合并错误的事件，然后创建不从Pod Preset写入任何资源的pod</li><li>注释生成的修改后的Pod spec，以表明它已被Pod Preset修改——<code>podpreset.admission.kubernetes.io/podpreset-&lt;pod-preset name&gt;: &quot;&lt;resource version&gt;&quot;</code></li></ol><p>每个Pod能够被零个或多个PodPreset匹配，每个PodPreset可以被应用到零个或多个Pod。当PodPreset应用于一个或多个Pod时，k8s会修改Pod spec。对于<code>Env, EnvFrom, VolumeMounts</code>，k8s修改Pod中所有容器的<code>container spce</code>；对于<code>Volume</code>的更改，k8s修改<code>Pod spec</code>。</p><p><strong>为指定Pod禁用PodPreset</strong><br>在某些情况下，你希望Pod不被任何PodPreset修改。你可修改: <code>podpreset.admission.kubernetes.io/exclude: &quot;true&quot;</code></p><p><br></p><p><strong>启用PodPreset</strong><br>要在集群中使用PodPreset，你必须确保以下内容：</p><ol><li>你已启用API类型: <code>settings.k8s.io/v1alpha1/podpreset</code></li><li>你已经启动<code>admission controller</code> PodPreset</li><li>你已通过在将使用的命名空间中创建PodPreset对象来定义PodPreset</li></ol><p><br><br><br></p><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>Disruptions</p><p>本节适用于想要构建高可用性应用程序的用户，因此需要了解Pod可能发生的中断类型。<br>这同样适用于希望执行自动化集群操作的集群管理员，例如升级或自动伸缩集群。</p><p><br></p><p><strong>自愿和非自愿中断</strong><br>Voluntary and Involuntary Disruptions</p><p><br><br><br></p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p><br></p><h4 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h4><p>副本集是下一个副本控制器。现在副本集和副本控制器之间的唯一区别是<code>selector</code>的支持。副本集支持<code>labels user guide</code>中描述的新的基于集合<code>selector</code>的要求，而副本控制器仅支持基于等同<code>selector</code>的要求。</p><p><br></p><p><strong>如何使用副本集</strong><br>大多数支持副本控制器的<code>kubectl</code>命令也支持副本集。一个例外是<code>rolling-update</code>命令。如果你想要滚动更新功能，请考虑使用Deployments代替。<br>虽然副本集可独立使用，但它主要被Deployment用作协调Pod创建，删除和更新的机制。使用部署时，你不必担心管理它们创建的副本集，部署拥有并管理其副本集。</p><p><br></p><p><strong>何时使用副本集</strong><br>副本集确保在任何给定时间运行指定数量的Pod副本。但是，部署是一个更高级别的概念，它管理副本集并为Pod提供声明性更新以及许多其它有用的功能。因此，除非你需要自定义更新或无需更新，否则建议你使用部署而不是直接使用副本集。<br>这实际上意味着，你不需要操作副本集对象：改为使用部署，并在<code>spec</code>部分定义你的应用程序。</p><p><br></p><p><strong>栗子</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">guestbook</span></span><br><span class="line"><span class="attr">    tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># modify replicas according to your case</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">    matchExpressions:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">&#123;key:</span> <span class="string">tier,</span> <span class="attr">operator:</span> <span class="string">In,</span> <span class="attr">values:</span> <span class="string">[frontend]&#125;</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">guestbook</span></span><br><span class="line"><span class="attr">        tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">php-redis</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">gcr.io/google_samples/gb-frontend:v3</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">100</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">GET_HOSTS_FROM</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">dns</span></span><br><span class="line">          <span class="comment"># If your cluster config does not include a dns service, then to</span></span><br><span class="line">          <span class="comment"># instead access environment variables to find service host</span></span><br><span class="line">          <span class="comment"># info, comment out the 'value: dns' line above, and uncomment the</span></span><br><span class="line">          <span class="comment"># line below.</span></span><br><span class="line">          <span class="comment"># value: env</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f /etc/k8s/test/frontend.yaml</span><br></pre></td></tr></table></figure><p><br></p><p><strong>编写副本集<code>spec</code></strong><br>与所有其它k8s API对象一样，副本集需要<code>apiVersion</code>, <code>kind</code>, <code>metadata</code>字段，副本集还需要一个<code>.spce</code>部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#Pod Template</span><br><span class="line">.spec.template是.spec唯一必需的字段</span><br><span class="line">除了pod的必须字段，副本集中的Pod模板还必须指定适当的`label`和`restart policy`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Pod Selector</span><br><span class="line">.spec.selector字段是一个label selector。副本集使用与selector匹配的label来管理所有pod。</span><br><span class="line">它不区分创建或删除的Pod以及人或进程创建或删除的pod。这允许替换副本集而不会影响正在运行的Pod。</span><br><span class="line">.spec.template.metadata.labels 必须匹配 .spec.selector，否则它将被API拒绝。</span><br><span class="line">此外，你通常不应创建任何label与selector匹配的pod。如果你这样做了，副本集会认为它创建了其它pod，k8s并没有阻止你这样做。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Labels on a ReplicaSet</span><br><span class="line">副本集本身可以有标签(.metadata.labels)。通常，你可将其设置为与 .spec.template.metadata.labels 一致。但，允许他们不同，并且 .metadata.labels 不会影响副本集的行为</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Replicas</span><br><span class="line">你可通过设置 .spec.replicas 来指定应同时运行的pod数量。如果未指定，默认为1</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用副本集</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#删除副本集和它的pods</span><br><span class="line">kubectl delete replicaset/xxx</span><br><span class="line">#或</span><br><span class="line">kubectl proxy --port=8080</span><br><span class="line">curl -XDELETE &apos;localhost:8080/apis/extensions/v1beta1/namespaces/default/replicasets/frontend \</span><br><span class="line">-d &apos;&#123;&quot;kind&quot;:&quot;DeleteOptions&quot;,&quot;apiVersion&quot;:&quot;v1&quot;,&quot;propagationPolicy&quot;:&quot;Foreground&quot;&#125;&apos; \</span><br><span class="line">-H &quot;Content-Type: application/json&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#仅删除副本集</span><br><span class="line">kubectl delete rs/xxx --cascade=false</span><br><span class="line">#或</span><br><span class="line">kubectl proxy --port=8080</span><br><span class="line">curl -X DELETE  &apos;localhost:8080/apis/extensions/v1beta1/namespaces/default/replicasets/frontend&apos; \</span><br><span class="line">-d &apos;&#123;&quot;kind&quot;:&quot;DeleteOptions&quot;,&quot;apiVersion&quot;:&quot;v1&quot;,&quot;propagationPolicy&quot;:&quot;Foreground&quot;&#125;&apos; \</span><br><span class="line">-H &quot;Content-Type: application/json&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#从副本隔离pods</span><br><span class="line">可通过更改label从副本集的目标中删除Pod。此技术可用于从服务中删除pod以进行调试，数据恢复等。以这种方式删除的pod将自动替换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#伸缩副本集</span><br><span class="line">只需更新副本集的 .spec.replicas 字段轻松伸缩副本集。副本集控制器确保具有匹配 label selector 所需数量的pod可用且可操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#作为水平pod自动伸缩目标的副本集</span><br><span class="line">Horizontal Pod Autoscalers(HPA)，意味着副本集可通过HPA自动伸缩。</span><br><span class="line">#栗子</span><br><span class="line">apiVersion: autoscaling/v1</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend-scaler</span><br><span class="line">spec:</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    kind: ReplicaSet</span><br><span class="line">    name: frontend</span><br><span class="line">  minReplicas: 3</span><br><span class="line">  maxReplicas: 10</span><br><span class="line">  targetCPUUtilizationPercentage: 50</span><br><span class="line"></span><br><span class="line">kubectl create -f /path/xx/hpa.rs.yaml</span><br><span class="line">#此外，可使用kubectl命令来自动伸缩</span><br><span class="line">#kubectl autoscale rs frontend</span><br></pre></td></tr></table></figure><p><br></p><p><strong>替代副本集</strong></p><ul><li>Deployment(推荐)</li><li>Bare Pods</li><li>Job</li><li>DaemonSet</li></ul><p><br><br><br></p><h4 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h4><p><strong>注意：现在，配置副本集的推荐方法是使用部署。</strong></p><p>副本控制器确保一次运行指定数量的Pod副本。换言之，副本控制器确保一个Pod或一组同类Pod总是可用。</p><p><br><br><br></p><h4 id="Deployments"><a href="#Deployments" class="headerlink" title="Deployments"></a>Deployments</h4><p>部署控制器为Pod和ReplicaSet提供了声明性更新。<br>在部署对象中描述所需的状态，部署控制器以受控速率将实际状态更改为所需状态。你可定义部署来创建新的副本集，或删除现有的部署并使用新的部署收纳所有资源。<br>你不应该直接管理部署所拥有的副本集，应该通过操作部署对象来涵盖所有用例。</p><p><br></p><p><strong>栗子</strong><br>以下是部署的典型案例：</p><ul><li>创建部署来上线副本集</li><li>声明Pod的新状态</li><li>回滚到早期的部署版本</li><li>伸缩部署</li><li>暂定部署</li><li>使用部署的状态</li><li>清理旧的副本集</li></ul><p><br></p><p><strong>创建一个部署</strong><br>下面的栗子，创建一个3个Nginx pods的副本集:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.7.9</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f ./nginx-deployment.yaml</span><br><span class="line"></span><br><span class="line">kubectl get deployment</span><br><span class="line">kubectl get rs</span><br><span class="line">kubectl get pod --show-labels</span><br></pre></td></tr></table></figure><p><br></p><p><strong>更新部署</strong><br>当且仅当部署的pod template发生更改时，才会触发部署更新上线。<br>假如我们要更新Nginx的版本为<code>1.9.1</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1</span><br><span class="line">deployment.extensions/nginx-deployment image updated</span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line">kubectl edit deployment/nginx-deployment</span><br><span class="line">deployment.extensions/nginx-deployment edited</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看上线状态</span><br><span class="line">kubectl rollout status deployment/nginx-deployment</span><br><span class="line">Waiting for deployment &quot;nginx-deployment&quot; rollout to finish: 1 out of 3 new replicas have been updated...</span><br><span class="line">Waiting for deployment &quot;nginx-deployment&quot; rollout to finish: 1 out of 3 new replicas have been updated...</span><br><span class="line">Waiting for deployment &quot;nginx-deployment&quot; rollout to finish: 2 out of 3 new replicas have been updated...</span><br><span class="line">Waiting for deployment &quot;nginx-deployment&quot; rollout to finish: 2 out of 3 new replicas have been updated...</span><br><span class="line">Waiting for deployment &quot;nginx-deployment&quot; rollout to finish: 2 out of 3 new replicas have been updated...</span><br><span class="line">Waiting for deployment &quot;nginx-deployment&quot; rollout to finish: 1 old replicas are pending termination...</span><br><span class="line">Waiting for deployment &quot;nginx-deployment&quot; rollout to finish: 1 old replicas are pending termination...</span><br><span class="line">deployment &quot;nginx-deployment&quot; successfully rolled out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#新旧副本集副本数</span><br><span class="line">kubectl get rs</span><br><span class="line">NAME                          DESIRED   CURRENT   READY     AGE</span><br><span class="line">nginx-deployment-67594d6bf6   0         0         0         16m</span><br><span class="line">nginx-deployment-d78fcfc84    3         3         3         3m</span><br></pre></td></tr></table></figure><p>部署可以确保在更新时只有一定数量的Pod可能会关闭。默认情况下，它确保最大不可用率25%。<br>部署确保在所需数量的Pod之上只能创建一定数量的Pod。默认情况下，它确保比最大数多25%。<br>例如，如果仔细查看上面的部署，你将看到它首先创建了一个新的Pod，然后删除了一些旧的Pod并创建新的Pod。在有足够数量的新Pod出现之前，它不会杀死旧的Pod，并且在足够数量的旧Pod被杀死之前不会创建新的Pod。</p><p>通常不鼓励进行<code>label selector</code>的更改，建议你事先规划好<code>selector</code>。</p><p><br></p><p><strong>回滚(rolling back)部署</strong><br>有时可能需要回滚部署，当部署不稳定时，如崩溃循环(crash looping)。默认情况下，所有的部署上线历史都保留在系统中，以便可以随时回滚。</p><p>假设我之间将<code>nginx:1.7.1</code>更新到<code>nginx:1.9.1</code>的时候错误的写成了<code>nginx:1.91</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kubectl set image deployment/nginx-deployment nginx=nginx:1.91</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#上线就会卡在此处</span><br><span class="line">kubectl rollout status deployments nginx-deployment</span><br><span class="line">Waiting for deployment &quot;nginx-deployment&quot; rollout to finish: 1 out of 3 new replicas have been updated...</span><br><span class="line">error: deployment &quot;nginx-deployment&quot; exceeded its progress deadline</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看容器错误，它会报镜像拉取错误</span><br><span class="line">kubectl get pod</span><br><span class="line">nginx-deployment-58c7645486-s5t6t   0/1       ImagePullBackOff   0          3m        &lt;none&gt;        node</span><br><span class="line">#UI里面的报错</span><br><span class="line">#Failed to pull image &quot;nginx:1.91&quot;: rpc error: code = Unknown desc = manifest for docker.io/nginx:1.91 not found</span><br></pre></td></tr></table></figure><p>部署控制器将自动停止错误的<code>rollout</code>，并将停止扩展新的副本集。这取决于滚动升级的参数(<code>maxUnavailable</code>)。默认情况下，k8s将值设置为1，将<code>.spec.replicas</code>设置为1，因此你无需关心设置这些参数。你的部署可能具有100%的不可用性。</p><p>要修复它，你需要回滚到先前稳定的部署版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#检查上线历史</span><br><span class="line">kubectl rollout history deployment/nginx-deployment</span><br><span class="line">deployments &quot;nginx-deployment&quot;</span><br><span class="line">REVISION    CHANGE-CAUSE</span><br><span class="line">1           kubectl create -f ./nginx-deployment.yaml --record</span><br><span class="line">2           kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1</span><br><span class="line">3           kubectl set image deployment/nginx-deployment nginx=nginx:1.91</span><br><span class="line"></span><br><span class="line">#查看某个上线历史</span><br><span class="line">rollout history deployment/nginx-deployment --revision=2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#回滚</span><br><span class="line"></span><br><span class="line">#回滚到前一个版本</span><br><span class="line">kubectl rollout undo deployment/nginx-deployment</span><br><span class="line">deployment.extensions/nginx-deployment</span><br><span class="line"></span><br><span class="line">#回滚到指定版本</span><br><span class="line">kubectl rollout undo deployment/nginx-deployment --to-revision=2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看事件</span><br><span class="line">kubectl describe deployment/nginx-deployment</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason              Age                From                   Message</span><br><span class="line">  ----    ------              ----               ----                   -------</span><br><span class="line">  Normal  DeploymentRollback  2m                 deployment-controller  Rolled back deployment &quot;nginx-deployment&quot; to revision 3</span><br><span class="line">  Normal  ScalingReplicaSet   2m                 deployment-controller  Scaled down replica set nginx-deployment-58c7645486 to 0</span><br></pre></td></tr></table></figure><p><br></p><p><strong>伸缩副本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#扩展部署</span><br><span class="line">kubectl scale deployment nginx-deployment --replicas=5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#水平伸缩</span><br><span class="line">kubectl autoscale deployment nginx-deployment --min=3 --max=6 --cpu-percent=80</span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">kubectl get horizontalpodautoscaler.autoscaling</span><br><span class="line">NAME               REFERENCE                     TARGETS         MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">nginx-deployment   Deployment/nginx-deployment   &lt;unknown&gt;/80%   3         6         5          1m</span><br></pre></td></tr></table></figure><p><strong>比例伸缩(proportional scaling)</strong><br>滚动升级部署支持同时运行多个版本的应用程序。当你或自动伸缩器正在上线滚动更新的部署时，部署控制器将平衡现有活动的副本集中的其它副本，以降低风险。这称为比例缩放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deploy</span><br><span class="line">NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deployment   5         5         5            5           1h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#更新一个错误镜像，它会卡住</span><br><span class="line">kubectl set image deploy/nginx-deployment nginx=nginx:sometag</span><br><span class="line"></span><br><span class="line">kubectl get rs -o wide</span><br><span class="line">NAME                         DESIRED   CURRENT   READY     AGE       CONTAINERS   IMAGES          SELECTOR</span><br><span class="line">nginx-deployment-895bd59bc   3         3         0         1m        nginx        nginx:sometag   app=nginx,pod-template-hash=451681567</span><br><span class="line">nginx-deployment-d78fcfc84   5         5         5         1h        nginx        nginx:1.7.1     app=nginx,pod-template-hash=834979740</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl get deploy -o wide</span><br><span class="line">NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE       CONTAINERS   IMAGES          SELECTOR</span><br><span class="line">nginx-deployment   6         8         3            5           1h        nginx        nginx:sometag   app=nginx</span><br></pre></td></tr></table></figure><p><br></p><p><strong>暂停和恢复部署</strong><br>你可以在触发一个或多个更新之前暂停(pause)部署，然后恢复(resume)它。这允许你在暂停和恢复之间应用多个修复，而不会触发不必要的上线。<br>注意： 在恢复暂停部署之前，无法执行回滚操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#暂停</span><br><span class="line">kubectl rollout pause deployment/nginx-deployment</span><br><span class="line">deployment.extensions/nginx-deployment paused</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl set image deploy/nginx-deployment nginx=nginx:1.9.1</span><br><span class="line">deployment.extensions/nginx-deployment image updated</span><br><span class="line"></span><br><span class="line">kubectl set resources deployment nginx-deployment -c=nginx --limits=cpu=200m,memory=128Mi</span><br><span class="line">deployment.extensions/nginx-deployment resource requirements updated</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#恢复</span><br><span class="line">kubectl rollout resume deployment/nginx-deployment</span><br><span class="line">deployment.extensions/nginx-deployment resumed</span><br></pre></td></tr></table></figure><p><br></p><p><strong>部署状态</strong><br>部署在其生命周期内会进入各种状态–<code>kubectl rollout status</code></p><ul><li><p>Progessing Deployment</p><ul><li>部署创建一个新的副本集</li><li>部署伸缩到新的/旧的副本集</li><li>新的Pod可用</li></ul></li><li><p>Complete Deployment</p><ul><li>所有与部署关联的副本都已完成</li><li>所有与部署关联的副本都可用</li><li>没有正在运行的旧的部署副本</li></ul></li><li><p>Failed Deployment</p><ul><li>配额不足</li><li>准备探针失败</li><li>镜像拉取失败</li><li>权限不足</li><li>限制范围</li><li>应用程序运行时配置错误</li></ul></li><li><p>Operating on a failed deployment</p></li></ul><p><br></p><p><strong>Clean up Policy</strong><br>可在部署中设置<code>.spec.revisionHistoryLimit</code>字段来指定需要保留的旧副本集数。其余的将在后台被垃圾回收，默认为10。</p><p><strong>注意：</strong>将此字段设置为0会导致清理部署的所有历史记录，从而部署将无法回滚。</p><p><br></p><p><strong>Deployment Spec</strong><br>与其它k8s配置一样，Deployment需要<code>apiVersion</code>, <code>kind</code>, <code>metadata</code>字段。但部署还需要<code>.spec</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#pod template</span><br><span class="line">#必填字段</span><br><span class="line">.spec.template</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Replicas</span><br><span class="line">.spec.replicas</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Selector</span><br><span class="line">#它必须匹配.spec.template.metadata.labels，否则会被API拒绝</span><br><span class="line">.spec.selector</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Strategy</span><br><span class="line">.spec.strategy</span><br><span class="line"></span><br><span class="line">#Recreate deployment</span><br><span class="line">.spec.strategy.type==Recreate</span><br><span class="line"></span><br><span class="line">#Rolling Update Deployment</span><br><span class="line">.spce.stratefy.type==RollingUpdate</span><br><span class="line">#Max Unavailable</span><br><span class="line">.spec.strategy.rollingUpdate.maxUnavailable</span><br><span class="line">#Max Surge</span><br><span class="line">.specstrategy.rollingUpdate.maxSurge</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Progress Deadline Seconds</span><br><span class="line">.spec.progressDeadlineSeconds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Min Ready Seconds</span><br><span class="line">.spec.minReadySeconds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Rollback To</span><br><span class="line">.spec.rollbackTo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Revision History Limit</span><br><span class="line">.spec.revisionHistoryLimit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Paused</span><br><span class="line">.spec.paused</span><br></pre></td></tr></table></figure><p><br></p><p><strong>替代方案</strong></p><ul><li>kubectl rolling update<br><code>kubetl rolling update</code>以类似的方式更新Pod和副本集控制器。但建议使用部署，因为它是声明性的。</li></ul><p><br><br><br></p><h4 id="StatefulSets"><a href="#StatefulSets" class="headerlink" title="StatefulSets"></a>StatefulSets</h4><p><code>StatefulSet</code>是用于管理有状态应用程序的工作负载的API对象。<br><strong>Note: StatefulSets are stable (GA) in 1.9.</strong></p><p>管理一组Pod的部署和伸缩，并提供有关这些Pod的序列和唯一性的保证。<br>与部署类似，有状态集管理基于相同容器规范(spec)的Pod；与部署不同，有状态集为其每个Pod维护一个粘性(sticky)标识。这些Pod根据相同的规范创建，但不可互换，每个Pod都有一个持久的标识符，它可在任何重新调度时保留。<br>有状态集与任何其它控制器相同的模式运行。你在有状态集对象中定义所需的状态，有状态集控制器进行任何必要的更新以从当前状态到达期望状态。</p><p><br></p><p><strong>使用有状态集</strong><br>有状态集对于需要以下一个或多个应用程序非常有用：</p><ul><li>稳定，唯一的网络标识</li><li>稳定，持久存储</li><li>有序，优雅的部署和伸缩</li><li>有序，优雅的删除和终止</li><li>有序，自动的滚动更新</li></ul><p>如果应用程序不需要任何稳定标识或有序部署、删除、伸缩，则应该使用提供一组无状态副本的控制器来部署你的应用程序。如部署或副本集这样的控制器可能更适合无状态需求。</p><p><br></p><p><strong>局限(limitations)</strong></p><ul><li>k8s v1.9+</li><li>给定Pod的存储必须由<code>PersistentVolume Provisioner</code>根据请求的存储类进行配置，或由管理员预先配置</li><li>删除/伸缩有状态集将不会删除与有状态集相关联的卷。这是为了确保数据安</li><li>有状态集目前要求<code>headless service</code>负责Pod的网络身份，你有责任创建此服务</li></ul><p><br></p><p><strong>组件(components)</strong></p><ul><li><code>headless service</code>，用于控制网络域</li><li><code>StatefulSet</code></li><li><code>volumeClaimTemplates</code>，使用持久化卷提供稳定存储</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span> <span class="comment"># has to match .spec.template.metadata.labels</span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">"nginx"</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span> <span class="comment"># by default is 1</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span> <span class="comment"># has to match .spec.selector.matchLabels</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      terminationGracePeriodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">k8s.gcr.io/nginx-slim:0.8</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">www</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="attr">  volumeClaimTemplates:</span></span><br><span class="line"><span class="attr">  - metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">www</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      accessModes:</span> <span class="string">[</span> <span class="string">"ReadWriteOnce"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">      storageClassName:</span> <span class="string">"my-storage-class"</span></span><br><span class="line"><span class="attr">      resources:</span></span><br><span class="line"><span class="attr">        requests:</span></span><br><span class="line"><span class="attr">          storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>Pod Selector</strong><br>必须设置有状态集的<code>.spec.selector</code>字段以匹配<code>.spec.template.metadata.labels</code>的标签。</p><p><br></p><p><strong>Pod Identity</strong><br>有状态集Pod有一个唯一的标识，由序数、稳定的网络表示和稳定的网络存储组成。</p><ul><li><p>Ordinal Index<br>对于有多个副本的有状态集，有状态集中的每个Pod将被分配一个唯一的整数序数(ordinal)，从0–(N-1)。</p></li><li><p>Stable Network ID<br>有状态集中的每个Pod都从有状态集的名称和Pod的序号中派生其主机名。构造的主机名的模式时<code>$(statefulset name)-$(ordinal)</code>。</p></li><li><p>Stable Storage<br>k8s为每个<code>VolumeClaimTemplate</code>创建一个<code>PersistentVolume</code>。</p></li><li><p>Pod Name Label<br>当有状态集控制器创建Pod时，它会添加一个标签<code>statefulset.kubernetes.io/pod-name</code>，该标签设置为Pod的名称。该标签允许你将服务附加到有状态集中的特定Pod。</p></li></ul><p><br></p><p><strong>部署和伸缩保证(guarantees)</strong></p><ul><li>对于有多个副本的有状态集，当Pod被部署时，它们按顺序从{0…N-1}被创建</li><li>但Pod被删除，它们将以{N-1…0}的相反顺序终止</li><li>在伸缩操作应用于Pod之前，所有的前置任务(predecessors)必须是Running和Ready</li><li>在终止Pod之前，其所有后继者(successors)必须完全关闭</li></ul><p>有状态集不应该指定<code>pod.Spec.TerminationGracePeriodSeconds</code>为0，这很不安全，强烈建议不要这么做。</p><p>k8s v1.7+，有状态集允许你放宽Pod管理策略的排序保证，同时通过其<code>.spec.podManagementPolicy</code>字段保留期唯一性和身份保证。<br><code>OrderedReady</code> pod管理是有状态集的默认设置。<br><code>Parallel</code> pod管理告诉有状态集控制器并行(parallel)启动或终止所有Pod，并且在启动或终止另一个Pod之前不等待Pod变为Running、Ready或完全终止。</p><p><br></p><p><strong>更新策略</strong><br>有状态集的<code>.spec.updateStrategy</code>字段允许你为有状态集中的Pod配置和禁用容器、标签、资源请求/限制、注释的自动更新。</p><p><br><br><br></p><h4 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h4><p>守护进程集确保所有(或某些)节点运行Pod的副本。随着节点添加到集群中，会将Pod添加到集群中。随着节点从集群中移除，Pod将被垃圾回收。删除一个守护进程集会清除它创建的Pod。</p><p>守护进程集的一些典型用法：</p><ul><li>在每个节点上运行集群存储守护进程</li><li>在每个节点上运行日志收集守护进程</li><li>在每个节点上运行一个节点监控守护进程</li></ul><p><br></p><p><strong>Writing a DaemonSet Spec</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">fluentd-logging</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      tolerations:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="attr">        effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">k8s.gcr.io/fluentd-elasticsearch:1.20</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          limits:</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">200</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">200</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">varlog</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/var/log</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/var/lib/docker/containers</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">varlog</span></span><br><span class="line"><span class="attr">        hostPath:</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/var/log</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line"><span class="attr">        hostPath:</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/var/lib/docker/containers</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#创建守护进程集</span><br><span class="line">kubectl create -f ./daemonset.yaml</span><br></pre></td></tr></table></figure><ul><li><p>Required Fields<br>与其它k8s配置一样，守护进程集需要<code>apiVersion</code>, <code>kind</code>, <code>metadata</code>, <code>.spec</code>字段。</p></li><li><p>Pod Template<br><code>.spec.template</code>是<code>.spec</code>的必要字段。<br>守护进程集中的人Pod模板必须要<code>RestartPolicy: Always(默认)</code>。</p></li><li><p>Pod Selector</p></li><li><p>仅在某些节点上运行Pod<br>如果指定了<code>.spec.template.spce.nodeSelector</code>，则守护进程控制器将在<code>node selector</code>匹配的节点上创建Pod。同样，如果指定了<code>.spec.template.spec.affinity</code>，则守护进程控制器将在与该节点关联匹配的节点上创建Pod。<br>如果未指定任何一个，则守护进程控制器将在所有节点上创建Pod。</p></li></ul><p><br></p><p><strong>Daemon Pods如何调度</strong></p><ul><li><p>由守护进程集控制器调度（默认）<br>通常，Pod运行的机器由k8s调度程序选择。然而，由守护进程集控制器创建的Pod已经选择了机器(<code>.spec.nodeName</code>)。</p></li><li><p>由默认调度器调度<br>功能阶段： k8s v1.11 <code>alpha</code><br>守护进程集确保所有符合条件的节点都运行Pod的副本。</p></li><li><p>Taints and Tolerations</p></li></ul><p><br></p><p><strong>Daemon Pods间通信</strong><br>守护进程集中Pod通信的一些可能模式：</p><ul><li>Push</li><li>NodeIP and Known Port</li><li>DNS</li><li>Service</li></ul><p><br></p><p><strong>更新DaemonSet</strong><br>如果更改了节点标签，守护进程集会立即将Pod添加到新匹配的节点，并从新匹配的节点中删除Pod。<br>可以修改守护进程集创建的Pod。然而，Pod不允许更新所有字段。同样，守护进程集控制器在下次创建节点时使用原始模板。<br>你也可以删除守护进程集，若指定了<code>--cascade=false</code>，则会在节点上保留Pod。</p><p><br></p><p><strong>守护进程集的替代方案</strong></p><ul><li>Init Scripts</li><li>Bare Pods</li><li>Static Pods</li><li>Deployments</li></ul><p><br><br><br></p><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>Garbage Collection</p><p>k8s垃圾回收的作用是删除曾经拥有所有者，但不再拥有所有者的某些对象。</p><p><br></p><p><strong>Owners and dependents</strong><br>一些k8s对象是其它对象的所有者。如副本集是一组Pod的所有者。拥有的对象称为所有者的依赖项(dependents)。每个依赖对象都有一个<code>metadata.ownerReferences</code>字段来指向所有者。</p><p><br></p><p><strong>控制垃圾回收器如何删除依赖项</strong><br>删除对象时，可以指定是否也自动删除对象的依赖项。<br>删除对象而不自动删除依赖项，则称依赖项为孤立对象(orphaned)。<br>自动删除依赖项被称为级联删除(cascading deletion)，这有两种级联删除模式：</p><ul><li>Foreground</li><li>Background</li></ul><p><br></p><p><strong>设置级联删除策略</strong><br>删除对象时，设置<code>deleteOptions</code>参数的<code>propagationPolicy</code>字段来控制级联删除策略。</p><p><br><br><br></p><h4 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h4><p>Jobs - Run to Completion</p><p>作业创建一个或多个Pod，并确保指定数量的Pod成功终止。随着Pod成功完成，作业跟踪也成功完成。删除作业将清除它创建的Pod。<br>作业还可用于并行运行多个Pod。</p><p><br></p><p><strong>栗子</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">perl</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">["perl",</span>  <span class="string">"-Mbignum=bpi"</span><span class="string">,</span> <span class="string">"-wle"</span><span class="string">,</span> <span class="string">"print bpi(2000)"</span><span class="string">]</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"><span class="attr">  backoffLimit:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f ./job.yaml</span><br><span class="line">job.batch/pi created</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl get job</span><br><span class="line">kubectl describe job/pi</span><br><span class="line">kubectl get pod</span><br><span class="line"></span><br><span class="line">kubectl logs pi-xxx</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Job Spec</strong><br>与其它k8s配置一样，Job也需要<code>apiVersion</code>, <code>kind</code>, <code>metadata</code>, <code>.spec</code>字段。</p><ul><li><p>Pod Template<br><code>.spec.template</code>是<code>.spce</code>字段的必要项。</p></li><li><p>Pod Selector<br><code>.spec.selector</code>字段可选。</p></li><li><p>Parallel Jobs: 有三种主要类型作业</p><ul><li>Non-parallel Jobs<ul><li>通常指启动一个Pod，除非Pod失败</li><li>Pod成功终止后，作业即告完成</li></ul></li><li>Parallel Jobs with a fixed completion count<ul><li>为<code>.spec.completions</code>指定非零正值</li><li>当1-<code>.spec.completions</code>范围内的每个值都有一个成功的Pod时，作业就完成了</li><li>尚未实施，每个Pod都传递了1-<code>.spec.completions</code>范围内不同的索引</li></ul></li><li>Parallel Jobs with a work queue<ul><li>每个Pod独立地确定是否所有对等都完成，因此整个Job完成</li><li>当任何Pod成功终止，不会创建新的Pod</li><li>一旦至少一个Pod成功终止并且所有Pod终止，则作业成功完成</li><li>一旦任意Pod已成功退出，其它任何Pod都不应该做任何工作或输出</li></ul></li></ul></li></ul><p><strong>控制并行</strong><br>Controlling Parallelism</p><p>请求的并行性(<code>.spec.parallelism</code>)可以设置为任何非负值。如果未指定，则默认为1.如果指定为0，则作业将暂停，直至其增加。<br>由于各种原因，实际并行性(在任何时刻运行的Pod数量)可能多于或少于请求的并行度：</p><ul><li>对于固定完成计数的作业，并行运行的实际Pod数不会超过剩余的Pod数</li><li>对于工作多列作业，任何Pod成功后都不会启动新的Pod，但允许剩余的Pod完成</li><li>如果控制器没有时间做出反应</li><li>如果控制器因任何原因无法创建Pod</li><li>由于同一作业中过多的先前Pod故障，控制器可能会限制新的Pod创建</li><li>当Pod正常关闭时，停止需要一些时间</li></ul><p><br></p><p><strong>处理Pod和Container失败</strong><br>Pod中的容器可能由于多种原因而失败，如果发生此情况，并且<code>.spec.template.spec.restartPolicy = &quot;OnFailure&quot;</code>，那么Pod会留在节点上，但容器会重新运行。因此，你的程序需要在本地处理此情况，或指定<code>.spec.template.spec.restartPolicy = &quot;Never&quot;</code>。</p><p>一个完整的Pod也可能由于多种原因而失败。当Pod失败时，作业控制器启动一个新的Pod。因此，你的程序需要在新Pod重启时处理此情况。</p><p><br></p><p><strong>Pod Backoff failure policy</strong><br>在某些情况下，由于配置中的逻辑错误等原因，你需要在重试一段时间后使作业失败。为此，可设置<code>.spec.backoffLimit</code>将作为视为失败前的重试次数。默认值为6s。与作业关联的失败的Pod由作业控制器重新创建，指数退避延迟(10s, 20s, 40s…)，上限6分钟。如果在作业的下一次状态检查之前没有出现新的故障Pod，则重置退避计数。</p><p><br></p><p><strong>作业终止和清理</strong><br>Job Termination and Cleanup</p><p>作业完成后，不会再创建Pod，也不会删除Pod。保持它们可让你仍然能查看已完成的Pod的日志以检查error, warning, 或其它诊断性输出。作业对象在完成后也会保留，以便可查看其状态。在注意到其状态后，用户可删除旧的作业。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#一并删除作业创建的Pod</span><br><span class="line">kubectl delete jobs/xxx</span><br><span class="line"></span><br><span class="line">#不删除作业创建的Pod</span><br><span class="line">kubectl delete jobs/xxx --</span><br></pre></td></tr></table></figure><p>默认情况下，除非Pod失败，否则作业将不间断运行，此时作业将延迟到上述的<code>.spec.backoffLimit</code>。终止作业的另一种方法是设置活动截止日期，通过设置<code>.spec.activateDeadlineSeconds</code>字段来执行此操作。请注意，作业的<code>.spec.activateDeadlineSeconds</code>优先于<code>.spec.backoffLimit</code>。因此，重试一个或多个失败的Pod的作业在达到<code>activeDeadlineSeconds</code>指定的时间限制后将不会重置其它Pod，即使尚未达到<code>backoffLimit</code>也是如此。</p><p><br></p><p><strong>作业模式</strong><br>Job Patterns</p><p>作业对象可用于支持Pod的可靠并行执行，它不是为了支持紧密通信的并行进程而设计。<br>在复杂系统中，可能存在多组不同的工作项。这里只考虑一组工作项——批处理作业</p><p>并行计算有几种不同的模式，每种模式都有有点和缺点：</p><ul><li>一个工作项一个作业对象 vs 所有工作项一个作业对象</li><li>创建的Pod数等于工作项数 vs 每个Pod可以处理多个工作项</li><li>多个方法使用一个工作队列</li></ul><p><br></p><p><strong>高级用法</strong><br>Advanced Usage</p><ul><li>指定自己的Pod selector<br>通常，创建作业对象时，不会指定<code>.spec.selector</code>。系统默认在创建作业时添加此字段。然而，在某些情况下，你可能需要设置它。这样做的时候要非常小心，如果你指定的label selector不是该作业的Pod所独有，并且与不想关的Pod匹配，则可能会删除不相关作业的Pod。如果选择了non-unique selector，则其它控制器及其Pod也可能以不可预测的方式进行。在指定<code>.spec.selector</code>时，k8s不会阻止你犯错误。</li></ul><p><br></p><p><strong>替代方案</strong><br>Alternatives</p><ul><li>Bare Pods</li><li>Replication Controller</li><li>Single Job starts Controller Pod</li></ul><p><br></p><p><strong>Cron Jobs</strong><br>在指定的时间/日期创建作业。</p><p><br><br><br></p><h4 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h4><p>Cron Job基于时间调度创建作业。<br>一个定时任务对象类似于crontab中的一行。它以给定的时间周期性运行作业。</p><p><strong>注意： 所有定时作业调度， 时间以UTC表示。</strong></p><p><br></p><p><strong>定时作业局限</strong><br>Cron Job Limitations</p><p>定时作业在其计划的每个执行时间创建一个作业对象。<br>如果<code>startingDeadlineSeconds</code>被设置为较大值或未设置(默认值)，并且<code>concurrencyPolicy</code>设置为Allow，则作业将始终至少运行一次。<br>如果设置了<code>startDeadlineSeconds</code>字段，则控制器会计算从<code>startingDeadlineSeconds</code>的值到现在发生的错过的作业数，而不是从上一个计划时间到现在。<br>如果定时作业未能在其预定时间创建，则将其视为未命中。</p><p>定时作业仅负责创建与其计划相匹配的作业，而作业则负责管理它所代表的Pod。</p><p><br><br><br><br><br></p><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>Configuration</p><p><br></p><h3 id="配置最佳实践"><a href="#配置最佳实践" class="headerlink" title="配置最佳实践"></a>配置最佳实践</h3><p>Configuration Best Practices</p><p><br></p><h4 id="一般配置技巧"><a href="#一般配置技巧" class="headerlink" title="一般配置技巧"></a>一般配置技巧</h4><p>General Configuration Tips</p><ul><li>定义配置时，请指定最新的稳定的API版本</li><li>在推送到集群之前，配置文件应存储在版本控制系统中。这允许你在必要时快速回滚配置，有助于集群重建和恢复</li><li>使用YMAL而不是JSON来编写配置文件，YAML格式更用户友好</li><li>只要有意义，就将相关对象分组到一个文件中。管理一个文件比管理一堆文件更便捷</li><li>可以在目录上调用许多<code>kubectl</code>命令。例如，你可在配置文件目录上调用<code>kubectl create</code></li><li>不要不必要地指定默认值</li><li>将对象描述写在注释中，以便更好进行内省</li></ul><p><br><br><br></p><h4 id="Naked-Pod-vs-副本集，部署和作业"><a href="#Naked-Pod-vs-副本集，部署和作业" class="headerlink" title="Naked Pod vs 副本集，部署和作业"></a>Naked Pod vs 副本集，部署和作业</h4><p>“Naked” Pods vs ReplicaSets, Deployments, and Jobs</p><ul><li>不要使用Naked Pods(即未绑定到副本集或部署的Pod)<br>如果节点发生故障，裸Pod将不会被重新调度。</li></ul><p><br><br><br></p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>Service</p><ul><li><p>在相应的后端工作负载(部署或副本集)访问它之前创建服务<br>当k8s启动容器时，它提供指向启动容器时正在运行的所有服务的环境变量。</p></li><li><p>除非绝对必要，否则不要为Pod指定hostPort<br>将Pod绑定到hostPort时，它会限制Pod可调度的位置数。因为每个<code>hostIP, hostPort, protocol</code>的组合必须是独特的。如果没有指定hostIp和protocol，k8s将使用<code>0.0.0.0</code>作为默认的hostIP，使用TCP作为默认协议。</p></li></ul><p>如果你只需要访问端口以进行调试，可使用<code>apiserver proxy</code>或<code>kubectl port-forward</code>。<br>如果你需要公开节点上Pod的端口，考虑使用<code>NodePort</code>服务。</p><ul><li>避免使用hostNetwork， 原因与hostPort类似</li><li>当不需要<code>kube-proxy</code>负载均衡时，使用 headless Services可轻松服务发现</li></ul><p><br><br><br></p><h4 id="使用标签"><a href="#使用标签" class="headerlink" title="使用标签"></a>使用标签</h4><p>Using Labels</p><ul><li>为你的应用程序或部署定义和使用标签<br>你可使用这些标签为其它资源筛选合适的Pod</li></ul><p><br><br><br></p><h4 id="容器镜像"><a href="#容器镜像" class="headerlink" title="容器镜像"></a>容器镜像</h4><p>Container Images</p><ul><li>默认的镜像拉取策略。对于容器是<code>ifNotPresent</code>，kubelet只有在本地镜像不存在时才拉取镜像。如果希望每次k8s启动容器时都拉取镜像，请指定<code>imagePullPolicy: Always</code>。<br>一个已弃用的替代方案。设置k8s总是拉取镜像的<code>:latest</code>标记，它会隐式地将<code>imagePullPolicy</code>设置为<code>Always</code>。</li></ul><p><strong>注意： 在生产环境中部署容器时，你应该避免使用<code>:latest</code>标记，因为这使得正在运行的镜像版本难以回滚。</strong><br>如果镜像使用<code>:latest</code>标记，回滚的话其实需要回滚代码，然后打包上线，然后触发动态更新，之后就还原成了之前的版本。这样确实要复杂很缓慢一些。</p><ul><li>确保容器使用使用相同版本的镜像</li></ul><p><br><br><br></p><h4 id="使用kubectl"><a href="#使用kubectl" class="headerlink" title="使用kubectl"></a>使用kubectl</h4><ul><li><p>使用<code>kubectl apply -f &lt;directory&gt;</code> 或 <code>kubectl create -f &lt;directory&gt;</code><br>它在此目录中所有<code>.yaml</code>, <code>.yml</code>, <code>.json</code>文件汇总寻找k8s配置配置文件，并将其传递给kubectl。</p></li><li><p>使用label selectors进行<code>get</code>和<code>delete</code>操作，而不是特定的对象名称</p></li><li>使用<code>kubectl run</code>和<code>kubectl expose</code>快速创建单容器部署和服务</li></ul><p><br><br><br></p><h3 id="管理容器的计算资源"><a href="#管理容器的计算资源" class="headerlink" title="管理容器的计算资源"></a>管理容器的计算资源</h3><p>Managing Compute Resources for Containers</p><p>指定Pod时，可以选择指定每个容器需要多少CPU和MEM。当容器指定了请求(requests)的资源时，调度器可以更好地决定将Pod放在哪个节点上。当容器指定了限制(limit)时，可以以指定的方式处理节点上资源的争用。</p><p><br><br><br></p><h4 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h4><p>Resource types</p><p>CPU和MEM都是资源类型。资源类型具有基本单元(unix)。CPU以核(<code>cores</code>)为指定单位，MEM以字节(<code>Byte</code>)为指定单位。<br>CPU和MEM统称为计算资源，或资源。计算资源是可以请求，分配和使用的可测量数据。它们与API资源不同。API资源(如Pod和Service)，是可通过k8s APIserver读取和修改的对象。</p><p><br><br><br></p><h4 id="资源的请求和限制"><a href="#资源的请求和限制" class="headerlink" title="资源的请求和限制"></a>资源的请求和限制</h4><p>Resource requests and limits of Pod and Container</p><p>Pod中的容器都可指定一个或多个限制：</p><ul><li><code>spec.containers[].resources.limits.cpu</code></li><li><code>spec.containers[].resources.limits.memory</code></li><li><code>spec.containers[].resources.requests.cpu</code></li><li><code>spec.containers[].resources.requests.memory</code></li></ul><p>虽然只能在单独的容器上指定请求和限制，但是讨论Pod资源的请求和限制很方便。特定资源类型的Pod资源 请求/限制 是Pod中每个容器的该类型的资源 请求/限制 的总和。</p><p><br><br><br></p><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>Meaning of CPU</p><p>CPU资源的限制和请求以CPU单位进行测量。在k8s中，1 cpu等于：</p><ul><li>1 AWS vCPU</li><li>1 GCP Core</li><li>1 Azure vCore</li><li>1 IBM vCPU</li><li>1 Hyperthread on a bare-metal Intel processor with Hyperthreading</li></ul><p>允许分数请求。如<code>spec.containers[].resources.requests.cpu: 0.5</code>。表达式<code>0.1</code>相当于表达式<code>100m</code>。具有小数点的请求资源(如<code>0.1</code>)由API转换为<code>100m</code>，不允许精度小于<code>1m</code>。<br>始终要求CPU作为绝对数量，而不是相对数量。因此，<code>0.1</code>单元对于单核，双核，八核机器上的CPU资源时相同的。</p><p><br><br><br></p><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p>Meaning of memory</p><p>内存的限制和请求以字节为单位。<br>你可使用以下后缀来表示整数内存: <code>E, P, T, G, M, K</code>；<br>你还还可以使用2的幂等: <code>Ei, Pi, Ti, Gi, Mi, Ki</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#相同值的不同表达</span><br><span class="line">128974848</span><br><span class="line">129e6</span><br><span class="line">129M</span><br><span class="line">123Mi</span><br></pre></td></tr></table></figure><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: db</span><br><span class="line">    image: mysql</span><br><span class="line">    env:</span><br><span class="line">    - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">      value: &quot;password&quot;</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        memory: &quot;64Mi&quot;</span><br><span class="line">        cpu: &quot;250m&quot;</span><br><span class="line">      limits:</span><br><span class="line">        memory: &quot;128Mi&quot;</span><br><span class="line">        cpu: &quot;500m&quot;</span><br><span class="line">  - name: wp</span><br><span class="line">    image: wordpress</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        memory: &quot;64Mi&quot;</span><br><span class="line">        cpu: &quot;250m&quot;</span><br><span class="line">      limits:</span><br><span class="line">        memory: &quot;128Mi&quot;</span><br><span class="line">        cpu: &quot;500m&quot;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="如何调度具有资源请求的Pod"><a href="#如何调度具有资源请求的Pod" class="headerlink" title="如何调度具有资源请求的Pod"></a>如何调度具有资源请求的Pod</h4><p>How Pods with resource requests are scheduled</p><p>创建Pod时，k8s调度器会选择要运行Pod的节点。每个节点都具有每种资源类型的最大容量，它可为Pod提供CPU和MEM。调度程序确保对于每种资源类型，调度的容器的资源请求总和小于节点的容量。请注意，即使节点上的实际内存或CPU资源使用率非常低，但如果容量检查失败，调度器扔拒绝在节点上放置Pod。当资源使用随后增加时，这可以防止节点上的资源短缺。</p><p><br><br><br></p><h4 id="如何运行具有资源限制的Pod"><a href="#如何运行具有资源限制的Pod" class="headerlink" title="如何运行具有资源限制的Pod"></a>如何运行具有资源限制的Pod</h4><p>How Pods with resource limits are run</p><p>当<code>kubelet</code>启动Pod中的容器时，它会将CPU和MEM限制传递给容器运行环境。</p><p>当使用Docker时：</p><ul><li><p><code>spec.container[].resources.requests.cpu</code>被转换成core value，分数的话会乘以1024。此数字中的较大值用作<code>docker run</code>命令中<code>--cpu-shares</code>标志的值</p></li><li><p><code>spec.container[].resources.limits.cpu</code>被转换为millicore value并乘以100。结果值代表容器每100ms可以使用的CPU时间总量。<br>在此间隔期间，容器不能使用超过其CPU时间的份额。<br>默认配额时间是100ms，CPU配额的最小解析为1ms。</p></li></ul><ul><li><code>spec.containers[].resources.limits.memory</code>被转换为整数，并用作<code>docker run</code>命令中<code>--memory</code>标志的值</li></ul><p>如果容器超出其内存限制(mem limit)，则容器可能会终止。如果它可以重启，则kubelet将重启它；<br>如果容器超出其内存请求(mem request)，当节点内存不足时，它的Pod可能会被驱逐；<br>容器可能会/可能不会被允许在较长时间内超过其CPU限制。但是，它不会因CPU使用率过高而被杀死。</p><p><br><br><br></p><h4 id="监控计算资源使用"><a href="#监控计算资源使用" class="headerlink" title="监控计算资源使用"></a>监控计算资源使用</h4><p>Monitoring compute resource usage</p><p>Pod的资源使用情况将作为Pod Status的一部分进行上报。</p><p><br><br><br></p><h4 id="本地短暂存储"><a href="#本地短暂存储" class="headerlink" title="本地短暂存储"></a>本地短暂存储</h4><p>Local ephemeral storage</p><p>FEATURE STATE: Kubernetes v1.11 beta</p><p>k8s v1.8介绍了一种新资源，用于管理本地短暂存储的短暂存储(ephemeral-storage)。在每个k8s 节点上，kubelet的根目录(默认<code>/var/lib/kubelet</code>)和日志目录(<code>/var/log</code>)存储在节点的根分区上。Pod还通过<code>emptyDir volume</code>，容器日志，镜像层，容器可写层共享和使用此分区。<br>此分区是短暂的，应用程序不能指望来自此分区的任何SLA(如磁盘IO)。本地临时存储仅适用于根分区，镜像层和可写层的可选分区超出了范围。</p><p><br></p><p><strong>本地短暂存储的请求和限制设置</strong><br>Requests and limits setting for local ephemeral storage</p><p>Pod中的容器可指定一个或多个短暂存储：</p><ul><li><code>spec.containers[].resources.limits.ephemeral-storage</code></li><li><code>spec.containers[].resources.requests.ephemeral-storage</code></li></ul><p>短暂存储的限制和请求以字节(<code>Byte</code>)为单位。<br>你可以使用一下后缀表示整数存储: <code>E, P, T, G, M, K</code>；<br>你也可以使用2的幂等: <code>Ei, Pi, Ti, Gi, Mi, Ki</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">128974848</span><br><span class="line">129e6</span><br><span class="line">129M</span><br><span class="line">123Mi</span><br></pre></td></tr></table></figure><p><br></p><p>栗子： Pod由两个容器，每个容器都有2GiB的本地短暂存储请求，4GiB的本地短暂存储限制。因此，总共是4GiB请求，8GiB限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: db</span><br><span class="line">    image: mysql</span><br><span class="line">    env:</span><br><span class="line">    - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">      value: &quot;password&quot;</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        ephemeral-storage: &quot;2Gi&quot;</span><br><span class="line">      limits:</span><br><span class="line">        ephemeral-storage: &quot;4Gi&quot;</span><br><span class="line">  - name: wp</span><br><span class="line">    image: wordpress</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        ephemeral-storage: &quot;2Gi&quot;</span><br><span class="line">      limits:</span><br><span class="line">        ephemeral-storage: &quot;4Gi&quot;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>如何调度具有本地短暂存储的Pod</strong><br>How Pods with ephemeral-storage requests are scheduled</p><p>对于容器级的隔离，如果容器的可写层和日志使用量超过其存储限制，则Pod将被驱逐。对于Pod级别的隔离，如果所有容器的本地短暂存储使用量与Pod的<code>emptyDir volume</code>的总和超过了限制，则Pod将被驱逐。</p><p><br><br><br></p><h4 id="扩展的资源"><a href="#扩展的资源" class="headerlink" title="扩展的资源"></a>扩展的资源</h4><p>Extended resources</p><p>扩展资源是<code>kubernetes.io</code>域之外的完全限定资源名称。它们允许集群操作者通告和用户使用非k8s内置资源。<br>使用扩展资源需要两个步骤，首先，集群操作者必须通告扩展资源；其次，用户必须在Pod中请求扩展资源。</p><p><br></p><p><strong>节点级扩展资源</strong><br>节点级扩展资源与节点相关联。</p><p><br></p><p><strong>集群级扩展资源</strong><br>集群级扩展资源不依赖与节点。它们通常由调度器扩展程序管理——它处理资源消耗和资源配额。</p><p><br></p><p><strong>使用扩展资源</strong><br>用户可以在<code>pod spec</code>中项CPU和MEM一样使用扩展资源。调度程序负责资源核算，以便不会同时为Pod分配可用的数量。<br>API server将扩展资源的数量限制为整数。</p><p>要在Pod中使用扩展资源，在<code>container spec</code>中的<code>spec.container[].resources.limits</code>映射中包含资源名称作为键。<br>只有满足所有请求资源时，才会调度Pod。只要无法满足资源请求，Pod就会保持在<code>PENDING status</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: my-container</span><br><span class="line">    image: myimage</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        cpu: 2</span><br><span class="line">        example.com/foo: 1</span><br><span class="line">      limits:</span><br><span class="line">        example.com/foo: 1</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="分配Pod到节点"><a href="#分配Pod到节点" class="headerlink" title="分配Pod到节点"></a>分配Pod到节点</h3><p>Assigning Pods to Nodes</p><p>你可以将Pod约束为只能在特定节点上运行，或更喜欢在特定节点上运行。有几种方法做到这一点，它们都使用<code>label selector</code>来进行选择。通常这种约束是不必要的，因为调度程序将自动进行合理的放置。但在某些情况下，你可能希望对Pod放置的节点进行更多控制。如确保Pod放置在安装有SSD的计算机上…</p><p><br><br><br></p><h4 id="节点选择器"><a href="#节点选择器" class="headerlink" title="节点选择器"></a>节点选择器</h4><p>nodeSelector</p><p>节点选择器是最简单的约束形式。<code>nodeSelector</code>是<code>PodSpecs</code>的一个字段，它指定了一个键值对的映射。要使Pod有资格在节点上运行，该节点必须将每个指示的的键值对作为标签。最常见的用法是一个键值对。</p><ul><li><p>Prerequisites<br>k8s 集群</p></li><li><p>Attach label to the node</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#获取节点名</span><br><span class="line">kubectl get node</span><br><span class="line">NAME      STATUS    ROLES     AGE       VERSION</span><br><span class="line">master    Ready     master    33d       v1.11.1</span><br><span class="line">node      Ready     &lt;none&gt;    33d       v1.11.1</span><br><span class="line">salt01    Ready     &lt;none&gt;    27d       v1.11.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#打标签</span><br><span class="line">kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;=&lt;label-value&gt;</span><br><span class="line"></span><br><span class="line">#查看标签</span><br><span class="line">kubectl get node --show-labels</span><br></pre></td></tr></table></figure><ul><li>Add a nodeSelector field to your pod configuration</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    env: test</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">  nodeSelector:</span><br><span class="line">    &lt;label-key&gt;: &lt;label-value&gt;</span><br></pre></td></tr></table></figure><p>当创建这个资源时，Pod将调度到附加此标签的节点上。</p><p><br><br><br></p><h4 id="内置节点标签"><a href="#内置节点标签" class="headerlink" title="内置节点标签"></a>内置节点标签</h4><p>built-in node labels</p><p>除了你附加的标签之外，节点还有一些预先填充的标准标签。</p><ul><li><code>kubernetes.io/hostname</code></li><li><code>failure-domain.beta.kubernetes.io/zone</code></li><li><code>failure-domain.beta.kubernetes.io/region</code></li><li><code>beta.kubernetes.io/instance-type</code></li><li><code>beta.kubernetes.io/os</code></li><li><code>beta.kubernetes.io/arch</code></li></ul><p><br><br><br></p><h4 id="亲和力和反亲和力"><a href="#亲和力和反亲和力" class="headerlink" title="亲和力和反亲和力"></a>亲和力和反亲和力</h4><p>Affinity and anti-affinity</p><p>节点选择器提供了一种非常简单的方法，使用特定标签约束Pod到特定节点。目前处于测试阶段的亲和力/反亲和力功能，极大地扩展了你可以表达的约束类型。关键的改进有：</p><ul><li>语言更具表达性</li><li>你可以指示规则是<code>soft/preference</code>而不是硬性要求，因此如果调度程序不能满足，也仍然会调度Pod</li><li>你可以约束运行在节点上的其它Pod的标签，而不是对节点本身的标签进行约束</li></ul><p>亲和力有两种类型：</p><ul><li>node-affinity</li><li>inter-pod affinity/anti-affinity</li></ul><p><br></p><p><strong>节点亲和力</strong><br>节点亲和力在概念上类似于nodeSelector，它允许你根据节点标签约束pod调度的节点。<br>目前有两种类型的节点亲和力：</p><ul><li><code>requiredDuringSchedulingIgnoredDuringExecution</code></li><li><code>preferredDuringSchedulingIgnoredDuringExecution</code></li></ul><p>你可将它们分别是为<code>hard</code>和<code>soft</code>，前者指定了将Pod调度到节点上必须满足的规则，后者指定调度程序将尝试执行但不保证的首选项。名称的<code>IgnoredDuringExecution</code>部分意味着，与节点选择器的工作方式类似，如果节点标签在运行时更改，而不再满足Pod的亲和力规则，则Pod将继续在节点上运行。<br>未来，我们计划提供<code>requiredDuringSchedulingRequiredDuringExecution</code>，就像Ignored一样，它将从不再满足Pod的亲和力要求的节点中驱逐Pod。</p><p>节点亲和力在<code>spec.affinity.nodeAffinity</code>字段中指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: with-node-affinity</span><br><span class="line">spec:</span><br><span class="line">  affinity:</span><br><span class="line">    nodeAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        nodeSelectorTerms:</span><br><span class="line">        - matchExpressions:</span><br><span class="line">          - key: kubernetes.io/e2e-az-name</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - e2e-az1</span><br><span class="line">            - e2e-az2</span><br><span class="line">      preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - weight: 1</span><br><span class="line">        preference:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: another-node-label-key</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - another-node-label-value</span><br><span class="line">  containers:</span><br><span class="line">  - name: with-node-affinity</span><br><span class="line">    image: k8s.gcr.io/pause:2.0</span><br></pre></td></tr></table></figure><p>此节点亲和力规则表示，Pod只能防止在<code>kubernetes.io/e2e-az-name</code>标签键，值为<code>e2e-az1</code>或<code>e2e-az2</code>的节点上。此外，在满足条件的节点中，应优先选择具有<code>another-node-label-key</code>键，值为<code>another-node-label-value</code>的节点。<br>节点亲和力语法支持如下操作符: <code>In, NotIn, Exists, DoesNotExist, Gt, Lt</code>。</p><p>如果你同时指定了<code>nodeSelector</code>和<code>nodeAffinity</code>，则必须满足两者以将Pod调度到候选节点上；<br>如果你指定了与<code>nodeAffinity</code>类型关联的多个<code>nodeSelectorTerms</code>。那么，如果满足其中一个<code>nodeSelectorTerms</code>，则可以将Pod调度到节点上；<br>如果你指定了与<code>nodeSelectorTerms</code>关联的多个<code>matchExpressions</code>。那么，只有满足所有<code>matchExpressions</code>的情况下，才能将Pod安排到节点上；<br>如果删除或更改调度Pod的节点标签，则Pod不会被删除。换句话说，亲和力仅在调度Pod时起作用。</p><p><br></p><p><strong>Pod间亲和力和反亲和力</strong><br>Pod间亲和力和反亲和力，你可以根据已在节点上运行的Pod上的标签(而不是节点标签)，来约束Pod可以调度的节点。与节点不同，Pod有命名空间，Pod标签的标签选择器必须指定选择器应该应用于哪些命名空间。</p><p>注意： Pod间亲和力和反亲和力需要大量的处理，可会显著减慢大型集群中的调度。因此，不建议在大于几百个节点的集群中使用；<br>注意： Pod反亲和力要求节点一致地标签节点，即集群中的每个节点都必须具有匹配的<code>topologyKey</code>标签，如果某些节点缺少，可能会导致意外情况。</p><p>目前有两种类型的Pod亲和力和反亲和力:</p><ul><li><code>requiredDuringSchedulingIgnoredDuringExecution</code></li><li><code>preferredDuringSchedulingIgnoredDuringExecution</code></li></ul><p>同样表示<code>hard</code>和<code>soft</code>要求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: with-pod-affinity</span><br><span class="line">spec:</span><br><span class="line">  affinity:</span><br><span class="line">    podAffinity:</span><br><span class="line">      requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - labelSelector:</span><br><span class="line">          matchExpressions:</span><br><span class="line">          - key: security</span><br><span class="line">            operator: In</span><br><span class="line">            values:</span><br><span class="line">            - S1</span><br><span class="line">        topologyKey: failure-domain.beta.kubernetes.io/zone</span><br><span class="line">    podAntiAffinity:</span><br><span class="line">      preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">      - weight: 100</span><br><span class="line">        podAffinityTerm:</span><br><span class="line">          labelSelector:</span><br><span class="line">            matchExpressions:</span><br><span class="line">            - key: security</span><br><span class="line">              operator: In</span><br><span class="line">              values:</span><br><span class="line">              - S2</span><br><span class="line">          topologyKey: kubernetes.io/hostname</span><br><span class="line">  containers:</span><br><span class="line">  - name: with-pod-affinity</span><br><span class="line">    image: k8s.gcr.io/pause:2.0</span><br></pre></td></tr></table></figure><p>Pod亲和力和反亲和力的有效操作符有: <code>In, NotIn, Exists, DoesNotExist</code><br>原则上，<code>topologyKey</code>可以是任一合法的<code>label-key</code>。但是，出于性能和安全的原因，它也有一些限制：</p><ul><li>对于亲和力和<code>requiredDuringSchedulingIgnoredDuringExecution</code>的Pod的反亲和力，不允许使用空的<code>topologykey</code></li><li>对于<code>requiredDuringSchedulingIgnoredDuringExecution</code>的Pod的反亲和力，引入控制器<code>LimitPodHardAntiAffinityTopology</code>是为了将<code>topologyKey</code>限制为<code>kubernetes.io/hostname</code>。如果要使其可用于自定义，可修改控制器，或禁用它</li><li>对于<code>preferredDuringSchedulingIgnoredDuringExecution</code>的Pod的反亲和力，空的<code>topologyKey</code>被解释为<code>all topologies</code></li><li>除了上面提到的，<code>topologyKey</code>可以是任一合法的<code>label-key</code></li></ul><p>除了<code>labelSelector</code>和<code>topologyKey</code>之外，你还可以选择指定<code>labelSelector</code>应匹配的命名空间。如果为空或省略，则默认为Pod的亲和力/反亲和力的命名空间。</p><p><br><br><br></p><h3 id="污点和容忍"><a href="#污点和容忍" class="headerlink" title="污点和容忍"></a>污点和容忍</h3><p>Taints and Tolerations</p><p>节点亲和力是Pod的属性，它将它们吸引到节点；Taints则相反——它允许节点排斥Pod。<br>Taints 和 Tolerations 一起工作以确保Pod不被安排的不适当的节点上。将一个或多个污点(taints)应用于节点，这标志着节点不应该接受任何不能容忍污点的Pod。容忍(tolerations)应用于Pod，并允许Pod安排到具有匹配污点的节点上。</p><p><br></p><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>使用<code>kubectl taint</code>命令对节点添加污染:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#除非具有匹配的容忍，否则不会将Pod调度到此节点上</span><br><span class="line">kubectl taint nodes &lt;node-name&gt; key=value:NoSchedule</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">kubectl taint nodes &lt;node-name&gt; key:NoSchedule-</span><br></pre></td></tr></table></figure><p>你可以在<code>PodSpec</code>的指定Pod的容忍度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tolerations:</span><br><span class="line">- key: &quot;key&quot;</span><br><span class="line">  operator: &quot;Equal&quot; #default</span><br><span class="line">  value: &quot;value&quot;</span><br><span class="line">  effect: &quot;NoSchedule&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tolerations:</span><br><span class="line">- key: &quot;key&quot;</span><br><span class="line">  operator: &quot;Exists&quot;</span><br><span class="line">  effect: &quot;NoSchedule&quot;</span><br></pre></td></tr></table></figure><p><br></p><p><code>effect</code>的三个选项：</p><ul><li><code>NoSchedule</code></li><li><code>PreferNoSchedule</code>: soft of NoSchedule</li><li><code>NoExecute</code></li></ul><p>你可在同一个节点上放置多个污点，并在同一个Pod上放置多个容忍。k8s处理多个污点和容忍的方式就像一个过滤器：从节点的所有污点开始，忽略Pod匹配的容忍度的那些，剩下的未被忽略的污点对Pod有明显的影响。尤其是：</p><ul><li>如果至少有一个未被忽略的<code>effect</code>为<code>NoSchedule</code>的污点，则k8s将不会调度Pod到该节点</li><li>如果没有<code>effect</code>为<code>NoSchedule</code>，但至少有一个未被忽略的<code>effect</code>为<code>PreferNoSchedule</code>的污点，则k8s将尝试不将Pod调度到该节点</li><li>如果至少有一个未被忽略的<code>effect</code>为<code>NoExecute</code>的污点，则Pod将从节点驱逐(如果它已经在节点上运行)，并且不会被调度到该节点上</li></ul><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes node1 key1=value1:NoSchedule</span><br><span class="line">kubectl taint nodes node1 key1=value1:NoExecute</span><br><span class="line">kubectl taint nodes node1 key2=value2:NoSchedule</span><br></pre></td></tr></table></figure><p>有两个容忍度的Pod：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="attr">- key:</span> <span class="string">"key1"</span></span><br><span class="line"><span class="attr">  operator:</span> <span class="string">"Equal"</span></span><br><span class="line"><span class="attr">  value:</span> <span class="string">"value1"</span></span><br><span class="line"><span class="attr">  effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line"><span class="attr">- key:</span> <span class="string">"key1"</span></span><br><span class="line"><span class="attr">  operator:</span> <span class="string">"Equal"</span></span><br><span class="line"><span class="attr">  value:</span> <span class="string">"value1"</span></span><br><span class="line"><span class="attr">  effect:</span> <span class="string">"NoExecute"</span></span><br></pre></td></tr></table></figure><p>对于<code>NoExecute</code>的容忍度可以指定一个可选<code>tolerationSeconds</code>字段，它指示在添加污点后Pod将保持绑定到节点的时间：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="attr">- key:</span> <span class="string">"key1"</span></span><br><span class="line"><span class="attr">  operator:</span> <span class="string">"Equal"</span></span><br><span class="line"><span class="attr">  value:</span> <span class="string">"value1"</span></span><br><span class="line"><span class="attr">  effect:</span> <span class="string">"NoExecute"</span></span><br><span class="line"><span class="attr">  tolerationSeconds:</span> <span class="number">3600</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>Example Use Cases</p><p>污点和容忍是一种灵活的方式来引导Pod远离节点或驱逐不应该运行的Pod。一些栗子：</p><ul><li><strong>专用节点(Dedicated Nodes)</strong></li><li><strong>特殊硬件的节点(Nodes with Special Hardware)</strong></li><li><strong>基于污点的驱逐(Taint based Evictions)</strong></li></ul><p><br><br><br></p><h4 id="Taint-based-Evictions"><a href="#Taint-based-Evictions" class="headerlink" title="Taint based Evictions"></a>Taint based Evictions</h4><p>内置的污点：</p><ul><li><code>node.kubernetes.io/not-ready</code></li><li><code>node.kubernetes.io/unreachable</code></li><li><code>node.kubernetes.io/out-of-disk</code></li><li><code>node.kubernetes.io/memory-pressure</code></li><li><code>node.kubernetes.io/disk-pressure</code></li><li><code>node.kubernetes.io/network-unavailable</code></li><li><code>node.kubernetes.io/unschedulable</code></li><li><code>node.cloudprovider.kubernetes.io/uninitialized</code></li></ul><p>使用<code>NoExecute</code>容忍的DaemonSet Pod为以下污点创建，没有<code>tolerationSeconds</code>：</p><ul><li><code>node.alpha.kubernetes.io/unreachable</code></li><li><code>node.kubernetes.io/not-ready</code></li></ul><p>这可确保DaemonSet Pod永远不会因为这个问题而被驱逐，这与禁用此功能时的行为相匹配。</p><p><br><br><br></p><h4 id="按条件污染节点"><a href="#按条件污染节点" class="headerlink" title="按条件污染节点"></a>按条件污染节点</h4><p>Taint Nodes by Condition</p><p>节点控制器创建对应于节点条件的污点。当启用此功能，调度程序不检查节点条件，调度程序检查污点。这可确保节点条件不会影响节点上的调度。用户可以通过添加适当的Pod容忍来选择忽略节点的一些问题。</p><p>DaemonSet controller自动将一下<code>NoSchedule</code>的容忍度添加到所有的守护进程，以防止守护进程破坏：</p><ul><li><code>node.kubernetes.io/memory-pressure</code></li><li><code>node.kubernetes.io/disk-pressure</code></li><li><code>node.kubernetes.io/out-of-disk</code> (only for critical pods)</li><li><code>node.kubernetes.io/unschedulable</code> (1.10 or later)</li><li><code>node.kubernetes.io/network-unavailable</code> (host network only)</li></ul><p>添加这些容忍度可确保向后兼容，你还可以向DaemonSet添加任意容忍度。</p><p><br><br><br></p><h3 id="Secrets"><a href="#Secrets" class="headerlink" title="Secrets"></a>Secrets</h3><p><code>Secrets</code>类型的对象旨在保存敏感信息，如密码、OAuth token、ssh keys。把这些敏感信息放在<code>Secrets</code>中比将其放在Pod中或image中更安全、更灵活。</p><p><br></p><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>用户和系统都可以创建一些秘密(Secrets)。<br>要使用秘密，Pod需要引用该秘密。秘密可以通过两种方式与Pod一起使用：</p><ul><li>作为挂载到容器中的卷中的文件</li><li>为Pod拉取镜像时由<code>kubelet</code>使用的文件</li></ul><p><br></p><h5 id="内建的秘密"><a href="#内建的秘密" class="headerlink" title="内建的秘密"></a>内建的秘密</h5><p>Built-in Secrets</p><p><strong>Service Accounts Automatically Create and Attach Secrets with API Credentials</strong><br>k8s会自动创建包含用于访问API的证书的秘密，并自动修改Pod以使用此类秘密。你可禁用它，但不推荐。</p><p><br></p><h5 id="创建自己的秘密"><a href="#创建自己的秘密" class="headerlink" title="创建自己的秘密"></a>创建自己的秘密</h5><p>Creating your own Secrets</p><p><br></p><p><strong>使用kubectl创建秘密(Creating a Secret Using kubectl create secret)</strong><br>假设一些Pod需要访问数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ echo -n &apos;admin&apos; &gt; ./username.txt</span><br><span class="line">$ echo -n &apos;1f2d1e2e67df&apos; &gt; ./password.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建秘密</span><br><span class="line">$ kubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt</span><br><span class="line">secret/db-user-pass created</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">#默认都不会显示文件内容，为了安全</span><br><span class="line">kubectl get secrets</span><br><span class="line"></span><br><span class="line">kubectl describe secrets/db-user-pass</span><br><span class="line">Name:         db-user-pass</span><br><span class="line">Namespace:    default</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"></span><br><span class="line">Type:  Opaque</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">password.txt:  12 bytes</span><br><span class="line">username.txt:  5 bytes</span><br></pre></td></tr></table></figure><p><br></p><p><strong>手动创建秘密(Creating a Secret Manually)</strong><br>每项必须是<code>base64</code>编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ echo -n &apos;admin&apos; | base64</span><br><span class="line">YWRtaW4=</span><br><span class="line">$ echo -n &apos;1f2d1e2e67df&apos; | base64</span><br><span class="line">MWYyZDFlMmU2N2Rm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#现在编写一个秘密对象文件</span><br><span class="line">#db-user-pass.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: mysecret</span><br><span class="line">type: Opaque</span><br><span class="line">data:</span><br><span class="line">  username: YWRtaW4=</span><br><span class="line">  password: MWYyZDFlMmU2N2Rm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建它</span><br><span class="line">$ kubectl create -f ./secret.yaml</span><br><span class="line">secret &quot;mysecret&quot; created</span><br></pre></td></tr></table></figure><p><br></p><p><strong>解码秘密(Decoding a Secret)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kubectl get secret mysecret -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  username: YWRtaW4=</span><br><span class="line">  password: MWYyZDFlMmU2N2Rm</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: 2016-01-22T18:41:56Z</span><br><span class="line">  name: mysecret</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;164619&quot;</span><br><span class="line">  selfLink: /api/v1/namespaces/default/secrets/mysecret</span><br><span class="line">  uid: cfee02d6-c137-11e5-8d73-42010af00002</span><br><span class="line">type: Opaque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#解码</span><br><span class="line">$ echo &apos;MWYyZDFlMmU2N2Rm&apos; | base64 --decode</span><br><span class="line">1f2d1e2e67df</span><br></pre></td></tr></table></figure><p><br></p><h5 id="使用秘密"><a href="#使用秘密" class="headerlink" title="使用秘密"></a>使用秘密</h5><p>Using Secrets<br>秘密可以作为数据卷来挂载，也可作为环境变量公开，以供Pod中的容器使用。它们也可以由系统的其它部分使用，而不是直接暴露在Pod中。</p><p><br></p><p><strong>将秘密用作Pod中的文件(Using Secrets as Files from a Pod)</strong><br>在Pod中的卷中使用秘密：</p><ul><li>创建或使用已有的秘密。多个Pod可以引用相同的秘密</li><li>修改Pod定义以添加卷和挂载卷</li><li>修改镜像或命令行，以便程序在该挂载目录中查找文件</li></ul><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">"/etc/foo"</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">    secret:</span></span><br><span class="line"><span class="attr">      secretName:</span> <span class="string">mysecret</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>向指定路径投射密钥(Projection of secret keys to specific paths)</strong><br>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">"/etc/foo"</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">    secret:</span></span><br><span class="line"><span class="attr">      secretName:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">      items:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">username</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">my-group/my-username</span></span><br><span class="line"><span class="comment">#username秘密存储在/etc/foo/my-group/my-username而不是/etc/foo/username</span></span><br><span class="line"><span class="comment">#password秘密没有投射</span></span><br></pre></td></tr></table></figure><p><br></p><p>**秘密文件权限(Secret files permissions)<br>你还可以指定秘密所具有的的权限:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">"/etc/foo"</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">    secret:</span></span><br><span class="line"><span class="attr">      secretName:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">      defaultMode:</span> <span class="number">256</span> <span class="comment">#0400(八进制)</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">"/etc/foo"</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">    secret:</span></span><br><span class="line"><span class="attr">      secretName:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">      items:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">username</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">my-group/my-username</span></span><br><span class="line"><span class="attr">        mode:</span> <span class="number">511</span> <span class="comment">#0777</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>从卷中使用秘密值(Consuming Secret Values from Volumes)</strong><br>在挂载秘密卷的容器内，密钥显示为文件，秘密值基于<code>base64</code>进行解码并存储在这些文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls /etc/foo/</span><br><span class="line">username</span><br><span class="line">password</span><br><span class="line">$ cat /etc/foo/username</span><br><span class="line">admin</span><br><span class="line">$ cat /etc/foo/password</span><br><span class="line">1f2d1e2e67df</span><br></pre></td></tr></table></figure><p><br></p><p><strong>挂载的秘密会自动更新(Mounted Secrets are updated automatically)</strong></p><p>当更新卷中已经使用的秘密时，最终也会更新投射的密钥。</p><p><br></p><p><strong>使用秘密作为环境变量(Using Secrets as Environment Variables)</strong><br>要在Pod中的环境变量中使用秘密：</p><ul><li>创建或使用已有的秘密。多个Pod可引用同一个秘密</li><li>修改Pod定义</li><li>修改Image或命令行，以便程序在指定的环境变量中查找值</li></ul><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">secret-env-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">mycontainer</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">SECRET_USERNAME</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          secretKeyRef:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">            key:</span> <span class="string">username</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">SECRET_PASSWORD</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          secretKeyRef:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">mysecret</span></span><br><span class="line"><span class="attr">            key:</span> <span class="string">password</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li>从环境变量中使用秘密值<br>Consuming Secret Values from Environment Variables</li></ul><p>容器内使用的环境变量的秘密值，它显示为<code>base64</code>的解码值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo $SECRET_USERNAME</span><br><span class="line">admin</span><br><span class="line">$ echo $SECRET_PASSWORD</span><br><span class="line">1f2d1e2e67df</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Using imagePullSecrets</strong><br>imagePullSecret是一种包含docker image registry password的秘密传递给kubelet的方法，因此它可以用于Pod拉取你的私有镜像。</p><p><br><br><br></p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p><br></p><h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><p>Restrictions</p><p>验证密钥卷源以确保指定的对象引用实际指向的秘密类型对象。因此，需要在任何Pod依赖它之前先创建秘密。<br><code>Secret API</code>对象驻留在命名空间中，它们只能由同一命名空间中的Pod引用。<br>单个秘密的大小被限制为1MB。这是为了阻止创建非常大的秘密，这会耗尽apiserver和kubelet的内存。然而，创建许多小的秘密也可能耗尽内存。更多关于限制秘密对内存的使用是未来的计划功能。<br>kubelet仅支持使用从apiserver获取的Pod秘密。这包含由<code>kubectl</code>创建的秘密，不包含通过<code>--manifest-url</code>标志或REST API创建的秘密。</p><p><br></p><h5 id="Secret和Pod的终生交互"><a href="#Secret和Pod的终生交互" class="headerlink" title="Secret和Pod的终生交互"></a>Secret和Pod的终生交互</h5><p>Secret and Pod Lifetime interaction</p><p>通过API创建Pod时，不会检查引用的秘密是否存在。一旦调度了Pod，kubelet将尝试获取秘密值。如果由于该秘密不存在或暂时缺少与apiserver的连接而无法获取该秘密，则kubelet将定期重试。它将报告有关Pod的事件，说明它尚未启动的原因。一旦获取到秘密，kubelet将创建并挂载包含它的卷，在挂载所有Pod的卷之前，Pod的容器都不会启动。</p><p><br><br><br></p><h4 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h4><ul><li><strong>Pod with ssh keys</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#创建包含ssh keys的秘密</span><br><span class="line">kubectl create secret generic ssh-key-secret --from-file=ssh-privatekey=/path/to/.ssh/id_rsa --from-file=ssh-publickey=/path/to/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建引用此秘密的Pod</span><br><span class="line">kind: Pod</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: secret-test-pod</span><br><span class="line">  labels:</span><br><span class="line">    name: secret-test</span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">  - name: secret-volume</span><br><span class="line">    secret:</span><br><span class="line">      secretName: ssh-key-secret</span><br><span class="line">  containers:</span><br><span class="line">  - name: ssh-test-container</span><br><span class="line">    image: mySshImage</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: secret-volume</span><br><span class="line">      readOnly: true</span><br><span class="line">      mountPath: &quot;/etc/secret-volume&quot;</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>Pods with prod / test credentials</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create secret generic prod-db-secret --from-literal=username=produser --from-literal=password=Y4nys7f11</span><br><span class="line">secret &quot;prod-db-secret&quot; created</span><br><span class="line">$ kubectl create secret generic test-db-secret --from-literal=username=testuser --from-literal=password=iluvtests</span><br><span class="line">secret &quot;test-db-secret&quot; created</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Pod中引用</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: List</span><br><span class="line">items:</span><br><span class="line">- kind: Pod</span><br><span class="line">  apiVersion: v1</span><br><span class="line">  metadata:</span><br><span class="line">    name: prod-db-client-pod</span><br><span class="line">    labels:</span><br><span class="line">      name: prod-db-client</span><br><span class="line">  spec:</span><br><span class="line">    volumes:</span><br><span class="line">    - name: secret-volume</span><br><span class="line">      secret:</span><br><span class="line">        secretName: prod-db-secret</span><br><span class="line">    containers:</span><br><span class="line">    - name: db-client-container</span><br><span class="line">      image: myClientImage</span><br><span class="line">      volumeMounts:</span><br><span class="line">      - name: secret-volume</span><br><span class="line">        readOnly: true</span><br><span class="line">        mountPath: &quot;/etc/secret-volume&quot;</span><br><span class="line">- kind: Pod</span><br><span class="line">  apiVersion: v1</span><br><span class="line">  metadata:</span><br><span class="line">    name: test-db-client-pod</span><br><span class="line">    labels:</span><br><span class="line">      name: test-db-client</span><br><span class="line">  spec:</span><br><span class="line">    volumes:</span><br><span class="line">    - name: secret-volume</span><br><span class="line">      secret:</span><br><span class="line">        secretName: test-db-secret</span><br><span class="line">    containers:</span><br><span class="line">    - name: db-client-container</span><br><span class="line">      image: myClientImage</span><br><span class="line">      volumeMounts:</span><br><span class="line">      - name: secret-volume</span><br><span class="line">        readOnly: true</span><br><span class="line">        mountPath: &quot;/etc/secret-volume&quot;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Dotfiles in secret volume</strong><br>隐藏文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kind: Secret</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: dotfile-secret</span><br><span class="line">data:</span><br><span class="line">  .secret-file: dmFsdWUtMg0KDQo=</span><br><span class="line">---</span><br><span class="line">kind: Pod</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: secret-dotfiles-pod</span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">  - name: secret-volume</span><br><span class="line">    secret:</span><br><span class="line">      secretName: dotfile-secret</span><br><span class="line">  containers:</span><br><span class="line">  - name: dotfile-test-container</span><br><span class="line">    image: k8s.gcr.io/busybox</span><br><span class="line">    command:</span><br><span class="line">    - ls</span><br><span class="line">    - &quot;-l&quot;</span><br><span class="line">    - &quot;/etc/secret-volume&quot;</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: secret-volume</span><br><span class="line">      readOnly: true</span><br><span class="line">      mountPath: &quot;/etc/secret-volume&quot;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Secret visible to one container in a pod</strong><br>考虑一个需要处理HTTP请求，执行一些复杂业务逻辑，然后使用HMAC签署一些消息的程序。由于它具有复杂的逻辑，因此可能存在未被注意的文件读取漏洞，这可能会将私钥暴露给攻击者。</p><p>这可以分为两个容器中的两个进程：</p><ul><li>前端容器处理用户交互和业务逻辑，但无法看到私钥</li><li>后端容器可查看签名的私钥，并相应来自前端的签名请求</li></ul><p><br><br><br></p><h4 id="最佳做法"><a href="#最佳做法" class="headerlink" title="最佳做法"></a>最佳做法</h4><p><strong>Clients that use the secrets API</strong></p><p>在部署与Secret API交互的应用程序时，应使用RBAC等授权策略限制访问。</p><p><br><br><br></p><h4 id="安全属性"><a href="#安全属性" class="headerlink" title="安全属性"></a>安全属性</h4><p><strong>保护</strong><br>由于可以独立于P使用秘密的Pod来创建秘密，因此在创建、查看、编辑Pod的工作流程中泄露秘密的风险较小。系统还可以对秘密对象采取额外的预防措施，如尽可能避免将其写入磁盘。<br>如果节点上的Pod需要秘密，则仅将秘密发送到节点。它不会写入磁盘，而是存储在tmpfs中(RAM)。一旦删除依赖它的Pod，它就会被删除。<br>节点上的秘密数据存储在tmpfs volume中，因此不会停留在节点上。<br>在大多数k8s项目维护的发行版中，用于与apiserver之间的通信，以及apiserver到kubelet的通信受到SSL/TLS保护。<br>同一节点上可能存在多个Pod的秘密，但是，只有Pod请求的密码可能在其容器中可见。因此，一个Pod无法访问另一个Pod的秘密。<br>同一个Pod中可能有几个容器，但是，Pod中的每个容器都必须在其<code>volumeMounts</code>中请求秘密卷，以使其在容器中可见。</p><p><br></p><p><strong>风险</strong></p><ul><li>apiserver中，秘密数据以明文形式存储在etcd中。因此：<ul><li>管理员应该限制用户对etcd的访问权限</li><li>apiserver中的秘密数据在etcd使用的磁盘上处于静止状态；管理员可能想要在不再使用时擦除etcd使用的磁盘</li></ul></li><li>如果通过json/yaml文件配置秘密，该文件的秘密数据的编码为<code>base64</code>，则该秘密可能被泄露。<code>base64</code>编码不是加密方法，被认为与纯文本相同</li><li>应用程序仍然需要在从卷读取秘密值后保护它</li><li>可创建使用秘密的Pod的用户也可看到秘密的值</li><li>如果运行了etcd的多个副本，则它们之间将共享秘密</li><li>目前，任何在节点上具有root权限的用户都可以模拟kubelet从apiserver中读取任何秘密</li></ul><p><br><br><br></p><h3 id="使用kubeconfig文件组织集群访问"><a href="#使用kubeconfig文件组织集群访问" class="headerlink" title="使用kubeconfig文件组织集群访问"></a>使用kubeconfig文件组织集群访问</h3><p>Organizing Cluster Access Using kubeconfig Files</p><p>使用<code>kubeconfig</code>文件来组织有关集群、用户、命名空间、身份验证机制的信息。<code>kubectl</code>使用kubeconfig文件来查找选择集群并与集群apiserver通信所需的信息。<br>用于配置对集群的访问的文件称为kubeconfig。这是引用配置文件的普通方法，这并不意味着有一个名为<code>kubeconfig</code>的文件。</p><p>默认情况下，<code>kubectl</code>从<code>$HOME/.kube</code>目录下查找名为<code>config</code>的文件。你可以通过<code>--kubeconfig</code>标志设置<code>KUBECONFIG</code>环境变量来指定kubeconfig文件。</p><p><br></p><h4 id="支持多集群、用户、认证机制"><a href="#支持多集群、用户、认证机制" class="headerlink" title="支持多集群、用户、认证机制"></a>支持多集群、用户、认证机制</h4><p>Supporting multiple clusters, users, and authentication mechanisms</p><p>假设你有多个集群，并且用户和组件以各种方式进行认证：</p><ul><li>正在运行的kubelet可能使用证书进行认证</li><li>用户可能使用令牌认证</li><li>管理员可能拥有他为用户提供的证书集</li></ul><p>使用kubeconfig，你可以组织集群、用户和命名空间。你还可以定义上下文，以便在集群和命名空间之间快速进行切换。</p><p><br><br><br></p><h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><p>kubeconfig文件中的上下文元素用于在方便的名称下对访问参数进行分组。每个上下文都有三个参数：集群、命名空间、用户。默认情况下，<code>kubectl</code>使用从当前上下文的参数与集群通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#Modify kubeconfig files</span><br><span class="line">kubectl config -h</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="KUBECONFIG环境变量"><a href="#KUBECONFIG环境变量" class="headerlink" title="KUBECONFIG环境变量"></a>KUBECONFIG环境变量</h4><p><code>$KUBECONFIG</code>环境变量包含kubeconfig文件列表，它不是必须的。如果不存在，则<code>kubectl</code>使用默认的<code>$HOME/.kube/config</code>；如果存在，则<code>kubectl</code>使用有效配置。在Linux/Mac上使用冒号分隔，Windows使用分号分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $KUBECONFIG</span><br><span class="line">/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="合并kubeconfig文件"><a href="#合并kubeconfig文件" class="headerlink" title="合并kubeconfig文件"></a>合并kubeconfig文件</h4><p>Merging kubeconfig files</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看配置</span><br><span class="line">kubectl config view</span><br></pre></td></tr></table></figure><ul><li><p>如果设置了<code>--kubeconfig</code>标志，则仅使用指定的文件。不合并，只允许此标志的一个实例。</p></li><li><p>否则，如果设置了<code>$KUBECONFIG</code>环境变量，将其应用于合并的文件列表。遵循以下规则：</p><ul><li>忽略空文件名</li><li>对包含无法反序列化内容的文件生成错误</li><li>设置成特定值或映射见的第一个文件获胜</li><li>切勿修改值或映射键</li></ul></li><li><p>否则，使用默认的<code>$HOME/.kube/config</code>文件，不做合并</p></li></ul><p><br><br><br></p><h3 id="Pod优先级和抢占"><a href="#Pod优先级和抢占" class="headerlink" title="Pod优先级和抢占"></a>Pod优先级和抢占</h3><p>Pod Priority and Preemption</p><blockquote><p>FEATURE STATE: Kubernetes 1.8 alpha<br>FEATURE STATE: Kubernetes 1.11 beta</p></blockquote><p>Pod也有优先级，优先级表示Pod相对于其它Pod的重要性。如果无法调度Pod，则调度程序会尝试抢占(驱逐)较低优先级的Pod，以便可以处理待调度(Pending)的Pod。<br>优先级还会影响Pod的调度顺序和节点上的资源驱逐顺序。</p><p><br></p><h4 id="使用优先级和抢占"><a href="#使用优先级和抢占" class="headerlink" title="使用优先级和抢占"></a>使用优先级和抢占</h4><p>How to use priority and preemption</p><p>要在k8s v1.11+使用优先级和抢占，遵循以下步骤：</p><ul><li>添加一个或多个优先级类(PriorityClassed)</li><li>创建带有<code>priorityClassName</code>的Pod设置为添加的优先级类之一。当然，你不需要直接创建Pod，通常你只需要将<code>priorityClassName</code>添加到对象的Pod模板(如deployment)</li></ul><p><br><br><br></p><h4 id="禁用抢占"><a href="#禁用抢占" class="headerlink" title="禁用抢占"></a>禁用抢占</h4><p>How to disable preemption</p><ul><li><p>禁用Pod优先级和抢占<br>要禁用Pod优先级，请为apiserver、调度程序、kubelet将该功能设置<code>false</code>——<code>--feature-gates=PodPriority=false</code></p></li><li><p>仅禁用抢占<br>在k8s v1.11+，抢占由<code>kube-scheduler</code>的<code>disablePreemption</code>标志控制，默认设置为<code>fasle</code>。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: componentconfig/v1alpha1</span><br><span class="line">kind: KubeSchedulerConfiguration</span><br><span class="line">algorithmSource:</span><br><span class="line">  provider: DefaultProvider</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">disablePreemption: true</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="PriorityClass"><a href="#PriorityClass" class="headerlink" title="PriorityClass"></a>PriorityClass</h4><p>优先级类(priorityClass)是一个非命名空间的对象，它定义从优先级类名到优先级的整数值的映射。该名称在<code>PriorityClass</code>对象的metadata的<code>name</code>字段中指定，必须的值在<code>value</code>字段中定义。值越高，优先级越高。<br>优先级类对象可以具有小于等于10亿的任何32位整数值。较大的数字保留给通常不会被抢占或驱逐的系统Pod。集群管理员应为他们想要的每个这样的映射创建一个优先级类对象。<br>优先级类有两个可选字段：</p><ul><li><code>globalDefault</code>： 表示该优先级类的值应该用于没有<code>priorityClassName</code>的Pod，系统中只能有一个<code>globalDefault</code>为<code>true</code>的Pod。如果没有设置为<code>globalDefault</code>的优先级类，则Pod的优先级为零。</li><li><code>description</code>： 旨在告诉用户何时应该使用此优先级类</li></ul><p><br></p><p>有关PodPriority和现有集群的说明：</p><ul><li>如果升级现有集群并启用此功能，则现有的Pod的优先级实际上为零</li><li>将<code>globalDefault</code>设置为<code>true</code>的优先级类添加将不会更改现有Pod的优先级。它的值仅用于添加优先级类之后创建的Pod</li><li>如果删除优先级类，则使用已删除的优先级类名称的现有Pod保持不变，但无法创建使用已删除的优先级类名称的Pod</li></ul><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: scheduling.k8s.io/v1beta1</span><br><span class="line">kind: PriorityClass</span><br><span class="line">metadata:</span><br><span class="line">  name: high-priority</span><br><span class="line">value: 1000000</span><br><span class="line">globalDefault: false</span><br><span class="line">description: &quot;This priority class should be used for XYZ service pods only.&quot;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Pod-priority"><a href="#Pod-priority" class="headerlink" title="Pod priority"></a>Pod priority</h4><p>当有一个或多个优先级类之后，你就可以创建在spec中指定priority class name的Pod。优先级许可控制器使用<code>priorityClassName</code>字段并填充优先级的整数值。如果为找到优先级，则决绝Pod。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    env: test</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">  priorityClassName: high-priority</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Pod优先级对调度顺序的影响</strong><br>启用Pod优先级后，调度程序按其优先级对挂起的Pod进行排序，并将挂起的Pod置于调度队列中优先级较低的其它挂起Pod之前。因此，如果满足调度要求，则优先级较低的Pod可以更快地安排具有较低优先级的Pod。如果无法调度此类Pod，则调度程序将继续并尝试安排其它较低优先级的Pod。</p><p><br><br><br></p><h4 id="Preemption"><a href="#Preemption" class="headerlink" title="Preemption"></a>Preemption</h4><p>创建Pod时，它们会进入队列并等待调度。调度程序从队列中选择一个Pod并尝试在节点上调度它。如果未找到满足Pod的所有指定要求的节点，则会为挂起的Pod触发抢占逻辑。抢占逻辑试图找到一个节点，其中删除优先级低于<code>Pod P</code>的一个或多个Pod，使得能够在该节点上调度<code>Pod P</code>。如果找到了此节点，则会删除那些Pod，在他们消失后，可在节点上调度<code>Pod P</code>。</p><p><br></p><p><strong>用户公开的信息</strong><br>User exposed information</p><p>当<code>Pod P</code>在节点上抢占一个或多个Pod时，<code>Pod P</code>的状态的<code>nominatedNodeName</code>字段被设置为节点的名称。该字段帮助调度器追踪为<code>Pod P</code>保留的资源，并且还向用户提供关于其集群中的抢占信息。<br>请注意，<code>Pod P</code>不一定安排到<code>nominated node</code>。在受害Pod被抢占后，它们将获得优雅的终止期。如果在调度程序等待受害Pod终止时另一个节点可用，则调度程序将使用另一个节点来调度<code>Pod P</code>。因此，Pod spec中的<code>nominatedNodeName</code>和<code>nodeName</code>并不总是相同。此外，如果调度程序在节点上抢占Pod，然后有比<code>Pod P</code>更高优先级的Pod到达，则调度程序可以将节点提供给新的更高优先级的Pod。</p><p><br></p><p><strong>抢占的局限性</strong><br>Limitations of preemption</p><ul><li>Graceful termination of preemption victims</li><li>PodDisruptionBudget is supported, but not guaranteed!</li><li>Inter-Pod affinity on lower-priority Pods</li><li>Cross node preemption</li></ul><p><br><br><br></p><h4 id="调试Pod优先级和抢占"><a href="#调试Pod优先级和抢占" class="headerlink" title="调试Pod优先级和抢占"></a>调试Pod优先级和抢占</h4><p>优先级和抢占可能会引起潜在的问题：</p><ul><li>Pods are preempted unnecessarily</li><li>Pods are preempted, but the preemptor is not scheduled</li><li>Higher priority Pods are preempted before lower priority pods</li></ul><p><br><br><br></p><h4 id="Pod优先级和QoS的交互"><a href="#Pod优先级和QoS的交互" class="headerlink" title="Pod优先级和QoS的交互"></a>Pod优先级和QoS的交互</h4><p>Interactions of Pod priority and QoS</p><p>调度程序的抢占逻辑在选择抢占目标是会考虑QoS。<br>考虑QoS和Pod优先级的唯一组件<code>kubelet out of resource</code>驱逐。kubelet首先根据他们对饥饿资源的使用是否超过请求，然后按优先级，通过相对于Pod的调度请求消耗的计算资源来排除Pod的驱逐。kubelet资源溢出驱逐不会驱逐资源使用不超过其请求的Pod。如果 优先级较低的未超过其请求，则不会被驱逐。另一个优先级高高于其请求的Pod可能被驱逐。</p><p><br><br><br><br><br></p><h2 id="服务，负载均衡和网络"><a href="#服务，负载均衡和网络" class="headerlink" title="服务，负载均衡和网络"></a>服务，负载均衡和网络</h2><p>Services, Load Balancing, and Networking</p><p><br></p><h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><p>k8s Pod是会死的，从出生到死亡，它们没有复活(resurrected)。副本集特别地动态创建和销毁Pod。虽然每个Pod都有自己的IP，但即使是那些IP也不能依赖它们随时间变得稳定。这导致一个问题，如果某些Pod为k8s集群内的其它Pod提供功能，那么它们如何找出并追踪它们呢？<br>这就需要用到服务了。</p><p>k8s 服务是一个抽象，它定义了一组逻辑Pod和一个访问它们的策略，有时称为<strong>微服务(micro-service)</strong>。服务目标的Pod由<code>Label Selector</code>来确定。</p><p>对于原生k8s应用程序，k8s提供了提供了一个简单的<code>Endpoints API</code>，只要服务中的Pod集发生变化，它就会更新。对于非原生k8s应用程序，k8s提供了一个基于虚拟IP的服务桥接器，可以重定向到后端的Pod。</p><p><br></p><h4 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h4><p>Defining a service</p><p>k8s中的服务是一个<strong>REST对象</strong>，类似于Pod。与所有REST对象一样，可以将服务定义<code>POST</code>到apiserver以创建实例。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: MyApp</span><br><span class="line">  ports:</span><br><span class="line">  - protocol: TCP</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: 9376</span><br></pre></td></tr></table></figure><p>此规范会创建一个名为<code>my-service</code>的服务对象，该对象使用<code>app=MyApp</code>的标签定位任何Pod上的TCP协议9376端口。服务还将分配一个IP地址(称为<code>cluster IP</code>)，由服务代理(service proxy)使用。将连续评估服务的<code>selector</code>，并将结果<code>POST</code>到名为<code>my-service</code>的<strong>Endpoints</strong>对象。<br>请注意，服务可以将传入端口映射到任何<code>targetPort</code>。默认情况下，<code>targetPort</code>将设置为与<code>port</code>字段相同的值。也许更有趣的是<code>targetPort</code>可以是一个字符串，指的是后端Pod中端口的名称。分配给该名称的实际端口号在每个后端Pod中可以不同。这为部署和发展你的服务提供了很大的灵活性。例如，你可以更改Pod的后端软件中公开的端口号，而不会破坏客户端。<br>k8s 服务支持TCP和UDP协议，默认是TCP。</p><p><br></p><p><strong>Services without selectors</strong><br>服务通常抽象访问k8s Pods，但它们也可以抽象访问其它类型的后端。例如：</p><ul><li>你希望在生产环境中拥有外部数据库集群，但在测试环境中你使用自己的数据库</li><li>你希望将服务指向另外的命名空间或集群</li><li>你正在将工作负载迁移到k8s，并且你的一些后端运行在k8s之外</li></ul><p>在任何方案中，你都可以定义不带选择器(selector)的服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">9376</span></span><br></pre></td></tr></table></figure><p>由于此服务没有选择器(selector)，因此不会创建相应的Endpoints对象。你可以手动将服务映射到你自己的特定端点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kind: Endpoints</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">subsets:</span><br><span class="line">  - addresses:</span><br><span class="line">      - ip: 1.2.3.4</span><br><span class="line">    ports:</span><br><span class="line">      - port: 9376</span><br></pre></td></tr></table></figure><p>在没有选择器的情况下访问服务的工作方式与使用选择器的方式相同。流量都会被路由到定义的端点。</p><p><code>ExternalName service</code>是一种特殊的服务案例，它没有选择器并且使用DNS名称代替。</p><p><br><br><br></p><h4 id="虚拟IP和服务代理"><a href="#虚拟IP和服务代理" class="headerlink" title="虚拟IP和服务代理"></a>虚拟IP和服务代理</h4><p>Virtual IPs and service proxies</p><p>在k8s v1.0中，服务是四层构造(tcp/udp)，代理纯粹实在用户空间中。在k8s v1.1中，添加了<code>Ingress API</code>来表示七层服务(HTTP)，也添加了iptables proxy。并成为k8s v1.2的默认操作模式。在k8s v1.8.0中，添加了ipvs proxy。</p><p>k8s 集群中的每个节点都运行一个<code>kube-proxy</code>——它负责为<code>ExternalName</code>以外类型的服务实现一种形式的虚拟IP。<br>在任何这些代理模式中，绑定到服务的<code>ip:port</code>的任何流量都将代理到适当的后端，而客户端不知道有关k8s或服务或Pod的任何信息。</p><p><br></p><p><strong>Proxy-mode: userspace</strong></p><p>在<code>userspace</code>模式下，<code>kube-proxy</code>会监视k8s master以添加和删除<code>Service</code>和<code>Endpoints</code>对象。对于每个服务，它在本地节点上打开一个端口(随机选择)。与此<code>proxy port</code>的任何连接都将代理到服务后端的Pod之一，并根据服务的<code>SessionAffinity</code>决定使用哪个后端Pod。最后，它将安装iptables规则，捕获流量到服务的<code>cluster IP</code>(虚拟IP)，并将流量重定向到代理后端Pod的代理端口。默认情况下，后端的选择是轮询(round robin)。</p><p><img src="/images/K8s/service_userspace.png" alt="service_userspace"></p><p><br></p><p><strong>Proxy-mode: iptables</strong></p><p>在<code>iptables</code>模式下，<code>kube-proxy</code>会监视k8s master以添加和删除<code>Service</code>和<code>Endpoint</code>对象。对于每个服务，它将安装iptables规则，捕获流量到服务的<code>cluster IP</code>和端口，并将流量重定向到服务的后端集之一。对于每个<code>Endpoint</code>对象，它会按照选择后端Pod的iptables规则。默认情况下，后端的选择是随机的。<br>显然，iptables不需要再用户空间(userspace)和内核空间(kernelspace)之间切换，它应该比用户空间代理更快更可靠。然而，与用户空间代理不同，如果最初选择的Pod没有响应，则iptables代理无法自动重试另一个Pod，因此它依赖于<code>readiness probes</code>的工作。</p><p><img src="/images/K8s/service_iptables.png" alt="service_iptables"></p><p><br></p><p><strong>Proxy-mode： ipvs</strong></p><blockquote><p>FEATURE STATE: Kubernetes v1.9 beta</p></blockquote><p>在<code>ipvs</code>模式下，<code>kube-proxy</code>监视k8s的<code>Service</code>和<code>Endpoints</code>，调用<code>netlink</code>接口以相应地创建ipvs规则，并定期与k8s的<code>Service</code>和<code>Endpoint</code>同步ipvs规则，以确保ipvs转台与期望一致。访问服务时，流量将被重定向到其中一个后端Pod。<br>与iptables类似，ipvs基于<code>netfilter hook</code>函数，但是用<code>hash table</code>作为底层数据结构，并在内核空间中工作。这意味着ipvs可以更快地重定向流量，并且再同步代理规则时具有更好的性能。此外，ipvs为负载均衡算法提供了更多选项：</p><ul><li><code>rr</code>： round-robin</li><li><code>lc</code>： least connection</li><li><code>dh</code>： destination hashing</li><li><code>sh</code>： source hashing</li><li><code>sed</code>： shortest expected delay</li><li><code>nq</code>： never queue</li></ul><p><strong>注意：</strong>ipvs模式假设在运行<code>kube-proxy</code>之前便已在节点上安装了IPVS内核模块。当<code>kube-proxy</code>以ipvs代理模式启动时，<code>kube-proxy</code>将验证节点上是否安装了IPVS模块，如果未安装，则<code>kube-proxy</code>将回退到iptables代理模式。</p><p><img src="/images/K8s/service_ipvs.png" alt="service_ipvs"></p><p><br><br><br></p><h4 id="多端口服务"><a href="#多端口服务" class="headerlink" title="多端口服务"></a>多端口服务</h4><p>Multi-Port Services</p><p>许多服务可能需要公开多个端口。对于此情况，k8s支持服务对象上的多个端口定义。当使用多个端口时，必须提供所有端口名称，以便消除端点(Endpoint)的歧义。<br>请注意，端口名称只能包含小写字母数字和横杠<code>-</code>，并须以字母数字结尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: MyApp</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    protocol: TCP</span><br><span class="line">port: 80</span><br><span class="line">targetPort: 9376</span><br><span class="line">  - name: https</span><br><span class="line">    protocol: TCP</span><br><span class="line">port: 443</span><br><span class="line">targetPort: 9377</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="选择自己的IP"><a href="#选择自己的IP" class="headerlink" title="选择自己的IP"></a>选择自己的IP</h4><p>Choosing your own IP address</p><p>你可以将自己的<code>cluster ip</code>指定为服务创建请求的一部分。为此，请设置<code>.spec.clusterIP</code>字段。用户选择的IP地址必须是有效的IP地址，并且在apiserver的标志指定的service-cluster-ip-range CIDR范围内。如果IP地址无效，则apiserver返回422 HTTP statuscode以指示该值无效。</p><p><br></p><p><strong>为什么不适用DNS轮询？</strong><br>Why not use round-robin DNS?</p><p>为什么我们使用虚拟IP来完成所有这些工作，而不仅仅是标准的DNS轮询。原因如下：</p><ul><li>DNS libraries的历史悠久，不尊重DNS TTL并缓存名称的查找结果</li><li>许多应用程序执行一次DNS查找并缓存结果</li><li>即使应用程序和库进行了适当的重新解析，每个客户算反复重新解析DNS的负载也是难以管理的</li></ul><p>我们试图阻止用户做出伤害自己的事情。也就是说，如果有足够的人要求这样做，我们可以将其作为替代方案来实施。</p><p><br><br><br></p><h4 id="服务发现-1"><a href="#服务发现-1" class="headerlink" title="服务发现"></a>服务发现</h4><p>Discovering services</p><p>k8s支持两种寻找服务的主要模式： <code>enviroment variables</code>和<code>DNS</code>。</p><p><br></p><p><strong>Environment variables</strong><br>当Pod在节点上运行时，kubelet为每个活跃的服务添加一组环境变量。它支持<code>Docker links compatible</code>变量和更简单的<code>{SVCNAME}_SERVICE_HOST</code>和<code>{SVCNAME}_SERVICE_PORT</code>变量。</p><p>栗子，如<code>redis-master</code>服务公开TCP6379端口，并分配了<code>10.0.0.11</code>的<code>cluster ip</code>以生成如下环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REDIS_MASTER_SERVICE_HOST=10.0.0.11</span><br><span class="line">REDIS_MASTER_SERVICE_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT=tcp://10.0.0.11:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP=tcp://10.0.0.11:6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PROTO=tcp</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_PORT=6379</span><br><span class="line">REDIS_MASTER_PORT_6379_TCP_ADDR=10.0.0.11</span><br></pre></td></tr></table></figure><p>这有一个要求——必须在Pod本身之前创建它想要访问的任何服务，否则将不会填充环境变量。DNS没有此限制。</p><p><br></p><p><strong>DNS</strong><br>可选的集群加载项是DNS server(强烈推荐)。DNS server监视k8s API以获取新服务，并为每个服务创建一组DNS 记录。如果已在集群中启用DNS，则所有Pod应该能够自动对服务进行名称解析。</p><p>例如，如果你在k8s命名空间<code>my-ns</code>中创建一个服务<code>my-service</code>，则会创建<code>my-service.my-ns</code>的DNS记录。存在于<code>my-ns</code>命名空间中的Pod应该能够通过简单地对<code>my-service</code>服务进行名称查找来找到它。存在于其它命名空间的Pod必须将名称限定为<code>my-service.my-ns</code>。这些名称查找的结果是<code>cluster ip</code>。<br>k8s还支持命名端口的DNS SRV(service)记录。如果<code>my-service.my-ns</code>服务具有带有TCP协议的名为<code>http</code>的端口，则可以对<code>_http._tcp.my-service.my-ns</code>执行DNS SRV查询以发现<code>http</code>的端口号。<br>k8s DNS server是访问<code>ExternalName</code>类型的服务的唯一方法。</p><p><br><br><br></p><h4 id="Headless-services"><a href="#Headless-services" class="headerlink" title="Headless services"></a>Headless services</h4><p>有时你不需要或不想要负载均衡和单个服务IP。在这种情况下，你可以通过将clusterIP(.spec.clusterIP)指定为<code>None</code>来创建一个<code>headless</code>服务。<br>此选项允许开发人员通过允许他们自由地以自己的方式进行发现来减少与k8s系统的耦合。应用程序仍然可以使用自注册(self-registration)模式，并且可以轻松地在API上构建适用于其它发现系统的适配器。</p><p>对于此类服务，并未分配clusterIP，<code>kube-proxy</code>也不处理这些服务，并且平台没有为它们执行负载均衡和代理。如何自动配置DNS取决于服务是否已定义选择器(selector)：</p><p><strong>With selectors</strong><br>对于定义了选择器的headless服务，端点控制器(endpoints controller)在API中创建端点记录(Endpoint records)，并修改DNS配置以返回直接指向支持服务的Pod的A记录(地址)。</p><p><strong>Without selectors</strong><br>对于没有定义选择器的headless服务，端点控制器不会创建端点记录。但是，DNS系统会查找并配置下面任一项；</p><ul><li><code>ExternalName</code>类型的服务的CNAME记录</li><li>所有其它类型的，与服务共享名称的任何端点记录</li></ul><p><br><br><br></p><h4 id="发布服务和服务类型"><a href="#发布服务和服务类型" class="headerlink" title="发布服务和服务类型"></a>发布服务和服务类型</h4><p>Publishing services - service types</p><p>对于应用程序的某些部分(如前端)，你可能希望将服务公开到外部IP地址(集群外)。<br>k8s <code>ServiceTypes</code>允许你指定所需的服务类型，默认为<code>ClusterIP</code>。</p><p>类型如下：</p><ul><li><p><code>ClusterIp</code><br>在集群内部IP上公开服务，选择此值使服务只能从集群内访问。这是默认的服务类型。</p></li><li><p><code>NodePort</code><br>在每个节点IP的静态端口上公开服务。将自动创建<code>cluster ip</code>服务(NodePort服务将路由到此服务)。你可以在集群外部通过请求<code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>来联系<code>NodePort</code>服务</p></li><li><p><code>LoadBalancer</code><br>使用云提供商的负载均衡器在外部公开服务。将自动创建外部负载均衡器路由到<code>NodePort</code>服务和<code>ClusterIP</code>服务。</p></li><li><p><code>ExternalName</code><br>通过返回CNAME记录的值，将服务映射到<code>externalName</code>字段的内容。没有设置任何类型的代理。这需要<code>kube-dns v1.7+</code>。</p></li></ul><p><br><br><br></p><h5 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h5><p><code>NodePort</code>类型下，k8s master将从<code>--service-node-port-range</code>标志指定的范围(默认 30000-32767)分配端口，(当然，你也可以在此范围了自定义)，并且每个节点将代理进入服务的端口(每个节点上的端口号相同)。服务中的<code>.spec.ports[].nodePort</code>字段。</p><p>如果要制定代理端口的特定IP，可将<code>kube-proxy</code>中的<code>--nodeport-addresses</code>标志 设置为特定IP块(从k8s v1.10+支持)。使用逗号<code>,</code>分隔IP块列表(如<code>10.0.0.0/8,1.2.3.4/31</code>)用于过滤此节点的本地地址。例如，如果你使用<code>--nodeport-address=127.0.0.0/8</code>标志启动<code>kube-proxy</code>，则<code>kube-proxy</code>将仅为NodePort服务选择环回地址接口(loopback)。<code>--nodeport-address</code>默认为空，这意味着选择所有可用的接口并符合当前的NodePort行为。</p><p>如果你需要特定的端口号，可以在<code>nodePort</code>字段中指定一个值，系统将为你分配该端口。请注意，指定的端口值必须在默认范围内，且没有端口冲突。</p><p>请注意，服务将同时显示<code>&lt;NodeIP&gt;:spec.ports[*].nodePort</code>和<code>.spec.clusterIP:spec.ports[*].port</code>。</p><p><br><br><br></p><h5 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h5><p>在支持外部负载均衡器的云提供商上，将<code>type</code>字段设置为<code>LoadBalancer</code>将为服务配置负载均衡器。负载均衡器的实际创建是异步(asynchronously)发生的，有关已配置的均衡器的信息将发布在服务的<code>.status.loadBalancer</code>字段。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: MyApp</span><br><span class="line">  ports:</span><br><span class="line">  - protocol: TCP</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: 9376</span><br><span class="line">  clusterIP: 10.0.171.239</span><br><span class="line">  loadBalancerIP: 78.11.24.19</span><br><span class="line">  type: LoadBalancer</span><br><span class="line">status:</span><br><span class="line">  loadBalancer:</span><br><span class="line">    ingress:</span><br><span class="line">    - ip: 146.148.47.155</span><br></pre></td></tr></table></figure><p>来自外部负载均衡器的流量将指向后端Pod，但具体如何工作取决于云提供商。某些云提供商允许指定<code>loaBalancerIP</code>。在这些情况下，将使用用户指定的<code>loadBalancerIP</code>创建负载均衡器。如果未指定<code>loadBalancerIP</code>字段，则将为负载均衡器分配临时IP。如果指定了<code>loadBalancerIP</code>字段，但云提供商不支持该功能，则该字段被忽略。</p><p><br></p><p>一些云提供商：</p><ul><li>AWS</li><li>Azure</li><li>GCP</li><li>Aliyun</li><li>TencentCloud</li></ul><p><br><br><br></p><h5 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h5><blockquote><p>NOTE: ExternalName Services are available only with kube-dns version 1.7 and later.</p></blockquote><p><code>ExternalName</code>类型的服务将服务映射到DNS名称(使用<code>spec.externalName</code>)，而不是映射到传统的选择器(如my-service)。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">  namespace: prod</span><br><span class="line">spec:</span><br><span class="line">  type: ExternalName</span><br><span class="line">  externalName: my.database.example.com</span><br></pre></td></tr></table></figure><p>查找主机<code>my-service.prod.svc.CLUSTER</code>时，集群DNS服务将返回<code>my.database.example.com</code>的CNAME记录。访问<code>my-service</code>服务的工作方式与其它服务的工作方式相同，但重要的区别在于重定向发生在DNS级别，而不是通过代理或转发。</p><p><br><br><br></p><h5 id="External-IPs"><a href="#External-IPs" class="headerlink" title="External IPs"></a>External IPs</h5><p>如果有外部IP路由到一个或多个集群节点，则可以在这些<code>externalIPs</code>上公开k8s 服务。在服务端口上使用外部IP，进入集群的流量将路由到其中一个服务端点。外部IP不由k8s管理，它是集群管理员的责任。</p><p>栗子；</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">MyApp</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">9376</span></span><br><span class="line"><span class="attr">  externalIPs:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">80.11</span><span class="number">.12</span><span class="number">.10</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><p>Shortcomings</p><p>使用虚拟IP(VIP)的用户空间(userspace)将在中小规模(small to medium scale)上工作，但不会扩展到具有成千上万个服务的大集群中。</p><p>使用用户空间代理会模糊访问服务的数据包的源IP，这使得某些类型的防火墙变得不可能。iptabels代理不会掩盖集群内源IP，但它仍然会影响通过负载均衡器或节点端口的客户端。</p><p><code>Type</code>字段设置为嵌套功能——每个级别都添加到前一个级别。并非所有云服务商都严格要求这样做，但目前的API需要它。</p><p><br><br><br></p><h4 id="VIP细节"><a href="#VIP细节" class="headerlink" title="VIP细节"></a>VIP细节</h4><p>The gory details of virtual IPs</p><ul><li><strong>避免冲突(Avoiding collisions)</strong><br>k8s的主要哲学之一是用户不应该暴露可能导致他们的行为失败的情况，而不是他们自己的过错。在这种情况下，我们查看网络端口——用户不应该选择可能与另一个用户发生冲突的网络端口。这叫隔离失败。<br>为了允许用户为服务选择端口号，我们必须确保没有服务间的冲突。我们通过为每个服务分配IP地址来做到这一点。</li></ul><p>为了确保每个服务都接收到一个唯一的IP，内部分配器会在创建每个服务之前以原子方式更新etcd中的全局分配映射。映射对象必须存在于映射表中以获取IP，否则创建将失败并显示一条消息，指示无法分配IP。后台控制器负责创建该映射以及由于管理员的干预而检查无效的分配，并清除已分配但当前没有服务使用的任何IP。</p><p><br></p><ul><li><strong>IPs和VIPs</strong><br>与实际路由到目的地的Pod IP不同，Service IP实际上并未由单个主机应答。相反，我们使用<code>iptables</code>来定义根据需要透明重定向的虚拟IP。当客户端连接到VIP时，其流量会自动传输到适当的端点。服务的环境变量和DNS实际上是根据服务的VIP和端口填充的。<br>支持三种代理模式： userspace、iptables、ipvs，它们的操作略有不同。</li></ul><p><br><br><br></p><h4 id="API对象-1"><a href="#API对象-1" class="headerlink" title="API对象"></a>API对象</h4><p>服务在k8s REST API中是顶级资源。</p><p><br><br><br></p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS for Services and Pods</p><p><br></p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>k8s DNS在集群上调度DNS Pod和Service，并配置kubelet以告知各个容器使用DNS Service’s IP 来解析DNS名称。<br>集群中定义的每个服务(包括DNS服务自身)，都会分配一个DNS名称。默认情况下，客户端Pod的DNS搜索列表将包含Pod自己的命名空间和集群的默认域。</p><p>栗子：<br>假设在k8s的<code>bar</code>命名空间中有一个<code>foo</code>服务，运行在<code>bar</code>命名空间中的Pod可通过简单地为<code>foo</code>执行DNS查询来查找此服务。运行在<code>quux</code>命名空间中的Pod可通过<code>foo.bar</code>执行DNS查询来查找此服务。</p><p><br><br><br></p><h4 id="Services-1"><a href="#Services-1" class="headerlink" title="Services"></a>Services</h4><p><strong>A records</strong><br>正常的服务(非headless)都分配了一个名为<code>my-svc.my-namespace.svc.cluster.local</code>形式的DNS A记录，这将解析为服务的<code>cluster ip</code>。<br><code>Headless</code>服务同样分配了一个名为<code>my-svc.my-namespace.svc.cluster.local</code>形式的DNS A记录。与服务不同，这将解析为服务选择的Pod的IP。</p><p><br></p><p><strong>SRV records</strong><br>为命名端口创建SRV记录，这些端口是普通服务或headless服务的一部分。<br>对于每个命名端口，SRV记录的格式为<code>_my-port-name._my-port-protocol.my-svc.my-namespace.svc.cluster.local</code>；<br>对于常规的服务，这将解析为端口号和域名：<code>my-svc.my-namespace.svc.cluster.local</code>；<br>对于headless服务，这将解析为多个答案。一个用于支持服务的每个Pod，并且包含Pod形式的端口号和域名:<code>auto-generated-name.my-svc.my-namespace.svc.cluster.local</code>。</p><p><br><br><br></p><h4 id="Pods-1"><a href="#Pods-1" class="headerlink" title="Pods"></a>Pods</h4><p><strong>A records</strong><br>启用后，将以<code>pod-ip-address.my-namespace.pod.cluster.local</code>的形式为Pod分配DNS A记录。如<code>10-0-1-11.default.pod.cluster.local</code>。</p><p><br></p><p><strong>Pod’s hostname and subdomain fields</strong><br>目前，当创建Pod时，其主机名时Pod的<code>metadata.name</code>值。Pod spec有一个可选的<code>hostname</code>字段，可用于指定Pod的主机名。指定后，它优先于Pod的名称作为Pod的主机名。<br>Pod spec同样有一个可选的<code>subdomain</code>字段，可用于指定其子域。</p><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">default-subdomain</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">1234</span></span><br><span class="line"><span class="attr">targetPort:</span> <span class="number">1234</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  nam:</span> <span class="string">busybox1</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  hostname:</span> <span class="string">busybox-1</span></span><br><span class="line"><span class="attr">  subdomain:</span> <span class="string">default-subdomain</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'3600'</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">busybox2</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  hostname:</span> <span class="string">busybox-2</span></span><br><span class="line"><span class="attr">  subdomain:</span> <span class="string">default-subdomain</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">sleep</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"3600"</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">busybox</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>Pod’s DNS Policy</strong><br>可以基于每个Pod设置DNS策略。目前，k8s支持以下特定于Pod的DNS策略。这些策略在Pod spec中的<code>dnsPolicy</code>字段中指定。</p><ul><li><p><code>Default</code><br>Pod从Pod的节点继承名称解析配置。</p></li><li><p><code>ClusterFirst</code><br>任何与配置的集群域后缀名称不匹配的DNS查询，都会转发到从该节点继承的上游名称服务器。集群管理员可能配置了额外的存根域和上游DNS server。<br>注意<code>Default</code>不是默认的DNS策略，如果未指定DNS策略，则使用<code>ClusterFirst</code>。</p></li><li><p><code>ClusterFirstWithHostNet</code><br>对于使用hostNetwork运行的Pod，你应该明确设置其DNS策略为<code>ClusterFirstWithHostNet</code>。</p></li><li><p><code>None</code><br>k8s v1.9+中引入的新功能。它允许Pod忽略k8s环境中的DNS设置。应该使用DNS spec中的<code>dnsConfig</code>字段提供所有的DNS设置。</p></li></ul><p><br></p><p><strong>Pod’s DNS Config</strong><br>要启用此功能，集群管理员需要在apiserver和kubelet上启用<code>--feature-gates=CustomPodDNS=true,...</code>。之后，用户便可以将Pod的<code>dnsPolicy</code>字段设置为<code>None</code>，并可以将新字段<code>dnsConfig</code>添加到Pod spec中。</p><p><code>dnsConfig</code>字段是可选的，它可与任何<code>dnsPolicy</code>设置一起使用。但是，当Pod的<code>dnsPolicy</code>字段设置为<code>None</code>时，必须指定<code>dnsConfig</code>字段。</p><p>用户可在<code>dnsConfig</code>字段中指定的属性：</p><ul><li><p><code>nameservers</code><br>用作Pod的DNS服务器的IP地址列表，最多可以指定3个IP地址。当<code>dnsPolicy</code>设置为<code>None</code>时，必须至少包含一个IP地址，否则此属性是可选的。</p></li><li><p><code>searches</code><br>Pod中主机名查找的DNS搜索域列表，此属性是可选的。k8s最多允许6个搜索域。</p></li><li><p><code>options</code><br>一个可选的对象属性，其中每个对象有<code>name(必须): value(可选)</code>。</p></li></ul><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">dns-example</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  dnsPolicy:</span> <span class="string">"None"</span></span><br><span class="line"><span class="attr">  dnsConfig:</span></span><br><span class="line"><span class="attr">    nameservers:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span></span><br><span class="line"><span class="attr">    searches:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ns1.svc.cluster.local</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">my.dns.search.suffix</span></span><br><span class="line"><span class="attr">    options:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">ndots</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">edns0</span></span><br></pre></td></tr></table></figure><p>查看:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it -- cat /etc/resolv.conf</span><br><span class="line">nameserver 1.2.3.4</span><br><span class="line">search ns1.svc.cluster.local my.dns.search.suffix</span><br><span class="line">options ndots:2 edns0</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="连接应用与服务"><a href="#连接应用与服务" class="headerlink" title="连接应用与服务"></a>连接应用与服务</h3><p>Connecting Applications with Services</p><p>现在你拥有了一个连续运行的副本应用程序，你可以在网络上公开它。在讨论k8s网络方法之前，值得将它与Docker的方式进行对比。<br>默认情况下，Docker使用<code>host-private</code>网络，因此只有当容器位于同一台主机上时，容器才能与其它容器进行通信。为了使Docker容器能够跨节点通信，必须在主机的IP地址上分配端口，然后将这些端口转发或代理到容器。这意味着容器要小心协调它们使用的端口。<br>k8s假设Pod可与其它Pod通信，无论它们着落在哪个主机。我们为每个Pod提供了集群专用IP，因此无需在Pod之间明确创建链接，或将容器端口映射到主机端口。这意味着Pod中的容器都可以在localhost上到达彼此的端口，并且集群中的所有Pod都可以在没有NAT的情况下看到对方。</p><p><br></p><h4 id="将Pod公开给集群"><a href="#将Pod公开给集群" class="headerlink" title="将Pod公开给集群"></a>将Pod公开给集群</h4><p>Exposing pods to the cluster</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      run:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h4><p>Creating a Service</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    run:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    run:</span> <span class="string">my-nginx</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="访问服务"><a href="#访问服务" class="headerlink" title="访问服务"></a>访问服务</h4><p>Accessing the Service</p><ul><li>Environment Variables</li><li>DNS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec &lt;pod&gt; -- printenv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl get services kube-dns --namespace=kube-system</span><br></pre></td></tr></table></figure><p><br></p><h4 id="服务安全"><a href="#服务安全" class="headerlink" title="服务安全"></a>服务安全</h4><p>Securing the Service</p><p>在将服务公开到因特网之前，你需要确保通信渠道是安全的。你需要：</p><ul><li>https签名证书</li><li>使用证书的nginx server</li><li>使证书可供Pod访问的secret</li></ul><p><br></p><h4 id="公开服务"><a href="#公开服务" class="headerlink" title="公开服务"></a>公开服务</h4><p>Exposing the Service</p><ul><li>NodePort</li><li>LoadBalancer</li></ul><p><br><br><br></p><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>管理集群中外部访问服务的API对象，通常是HTTP。<br>Ingress(入口)可以提供负载均衡，SSL终止和基于名称的虚拟主机。</p><p><br></p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>Terminology</p><ul><li>Node</li><li>Cluster</li><li>Edge router</li><li>Cluster network</li><li>Service</li></ul><p><br></p><h4 id="Ingress是什么"><a href="#Ingress是什么" class="headerlink" title="Ingress是什么"></a>Ingress是什么</h4><p>通常，服务和Pod具有的IP仅可在集群网络路由。最终在边缘路由器上的所有流量都被丢弃或转发到其它地方。从概念上讲，这可能看起来像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  internet</span><br><span class="line">      |</span><br><span class="line">------------</span><br><span class="line">[ Services ]</span><br></pre></td></tr></table></figure><p>Ingress是一组允许访问连接到达集群服务的一组规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> internet</span><br><span class="line">     |</span><br><span class="line">[ Ingress ]</span><br><span class="line">--|-----|--</span><br><span class="line">[ Services ]</span><br></pre></td></tr></table></figure><p>它可以配置为微服务提供外部可访问的URL，负载均衡流量、ssl terminate、基于名称的虚拟主机等。用户通过POST ingress资源到api-server来请求ingress。Ingress Controller负责完成ingress，通常使用负载均衡器(loadbalancer)，但也可配置为edge router或其它前端以帮助以HA方式处理流量。</p><p><br><br><br></p><h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><p>Prerequisites</p><p>在开始使用ingress资源之前，你应该了解一些事项。Ingress是<code>beta resource</code>，在k8s v1.1 之前的版本中都没有。你需要一个<code>ingress controller</code>来满足Ingress，简单地创建资源将无法生效。<br>GCE/Google Kubernetes Engine在<code>master</code>上部署<code>ingress controller</code>。你可以在Pod中部署任意数量的自定义入口控制器。你必须使用适当的class对每个入口进行注释。在GCE/google kubernetes engine以外的环境中，你需要将ingress controller部署为Pod。</p><p><br><br><br></p><h4 id="Ingress资源"><a href="#Ingress资源" class="headerlink" title="Ingress资源"></a>Ingress资源</h4><p>一个最小化的Ingress看起来如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">test-ingress</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line"><span class="comment">#ingress spec需要配置负载均衡器或代理服务器所需的信息</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/testpath</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>如果尚未配置ingress controller，则将此操作发送到api-verser将不起作用。</p><p>和其它k8s配置一样，Ingress也需要<code>apiVersion</code>, <code>kind</code>, <code>metadata</code>, <code>spec</code>字段。<br>Ingress spec字段需要配置负载均衡器和代理服务器所需的所有信息。最重要的是，它包含与所有传入请求匹配的规则列表。目前，Ingress仅支持http规则。<br>每个http rule都包含如下信息： <code>a host</code>，默认值为<code>*</code>；与后端挂念的一组<code>path</code>列表。在负载均衡器将流量定向到后端之前，host和path都必须与传入请求的内容匹配。<br>后端(backend)是一个<code>service:port</code>的组合。入口流量通常直接发送到与后端匹配的端点(endpoint)。<br>实例中没有包含Ingress的全局参数(global patameters)，详情请查看文档。</p><p><br><br><br></p><h4 id="Ingress-controllers"><a href="#Ingress-controllers" class="headerlink" title="Ingress controllers"></a>Ingress controllers</h4><p>为了使ingress资源正常工作，集群必须运行ingress controller——这与其它类型的控制器不同，后者通常为<code>kube-controller-manager</code>程序的一部分，并且通常作为集群创建的一部分而自启动。选择最适合你的集群的ingress controller。</p><ul><li><p>k8s目前支持和维护GCE和Nginx控制器<br>GCE: <a href="https://github.com/kubernetes/ingress-gce/blob/master/README.md" target="_blank" rel="noopener">https://github.com/kubernetes/ingress-gce/blob/master/README.md</a></p></li><li><p>F5 BIG-IP Controller for Kubernetes<br>链接： <a href="http://clouddocs.f5.com/products/connectors/k8s-bigip-ctlr/latest" target="_blank" rel="noopener">http://clouddocs.f5.com/products/connectors/k8s-bigip-ctlr/latest</a></p></li><li><p>Kong Ingress Controller for Kubernetes<br>链接： <a href="https://konghq.com/blog/kubernetes-ingress-controller-for-kong/" target="_blank" rel="noopener">https://konghq.com/blog/kubernetes-ingress-controller-for-kong/</a></p></li><li><p>Traefik<br>Traefik: <a href="https://github.com/containous/traefik" target="_blank" rel="noopener">https://github.com/containous/traefik</a><br>Containous: <a href="https://containo.us/services" target="_blank" rel="noopener">https://containo.us/services</a></p></li><li><p>NGINX Ingress Controller for Kubernetes<br>链接: <a href="https://www.nginx.com/products/nginx/kubernetes-ingress-controller/" target="_blank" rel="noopener">https://www.nginx.com/products/nginx/kubernetes-ingress-controller/</a><br>github: <a href="https://github.com/jcmoraisjr/haproxy-ingress" target="_blank" rel="noopener">https://github.com/jcmoraisjr/haproxy-ingress</a></p></li><li><p>HAProxy Ingress Controller for Kubernetes<br>链接： <a href="https://www.haproxy.com/blog/haproxy_ingress_controller_for_kubernetes/" target="_blank" rel="noopener">https://www.haproxy.com/blog/haproxy_ingress_controller_for_kubernetes/</a></p></li><li><p>基于<strong>istio</strong>的<strong>Control Ingress Traffic</strong><br>istio: <a href="https://istio.io/" target="_blank" rel="noopener">https://istio.io/</a><br>链接: <a href="https://istio.io/docs/tasks/traffic-management/ingress/" target="_blank" rel="noopener">https://istio.io/docs/tasks/traffic-management/ingress/</a></p></li></ul><p><br><br><br></p><p>####Ingress的类型</p><p><br></p><h5 id="Single-Service-Ingress"><a href="#Single-Service-Ingress" class="headerlink" title="Single Service Ingress"></a>Single Service Ingress</h5><p>现有的k8s概念允许你公开单个服务，但你也可以通过Ingress指定不使用规则的默认后端。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">test-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  backend:</span></span><br><span class="line"><span class="attr">    serviceName:</span> <span class="string">testsvc</span></span><br><span class="line"><span class="attr">    servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#创建</span><br><span class="line">kubectl create -f</span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">kubectl get ingress test-ingress</span><br><span class="line">NAME           HOSTS     ADDRESS           PORTS     AGE</span><br><span class="line">test-ingress   *         107.178.254.228   80        59s</span><br><span class="line">#107.178.254.228是ingress controller为满足此Ingress而分配的IP</span><br></pre></td></tr></table></figure><p><br></p><h5 id="Simple-fanout"><a href="#Simple-fanout" class="headerlink" title="Simple fanout"></a>Simple fanout</h5><p>如前所述，k8s中Pod只能在集群内网络上看到IP，因此我们需要在边缘处接收入口流量并将其代理到正确的端点。该组件通常是高可用的负载均衡器。Ingress允许你将负载均衡器的数量将至最低。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.bar.com -&gt; 178.91.123.132 -&gt; / foo    s1:80</span><br><span class="line">                                 / bar    s2:80</span><br></pre></td></tr></table></figure><p>需要一个Ingress，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">foo.bar.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/foo</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">s1</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/bar</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">s2</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f xxx</span><br><span class="line">kubectl describe ingress test</span><br><span class="line"></span><br><span class="line">Name:             test</span><br><span class="line">Namespace:        default</span><br><span class="line">Address:          178.91.123.132</span><br><span class="line">Default backend:  default-http-backend:80 (10.8.2.3:8080)</span><br><span class="line">Rules:</span><br><span class="line">  Host         Path  Backends</span><br><span class="line">  ----         ----  --------</span><br><span class="line">  foo.bar.com</span><br><span class="line">               /foo   s1:80 (10.8.0.90:80)</span><br><span class="line">               /bar   s2:80 (10.8.0.91:80)</span><br><span class="line">Annotations:</span><br><span class="line">  nginx.ingress.kubernetes.io/rewrite-target:  /</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason  Age                From                     Message</span><br><span class="line">  ----     ------  ----               ----                     -------</span><br><span class="line">  Normal   ADD     22s                loadbalancer-controller  default/test</span><br></pre></td></tr></table></figure><p><br></p><h5 id="Name-based-virtual-hosting"><a href="#Name-based-virtual-hosting" class="headerlink" title="Name based virtual hosting"></a>Name based virtual hosting</h5><p>基于名称的虚拟主机对同一IP地址使用多个主机名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.bar.com --|                 |-&gt; foo.bar.com s1:80</span><br><span class="line">              | 178.91.123.132  |</span><br><span class="line">bar.foo.com --|                 |-&gt; bar.foo.com s2:80</span><br></pre></td></tr></table></figure><p>如下的Ingress告诉后端负载均衡器根据Host Header来路由请求：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">foo.bar.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">s1</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">bar.foo.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">s2</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><strong>default backend</strong>： 没有指定规则的Ingress将所有流量发送到单个默认后端。你可以使用相同的技术来指定一组规则和默认后端来告诉负载均衡器在哪里找到网站的404页面。如果Ingress中的所有主机都与请求Header中的主机不匹配，并且没有任何路径与请求的URL匹配，则流量将路由到你的默认后端。</p><p><br></p><h5 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h5><p>可以通过指定包含TSL私钥和证书的机密来保护Ingress。目前，Ingress仅支持单个TLS 443端口。TLS Secret必须包含名为<code>tls.crt</code>和<code>tls.key</code>的证书和密钥：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">tls.crt:</span> <span class="string">base64</span> <span class="string">encoded</span> <span class="string">cert</span></span><br><span class="line">  <span class="string">tls.key:</span> <span class="string">base64</span> <span class="string">encoded</span> <span class="string">key</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">testsecret</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br></pre></td></tr></table></figure><p>在Ingress中引用secret将此告知ingress controller：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="literal">no</span><span class="bullet">-rules-map</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  tls:</span></span><br><span class="line"><span class="attr">  - secretName:</span> <span class="string">testsecret</span></span><br><span class="line"><span class="attr">  backend:</span></span><br><span class="line"><span class="attr">    serviceName:</span> <span class="string">s1</span></span><br><span class="line"><span class="attr">    servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>请注意，各种ingress controller支持的TLS功能存在差异性。</p><p><br></p><h5 id="Loadbalancing"><a href="#Loadbalancing" class="headerlink" title="Loadbalancing"></a>Loadbalancing</h5><p>ingress controller通过一些适用于所有Ingress的负载均衡策略设置进行引导(bootstrapped)，一些高级 的负载均衡概念(持久会话、动态权重)尚未通过Ingress进行公开。但你仍然可以通过服务负载均衡器获得这些功能。</p><p><br><br><br></p><h4 id="更新Ingress"><a href="#更新Ingress" class="headerlink" title="更新Ingress"></a>更新Ingress</h4><ul><li>直接更新资源</li><li>更新配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#直接更新资源</span><br><span class="line">kubectl edit ingress test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#更新修改的配置文件</span><br><span class="line">kubectl replace -f xxx</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h4><ul><li>各种模式的HTTPS/TLS支持</li><li>通过声明请求IP或Hostname</li><li>结合L4和L7 Ingress</li><li>更多ingress controller</li></ul><p><br><br><br></p><h4 id="Alternatives"><a href="#Alternatives" class="headerlink" title="Alternatives"></a>Alternatives</h4><p>有多种方式公开服务：</p><ul><li>LoadBalancer</li><li>NodePort</li><li>Port Proxy</li></ul><p><br><br><br></p><h3 id="LoadBalancer-NodePort-Ingress比较"><a href="#LoadBalancer-NodePort-Ingress比较" class="headerlink" title="LoadBalancer/NodePort/Ingress比较"></a>LoadBalancer/NodePort/Ingress比较</h3><p>参考: <a href="https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0" target="_blank" rel="noopener">Kubernetes NodePort vs LoadBalancer vs Ingress? When should I use what?</a></p><p>这几种服务类型的优缺点，以及什么时候使用它们。</p><p><br></p><p><strong>Cluster IP</strong><br><code>Cluster IP</code>是默认的k8s服务，它提供集群内部的访问，外部无法访问。<br>但你可以使用<code>kubernetes proxy</code>来访问它。</p><p>什么时候使用：</p><ul><li>调试服务</li><li>内部访问就可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#开启proxy</span><br><span class="line">kubectl proxy --port=8080</span><br><span class="line"></span><br><span class="line">#访问资源</span><br><span class="line">http://localhost:8080/api/v1/proxy/namespaces/&lt;NAMESPACE&gt;/services/&lt;SERVICE-NAME&gt;:&lt;PORT-NAME&gt;/</span><br></pre></td></tr></table></figure><p><img src="/images/K8s/kubernetes-proxy.png" alt=""></p><p><br></p><p><strong>NodePort</strong><br><code>NodePort</code>是公开服务的最原始的方式。</p><p>什么时候使用？此方法有许多缺点：</p><ul><li>每个端口只能有一个服务</li><li>默认端口范文<code>30000-32767</code></li><li>如果节点IP地址发生更改，则需要处理该问题</li><li>由于这些原因，不建议在生产环境使用这种方法</li></ul><p><img src="/images/K8s/kubernetes-nodeport.png" alt=""></p><p><br></p><p><strong>LoadBalancer</strong><br><code>LoadBalancer</code>是公开服务的标准方式。</p><p>什么时候用：</p><ul><li>指定端口上的所有流量都被转发到该服务，没有过滤、路由等。这意味着你可以发送任何类型的流量，如HTTP, TCP, UDP, Websocket, gRPC…</li><li>最大的缺点，你必须为每一个公开的服务使用一个负载均衡器，这个负载均衡器公开的服务都将获得自己的IP，这可能会付出比较大的代价</li></ul><p><img src="/images/K8s/kubernetes-loadbalancer.png" alt=""></p><p><br></p><p><strong>Ingress</strong><br>与以上方式不同，Ingress不是一种服务。相反，它位于多个服务之前，充当集群中的入口。<br>你可以使用Ingress做很多不同的事，并且有许多类型的 ingress controller，具有不同的功能。</p><p>什么时候用：</p><ul><li>Ingress可能是公开服务最强大的方式，但也可能是最复杂的</li><li>如果你希望在相同的IP下公开多个服务，则Ingress是最有用的</li></ul><p><img src="/images/K8s/kubernetes-ingress.png" alt=""></p><p><br><br><br></p><h3 id="网络策略"><a href="#网络策略" class="headerlink" title="网络策略"></a>网络策略</h3><p>Network Policies</p><p>网络策略是允许容器组如何与彼此以及其它网络端点通信的规范。<br><code>NetworkPolicy</code>资源使用<code>labels</code>选择Pod并定义规则，这些规则指定允许选定的Pod的流量。</p><p><br></p><h4 id="先决条件-1"><a href="#先决条件-1" class="headerlink" title="先决条件"></a>先决条件</h4><p>网络策略由网络插件来实现，因此你必须使用支持<code>NetworkPolicy</code>的网络解决方案——简单地创建资源而没有控制器来实现它将不起作用。</p><p><br><br><br></p><h4 id="Isolated-and-Non-isolated-Pods"><a href="#Isolated-and-Non-isolated-Pods" class="headerlink" title="Isolated and Non-isolated Pods"></a>Isolated and Non-isolated Pods</h4><p>默认情况下，Pod是非隔离的(non-isolated)。它们接受任何来源的流量。<br>可选择<code>NetworkPolicy</code>来隔离Pod，一旦命名空间中任何<code>NetworkPolicy</code>选择了特定的Pod，该Pod将拒绝网络策略不允许的任何连接。</p><p><br><br><br></p><h4 id="NetworkPolicy资源"><a href="#NetworkPolicy资源" class="headerlink" title="NetworkPolicy资源"></a>NetworkPolicy资源</h4><p>The NetworkPolicy Resource</p><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">test-network-policy</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  podSelector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      role:</span> <span class="string">db</span></span><br><span class="line"><span class="attr">  policyTypes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Ingress</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Egress</span></span><br><span class="line"><span class="attr">  ingress:</span></span><br><span class="line"><span class="attr">  - from:</span></span><br><span class="line"><span class="attr">    - ipBlock:</span></span><br><span class="line"><span class="attr">        cidr:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line"><span class="attr">        except:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">172.17</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line"><span class="attr">    - namespaceSelector:</span></span><br><span class="line"><span class="attr">        matchLabels:</span></span><br><span class="line"><span class="attr">          project:</span> <span class="string">myproject</span></span><br><span class="line"><span class="attr">    - podSelector:</span></span><br><span class="line"><span class="attr">        matchLabels:</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">  egress:</span></span><br><span class="line"><span class="attr">  - to:</span></span><br><span class="line"><span class="attr">    - ipBlock:</span></span><br><span class="line"><span class="attr">        cidr:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">5978</span></span><br></pre></td></tr></table></figure><ul><li><strong>必填字段</strong>： <code>NetworkPolicy</code>, <code>apiVersion</code>, <code>kind</code>, <code>metadata</code></li><li><strong>spec</strong>: 网络策略所需的所有信息</li><li><strong>podSelector</strong>： 选择策略适用的Pod分组。(如果为空，则表示此命名空间下的所有Pod)</li><li><strong>policyTypes</strong>： 可能包含<code>Ingress</code>, <code>Egress</code>。指示给定策略是否适用于入口流量和出口流量。(如果为空，默认为Ingress)</li><li><strong>ingress</strong>： 允许配置<code>from</code>和<code>ports</code>部分的流量。<code>ipBlock</code>, <code>namespaceSelector</code>, <code>podSelector</code>指定具体信息</li><li><strong>egress</strong>： 允许配置<code>to</code>和<code>ports</code>部分的流量</li></ul><p><br><br><br></p><h4 id="默认策略"><a href="#默认策略" class="headerlink" title="默认策略"></a>默认策略</h4><p>Default policies</p><p>默认情况下，如果命名空间中不存在任何策略，则允许所有入口(ingress)和出口(egress)流量进出该命名空间中的Pod。</p><p><br></p><ul><li><strong>默认拒绝所有入口流量(Default deny all ingress traffic)</strong><br>你可以通过创建<code>NetworkPolicy</code>来为命名空间创建默认的隔离策略，该策略选择所有Pod但不允许任何入口流量到这些Pod。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">default-deny</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  podSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  policyTypes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Ingress</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>默认允许所有入口流量(Default allow all ingress traffic)</strong><br>如果要允许所有流量到命名空间的所有Pod，你可以创建一个明确允许该命名空间中所有流量的策略。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">allow-all</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  podSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  ingress:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>默认拒绝所有出口流量(Default deny all egress traffic)</strong><br>可通过创建<code>NetworkPolicy</code>来为命名空间创建默认的出口隔离策略，该策略选择所有Pod但不允许来自这些Pod的出口流量。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">default-deny</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  podSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  policyTypes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Egress</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>默认允许所有出口流量(Default allow all egress traffic)</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">allow-all</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  podSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  egress:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  policyTypes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Egress</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>默认拒绝所有入口/出口流量(Default deny all ingress and all egress traffic)</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">default-deny</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  podSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  policyTypes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Ingress</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Egress</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用HostAliases向Pod的hosts添加条目"><a href="#使用HostAliases向Pod的hosts添加条目" class="headerlink" title="使用HostAliases向Pod的hosts添加条目"></a>使用HostAliases向Pod的hosts添加条目</h3><p>Adding entries to Pod <code>/etc/hosts</code> with HostAliases</p><p>当DNS和其它选项不适用时，向Pod的<code>/etc/hosts</code>文件添加条目可提供主机名解析的Pod级别的覆盖。在 <strong>v1.7</strong> 中，用户可以使用pod spec中的<code>HostAliases</code>字段来添加这些自定义条目。<br>不建议不使用<code>HostAliases</code>进行修改，因为该文件由Kubelet管理，并且可以在Pod 创建/重启 期间覆盖。</p><p><br></p><h4 id="默认hosts文件"><a href="#默认hosts文件" class="headerlink" title="默认hosts文件"></a>默认hosts文件</h4><p>Default Hosts File Content</p><p>查看Pod hosts文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -o=wide</span><br><span class="line">NAME                                     READY     STATUS    RESTARTS   AGE       IP            NODE</span><br><span class="line">nginx-deployment-597549df56-chjps        1/1       Running   0          26d       10.244.2.52   salt01</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#kubectl exec POD [-c CONTAINER] -- COMMAND [args...] [options]</span><br><span class="line">kubectl exec nginx-deployment-597549df56-chjps -- cat /etc/hosts</span><br><span class="line"># Kubernetes-managed hosts file.</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">fe00::0 ip6-mcastprefix</span><br><span class="line">fe00::1 ip6-allnodes</span><br><span class="line">fe00::2 ip6-allrouters</span><br><span class="line">10.244.2.52     nginx-deployment-597549df56-chjps</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用HostAliases添加额外条目"><a href="#使用HostAliases添加额外条目" class="headerlink" title="使用HostAliases添加额外条目"></a>使用HostAliases添加额外条目</h4><p>Adding Additional Entries with HostAliases</p><p><code>hostaliases-pod.yaml</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">hostaliases-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"><span class="attr">  hostAliases:</span></span><br><span class="line"><span class="attr">  - ip:</span> <span class="string">"127.0.0.1"</span></span><br><span class="line"><span class="attr">    hostnames:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"foo.local"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"bar.local"</span></span><br><span class="line"><span class="attr">  - ip:</span> <span class="string">"192.168.31.119"</span></span><br><span class="line"><span class="attr">    hostnames:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">zhang21</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">cat-hosts</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">command:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"><span class="attr">args:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"/etc/hosts"</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f hostaliases-pod.yaml</span><br><span class="line"></span><br><span class="line">kubeclt logs hostaliases-pod</span><br><span class="line"><span class="comment"># Kubernetes-managed hosts file.</span></span><br><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0ip6-localnet</span><br><span class="line">fe00::0ip6-mcastprefix</span><br><span class="line">fe00::1ip6-allnodes</span><br><span class="line">fe00::2ip6-allrouters</span><br><span class="line">10.244.1.69hostaliases-pod</span><br><span class="line"><span class="comment"># Entries added by HostAliases.</span></span><br><span class="line">127.0.0.1foo.local</span><br><span class="line">127.0.0.1bar.local</span><br><span class="line">192.168.31.119zhang21</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="为什么kubelet管理hosts"><a href="#为什么kubelet管理hosts" class="headerlink" title="为什么kubelet管理hosts"></a>为什么kubelet管理hosts</h4><p>Why Does Kubelet Manage the Hosts File?</p><p>Kubelet管理Pod中每个容器的hosts文件，以防止Docker在容器已启动后修改文件。<br>由于文件的托管性质，只要在容器重启或Pod重新调度的情况下由Kubelet重新挂载hosts文件，因此用户编写的内容都将被覆盖。因此，不建议直接修改文件的内容。</p><p><br><br><br><br><br></p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>Storage</p><p><br><br><br></p><h3 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h3><p>容器中的磁盘文件是短暂的，这在容器中运行时会给重大的应用程序带来一些问题。首先，当一个容器奔溃时，kubelet将重启它，但文件会丢失，容器将以干净的状态启动。其次，在Pod中一起运行容器时，通常需要在这些容器间共享文件。k8s volume抽象解决这些问题。</p><p><br><br><br></p><h4 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h4><p>Docker也有关于卷的概念，虽然它有点宽松和管理较少。在Docker中，卷是磁盘上或其它容器中的目录，声明周期不受管理。Docker提供了卷驱动，但目前功能非常有限。</p><p>另一方面，k8s的卷具有明确的生命周期。因此，卷可以比Pod中运行的任何容器活得更久，并且可在容器重启之间保留数据。当然，当Pod不再存在时，卷也将不复存在。更重要的是，k8s支持多种类型的卷，Pod可以同时使用任意数量的卷。<br>从本质上讲，卷只是一个目录，可能包含一些数据，Pod中的容器可以访问它。该目录如何形成，支持它的介质以及它的内容都由所用特定卷的类型决定。<br>要使用卷，Pod Spec要指定提供的卷(<code>.spec.volumes</code>字段)，以及将这些卷挂载到容器中的位置(<code>.spec.containers.volumeMounts</code>字段)。</p><p>容器中的进程可以看到由Docker镜像和卷组成的文件系统视图。Docker镜像位于文件系统层次结构的根下，任何卷都挂载到镜像中的指定路径。卷不能挂载到其它卷或其它卷的硬链接上，Pod中的每个容器必须独立的指定每个卷的挂载位置。</p><p><br><br><br></p><h4 id="卷类型"><a href="#卷类型" class="headerlink" title="卷类型"></a>卷类型</h4><p>k8s支持如下卷类型。注意，这些卷并非全部都是持久化的(如emptyDir)，它们会随着Pod的消亡而消亡。</p><ul><li>awsElasticBlockStore</li><li>azureDisk</li><li>azureFile</li><li>cephfs</li><li>configMap</li><li>csi</li><li>downwardAPI</li><li>emptyDir</li><li>fc (fibre channel)</li><li>flocker</li><li>gcePersistentDisk</li><li>gitRepo (deprecated)</li><li>glusterfs</li><li>hostPath</li><li>iscsi</li><li>local</li><li>nfs</li><li>persistentVolumeClaim</li><li>projected</li><li>portworxVolume</li><li>quobyte</li><li>rbd</li><li>scaleIO</li><li>secret</li><li>storageos</li><li>vsphereVolume</li></ul><p>具体例子请参考: <a href="https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes</a></p><p><br></p><p><strong>configMap</strong><br><code>configMap</code>资源提供了一种将配置数据注入Pod的方法。存储在configMap对象中的数据可以在configMap类型的卷中引用，然后由Pod中运行的应用程序使用。<br>引用configMap对象时，只需在卷中提供其名称即可引用它。你还可以自定义configMap中的特定条路的路径。</p><p>例如，要将<code>log-config</code>的ConfigMap挂载到名为<code>configmap-pod</code>的Pod上，你可以这样操作：<br>注意，在使用之前你先得创建ConfigMap<br>使用ConfigMap作为subPath的卷挂载将不会收到<code>ConfigMap</code>的更新</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">configmap-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">config-vol</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">config-vol</span></span><br><span class="line"><span class="attr">      configMap:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">log-config</span></span><br><span class="line"><span class="attr">        items:</span></span><br><span class="line"><span class="attr">          - key:</span> <span class="string">log_level</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">log_level</span></span><br><span class="line"><span class="comment">#log-config configMap作为卷挂载，存储在`log_level`的所有内容都挂载到路径`/etc/config/log_level`的Pod中</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>emptyDir</strong><br>将Pod分配给节点时，首先会创建一个<code>emptyDir</code>卷。只要节点还在该节点上运行，它就会存在。就如同它的名称一样，它最初是空的。Pod中的容器都可以在<code>emptyDir</code>卷中读取和写入相同的文件，尽管改卷可以安装在每个容器中相同或不同的路径上。当从节点上删除Pod时，将永久删除<code>emptyDir</code>中的数据。<br>注意：容器奔溃不会从节点中删除Pod，因此<code>emptyDir</code>卷中的数据在容器奔溃时是安全的。</p><p><code>emptyDir</code>的一些用途：</p><ul><li>临时空间</li><li>检查从崩溃中恢复的长计算</li><li>保存内容管理器容器在Web服务器提供数据时提取的文件</li></ul><p>默认情况下，<code>emptyDir</code>卷存储在节点的任何介质上(磁盘、SSD、网络存储…)，取决于你的环境。但是，你可以将<code>emptyDir.medium</code>字段设置为<code>Memory</code>，以告诉k8s为你安装<code>tmpfs</code>(RAM支持的文件系统)。tmpfs非常快，但请注意断电就没有了，并且你编写的任何文件都将计入容器的内存限制。</p><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">test-pd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8s.gcr.io/test-webserver</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">test-container</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - mountPath:</span> <span class="string">/cache</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">cache-volume</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">cache-volume</span></span><br><span class="line"><span class="attr">    emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>hostPath</strong><br><code>hostPath</code>卷将文件或目录从主机节点的文件系统挂载到Pod中。这不是大多数Pod需要的东西，但它为某些应用程序提供了强大的逃生舱。</p><p><code>hostPath</code>的一些用途：</p><ul><li>运行需要访问Docker内部的容器，使用<code>/var/lib/docker</code>的<code>hostPath</code></li><li>在容器中运行cAdvisor</li><li>允许Pod指定在Pod运行之前是否应该存在给定的<code>hostPath</code>，是否应该创建它以及它应该存在的内容</li></ul><p>三个字段:</p><ul><li>hostPath</li><li>path</li><li>type</li></ul><p>支持的<code>type</code>的值：</p><table><thead><tr><th>Value</th><th>Behavior</th></tr></thead><tbody><tr><td>空</td><td>Empty string (default) is for backward compatibility, which means that no checks will be performed before mounting the hostPath volume.</td></tr><tr><td>DirectoryOrCreate</td><td>If nothing exists at the given path, an empty directory will be created there as needed with permission set to 0755, having the same group and ownership with Kubelet.</td></tr><tr><td>Directory</td><td>A directory must exist at the given path</td></tr><tr><td>FileOrCreate</td><td>If nothing exists at the given path, an empty file will be created there as needed with permission set to 0644, having the same group and ownership with Kubelet.</td></tr><tr><td>File</td><td>A file must exist at the given path</td></tr><tr><td>Socket</td><td>A UNIX socket must exist at the given path</td></tr><tr><td>CharDevice</td><td>A character device must exist at the given path</td></tr><tr><td>BlockDevice</td><td>A block device must exist at the given path</td></tr></tbody></table><p>请注意何时使用此类型的卷，因为：</p><ul><li>由于节点上的文件不同，具有相同配置的Pod在不同节点上的行为可能有所不同</li><li>当k8s按计划添加资源，它将无法考虑<code>hostPath</code>使用的资源</li><li>在底层主机上创建的文件或目录只能由root写入</li></ul><p>栗子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">test-pd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8s.gcr.io/test-webserver</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">test-container</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - mountPath:</span> <span class="string">/test-pd</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">test-volume</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">test-volume</span></span><br><span class="line"><span class="attr">    hostPath:</span></span><br><span class="line">      <span class="comment"># directory location on host</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/data</span></span><br><span class="line">      <span class="comment"># this field is optional</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">Directory</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>local</strong><br><code>local</code>卷表示已挂载的本地存储设备，如磁盘，分区或目录。它只能用作静态创建的持久化卷，尚不支持动态配置。<br>与<code>hostPath</code>卷相比，可以以持久且可移植的方式使用<code>lobal</code>卷，而无需手动将Pod调度到节点。<br>然而，local卷仍受基础节点可用性的限制，并不适用于所有应用程序。如果节点变得不健康，则local卷也将变得不可访问，并且使用它的Pod将无法运行。使用local volume的应用程序必须能够容忍这种降低的可用性以及潜在的数据丢失，具体取决于底层磁盘的持久性特征。</p><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">example-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  capacity:</span></span><br><span class="line"><span class="attr">    storage:</span> <span class="number">100</span><span class="string">Gi</span></span><br><span class="line">  <span class="comment"># volumeMode field requires BlockVolume Alpha feature gate to be enabled.</span></span><br><span class="line"><span class="attr">  volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  persistentVolumeReclaimPolicy:</span> <span class="string">Delete</span></span><br><span class="line"><span class="attr">  storageClassName:</span> <span class="string">local-storage</span></span><br><span class="line"><span class="attr">  local:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/mnt/disks/ssd1</span></span><br><span class="line"><span class="attr">  nodeAffinity:</span></span><br><span class="line"><span class="attr">    required:</span></span><br><span class="line"><span class="attr">      nodeSelectorTerms:</span></span><br><span class="line"><span class="attr">      - matchExpressions:</span></span><br><span class="line"><span class="attr">        - key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line"><span class="attr">          operator:</span> <span class="string">In</span></span><br><span class="line"><span class="attr">          values:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">example-node</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>NFS</strong><br>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">nfs</span></span><br><span class="line"><span class="attr">  nfs:</span></span><br><span class="line">    <span class="comment"># <span class="doctag">FIXME:</span> use the right hostname</span></span><br><span class="line"><span class="attr">    server:</span> <span class="number">10.254</span><span class="number">.234</span><span class="number">.223</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">"/"</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>persistentVolumeClaim</strong><br><code>persistentVolumeClaim</code>卷用于将持久化卷挂载到Pod中。</p><p><br><br><br></p><h4 id="使用子路径"><a href="#使用子路径" class="headerlink" title="使用子路径"></a>使用子路径</h4><p>Using subPath</p><p>有时，在单个Pod中共享一个卷用于多个用途是很有用的。<code>volumeMounts.subPath</code>属性可用于指定引用卷内的子路径，而不是根路径。</p><p>使用单个共享卷的Pod与LAMP Stack的示例，HTML内容被映射到html目录中，数据库存储在mysql目录中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-lamp-site</span><br><span class="line">spec:</span><br><span class="line">    containers:</span><br><span class="line">    - name: mysql</span><br><span class="line">      image: mysql</span><br><span class="line">      env:</span><br><span class="line">      - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">        value: &quot;rootpasswd&quot; </span><br><span class="line">      volumeMounts:</span><br><span class="line">      - mountPath: /var/lib/mysql</span><br><span class="line">        name: site-data</span><br><span class="line">        subPath: mysql</span><br><span class="line">    - name: php</span><br><span class="line">      image: php:7.0-apache</span><br><span class="line">      volumeMounts:</span><br><span class="line">      - mountPath: /var/www/html</span><br><span class="line">        name: site-data</span><br><span class="line">        subPath: html</span><br><span class="line">    volumes:</span><br><span class="line">    - name: site-data</span><br><span class="line">      persistentVolumeClaim:</span><br><span class="line">        claimName: my-lamp-site-data</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用带有扩展环境变量的子路径</strong><br>Using subPath with expanded environment variables</p><p>FEATURE STATE: <code>k8s v1.11 alpha</code></p><p><code>subPath</code>目录名也可从Downward API环境变量构造。在使用此功能之前，必须启用<code>VolumeSubpathEnvExpansion</code>。<br>下例中，Pod使用<code>subPath</code>在主机路径卷<code>/var/log/pods</code>中创建<code>pod1</code>目录，使用Downward API中的Pod名。主机目录<code>/var/log/pods/pod1</code>被挂载到容器中的<code>/logs</code>目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod1</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: container1</span><br><span class="line">    env:</span><br><span class="line">    - name: POD_NAME</span><br><span class="line">      valueFrom:</span><br><span class="line">        fieldRef:</span><br><span class="line">          apiVersion: v1</span><br><span class="line">          fieldPath: metadata.name</span><br><span class="line">    image: busybox</span><br><span class="line">    command: [ &quot;sh&quot;, &quot;-c&quot;, &quot;while [ true ]; do echo &apos;Hello&apos;; sleep 10; done | tee -a /logs/hello.txt&quot; ]</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: workdir1</span><br><span class="line">      mountPath: /logs</span><br><span class="line">      subPath: $(POD_NAME)</span><br><span class="line">  restartPolicy: Never</span><br><span class="line">  volumes:</span><br><span class="line">  - name: workdir1</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /var/log/pods</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p><code>emptyDir</code>卷的存储介质(磁盘，SSD…)由kubelet根目录的文件系统的介质确定。<code>emptyDir</code>或<code>hostPath</code>卷可以占用多少空间没有限制，容器之间或Pod之间没有隔离。</p><p><br><br><br></p><p>####挂载传播</p><p>Mount propagation</p><p>FEATURE STATE: <code>k8s v1.10 beta</code></p><p>挂载传播允许将容器挂载的卷共享到同一Pod的其它容器，或同一节点的其它Pod。<br>如果<code>MountPropagation</code>功能被禁用，或Pod未指明特定的挂载环境，则不会传播Pod的容器中的挂载卷。<br>卷的挂载传播由<code>Container.volumeMounts</code>中的<code>mountPropagation</code>字段控制。它的值为：</p><ul><li><p><code>None</code><br>此卷的挂载不会接收主机挂载到此卷或任何子目录的任何后续挂载。此模式等同于于Linux kernel中描述的<code>private</code>挂载传播。</p></li><li><p><code>HostToContainer</code><br>此卷的挂载将接收安装到此卷或其任何子目录的所有后续挂载。换句话说，如果主机在卷挂载中挂载任何内容，则容器将看到它挂载在那里。<br>类似地，如果任何具有双向挂载传播的Pod挂载到同一个卷中，那么具有<code>HostToContainer</code>挂载传播的容器将看到它。此模式等同于Linux Kernel中描述的<code>rslave</code>挂载传播。</p></li><li><p><code>Bidirectional</code><br>此卷的挂载行为与<code>HostToContainer</code>相同。此外，容器创建的所有卷 挂载都将传播会主机和所有使用相同卷的Pod中的容器。此模式等同于Linux kernel中描述的<code>rshared</code>挂载传播。</p></li></ul><p><br></p><p><strong>配置</strong><br>在挂载传播可以在某些部署上正常工作之前，必须在Docker中正确配置挂载共享，修改<code>docker systemd</code>服务文件，设置<code>MountFlags</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MountFlags=shared</span><br></pre></td></tr></table></figure><p>重启Docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="持久化卷"><a href="#持久化卷" class="headerlink" title="持久化卷"></a>持久化卷</h3><p>Persistent Volumes</p><p><br></p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>PersistentVolume</code> 子系统为用户和管理员提供了一个API，它提供了如何根据消耗提供存储的详细信息。为此，我们引入了两个新的API资源：</p><ul><li><strong>PersistentVolume(PV)</strong></li><li><strong>PersistentVolumeClaim(PVC)</strong></li></ul><p><br></p><p><code>PersistentVolume</code> 是群集中由管理员配置的一块存储。它是集群中的资源，就像节点是集群资源一样。它是像 Volume 的 Volume Plugin，但其生命周期独立于使用它的任何单个 pod 。此API对象捕获存储实现的详细信息，包括NFS，iSCSI或特定于云提供程序的存储系统。</p><p><code>PersistentVolumeClaim</code> 是用户存储的请求。与 Pod 类似，Pod 消耗 Node 资源，而 PVC 消耗 PV 的资源。Pod可以请求特定级别的资源(CPU, MEM)，Claim 可以请求特定的大小和访问模式。</p><p>虽然 PersistentVolumeClaims 允许用户使用抽象存储资源，但是对于不同的问题，用户需要具有不同属性的 PersistentVolumes。群集管理员需要能够提供各种PersistentVolume，这些PersistentVolume在多种方式上而不仅仅是大小和访问模式，而不会让用户了解这些卷的实现方式。对于这些需求，有 <strong>StorageClass</strong> 资源。</p><p><br><br><br></p><h4 id="volume和claim的生命周期"><a href="#volume和claim的生命周期" class="headerlink" title="volume和claim的生命周期"></a>volume和claim的生命周期</h4><p>Lifecycle of a volume and claim</p><p>PV是群集中的资源。 PVC是对这些资源的请求，并且还充当对资源的声明检查。PV和PVC之间的相互作用遵循如下生命周期。</p><p><br></p><h5 id="Provisioning"><a href="#Provisioning" class="headerlink" title="Provisioning"></a>Provisioning</h5><p>有两种方式配置PV:</p><ul><li><strong>Static</strong></li></ul><p>集群管理员创建了许多PV。它们包含可供群集用户使用的实际存储的详细信息。它们存在于Kubernetes API中，可供使用。</p><ul><li><strong>Dynamic</strong></li></ul><p>当管理员创建的 Static PV 都不匹配用户的 PersistentVolumeClaim 时，群集可能会尝试为PVC 专门动态配置Volume。此 Provision 基于StorageClasses， PVC必须请求存储类，管理员必须已创建并配置该类，以便进行动态供应。</p><p><br></p><h5 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h5><p>用户在动态配置的情况下创建或已创建 PersistentVolumeClaim，其具有请求的特定存储量和某些访问模式。Master中的控制循环观察新PVC，找到匹配的PV（如果可能），并将它们绑定在一起。如果为新PVC动态配置PV，则循环将始终将该PV绑定到PVC。否则，用户将始终至少得到他们要求的内容，但是Volume可能超过所要求的数量。绑定后，PersistentVolumeClaim 绑定是独占的，无论它们如何绑定，PVC到PV绑定是一一对应。</p><p>如果不存在匹配的卷，则 Claim 将无限期地保持未绑定状态。Claim 将在匹配卷可用时受到绑定。例如，集群配置了许多50Gi PV，与请求100Gi的PVC不匹配。当100Gi PV添加到集群时，可以绑定PVC。</p><p><br></p><h5 id="Using"><a href="#Using" class="headerlink" title="Using"></a>Using</h5><p>Pods 使用 Claim 作为 Volume。群集检查 Claim 以查找绑定卷并为该 Pod 挂载该卷。对于支持多种访问模式的卷，用户在将其声明用作 Pod 的卷时指定所需的模式。</p><p>一旦用户具有声明并且该声明被绑定，绑定的PV就属于用户，只要用户需要它。用户通过在Pod的 Volume Block 中包含 persistentVolumeClaim 来调度Pod并访问其声明的PV。</p><p><br></p><h5 id="Storage-Object-in-Use-Protection"><a href="#Storage-Object-in-Use-Protection" class="headerlink" title="Storage Object in Use Protection"></a>Storage Object in Use Protection</h5><p><strong>使用中的存储对象保护</strong> 功能的目的是确保不会从系统中删除 绑定到 PVC，由 Pod 和 PV 主动使用的 PVC，因为这可能会导致数据丢失。</p><blockquote><p>注意：当pod状态为Pending且pod已分配给Node，或pod状态为Running时，pod将主动使用PVC。</p></blockquote><p><br></p><h5 id="Reclaiming"><a href="#Reclaiming" class="headerlink" title="Reclaiming"></a>Reclaiming</h5><p>当用户完成卷时，他们可以从API中删除PVC对象，从而允许回收资源。PersistentVolume 的回收策略告诉群集在释放其声明后如何处理该卷。</p><p>目前，卷可以保留、回收、删除:</p><ul><li><strong>Retain</strong></li></ul><p>保留回收政策允许手动回收资源。删除 PVC 时，PV 仍然存在，并且该卷被视为 <em>已释放</em>。但它还不能被 Claim 使用，因为之前的 Claim 的数据仍在卷上。管理员可以通过以下步骤手动回收该卷:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 删除此PV</span><br><span class="line">2. 手动清理相关数据</span><br><span class="line">3. 手动删除关联的存储资产</span><br></pre></td></tr></table></figure><ul><li><strong>Recycle</strong></li></ul><p>警告：Recycle Claim Policy 将会被移除，不推荐使用。相反，推荐的方法是使用动态配置。</p><ul><li><strong>Delete</strong></li></ul><p>对于支持删除回收策略的卷插件，将删除k8s中的 PV 对象以及外部基础结构中的关联存储资产。动态配置的卷继承其 StorageClass 的回收策略(默认为Delete)。管理员应根据用户的期望配置StorageClass，否则PV必须在创建后进行编辑或修补。</p><p><br><br><br></p><h4 id="Expanding-Persistent-Volumes-Claims"><a href="#Expanding-Persistent-Volumes-Claims" class="headerlink" title="Expanding Persistent Volumes Claims"></a>Expanding Persistent Volumes Claims</h4><blockquote><p>FEATURE STATE: Kubernetes v1.8 alpha<br>FEATURE STATE: Kubernetes v1.11 beta</p></blockquote><p>只有将 <code>StorageClass</code> 的 <code>allowVolumeExpansion</code> 字段设置为 <code>true</code>，才能使用扩展的PVC。<br>现在默认启用对扩展PVC的支持。您可以扩展以下类型的卷：</p><ul><li>gcePersistentDisk</li><li>awsElasticBlockStore</li><li>Cinder</li><li>glusterfs</li><li>rbd</li><li>Azure File</li><li>Azure Disk</li><li>Portworx</li></ul><p><br></p><ul><li><strong>Resizing a volume containing a file system</strong></li></ul><p>如果文件系统是XFS，Ext3或Ext4，你可调整包含文件系统的卷的大小。<br>当卷包含文件系统时，仅在使用 RW模式下的 PVC 启动新Pod时才调整文件系统的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#如果PVC的状态为FileSystemResizePending，则使用PVC重新创建pod是安全的</span><br><span class="line">kubectl describe pvc &lt;pvc_name&gt;</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>Resizing an in-use PersistentVolumeClaim</strong></li></ul><blockquote><p>FEATURE STATE: Kubernetes v1.11 alpha</p></blockquote><p>要使用它，请启用 <strong>ExpandInUsePersistentVolumes</strong>。在这种情况下，您无需删除并重新创建使用现有PVC的Pod或Deployment。任何正在使用的PVC在其文件系统扩展后自动可用于其Pod。</p><p><br><br><br></p><h4 id="持久化卷的类型"><a href="#持久化卷的类型" class="headerlink" title="持久化卷的类型"></a>持久化卷的类型</h4><p>Types of Persistent Volumes</p><p>PV类型实现为插件， k8s 目前支持以下插件:</p><ul><li>GCEPersistentDisk</li><li>AWSElasticBlockStore</li><li>AzureFile</li><li>AzureDisk</li><li>FC (Fibre Channel)</li><li>FlexVolume</li><li>Flocker</li><li>NFS</li><li>iSCSI</li><li>RBD (Ceph Block Device)</li><li>CephFS</li><li>Cinder (OpenStack block storage)</li><li>Glusterfs</li><li>VsphereVolume</li><li>Quobyte Volumes</li><li>HostPath</li><li>Portworx Volumes</li><li>ScaleIO Volumes</li><li>StorageOS</li></ul><p><br><br><br></p><h4 id="Persistent-Volumes"><a href="#Persistent-Volumes" class="headerlink" title="Persistent Volumes"></a>Persistent Volumes</h4><p>每个PV都包含 <code>spec</code> 和 <code>status</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pv0003</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  capacity:</span></span><br><span class="line"><span class="attr">    storage:</span> <span class="number">5</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line"><span class="attr">  storageClassName:</span> <span class="string">slow</span></span><br><span class="line"><span class="attr">  mountOptions:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">hard</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">nfsvers=4.1</span></span><br><span class="line"><span class="attr">  nfs:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/tmp</span></span><br><span class="line"><span class="attr">    server:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="PersistentVolumeClaims"><a href="#PersistentVolumeClaims" class="headerlink" title="PersistentVolumeClaims"></a>PersistentVolumeClaims</h4><p>每个PVC都包含了 <code>spec</code> 和 <code>status</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myclaim</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">8</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  storageClassName:</span> <span class="string">slow</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      release:</span> <span class="string">"stable"</span></span><br><span class="line"><span class="attr">    matchExpressions:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">&#123;key:</span> <span class="string">environment,</span> <span class="attr">operator:</span> <span class="string">In,</span> <span class="attr">values:</span> <span class="string">[dev]&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Claims-As-Volumes"><a href="#Claims-As-Volumes" class="headerlink" title="Claims As Volumes"></a>Claims As Volumes</h4><p>Pods使用 <strong>claim as a volume</strong> 来访问存储。声明必须与使用声明的pod存在于同一名称空间中。群集在pod的命名空间中查找声明，并使用它来获取支持声明的PV，然后将卷挂载到主机并进入容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mypod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">myfrontend</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">dockerfile/nginx</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">      - mountPath:</span> <span class="string">"/var/www/html"</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">mypd</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">mypd</span></span><br><span class="line"><span class="attr">      persistentVolumeClaim:</span></span><br><span class="line"><span class="attr">        claimName:</span> <span class="string">myclaim</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="编写可移植配置"><a href="#编写可移植配置" class="headerlink" title="编写可移植配置"></a>编写可移植配置</h4><p>如果您正在编写在各种群集上运行并需要持久存储的配置模板或示例，我们建议您使用以下模式：</p><ul><li>在配置中包含PVC对象</li><li>不要在配置中包含PV对象，因为实例化配置的用户可能没有创建PV的权限</li><li>在实例化模板时，为用户提供提供存储类名称的选项<ul><li>如果用户提供存储类名称，请将该值放入 <code>persistentVolumeClaim.storageClassName</code> 字段中</li><li>如果用户未提供存储类名称，请将 <code>persistentVolumeClaim.storageClassName</code> 字段保留为 <code>nil</code></li><li>这将导致使用群集中的默认StorageClass为用户自动配置PV</li></ul></li><li>在您的工具中，请注意一段时间后未受约束的PVC并将其显示给用户，因为这可能表明群集没有动态存储支持或群集没有存储系统</li></ul><p><br><br><br><br><br></p><h3 id="Storage-Classes"><a href="#Storage-Classes" class="headerlink" title="Storage Classes"></a>Storage Classes</h3><p><strong>StorageClass</strong> 为管理员提供了一种描述他们提供的 <strong>存储类</strong> 的方法。不同的类可能映射到服务质量级别、备份策略，或者由集群管理员确定的任意策略。k8s 本身对于类代表什么是不受任何影响的，这个概念有时在其他存储系统中称为<code>profile</code>。</p><p><br><br><br><br><br></p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>Kubernetes 垃圾收集器的角色是删除指定的对象，这些对象曾经有但以后不再拥有 Owner 了。</p><p>某些Kubernetes对象是其它一些对象的Owner。如，一个副本集是一组pod的Owner。<br>具有Owner的对象被称为是Owner的<strong>Dependent</strong>。每个Dependent对象具有一个执行所属对象的<code>metadata.ownerReference</code>字段。</p><p>有时，Kubernetes会自动设置<code>ownerReference</code>的值。<br>也可以手动设置<code>ownerReference</code>的值，来指定Owner和Dependent之间的关系。</p><p><br></p><p><strong>控制垃圾收集器删除Dependent</strong></p><ul><li><p>级联删除</p><ul><li>background</li><li>foreground<br>删除对象时自动删除Dependent。<br>在bg级联删除模式下，k8s会立即删除Owner对象，然后垃圾收集器会在后台删除这些Dependent。<br>在fg级联删除模式下，根对象首先进入删除中状态。一旦对象被设置为删除中状态，垃圾收集器会删除对象的所有Dependent。</li></ul></li><li><p>孤儿<br>删除对象时，不自动删除它的Dependent。这些Dependent就被称作孤儿。垃圾收集器在删除了所有 “Blocking” 状态的 Dependent（对象的 ownerReference.blockOwnerDeletion=true）之后，它会删除 Owner 对象。</p></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p>Tutorials</p><p>教程展示了如何实现比单个任务更大的目标(task)。</p><p><br></p><h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><p>栗子里面包含一个Service和Deployment，请一定要注意yaml的语法格式，不使用<code>-</code>的话可能会报错。<br>很多k8s配置我们只需要在云界面上小配置，看它生成的YAML文件如何，之后再进行相应修改即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">#注意yaml语法错误</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment-test</span><br><span class="line">  namespace: default</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: nginx</span><br><span class="line">    env: test</span><br><span class="line">  annotations:</span><br><span class="line">    des: A k8s-deployment test</span><br><span class="line">    author: Zhang21</span><br><span class="line">    date: 2018-09-13</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      k8s-app: nginx</span><br><span class="line">  strategy:</span><br><span class="line">    type: RollingUpdate</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxUnavailable: 50%</span><br><span class="line">      maxSurge: 50%</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        k8s-app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      dnsPolicy: ClusterFirst</span><br><span class="line">      restartPolicy: Always</span><br><span class="line">      volumes:</span><br><span class="line">      - name: test01</span><br><span class="line">        emptyDir: &#123;&#125;</span><br><span class="line">      - name: test02</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /tmp/k8s/volume/test02</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.12.2</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">#特权容器</span><br><span class="line">        securityContext:</span><br><span class="line">          privileged: true</span><br><span class="line">        workingDir: /usr/share/nginx/html</span><br><span class="line">        ports:</span><br><span class="line">- protocol: TCP</span><br><span class="line">          containerPort: 80</span><br><span class="line">        readinessProbe:</span><br><span class="line">            httpGet:</span><br><span class="line">              path: /</span><br><span class="line">              port: 80</span><br><span class="line">              scheme: HTTP</span><br><span class="line">            initialDelaySeconds: 10</span><br><span class="line">            periodSeconds: 5</span><br><span class="line">          livenessProbe:</span><br><span class="line">            httpGet:</span><br><span class="line">              path: /</span><br><span class="line">              port: 80</span><br><span class="line">              scheme: HTTP</span><br><span class="line">            #60s内，Server未启动则重启容器</span><br><span class="line">            initialDelaySeconds: 60</span><br><span class="line">            periodSeconds: 10</span><br><span class="line">env:</span><br><span class="line">        - name: AUTHOR</span><br><span class="line">          value: Zhang21</span><br><span class="line">        - name: EMAIL</span><br><span class="line">          value: me@zhang21.cn</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: test01</span><br><span class="line">          mountPath: /usr/share/nginx/html/test01</span><br><span class="line">        - name: test02</span><br><span class="line">          mountPath: /usr/share/nginx/html/test02</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 100Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 0.3</span><br><span class="line">            memory: 300Mi</span><br><span class="line">      imagePullSecrets:</span><br><span class="line">        - name: docker-secret</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service-test</span><br><span class="line">  namespace: default</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: nginx</span><br><span class="line">  annotations:</span><br><span class="line">    des: A k8s Service test</span><br><span class="line">    author: Zhang21</span><br><span class="line">    date: 2018-09-13</span><br><span class="line">spec:</span><br><span class="line">  #记得指定应用，不然服务无法找到后端端点和容器组</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: nginx</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    nodePort: 31234</span><br><span class="line">    #The range of valid ports is 30000-32767</span><br><span class="line">    protocol: TCP</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: 80</span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br><span class="line">#</span><br><span class="line">#ClusterIP</span><br><span class="line">#spec:</span><br><span class="line">#  ports:</span><br><span class="line">#    - name: http</span><br><span class="line">#      protocol: TCP</span><br><span class="line">#      port: 80</span><br><span class="line">#      targetPort: 80</span><br><span class="line">#  selector:</span><br><span class="line">#    k8s-app: nginx</span><br><span class="line">#  type: ClusterIP</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#spec:</span><br><span class="line">#  ports:</span><br><span class="line">#    - name: http</span><br><span class="line">#      protocol: TCP</span><br><span class="line">#      port: 80</span><br><span class="line">#      targetPort: 80</span><br><span class="line">#  selector:</span><br><span class="line">#    k8s-app: nginx</span><br><span class="line">#  type: LoadBalancer</span><br><span class="line">#  loadBalancerIP: 1.2.3.4</span><br></pre></td></tr></table></figure><p><br></p><p>执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f ./nginx.yaml</span><br><span class="line"></span><br><span class="line">#apply可修改后更新</span><br><span class="line">kubectl apply -f ./nginx.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#之后在dashboard中查看成功与否</span><br><span class="line">#访问master 31234 port</span><br><span class="line">curl master:31234</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="k8s基本"><a href="#k8s基本" class="headerlink" title="k8s基本"></a>k8s基本</h2><p><br></p><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>本教程提供了Kubernetes集群编排系统基础知识的介绍。</p><p>你将学到：</p><ul><li>在集群上部署容器化服务</li><li>伸缩部署</li><li>使用新软件版本更新容器化应用程序</li><li>调试容器化应用程序</li></ul><p><br></p><p><strong>k8s能为你做什么？</strong><br>容器化有助于打包软件以实现这些目标，是应用程序能够以简单快速的方式发布和更新，而无需停机。k8s可帮助你确保这些容器化应用程序随时随地运行，并帮助它们找到运行所需的资源。</p><p><br></p><p><strong>k8s 基础模块</strong></p><ol><li>创建(create)一个k8s集群</li><li>部署(deploy)应用程序</li><li>探索(explore)应用程序</li><li>公开(expose)展示应用程序</li><li>伸缩(scale)应用程序</li><li>升级(update)应用程序</li></ol><p><br><br><br></p><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>Create a Cluseter</p><p>详情见安装部分。</p><p><br><br><br></p><h3 id="部署应用程序"><a href="#部署应用程序" class="headerlink" title="部署应用程序"></a>部署应用程序</h3><p>Deploy an APP</p><p><br></p><h4 id="使用kubectl创建部署"><a href="#使用kubectl创建部署" class="headerlink" title="使用kubectl创建部署"></a>使用kubectl创建部署</h4><p>Using kubectl to create a Deployment</p><p>目标：</p><ul><li>了解应用程序部署</li><li>在k8s上使用<code>kubectl</code>部署你的第一个应用程序</li></ul><p><br></p><p><strong>k8s Deployments</strong><br>一旦运行了k8s集群，就可在其上部署容器化应用程序。为此，你需要创建Kubernetes Deployment configuration。它指示k8s 如何创建和更新应用程序实例。创建部署后，k8s master将应用程序实例调度到各个node上。<br>创建应用程序实例后，Kubernetes Deployment Controller会持续监控这些实例。如果主机节点上的实例关闭或删除，Deployment Controller会替换它。这提供了一种自我修复(self-healing)机制来解决机器故障或维护。</p><p><br></p><p><strong>部署应用程序</strong><br>可使用<code>kubectl</code>(使用k8s api与集群交互)来创建和管理Deployment。下面有一些关于使用kubectl在k8s集群上创建和管理Deployment的基础命令。</p><p>创建部署时，你需要指定应用程序的容器镜像(image)，以及要运行的副本数(replicas)。你可在以后改变这些信息来更新你的部署。</p><p>栗子：<br>第一个部署，k8s使用一个Docker容器的<code>Node.js</code>应用程序包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">kubectl version</span><br><span class="line">#client</span><br><span class="line">#server</span><br><span class="line"></span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">#创建名为k8s-bootcamp的deployment</span><br><span class="line">kubectl run kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=8080</span><br><span class="line">#这是国内镜像: docker.io/jocatalin/kubernetes-bootcamp:v1</span><br><span class="line"></span><br><span class="line">kubectl get deployments</span><br><span class="line">NAME           DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubenetes-bootcamp   1         1        1           1          1h</span><br><span class="line">#表示 希望副本数，当前副本数，最新副本数，可用副本数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#由于pod被封装在集群私网，没有对外开放</span><br><span class="line">#proxy将通信转发到集群内私网</span><br><span class="line">kubectl proxy</span><br><span class="line">curl http://localhost:8081/version</span><br><span class="line">curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/</span><br><span class="line">#Hello Kubernetes bootcamp!</span><br></pre></td></tr></table></figure><p>此处我遇到一个错误，<code>replicats unavailable</code>:<br>原因是拉取的镜像在谷歌云上，无法访问<gcr.io>，拉取失败所以导致部署失败。<br>gcr(google container Registry)</gcr.io></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#查看部署信息</span><br><span class="line"> kubectl get deployment kubernetes-bootcamp -o yaml</span><br><span class="line">    message: &apos;unable to create pods: No API token found for service account &quot;default&quot;,</span><br><span class="line">      retry after the token is automatically created and added to the service account&apos;</span><br><span class="line">    reason: FailedCreate</span><br><span class="line">    status: &quot;True&quot;</span><br><span class="line">    type: ReplicaFailure</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl get deployments</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   1         0         0            0           33m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl describe deployments kubernetes-bootcamp</span><br><span class="line">Replicas:               1 desired | 0 updated | 0 total | 0 available | 1 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">ReplicaFailure   True    FailedCreate</span><br></pre></td></tr></table></figure><p>针对<strong>unable to create pods: No API token found for service account “default”</strong>这个问题，需要修改kube-apiserver配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#去掉 KUBE_ADMISSION_CONTROL中的SecurityContextDeny,ServiceAccount</span><br><span class="line">KUBE_ADMISSION_CONTROL=&quot;--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,ResourceQuota&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#重启kube-apiserver</span><br><span class="line">systemctl restart kube-apiserver</span><br><span class="line"></span><br><span class="line">#之后查看副本数就正常了</span><br><span class="line">kubectl get deployments</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   1         1         1            0           8m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#这里available还是0</span><br><span class="line">kubectl get pods</span><br><span class="line">NAME                                  READY     STATUS              RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-390780338-6x48n   0/1       ContainerCreating   0          21h</span><br><span class="line">#pod处于创建状态</span><br><span class="line"></span><br><span class="line">#查看详情</span><br><span class="line">kubectl describe pods</span><br><span class="line">#错误信息</span><br><span class="line">  Warning  FailedSync  4m (x258 over 21h)   kubelet, 192.168.31.159  Error syncing pod, skipping: failed to &quot;StartContainer&quot; for &quot;POD&quot; with ErrImagePull: &quot;image pull failed for registry.access.redhat.com/rhel7/pod-infrastructure:latest, this may be because there are no credentials on this request.  details: (open /etc/docker/certs.d/registry.access.redhat.com/redhat-ca.crt: no such file or directory)&quot;</span><br><span class="line">  Warning  FailedSync  9s (x5728 over 21h)  kubelet, 192.168.31.159  Error syncing pod, skipping: failed to &quot;StartContainer&quot; for &quot;POD&quot; with ImagePullBackOff: &quot;Back-off pulling image \&quot;registry.access.redhat.com/rhel7/pod-infrastructure:latest\&quot;&quot;</span><br><span class="line"></span><br><span class="line">#在node上查看此文件，发现它指向了一个空链接</span><br><span class="line">#并不存在/etc/rhsm目录</span><br><span class="line">ll /etc/docker/certs.d/registry.access.redhat.com/redhat-ca.crt</span><br><span class="line">lrwxrwxrwx. 1 root root 27 7月  16 16:58 /etc/docker/certs.d/registry.access.redhat.com/redhat-ca.crt -&gt; /etc/rhsm/ca/redhat-uep.pem</span><br><span class="line"></span><br><span class="line">#在node安装此rhsm</span><br><span class="line">yum search rhsm</span><br><span class="line">#python-rhsm-certificates.x86_64</span><br><span class="line">#python-rhsm.x86_64</span><br><span class="line">yum install -y python-rhsm.x86_64 python-rhsm-certificates.x86_64</span><br><span class="line">#之后在node上手动拉取下image便可看到pod正常运行</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="探索应用程序"><a href="#探索应用程序" class="headerlink" title="探索应用程序"></a>探索应用程序</h3><p>Explore Your App</p><p><br></p><h4 id="查看Pods和Nodes"><a href="#查看Pods和Nodes" class="headerlink" title="查看Pods和Nodes"></a>查看Pods和Nodes</h4><p>目标：</p><ul><li>了解k8s Pods</li><li>了解k8s Nodes</li><li>部署应用的故障解决(troubleshoot)</li></ul><p><br></p><p><strong>k8s Pods</strong><br>当你创建一个部署时，k8s创建了一个pod来托管你的应用程序实例。pod是k8s的一个抽象，表示一组(一个/多个)应用程序容器，以及这些容器的共享资源。<br>pod有一个唯一的IP地址，甚至是同一节点上的pod。pod中的容器共享IP地址和端口，始终位于同一位置并共同调度，并在同一节点上共享上下文中运行。<br>这些资源包括：</p><ul><li>共享存储(volumes)</li><li>网络(唯一的集群内ip)</li><li>运行容器的相关信息</li></ul><p><br></p><p><strong>Nodes</strong><br>pod总是运行在node上，一个node上可运行多个pod。每个node由master管理，master自动处理在node上调度pod。<br>node至少运行如下组件：</p><ul><li>kubelet</li><li>container runtime(如docker)</li></ul><p><br></p><p><strong>Troubleshooting with kubectl</strong><br>最常用的<code>kubectl</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#列出资源</span><br><span class="line">kubectl get</span><br><span class="line">#kubectl get nodes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#某个资源的详细信息</span><br><span class="line">kubectl describe</span><br><span class="line">#kubectl describe deployments kubernetes-bootcamp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pod中容器日志</span><br><span class="line">kubectl logs</span><br><span class="line">#kubectl logs $pod --since=1h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在pod的容器执行命令</span><br><span class="line">kubectl exec</span><br><span class="line">#kubectl ecec $pod env</span><br><span class="line">#kubectl exec -it $pod /bin/bash</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="公开展示应用程序"><a href="#公开展示应用程序" class="headerlink" title="公开展示应用程序"></a>公开展示应用程序</h3><p>Expose Your App Publicly</p><p><br></p><h4 id="使用服务来展示应用程序"><a href="#使用服务来展示应用程序" class="headerlink" title="使用服务来展示应用程序"></a>使用服务来展示应用程序</h4><p>Using a Service to Expose Your App</p><p>目标：</p><ul><li>了解k8s中的服务(service)</li><li>理解labels和LabelSelector对象如何关联服务</li><li>使用服务将应用程序展示在集群外部</li></ul><p><br></p><p><strong>k8s Service</strong><br>事实上，pods有一个生命周期。当工作node死亡，node上运行的pods也会丢失。ReplicationController可以通过创建新的Pod来动态地将集群驱动会所需状态，以使应用程序保持运行。<br>k8s的服务是一个抽象概念，它定义了一组逻辑Pod和一个访问pods的策略。服务使用YAML或JSON来定义。由一组pods所构成的服务通常由LabelSelector来确定。<br>尽管每个Pod都有一个唯一的IP地址，但如果没有服务，这些IP就不会在集群外公开。<br>通过指定ServeceSpec中的type，可以不同方式公开服务:</p><ul><li><p>ClusterIP(默认方式)<br>在集群内部IP公开服务，只可内部访问</p></li><li><p>NodePort<br>使用NAT在集群的指定节点上公开服务</p></li><li><p>LoadBalancer<br>创建一个外部负载均衡器，并给服务分配一个外部IP</p></li><li><p>ExternalName<br>通过返回带有名称的CNAME(k8s-dns)记录，使用任意名称公开服务</p></li></ul><p><br></p><p><strong>Services和Labels</strong><br>服务使用labels和selectors匹配一组pod这是一个允许对k8s的对象进行逻辑操作的分组原语。<br>Label是附件到对象的键/值对，随时随地可修改。有多种方式可使用：</p><ul><li>指定用于开发(development)、测试(test)、生产(procuct)的对象</li><li>嵌入版本tag</li><li>使用tag对对象进行分类</li></ul><p><br></p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br><span class="line">#NAME                                  READY     STATUS    RESTARTS   AGE</span><br><span class="line">#kubernetes-bootcamp-390780338-6x48n   1/1       Running   0          22h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl get services</span><br><span class="line">#NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">#kubernetes   ClusterIP   10.254.0.1   &lt;none&gt;        443/TCP   1d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#公开展示应用程序</span><br><span class="line">kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 8080</span><br><span class="line">#service &quot;kubernetes-bootcamp&quot; exposed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl get services</span><br><span class="line">#NAME                  TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">#kubernetes            ClusterIP   10.254.0.1     &lt;none&gt;        443/TCP          1d</span><br><span class="line">#kubernetes-bootcamp   NodePort    10.254.11.76   &lt;none&gt;        8080:31514/TCP   2m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl describe services/kubernetes-bootcamp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl describe deployment</span><br><span class="line">#Labels:                 run=kubernetes-bootcamp</span><br><span class="line">#使用label查询</span><br><span class="line">kubectl get pods -l run=kubernetes-bootcamp</span><br><span class="line">kubectl get services -l run=kubernetes-bootcamp</span><br><span class="line">#使用label删除</span><br><span class="line">kubectl delete service -l run=kubernetes-bootcamp</span><br><span class="line"></span><br><span class="line">kubectl describe pods kubernetes-bootcamp-390780338-6x48n</span><br><span class="line"></span><br><span class="line">kubectl exec -it kubernetes-bootcamp-390780338-6x48n /bin/bash</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="扩展应用程序"><a href="#扩展应用程序" class="headerlink" title="扩展应用程序"></a>扩展应用程序</h3><p>Scale Your App</p><p>Running Multiple Instances of Your App</p><p>目标：</p><ul><li>使用<code>kubectl</code>伸缩应用程序</li></ul><p><br></p><p><strong>伸缩应用程序</strong><br>前面通过部署创建的服务仅有一个pod，当遇到流量激增，我们便需要扩展应用程序。<br>通过更改部署中的副本数来完成扩展。</p><p>扩展部署将确保使用可用资源(available resource)创建新的pod并将其调度到node。k8s支持Pod的自动伸缩，缩放到0(也就是没有pod)也是可能的，它将终止指定部署的所有Pod。<br>对应用程序运行多个实例需要一种方法将流量分配给所有这些实例。服务有集成的负载均衡器(load-blancer)，可将网络流量分配到公开部署的所有Pod。服务将使用endpoint持续监控运行的Pod，以确保网络流量发送到可用的Pods。</p><p>一旦运行的应用程序有了多个实例，你就可以在不停机(downtime)的情况下执行滚动更新(rolling update)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments</span><br><span class="line">#1个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#扩展实例</span><br><span class="line">kubectl scale deployments/kubernetes-bootcamp --replicas=4</span><br><span class="line">#deployment.extensions &quot;kubernetes-bootcamp&quot; scaled</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl get deployments</span><br><span class="line">#4个</span><br><span class="line">kubectl get pods -o wide</span><br><span class="line">#4个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl describe deployment/kubernetes-bootcamp</span><br><span class="line">kubectl describe services/kubernetes-bootcamp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#缩放实例</span><br><span class="line">kubectl scale deployments/kubernetes-bootcamp --replicas=2</span><br><span class="line">#deployment.extensions &quot;kubernetes-bootcamp&quot; scaled</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl get deployments</span><br><span class="line">#2个</span><br><span class="line"></span><br><span class="line">#有两个pods正在关闭中</span><br><span class="line">kubectl get pods -o wide</span><br><span class="line">NAME                                  READY     STATUS        RESTARTS   AGE       IP            NODE</span><br><span class="line">kubernetes-bootcamp-390780338-1zgvs   1/1       Terminating   0          7m        10.254.76.5   192.168.31.159</span><br><span class="line">kubernetes-bootcamp-390780338-6x48n   1/1       Running       0          2d        10.254.76.2   192.168.31.159</span><br><span class="line">kubernetes-bootcamp-390780338-bqztg   1/1       Running       0          7m        10.254.76.4   192.168.31.159</span><br><span class="line">kubernetes-bootcamp-390780338-hkwfd   1/1       Terminating   0          7m        10.254.76.3   192.168.31.159</span><br><span class="line"></span><br><span class="line">#关闭完成</span><br><span class="line">kubectl get pods -o wide</span><br><span class="line">NAME                                  READY     STATUS    RESTARTS   AGE       IP            NODE</span><br><span class="line">kubernetes-bootcamp-390780338-6x48n   1/1       Running   0          2d        10.254.76.2   192.168.31.159</span><br><span class="line">kubernetes-bootcamp-390780338-bqztg   1/1       Running   0          15m       10.254.76.4   192.168.31.159</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="升级应用程序"><a href="#升级应用程序" class="headerlink" title="升级应用程序"></a>升级应用程序</h3><p>Update your App<br>Performing a Rolling Update</p><p>目标：</p><ul><li>使用<code>kubectl</code>执行滚动升级</li></ul><p><br></p><p><strong>滚动更新</strong><br>用户希望应用程序始终可用，可发人员可能会多次部署新版本应用程序。在k8s中，这都可以通过滚动更新(rolling update)完成。<br>滚动更新允许通过使用新的实例逐步更新Pod来实现部署的更新，而不需停机(downtime)。新的Pod将在具有可用资源的node上进行调度。<br>在k8s中，更新是版本化的，任何部署更新都可以恢复到以前的版本。</p><p>与应用程序扩展类似，服务在更新期间仅会将流量负载均衡到可用的Pod(应用实例)。</p><p>滚动更新允许以下操作：</p><ul><li>将应用程序从一个环境推到另一个环境</li><li>回滚(rollback)到之前的版本</li><li>无需停机的持续集成(CI)和持续交付(CD)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments</span><br><span class="line">kubectl get pods</span><br><span class="line">#2个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#更新镜像</span><br><span class="line">kubectl set image deployments/kubernetes-bootcamp  kubernetes-bootcamp=docker.io/jocatalin/kubernetes-bootcamp:v2</span><br><span class="line">deployment.apps &quot;kubernetes-bootcamp&quot; image updated</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">kubectl get pods</span><br><span class="line">NAME                                  READY     STATUS        RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-390780338-6x48n   1/1       Terminating   0          3d</span><br><span class="line">kubernetes-bootcamp-390780338-bqztg   1/1       Terminating   0          38m</span><br><span class="line">kubernetes-bootcamp-472176051-m6h1q   1/1       Running       0          29s</span><br><span class="line">kubernetes-bootcamp-472176051-z4wqs   1/1       Running       0          29s</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">kubectl get pods</span><br><span class="line">NAME                                  READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-472176051-m6h1q   1/1       Running   0          42s</span><br><span class="line">kubernetes-bootcamp-472176051-z4wqs   1/1       Running   0          42s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#检查回滚状态</span><br><span class="line">kubectl rollout status deployments/kubernetes-bootcamp</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; successfully rolled out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=docker.io/jocatalin/kubernetes-bootcamp:v10</span><br><span class="line">deployment.apps &quot;kubernetes-bootcamp&quot; image updated</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#有错</span><br><span class="line">kubectl get deployments</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   2         3         2            1           3d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#有错</span><br><span class="line">kubectl get pods</span><br><span class="line">NAME                                  READY     STATUS             RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-384357858-7kjx1   0/1       ErrImagePull       0          2m</span><br><span class="line">kubernetes-bootcamp-384357858-t0wmt   0/1       ImagePullBackOff   0          2m</span><br><span class="line">kubernetes-bootcamp-472176051-m6h1q   1/1       Running            0          9m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">kubectl describe pods</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#回滚</span><br><span class="line">kubectl rollout undo deployments/kubernetes-bootcamp</span><br><span class="line">deployment.apps &quot;kubernetes-bootcamp&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">kubectl get pods</span><br><span class="line">kubectl decribe pods</span><br><span class="line">#Image:          docker.io/jocatalin/kubernetes-bootcamp:v2</span><br><span class="line">#回到了V2版</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h2><p>Configuration</p><p><br></p><h3 id="使用ConfigMap配置Redis"><a href="#使用ConfigMap配置Redis" class="headerlink" title="使用ConfigMap配置Redis"></a>使用ConfigMap配置Redis</h3><p><strong>目标(Objective)</strong></p><ul><li>创建ConfigMap</li><li>使用ConfigMap创建Pod规范</li><li>创建Pod</li><li>验证配置是否正确应用</li></ul><p><br></p><p><strong>开始之前</strong><br>需要有k8s集群，并且安装了<code>kubectl</code>命令行工具。</p><p><br></p><p><strong>栗子：使用ConfigMap配置Redis</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#Master</span><br><span class="line">#创建redis的ConfigMap</span><br><span class="line">kubectl create configmap redis-config --from-file=xxx/redis-config</span><br><span class="line">kubectl get configmap redis-config -o yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建redis-pod.yaml文件</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: redis</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: redis</span><br><span class="line">    image: kubernetes/redis:v1</span><br><span class="line">    env:</span><br><span class="line">    - name: MASTER</span><br><span class="line">      value: &quot;true&quot;</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 6379</span><br><span class="line">    resources:</span><br><span class="line">      limits:</span><br><span class="line">        cpu: &quot;0.1&quot;</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /redis-master-data</span><br><span class="line">      name: data</span><br><span class="line">    - mountPath: /redis-master</span><br><span class="line">      name: config</span><br><span class="line">  volumes:</span><br><span class="line">    - name: data</span><br><span class="line">      emptyDir: &#123;&#125;</span><br><span class="line">    - name: config</span><br><span class="line">      configMap:</span><br><span class="line">        name: redis-config</span><br><span class="line">        items:</span><br><span class="line">        - key: redis-config</span><br><span class="line">          path: redis.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建pod</span><br><span class="line">kubectl create -f /etc/k8s/pods/config/redis-pod.yaml</span><br><span class="line"></span><br><span class="line">kubectl exec -it redis redis-cli</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="无状态应用程序"><a href="#无状态应用程序" class="headerlink" title="无状态应用程序"></a>无状态应用程序</h2><p>Stateless Applications</p><p><br></p><h3 id="公开外物IP以访问集群中的应用程序"><a href="#公开外物IP以访问集群中的应用程序" class="headerlink" title="公开外物IP以访问集群中的应用程序"></a>公开外物IP以访问集群中的应用程序</h3><p>Exposing an External IP Address to Access an Application in a Cluster</p><p><strong>目标</strong></p><ul><li>为一个Hello World应用程序运行五个实例</li><li>创建一个展示外部IP的服务对象</li><li>使用服务对象去访问运行的应用程序</li></ul><p><br></p><p><strong>为运行五个pods的应用程序创建一个服务</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#运行hello world</span><br><span class="line">kubectl run hello-world --replicas=5 --labels=&quot;run=load-balancer-example&quot; --image=gcr.io/google-samples/node-hello:1.0  --port=8080</span><br><span class="line">#--image=docker.io/jocatalin/hellonode:v1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看信息</span><br><span class="line">kubectl get deployments hello-world</span><br><span class="line">kubectl describe deployments hello-world</span><br><span class="line"></span><br><span class="line">kubectl get replicasets</span><br><span class="line">kubectl describe replicasets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建展示部署的服务对象</span><br><span class="line">kubectl expose deployment hello-world --type=LoadBalancer --name=my-service</span><br><span class="line">#如果外部地址显示为pending，请等待几分钟</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看信息</span><br><span class="line">kubectl get services my-service</span><br><span class="line">kubectl describe services my-service</span><br><span class="line">#可看到LoanBlancer Ingress</span><br><span class="line"></span><br><span class="line">kubectl get pods --output=wide</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#访问外部地址(LoadBalancer Ingress)</span><br><span class="line">curl http://&lt;external-ip&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>清理</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#删除服务</span><br><span class="line">kubectl delete services my-service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除正在运行的程序的Deployment，ReplicaSet，Pods</span><br><span class="line">kubectl delete deployment hello-world</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br><br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes: &lt;a href=&quot;https://zh.wikipedia.org/wiki/Kubernetes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;官方文档: &lt;a href=&quot;https://kubernetes.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://kubernetes.io/docs/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中文文档: &lt;a href=&quot;http://docs.kubernetes.org.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://docs.kubernetes.org.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub: &lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kubernetes/kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;etcd: &lt;a href=&quot;https://coreos.com/etcd/docs/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://coreos.com/etcd/docs/latest/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;flannel: &lt;a href=&quot;https://coreos.com/flannel/docs/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://coreos.com/flannel/docs/latest/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7x86_64&lt;/li&gt;
&lt;li&gt;Kubernetes v1.11&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Kubernetes" scheme="https://zhang21.github.io/tags/Kubernetes/"/>
    
      <category term="k8s" scheme="https://zhang21.github.io/tags/k8s/"/>
    
  </entry>
  
</feed>
