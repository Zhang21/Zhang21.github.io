<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风继续吹</title>
  
  <subtitle>Yesterday, you said tomorrow!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhang21.github.io/"/>
  <updated>2018-03-25T03:33:30.245Z</updated>
  <id>https://zhang21.github.io/</id>
  
  <author>
    <name>Zhang21</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《网站运维》读书笔记</title>
    <link href="https://zhang21.github.io/2018/03/05/%E7%BD%91%E7%AB%99%E8%BF%90%E7%BB%B4/"/>
    <id>https://zhang21.github.io/2018/03/05/网站运维/</id>
    <published>2018-03-05T14:34:49.000Z</published>
    <updated>2018-03-25T03:33:30.245Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>《网站运维：保持数据实时的秘籍》(Web Operations: Keeping the Data on Time)</li></ul><p><br><br><br></p><a id="more"></a><p><br></p><h1 id="作为职业的运维"><a href="#作为职业的运维" class="headerlink" title="作为职业的运维"></a>作为职业的运维</h1><p>互联网变化如此之快，以至于几乎没有时间认真思考一下我们在做什么，以及为什么做。我们奋力拼搏，才避免被淘汰出局，哪里还敢谈论什么引领潮流呢！这种高压、过度刺激的环境使得所有努力都只是为了一份工作，而没有职业的概念了。</p><p>职业是指占去你人生大部分时光的事业，并能够逐步晋升。工作只是拿钱干活儿，换句话说，工作就只是工作而已。</p><p><br></p><h2 id="为什么运维如此艰难"><a href="#为什么运维如此艰难" class="headerlink" title="为什么运维如此艰难"></a>为什么运维如此艰难</h2><p>运维对如下领域都有深入的理解：<strong>网络、路由、交换、防火墙、负载均衡、高可用性、灾难恢复、TCP与UDP服务、网络运维中心管理、硬件规范、各种Unix、各种Web服务器技术、高速缓存技术、数据库技术、存储基础架构、密码学、算法、趋势分析、容量规划…</strong></p><p>运维要求广博，可以说几乎是不可接受的。</p><p>运维领域成为一个合格的人选，需要具备三点素质：<strong>扎实的计算背景、娴熟的决断力、沉稳的性格</strong>。</p><p><br></p><h3 id="扎实的计算背景"><a href="#扎实的计算背景" class="headerlink" title="扎实的计算背景"></a>扎实的计算背景</h3><p>运维要求理解架构中的各个组成部分，在理解计算系统的来龙去脉时，扎实的计算背景对你会有莫大的帮助。具有扎实的基础，对于理解为什么及如何架构解决方案，以及识别出问题所在，是非常重要的。毕竟，计算是架构我们的智能系统的基础。此外，工程师的思维方式和对物理定律的基本理解，也是一个很大的优势。</p><p>运维会经常遇到随意的、不切实际的期望。<br>运维，就是理解理论和实践在哪里发生冲突，并发明适当的方法，以便在发生事故时减少损失。</p><p><br></p><h3 id="娴熟的决断力"><a href="#娴熟的决断力" class="headerlink" title="娴熟的决断力"></a>娴熟的决断力</h3><p>虽然优柔寡断在任何领域都不算是一个优点，但在运维中却几乎不能容忍。</p><p><br></p><h3 id="沉稳的性格"><a href="#沉稳的性格" class="headerlink" title="沉稳的性格"></a>沉稳的性格</h3><p>一个沉稳与可控的思维过程是非常关键的，需要保持自己是清醒的一方。</p><p>在运维领域，目标很简单，使所有事情在所有时间正常运转。一个简单的定义，但却是一个不可能的期望。或许在这个领域成为一名工程师的更大挑战是组织内的同事对你的不切实际的期望。</p><p><br><br><br></p><h2 id="从学徒到师傅"><a href="#从学徒到师傅" class="headerlink" title="从学徒到师傅"></a>从学徒到师傅</h2><p>掌握任何知识领域都需要四项基本要求：<strong>知识、工具、经验和纪律</strong>。</p><p><br></p><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p>互联网行业的一个独特之处就是几乎所有的东西都是公开的，事实上，有专有权的东西也是极少的，而更为独特的是，几乎所有规范文档都是免费的。</p><p>在你走在从从学徒到师傅的路途中，尽可能多滴占有信息是你的职责，这样你的大脑才能将那些细微之处进行排序、过滤、关联，使其成为一幅简明、精确的图画，从而有助于你的决策——不管是长期的架构设计的关键决策，还是临时的排除故障的决策。</p><p><br></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>虽然工具各有优缺点，然而人们使用这些工具都取得了成功。制造和使用工具使我们人类的本性。<br>所有的工具归根结底都只是人类肢体和感觉器官的延长。</p><p>师傅不适用工具炼成的。在互联网应用的环境中，你会看得更清楚，五花八门的语言、平台、技术都能够成功地结合在一起，将这些成功地构建为一个架构的，不是Java或PHP，而是设计与实现它的工程师——那些师傅们。</p><p>工具上的一个真理是，不管在用的工具是什么，要了解你的工具，这是在这个行业登堂入室的前提。灵巧地运用工具的能力，比工具本身的质量要重要的多。话虽如此，有经验的工程师还是应该手边备一件合适的高质量的工具。</p><p><br></p><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><p>从最本质的意义上来说，经验意味着良好的判断力，而良好的判断力却是从很多失败中取得的。</p><p>经验与知识是紧密相关的，知识可以认为是他人经验的总结。<br>经验既是一个名词，也是一个动词。获得经验与应用经验，同样容易也同样困难。</p><p>一名资深工程师最大的特点是其一致与可靠的良好判断力。很显然，这要在需要做出判断的场合经受锻炼。</p><p>对进入运维这个领域而没有什么经验的工程师，我的忠告是：<strong>耐心</strong>。</p><p><br></p><h3 id="纪律"><a href="#纪律" class="headerlink" title="纪律"></a>纪律</h3><p>通过尽可能正确而高效地做事，从而为解决同样问题，而尽可能地少做工作。</p><p><br><br><br></p><hr><p><br></p><h1 id="如何应用云计算-Elastic-Compute"><a href="#如何应用云计算-Elastic-Compute" class="headerlink" title="如何应用云计算(Elastic Compute)"></a>如何应用云计算(Elastic Compute)</h1><p>云服务器(ECS, Elastic Compute Service)</p><p><br></p><h2 id="什么地方适合云计算"><a href="#什么地方适合云计算" class="headerlink" title="什么地方适合云计算"></a>什么地方适合云计算</h2><p>灵活性和一定程度上的自由是云服务器的特点，当然，本地服务器同样有这个特点。</p><p><br></p><h3 id="混合计算"><a href="#混合计算" class="headerlink" title="混合计算"></a>混合计算</h3><p>混合计算=云计算+本地计算</p><p><br></p><h2 id="什么地方不适合云计算"><a href="#什么地方不适合云计算" class="headerlink" title="什么地方不适合云计算"></a>什么地方不适合云计算</h2><p>当然，最先考虑的肯定是经济层面。</p><p>服务层与数据库是紧密耦合的，所以使它们之间的网络延迟最小化是很重要的。这意味着它们要么全在云里，要么全在云外。</p><p><br></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>尽管有大量广告吹嘘完整托管在云里，但从运维角度来说，混合应用架构模式或许是最有趣的。有些事情在云里做的不一定好。脚踏两只船，你才会游刃有余。</p><p>混合应用还强调一点，就是传统运维中的最佳时间仍然是成功的公司的云应用所必须的。</p><p><br><br><br></p><hr><p><br></p><h1 id="基础架构与应用程序测量"><a href="#基础架构与应用程序测量" class="headerlink" title="基础架构与应用程序测量"></a>基础架构与应用程序测量</h1><p>任何规模的运维，采集测量数据就像将服务器连接到网络上一样重要，对于一个规模不断增长的基础架构来说，或许更加重要。</p><p>我们不光讨论你要采集并监视的测量数据的种类，还要讨论为了应对各种情况，你能利用这些数据做些什么。</p><p>测量数据的采集和带有报警(alerting)功能的监控有明显的区别。</p><p><br><br><br></p><h2 id="时间刷新率和存留时间的考虑"><a href="#时间刷新率和存留时间的考虑" class="headerlink" title="时间刷新率和存留时间的考虑"></a>时间刷新率和存留时间的考虑</h2><p>随着采集的数据不断增长，确保这些数据能够一直可查询和移动，这是很明智的。</p><p>如Zabbix中——获取数据的时间刷新率和数据保存时间。历史数据保留时长和趋势数据存储时间。<br>比如有的数据要30s获取一次，而有的信息只需要1h获取一次。</p><p>测量数据真正出彩的地方：</p><ul><li>对于某个特定的资源，每天的峰值是哪些？每周的峰值日是哪些？每年的峰值月是哪些？</li><li>有季节性模式吗？<ul><li>如夏时日和节假日会高一些</li></ul></li><li>最大(波峰)值与最小(波谷)值比较起来怎么样？</li><li>在用户分布广泛的情况下，波峰与波谷是否发生变化？</li></ul><p><br><br><br></p><h2 id="测量数据采集与存储的地点"><a href="#测量数据采集与存储的地点" class="headerlink" title="测量数据采集与存储的地点"></a>测量数据采集与存储的地点</h2><p>无论使用什么采集工具，易于采集和便于得出结果都是必须要考虑的。</p><p><br><br><br></p><h2 id="测量数据的层次"><a href="#测量数据的层次" class="headerlink" title="测量数据的层次"></a>测量数据的层次</h2><p>不同层次的数据存储在不同的数据库中。</p><p><br></p><h3 id="高层业务或功能特定的测量数据"><a href="#高层业务或功能特定的测量数据" class="headerlink" title="高层业务或功能特定的测量数据"></a>高层业务或功能特定的测量数据</h3><p>有了这些高层数据之后，面向产品的那些人对这些数据也抱有极大的兴趣，你一点都不用感到惊讶。</p><p>对于应用层面的数据，最有用的是能够跟踪用户的交互情况。</p><p><br></p><h3 id="系统及服务层面的测量数据"><a href="#系统及服务层面的测量数据" class="headerlink" title="系统及服务层面的测量数据"></a>系统及服务层面的测量数据</h3><p>这些是在运维工程师电脑上以图形方式显示的数据。</p><p><br></p><p>测量数据的层次：</p><table><thead><tr><th>-</th><th>例子</th><th>测量项目</th></tr></thead><tbody><tr><td>应用层</td><td>网页或API</td><td>故障：类型、延迟、发生率…</td></tr><tr><td>服务层</td><td>Nginx, MySQL, MongoDB…</td><td>Nginx: 请求频率、响应时间、忙碌的工作进程… <br> MySQL/MongoDB：导致故障的查询类型、慢查询、连接数…</td></tr><tr><td>物理层</td><td>CPU、内存、网络、硬盘</td><td>内存：繁忙程度 <br> 内存：空闲内存 <br> 硬盘：可用空间，I/O速率 <br> 网络：网络I/O带宽情况</td></tr></tbody></table><p>有了这些数据，就能够回答如下问题：</p><ul><li>平均的Web请求时间</li><li>CPU时间</li><li>调用最多的数据库查询</li><li>数据库慢查询</li><li>文件系统缓存</li><li>最大的页面响应</li><li>…</li></ul><p><br><br><br></p><h2 id="为异常检测和报警提供环境"><a href="#为异常检测和报警提供环境" class="headerlink" title="为异常检测和报警提供环境"></a>为异常检测和报警提供环境</h2><p>在本地采集的测量数据的主要理由，就像油表一样，有了这些数据，就可以明白基础架构正在发生什么，以及正在驶向何方。<br>知道哪里的资源在增长或缩减，能够进行预测。使用预测对基础架构的容量需求进行预报，称为容量规划。<br>观察网站运行是否有异常时，测量数据就派上用场了。</p><p>发生异常是，测量数据回味报警提供相关信息。报警的信息要尽量简明，告知检测到了什么，以及何时检测到。而测量数据会告诉你报警都发生了什么。</p><p><br><br><br></p><h2 id="日志记录也是测量数据"><a href="#日志记录也是测量数据" class="headerlink" title="日志记录也是测量数据"></a>日志记录也是测量数据</h2><p>应用程序的日志文件也提供了测量数据和使用情况的信息。这些信息用于追踪过去发生的事件。</p><p><br><br><br></p><h2 id="将变化管理和事件的时间线建立关联"><a href="#将变化管理和事件的时间线建立关联" class="headerlink" title="将变化管理和事件的时间线建立关联"></a>将变化管理和事件的时间线建立关联</h2><p>更新生产系统会带来风险。<br>记录更新发生的时间，从而保留更新的踪迹，这在发生问题需要进行追踪时是非常有价值的。</p><p><br><br><br></p><h2 id="给测量数据加入报警机制"><a href="#给测量数据加入报警机制" class="headerlink" title="给测量数据加入报警机制"></a>给测量数据加入报警机制</h2><p>Zabbix、Nagios等就是一个测量数据采集系统配合使用的监控/报警工具。</p><p><br><br><br></p><h2 id="使用测量数据建立加载-反馈机制"><a href="#使用测量数据建立加载-反馈机制" class="headerlink" title="使用测量数据建立加载-反馈机制"></a>使用测量数据建立加载-反馈机制</h2><p>采集时序数据的另一个好处，就是能够通过编程使你的应用生成测量数据，从而可以建立安全、精密的反馈循环。</p><p><br><br><br></p><h2 id="结语-1"><a href="#结语-1" class="headerlink" title="结语"></a>结语</h2><p>测量数据的采集、存储、显示，可以认为是web基础架构的关键部分。不论是及时排查错误，预测容量、规划产品的发布，还是建立应用的反馈机制，如果没有正确的测量数据为你提供一个基础架构运行的全景图的话，你会损失惨重。</p><p>设计数据如何经过系统时，要考虑安全问题，而且数据要易于导出到其它应用。一旦运维部门采集了测量数据，你会发现，追踪数据是一件多么有趣的事情，同时也能使工作更加轻松。</p><p><br><br><br></p><hr><p><br></p><h1 id="连续部署"><a href="#连续部署" class="headerlink" title="连续部署"></a>连续部署</h1><p>软件应该以小批量的方式进行设计、编写和部署。</p><p>批量大小是产品在开发过程的各个阶段转移的单位。对于软件而言，最容易看到的批量是代码。每次工程师检入代码，都是在提交一定量的工作。有很多技术用来控制这些批量，从连续部署所需的最小批量到更为传统的分支开发，在分支开发中，多个开发者工作数周或数月产生的所有代码将被成批处理，并集中到一起。</p><p>结果证明，以远小于传统做法的建议的批量工作，有极大的好处。</p><p><br><br><br></p><h2 id="小批量意味着更快的反馈"><a href="#小批量意味着更快的反馈" class="headerlink" title="小批量意味着更快的反馈"></a>小批量意味着更快的反馈</h2><p>工作转移到下一阶段越快，则也就能越快地发现下一个阶段是如何接纳你的工作的。</p><p><br><br><br></p><h2 id="小批量意味着问题即刻被本地化"><a href="#小批量意味着问题即刻被本地化" class="headerlink" title="小批量意味着问题即刻被本地化"></a>小批量意味着问题即刻被本地化</h2><p>问题发现得越快，则解决的也越快。</p><p>每次部署，都只有少量代码有变化，所以导致回归或料想不到的性能问题的任何变化，都能够快速识别出来，并进行改正。当然，由于需要改正或回滚的变化数量不仅是确定的，也是很小的，所以解决问题的平均时间也就很低了。</p><p><br><br><br></p><h2 id="小批量能够减少风险"><a href="#小批量能够减少风险" class="headerlink" title="小批量能够减少风险"></a>小批量能够减少风险</h2><p><br><br><br></p><h2 id="小批量可以降低总开销"><a href="#小批量可以降低总开销" class="headerlink" title="小批量可以降低总开销"></a>小批量可以降低总开销</h2><p>大多数机构都会降低自己的批量大小，以降低总的开销。<br>大批量导致的瓶颈经常是隐含的，是这些隐含的瓶颈显现出来，是需要开销的，甚至要投入更多的工作才能修正这些瓶颈。</p><p>连续部署的目标，是在减小批量的同时，帮助开发团队清除开发过程中的垃圾，加快工作步伐。这样就能使各个团队处于持续的流动状态，这种状态使得团队的创新、试验变得非常容易，从而形成可持续发展的良性循环。</p><p><br><br><br></p><h2 id="质量卫士的挽歌"><a href="#质量卫士的挽歌" class="headerlink" title="质量卫士的挽歌"></a>质量卫士的挽歌</h2><p>产生开发过程中的垃圾的一个很大原因是重复检查。</p><p>连续集成，有助于加快缺陷反馈流程；故事卡和看板，用于降低批量大小；日站，有助于加快步伐；连续部署也是这样的技术，有能力是开发团队更有活力。</p><p><br></p><h3 id="为什么连续部署能行"><a href="#为什么连续部署能行" class="headerlink" title="为什么连续部署能行"></a>为什么连续部署能行</h3><p>连续部署区分了发布的两种不同的定义：</p><ul><li>一个是工程师使用的，指的是将代码完全集成到生产环境中的过程；</li><li>另一个是市场部门使用的，指的是客户看到的东西</li></ul><p>使用连续部署，代码一旦写完，就在去往生产环境的路上了。<br>连续部署也起着速度调节器的作用。</p><p>这种速度调节，对于习惯于通过个体效率来度量其进步的团队来说，是一种技巧性的调整。在这种团队中，每个工程师的头等大事就是保持忙碌。不幸的是，这种观点忽略了团队的整体生产能力。对于有些情形，大家坐下来讨论，找出协调方法，从而不需要做重复工作，这时候才是有效率的。</p><p><br><br><br></p><h2 id="让我们开始吧"><a href="#让我们开始吧" class="headerlink" title="让我们开始吧"></a>让我们开始吧</h2><h3 id="步骤1：连续集成服务器"><a href="#步骤1：连续集成服务器" class="headerlink" title="步骤1：连续集成服务器"></a>步骤1：连续集成服务器</h3><p>这是连续部署的脊梁。我们需要一个中心服务器，运行所有的自动化测试，并监控每一次的提交。</p><p><br></p><h3 id="步骤2：源代码控制提交检查"><a href="#步骤2：源代码控制提交检查" class="headerlink" title="步骤2：源代码控制提交检查"></a>步骤2：源代码控制提交检查</h3><p>下一个需要的基础框架是源代码控制服务器，并带有能进行提交检查的甲苯。如CVS、SVN、Git等。</p><p>作为一个团队，我们的目标是在能够可靠地生产高质量代码的前提下，尽可能快地工作，但不要过快。</p><p><br></p><h3 id="步骤3：简单的部署脚本"><a href="#步骤3：简单的部署脚本" class="headerlink" title="步骤3：简单的部署脚本"></a>步骤3：简单的部署脚本</h3><p>建立一个关键的部署脚本，用于逐台机器进行增量备份，与此同时，监控集群和业务的运行情况。这样一旦出现异常，就可以快速恢复。</p><p><br></p><h3 id="步骤4：实时报警"><a href="#步骤4：实时报警" class="headerlink" title="步骤4：实时报警"></a>步骤4：实时报警</h3><p>无论部署过程多么完美，缺陷仍然会通过部署而进入生产环境。需要一个监控平台，以便事情一旦偏离正常，能够进行提醒，并找到人来调试。</p><p><br></p><h3 id="步骤5：根本原因分析"><a href="#步骤5：根本原因分析" class="headerlink" title="步骤5：根本原因分析"></a>步骤5：根本原因分析</h3><p>无论问题多小，都要做些投资，而且各个级别都要做。<br>小的改进，经过经年累月，非常像复利。</p><p><br><br><br></p><h2 id="连续部署用于关键应用"><a href="#连续部署用于关键应用" class="headerlink" title="连续部署用于关键应用"></a>连续部署用于关键应用</h2><p>连续部署要求的第一个心态转移是：如果一个更新假设是无副作用的，马上发布。不要再等着与其它相关的更新捆绑在一起，否则，一旦发生副作用，就很难确定到底是哪个更新产生的。</p><p>第二个是心态转移是把市场发布的概念和工程发布的概念区分开。</p><p><br></p><ul><li>更快更好的反馈</li><li>更多的自动化</li><li>对真实环境测量数据的监控</li><li>更好地处理间歇性错误</li><li>更小的批量</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="作为代码的基础架构"><a href="#作为代码的基础架构" class="headerlink" title="作为代码的基础架构"></a>作为代码的基础架构</h1><p><strong>只需要源代码库、应用程序数据备份、硬件裸机就能够把整个业务重建起来。</strong></p><p>理想情况下，重组业务的最大制约是还原应用程序数据所需要的时间，应用程序数据是真正的业务价值所在。</p><p><br><br><br></p><h2 id="面向服务体系结构"><a href="#面向服务体系结构" class="headerlink" title="面向服务体系结构"></a>面向服务体系结构</h2><p>将系统的每个组件都分解为可通过网络访问的服务，这些服务集成在一起就构成了一个功能性应用程序。</p><p>通过将每个基本组件都呈现为服务、应用开发者可自由组装的新的应用，结果就是重用更为容易、封装更为清洁、错误排查更为简单。</p><ul><li><p>应该是模块化的</p><ul><li>做一件事，并且做好<br>在SOA中，每个服务都很小——只做一件事，并允许其它服务调用。每个服务都很简单，但应用程序员要做很多集成工作。每个服务都专注于自己的狭小领域，则管理、开发、测试都会很容易。<br>基础架构服务也是一样的，缩小每个服务的操作范围，就可以降低复杂性，从而他人也就易于理解其行为。</li></ul></li><li><p>应该是协作的</p><ul><li>让我们团结起来<br>在构建通过网络API呈现的基本服务时，要鼓励别人和你协作，而不是重复实现相同的功能。每个服务都要设计成与其它服务协作的，尽量少假设服务的使用方式。<br>服务的协作本性决定了用的人越多，则服务本身就越有用。对于基础架构服务而言，这种本性是至关重要的——随着基础架构的每个部分都成为可集成的服务，服务之间相互协作的方式会呈指数增长。</li></ul></li><li><p>应该是可组合的</p><ul><li>应该一切准备就绪<br>理想情况下，每个服务都应该通过易于访问的网络API呈现自己的配置和功能，实际情况是：大部分都没有。</li></ul></li></ul><p><br></p><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>配置管理是一种管理活动，从技术和管理两个方面作用于产品和生命周期、配置项，以及相关的产品配置信息。</p><p>配置管理是指对所有那些事情的跟踪，那些事情是把一个系统从<strong>裸机(baremetal)</strong>转变成<strong>做自己的事</strong>时必须要做的。系统管理员手工配置系统，并将笔记贴到wiki上时，他就是在实践着最基本的配置管理。软件开发者写了一个脚本来自动部署自己的应用程序，她就是在实践着自动化的配置管理。</p><p><br></p><h3 id="配置管理是策略驱动的"><a href="#配置管理是策略驱动的" class="headerlink" title="配置管理是策略驱动的"></a>配置管理是策略驱动的</h3><ol><li>把问题和解决方案的最终结果记入文档(设立策略)；</li><li>写出在策略中要执行的代码(执行策略)；</li><li>确认最终结果是正确的(审计策略)；</li><li>重复这个过程，确保以后呢能够可靠的执行(测试策略)</li></ol><p><br></p><h3 id="系统自动化就是用代码实现配置管理策略"><a href="#系统自动化就是用代码实现配置管理策略" class="headerlink" title="系统自动化就是用代码实现配置管理策略"></a>系统自动化就是用代码实现配置管理策略</h3><p>自动化几乎总是使用高级语言，自动化方式展现了三个原则：</p><ul><li>应该是灵活的<ul><li>无论需要什么，都应该有能力做</li></ul></li><li>应该是可扩展的<ul><li>遇到新情况时，要易于扩展</li></ul></li><li>应该是可重复的<ul><li>不管重复做了多少次，结果都一样</li></ul></li></ul><p><br></p><h3 id="系统管理中的配置管理"><a href="#系统管理中的配置管理" class="headerlink" title="系统管理中的配置管理"></a>系统管理中的配置管理</h3><p>配置管理工具应该有如下思想：</p><ul><li>描述的<ul><li>说明做什么，而不是怎么做</li></ul></li><li>抽象的<ul><li>让工具为你操心细节</li></ul></li><li>幂等的<ul><li>旨在需要时才采取行动</li></ul></li><li>聚合的<ul><li>只关心自己，并信赖其他服务亦然</li></ul></li></ul><p><br></p><h3 id="系统集成"><a href="#系统集成" class="headerlink" title="系统集成"></a>系统集成</h3><p>系统集成是指将各个组件整合为一个功能正常的、完全自动化的系统。系统集成侧重于广度，能否成功则依赖于对两个方面的理解：</p><ul><li>系统中的每个组件是如何工作的</li><li>这些组件是如何相关的</li></ul><p>应该遵循这两个步骤将基础架构构建为代码，这两个恰好也是系统集成阶段使用的步骤。系统集成就是将所有的东西整合在一起。</p><p><br></p><p><strong>将基础架构分解为可重用的，可通过网络访问的服务</strong></p><p>良好基础架构的十大核心原则：</p><ul><li>应该是模块化的<ul><li>启动过程将只处理这样的任务：使资源成为网络可访问</li></ul></li><li>应该是协作的<ul><li>启动服务应该能够将启动后的工作传给其他服务</li></ul></li><li>应该是可组合的<ul><li>能够从不同的服务中调用启动服务</li></ul></li><li>应该是灵活的<ul><li>足够灵活以应付不同类型的物理系统</li></ul></li><li>应该是可扩展的<ul><li>易于扩展，义启动新的资源类型</li></ul></li><li>应该是可重复的<ul><li>每次启动，都要生产相同的系统</li></ul></li><li>应该是描述的<ul><li>应该描述需要的系统类型，而不是如何安装和构建这些系统的细节</li></ul></li><li>应该是抽象的<ul><li>应该隐藏底层机制</li></ul></li><li>应该是幂等的</li><li>应该是聚合的<ul><li>应该尽快将每个系统都启动起来，并为随后的操作系统做好准备，而不用担心其他系统的状态</li></ul></li></ul><p><br></p><p><strong>将服务集成在一起</strong></p><p>现在，你已经创建了一个如何引导和配置系统的策略，你知道接收标准是什么、能够列出实现步骤、能够对策略进行测试。这种做系统集成的方式类似于做一个多层蛋糕：每一层都建立在前一层的美味基础上，使得整个蛋糕更为诱人。</p><p><br><br><br></p><hr><p><br></p><h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><p>我以前假定服务器资源是无限的，实际情况却是服务器正在为获得必要的内存而努力挣扎着。操作系统开始进行交换，CPU开始过载，从而响应时间开始变糟。</p><p>技术人员的观点和最终用户/业务的观点并不一致。</p><p>监控并不是设置一个系统，它是用来支持业务运转的，是用来保证系统中各个部分都在各司其职地工作着。能够正常工作也可以表述为保持网站的可用性。</p><p>可用性(A)可表述为：<br>A = Uptime/(Uptime + Downtime)</p><p>网站可用性受如下4个参数的影响：</p><ul><li><strong>MTTD(平均故障诊断时间)</strong><ul><li>诊断该问题所花费的平均时间</li></ul></li><li><strong>MTTR(平均修复时间)</strong><ul><li>用于修复问题所花费的平均时间</li></ul></li><li><strong>MTTF(平均无故障时间)</strong><ul><li>正常运行的平均时间</li></ul></li><li><strong>MTBF(平均故障间隔时间)</strong><ul><li>两次故障间隔的平均时间</li></ul></li></ul><p>A = MTTF/MTBF = MTTF/(MTTF+MTTD+MTTR)</p><p>并不是说你的业务需要接近90%或更高的可用性，业务要求的可能性只是一种期望值，如果宕机发生在周末，即使发生在工作日，只要还能工作，用户也不会说什么。你的目标是应该通过降低MTTD和MTTR，以及增加MTTF来增加可用性。</p><p><br><br><br></p><h2 id="理解你在监控什么"><a href="#理解你在监控什么" class="headerlink" title="理解你在监控什么"></a>理解你在监控什么</h2><p><strong>技术组件的依赖项：</strong></p><table><thead><tr><th>组件</th><th>依赖关系</th></tr></thead><tbody><tr><td>应用程序</td><td>应用程序服务器、Web服务器、邮件服务器、缓存服务器、队列服务器</td></tr><tr><td>Mail服务器</td><td>Mail服务进程、网络、主机、存储</td></tr><tr><td>DNS服务器</td><td>DNS服务进程、网络、主机、存储</td></tr><tr><td>应用程序服务</td><td>应用程序服务进程、网络、主机、存储</td></tr><tr><td>Web服务器</td><td>Web服务器进程、网络、主机、存储</td></tr><tr><td>数据库</td><td>数据库服务进程、网络、主机、存储</td></tr><tr><td>主机</td><td>设备、OS设备进程</td></tr><tr><td>网络</td><td>设备、网络设备进程</td></tr><tr><td>存储</td><td>设备、磁盘、RAID控制器、接口</td></tr><tr><td>通用设备</td><td>磁盘、内存、CPU、接口、房屋</td></tr><tr><td>房屋</td><td>UPS、电源、温度</td></tr></tbody></table><p>依赖项常常不受你控制，相反，它是由公司内不同的组管理的。从你自己的筒子里走出来，到其他部门获取相关信息，并不是很容易。正是因为你依赖于他们，所以更好地理解他们的就很关键了。这样你就不用在讯早问题的原因上浪费时间，在用户访问服务所依赖的那些组件上也就不会存在盲点。</p><p><br></p><p><strong>不同部门之间的边界：</strong></p><table><thead><tr><th>企业部门</th><th>依赖项</th></tr></thead><tbody><tr><td>支援部门</td><td>能影响浏览器、桌面设置、防病毒/间谍软件</td></tr><tr><td>开发组</td><td>专注于应用程序更新</td></tr><tr><td>中间件组</td><td>经常运行数据库、Web服务器、应用程序服务器、邮件服务器、缓存服务器队列服务器</td></tr><tr><td>系统组</td><td>操作系统、DNS、DHCP、虚拟化、集群</td></tr><tr><td>网络组</td><td>交换机、路由器、VPN、代理服务器</td></tr><tr><td>存储组</td><td>SAN、NAS、备份、恢复</td></tr><tr><td>数据中心组</td><td>电缆、电力、UPS</td></tr><tr><td>安全小组</td><td>防火墙、安全策略</td></tr></tbody></table><p>这样划分责任，在不清楚问题的真正原因时，会显著增加修复问题的时间。大量精力会花在努力证明自己部门的清白上面，从而延长了解决问题的时间。这份额外时间称为平均清白时间(Mean Time to Innocence)。<br>为了减少这种相互推诿的时间，良好的合作与协调很重要。持续的知识共享有助于增加这种共同应对问题的责任感。</p><p>组织边界到防火墙哪里就停止了，但Internet服务比内部控制的服务有更多的依赖项，这些外部依赖项有ISP、广告商、RSS信息、Internet邮件、DNS服务器、ISP连接等，内部依赖项和外部依赖项的主要区别在于，对于外部依赖项，你不知道这些服务是如何提供的。即使如此，也不能在监控这些服务上止步不前，毕竟它们仍然是你的服务的依赖项。</p><p>在无冗余的系统中，一个组件失效，整个服务就会失效。当一个组件的失效会影响整个服务时，这种失效就称为单点故障。这种影响既指服务完全中断，也指对服务质量的影响。<br>为了避免单点故障，通常是在架构中的多个位置增加冗余，这些冗余是你的环境的安全卫士，而不是对问题的某种补偿方式。通常，增加冗余会增加复杂性，所以不要掉进过度设计的陷阱。</p><p><strong>一些冗余机制：</strong></p><table><thead><tr><th>服务/组件</th><th>冗余机制</th></tr></thead><tbody><tr><td>应用程序</td><td>负载均衡器、状态复制</td></tr><tr><td>Mail服务器</td><td>一个域名多条MX记录</td></tr><tr><td>DNS服务器</td><td>一个域名多条NS记录</td></tr><tr><td>应用程序服务器</td><td>会话复制、多实例安装</td></tr><tr><td>Web服务器</td><td>Web服务器服务进程</td></tr><tr><td>数据库</td><td>集群服务、水平区分</td></tr><tr><td>主机</td><td>虚拟化、集群</td></tr><tr><td>网络</td><td>多网关、BGP、VRRP、多ISP</td></tr><tr><td>存储</td><td>RAID、镜像、多重路径技术</td></tr><tr><td>通用设备</td><td>多网卡、CPU、内存</td></tr><tr><td>数据中心</td><td>BGP任播、GSLB</td></tr></tbody></table><p><br></p><p>不要忘了检查监控服务的依赖项，如果监控都挂了，那还监控什么呢。</p><p><strong>各种检查：</strong></p><table><thead><tr><th>检查种类</th><th>例子</th></tr></thead><tbody><tr><td>可用性</td><td>能访问80端口吗？HTTP进程在运行吗？数据库能访问吗？</td></tr><tr><td>功能/既时</td><td>应用程序在请求数据库，OS在进行DNS查询，控制器在进行磁盘写入，负载均衡器在请求Web服务器</td></tr><tr><td>功能/模拟</td><td>模拟HTTP请求、DNS请求、发送邮件</td></tr><tr><td>质量/利用</td><td>CPU、内存、磁盘等硬件信息使用情况，可以知道机器是否有足够的处理能力</td></tr><tr><td>质量/效率</td><td>Squid缓存命中率</td></tr><tr><td>质量/吞吐</td><td>订阅数、登录数、请求数、进/出请求数，用户数，数据库连接数，活动连接数，实例数</td></tr><tr><td>环境</td><td>配置监控，安全监控，备份监控</td></tr><tr><td>可信性</td><td>邮件域的垃圾邮件防范级别，SSL证书</td></tr></tbody></table><p><br></p><p><strong>不同层级的检查：</strong></p><table><thead><tr><th>层级</th><th>例子</th></tr></thead><tbody><tr><td>业务</td><td>内部网管理站点</td></tr><tr><td>交易</td><td>登录、增加文档、分享链接、注销</td></tr><tr><td>服务</td><td>Mail、DNS、Web服务器、数据库、路由、防火墙</td></tr><tr><td>机器</td><td>服务器、CPU、内存、交换机</td></tr></tbody></table><p><br><br><br></p><h2 id="理解正常行为"><a href="#理解正常行为" class="headerlink" title="理解正常行为"></a>理解正常行为</h2><p><strong>即使你了解所有依赖项，但设计一个好的监控解决方案仍是要花时间的。需要根据业务实际需求和变化对监控实施改变。</strong></p><blockquote><p><strong>一些监控中的主要问题：</strong><br>如果多次报警基于同一个原因，应该只发送一次报警；<br>夜间，备份可能会在生产网络上产生很高的负载，这样由于响应时间的变慢而导致多个ping失败和其它可能的误报，从而产生起起伏伏的报警；<br>如果我们想要随时待命的支持人员，必须尽可能降低报警和误报的次数。</p></blockquote><p><br></p><p>加入的检查越多，消耗的生产系统的资源也就越多，这些资源可以是传送数据的带宽、计算结果的CPU…<br>你需要找到正确的平衡：监控太多只会浪费资源，从而降低对整个状况的了解；监控不足将导致不能及时报警。越靠近业务层的检查越有机会检测出问题，而越底层的检查越能够对发生的问题进行定位。</p><p>监控被认为是运维环境的一部分，通常是由系统或网络管理员来管理的。开始时是一个很小的系统，在后台运行。随着监控环境的扩大，需要执行更多的配置和定制。虽然运维人员常常是第一个对要部署的新软件进行仔细检查的人，他们的标准却往往并不应用到自己的监控系统上。监控系统是你的关键应用之一，请一视同仁。</p><p><br></p><p><strong>监控的最佳实践：</strong></p><table><thead><tr><th>实践</th><th>说明</th></tr></thead><tbody><tr><td>版本</td><td>对你的检查进行版本华，并把他们放入版本控制库中</td></tr><tr><td>不同环境</td><td>使用不同环境开发、测试新的检查</td></tr><tr><td>测试</td><td>将检查作为通常代码对待，在代码功能中加入测试</td></tr><tr><td>可使用性</td><td>创建一个所有组件及其关系的可视化总览图，指出失效和组件的关系对工程师很有帮助，只需要看一下仪表板就能明白问题出在哪里</td></tr><tr><td>信息架构</td><td>使用不同的数据表示法，将数据组织为层次结构以便于导航，同时还要避免信息过载</td></tr><tr><td>代码重用</td><td>如果能够重用所监控的应用程序中的业务逻辑，就不要自己写</td></tr><tr><td>无硬编码</td><td>避免将参数编码在脚本中，使用配置文件，这也易于脚本在不同环境中的迁移</td></tr><tr><td>部署</td><td>要易于部署和分发新的检查</td></tr><tr><td>备份/还原</td><td>备份监控数据，并了解在什么情况下需要还原</td></tr><tr><td>监控</td><td>监控你的监控系统</td></tr><tr><td>冗余</td><td>在监控上，使用高可用性的功能做维护工作</td></tr><tr><td>应用的安全规则</td><td>监控账号与其它事务账号分开 <br> 是用最小特权级 <br> 不要将密码保存为明文 <br> 限制对系统的访问，不要将其用于其它的测试 <br> 将监控系统用防火墙或代理系统保护起来，避免来自易受攻击的主机的访问</td></tr></tbody></table><p>所有信息一旦采集和存储，接下来做的就是分析检查结果。服务或系统的状态有<strong>可用(Up)</strong>和<strong>不可用(Down)</strong>，某些监控系统还增加了两个状态，一个用于<strong>系统不可达(Unreachable)</strong>，一个用于<strong>系统/服务尚未检查(Pending)</strong>。</p><p>有的时候，在位新服务建立环境时，预先定义的阈值很困难——实际使用可能会超过预期，或者相反。所以，对阈值进行不断的调优就有意义了。先根据理论上的假设定义一组阈值，然后在测试环境中模拟预期的行为，并翻译为技术化的组件使用情况。因为系统及使用情况的复杂性，对系统、应用程序、用户行为建立精确的模型是很困难的。所以，对阈值只能持续不断地研究与改进。趋势分析确实有助于定义阈值，大部分监控软件都可以让你对监控的值做趋势分析，而不产生报警，根据历史数据得出阈值之后，再启动报警设置。</p><p>管理报警并不仅仅是状态变化时发出报警信息。所有报警如果一直打开着的话，工程师将无法安心做系统支持，因为报警信息太多了，可能要被报警轰炸。同样，如果有太多假设报警，也会导致同样的问题，这可以看成是你的监控系统存在技术缺陷。<br>警报应该产生行动。如果一条警报可以忽略或不需要人工干预，这条报警就是一种浪费。然而，消除噪音却是真正的挑战。警报太多会导致<strong>狼来了</strong>效应，由于警报过载而忽略了正在重要的警报。</p><p>为了使网站可以忍受而限制报警是好的，但假如与业务需求不一致的话，就不行了。反之也是对的，如果业务不需要的话，为了显示网站运行正常而发送很多报警信息，也是毫无意义的。使监控保持正确的平衡，这很重要。</p><p><br><br><br></p><h2 id="有备而学"><a href="#有备而学" class="headerlink" title="有备而学"></a>有备而学</h2><p>一个人不可能在每个方面都是专家，有一个清晰定义的升级路径，从而把问题提交给更为专业的人员去处理是明智的。<br>对紧急报警进行跟踪和趋势分析，有助于提出架构和过程的改进建议。</p><p>故障时间本身并不仅仅有功能失效引起的，也可能是由于维护活动产生的。维护活动产生的故障时间被描述为维护窗口。在这种情况下，业务部门是认可默写故障时间的。为了避免不必要的报警，监控系统可能会在这段时间关闭报警。这会导致丢失一些与此次维护无关的系统/服务故障。所以，应该只关掉与维护相关的报警，而不是整个报警系统。然后，一旦服务运行稳定了，就要打开报警。</p><p><br><br><br></p><h2 id="结语-2"><a href="#结语-2" class="headerlink" title="结语"></a>结语</h2><p>监控并不是要保持服务器运行正常，也要保持业务运行正常。理解了技术组件和业务行为，你就会有相当的把握减少和修复问题上的时间。错误总是会发生的，但要为此做好准备。万一系统失效，一定要将反馈信息发送给每一个希望听到的人，并对事情做出改进，避免再发生新的错误。愿监控的力量与你同在。</p><p><br><br><br></p><hr><p><br></p><h1 id="复杂系统是如何失败的"><a href="#复杂系统是如何失败的" class="headerlink" title="复杂系统是如何失败的"></a>复杂系统是如何失败的</h1><p>所有复杂系统失败时，都有共同点。Web运维就是这样一个领域。</p><p><br><br><br></p><h2 id="复杂系统是如何失效的"><a href="#复杂系统是如何失效的" class="headerlink" title="复杂系统是如何失效的"></a>复杂系统是如何失效的</h2><ul><li>复杂系统本质上都是灾难系统</li><li>复杂系统都被重重地然而也是成功地防护着</li><li>灾难要求多点失效——单点失效是不够的</li><li>复杂系统包含潜藏在其中的缺陷的变化混合物</li><li>复杂系统以降级模式运行</li><li>灾难随时会发生</li><li>事后归结为”根本原因“是错误的</li><li>幕后认识对人类行为的时候评估存在偏见</li><li>人类操作员有双重角色：作为生产者，以及作为失效防护者</li><li>所有操作者的行为都是赌博</li><li>最为困难的行动解决了所有的模糊性</li><li>人类操作者是复杂系统的可调整因素</li><li>复杂系统中人类专门处理知识处于不断变化中</li><li>变化会引入新的失效</li><li>“原因”观点限制了对未来事件的有效防护</li><li>安全是系统的特性，而不是系统的组件</li><li>持续创造安全的是人</li><li>无事故的运维需要经历事故的历练</li></ul><p><br></p><p><strong>针对Web运维而言：</strong></p><ul><li>了解系统失效很困难</li><li>了解哪部分失效很困难</li><li>有意义的响应会被延迟</li><li>沟通会产生紧张，而脾气会冒火</li><li>维护会成为新的失效的主要源头</li><li>从备份中恢复本身就很困难，而且还有潜在的危险</li><li>创建测试过程，一线人员用来验证系统状态</li><li>对运维进行例行的每日管理</li><li>控制维护</li><li>定期对性能进行评估</li><li>要成为(独一无二)的用户</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="社区管理与Web运维"><a href="#社区管理与Web运维" class="headerlink" title="社区管理与Web运维"></a>社区管理与Web运维</h1><p>运行一个大型且广为人知的网站，意味着会有大批人依赖于网站快速而稳定的服务。这些人会形成一个社区，以各种有趣新颖的方式进行交流，并彼此关照。</p><p>社区起着一个交流、沟通、反馈的渠道作用。</p><p><br><br><br></p><hr><p><br></p><h1 id="处理非预期的访问量激增"><a href="#处理非预期的访问量激增" class="headerlink" title="处理非预期的访问量激增"></a>处理非预期的访问量激增</h1><p>有些时候，因为某种原因，Web的访问量会急剧增加(是正常用户访问而不是遭受攻击)，我们的服务器就会遭受严重的考验。</p><p><br><br><br></p><h2 id="一切是如何开始的"><a href="#一切是如何开始的" class="headerlink" title="一切是如何开始的"></a>一切是如何开始的</h2><p>开能由于某个原因，导致Web流量激增，而我们服务器却无法应付这么高的并发和流量，所以导致Web瘫痪。</p><p><br><br><br></p><h2 id="警报连连"><a href="#警报连连" class="headerlink" title="警报连连"></a>警报连连</h2><p>监控软件(如nagios, zabbix)警报连连。Web请求太多导致响应很慢或奔溃。</p><p><br><br><br></p><h2 id="扑灭烈火"><a href="#扑灭烈火" class="headerlink" title="扑灭烈火"></a>扑灭烈火</h2><p>查找是哪些环节导致Web响应很慢或奔溃，对之做相应的优化。</p><p><br><br><br></p><h2 id="未雨绸缪"><a href="#未雨绸缪" class="headerlink" title="未雨绸缪"></a>未雨绸缪</h2><p>当我们经历了非预期的流量激增，并处理优化之后，下一步就需要对整个基础架构进行加固，或转向新的架构。</p><p><br><br><br></p><h2 id="救命稻草CDN"><a href="#救命稻草CDN" class="headerlink" title="救命稻草CDN"></a>救命稻草CDN</h2><p>解决带宽问题要靠内容分发网络(CDN)——在多个地点存储文件，为客户提供最近最快的响应。<br>大部分静态资源适合移动到CDN上，以减轻原始服务器的负担。</p><p>但CDN也有一些不足。对于移动到CDN上的数据，你就失去了控制。对于短时间的静态内容，CDN的效果并不好。</p><p><br><br><br></p><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>代理服务器处于我们系统的最前沿，尽可能让代理服务器转发请求，而不使用任何其它资源。</p><p><br><br><br></p><h2 id="围剿踩踏"><a href="#围剿踩踏" class="headerlink" title="围剿踩踏"></a>围剿踩踏</h2><p>如何避免缓存踩踏？</p><ul><li>一个是对数据库进行优化</li><li>一个是搭建数据库集群</li></ul><p><br><br><br></p><h2 id="将代码基流水化"><a href="#将代码基流水化" class="headerlink" title="将代码基流水化"></a>将代码基流水化</h2><p><br><br><br></p><h2 id="怎么知道它能否工作"><a href="#怎么知道它能否工作" class="headerlink" title="怎么知道它能否工作"></a>怎么知道它能否工作</h2><p>确保系统能够处理负载的唯一途径是在流量汹涌而来时，对其进行现场测试。</p><p><br><br><br></p><h2 id="真实测试"><a href="#真实测试" class="headerlink" title="真实测试"></a>真实测试</h2><p>必须要在真实的生产环境中查看其负载效果，才能确保其能正常工作。</p><p><br><br><br></p><h2 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h2><p>总要为未来几年做一个规划——问问你自己：“当前的架构方案能够用于未来几年吗？”</p><p>要测试生产环境，经过适当的测试规划，很多问题是可以避免的。</p><p>当一个架构方案已经明显不能工作的时候，必须要有重新考虑整个方案的勇气。<br>重新思考代码、硬件、网络、数据库模式，为可见的未来创建一个伸缩性更好的系统。</p><p><br><br><br></p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>针对遭受的问题，之后对系统的改进。</p><p><br><br><br></p><hr><p><br></p><h1 id="开发者与运维者的协调与合作"><a href="#开发者与运维者的协调与合作" class="headerlink" title="开发者与运维者的协调与合作"></a>开发者与运维者的协调与合作</h1><p>很多网站都将其开发和运维分为两个独立的团队，开发负责开发新功能和对现有功能进行改进，运维负责网站的正常运行。<br>两个团队有不同的目标，工作方式的要求也是迥然有别。</p><p>这种设置很常见，但也是保证网站稳定性或及时推出新功能的最糟糕的设置。</p><p>这在种情形下，开发人员没有动力将网站做得更易于运维支持，开发团队交付的代码通常是一个黑盒子，一旦发生意外，运维团队没有办法及时去修复问题。这种结构也抑制了新的功能的开发、构建和部署网站的新版本，不仅耗时，成本高，还涉及很多不同团队之间的协调。对运维来说，部署是存在风险的，而且也是造成很多宕机事故的原因。</p><p>传统的运维和开发，两者之间存在着很多对彼此很有用的信息。对很多网站来说，性能瓶颈都出在应用程序代码上：开发团队最适合修正这些问题，但运维团队有测量数据，要想找出问题出在哪，是需要这些数据的。关于什么地方可能会出问题，以及如何修复，开发团队有很多很好的想法，但这些却很少会记录在文档里面。</p><p>所以，重新评估运维跟开发之间的关系！</p><p><br><br><br></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>以合适的方式进行移交，则不同团队之间就能更好地共同工作，而改变过程这是困难的，需要协助以及每个人的认可。</p><p>一项服务之所以受人欢迎，频繁部署也是重要原因之一。小批量代码更新。</p><p>用户报告问题后，极短时间内就得到修复，这一做法会彻底征服用户。有了这种响应凡是，则将来有了问题，用户也会很乐意报告给你，这样产品就会越做越好，特别是你能够一直这样快速反应的话。对关键的数据损失或安全缺陷能够在短时间内而不是几周响应的话，用户的数据就会安全得多。</p><p>然而最重要的是，频繁部署并不比周部署或月部署风险更大。很多小的更新，每个都单独测试和检查过，比起一次大的更新来说，导致严重宕机的事故的可能性要小很多。</p><p>这是因为小更新的影响能够提前单独进行复审和测试，从而错误造成的影响也易于量化及应对。定位代码中的缺陷，复审10行的更新比起10000行来，会容易得多，而且只测试那些受更新影响的功能，比起测试整个系统，也要快得多。而且能够确保每次部署都只是更新一个区域，从而避免同时更新的两个组件之间发生预料不到的交互作用。小部署意味着更容易预言更新对基础架构的影响，而这也就意味着未雨绸缪更加有的放矢。</p><p>如果只是部署30行代码，缺陷通常是自明的。如果缺陷不自明，其影响也会非常小，即使回滚也非常容易。</p><p><br></p><p>只有在遵循以下三条规则的情形下，频繁的小更新才起作用：</p><ul><li>构建与部署系统必须能够完全重复且自动地工作</li><li>具有几近完美的预演环境</li><li>部署必须尽可能快，理想情况是小于5min</li></ul><p>大多数构建和部署系统在某种程度上都是自动化的，少数团队走得更远，把构建和部署做成了一键操作。</p><p><br><br><br></p><h2 id="共享、开放的基础架构"><a href="#共享、开放的基础架构" class="headerlink" title="共享、开放的基础架构"></a>共享、开放的基础架构</h2><p>很多情形下，运维和工程都分为不同的小组，你会发现支持的基础架构也会一分为二。</p><p>共享基础架构是在团队之间进行协作的最容易的方式。</p><p>为了有效地工作，你需要了解系统的其它方面目前是如何运转的。为了建立信任，你需要使你的工作变得透明。</p><p><br><br><br></p><h2 id="信任"><a href="#信任" class="headerlink" title="信任"></a>信任</h2><p>信任是开发和运维之间最常见的紧张关系之一。多数运维团队对开发团队多少都有点怀疑，开发人员通常也好不到哪去。团队之间的不信任是不健康的，也是不合适的。</p><p>信任最终是建立在一种尊敬的感觉之上的。如果你尊敬某人，就很容易信任此人能够做好他的事情。反之，如此人交往便会带有偏见、不满等情绪。</p><p>运维和开发之间的许多问题都是由于对两个团队不同角色的重要性认识不同而造成的。</p><p>充分尊重你的同事，而不是事后指责他们。</p><p><br><br><br></p><h2 id="随叫随到的开发人员"><a href="#随叫随到的开发人员" class="headerlink" title="随叫随到的开发人员"></a>随叫随到的开发人员</h2><p>只有在开发人员对修正生产系统代码中的问题肩负起责任的情况下，才是有意义的，而这就意味着开发人员随叫随到。</p><p><br></p><h3 id="现场调试工具"><a href="#现场调试工具" class="headerlink" title="现场调试工具"></a>现场调试工具</h3><p>很多代码对于运维团队来说都是黑盒子。</p><p>要想办法在运行时调用额外的调试信息，技术团队的每个人在用管理账号登录系统之后，都可以开启额外的调试信息。</p><p><br></p><h3 id="功能标识"><a href="#功能标识" class="headerlink" title="功能标识"></a>功能标识</h3><p>禁掉某些依赖于问题架构的功能，而保持网站的其他部分正常运行，功能标识能够实现这一点。</p><ul><li>单个标识，用来禁掉每个非核心的基础架构</li><li>只要这些服务出现问题，我们都可以暂时并优雅地禁止掉这些功能</li><li>如果生产系统出现新的错误场景，也可增加新的标识</li></ul><p><br><br><br></p><h2 id="避免职责"><a href="#避免职责" class="headerlink" title="避免职责"></a>避免职责</h2><p>在很多团队中，没有人愿意成为搞坏所有事情的傻瓜。发生问题时，人们都会将责任推卸给别人。</p><p>每个人都有貌似合理的理由将指责转嫁给别人，却没有挺身而出，实实在在地修复问题，组织良好的团队深切地了解，在将问题修复之前，争论到底是谁的责任是没有意义的，为保护自己而浪费的每一分钟，由于问题没有修复，都会成为给用户带来损失的一分钟。用户会尝试各种可能性，知道他们发现系统出问题了。</p><p>多数生产环境都有足够的冗余，也足够复杂，任何问题都不太可能存在单一的根本问题。很多问题都是由两个或多个系统发生意料之外的交互作用而引起的。</p><p><br><br><br></p><h2 id="结语-3"><a href="#结语-3" class="headerlink" title="结语"></a>结语</h2><p>网站的稳定性是每一个人的责任，而不仅仅是某种应该交给运维团队去处理的东西。</p><p>让人人都拥有对网站的主人翁感觉，确实意味着能够减轻运维团队的工作负担。他们不用再花费大量时间呼吁采取防护性措施，一旦发生问题，也能够花更小的时间修复。这非常了不起，因为这意味着网站的宕机时间会减少很多。这也释放了运维团队，让他们能够把精力放在更为重要的任务上，即对基础架构的长期增长进行管理。</p><p><br><br><br></p><hr><p><br></p><h1 id="你的访问者感觉怎么样：面向用户的测量"><a href="#你的访问者感觉怎么样：面向用户的测量" class="headerlink" title="你的访问者感觉怎么样：面向用户的测量"></a>你的访问者感觉怎么样：面向用户的测量</h1><p>对于网站的成功而言，终端用户的测量也就变得和后台测量一样至关重要。</p><p><br><br><br></p><h2 id="为何要采集面向用户的测量数据"><a href="#为何要采集面向用户的测量数据" class="headerlink" title="为何要采集面向用户的测量数据"></a>为何要采集面向用户的测量数据</h2><p>采集数据，从而就可以对业务的健康状况进行分析。</p><p>如：</p><ul><li>每秒请求数/发布数</li><li>带宽</li><li>响应时间</li><li>HTTP错误率</li><li>记入日志的异常数</li><li>进程重启次数</li><li>队列大小</li><li>服务器的平均负载和进程数</li><li>数据库负载</li><li>内存</li></ul><p><br></p><h3 id="成功的创业公司所学到的以及必须适应的"><a href="#成功的创业公司所学到的以及必须适应的" class="headerlink" title="成功的创业公司所学到的以及必须适应的"></a>成功的创业公司所学到的以及必须适应的</h3><p>创业公司的一大优势就是敏捷，即快速反应的能力。要真正做到敏捷，创业公司需要了解终端用户真正体验到的是什么。</p><p>任何网站想要成功，就必须向用户学习，而且必须适应用户的需求。很多Internet巨头，它们现在的业务，都与其当初设定的相比有很大的不同。</p><p><br></p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>响应越快的应用程序越好！</p><p>响应级别：</p><ul><li>加入事情的响应时间在10ms内，我们的大脑就会认为这是真实的<ul><li>如点击桌面系统上的按钮</li></ul></li><li>如果谈话有100ms左右的延迟，我们不会感觉到这种延迟<ul><li>如国际长途电话</li></ul></li><li>如果应用程序的响应时间在1s之内，我们的感觉就是仍然在与应用程序互动，仍然在工作</li><li>应用程序的响应时间要是明显长于1s的话，我们就会抓狂</li></ul><p><br></p><h3 id="研究量化了这种关系"><a href="#研究量化了这种关系" class="headerlink" title="研究量化了这种关系"></a>研究量化了这种关系</h3><p>Web应用的速度越快，其Web业务员的优势就越明显！</p><p>如果你的网站很慢，你将得到：</p><ul><li>更少的用户搜索</li><li>更少的精度搜索</li><li>更少的每访客收入</li><li>更少的点击，更低的满意度</li><li>更少的每日搜索</li><li>等待访客点击的时间更长</li><li>更低的搜索引擎排名</li><li>更差的用户体验</li></ul><p><br><br><br></p><h2 id="是什么使网站变得很慢"><a href="#是什么使网站变得很慢" class="headerlink" title="是什么使网站变得很慢"></a>是什么使网站变得很慢</h2><p>简单来说，由以下三点原因造成：</p><ul><li>服务器花在处理用户请求上的时间</li><li>网络花在传输请求和响应上的时间</li><li>用户花在组装并显示结果内容上的时间</li></ul><p><br></p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>开始访问网站，用户都需要先找到服务器。</p><p>对于带有很多组件的网站——这是一个日渐普遍的模式——都会迫使用户去解析很多网站，并且页面加载的时间也延长了。</p><p><br></p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>网络再快，用户与服务器之间的往返也是需要时间的。</p><p>请求包含的内容越多，则网络用来传输的时间就越长。加入是一个安全页面的话，还会有另外的延迟，用来在客户与服务器之间进行加密协商。</p><p><br></p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>请求到达服务器之后，另一个导致延迟的罪魁祸首就登场了——主机。不论是从内存中检索静态对象，还是利用后台的第三方服务来完成一个复杂的请求，主机延迟都会对性能造成影响。</p><p><br></p><h3 id="发送响应"><a href="#发送响应" class="headerlink" title="发送响应"></a>发送响应</h3><p>响应内容一旦准备就绪，服务器就可以通过HTTP协议发送这些请求对象——大多数页面包含多个对象(如html,css,js,gif,png,jpg…)，正是这些对象的发送造成了访客体验到的延迟。</p><p><br></p><h3 id="异步通信与刷新"><a href="#异步通信与刷新" class="headerlink" title="异步通信与刷新"></a>异步通信与刷新</h3><p>某些应用包括一些客户与服务器之间的通信，这些通信是独立于页面进行的。<br>包含某种异步更新或刷新的应用，有不同的延迟测量指标。</p><p><br></p><h3 id="渲染时间"><a href="#渲染时间" class="headerlink" title="渲染时间"></a>渲染时间</h3><p>随着客户端越来越复杂，浏览器做的也就越来越多。有可能是启动富互联网应用(RIA)，这些RIAs都是构建在Flash、Flex、HTML5、Java、JS…之上的，也可能是运行QuickTime或Windows媒体播放器等这样的插件，甚至决定如何对复杂页面进行布局也是需要花费时间的。<br>所以，对于大量依赖客户端进行渲染的网站，就必须考虑这种延迟。</p><p><br><br><br></p><h2 id="测量延迟"><a href="#测量延迟" class="headerlink" title="测量延迟"></a>测量延迟</h2><p>有两种测量方法：</p><ul><li>综合监控</li><li>实际用户监控(RUM)</li></ul><p><br></p><h3 id="综合监控"><a href="#综合监控" class="headerlink" title="综合监控"></a>综合监控</h3><p>综合监控是通过从多个地点对网站进行一系列正规的校本化测试，对网站的性能进行监控。</p><p><strong>要记住，综合测试也是要消耗服务器资源的。</strong></p><p><br></p><h3 id="真实用户监控"><a href="#真实用户监控" class="headerlink" title="真实用户监控"></a>真实用户监控</h3><p>RUM的工作名副其实：它观察的是网站的真实访客，记录访客打开页面的速度，然后生成报表。</p><p>从这点来看，RUM会告诉你系统是否出问题了，因为你可以通过RUM发现问题以及速度变慢的情况，这些情况你没有进行测试，从而也就不知道是否存在。</p><p><br><br><br></p><h2 id="编写SLA"><a href="#编写SLA" class="headerlink" title="编写SLA"></a>编写SLA</h2><p>Web运维收集终端用户的数据的一个主要理由就是用来编写SLA，哪怕与客户之间没有正式的SLA，但对于正常工作时间及页面延迟，也应该有内部的目标，因为网站速度对用户体验有直接的影响。</p><p><br><br><br></p><h2 id="访客结果：分析"><a href="#访客结果：分析" class="headerlink" title="访客结果：分析"></a>访客结果：分析</h2><p>对于成功的Web运维来说，监控就是了解存在哪些不利因素。而当进入Web业务时，这些测量就要让位于Web分析了。</p><p><br></p><h3 id="市场营销如何定义成功"><a href="#市场营销如何定义成功" class="headerlink" title="市场营销如何定义成功"></a>市场营销如何定义成功</h3><p>对市场营销的最好描述——“更经常、更有效地卖出更多的东西给更多的人，从而得到更多的钱。”<br>或许应该将成功的在线营销更精确地定义为“让人们有效地去做你要他们做的事情。”</p><p><br></p><h3 id="网站的四种类型"><a href="#网站的四种类型" class="headerlink" title="网站的四种类型"></a>网站的四种类型</h3><ul><li>交易性网站</li><li>协作型网站</li><li>作为服务(saas)网站</li><li>媒体网站</li></ul><p>很多流行网站都是上述模式的混合。</p><p>网站分析就是对每种类型网站的成功因素进行追踪，从中识别出使这些因素得以增长的背后动因——不管是广告活动、性能的提升、社会网络上的关注、特殊的定价模式还是某个引人注目的内容。</p><p><br></p><h3 id="分析一个简单的模型"><a href="#分析一个简单的模型" class="headerlink" title="分析一个简单的模型"></a>分析一个简单的模型</h3><p>有一个简单方式来考虑网站分析，就是做一次访问。</p><p>网站分析的目标，就是通过优化网站，将访客的转变最大化，通常是对网站进行试验，并针对各种内部和外部区段，对这些试验结果进行分析。</p><p><br><br><br></p><h2 id="市场营销关心的其他测量数据"><a href="#市场营销关心的其他测量数据" class="headerlink" title="市场营销关心的其他测量数据"></a>市场营销关心的其他测量数据</h2><h3 id="Web交互分析"><a href="#Web交互分析" class="headerlink" title="Web交互分析"></a>Web交互分析</h3><p>分析查看的是用户对多个页面的整体访问情况，Web交互分析集中在单个页面的可用性交互上。</p><p><br></p><h3 id="用户之声"><a href="#用户之声" class="headerlink" title="用户之声"></a>用户之声</h3><p>用户之声工具用来询问客户在想什么。这些工具从网站的访问性中征求反馈，通过请求客户参与调查，或者在页面上提供一个反馈按钮。</p><p><br><br><br></p><h2 id="用户体验如何影响Web运维"><a href="#用户体验如何影响Web运维" class="headerlink" title="用户体验如何影响Web运维"></a>用户体验如何影响Web运维</h2><p>随着新建公司对终端用户体验的关注，Web运维的角色正在发生变化。对线上事务的兴趣越来越浓，而且通过追踪分析，网站的所有事情都能够和业绩联系起来。</p><p><br></p><h3 id="将监控作为生命周期的一部分"><a href="#将监控作为生命周期的一部分" class="headerlink" title="将监控作为生命周期的一部分"></a>将监控作为生命周期的一部分</h3><p>网站现在已经有了很大的变化，随着敏捷和精简产品开发的流行，监控也需要跟上。所以来的综合监控脚本以及RUM配置也需如此。</p><p><br></p><h2 id="Web监控的未来"><a href="#Web监控的未来" class="headerlink" title="Web监控的未来"></a>Web监控的未来</h2><p>终端用户体验的监控正在兴起，变化很快。这是业务中最能进行分析、量化的部分，每周都能涌现出新的技术。</p><ul><li>从系统转向用户</li><li>以服务为中心的架构</li><li>云与监控</li><li>APIs与RSS消息</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="将关系数据库用于Web的战略战术"><a href="#将关系数据库用于Web的战略战术" class="headerlink" title="将关系数据库用于Web的战略战术"></a>将关系数据库用于Web的战略战术</h1><p>如何为产品或应用程序设计一个良好的关系数据库架构，如何构建良好的互联网数据库架构？</p><p><br><br><br></p><h2 id="Web数据库需求"><a href="#Web数据库需求" class="headerlink" title="Web数据库需求"></a>Web数据库需求</h2><p>其实，大多数网站，相对而言，都只是小型数据库。<br>一些大型公司，可能才是一个大型数据库。</p><p><br></p><h3 id="一直在线"><a href="#一直在线" class="headerlink" title="一直在线"></a>一直在线</h3><p>数据库通常要7x24小时运行。<br>一直在线意味着维护和运维任务是很难做的，你不能简单地等到人们回家了然后将服务器卸下来，给硬件升级或备份。必须在不停机的情况下做这些事，而且很多情况下还不能给应用程序增加额外的负载。</p><p>话虽这么说，还是极少看到没有峰值时间的数据库。所以，还是有很好的机会，在数据库活动的间歇期来做备份或对数据库产生干扰工作。</p><p><br></p><h3 id="事务最多的工作负载"><a href="#事务最多的工作负载" class="headerlink" title="事务最多的工作负载"></a>事务最多的工作负载</h3><p>很多互联网应用都匹配以下模式：</p><ul><li>应用程序读远大于写</li><li>一次读一行和一次读多行是混合出现的</li><li>一般，写每次只影响一行</li></ul><p>这就是称之为的<strong>事务型负荷</strong>。</p><p><br></p><h3 id="简单数据，简单查询"><a href="#简单数据，简单查询" class="headerlink" title="简单数据，简单查询"></a>简单数据，简单查询</h3><p>网站的流量很大程度上决定了数据库的流量。</p><p>查询通常会满足下面的模式：</p><ul><li>读写用户表，一次一行</li><li>以区域或集合方式读取用户自己的数据</li><li>以区域或集合方式读取其他用户的数据</li><li>从该用户到其他用户的关联表中读取区域行</li><li>对该用户和其他用户的数据进行汇总与计数</li></ul><p>特别低，很多数据可以分区存储的事实说明了为什么<strong>分片(sharded)</strong>架构是可能的。</p><p><br></p><h3 id="可用性胜过一致性"><a href="#可用性胜过一致性" class="headerlink" title="可用性胜过一致性"></a>可用性胜过一致性</h3><p>从业务的角度看，最重要的事情是应用程序对用户的可用性。</p><p><br></p><h3 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h3><p>传统应用极少以天或周为周期构建和部署，但对于大量Web应用来说却是常态，这些Web应用是永远的Beta版。</p><p><br></p><h3 id="在线部署"><a href="#在线部署" class="headerlink" title="在线部署"></a>在线部署</h3><p>模式和数据的更新都做成代码形式，而且也有这样的框架，部署这些代码或将其回滚都很容易。</p><p><br></p><h3 id="由开发人员构建"><a href="#由开发人员构建" class="headerlink" title="由开发人员构建"></a>由开发人员构建</h3><p>大量的应用程序都是由开发人员做的，都没有一个高水平的DBA。</p><p><br><br><br></p><h2 id="典型的Web数据库是如何增长的"><a href="#典型的Web数据库是如何增长的" class="headerlink" title="典型的Web数据库是如何增长的"></a>典型的Web数据库是如何增长的</h2><p>大多数Web数据库的增长，都经历了一些列的架构变动。这些架构变动，在应用程序的整个生命周期中，相对而言都是可预知的。</p><p><br></p><h3 id="单台服务器"><a href="#单台服务器" class="headerlink" title="单台服务器"></a>单台服务器</h3><p>一般应用程序都是从单台服务器开始起步的。使用单台服务器有很多好处：</p><ul><li>数据只有一份拷贝，不存在你的数据是否正确或不同的问题</li><li>易于配置</li><li>便宜</li></ul><p>当然，缺点就是只有一台服务器！加入发生问题，没有冗余机器做故障转移。性能也会受影响。</p><p><br></p><h3 id="主服务器与单复制从服务器"><a href="#主服务器与单复制从服务器" class="headerlink" title="主服务器与单复制从服务器"></a>主服务器与单复制从服务器</h3><p>各数据库的复制技术都不一样，但一般而言，发生在主服务器上的数据修改，都要在从服务器上重复一遍，所以从服务器是主服务器数据的只读拷贝。依赖于数据库、系统负载以及执行的查询类型，从服务器不一定时刻与主服务器的数据完全一致(异步复制)。</p><p>增加一个复制从服务器有很多好处。数据库读请求可以在主、从指间分担，这称为读写分离。可以在从服务器上执行那些效率不高的查询、备份以及其它有可能对网站造成破坏的任务。</p><p><br></p><h3 id="主服务器与多复制从服务器"><a href="#主服务器与多复制从服务器" class="headerlink" title="主服务器与多复制从服务器"></a>主服务器与多复制从服务器</h3><p>大多数复制技术对两台或多台从服务器都没问题。<br>这样确实不错，而且随着从服务器越来越多，系统的数据库读取能力也越来越强。但这种增长不是无限制的，在很多层面上都会遇到收益递减的拐点。</p><ul><li>第一个层面就是应用程序中读对写的比例</li><li>第二个方式表示主服务器的写操作有多忙，其中你会看到收益递减的情况</li><li>第三个限制是操作成本和复杂性<ul><li>管理一群服务器，比管理单台服务器，要难得多也昂贵得多</li></ul></li><li>最后一个不足是应用的复杂性<ul><li>从单一数据源走向两个数据源，对于大多数应用程序而言，都是一个重大转移。应用程序不得不连接多个位置来进行查询。连接池、负载均衡器以及类似技术会在一定程度上保护你不受这种复杂性的困扰，但最终应用程序仍然要面对某种程度的复杂性</li></ul></li></ul><p>复杂性的一个最大来源是异步复制。异步意味着写操作先在主服务器上完成，随后送往从服务器执行。结果就是，从服务器总是拖后于主服务器某段时间，即时这段时间很短，但由此而造成的问题却很大。这可能会导致用户体验的不一致到数据完整性等一系列问题。</p><p>一般而言，不存在修复这个问题的神奇方法，应用程序必须自己处理这种延迟复制。<br>一种不错的简单技术是基于会话的分裂。用户做了更新之后，一段时间之内，该用户的所有查询都导向到主服务器。认为能够安全地查询从服务器所需的时间戳通常都存储在会话里。</p><p><br></p><h3 id="功能分区"><a href="#功能分区" class="headerlink" title="功能分区"></a>功能分区</h3><p>复制只对读有伸缩，对写没有。随着应用的规模越来越大，写操作的负载最终会大到系统无法处理。</p><p>功能分区(functional partitioning)，假如将某些部分与其余部分分开，则这些部分可以独立增长。<br>如，对于博客服务，可将评论功能分离到它自己的服务器中。</p><p>从运维角度来看，不同部分处在不同位置，则应用程序的功能也就能够单独对待。比起网站宕机，将评论改为只读模式，用户的反感可能要小得多。</p><p>这种做法的不利之处是增加了复杂性。应用程序需要从多个位置获取数据，而运维团队必须保持这些服务器正常运行。</p><p><br></p><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>分片(sharding)，是将单一逻辑数据划分为多个片段并发布在多台服务器上的一种方式。所有的片段在逻辑上和功能上都是相同的，虽然这些片段分别包含数据的不同子集。</p><p>分片架构的主要设计目标和优势都是双重的。第一是允许写伸缩，因为负值无法实现写伸缩，假如应用程序的写操作草果了任何单台服务器能承受的程度，就必须要分片以减少写操作的负载，写操作的负载必须分担到完全隔离的服务器上，对一个分片的服务器的写操作不能复制到另一个分片服务器上。第二个目标和优势是，随着数据集的增长，能够增加更多容量的能力。</p><p>在分片架构中，许多查询也变得困难或不可能了。例如，需要访问所有客户数据的查询，通常都要在每个分片上分别执行，然后在应用程序代码中在聚合在一起。</p><p>分片架构还存在很多其他的不足和复杂性。</p><p><br></p><h3 id="缓存层"><a href="#缓存层" class="headerlink" title="缓存层"></a>缓存层</h3><p>缓存层的目的是阻止查询到达数据库。<br>标准的例子是：memcached，redis</p><p>缓存层的主要优势是极为容易，并且简单。</p><p>从运维的立场来看，需要考虑缓存服务器的冗余和可用性，就像为其他服务器所做的一样。</p><p><br><br><br></p><h2 id="对集群的渴望"><a href="#对集群的渴望" class="headerlink" title="对集群的渴望"></a>对集群的渴望</h2><p>在应用程序出现某种问题，或关于可用性或伸缩性的困难问题来的时候，人们的思想就会转向集群(cluster)，就像年轻人的思想转向春天和爱情一样。</p><p><br></p><h3 id="CAP定理以及ACID和BASE"><a href="#CAP定理以及ACID和BASE" class="headerlink" title="CAP定理以及ACID和BASE"></a>CAP定理以及ACID和BASE</h3><p>CAP原理： 一致性(Consistency)、可用性(Availability)、分区容错性(Partition Tolerance)。你可以具有两者，但不能三者皆具备。</p><p>ACID： 原子性(Atomicity)、一致性(Consisitency)、分离性(Isolation)、持续性(Durability)。</p><p>BASE: 根本可用性(basically available)、软状态(soft state)、最终一致性(eventual consistency)。</p><p><br></p><h3 id="MySQL集群的状态"><a href="#MySQL集群的状态" class="headerlink" title="MySQL集群的状态"></a>MySQL集群的状态</h3><p>MySQL Cluster是将MySQL服务器作为一个完全不相干的、称为NDB的软件的前端。NDB的意思是网络数据库，这是一个极快、分布式、无共享、高可用的数据库。</p><p><br></p><h4 id="DRDB和Heartbeat"><a href="#DRDB和Heartbeat" class="headerlink" title="DRDB和Heartbeat"></a>DRDB和Heartbeat</h4><p>DRDB在服务器之间对块设备进行复制，将修改的块通过网络复制给备机。如果主服务器失效了，则Heartbear激活备机。</p><p>从运维的角度来说，DRDB非常棒，装上就能工作，但却不能满足在线用户的需求。它不是为满足典型Web应用的高可用性而设计的。相反，它非常适合用户保证你不丢失数据的情况，也就是说，它关注的焦点是一致性而不是可用性。</p><p>另一个问题就是基于DRDB的集群不能改进性能。Web应用需要的是正常工作时间和性能，而基于DRDB的集群是以性能为代价来提供一致性，而一旦失效，宕机时间就会很长。</p><p><br></p><h4 id="主服务器到主服务器的复制管理器-MMM"><a href="#主服务器到主服务器的复制管理器-MMM" class="headerlink" title="主服务器到主服务器的复制管理器(MMM)"></a>主服务器到主服务器的复制管理器(MMM)</h4><p>MMM是一系列的Perl脚本，管理复制和虚拟IP地址，从而为MySQL提供一个伪集群(pseudocluster)。</p><p>应用程序连接到虚拟IP而不是服务器的真实IP。服务器发生问题时，MMM将该服务器的虚拟IP移动到另外的可用服务器上。它也可以将复制从服务器从失效的主服务器移动到正常的主服务器上。MMM允许手工将服务器离线执行维护任务。</p><p><br></p><h4 id="带复制的Heartbeat"><a href="#带复制的Heartbeat" class="headerlink" title="带复制的Heartbeat"></a>带复制的Heartbeat</h4><p>如果MMM无法完美地管理复制和虚拟IP地址，heartbeat考虑以下？</p><p>不管怎么说，复制延迟仍然是一个复杂的问题。必须在应用程序层解决这一部分问题。</p><p><br></p><h4 id="基于代理的解决方案"><a href="#基于代理的解决方案" class="headerlink" title="基于代理的解决方案"></a>基于代理的解决方案</h4><p>有一种可供选择的方案，基于代理(proxy)，需要人工介入，MySQL Proxy位于前端。HAProxy是另一个流行的方案。</p><ul><li>MySQL Proxy，事实上能够理解MySQL的协议，并且拦截、解释以及传递消息</li><li>HAProxy，只是传递TCP流，并不对内部进行窥探</li></ul><p>基于代理的解决方案仍然没有入人们所愿的那样解决复制延迟问题，而且还引入了单点故障，并且影响性能。</p><p><br></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>前面讨论这么多，简而言之，就是没有一个完美的、万能的答案。</p><p>最好的数据库架构是为了应用而建的，期待集群所承担的指责分布在数据库、网络以及应用程序上，有运维的适度介入，以及起粘合作用的软件，就能把各部分整合在一起。</p><p><br><br><br></p><h2 id="数据库战略"><a href="#数据库战略" class="headerlink" title="数据库战略"></a>数据库战略</h2><p>如何选择一个对于大量的互联网架构来说都能够运转良好的架构。</p><p><br></p><h3 id="架构需求"><a href="#架构需求" class="headerlink" title="架构需求"></a>架构需求</h3><p>最好定义你的需求，特别是，把那些超出你的范围从而成为别人的问题的内容写成文档。</p><p><br></p><h3 id="有把握的架构"><a href="#有把握的架构" class="headerlink" title="有把握的架构"></a>有把握的架构</h3><p>以下数据库架构，是比较有把握的。</p><p><br></p><ul><li><p><strong>单主服务器，多从服务器</strong><br>这种主-从架构很难自动实现主服务器的故障转移，因为主服务器和从服务器的配置是不一样的，所以，一旦主服务器失效，则必须手动进行失效转移。</p></li><li><p><strong>主服务器-主服务器复制，外加从服务器</strong><br>这种方式实际上与一台主服务器加多台从服务器的架构一样，但有时候主服务器本身也成为从服务器。这种架构的优点是，在协同的主服务器之间更容易实现失效转移和失效转回。缺点是，向两台主服务器进行写入存在风险，会导致数据库存在某种不一致性，也很难解决。</p></li><li><p><strong>功能分区</strong><br>随着应用的增长，将应用中某些部分转移到特定的服务器或特定集群上。</p></li><li><p><strong>失效转移和负载均衡</strong><br>使用负载均衡器，或者浮动的虚拟IP地址。</p></li><li><p><strong>ACID仍然是有意义的</strong><br>高可用性要求快速而可靠的灾难恢复。</p></li><li><p><strong>使用正确的工具</strong><br>不要使数据库处于关键路径上，不要讲应用程序的静态信息放入数据库中。数据库应该存储数据，而非应用程序本身。将数据库简单化，因为这是最难于伸缩，也是最昂贵的资源。但是，对于Web应用，还是应该分离应用程序和数据库，将数据库仅用来存储和检索数据。</p></li></ul><p><br></p><h3 id="有风险的架构"><a href="#有风险的架构" class="headerlink" title="有风险的架构"></a>有风险的架构</h3><p>建议不要使用这些架构</p><p><br></p><ul><li><p><strong>分片</strong><br>除非不得已，不要分片。<br>对于一个中等规模的应用，将其构建在数百台低档机器的分片架构上，试图提供无线伸缩能力，是非常愚蠢的。其实，只需购买几台足够好的机器，在工程上多做一些考虑就足够了。<br>分片架构比你预想要昂贵的多，甚至在短期内也是如此，长期则一定如此<br>分片问题设计过度设计的风险</p></li><li><p><strong>写入多台主服务器</strong><br>不要将多台服务器配置为可写，这会造成数据一致性问题。非常麻烦。</p></li><li><p><strong>多级复制</strong><br>尽量不要使用多级复制。<br>使用一主多从而不是从的从的从服务器，要简单的多。孙子辈的从服务器和重孙辈的从服务器很难管理。</p></li><li><p><strong>环形复制</strong><br>避免使用环形复制，其失效情形，不管是数量还是复杂度，都打得超乎想象。</p></li><li><p><strong>依赖于DNS</strong><br>DNS很脆弱，依赖DNS最终会自食苦果。</p></li></ul><p><br><br><br></p><h2 id="数据库战术"><a href="#数据库战术" class="headerlink" title="数据库战术"></a>数据库战术</h2><p>数据库战术，即为保持数据库基础架构的可靠性而做的日常运维任务。</p><p><br></p><h3 id="在从服务器上做备份"><a href="#在从服务器上做备份" class="headerlink" title="在从服务器上做备份"></a>在从服务器上做备份</h3><p>一些小提示：</p><ul><li>在备份上不要拖延，做备份其实并不难</li><li>做事不要追求完美，而要追求可恢复</li><li>至少对于可接受的数据损失、可接受的宕机时间、数据持续策略以及安全需求要形成文档</li><li>对恢复过程要进行练习并形成文档，恢复比备份要重要的多</li><li>对于备份成功与否，要进行外部验证，不要依赖于作业自身对你的提示</li></ul><p>可以专门配置一台复制(备份)从服务器，将复制延迟一段时间——如30min，以避免主服务器上的某些误操作——如<code>DROP table</code>。</p><p><br></p><h3 id="在线模式修改"><a href="#在线模式修改" class="headerlink" title="在线模式修改"></a>在线模式修改</h3><p>将表做的小一点是很有好处的。</p><p>一般的想法是设置主-主复制对，但只有一台服务器可写。在只读上执行更新，但不要复制到可写服务器上。更新一旦完成，则用正常方式使应用程序实现失效转移。这样，读和写便实现了角色转换。然后在另一台服务器上重复执行风险。这就实现了对应用程序隐含宕机时间的目的。</p><p><br></p><h3 id="监控和图示"><a href="#监控和图示" class="headerlink" title="监控和图示"></a>监控和图示</h3><p>构建用于测量和监控的系统是很值得做的事情，这些系统是基础架构非常重要的核心内容。</p><p><br></p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>一般步骤是，在产生麻烦的时间内手机详细的诊断数据，消除掉可能的原因，集中在问题的现象上。<br>问题往往是服务器产生大量负载，而这通常是由于糟糕的查询产生的。</p><p>MySQL所谓的慢查询日志(slow query log)可以回答这个问题，不仅是因为日志收集了慢查询的信息，而且对于每个查询还有时间信息。</p><p>加入性能问题不是查询引起的，则需要对MySQL本身进行性能测试。</p><p><br></p><h3 id="归档和删除数据"><a href="#归档和删除数据" class="headerlink" title="归档和删除数据"></a>归档和删除数据</h3><p>从一开始就要规划归档和删除不活动或不需要的数据，这样有助于减小“工作集”的大小。</p><ul><li>将极不活跃的用户数据移动到慢速服务器，或仅仅将用户设置为过期。当用户登录或重新激活时，在倒回到正常表中</li><li>另外一类可归档或删除的数据是陈旧的历史数据，或将历史数据移到另外的服务器上</li></ul><p><br><br><br></p><h2 id="结语-4"><a href="#结语-4" class="headerlink" title="结语"></a>结语</h2><p>尽最大可能将数据库架构建立在逻辑的基础上，而不是做一些看起来很酷的事情。</p><p>努力使系统保持小巧，不要大——而当不得不变大时，也要保持在能够掌控的范围内。要确定应用程序的真正需求，尽可能满足这些需求。要尽早及经常做缓存，但不要尽早及经常做分片。</p><p>最重要的，请记住：<strong>做备份</strong>。</p><p><br><br><br></p><hr><p><br></p><h1 id="如何优雅地失败：事后处理的艺术与科学"><a href="#如何优雅地失败：事后处理的艺术与科学" class="headerlink" title="如何优雅地失败：事后处理的艺术与科学"></a>如何优雅地失败：事后处理的艺术与科学</h1><p>宕机意味着实际的金钱损失。<br>客户才不会管这些故障，他们要的就是可靠性。互联网已经变得非常重要，宕机成本也越来越高。</p><p>但正如一个刚毕业的年轻人一样，只是知道你需要成长，但并没有告诉你如何去成长。我们需要将失败转化为学习经验。</p><p>保证网站稳定的首要事情，就是建立一个系统化的事后分析过程。通过阻止事故的重现以及改进处理事故的方法，使得系统稳定之后，事后分析能够让你全面地理解事故的本性。</p><p>例行的时候分析，是对运维的复杂问题进行科学分析的最贴近的方法。通过收集实际证据，可将有限的资源集中于解决产生问题的实际原因上。</p><p><br><br><br></p><h2 id="什么是事后分析"><a href="#什么是事后分析" class="headerlink" title="什么是事后分析"></a>什么是事后分析</h2><p>事后分析至少要包含这些内容：</p><ul><li>事故描述</li><li>根本原因描述</li><li>事件是如何修复的</li><li>用于解决事故的行动的时间表</li><li>事故是如何影响用户的</li><li>纠正或改正动作</li></ul><p>事后分析时，与事故明显有关的人员都要同时到场，对事故的真实情况作出共同的描述，从而正确地采取行动。</p><p>减少事故的修复时间，就跟消除事故本身一样重要。</p><p>对问题赋予严重级别，将帮助你按照轻重缓急来处理纠正项，而且对于活跃事件的评估也是有用的。</p><p>事故严重级别：</p><ul><li>严重影响大批用户</li><li>网站降级运行、性能问题或很难应对的功能故障</li><li>对客户影响不大或易于应对</li></ul><p><br><br><br></p><h2 id="什么时候引入事后分析"><a href="#什么时候引入事后分析" class="headerlink" title="什么时候引入事后分析"></a>什么时候引入事后分析</h2><p>在事故处理完成之后，就应该进行事故分析。事后分析过程应该最终使用户获益，而不应该在恢复服务的过程中进行。</p><p><br><br><br></p><h2 id="进行事后分析"><a href="#进行事后分析" class="headerlink" title="进行事后分析"></a>进行事后分析</h2><p>开始事后分析时，要明确基本规则，要明确告知参与事后分析的相关各方，事后分析不是指责谁(人们害怕这样的会议变成政治迫害)，主要目的是为了使类似事件不在重复发生。问题不可避免，重要的是我们能够从错误中学到教训。<br>事情一旦清楚之后，就可以开始讨论为了使类似事情不在发生，需要做些什么。确保相关各方对各自领域都能得出补救的办法。但切记不可矫枉过正！</p><p>一旦有了一套纠正措施，要将其记录在案，包括执行人员和完成日期。</p><p><br><br><br></p><h2 id="事后分析的后续工作"><a href="#事后分析的后续工作" class="headerlink" title="事后分析的后续工作"></a>事后分析的后续工作</h2><p>对纠正措施必须进行追踪，直到执行完成。</p><p>一些网站可操作性：</p><ul><li>消除单点故障</li><li>容量规划</li><li>监控</li><li>发布管理</li><li>运维架构复审</li><li>配置管理</li><li>随时待命和提升过程</li><li>不稳定的组件</li></ul><p><br><br><br></p><h2 id="结语-5"><a href="#结语-5" class="headerlink" title="结语"></a>结语</h2><p>最后，对于避免事故的发生，事后分析是最有用的方法。在一个快速变化的环境中，发生问题时可以理解的，但问题重复发生却是不能原谅的。花些时间高清楚问题的实质，从而确定、记录以及实施高强度的纠正措施，就可以避免事故的重复发生。</p><p><br><br><br></p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>数据是一项最重要、不可替代的商业资产。</p><p><br></p><h2 id="数据资产的库存"><a href="#数据资产的库存" class="headerlink" title="数据资产的库存"></a>数据资产的库存</h2><p>在开始一项新的存储工作时，首要的事情是要知道数据存在哪里。<br>对于不了解的数据，你是无法进行保护的。</p><p><br><br><br></p><h2 id="数据的保护"><a href="#数据的保护" class="headerlink" title="数据的保护"></a>数据的保护</h2><p>数据保护对所有系统都是很重要的。<br>良好的数据保护实践有助于处理范围广泛的情形，从还原被用户偶然删除的文件，到从灾难事件中恢复。</p><p>为了对数据中心问题提供完全的防护，重要的是将关键数据复制到不同的地点。</p><p>如今大多数的存储系统都有某种类型的复制技术。复制通常有两种形式：同步和异步。</p><p><br><br><br></p><h2 id="容量规划"><a href="#容量规划" class="headerlink" title="容量规划"></a>容量规划</h2><p>在确保有效的的数据保护之后，作为一名存储专业人员，容量规划就是第二项最重要的职责。<br>规划在前，确保应用和服务有足够的资源来运行和成长，不至于碰到天花板，这是必须的。</p><p>总是确保有足够的空间以应对突然的爆炸性增长，以及软件开发方面出现的延迟。</p><p><br><br><br></p><h2 id="存储大小的变化"><a href="#存储大小的变化" class="headerlink" title="存储大小的变化"></a>存储大小的变化</h2><p>存储是很昂贵的，这是现代基础框架中成本最高的组件。正是由于这个原因，对于存储上的开支进行明智地规划是很重要的。</p><p>存储需求要点：</p><ul><li>应用是什么</li><li>应用位于哪里</li><li>存储的是什么类型的数据</li><li>需要共享存储吗</li><li>是否需要特殊的访问协议</li><li>典型的文件大小是多少</li><li>数据是压缩的吗</li><li>如果描述工作负载</li><li>需要批处理操作吗</li><li>工作负荷是大部分用于读、写、读写</li><li>工作负荷是大部分顺序、还是大部分随机、还是两者</li><li>快照是怎么安排的</li><li>快照的一致性问题</li><li>存储容量在6个月、12个月、18个月的计划是什么</li><li>工作负荷在6个月、12个月、18个月的计划是什么</li><li>复制策略是什么</li><li>业务连续性规划是什么</li><li>可用性需求是什么</li><li>备份的频度是什么</li><li>备份保持的计划是什么样的</li><li>归档策略是什么</li><li>综合性需求是什么</li><li>加密需求是什么</li><li>…</li></ul><p><br><br><br></p><h2 id="结语-6"><a href="#结语-6" class="headerlink" title="结语"></a>结语</h2><p>数据是最宝贵的业务资产，且是不可替换的。</p><p><br><br><br></p><hr><p><br></p><h1 id="非关系数据库"><a href="#非关系数据库" class="headerlink" title="非关系数据库"></a>非关系数据库</h1><p>应用的数据存储层的伸缩是很难的。不管用的是什么数据库技术，随着数据量和事务数量的增长，就需要做出改变以适应新的负荷。</p><p>SQL数据库的可伸缩性通常归结为四件事：<strong>缓存、查询优化、购买新硬件、数据库分片。</strong></p><p><br><br><br></p><h2 id="NoSQL数据库概览"><a href="#NoSQL数据库概览" class="headerlink" title="NoSQL数据库概览"></a>NoSQL数据库概览</h2><p>NoSQL共生系统，可将数据库划分为5大类：</p><ul><li>纯粹的键值</li><li>数据结构</li><li>图</li><li>面向文档</li><li>高度分布</li></ul><p>每种类别的数据库都面向不同的应用情况，每个类别也都做了不同的这种。</p><p><br><br><br></p><h3 id="纯粹的键值"><a href="#纯粹的键值" class="headerlink" title="纯粹的键值"></a>纯粹的键值</h3><p>如： Tokyo Cabinet、 Kyoto Cabinet、MemcacheDB</p><p>正是它们的简单性定义了这组数据库。向数据库存入一个键和一个值，然后用同一个键查询数据库，则会得到相同的值。没有结构或类型系统——通常所处理的只是字节或字符串。因为这种简单性，这些数据库的开销极小，所以非常块。事实上，这些数据库通常都是实现为磁盘上的B树或哈希表。</p><p><br><br><br></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构数据库对键值数据库做了些修改，数据结构数据库将其存储为特定的数据结构，如<strong>列表、集合、哈希表等。</strong>有了这些附加的结构，就可以对值执行一些原子操作。可以对数据库执行在应用程序中对数据结构进行的各种操作。</p><p>Redis默认是在内存中(in memory)存储其全部内容，只是周期性地将内容的快照存储到磁盘。这使得Redis出奇的快，但假如数据库奔溃了，就会对数据造成一些损失，同时也意味着必须有足够的RAM存储这个数据库。</p><p><br><br><br></p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图数据库几乎就是数据结构数据库的一个特定实现，因为图本就是一种数据库。区别是图数据库不再是基于键值，数据是作为图的节点和边存储的。图数据库不是用键来查询值，而是给出根节点的句柄，然后就可以遍历整个图以找到需要的节点或边。</p><p>图数据库的优势：存储图或树形的数据。如一个社交图(social graph)。</p><p>常见图数据库包含：<strong>Neo4j、HyperGraphDB、InfoGrid、VertexDB。</strong></p><p><br><br><br></p><h2 id="面向文档"><a href="#面向文档" class="headerlink" title="面向文档"></a>面向文档</h2><p>面向文档的数据库又类似于键值数据库，但值不再是字节、字符串、列表、集合，而是<strong>文档</strong>。<br>文档作为JSON(BSON)对象存储，本质上是一种哈希表或字典。这些值都想相同的结构，意味着可以用查询来探测这种结构，并只返回所需要的文档。这种查询能力是建立在通过键来查找文档的能力之上的。</p><p>常见面向文档数据库： <strong>MongoDB、CouchDB</strong>。</p><p><br><br><br></p><h3 id="高度分布"><a href="#高度分布" class="headerlink" title="高度分布"></a>高度分布</h3><p>高度分布的数据库多少有些不同——有些本质上更接近于键值存储，其它则像大型的多维哈希图。</p><p><strong>HBase、Cassandra</strong>是高度分布式数据库。</p><p><br><br><br></p><h2 id="某些细节"><a href="#某些细节" class="headerlink" title="某些细节"></a>某些细节</h2><p>注意这些数据库之间的一些相似性，以及所做决策是如何影响系统可操作性的。</p><p><br><br><br></p><h3 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h3><p>Cassandra是一个高度分布数据库。</p><p>它有一些关键概念：</p><ul><li>认为写比读更难于伸缩，所以它专门为写操作做了大量优化</li><li>认为不应该存在单一故障点<br>任何数据可以写入到集群内的任何一个节点，而且读也一样。任何接收到请求的节点都可以，并且将会吧请求转发到合适的节点。</li></ul><p><br><br><br></p><h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><p>HBase选择一致性和可用性作为自己的核心价值。这样的结果，导致了在某些网段、集群无法实现优雅的恢复。作为这种牺牲的补偿，HBase有很强的一致性，保证写入一结束，写入的值就立即可以读取。</p><p><br><br><br></p><h3 id="Riak"><a href="#Riak" class="headerlink" title="Riak"></a>Riak</h3><p>Riak实现了向量时钟(vector clocks)，一些高度分布的数据库都没有实现——这些数据库选择了依赖于更为简单的基于时间戳的技术。</p><p>向量时钟是一种分布式系统中的机制，用于生成偏序事件。使用向量时钟，解决发生在两个独立的不同节点中的相同值的冲突就变得非常简单。从Riak客户端的角度来看，每个客户实例在Riak集群中执行一个动作时，都应该有一个唯一的标识(token)(连同其接收到的向量时钟一起)。然后，客户读取数据时，就可以看到向量时钟和数据值，使用包含的信息连接两个结果，从而将正确的版本写会数据库。</p><p>Riak也不存在单一故障点。</p><p><br><br><br></p><h3 id="CouchDB"><a href="#CouchDB" class="headerlink" title="CouchDB"></a>CouchDB</h3><p>CouchDB对世界的看法是一致的：所有东西都是文档，而且都通过RESTful HTTP来访问。<br>CouchDB可以在数据库中直接存储静态媒体，它实际上是允许将整个应用程序都存储在数据库中的。<br>CouchDB的数据模型很新颖，即数据以一种只附加的B树进行存储。</p><p><br><br><br></p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>MongoDB是一个面向文档的数据库，文档格式使用BSON——一种类似于JSON对象的二进制规范。MongoDB是用C++写的，因而有很高的性能。</p><p>所有能用SQL做的事情也能用MongoDB查询表达式来做。<br>MongoDB与以SQL数据库相同的方式支持索引，同时这些索引也强制了唯一性。</p><p>MongoDB有一个<code>mongostat</code>命令来查看数据库状态。</p><p>有好几种MongoDB备份方式：</p><ul><li>停掉数据库，复制数据文件</li><li>锁定数据库写入，复制数据文件，解除锁定</li><li>使用<code>mongodump</code>，将数据库转存到一个二进制文件中</li><li>可以设置一个从服务器，在从服务器上进行备份，而不是主服务器上</li></ul><p><br><br><br></p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis(remote dictionary server)，远程字典服务器。通过<code>INFO</code>可查看相关信息。</p><p>不管你将Redis运行在快照模式(rdb)还是只附加模式(aof)上，都可以简单地调用<code>rsync</code>实现备份。</p><p><br><br><br></p><hr><p><br></p><h1 id="如何高枕无忧"><a href="#如何高枕无忧" class="headerlink" title="如何高枕无忧"></a>如何高枕无忧</h1><p>企业持续规划(Business Continuity Planning)BCP。<br>BCP简单最简单来说，就是<strong>什么都是两份</strong>。当然，两套设备间的失效转移必须完全自动化。</p><p><br><br><br></p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>集中于BCP计划的高可用部分：保证站点正常工作。即使在高可用性领域，也有各种各样的技术，从<strong>热/热(Hot/Hot)、热/暖(Hot/Warm)、热/冷(Hot/Cold)到灾难恢复</strong>。</p><ul><li>热/热是高可用性的最高级别。用户可以从任意的数据中心使用全部的应用程序。读和写可以发生在任何地方。折让自动的故障转移变得非常简单，但它不是万能的。你想必须思考如何处理数据一致性的问题。</li><li>热/暖是一种很好的方式，如果你不能容忍数据的不一致性的话。很多应用有大量的读操作，仅偶尔写一下(但很重要)。在这种情况下，区别处理这两种操作是有意义的。</li><li>热/冷让我害怕。这种架构将读写流量送到单一地点，而让另一个相同的部署在遥远的地平线上闲置。它容易建立，但价值很低。</li><li>灾难恢复是最差的技术，本质上是雾件(vaporware)。它的本意不是在平常的时候保护你，而是在大的灾难发生时给你提供重建的选项。</li></ul><p><br><br><br></p><h2 id="影响持续时间对事件持续时间"><a href="#影响持续时间对事件持续时间" class="headerlink" title="影响持续时间对事件持续时间"></a>影响持续时间对事件持续时间</h2><p>当灾难来袭时，所有你需要考虑的是将用户流量以最快速度转移，离开问题区域。你需要立即降低影响。不要过于担心根源问题的修复，一旦将影响制止住，会有很多时间来解决这次事故。</p><p>怎样才能将流量从问题站点转出呢？通常方案是使用<strong>全局负载均衡(Global Server Load Balancing)GSLB</strong>。这实际是一个动态的授权DNS服务器，他能够根据相关因素对同一域名给出不同的IP地址。</p><p><br><br><br></p><h2 id="数据中心数量"><a href="#数据中心数量" class="headerlink" title="数据中心数量"></a>数据中心数量</h2><p>我们知道数据中心会失效，所以你至少需要两个。这就够了吗？三个或更多是不是会好一些？这取决于三个因素，<strong>成本、复杂性和性能</strong>。</p><p><br><br><br></p><h2 id="逐渐失效"><a href="#逐渐失效" class="headerlink" title="逐渐失效"></a>逐渐失效</h2><p>当数据中心出现局部问题(partial problem)时，不要等它解决从而希望你不需要撤离，立即导出复制数据！</p><p><br><br><br></p><h2 id="不信赖任何人"><a href="#不信赖任何人" class="headerlink" title="不信赖任何人"></a>不信赖任何人</h2><p>正如最可靠的数据中心也会时不时宕机，你可以预期即使最好的第三方供应商，偶尔也会有问题。就是你不能完全信赖一个服务提供商。</p><p><br><br><br></p><h2 id="故障测试转移"><a href="#故障测试转移" class="headerlink" title="故障测试转移"></a>故障测试转移</h2><p>通过早期和经常的测试，获取经验，以便当灾难袭来时，不会手忙脚乱，而是立即做出正确的事情。</p><p><br><br><br></p><h2 id="监控和历史模式"><a href="#监控和历史模式" class="headerlink" title="监控和历史模式"></a>监控和历史模式</h2><p>你要知道日、周、月的流量模式。如果清楚正常流量中的不寻常处，你就不会在切换、迁移或升级时感到惊讶。确保监控包括周对周的图形和趋势。</p><p><br><br><br></p><h2 id="高枕无忧"><a href="#高枕无忧" class="headerlink" title="高枕无忧"></a>高枕无忧</h2><p>如果你能够事先有计划，能够解决大的问题，并且在日常工作中操练故障转移，则平台任何部分的失效将会变成容易处理的事件，而不是危机。</p><p><br><br><br></p><hr><p><br></p><p>March 25, 2018 11:32 AM</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《网站运维：保持数据实时的秘籍》(Web Operations: Keeping the Data on Time)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Database" scheme="https://zhang21.github.io/tags/Database/"/>
    
      <category term="Operations" scheme="https://zhang21.github.io/tags/Operations/"/>
    
  </entry>
  
  <entry>
    <title>《经济学原理》读书笔记</title>
    <link href="https://zhang21.github.io/2018/02/23/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://zhang21.github.io/2018/02/23/经济学原理读书笔记/</id>
    <published>2018-02-23T08:13:58.000Z</published>
    <updated>2018-02-25T11:24:49.684Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>《经济学原理-微观/宏观》，曼昆： <a href="https://book.douban.com/subject/26435630/" target="_blank" rel="noopener">https://book.douban.com/subject/26435630/</a></li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><h1 id="微观经济学"><a href="#微观经济学" class="headerlink" title="微观经济学"></a>微观经济学</h1><p>阿尔弗雷德·马歇尔在《经济学原理》中写道<strong>经济学是一门研究人类一般生活事务的学问</strong>。</p><p>应当学习经济学的原因如下：</p><ul><li>有助于你理解你所生活在其中的世界</li><li>使你更加精明的参与经济</li><li>使你更好地理解经济政策的潜力与局限性</li><li>经济学原理可以运用到生活中的方方面面</li></ul><p><br></p><p>经济学领域的伟大洞见，如亚当·斯密的<strong>看不见的手</strong>的概念、大卫·李嘉图的<strong>比较优势原理</strong>，以及约翰·梅纳德·凯恩斯的<strong>总需求理论</strong></p><p><br><br><br></p><hr><p><br></p><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p><br></p><h3 id="经济学十大原理"><a href="#经济学十大原理" class="headerlink" title="经济学十大原理"></a>经济学十大原理</h3><p><strong>经济(economy)</strong>这个词来源于希腊语oikonomos，意思是“管理一个家庭的人”。</p><p>一个家庭面临着许多决策，同样，一个社会也面临着许多决策。</p><p><br></p><p>由于资源是稀缺的，社会资源的管理就尤为重要。</p><ul><li><strong>稀缺性(scarcity):</strong><ul><li>社会资源的有限性</li></ul></li><li><strong>经济学(economics):</strong><ul><li>研究社会如何管理自己的稀缺资源</li></ul></li></ul><p><br></p><h4 id="人们如何做出决策"><a href="#人们如何做出决策" class="headerlink" title="人们如何做出决策"></a>人们如何做出决策</h4><p>由于一个经济的行为反映了组成这个经济的个人的行为，所以个人就需要做出决策。</p><p><br></p><h5 id="人们面临权衡取舍"><a href="#人们面临权衡取舍" class="headerlink" title="人们面临权衡取舍"></a>人们面临权衡取舍</h5><ul><li><strong>效率(efficiency):</strong><ul><li>社会能从其稀缺资源中得到最大利益的特性</li></ul></li><li><strong>平等(equlity):</strong><ul><li>经济成果在社会成员中平均分配的特性</li></ul></li></ul><p><br></p><p>作出决策就是要求我们在一个目标与另一个目标之间进行权衡取舍。</p><p>当人们组成社会时，他们会面临不同的权衡取舍。经典的权衡取舍是在<strong>大炮与黄油</strong>之间。</p><p>社会面临的另一种权衡取舍是在效率与平等之间。</p><p>然而，认识到人们面临权衡取舍本身并没有告诉我们人们将会或应该做出什么决策。</p><p><br></p><h5 id="某种东西的成本是为了得到这种东西所放弃的东西"><a href="#某种东西的成本是为了得到这种东西所放弃的东西" class="headerlink" title="某种东西的成本是为了得到这种东西所放弃的东西"></a>某种东西的成本是为了得到这种东西所放弃的东西</h5><ul><li><strong>机会成本(opportunity cost):</strong><ul><li>为了得到某种东西所必须放弃的东西</li></ul></li></ul><p><br></p><p>由于人们面临着权衡取舍，所以做决策就需要比较可供选择的行动方案的成本与收益。</p><p><br></p><h5 id="理性人考虑边际量"><a href="#理性人考虑边际量" class="headerlink" title="理性人考虑边际量"></a>理性人考虑边际量</h5><ul><li><strong>理性人(rational people):</strong><ul><li>系统而有目的地尽最大努力实现其目标的人</li></ul></li><li><strong>边际变动(marginal change):</strong><ul><li>对行动计划的微小增量调整</li></ul></li><li><strong>边际成本(marginal cose):</strong><ul><li>对行动计划调整所带来的成本</li></ul></li><li><strong>边际收益(marginal benefit):</strong><ul><li>对行动计划调整所带来的的收益</li></ul></li><li><strong>边际决策(marginal decision):</strong><ul><li>选择哪种决策</li></ul></li></ul><p><br></p><h5 id="人们会对激励做出反应"><a href="#人们会对激励做出反应" class="headerlink" title="人们会对激励做出反应"></a>人们会对激励做出反应</h5><ul><li><strong>激励(incentive):</strong><ul><li>引起一个人做出某种行为的某种东西</li></ul></li></ul><p><br></p><p>在经济学研究中，激励起着中心作用。</p><p>市场上的高价格提供了买者少消费而卖者多生产的激励。<br>价格对消费者和生产者行为的影响对于市场经济如何配置稀缺资源是至关重要的。</p><p>政府决策者决不能忘记激励，因为许多政策改变了人们面临的成本或收益，从而也改变了人们的行为。</p><p>在分析任何一种政策时，我们不仅应该考虑它的直接影响，而且还应该考虑它通过激励产生的不太明显的间接影响。如果政策改变了激励，那就会使人们改变自己的行为。</p><p><br></p><h4 id="人们如何互相影响"><a href="#人们如何互相影响" class="headerlink" title="人们如何互相影响"></a>人们如何互相影响</h4><p>我们的许多决策不仅影响了我们自己，还会影响其他人。</p><p><br></p><h5 id="贸易可以使每个人的状况都变得更好"><a href="#贸易可以使每个人的状况都变得更好" class="headerlink" title="贸易可以使每个人的状况都变得更好"></a>贸易可以使每个人的状况都变得更好</h5><p>思考国家之间的竞争的想法很容易产生误导。美国与中国之间的贸易并不像体育比赛一样，一方赢而另一方输。实际上，事实正好相反：两国之间的贸易可以使两个国家的状况都变得更好。</p><p>贸易使每个人都可以专门从事自己最擅长的活动，无论它是耕种、做衣服还是盖房子。通过与其他人的贸易，人们可以以较低的成本获得各种各样的物品和服务。</p><p>国家和家庭一样，也能从相互贸易中获益。贸易可以使各国可以专门从事自己最擅长的活动，并享有种类更多的物品与服务。美国人和英国人、法国人一样，在世界经济中既是我们的竞争对手，又是我们的伙伴。</p><p><br></p><h5 id="市场通常是组织经济活动的一种好方法"><a href="#市场通常是组织经济活动的一种好方法" class="headerlink" title="市场通常是组织经济活动的一种好方法"></a>市场通常是组织经济活动的一种好方法</h5><ul><li><strong>市场经济(market economy):</strong><ul><li>当许多企业和家庭在物品与服务市场上相互交易时，通过他们的分散决策配置资源的经济</li></ul></li><li><p><strong>看不见的手(invisible hand):</strong></p></li><li><p><strong>利己心(self-interest):</strong></p></li></ul><p><br></p><p>中央计划经济国家运行的前提假设是，政府官员能够最佳地配置经济中稀缺资源。这些中央计划者决定，生产什么物品与服务、生产多少，以及谁生产和消费这些物品与服务。支撑中央计划经济的理论是，只有政府才能以促进整个社会经济福利的方式组织经济活动。</p><p>大部分曾经是中央计划经济的国家已经放弃了这个制度，代之以发展市场经济。在市场经济中，中央计划者的决策被数千百万企业和家庭的决策所取代。</p><p><br></p><p>在市场经济中，没有一个人追求整个社会的经济福利。自由市场包括大量物品与服务的许多买者与卖者，而所有的人都主要关心自己的福利。</p><p>经济学家亚当·斯密在《国富论》中提出了全部经济学中最著名的观察结果：“家庭和企业在市场上相互交易，他们仿佛被一只<strong>看不见的手</strong>所指引，并导致了合意的市场结果。”</p><p>价格就是看不见的手用来指引经济活动的工具。作为买者与卖者决策的结果，市场价格既反映了一种物品的社会价值，也反映了生产该物品的社会成本。斯密的重要洞察是，价格会自发调整，指引这些单个买者和卖者达到某种结果，该结果在大多数情况下会实现整个社会福利的最大化。</p><p>斯密的观点有一个重要的推论：当政府阻止价格根据供求状况自发调整时，它就限制了看不见的手对组成经济的千百万家庭和企业的决策进行协调的能力。这个推论解释了为什么税收对资源配置有不利的影响：由于税收扭曲了价格，从而也扭曲了家庭和企业的决策。这个推论还解释了像租金控制这类直接控制价格的政策所引起的巨大危害。而且，这个推论解释了中央计划经济的失败。在中央计划经济国家，价格并不是在市场上决定的，而是由中央计划者规定的。这些计划者缺乏关于消费者爱好和生产者成本的必要信息，而在市场经济中这些信息都反映在价格上。中央计划者之所以失败，是因为他们在管理经济时把市场这只看不见的手绑起来了。</p><p>亚当·斯密描述了市场经济中人们如何相互影响：</p><blockquote><p>人类几乎随时随地都需要同胞的协助，要想仅仅依赖他人的恩惠，那是绝对不行的。他如果能够刺激他人的利己心，使其有利于他，并告诉其他人，给他做事是对他们自己有利的，那么他要达到目的就容易得多了。··· ···请给我们我所要的东西吧，同时，你也可以获得你所要的东西：这句话是交易的通义。我们所需要的相互帮助，大部分是依照这个方法取得的。<br>我们每天所需的食物和饮料，不是出自屠户、酿酒师或面包师的恩惠，而是出自他们利己的打算。我们不说唤起他们利他心的话，而说唤起他们利己心得话。我们不说自己有需要，而说对他们有利。社会上，除乞丐外，没有一个人愿意全然靠别人的恩惠过活… …<br>每一个人··· ···既不打算促进公共的利益，也不知道自己是在何种程度上促进那种利益··· ···他所盘算的也只是他自己的利益。在这种场合下，像在其他许多场合一样，他受着一只看不见的手的引导，去尽力达到一个并非他本意想要达到的目的。也并不因为不是出于本意，就对社会有害。他追求自己的利益，往往使他能比在真正处于本意的情况下更有效地促进社会的利益。</p></blockquote><p>斯密是说，经济参与者受利己心所驱动，而市场上这只看不见的手指引这种利己心去促进总体的经济福利。</p><p><br></p><h5 id="政府有时可以改善市场结果"><a href="#政府有时可以改善市场结果" class="headerlink" title="政府有时可以改善市场结果"></a>政府有时可以改善市场结果</h5><ul><li><strong>产权(property rights):</strong><ul><li>个人拥有并控制稀缺资源的能力</li></ul></li><li><strong>市场失灵(market failure):</strong><ul><li>市场本身不能有效的配置资源的情况</li></ul></li><li><strong>外部性(externality):</strong><ul><li>一个人的行为对旁观者福利的影响</li><li>外部性的经典例子是污染</li></ul></li><li><strong>市场势力(market power):</strong><ul><li>单个经济活动者(或某个经济活动小群体)对市场价格有显著影响的能力</li></ul></li></ul><p><br></p><p>我们需要政府的原因之一是：只有在政府实施规则并维持对市场经济至关重要的制度时，看不见的手才能施展其魔力。最重要的是，市场经济需要实施产权制度，以便个人可以拥有和控制稀缺资源。<br>我们都依靠政府提供的警察和法律来实施我们对自己生产出来的东西的权利——而看不见的手依靠我们实施自己权利的能力。</p><p>然而，我们需要政府的另一个原因是：看不见的手是强有力的，但并不是无所不能的。政府干预经济并改变人们自己选择的资源配置的原因有两类：<strong>促进效率</strong>和<strong>促进公平</strong>。这就是说，大多数政策的目标要么是把经济蛋糕做大，要么是改变这个蛋糕的分割方式。</p><p>在存在外部性或市场势力的情况下，设计良好的公共政策可以提高经济效率。</p><p>即使看不见的手带来了有效率的产出，他也不能消除经济福利上巨大的不对称。根据某种政治哲学，这种不平等要求政府进行干预。实际上，许多公共政策，例如所得税和福利制度的目标就是要实现更平等的经济福利分配。</p><p>我们说政府有时可以改善市场结果并不意味着它总会这样。公共政策并不是天使制定的，而是由不完善的政治程序制定的。有时所设计的政策只是为了有利于政治上有权势的人；有时政策是由动机良好但信息不充分的领导人制定的。</p><p><br></p><h4 id="整体经济如何运行"><a href="#整体经济如何运行" class="headerlink" title="整体经济如何运行"></a>整体经济如何运行</h4><p>决策和相互影响共同组成了<strong>经济</strong>。</p><p><br></p><h5 id="一国的生活水平取决于它生产物品与服务的能力"><a href="#一国的生活水平取决于它生产物品与服务的能力" class="headerlink" title="一国的生活水平取决于它生产物品与服务的能力"></a>一国的生活水平取决于它生产物品与服务的能力</h5><ul><li><strong>生产率(productivity):</strong><ul><li>每单位劳动投入所生产的物品与服务数量</li></ul></li></ul><p><br></p><p>世界各国生活水平的差别是惊人的。<br>随着时间的推移，生活水平的变化也是巨大的。</p><p><strong>几乎所有的生活水平的差别都可以归因于各国生产率的差别。</strong></p><p>生产率和生活水平之间的基本关系是简单的，但它的意义却是深远的。如果生产率是生活水平的首要决定因素，那么，其他因素就应该是次要的。</p><p><br></p><h5 id="当政府发行了过多货币时，物价上升"><a href="#当政府发行了过多货币时，物价上升" class="headerlink" title="当政府发行了过多货币时，物价上升"></a>当政府发行了过多货币时，物价上升</h5><ul><li><strong>通货膨胀(inflation):</strong><ul><li>经济中物价总水平的上升</li></ul></li></ul><p><strong>在大多数严重或持续通货膨胀的情况下，罪魁祸首是货币量的增长。</strong></p><p>当一国政府发行了大量本国货币时，货币的价值就下降了。</p><p>由于高通货膨胀会让社会付出各种成本，所以世界各国的经济政策制定者都把保持低通货膨胀作为目标之一。</p><p><br></p><h5 id="社会面临通货膨胀与失业之间的短期权衡取舍"><a href="#社会面临通货膨胀与失业之间的短期权衡取舍" class="headerlink" title="社会面临通货膨胀与失业之间的短期权衡取舍"></a>社会面临通货膨胀与失业之间的短期权衡取舍</h5><ul><li><strong>经济周期(business cycle):</strong><ul><li>就业和经济生产的波动</li></ul></li></ul><p><br></p><p>虽然在长期中，物价水平上升主要是货币增加的结果，但短期中，问题就变得更为复杂更具争议性。</p><p>大多数经济学家这样描述货币注入的短期效应：</p><ul><li>经济中货币量增加刺激了社会的整体支出水平，从而增加了对物品与服务的需求</li><li>需求的增量随着时间的推移，会引起企业提高物价，但同时，它也鼓励企业雇佣更多的工人，并生产更多的产品与服务</li><li>服用更多的工人意味着更少的失业</li></ul><p>你知道，支出链将以乘数扩大，并带来更高的收入和就业。人们看到了发生了的活动，但他们没有看到本来会发生的活动。</p><p><br></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><strong>经济学十大原理：</strong></p><ul><li>人们如何做出决策<ul><li>人们面临权衡取舍</li><li>某种东西的成本是为了得到它所放弃的东西</li><li>理性人考虑边际量</li><li>人们会对激励做出反应</li></ul></li><li>人们如何相互影响<ul><li>贸易可以使每个人的状况都变得更好</li><li>市场通常是组织经济活动的一种好方法</li><li>政府有时可以改善市场结果</li></ul></li><li>整体经济如何运行<ul><li>一国的生活水平取决于它生产物品与服务的能力</li><li>当政府发行了过多的货币时，物价上升</li><li>社会面临通货膨胀与失业之间的短期权衡取舍</li></ul></li></ul><p><br><br><br></p><hr><p><br></p><h3 id="像经济学家一样思考"><a href="#像经济学家一样思考" class="headerlink" title="像经济学家一样思考"></a>像经济学家一样思考</h3><p>每个研究领域都有自己的语言和思考方式。经济学家也一样。<br>供给、需求、弹性、比较优势、消费者剩余和无谓损失——这些术语也是经济学家语言的一部分。</p><p><br></p><h4 id="作为科学家的经济学家"><a href="#作为科学家的经济学家" class="headerlink" title="作为科学家的经济学家"></a>作为科学家的经济学家</h4><p>先提出理论，再收集数据，然后分析数据，以努力证明或否定他们的理论。</p><p><br></p><h5 id="科学方法：观察、理论和进一步观察"><a href="#科学方法：观察、理论和进一步观察" class="headerlink" title="科学方法：观察、理论和进一步观察"></a>科学方法：观察、理论和进一步观察</h5><p>在经济学研究中，进行实验往往是不可能的。通常不得不使用这个世界向他们提供的数据。</p><p>为了寻找实验室实验的替代品，经济学家十分关注历史所提供的自然实验。</p><p><br></p><h5 id="假设的作用"><a href="#假设的作用" class="headerlink" title="假设的作用"></a>假设的作用</h5><p>当我们在研究政策变动在长短不同时间中的影响时，就会做出不同的假设。</p><p><br></p><h5 id="经济模型"><a href="#经济模型" class="headerlink" title="经济模型"></a>经济模型</h5><p>经济学家也用模型来了解世界，但不是塑料模型，而通常是由图形和方程组成的模型。</p><p><br></p><h5 id="第一个模型：循环流量图"><a href="#第一个模型：循环流量图" class="headerlink" title="第一个模型：循环流量图"></a>第一个模型：循环流量图</h5><ul><li><strong>循环流量图(circular-flow diagram):</strong><ul><li>一个说明货币如何通过市场在家庭与企业之间流动的直观经济模型</li></ul></li><li><strong>生产要素(production factors):</strong><ul><li>劳动、土地、资本等投入品被称为生产要素</li></ul></li></ul><p><br></p><p>企业用生产要素来生产产品和服务，家庭则拥有生产要素并消费企业生产的物品与服务。家庭与企业之间相互交易。</p><p><br></p><h5 id="第二个模型：生产可能性边界"><a href="#第二个模型：生产可能性边界" class="headerlink" title="第二个模型：生产可能性边界"></a>第二个模型：生产可能性边界</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《经济学原理-微观/宏观》，曼昆： &lt;a href=&quot;https://book.douban.com/subject/26435630/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://book.douban.com/subject/26435630/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Economics" scheme="https://zhang21.github.io/categories/Economics/"/>
    
    
      <category term="Economics" scheme="https://zhang21.github.io/tags/Economics/"/>
    
  </entry>
  
  <entry>
    <title>Windows</title>
    <link href="https://zhang21.github.io/2018/02/11/Windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://zhang21.github.io/2018/02/11/Windows常用命令/</id>
    <published>2018-02-11T06:37:59.000Z</published>
    <updated>2018-02-26T02:52:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><a id="more"></a><p><br></p><h1 id="Windows快捷操作"><a href="#Windows快捷操作" class="headerlink" title="Windows快捷操作"></a>Windows快捷操作</h1><p><br></p><h2 id="打开Windows系统应用"><a href="#打开Windows系统应用" class="headerlink" title="打开Windows系统应用"></a>打开Windows系统应用</h2><ul><li>运行<ul><li><code>Win+R</code></li></ul></li><li>远程桌面<ul><li><code>mstsc</code> (Microsoft terminal services client)</li></ul></li><li>记事本<ul><li><code>notepad</code></li></ul></li><li>计算器<ul><li><code>calc</code></li></ul></li><li>屏幕键盘<ul><li><code>osk</code></li></ul></li><li>设备管理器<ul><li><code>devmgmt.msc</code></li></ul></li><li>事件查看器<ul><li><code>eventvwr.msc</code></li></ul></li><li>任务管理器<ul><li><code>taskmgr</code></li></ul></li><li>服务列表<ul><li><code>services.msc</code></li></ul></li><li>注册表<ul><li><code>regedit</code></li></ul></li><li>共享文件夹<ul><li><code>fsmgmt.msc</code></li></ul></li><li>系统信息<ul><li><code>msinfo32</code></li></ul></li><li>系统配置<ul><li><code>msconfig</code></li></ul></li><li>DirecX<ul><li><code>dxdiag</code></li></ul></li><li>清屏<ul><li><code>cls</code></li></ul></li></ul><p><br><br><br></p><h2 id="Windows快捷键"><a href="#Windows快捷键" class="headerlink" title="Windows快捷键"></a>Windows快捷键</h2><p><br><br><br></p><hr><p><br></p><h1 id="Windows批处理命令"><a href="#Windows批处理命令" class="headerlink" title="Windows批处理命令"></a>Windows批处理命令</h1><p>Windows下并不区分大小写。</p><p>batch or batch file or DOS batch.是由DOS或Windows内嵌命令解释器(cmd.exe)解释执行。<br>类似于Unix中的shell script。</p><p>在批处理中，不仅可以使用系统內建的命令，还可使用已安装的第三方提供的软件。</p><p>一般情况下，每条命令占一行，当然也可以将多条命令用特定符号<code>&amp;  &amp;&amp;  |  ||</code>分隔后写到同一行。</p><p>系统在解释运行批处理程序时，首先扫描整个批处理程序，然后从第一行代码开始详细逐句执行所有命令，直至程序结尾或遇见 exit 命令或出错意外退出。</p><p><br><br><br></p><h2 id="基础批处理命令"><a href="#基础批处理命令" class="headerlink" title="基础批处理命令"></a>基础批处理命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#查看命令帮助</div><div class="line">cmd /?</div><div class="line"></div><div class="line"></div><div class="line">#打开或关闭回显</div><div class="line">echo</div><div class="line"></div><div class="line"></div><div class="line">#注释命令</div><div class="line">rem</div><div class="line"></div><div class="line"></div><div class="line">#暂停命令</div><div class="line">pause</div><div class="line"></div><div class="line"></div><div class="line">#从一个批处理程序调用另一个批处理程序，并且不终止父批处理程序</div><div class="line">call</div><div class="line"></div><div class="line"></div><div class="line">#调用外部程序，所有的dos命令都可以由start命令来调用</div><div class="line">start</div><div class="line"></div><div class="line"></div><div class="line">#跳转命令</div><div class="line">goto</div><div class="line"></div><div class="line"></div><div class="line">#显示、设置或删除变量</div><div class="line">set</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="批处理常用符号"><a href="#批处理常用符号" class="headerlink" title="批处理常用符号"></a>批处理常用符号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#回显屏蔽</div><div class="line">@</div><div class="line"></div><div class="line"></div><div class="line">#输出重定向</div><div class="line">&gt;  &gt;&gt;</div><div class="line"></div><div class="line"></div><div class="line">#输入重定向</div><div class="line">&lt;</div><div class="line"></div><div class="line"></div><div class="line">#管道符号</div><div class="line">|</div><div class="line"></div><div class="line"></div><div class="line">#转义符</div><div class="line">^</div><div class="line"></div><div class="line"></div><div class="line">#逻辑命令符</div><div class="line">&amp;  &amp;&amp;  ||</div><div class="line"></div><div class="line">#无条件执行&amp;后面的命令</div><div class="line">&amp;</div><div class="line"></div><div class="line">#当&amp;&amp;前面的命令成功后才执行&amp;&amp;后面的命令，否则不执行</div><div class="line">&amp;&amp;</div><div class="line"></div><div class="line">#当 || 前面的命令失败时，才执行 || 后面的命令，否则不执行</div><div class="line">||</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="基础dos命令"><a href="#基础dos命令" class="headerlink" title="基础dos命令"></a>基础dos命令</h2><h3 id="文件操作系统"><a href="#文件操作系统" class="headerlink" title="文件操作系统"></a>文件操作系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vol</div><div class="line"></div><div class="line">lable</div></pre></td></tr></table></figure><p><br></p><h3 id="文件夹管理"><a href="#文件夹管理" class="headerlink" title="文件夹管理"></a>文件夹管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">cd</div><div class="line"></div><div class="line">md/mkdir</div><div class="line"></div><div class="line">rd/rmdir</div><div class="line"></div><div class="line">dir</div><div class="line"></div><div class="line">tree</div><div class="line"></div><div class="line">path</div><div class="line"></div><div class="line">xcopy</div></pre></td></tr></table></figure><p><br></p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">type</div><div class="line"></div><div class="line">copy</div><div class="line"></div><div class="line">del/erase</div><div class="line"></div><div class="line">move</div><div class="line"></div><div class="line">ren/rename</div><div class="line"></div><div class="line">replace</div><div class="line"></div><div class="line">attrib</div><div class="line"></div><div class="line">find</div><div class="line"></div><div class="line">fc</div></pre></td></tr></table></figure><p><br></p><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ping</div><div class="line"></div><div class="line">ftp</div><div class="line"></div><div class="line">net</div><div class="line"></div><div class="line">netstat</div><div class="line"></div><div class="line">route</div><div class="line"></div><div class="line">tracert</div><div class="line"></div><div class="line">telnet</div><div class="line"></div><div class="line">ipconfig</div><div class="line"></div><div class="line">msg</div><div class="line"></div><div class="line">arp</div></pre></td></tr></table></figure><p><br></p><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">at</div><div class="line"></div><div class="line">shutdown</div><div class="line"></div><div class="line">tskill</div><div class="line"></div><div class="line">taskkill</div><div class="line"></div><div class="line">tasklist</div><div class="line"></div><div class="line">sc</div><div class="line"></div><div class="line">reg</div><div class="line"></div><div class="line">powercfg</div></pre></td></tr></table></figure><p><br></p><h3 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cls</div><div class="line"></div><div class="line">assoc</div><div class="line"></div><div class="line">ftype</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="批处理命令使用"><a href="#批处理命令使用" class="headerlink" title="批处理命令使用"></a>批处理命令使用</h2><p><br></p><h3 id="回显控制"><a href="#回显控制" class="headerlink" title="回显控制"></a>回显控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#关闭单行回显</div><div class="line">echo</div><div class="line"></div><div class="line"></div><div class="line">#从下一行开始关闭回显</div><div class="line">echo off</div><div class="line"></div><div class="line">#从本行开始关闭回显，一般批处理第一行都是这个</div><div class="line">@echo off</div><div class="line"></div><div class="line"></div><div class="line">#从下一行开始打开回显</div><div class="line">echo on</div><div class="line"></div><div class="line"></div><div class="line">#显示当前是 echo on还是 echo off</div><div class="line">echo</div><div class="line"></div><div class="line"></div><div class="line">#输出一个“回车换行”</div><div class="line">echo.</div><div class="line"></div><div class="line"></div><div class="line">#输出 hello world</div><div class="line">echo hello world</div><div class="line"></div><div class="line">#关闭回显是指运行批处理文件时，不显示文件里的每条命令，只显示运行结果批处理开始和结束时，系统都会自动打开</div></pre></td></tr></table></figure><p><br></p><h3 id="errorlevel程序返回码"><a href="#errorlevel程序返回码" class="headerlink" title="errorlevel程序返回码"></a>errorlevel程序返回码</h3><p>类似于Unix下的<code>$?</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#查看返回码的值</div><div class="line">echo %errorlevel%</div><div class="line"></div><div class="line">#执行成功默认为0</div><div class="line">#一般命令执行出错为1</div></pre></td></tr></table></figure><p><br></p><h3 id="显示目录和子目录"><a href="#显示目录和子目录" class="headerlink" title="显示目录和子目录"></a>显示目录和子目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">dir</div><div class="line"></div><div class="line"></div><div class="line">#列出所有文件和目录，包括隐藏文件</div><div class="line">dir /a</div><div class="line"></div><div class="line"></div><div class="line">#列出D盘</div><div class="line">dir d:</div><div class="line"></div><div class="line">#列出D盘中的目录</div><div class="line">dir d: /A:d</div><div class="line"></div><div class="line">#/A：属性</div><div class="line"></div><div class="line">/A          显示具有指定属性的文件</div><div class="line"></div><div class="line"></div><div class="line">#属性</div><div class="line"></div><div class="line">D  目录                R  只读文件</div><div class="line"></div><div class="line">H  隐藏文件            A  准备存档的文件</div><div class="line"></div><div class="line">S  系统文件            I  无内容索引文件</div><div class="line"></div><div class="line">L  解析点            -  表示“否”的前缀</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#显示文件内容</div><div class="line">type d:\hello.txt</div></pre></td></tr></table></figure><p><br></p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>%0 %1 %2 … %*, 命令行参数类似于shell</p><ul><li>%0: 批处理文件本身</li><li>%1: 第一个参数</li><li>%*: 所有参数</li></ul><p><br></p><h3 id="if和for"><a href="#if和for" class="headerlink" title="if和for"></a>if和for</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if &quot;%1&quot; == &quot;/a&quot; echo 第一个参数/a</div><div class="line">if /i &quot;%1&quot; equ &quot;/a&quot;</div><div class="line"></div><div class="line">if exist d:\hell.txt (</div><div class="line">echo 存在</div><div class="line">)</div><div class="line">else (</div><div class="line">echo 不存在</div><div class="line">)</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for %%i in (c: d: e: f:) do</div><div class="line">echo %%i</div></pre></td></tr></table></figure><p><br></p><h3 id="set设置变量"><a href="#set设置变量" class="headerlink" title="set设置变量"></a>set设置变量</h3><p>引用变量可在变量前加%，即 %变量名%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">#显示目前所有可用的变量，包括系统变量和自定义的变量</div><div class="line">set</div><div class="line"></div><div class="line"></div><div class="line">#显示系统盘盘符。系统变量可以直接引用</div><div class="line">echo %SystemDrive%</div><div class="line"></div><div class="line"></div><div class="line">#显示所有以p开头的变量，要是一个也没有就设errorlevel=1</div><div class="line">set p</div><div class="line"></div><div class="line"></div><div class="line">#设置变量p，并赋值为 = 后面的字符串，即aa1bb1aa2bb2</div><div class="line">set p=aa1bb1aa2bb2</div><div class="line"></div><div class="line">#显示变量p代表的字符串，即aa1bb1aa2bb2</div><div class="line">echo %p%</div><div class="line"></div><div class="line">#显示变量p中第6个字符以后的所有字符，即aa2bb2</div><div class="line">echo %p:~6%</div><div class="line"></div><div class="line"></div><div class="line">#显示第6个字符以后的3个字符，即aa2</div><div class="line">echo %p:~6,3%</div><div class="line"></div><div class="line"></div><div class="line">#显示前3个字符，即aa1</div><div class="line">echo %p:~0,3%</div><div class="line"></div><div class="line"></div><div class="line">#显示最后面的2个字符，即b2</div><div class="line">echo %p:~-2%</div><div class="line"></div><div class="line"></div><div class="line">#显示除了最后2个字符以外的其它字符，即aa1bb1aa2b</div><div class="line">echo %p:~0,-2%</div><div class="line"></div><div class="line"></div><div class="line"> #用c替换变量p中所有的aa，即显示c1bb1c2bb2</div><div class="line">echo %p:aa=c%</div><div class="line"></div><div class="line"></div><div class="line">#将变量p中的所有aa字符串置换为空，即显示1bb12bb2</div><div class="line">echo %p:aa=%</div><div class="line"></div><div class="line"></div><div class="line"> #第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2</div><div class="line">echo %p:*bb=c%</div><div class="line"></div><div class="line"></div><div class="line">#设置变量p，赋值为 %p:*bb=c% ，即c1aa2bb2</div><div class="line">set p=%p:*bb=c%</div><div class="line"></div><div class="line"></div><div class="line">#设置p为数值型变量，值为39</div><div class="line">set /a p=39</div><div class="line"></div><div class="line"></div><div class="line">#支持运算符，有小数时用去尾法，39/10=3.9，去尾得3，p=3</div><div class="line">set /a p=39/10</div><div class="line"></div><div class="line"></div><div class="line">#用 /a 参数时，在 = 后面的变量可以不加%直接引用</div><div class="line">set /a p=p/10</div><div class="line"></div><div class="line"></div><div class="line">#”与”运算，要加引号。其它支持的运算符参见set/?</div><div class="line">set /a p=”1&amp;0″</div><div class="line"></div><div class="line"></div><div class="line">#取消p变量</div><div class="line">set p=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">set /p p=请输入</div></pre></td></tr></table></figure><p><br></p><h3 id="一些动态变量"><a href="#一些动态变量" class="headerlink" title="一些动态变量"></a>一些动态变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#系统盘符</div><div class="line">%SystemDrive%</div><div class="line"></div><div class="line"></div><div class="line">#代表当前目录的字符串</div><div class="line">%CD%</div><div class="line"></div><div class="line">#当前日期</div><div class="line">%DATE%</div><div class="line"></div><div class="line"></div><div class="line">#当前时间</div><div class="line">%TIME%</div><div class="line"></div><div class="line"></div><div class="line">#随机整数，介于0~32767</div><div class="line">%RANDOM%</div><div class="line"></div><div class="line"></div><div class="line">#当前ERRORLEVEL值</div><div class="line">%ERRORLEVEL%</div><div class="line"></div><div class="line"></div><div class="line">#当前命令处理器扩展名版本号</div><div class="line">%CMDEXTVERSION%</div><div class="line"></div><div class="line"></div><div class="line">#调用命令处理器的原始命令行</div><div class="line">%CMDCMDLINE%</div></pre></td></tr></table></figure><h3 id="其它命令-1"><a href="#其它命令-1" class="headerlink" title="其它命令"></a>其它命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#批处理中调用外部程序的命令，否则等外部程序完成后才继续执行剩下的指令</div><div class="line">start</div><div class="line"></div><div class="line"></div><div class="line">#批处理中调用另一个批处理的命令，否则剩下的批处理指令将不会被执行</div><div class="line">call</div><div class="line"></div><div class="line"></div><div class="line">#让用户输入一个字符，从而选择运行不同的命令，返回码errorlevel为1234...</div><div class="line">choice</div></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="Windows排错"><a href="#Windows排错" class="headerlink" title="Windows排错"></a>Windows排错</h1><p>一些常见的Windows错误及其解决办法。</p><p><br></p><h2 id="Windows无法识别键鼠"><a href="#Windows无法识别键鼠" class="headerlink" title="Windows无法识别键鼠"></a>Windows无法识别键鼠</h2><p>Windows在更新或安装了其他软件之后，导致开机后无法识别键鼠。</p><p>此时则需要先使用PS2鼠标和虚拟键盘进入系统后，重新安装驱动程序。<br>如果安装驱动程序报错——“windows已找到设备的驱动程序软件,但在试图安装它时遇到错误”。这需要进入设备管理器，选择此驱动–&gt;更新驱动程序–浏览我的计算机以查找驱动程序–&gt;位置为：C:\Windows\winsxs–&gt;安装驱动–&gt;之后键鼠就能正常使用了，重启也没有问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Windows" scheme="https://zhang21.github.io/categories/Windows/"/>
    
    
      <category term="Windows" scheme="https://zhang21.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://zhang21.github.io/2018/02/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://zhang21.github.io/2018/02/08/正则表达式/</id>
    <published>2018-02-08T03:33:16.000Z</published>
    <updated>2018-02-24T10:43:37.352Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>《鸟哥的Linux私房菜》</li><li><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">正则表达式维基百科</a></li></ul><p><br><br><br></p><a id="more"></a><p><br></p><h1 id="正则表达式介绍"><a href="#正则表达式介绍" class="headerlink" title="正则表达式介绍"></a>正则表达式介绍</h1><p>正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法(Regular Expression, 在代码中常简写为regex、regexp或RE）。<br>是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p><p><br></p><p>正则表达式的POSIX规范，分为两大流派：</p><ul><li>基本型正则表达式（Basic Regular Expression，BRE）<ul><li><code>grep</code>、<code>vi</code>、<code>sed</code>都属于BRE，是历史最早的正则表达式，因此元字符必须转译之后才具有特殊含义</li></ul></li><li>扩展型正则表达式（Extended Regular Express，ERE）<ul><li><code>egrep</code>、<code>awk</code>则属于ERE，元字符不用转译</li></ul></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="正则表达式基本语法"><a href="#正则表达式基本语法" class="headerlink" title="正则表达式基本语法"></a>正则表达式基本语法</h1><p>一个正则表达式通常被称为一个模式（pattern），用来描述或者匹配一系列匹配某个句法规则的字符串。</p><p><br></p><p>大部分正则表达式有如下结构：</p><ul><li><strong>选择</strong><ul><li><code>|</code>竖线符代表选择(或)，具有最低优先级</li></ul></li><li><strong>数量限定</strong><ul><li>字符后的数量限定符用来限定前面这个字符允许出现的个数</li><li>不加数量限定则代表仅出现一次</li><li>常见的数量限定符包括 <strong>+</strong>、<strong>?</strong>、<strong>*</strong><ul><li><code>+</code>加号代表前面的字符必须至少出现一次 ( $$$&gt;=1$$$ )</li><li><code>?</code>问号代表前面的字符最多只可出现一次 ( $$$1&gt;=?&gt;=0$$$ )</li><li><code>*</code>星号代表前面的字符可不出现，也可出现一次或多次 ($$$&gt;=0$$$)</li></ul></li></ul></li><li><strong>匹配</strong><ul><li><code>()</code>圆括号可以定义操作符的范围和优先度</li></ul></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="PCRE表达式全集"><a href="#PCRE表达式全集" class="headerlink" title="PCRE表达式全集"></a>PCRE表达式全集</h1><p>正则表达式有多种不同的风格。<br>PCRE（Perl兼容正则表达式，Perl Compatible Regular Expression）。适用于Perl或者Python编程语言（grep或者egrep的正则表达式文法是PCRE的子集）</p><p><br></p><p><strong>基础正则表达式</strong></p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>转义字符</td></tr><tr><td>zhang</td><td>匹配文本字符串值<code>zhang</code></td></tr><tr><td>.</td><td>匹配除<code>\r</code>,<code>\n</code>之外的任何单个字符</td></tr><tr><td>竖线l</td><td>匹配竖线两边某一个</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次</td></tr><tr><td>{n}</td><td>n是一个非负整数。匹配n次</td></tr><tr><td>{n,}</td><td>n是一个非负整数。至少匹配n次</td></tr><tr><td>{n,m}</td><td>m和n均为非负整数，匹配n-m次</td></tr><tr><td>[xyz]</td><td>字符集合（character class）。匹配所包含的任意一个字符</td></tr><tr><td>[^xyz]</td><td>排除型字符集合（negated character classes）。匹配未列出的任意字符</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符</td></tr><tr><td>[^a-z]</td><td>排除型的字符范围。匹配任何不在指定范围内的任意字符</td></tr><tr><td>[:name:]</td><td>增加命名字符类（named character class）</td></tr><tr><td>[=elt=]</td><td>增加当前locale下排序（collate）等价于字符“elt”的元素</td></tr><tr><td>[.elt.]</td><td>增加排序元素（collation element）elt到表达式中。这是因为某些排序元素由多个字符组成</td></tr></tbody></table><p><br></p><p><strong>元字符</strong><br>元字符(meta character)，是一种Perl风格的正则表达式，只有一部分文本处理工具支持它。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置</td></tr><tr><td>\B</td><td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”</td></tr><tr><td>\cx</td><td>匹配由x指明的控制字符</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于[0-9]。注意Unicode正则表达式会匹配全角数字字符</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于[^0-9]</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于\x0c和\cL</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于\x0a和\cJ</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于\x0d和\cM</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于[^ \f\n\r\t\v]</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于\x09和\cI</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于\x0b和\cK</td></tr><tr><td>\w</td><td>匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。注意Unicode正则表达式会匹配中文字符</td></tr><tr><td>\W</td><td>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”</td></tr><tr><td>\ck</td><td>匹配控制转义字符。k代表一个字符。等价于“Ctrl-k”。用于ECMA语法</td></tr><tr><td>\xnn</td><td>十六进制转义字符序列。匹配两个十六进制数字nn表示的字符</td></tr><tr><td>\num</td><td>向后引用（back-reference）一个子字符串（substring），该子字符串与正则表达式的第num个用括号围起来的捕捉群（capture group）子表达式（subexpression）匹配。其中num是从1开始的十进制正整数，其上限可能是9[注 2]、31、[注 3]99甚至无限。[注 4]例如：“(.)\1”匹配两个连续的相同字符</td></tr><tr><td>\n</td><td>标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值</td></tr><tr><td>\nm</td><td>3位八进制数字，标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm</td></tr><tr><td>\nml</td><td>如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml</td></tr><tr><td>\un</td><td>Unicode转义字符序列。其中n是一个用四个十六进制数字表示的Unicode字符</td></tr></tbody></table><p><br></p><p><strong>扩展正则表达式</strong></p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>?</td><td>非贪心量化（Non-greedy quantifiers）：当该字符紧跟在任何一个其他重复修饰符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串</td></tr><tr><td>(pattern)</td><td>匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”</td></tr><tr><td>(?:pattern)</td><td>匹配pattern但不获取匹配的子字符串（shy groups)，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用</td></tr><tr><td>(?=pattern)</td><td>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用</td></tr><tr><td>(?!pattern)</td><td>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用</td></tr><tr><td>(?&lt;=pattern)</td><td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反</td></tr><tr><td>(?&lt;!pattern)</td><td>反向否定预查，与正向否定预查类似，只是方向相反</td></tr></tbody></table><p><br><br><br></p><hr><p><br></p><h1 id="POSIX字符组"><a href="#POSIX字符组" class="headerlink" title="POSIX字符组"></a>POSIX字符组</h1><p>POSIX字符类(POSIX character class),是一个形如[:…:]的特殊元序列，它用于匹配特定的字符范围。</p><table><thead><tr><th>POSIX字符组</th><th>说明</th><th>ASCII环境</th><th>Unicode环境</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>字母字符和数字字符</td><td>[a-zA-Z0-9]</td><td>[\p{L&amp;}\p{Nd}]</td></tr><tr><td>[:alpha:]</td><td>字母</td><td>[a-zA-Z]</td><td>\p{L&amp;}</td></tr><tr><td>[:ascii:]</td><td>ASCII字符</td><td>[\x00-\x7F]</td><td>\p{InBasicLatin}</td></tr><tr><td>[:blank:]</td><td>空格字符和制表符</td><td>[ \t]</td><td>[\p{Zs}\t]</td></tr><tr><td>[:cntrl:]</td><td>控制字符</td><td>[\x00-\x1F\x7F]</td><td>\p{Cc}</td></tr><tr><td>[:digit:]</td><td>数字字符</td><td>[0-9]</td><td>\p{Nd}</td></tr><tr><td>[:graph:]</td><td>空白字符之外的字符</td><td>[\x21-\x7E]</td><td>[^\p{Z}\p{C}]</td></tr><tr><td>[:lower:]</td><td>小写字母字符</td><td>[a-z]</td><td>\p{Ll}</td></tr><tr><td>[:print:]</td><td>类似[:graph:]，但包括空白字符</td><td>[\x20-\x7E]</td><td>\P{C}</td></tr><tr><td>[:punct:]</td><td>标点符号</td><td>}~-]</td><td>[\p{P}\p{S}]</td></tr><tr><td>[:space:]</td><td>空白字符</td><td>[ \t\r\n\v\f]</td><td>[\p{Z}\t\r\n\v\f]</td></tr><tr><td>[:upper:]</td><td>大写字母字符</td><td>[A-Z]</td><td>\p{Lu}</td></tr><tr><td>[:word:]</td><td>字母字符</td><td>[A-Za-z0-9_]</td><td>[\p{L}\p{N}\p{Pc}]</td></tr><tr><td>[:xdigit:]</td><td>十六进制字符</td><td>[A-Fa-f0-9]</td><td>[A-Fa-f0-9]</td></tr></tbody></table><p><br><br><br></p><hr><p><br></p><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><table><thead><tr><th>优先权</th><th>符号</th></tr></thead><tbody><tr><td>最高</td><td>\</td></tr><tr><td>高</td><td>( )、(?: )、(?= )、[ ]</td></tr><tr><td>中</td><td>*、+、?、{n}、{n,}、{m,n}</td></tr><tr><td>低</td><td>^、$、中介字符</td></tr><tr><td>次最低</td><td>串接，即相邻字符连接在一起</td></tr><tr><td>最低</td><td>l</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《鸟哥的Linux私房菜》&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;正则表达式维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="RegularExpression" scheme="https://zhang21.github.io/tags/RegularExpression/"/>
    
      <category term="正则表达式" scheme="https://zhang21.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://zhang21.github.io/2018/02/05/Redis/"/>
    <id>https://zhang21.github.io/2018/02/05/Redis/</id>
    <published>2018-02-05T09:20:28.000Z</published>
    <updated>2018-02-25T13:25:59.216Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>《Redis官方文档》: <a href="http://www.redis.cn/documentation.html" target="_blank" rel="noopener">http://www.redis.cn/documentation.html</a></li><li>《Redis命令大全》: <a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">http://www.redis.cn/commands.html</a></li></ul><p><br></p><p>环境:</p><ul><li>CentOS7x86_64</li><li>Redis 3.2</li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p><br></p><h2 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h2><p>Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的、非关系型,键值对存储数据库。<br>Redis是一个开源(BSD许可)的,内存中的数据结构存储系统,它可以用作数据库、缓存和消息中间件。</p><p>毫无疑问,Redis开创了一种新的数据存储思路,使用Redis,我们不用在面对功能单调的数据库时,把精力放在如何把大象放进冰箱这样的问题上,而是利用Redis灵活多变的数据结构和数据操作,为不同的大象构建不同的冰箱。希望你喜欢这个比喻。</p><p>Remote Dictionary Server(Redis)是由一个Salvatore Sanfilippo写的key-value储存系统。Redis提供了一些丰富的数据结构,包括lists,sets,ordered sets,hashes,当然还有和Memcached一样的string结构,所以常被称为是一款数据结构服务器(data structure server)。Redis当然还包括了对这些数据结构的丰富操作。</p><p>你可以在这些类型上面运行原子操作,例如,追加字符串,增加哈希中的值,加入一个元素到列表,计算集合的交集、并集和差集,或者是从有序集合中获取最高排名的元素。</p><p><br><br><br></p><h2 id="Redis的优点"><a href="#Redis的优点" class="headerlink" title="Redis的优点"></a>Redis的优点</h2><p>为了满足性能,Redis采用内存(in-memory)数据集(dataset)。根据你的使用场景,你可以通过每隔一段时间转储数据集到磁盘,或者追加每条命令到日志来持久化。持久化也可以被禁用,如果你只是需要一个功能丰富,网络化的内存缓存。</p><ul><li>性能极高,Redis能支持超过100K+每秒的读写频率</li><li>丰富的数据类型,Redis支持二进制案例的Strings,Lists,Hashes,Sets及Ordered Sets数据类型操作</li><li>原子,Redis的所有操作都是原子性的,同时Redis还支持对几个操作全并后的原子性执行</li><li>丰富的特性,Redis还支持publish/sucscribe,通知,key过期等特性</li><li>Redis还支持主从异步复制,非常快的非阻塞初次同步、网络断开时自动重连局部重同步</li></ul><p><br></p><hr><p><br></p><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><p>直接通过<code>yum</code>安装:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y redis</div></pre></td></tr></table></figure><p><br></p><p>启动redis-server的两种方式:</p><ul><li>redis-server: standalone模式</li><li>systemctl redis start: daemon模式<ul><li>需要在配置文件中开启daemonize</li></ul></li></ul><p>启动redis-cli:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis-cli</div><div class="line">redis-cli -a passwd</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h1><p>redis配置文件(/etc/redis.conf)常用参数:</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>daemonize</td><td>以守护进程启动,放置于后台</td></tr><tr><td>bind</td><td>监听地址,建议只对本地127.0.0.1开放</td></tr><tr><td>protect-mode</td><td>redis的保护模式</td></tr><tr><td>requirepass</td><td>设置密码</td></tr><tr><td>timeout</td><td>超时</td></tr><tr><td>tcp-keepalive</td><td>在Linux上,指定值(秒)用于发送ACKs的时间,关闭连接需要双倍的时间,默认为0</td></tr><tr><td>loglevle</td><td>指定日志记录的级别。有四个级别:debug(记录很多信息,用于开发测试)、notice(常用于生产环境)、warning(严重的信息)、verbose(有用的信息)</td></tr><tr><td>logfile</td><td>日志文件,默认为stdout</td></tr><tr><td>databases</td><td>可用数据库,范围在0-(database-1)</td></tr><tr><td>save</td><td>保存数据到磁盘(.rdb)</td></tr><tr><td>stop-writes-on-bgsave-error</td><td>后台储存错误停止写</td></tr><tr><td>rdbcompression</td><td>储存到本地数据库时(持久化到rdb文件)是否压缩</td></tr><tr><td>dbfilename</td><td>本地持久化数据库文件名,默认dump.rdb</td></tr><tr><td>dir</td><td>数据库文件路径,是目录</td></tr><tr><td>salveof</td><td>设置从库</td></tr><tr><td>masterauth</td><td>设置主库认证的密码</td></tr><tr><td>slave-read-only</td><td>设置slave是否只读</td></tr><tr><td>slave-serve-stale-data</td><td>从库同主库失去连接或复制正在进行时,从库是否继续响应客户端请求</td></tr><tr><td>repl-disable-tcp-nodelay</td><td>tcp-nodelay</td></tr><tr><td>slave-priority</td><td>slave优先级,master不能工作后,从众多slave中选出优先值最小的slave提升为master,优先值为0表示不能为master</td></tr><tr><td>appendonly</td><td>是否开启AOF数据备份,redis会把所接收到的每一次写操作请求都追加到appendonly.aof文件,当此文件很大</td></tr><tr><td>appendsync</td><td>AOF文件同步策略,后台会进行大量I/O</td></tr><tr><td>no-appendfsync-on-rewrite</td><td>-</td></tr><tr><td>auto-aof-rewrite-percentage</td><td>aof自动重写</td></tr><tr><td>auto-aof-rewrite-min-size</td><td>指定最小大小用于aof重写</td></tr><tr><td>slowlog-log-slower-than</td><td>慢日志,记录超过特定执行时间的命令,不包括I/o</td></tr><tr><td>slowlog-max-len</td><td>慢日志记录的长度,超过大小,最先进入队列的记录会被踢出</td></tr><tr><td>hash-max-zipmap-entries</td><td>hash将以一种特殊的编码方式(大大减少内存使用)来储存,这是其中一个临界值</td></tr><tr><td>hash-max-zipmap-value</td><td>另一个临界值</td></tr><tr><td>list-max-ziplist-entries</td><td>多个list以特定的方式编码来节省空间</td></tr><tr><td>activerehashing</td><td>Redis将在每100ms时使用1ms的CPU时间来对redis的hash表进行重新hash,可降低内存的使用</td></tr><tr><td>hz</td><td>不是所有任务都以相同的频率执行,但redis按照指定的“hz”值执行检查任务</td></tr><tr><td>aof-rewrite-incremental-fsync</td><td>当一个子节点重写AOF文件时,则文件每生产32m数据进行同步</td></tr></tbody></table><p><br></p><p>官方文档对VM的使用建议:</p><ul><li>当KEY很小而VALUE很大时,使用VM的效果会比较好,因为这样节约内存比较大</li><li>当key不小时,可以考虑使用一些非常方法将很大的key变成value,比如将key,value组合成一个新的value</li></ul><p><br></p><hr><p><br></p><h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><p>Redis不仅仅是简单的key-value存储器,同时也是一种data structure server。传统的key-value是指支持使用一个key字符串来索引value字符串的储存。而Redis中,value不仅仅支持字符串,还支持更多的复杂结构,包括列表、集合、哈希表等。Redis采用二进制安全,这就意味着你可以使用任何二进制序列作为重点。</p><p><br></p><h2 id="字符串-strings"><a href="#字符串-strings" class="headerlink" title="字符串(strings)"></a>字符串(strings)</h2><p>字符串 是一种最基本的Redis值类型。Redis字符串是二进制安全的,这意味着一个Redis字符串能包含任意类型的数据。</p><p>只关心二进制化的字符串,不关心具体格式。只会严格的按照二进制的数据存取。不会妄图已某种特殊格式解析数据。</p><p><br></p><h2 id="列表-lists"><a href="#列表-lists" class="headerlink" title="列表(lists)"></a>列表(lists)</h2><p>Redis列表是简单的字符串列表,按照插入顺序序列,你可以添加一个或多个元素到列表的头部或者尾部。</p><p><br></p><h2 id="散列-hash"><a href="#散列-hash" class="headerlink" title="散列(hash)"></a>散列(hash)</h2><p>Redis Hashes是字符串字段和字符串值之间的映射,因此他们是展现对象的完美数据类型。如一个有姓、名、年龄等属性的用户。一个带有一些字段的hash仅仅需要一块很小的空间储存,因此你可以储存数以百万计的对象在一个小的Redis实例中。</p><p>哈希主要用来表现对象,他们有能力储存很多对象,因此你可以将哈希用于许多其他的任务。</p><p><br></p><h2 id="无序集合-unorder-set"><a href="#无序集合-unorder-set" class="headerlink" title="无序集合(unorder set)"></a>无序集合(unorder set)</h2><p>Redis集合(Set)是一个无序的字符串集合。可以用O(1)的时间复杂度(无论集合中有多少元素时间复杂度都是常量)完成添加、删除、测试元素是否存在。</p><p>Redis集合拥有令人满意的不允许包含相同成员的属性。多次添加相同的元素,最终在集合里只会有一个元素。实际上就是添加元素时无序检测元素是否存在。</p><p>一个Redis集合有趣的事情是它支持一些服务端的命令从现有的集合出发去进行集合运算,因此你可以在非常短的时间内进行合并(unions)、交集(intersections)、找出不同的元素(difference of sets)。</p><p><br></p><h2 id="有序集合-order-set"><a href="#有序集合-order-set" class="headerlink" title="有序集合(order set)"></a>有序集合(order set)</h2><p>Redis有序集合与普通集合非常相似,也是一个没有重复项的字符串集合。不同之处是有序集合的每一个成员都关联了一个评分,这个评分被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的,但是评分可以是重复了。</p><p>使用有序集合可以以非常快的速度(O(log(N)))添加,删除和更新元素。可以很快根据评分(score)或者次序(position)来获取一个范围的元素。访问有序集合的中间元素也是很快的,因此能够使用有序集合作为一个没有重复成员的智能列表。在有序集合中,你可以很快捷的访问一切你需要的东西。</p><p>简而言之,使用有序的集合你可以做完许多对性能有极端要求的任务,而那些任务使用其他类型的数据库真的是很难完成。</p><p><br></p><hr><p><br></p><h1 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h1><p><br></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">exists key    <span class="comment">#判断一个key是否存在</span></div><div class="line"></div><div class="line">del key    <span class="comment">#删除某个或一系列key</span></div><div class="line"></div><div class="line"><span class="built_in">type</span> key    <span class="comment">#返回某个key元素的数据类型,key不存在返回空</span></div><div class="line"></div><div class="line">keys key-pattern    <span class="comment">#返回匹配的key列表</span></div><div class="line"></div><div class="line">randomkey    <span class="comment">#随机获取一个已经存在的key</span></div><div class="line"></div><div class="line">rename oldname newname<span class="comment">#改key的名字,如果存在将会覆盖</span></div><div class="line"></div><div class="line">dbsize    <span class="comment">#返回当前数据库的key的总和</span></div><div class="line"></div><div class="line">expire key time   <span class="comment">#设置某个key的过期时间(秒),到期后自动删除</span></div><div class="line"></div><div class="line">ttl    <span class="comment">#查询key剩余存活时间</span></div><div class="line"></div><div class="line">flushdb    <span class="comment">#清空当前数据库中的所有键</span></div><div class="line"></div><div class="line">flushall    <span class="comment">#清空所有数据库中的键</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="设置相关"><a href="#设置相关" class="headerlink" title="设置相关"></a>设置相关</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">config get    <span class="comment">#用来读取Redis服务器的配置参数</span></div><div class="line"></div><div class="line">config <span class="built_in">set</span>    <span class="comment">#用于更改运行Redis服务器的配置参数</span></div><div class="line"></div><div class="line">config resetstat    <span class="comment">#重置数据统计报告,通常返回OK</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">quit<span class="comment">#关闭连接</span></div><div class="line"></div><div class="line">auth<span class="comment">#密码认证</span></div><div class="line"></div><div class="line"><span class="built_in">help</span> <span class="built_in">command</span><span class="comment">#帮助</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">save<span class="comment">#将数据同步保存到磁盘</span></div><div class="line"></div><div class="line"></div><div class="line">bgsave<span class="comment">#将数据异步保存到磁盘</span></div><div class="line"></div><div class="line"></div><div class="line">lastsave<span class="comment">#返回上次成功将数据保存到磁盘的Unix时戳</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="远程服务"><a href="#远程服务" class="headerlink" title="远程服务"></a>远程服务</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">info<span class="comment">#服务器信息统计,基本所有信息</span></div><div class="line"></div><div class="line">monitor<span class="comment">#实时转储收到的请求</span></div><div class="line"></div><div class="line">slaveof<span class="comment">#改变复制策略</span></div><div class="line"></div><div class="line">shutdown<span class="comment">#将数据同步保存到磁盘,然后关闭服务</span></div><div class="line"></div><div class="line">server<span class="comment">#Redis server的常规信息</span></div><div class="line"></div><div class="line">clients<span class="comment">#Client的连接选项</span></div><div class="line"></div><div class="line">memory<span class="comment">#存储占用相关信息</span></div><div class="line"></div><div class="line">persistence<span class="comment">#RDB and AOF 相关信息</span></div><div class="line"></div><div class="line">stats<span class="comment">#常规统计</span></div><div class="line"></div><div class="line">replication<span class="comment">#Master/slave请求信息</span></div><div class="line"></div><div class="line">cpu<span class="comment">#CPU占用信息统计</span></div><div class="line"></div><div class="line">cluster<span class="comment">#Redis 集群信息</span></div><div class="line"></div><div class="line">keyspace<span class="comment">#数据库信息统计</span></div><div class="line"></div><div class="line">all<span class="comment">#返回所有信息</span></div><div class="line"></div><div class="line">default<span class="comment">#返回常规设置信息</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="值-value-操作"><a href="#值-value-操作" class="headerlink" title="值(value)操作"></a>值(value)操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">exists key<span class="comment">#判断一个key是否存在</span></div><div class="line"></div><div class="line">del key<span class="comment">#删除一个key</span></div><div class="line"></div><div class="line"><span class="built_in">type</span> key<span class="comment">#返回值的类型</span></div><div class="line"></div><div class="line">keys pattern<span class="comment">#返回满足给定模式的所有key</span></div><div class="line"></div><div class="line">randomkey<span class="comment">#随机返回key空间的一个</span></div><div class="line"></div><div class="line">rename oldname newname<span class="comment">#改key的名字,如果存在将会覆盖</span></div><div class="line"></div><div class="line">dbsize<span class="comment">#返回当前数据库中key的数目</span></div><div class="line"></div><div class="line">expire<span class="comment">#设定一个key的活动时间(s)</span></div><div class="line"></div><div class="line">ttl<span class="comment">#获得一个key的活动时间</span></div><div class="line"></div><div class="line">select index<span class="comment">#按索引查询</span></div><div class="line"></div><div class="line">move key dbindex<span class="comment">#移动当前数据库中的key到dbindex数据库</span></div><div class="line"></div><div class="line">flushdb<span class="comment">#删除当前选择的数据库中的所有key</span></div><div class="line"></div><div class="line">flushall<span class="comment">#删除所有数据库中的所有key</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="字符串-string-操作"><a href="#字符串-string-操作" class="headerlink" title="字符串(string)操作"></a>字符串(string)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">set key value           #给数据库中名称为key的string赋值value</div><div class="line"></div><div class="line">get key                         #返回数据库中名为key的string的value</div><div class="line"></div><div class="line">getset key value                #给名称为key的string赋予上一次的value</div><div class="line"></div><div class="line">mget key1 key2 ... key N                #返回库中多个string的value</div><div class="line"></div><div class="line">setnx key value         #添加string 名称为key 值为value</div><div class="line"></div><div class="line">setex key time value            #向库中添加string 设定过期时间time</div><div class="line"></div><div class="line">mset key 1 value 1 ... key N value N            #批量设置多个string的值</div><div class="line"></div><div class="line">msetnx key 1 value 1 ... key N value N          #如果所有名称为 key N的string都不存在 则向库中添加string 名称为 key N赋值value N</div><div class="line"></div><div class="line">incr key                #名称为key的string加 1 操作</div><div class="line"></div><div class="line">incrby key integer              #名称为key的string增减integer</div><div class="line"></div><div class="line">decr key                #名称为key的string减1操作</div><div class="line"></div><div class="line">decrby key integer              #名称为key的string的值附加value</div><div class="line"></div><div class="line">append key value                #名称为key的值附加value</div><div class="line"></div><div class="line">substr key start end            #返回名称为key的string的value的子串</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="列表-list-操作"><a href="#列表-list-操作" class="headerlink" title="列表(list)操作"></a>列表(list)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">rpush key value                 #在名称为key的list尾部添加一个值为value的元素</div><div class="line"></div><div class="line">lpush key value                 #在名称为key的list首部添加一个值为value的元素</div><div class="line"></div><div class="line">llen key                #返回名称为key的list的长度</div><div class="line"></div><div class="line">lrange key start end            #返回名称为key的list中start至end之间的元素 下表从0开始</div><div class="line"></div><div class="line">ltrim key start end             #截取名称为key的list 保留start至end之间的元素</div><div class="line"></div><div class="line">lindex key index                #返回名称为key的list中index位置的元素</div><div class="line"></div><div class="line">lset key index value            #给名称为key的list中index位置的元素赋值value</div><div class="line"></div><div class="line">lrem key count value            #删除count个名称为key的list中值为value的元素</div><div class="line"></div><div class="line">brpop key1 key2 ... keyN               #rpop的block版本</div><div class="line"></div><div class="line">rpoplpush srckey dstkey                 #返回并删除名为srckey的list尾元素 并将该元素添加到名为dstkey的list的头部</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="集合-set-操作"><a href="#集合-set-操作" class="headerlink" title="集合(set)操作"></a>集合(set)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">sadd key member                 #向名为key的set中添加元素member</div><div class="line"></div><div class="line">srem key member                 #删除名为key的set中元素的member</div><div class="line"></div><div class="line">spop key                #随机返回并删除名为key的set中的一个元素</div><div class="line"></div><div class="line">smove srckey dstkey member              #将member元素从名为srckey的集合移动到名为dstkey的集合</div><div class="line"></div><div class="line">scard key               #返回名为key的set的基数</div><div class="line"></div><div class="line">sismember key member            #测试member是否是名称为key的set的集合</div><div class="line"></div><div class="line">sinter key1 key2 ... key N              #求交集</div><div class="line"></div><div class="line">sinterstore dstkey key1 ... key N               #求交集并将交集保存到dstkey的集合</div><div class="line"></div><div class="line">sunion key1 ... key N           #求并集</div><div class="line"></div><div class="line">sunionstore dstkey key 1 ... key N              #求并集并将并集保存到dstkey的集合</div><div class="line"></div><div class="line">sdiff key1 ... key N            #求差集</div><div class="line"></div><div class="line">sdiffstore dstkey key 1 ... key N               #求差集并将差集保存到dstkey的集合</div><div class="line"></div><div class="line">smembers key            #返回名为key的set的所有元素</div><div class="line"></div><div class="line">srandmember key                 #随机返回名为key的set的一个元素</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="有序集合-sorted-set-操作"><a href="#有序集合-sorted-set-操作" class="headerlink" title="有序集合(sorted set)操作"></a>有序集合(sorted set)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">zadd key score member           #向名为key的zset中添加元素member score用于排序 如果该元素已经存在 则根据</div><div class="line">score更新该元素的顺序</div><div class="line"></div><div class="line">zrem key member                 #删除名为key的zset中的元素member</div><div class="line"></div><div class="line">zincrby key increment member            #如果在名为key的zset中已经存在元素member 则该元素的score增加increment 否则向集合中添加该元素 其score的值为increment</div><div class="line"></div><div class="line">zrank key member                #返回名为key的zset 顺序</div><div class="line"></div><div class="line">zrevrank key member             #返回名为key的zset 倒序</div><div class="line"></div><div class="line">zrange key start end            #返回名为key的zset score顺序按index从start到end返回所有元素</div><div class="line"></div><div class="line">zrevrange key start end                 #返回名为key的zset score倒序按index从start到end返回所有元素</div><div class="line"></div><div class="line">zrangebyscore key min max               #返回名为key的zset中score大于等于min 小于等于max的所有元</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="hash操作"><a href="#hash操作" class="headerlink" title="hash操作"></a>hash操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">hset key field value            #向名为key的hash中添加元素filed----value</div><div class="line"></div><div class="line">hget key field          #返回名为key的hash中field对应的value</div><div class="line"></div><div class="line">hmset key field1 value1 ... field N value N             #向名为key的hash中添加元素field----value</div><div class="line"></div><div class="line">hmget key field1 ... field N            #返回名为key的hash中filed对应的value</div><div class="line"></div><div class="line">hincrby key field integer               #将名为key的hash中field的value增加integer</div><div class="line"></div><div class="line">hexists key field               #名为key的hash中是否存在键为field的域</div><div class="line"></div><div class="line">hdel key field          #删除名为key的hash中键为field的域</div><div class="line"></div><div class="line">hlen key                #返回名为key的hash中元素个数</div><div class="line"></div><div class="line">hkeys key               #返回名为key的hash中所有键</div><div class="line"></div><div class="line">hvals key               #返回名为key的hash中所有键对应的value</div><div class="line"></div><div class="line">hgetall key     #返回名为key的hash中所有的键 field 及其对应的value</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="Redis高级应用"><a href="#Redis高级应用" class="headerlink" title="Redis高级应用"></a>Redis高级应用</h1><p>Redis高级应用包括<strong>安全性设置、主从复制、事务处理、持久化机制和虚拟内存的使用</strong>。</p><p><br><br><br></p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>由于redis速度相当快，一秒钟可以150K次密码尝试，所以需要设置一个密码强度很强大的密码。</p><p>设置密码的两种方法：</p><ul><li><code>config set requirepass &quot;passwd&quot;</code>，通过命令设置密码</li><li>直接在配置文件中<code>requirepass</code>属性后加上密码</li></ul><p>认证登录的两种方式：</p><ul><li><code>redis-cli -a passwd</code></li><li><code>redi-cli</code> –&gt; <code>auth passwd</code></li></ul><p><br><br><br></p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>Redis的主从复制的配置和使用都比较简单。</p><ul><li>master server</li><li>slave server</li></ul><p>Redis主从复制特点：</p><ul><li>一主多从</li><li>当master宕机后，优先级值小的那台slave server自动转变为master</li><li>主从复制不同阻塞master，在同步数据时master可以继续处理client的请求</li><li>提高了系统的可伸缩性</li></ul><p>Redis主从复制过程：</p><ul><li>slave与master建立连接，发送sync同步命令</li><li>master会启动一个后台进程，将数据库快照保存到文件中，同时master主进程会开始收集新的写命令并缓存</li><li>后台完成保存后，就将此文件发送给slave</li><li>slave将文件保存在磁盘上</li></ul><p><br></p><h3 id="主从复制栗子"><a href="#主从复制栗子" class="headerlink" title="主从复制栗子"></a>主从复制栗子</h3><p>Redis主从配置，一主多从。<br>注意：由于redis吃内存，可能会由于内存过小而无法正常启动redis，可查看<code>/var/log/message</code>。</p><p><br></p><p><strong>配置master</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">vim /etc/redis_master.conf</div><div class="line"></div><div class="line"></div><div class="line">daemon yes</div><div class="line">bind 127.0.0.1 ip1</div><div class="line">port 6379</div><div class="line">requirepass fuza_mima</div><div class="line">protect-mode yes</div><div class="line">datebases 100</div><div class="line">logfile /var/log/redis/redis_master.log</div><div class="line">dir /var/lib/redis_master</div><div class="line"></div><div class="line"></div><div class="line">mkdir /var/lib/redis_master</div><div class="line">chown redis:redis /var/lib/redis_master</div><div class="line"></div><div class="line"></div><div class="line">systemctl start redis</div></pre></td></tr></table></figure><p><strong>配置slave</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">vim /etc/redis_slave.conf</div><div class="line"></div><div class="line"></div><div class="line">daemon yes</div><div class="line">bind 127.0.0.1</div><div class="line">port 6379</div><div class="line">protect-mode yes</div><div class="line">logfile /var/log/redis/redis_slave.log</div><div class="line">dir /var/lib/redis_slave</div><div class="line"></div><div class="line"></div><div class="line">slaveof &lt;master-ip&gt; &lt;master-port&gt;</div><div class="line">masterauth &lt;master-passwd&gt;</div><div class="line">slave-read-only yes</div><div class="line">slave-priority 100</div><div class="line"></div><div class="line">#master挂掉后，从slave中选出优先级最小的作为master</div><div class="line"></div><div class="line">······</div><div class="line">#其他具体主从参数自己配置</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">mkdir /var/lib/redis_slave</div><div class="line">chown redis:redis /var/lib/redis_slave</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">systemctl start redis</div></pre></td></tr></table></figure><p><br></p><p><strong>测试master</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis-cli -a xxx</div><div class="line"></div><div class="line">set name zhang</div><div class="line">get zhang</div></pre></td></tr></table></figure><p><strong>测试slave</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis-cli</div><div class="line">auth(&apos;passwd&apos;)</div><div class="line"></div><div class="line"></div><div class="line">key *</div><div class="line">get zhang</div></pre></td></tr></table></figure><p><br></p><p><strong>注意</strong>：</p><p>由于Redis只是主从，并不像MongoDB的集群功能。当Redis master挂掉以后，虽然优先级较小的slave成为了master，但从库是无法更新数据的。这点也可以从Redis从的配置文件中看出，连接到Redis主的IP：PORT，并通过主的密码来认证。</p><p><br><br><br></p><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>Redis的事务处理比较简单。只能保证client发起的事务中的命令可以连续的执行，而且不会插入其他的client命令。</p><p>当一个client在连接中发出multi命令时，这个连接就进入一个事务的上下文，该连接后续的命令不会执行，而是存放在一个队列中，当执行exec命令时，redis会顺序的执行队列中的所有命令。如果其中执行出现错误，执行正确的不会回滚，不同于关系型数据库的事务。</p><p><br><br><br></p><h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>持久化就是把数据从内存保存到硬盘。</p><p>Redis是一个支持持久化的内存数据库，Redis需要经常将内存中的数据同步到磁盘来保证持久化。</p><p>Redis支持两种持久化方式：</p><ol><li>snapshotting(快照)<ul><li>将数据存放到文件里，默认方式。默认写入dump.rdb二进制文件中</li><li>可配置redis在n秒内超过m个key被修改就自动做快照</li><li>save 500 10 –&gt; 500s内超过10个key被修改，则保存快照</li></ul></li></ol><p>由于快照方式在一定间隔时间做一次保存， 如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。<br>AOF比快照方式有更好的持久化性，是由于使用aof时，redis会将每一个收到的写命令都通过write函数写入到文件中当redis启动时会通过重新执行文件中保存的写命令在内存中重新建立整个数据库的内容。</p><ol><li>appendonly file(AOF)<ul><li>aof方式redis会将每一次的函数都追加到文件中，当redis重启时会重新执行文件中保存的命令</li></ul></li></ol><p><br></p><p>配置文件参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#启用aof持久化方式</span></div><div class="line">appendonly yes</div><div class="line"></div><div class="line"><span class="comment">#每秒写入磁盘一次，在性能和持久化方面做了很好的折中</span></div><div class="line">appendonly everysc</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#将数据写入磁盘</span></div><div class="line">save 900 1</div><div class="line">save 300 10</div><div class="line">save 60 10000</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>Redis的虚拟内存是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出内存空间用于其它的访问数据。<br>对于redis这样的内存数据库，内存总是不够用的。</p><p>在配置文件(/etc/redis.conf)中配置VM:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#开启vm功能</span></div><div class="line">vm-enableyes</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#交换出来的value保存的文件路径</span></div><div class="line">vm-swap-file    /tmp/redis.swap</div><div class="line"></div><div class="line"><span class="comment">#redis使用的最大内存上线</span></div><div class="line">vm-max-memory 10000000</div><div class="line"></div><div class="line"><span class="comment">#每个页面的大小32字节</span></div><div class="line">vm-page-size 32</div><div class="line"></div><div class="line"><span class="comment">#最多使用多少个页面</span></div><div class="line">vm-pages 123217729</div><div class="line"></div><div class="line"><span class="comment">#用于执行value对象换入的工作线程数量</span></div><div class="line">vm-max-threads 4</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>Redis监听地址<code>bind： x.x.x.x</code>，强烈建议只对本地<code>127.0.0.1</code>开放。不建议对外网开放，有安全隐患</li><li>防火墙，最简单就是关闭防火墙，另一个就是开放redis的监听端口</li><li>开启守护进程，让redis可以在后台运行而不必通过<code>redis-server</code>的方式来启动，将配置文件里的<code>deamonize no</code>改为<code>yes</code></li><li>关闭redis的保护模式(protect-mode)，这里的保护模式是指是否允许其他IP的设备访问redis。如果开启的话就只能允许本机访问。如果是生产开发的实际运行环境，请一定开启保护模式</li><li>设置redis数据库密码！不仅仅是redis，任何数据库都应该设置密码，否则对外网开放的数据库就成了活靶子。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Redis官方文档》: &lt;a href=&quot;http://www.redis.cn/documentation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.redis.cn/documentation.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Redis命令大全》: &lt;a href=&quot;http://www.redis.cn/commands.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.redis.cn/commands.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7x86_64&lt;/li&gt;
&lt;li&gt;Redis 3.2&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="https://zhang21.github.io/categories/Database/"/>
    
    
      <category term="Redis" scheme="https://zhang21.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>计算机集群</title>
    <link href="https://zhang21.github.io/2018/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4/"/>
    <id>https://zhang21.github.io/2018/02/03/计算机集群/</id>
    <published>2018-02-03T05:56:45.000Z</published>
    <updated>2018-02-24T10:47:08.777Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>《老男孩Linux运维》</li><li>《服务器集群系统各概念》: <a href="https://segmentfault.com/a/1190000009923581" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009923581</a></li><li>《WEB的负载均衡、集群、高可用解决方案》： <a href="https://zhuanlan.zhihu.com/p/23826048" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23826048</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4" target="_blank" rel="noopener">计算机集群维基百科</a></li></ul><p><br></p><a id="more"></a><hr><p><br></p><h1 id="计算机集群"><a href="#计算机集群" class="headerlink" title="计算机集群"></a>计算机集群</h1><p>计算机集群简称<strong>集群</strong>(Clusters)，是一种计算机系统。它通过一组散列集成的软件或硬件 连接起来高度紧密地协作完成计算工作。在某种意义上，他们可以被看做是一台计算机。</p><p>集群就是指一组（若干）相互独立的计算机，利用高速通信网络组成的一个较大的计算机服务系统，每个集群结点都是运行各自服务的独立服务器。这些服务器之间可以彼此通信，协同向用户提供应用程序、系统资源和数据，并以单一系统的模式加以管理。</p><p>当客户机请求集群系统时，集群给用户的感觉就是一个单一独立的服务器，而实际上用户请求的是一组集群服务器。</p><p>集群系统中的单个计算机通常称为节点，通常通过内网连接，但也有其它的可能连接方式。集群计算机通常用来改进单个计算机的计算速度和可靠性。</p><p><br><br><br></p><h2 id="服务器集群概念"><a href="#服务器集群概念" class="headerlink" title="服务器集群概念"></a>服务器集群概念</h2><p>集群、冗余、负载均衡、主从复制、读写分离、分布式、分布式计算、分布式计算平台、并行计算……</p><p>实际生产环境中常有的问题：</p><ul><li>当数据库性能遇到问题时，是否能够横向扩展，通过添加服务器的方式达到更高的吞吐量，从而充分利用现有的硬件实现更好的投资回报率;</li><li>是否拥有实时同步的副本，当数据库面临灾难时，可以短时间内通过故障转移的方式保证数据库的可用性。此外，当数据丢失或损坏时，能否通过所谓的实时副本（热备）实现数据的零损失;</li><li>数据库的横向扩展是都对应用程序透明，如果数据库的横向扩展需要应用程序端进行大量修改，则所带来的后果不仅仅是高昂的开发成本，同时也会带来很多潜在和非潜在的风险.</li></ul><p><br></p><h3 id="集群和冗余"><a href="#集群和冗余" class="headerlink" title="集群和冗余"></a>集群和冗余</h3><p>集群和冗余并不对立，多台服务器做集群（不是主从），本身就有冗余和负载均衡的效果。<br>狭义上来说，集群就是把多台服务器虚拟成一台服务器，而冗余的每台服务器都是独立的。</p><ul><li>集群的侧重点在于协同，多台服务器系统分担工作，提升效率；</li><li>冗余的侧重点在于防止单点故障，一主多备的架构，也就是主从复制；</li></ul><blockquote><p>数据冗余==高可用性==主从</p></blockquote><ul><li>主从一定程度上起到了负载均衡的作用，但主要目的还是为了保证数据冗余和高可用性</li><li>主从只提供一种成本较低的数据备份方案加上不完美的灾难和负载均衡，由于复制存在时间差，不能同步读，所以只是不完善的负载均衡和有损灾备</li><li>主从显然达不到集群的严格度，不论是 HA 还是 AA（多活并行集群），主从都达不到数据一致性的集群要求</li></ul><p><br><br><br></p><h2 id="为什么要使用集群"><a href="#为什么要使用集群" class="headerlink" title="为什么要使用集群"></a>为什么要使用集群</h2><ul><li>高性能（Performance）<br>  大型网站谷歌、淘宝、百度等，都不是几台大型机可以构建的，都是上万台服务器组成的高性能集群，分布于不同的地点。<br>  只有当并发或总请求数量超过单台服务器的承受能力时，服务器集群的优势才会体现出来。</li><li>价格有效性（Cost-effectiveness）<br>  在达到同样性能的需求下，采用计算机集群架构比采用同等运算能力的大型计算机具有更高的性价比。</li><li>可伸缩性（Scalability）<br>  当服务负载、压力增长时，针对集群系统进行较简单的扩展即可满足需求，且不会降低服务质量。</li><li>高可用（Availability）<br>  单一计算机发生故障时，就无法正常提供服务；而集群架构技术可以是得系统在若干硬件设备发生故障时仍可以继续工作。<br>  集群系统在提高系统可靠性的同时，也大大减小了系统故障带来的业务损失，目前几乎100%的网站都要求7x24h提供服务。</li><li>透明性（Transparency）<br>  多个独立计算机组成的耦合集群系统构成一个虚拟服务器。用户访问集群系统时，就像访问一台高性能、高可用的服务器一样，集群中一部分服务器的上线、下线不会中断整个系统服务，这对用户也是透明的。</li><li>可管理性（Manageability）<br>  这个系统可能在物理上很大，但其实很容易管理，就像管理一个单一映像系统一样。</li><li>可编程性（Programmability）<br>  在集群系统上，容易开发及修改各类应用程序。</li></ul><p><br></p><hr><p><br></p><h1 id="集群分类"><a href="#集群分类" class="headerlink" title="集群分类"></a>集群分类</h1><p>集群分为同构和异构，他们区别在于 “组成集群系统的计算机之间的体系结构是否相同”。</p><p>集群计算机按功能和结构可以分为以下几类：</p><ul><li>均衡集群（Load balancing clusters）</li><li>用性集群（High-availability clusters）</li><li>能计算集群（High-performance cluster）</li><li>计算集群（Grid computing）</li></ul><blockquote><p>负载均衡集群（LB）和高可用性集群（HA）是互联网行业常用的集群架构模式</p></blockquote><p><br><br><br></p><h2 id="负载均衡集群"><a href="#负载均衡集群" class="headerlink" title="负载均衡集群"></a>负载均衡集群</h2><p><strong>负载均衡集群用于抗并发。</strong></p><blockquote><p>负载均衡集群典型的开源软件包括：LVS、Nginx、Haproxy 等。</p></blockquote><p><br></p><p>负载均衡集群可以把很多客户集中的访问请求负载压力尽可能平均分摊在计算机集群中处理。<br>集群中每个节点都可以一定的访问请求负载压力，并且可以实现访问请求在各节点之间动态分配，以实现负载均衡。<br>负载均衡集群运行时，一般是通过一个或多个前端负载均衡器（Director）将客户访问请求分发到后端的一组服务器上，从而达到整个系统的高性能和高可用性。<br>一般高可用性集群和负载均衡集群会使用类似的技术，或同时具有高可用性与负载均衡的特点。</p><p>Linux虚拟服务器（LVS）项目 在Linux操作系统上提供最常用的负载均衡软件。</p><p><br></p><p>负载均衡的作用：</p><ul><li>用户访问请求及数据流量（负载均衡）</li><li>业务连续性，即7x24h服务（高可用）</li><li>于Web业务及数据库从库等服务器的业务</li></ul><p><br><br><br></p><h2 id="高可用性集群"><a href="#高可用性集群" class="headerlink" title="高可用性集群"></a>高可用性集群</h2><p><strong>高可用性集群用于避免单点故障。</strong></p><blockquote><p>高可用性集群常用开源软件包括：Keepalived、Heartbeat 等。</p></blockquote><p><br></p><p>一般是指集群中任意一个节点失效的情况下，该节点上的所有任务会自动转移到其他正常的节点上。此过程不会影响整个集群的运行。</p><p>当集群中的一个节点系统发生故障时，运行着的集群服务器会迅速做出反应，将该系统的服务分配到集群中其他正在工作的系统上运行。考虑到计算机硬件和软件的容错性，高可用性集群的主要目的是使局群的整体服务尽可能可用。<br>如果高可用集群中的主节点发生了故障，那么这段时间内将由备节点代替它。备节点通常是主节点的镜像。当它代替主节点时，它可以完全接管主节点（包括Ip和其他资源）提供服务，因此，使集群系统环境对系统环境来说是一致的，既不会影响用户的访问。</p><p>高可用性集群使服务器系统的运行速度和响应速度会尽可能的快。它们经常利用在多台机器上运行的冗余节点和服务来相互跟踪。<br>如果某个节点失败，它的替补者将在几秒钟或更多时间内接管它的职责。因此，对于用户来说，集群里的任意一台机器宕机，业务都不会受影响。</p><p>高可用性集群的作用：</p><ul><li>当一台机器宕机后，另外一台机器接管宕机的机器的Ip资源和服务资源，提供服务；</li><li>常用于不易实现负载均衡的应用，如负载均衡器、主数据库、主存储对之间；</li></ul><p><br><br><br></p><h2 id="高性能计算集群"><a href="#高性能计算集群" class="headerlink" title="高性能计算集群"></a>高性能计算集群</h2><p>高性能计算集群也称并行计算。通常，高性能计算集群涉及为集群开发的并行应用程序，以解决复杂的科学问题。</p><p>高性能计算集群对外就好像一个超级计算机，这种超级计算机内部由数万个独立服务器组成，并且在公共消息传递层上进行通信以运行并行应用程序。</p><p><br><br><br></p><h2 id="高可用与负载均衡有什么区别"><a href="#高可用与负载均衡有什么区别" class="headerlink" title="高可用与负载均衡有什么区别"></a>高可用与负载均衡有什么区别</h2><ul><li>HA偏重于备用资源，切机时会有业务的断开的，保证了数据的安全，但造成资源的浪费；</li><li>LB侧重于资源的充分应用，没有主备的概念，只有资源的最大限度的加权平均应用，基本不会业务的中断；</li><li>HA的目的是不中断服务，LB的目的是为了提高接入能力。虽然经常放一起用，但确实是两个不同的领域；</li><li>HA在一条路不通的时候提供另一条路可走，而 LB 就类似于是春运时的多个窗口；</li></ul><p><br></p><hr><p><br></p><h1 id="集群软硬件"><a href="#集群软硬件" class="headerlink" title="集群软硬件"></a>集群软硬件</h1><p><br></p><p>企业运维中常见集群产品：</p><ul><li>开源集群软件：<pre><code>+ Nginx, LVS, Haproxy, Keepalived, Heartbear...</code></pre></li><li>商业集群硬件：<pre><code>+ F5， Netscaler,Radware, A10...</code></pre></li></ul><p>如何选择开源集群软件：</p><ul><li>网站在并发访问和总访问量不是很大的情况下，建议首选Nginx负载均衡，Nginx配置简单使用方便安全稳定。 另一个实现负载均衡的产品为Haproxy</li><li>如果要考虑Nginx负载均衡的高可用功能，建议首选Keepalived软件，因为安装配置简单方便稳定。类似高可用软件还有Heartbeat，但比较复杂</li><li>如果是大型企业，负载均衡可以使用 LVS+Keepalived 在前端做四层转发，后端使用Nginx或Haproxy做七层转发，再后面是应用服务器。如果是数据库与存储的负载均衡和高可用，可选用<code>LVS+Heartbeat</code></li></ul><p><img src="/images/Zabbix/cluster.png" alt=""></p><p><br></p><hr><p><br></p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>所谓负载均衡，就是把大访问量分发给不同的服务器，也就是分流请求。</p><p><br></p><h2 id="HTTP重定向协议实现负载均衡"><a href="#HTTP重定向协议实现负载均衡" class="headerlink" title="HTTP重定向协议实现负载均衡"></a>HTTP重定向协议实现负载均衡</h2><p>HTTP 重定向就是应用层的请求转发，用户的请求其实已经到了HTTP重定向负载均衡服务器，服务器根据算法要求用户重定向，用户收到重定向请求后，再次请求真正的集群.</p><ul><li>优点：简单</li><li>缺点：性能较差</li></ul><p><br><br><br></p><h2 id="DNS域名解析负载均衡"><a href="#DNS域名解析负载均衡" class="headerlink" title="DNS域名解析负载均衡"></a>DNS域名解析负载均衡</h2><p>DNS域名解析负载均衡就是在用户请求DNS服务器，获取域名对应的IP地址时，DNS服务器直接给出负载均衡后的服务器IP。</p><ul><li>优点：交给DNS，不用我们去维护负载均衡服务器</li><li>缺点：当一个应用服务器挂了，不能及时通知DNS，而且DNS负载均衡的控制权在域名服务商那里，网站无法做更多的改善和更强大的管理</li></ul><p><br><br><br></p><h2 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h2><p>在用户的请求到达方向代理服务器时（已到达网站机房），由于反向代理服务器根据算法转发到具体的服务器，常用的Apache，Nginx都可以充当反向代理服务器。</p><ul><li>优点：部署简单</li><li>缺点：代理服务器可能成为性能的瓶颈，特别是一次上传大文件</li></ul><p><br><br><br></p><h2 id="IP负载均衡-LVS-NAT"><a href="#IP负载均衡-LVS-NAT" class="headerlink" title="IP负载均衡(LVS-NAT)"></a>IP负载均衡(LVS-NAT)</h2><p>LVS集群中实现的三种IP负载均衡技术。</p><p><br></p><p>在请求到达负载均衡器后，负载均衡器通过修改请求的目的IP地址，从而实现请求的转发，做到负载均衡。</p><ul><li>优点：性能更好</li><li>缺点：负载均衡器的带宽称为瓶颈</li></ul><p><br><br><br></p><h2 id="直接路由负载均衡-LVS-DR"><a href="#直接路由负载均衡-LVS-DR" class="headerlink" title="直接路由负载均衡(LVS-DR)"></a>直接路由负载均衡(LVS-DR)</h2><p>数据链路层负载均衡，在请求到达负载均衡器后，负载均衡器通过修改请求的Mac地址，从而做到负载均衡，与IP负载均衡不一样的是，当请求访问完服务器之后，直接返回客户，而无需在经过负载均衡器。</p><p><br><br><br></p><h3 id="IP隧道负载均衡-LVS-TUN"><a href="#IP隧道负载均衡-LVS-TUN" class="headerlink" title="IP隧道负载均衡(LVS-TUN)"></a>IP隧道负载均衡(LVS-TUN)</h3><p><br></p><hr><p><br></p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主从是一种用于数据容错和灾备的高可用解决方案，而不是一种处理高并发压力的解决方案（负载均衡是用来抗并发的）。</p><blockquote><p>如MySQL主从复制，MongoDB主从复制(副本集)</p></blockquote><ul><li>主机负责查询，从机负责增删改</li><li>可以在从机上执行备份，以避免备份期间影响主机的服务</li><li>主从复制后，也可以在从机上查询，以降低主机的访问压力。但是，只有更新不频繁的数据或者对实时性要求不高的数据可以通过从服务器查询，实时性要求高的数据仍需在主服务器查询（因为主从复制有同步延迟，所以不能保证强数据一致性）</li></ul><p><br><br><br></p><h2 id="主从复制和读写分离"><a href="#主从复制和读写分离" class="headerlink" title="主从复制和读写分离"></a>主从复制和读写分离</h2><ul><li>主从复制是实现读写分离的技术之一，也是实现读写分离的前提条件</li><li>做读写分离时最重要的就是确保 读库 和 写库 的数据统一，而主从复制是实现数据统一最简单的方法（并不能够保证强数据的一致性）</li><li>读写分离，顾名思义，就是一个表只负责向前台页面展示数据，而后台管理人员对表的增删改在另一个表中，把两个表分开，就是读写分离</li><li>主从复制则是一个表数据 增删改 之后会及时更新到另一个表中，保证两个表的数据一致</li></ul><p><br><br><br></p><h2 id="主从类型"><a href="#主从类型" class="headerlink" title="主从类型"></a>主从类型</h2><ul><li>双机热备=主机+备机</li><li>主要应用运行在主机，备机即备用机器。备机不工作，主机出现故障时备机接管主机的所有工作</li><li>双机互备=主机（备机） + 备机（主机）</li><li>互为主备，部分应用运行于主机，部分应用运行于备机，主机备机同时工作</li><li>双机双工=主机+主机</li><li>两台主机同时运行应用，主机备机同时工作</li></ul><p><br></p><hr><p><br></p><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><ul><li>广义上的分布式是指，将不同的服务分布在不同的服务器上</li><li>集群是指，将几台服务器集中在一起，实现同一业务</li><li>分布式中的每一个节点都可以做集群，而集群并不一定是分布式的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《老男孩Linux运维》&lt;/li&gt;
&lt;li&gt;《服务器集群系统各概念》: &lt;a href=&quot;https://segmentfault.com/a/1190000009923581&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000009923581&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《WEB的负载均衡、集群、高可用解决方案》： &lt;a href=&quot;https://zhuanlan.zhihu.com/p/23826048&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/23826048&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计算机集群维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://zhang21.github.io/tags/Nginx/"/>
    
      <category term="Cluster" scheme="https://zhang21.github.io/tags/Cluster/"/>
    
  </entry>
  
  <entry>
    <title>Bash特殊符号</title>
    <link href="https://zhang21.github.io/2018/01/25/Bash%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"/>
    <id>https://zhang21.github.io/2018/01/25/Bash特殊符号/</id>
    <published>2018-01-25T09:37:17.000Z</published>
    <updated>2018-01-25T09:54:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在编写shellscripts的时候，特殊符号也有其重要的功能。</p><a id="more"></a><p>具体描述如下：</p><table><thead><tr><th>符号</th><th>描述</th><th>栗子</th></tr></thead><tbody><tr><td>#!</td><td>shellban，申明脚本所使用的shell</td><td>#!/bin/bash</td></tr><tr><td>\</td><td>转义字符</td><td>\n</td></tr><tr><td>l</td><td>管道</td><td>stdout l grep</td></tr><tr><td>&gt;,&gt;&gt;</td><td>输出重定向</td><td>&gt;1.txt</td></tr><tr><td>&lt;,&lt;&lt;</td><td>输入重定向</td><td>&lt;1.txt</td></tr><tr><td>2&gt;</td><td>错误输出</td><td>2&gt;error.txt</td></tr><tr><td>;</td><td>连续命令分隔符</td><td>cmd1; cmd2</td></tr><tr><td>&amp;&amp;</td><td>与，只有当前命令完成后才执行后一个命令</td><td>cmd1 &amp;&amp; cmd2</td></tr><tr><td>ll</td><td>或，或此或彼</td><td>cmd1 ll cmd2</td></tr><tr><td>~</td><td>用户家目录</td><td>cd ~</td></tr><tr><td>#</td><td>注释符</td><td>#it’s a comments</td></tr><tr><td>$</td><td>取用变量前导符</td><td>\$PATH或${PATH}</td></tr><tr><td>&amp;</td><td>工作控制，将命令放入后台(bg)</td><td>command&amp;</td></tr><tr><td>*, ?, [], [-], [^]</td><td>通配符</td><td><em>.sh，?.sh，[a-z]</em>.txt</td></tr><tr><td>!</td><td>逻辑运算’非’not</td><td>!=</td></tr><tr><td>=,两边无空格</td><td>赋值符号</td><td>name=zhang</td></tr><tr><td>=,两边有空格</td><td>比较符号</td><td>if  [ $name  =  zhang ]</td></tr><tr><td>\$0</td><td>代表脚本自身</td><td>zhang.sh</td></tr><tr><td>\$1，\$2</td><td>第1个/2个…变量</td><td>./zhang.sh start…</td></tr><tr><td>$#</td><td>命令后面参数个数</td><td>if [ $# -ne 2 ]；then echo “Usage: \$0 arg1 arg2”</td></tr><tr><td>$@</td><td>代表\$1,\$2,\$3…之意，每个变量是独立的</td><td>xx</td></tr><tr><td>$*</td><td>代\$1 \$2 \$3 …”之意</td><td>xxx</td></tr><tr><td>\$?</td><td>命令状态码，成功为0</td><td>\$?</td></tr><tr><td>\$\$</td><td>当前shell的PID</td><td>echo \$\$</td></tr><tr><td>‘单引号’</td><td>单引号内特殊字符仅为一般字符</td><td>echo ‘\$host’–$host</td></tr><tr><td>“双引号”</td><td>双引号内特殊符号，可保有原本特性</td><td>echo “\$host” –localhost</td></tr><tr><td>`反引号`</td><td>运行命令，也可用()代替</td><td>`date`或 \$(date)</td></tr><tr><td>()</td><td>以子shell方式执行</td><td>($(date))</td></tr><tr><td>{}</td><td>命令区块的组合</td><td>xxx</td></tr><tr><td>PS1</td><td>命令提示符</td><td>$PS1</td></tr><tr><td>PS2</td><td>第二行以后的提示字符</td><td>$PS2</td></tr><tr><td>shift</td><td>移动参数</td><td>当使用shift后，\$1=\$2;再次shift后，\$1=\$3</td></tr><tr><td>set</td><td>查看所有变量</td><td><code>set</code></td></tr><tr><td>unset</td><td>取消变量</td><td>unset name，没有$符号</td></tr><tr><td>export</td><td>使某变量成为环境变量</td><td>export name，没有$符号</td></tr><tr><td>source</td><td>source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录</td><td>source file</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编写shellscripts的时候，特殊符号也有其重要的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Shell" scheme="https://zhang21.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>不成熟的小想法</title>
    <link href="https://zhang21.github.io/2018/01/21/%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E5%B0%8F%E6%83%B3%E6%B3%95/"/>
    <id>https://zhang21.github.io/2018/01/21/不成熟的小想法/</id>
    <published>2018-01-21T14:11:16.000Z</published>
    <updated>2018-03-18T12:19:12.500Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ynwa.png" alt="YNWA"></p><a id="more"></a><p><br><br><br></p><blockquote><p>你在大学奋斗四年和你进入工作岗位后奋斗四年，这两者的质量是完全不同的。前者是一个人一生的黄金时代，他有绝对的选择权来决定自己要成为什么样子；而后者则不同，吃饱饭才是这些已经步入社会的人需要考虑的第一要务。</p></blockquote><p><br></p><blockquote><p>我想不明白，为什么非要把成都建设成为2/3个四川？(或许西部省份都是这样，省会便是这个省)2017年成都市GDP约为13800亿人民币，而第二名的绵阳，却连2000亿都不到。<br>后来别人对我讲，资本都是逐利的。也许将壹万亿拆分成小蛋糕到各个地级市能使得各个地级市经济都得到一定的发展，但肯定没有将全部蛋糕投在成都的利润更好。这让我想起了滚雪球效应，相比滚出许多小雪球，所带来的的直观效应也没有大雪球突出，雪球越滚越大，给人的映像也就越来越明显。还有就是为政者都是需要政绩来突出自己，这是升迁的重要依据。GDP才是衡量你当政的重要依据，其它因素虽然也重要，但也比不过它。</p></blockquote><p><br></p><blockquote><p>我喜欢苹果，你却给了我一车梨，然后告诉全世界你花光了所有的钱给我买了一车梨。可是我却没有一点点感动，你说我是一个铁石心肠的人，可是我只是喜欢苹果而已。</p></blockquote><p><br></p><blockquote><p>任何人不是要你来教他如何做人的！</p></blockquote><p><br></p><blockquote><p>难道真如马尔克斯所说——“上了年纪的人不是按照已经活了多少岁来衡量年龄的，而是通过距离死亡还有多远来衡量！”</p></blockquote><p><br></p><blockquote><p>我刚开上本田的时候，也是宋总这心情，把骑自行车的人贬个贼死，而且心里就会骂出口，大屁股晃什么晃，开个玛萨拉蒂得瑟呀，我那时就像我买得起玛萨拉蒂一样。哈哈，就是个工具，先上手再说。<br>原来人都有这种心态，哈哈哈。</p></blockquote><p><br></p><blockquote><p>看着老一辈的逐渐老去，小一辈的逐渐长大，感叹时光过得真快呀！</p><p>过年回家，任何人都会谈及一个字——“钱”。</p><p>全家人都想出去挣钱，关于老人赡养问题，儿子和女儿又该如何担责？</p><p>儿媳妇也是一个严重的问题！我在想一个问题，儿媳妇在对待男方父母的时候，有没有想过如果以后她的儿媳也这样对待她，她作何感想？</p><p>现在的亲戚关系如果隔代的话，基本上过年就只有上一辈的人才走动了，下一辈子女基本都不会去。想想我们这些娃儿，上辈是亲兄弟姐妹、堂兄弟姐妹或表兄弟姐妹，我们这些小辈娃儿从小一起玩耍长大，小时候的关系好的不得了，用俗话说就是“穿一条裤子”。可是长大以后、结婚成家以后关系就淡泊了，哎！<br>可能我们这一辈情况以后会好一点，因为由于国家的计划生育政策，我们这一辈基本上都是独生子女。以后亲戚就这些，可能关系会好点，逢年过节走动会更频繁一点。其实计划生育使得我们这一辈人挺孤单的，长得后没什么亲戚、兄弟姊妹。以后我们的孩子也没有了舅舅、姨、叔伯、嬢嬢。所以可能以后非直系亲戚间的关系也会更紧密一些。现在国家放开了二胎其实挺好的，孩子们能有个哥哥姐姐弟弟妹妹真的挺好的。</p><p>过年回家经典问答：毕业了没有呀？毕业了，微笑；多少岁了呀？xxx岁了，微笑；在哪上班呀？在外上班，微笑；在成都哪个地方呀？南边，微笑；在哪个公司呀？小公司，微笑；是做啥子的呀？计算机，微笑；工资多少呀？不多不少，微笑；有没有女朋友呀？没有，微笑……<br>我知道这些长辈本没有恶意，只是出于不知道说什么而问点问题。但是，你们就不能动动脑子吗，我的长辈些。</p></blockquote><p><br></p><blockquote><p>我只是一个农村里出来的怯弱书生，一定要找准自己的定位。上辈给不了我什么东西，这点和城里的孩子已经差了一步，所以只有靠自己好好努力奋斗。争取给小一辈创造一个好一点的环境。</p><p>人人都是有利己心，人人都是自私的，表面和内心就如同硬币的正反两面。底层人民毫不讲理的一套，做事情完全不看原则和对错，完全是斗谁的声音高谁的脾气大才是理。看见斗不过有立马哭闹装楞。农村人民并不是那么淳良朴实，一点点鸡毛蒜皮的事情都要争。</p></blockquote><p><br></p><blockquote><p>任何人际关系都需要维持的！</p></blockquote><p><br></p><blockquote><p>我发觉我有一个问题。<br>人对一个人、一件物、一件事产生一个误解(或称之为成见的东西)，是很难改变的，以后会一直存在于我们的潜意识里面。我们的潜意识会主动隔阂某人某事某物，几遍某人某物某事是对的，这样一个长期效应便是对于我们潜意识里面的思维，我们会主动用我们的成见来隔阂。不知道能不能用“一朝被蛇咬十年怕井绳”来表述。<br>其实人与人、人与事是需要相互了解的，有了成见以后人就不愿意了解对方，而用自己潜意识的成见来判断人事物。这样隔阂也就难以消除而会一直延续小区。<br>所以，对人对事，不能带着老旧的成见去看到。——“士别三日当刮目相待，已非吴下阿蒙”。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/ynwa.png&quot; alt=&quot;YNWA&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Zhang" scheme="https://zhang21.github.io/categories/Zhang/"/>
    
    
      <category term="Zhang" scheme="https://zhang21.github.io/tags/Zhang/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://zhang21.github.io/2018/01/16/MySQL/"/>
    <id>https://zhang21.github.io/2018/01/16/MySQL/</id>
    <published>2018-01-16T02:47:12.000Z</published>
    <updated>2018-03-02T10:00:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>MySQL5.7参考文档： <a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/</a></li></ul><p><br></p><p>环境：</p><ul><li>CentOS7.x86_64</li><li>MySQL5.7</li></ul><a id="more"></a><p><br><br><br></p><hr><p><br></p><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>MySQL官网： <a href="https://www.mysql.com/" target="_blank" rel="noopener">https://www.mysql.com/</a></p><p>由于MySQL5.7和以前版本之间的许多功能和其他差异，因此此手册不太适用于之前的老版本。之前的版本请参考MySQL相关版本的手册。</p><p><br></p><p><img src="/images/Mysql/MySQL.png" alt="MySQL"></p><p><br><br><br></p><hr><p><br></p><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>General information</p><p>MySQL™ software提供了一个快速、多线程、多任务和健壮的SQL(结构化查询语言)的数据库服务器。MySQL server是为关键服务(mission-critical)、重负荷(heavy-load)生产系统以及嵌入式(embedding)大规模部署的软件而设计。<br>MySQL是Oracle Corporation的商标(trademark)。</p><p>MySQL software是双重许可的(dual license)：</p><ol><li>Open Source product of the GNU General Public License</li><li>A Standard commercial License from Oracle</li></ol><p><br><br><br></p><h2 id="关于此手册"><a href="#关于此手册" class="headerlink" title="关于此手册"></a>关于此手册</h2><ul><li>该手册作为一个参考，它不提供关于SQL或关系型数据库概念的一般指令；</li><li>MySQL Database Software正在不断发展，所以参考手册也经常更新。可在此 &lt; <a href="http://dev.mysql.com/doc/&gt;" target="_blank" rel="noopener">http://dev.mysql.com/doc/&gt;</a> 获取最新版的手册；</li><li>参考手册(Reference Manual)的源文件使用DocBook XML格式书写的，其他版本(如HTML)等是自动生成的；</li><li>如果在使用过程中有任何问题或建议，请发邮件给我们；</li><li>手册由MySQL Documentation Team维护。</li></ul><p><br><br><br></p><h2 id="MySQL数据库管理系统"><a href="#MySQL数据库管理系统" class="headerlink" title="MySQL数据库管理系统"></a>MySQL数据库管理系统</h2><p>MySQL Database Management System</p><p><br></p><h3 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a>MySQL介绍</h3><p>MySQL是最流行的开源的SQL数据库管理系统，由Oracle Corporation开发、分发和支持。</p><p><br></p><ul><li><p>MySQL is a database management system<br>数据库是一个结构化的数据集合。它可能是从简单的购物清单到图片库，或是公司网络中的大量信息。若要添加、访问和处理存储在计算机数据库中的数据，你需要一个像MySQL Server这样的数据库管理系统。由于计算机非常擅长处理大量的数据，数据库管理系统在计算机中扮演这一个重要的角色。</p></li><li><p>MySQL databases are relational<br>关系型数据库将数据存储在单独的表(table)中，而不是将所有数据放入一个大的库房中。数据库结构被组织成针对速度优化的物理文件。具有数据库(database)，表(table)，视图(view)，行(row)，列(column)等物理对象的逻辑模型提供了灵活的编程环境。你设置了管理不同数据字段之间关系的规则，如一对一，一对多，唯一，必须和可选关系，以及不同表之间的指针(pointer)。数据库强制执行这些规则，这样在设计良好的数据库中，应用程序就不会看到不一致、重复、孤立、过时或丢失的数据。</p></li></ul><p>MySQL也是代表SQL(Structure Query Language)的一部分。SQL是访问数据库最常用的标准化语言。你可以直接使用SQL语句，或者将SQL语法隐藏到语言特定的API中。</p><p>-MySQL software is Open Source<br>MySQL software使用GPL(GNU General Public License)，开源意味着任何人都可以下载、转发、使用和修改软件，而不需要支付任何费用。</p><ul><li><p>MySQL database server is very fast,reliable,scalabe and easy to use</p></li><li><p>MySQL server works in Client/Server or embedded system<br>MySQL Database Server是一个由多线程(multi-threaded)SQL Server组成的客户/服务器系统。它支持不同的后端，多个不同的客户程序和库、管理工具和广泛的APIs。<br>还提供MySQL Server作为一个嵌入式多线程库以便链接到你的产品，以获得一个更小，更快，更容易管理的独立产品。</p></li><li><p>A large amount of contributed MySQL software is available</p></li></ul><p><br><br><br></p><h3 id="MySQL主要特点"><a href="#MySQL主要特点" class="headerlink" title="MySQL主要特点"></a>MySQL主要特点</h3><h4 id="Internals-and-Portability"><a href="#Internals-and-Portability" class="headerlink" title="Internals and Portability"></a>Internals and Portability</h4><ul><li>由C和C++写成</li><li>适用于许多不同的平台</li><li>为了可移植性，使用<code>CMake</code></li><li>采用独立(independent)模块的多层(layer)服务器设计</li><li>设计为使用内核线程的完全多线程，如果有多核CPU，能够轻松使用它们</li><li>提供了事务性(transactional)和非事务性(notransactional)存储引擎</li><li>使用非常快速的带有索引压缩的B-tree磁盘表</li><li>添加其他存储引擎相对容易</li><li>使用非常快速的基于线程的内存分配系统</li><li>使用优化的嵌套循环(nested-loop)连接执行非常快的联结</li><li>实现内存中的hash table，这些表用作临时表</li><li>使用高度优化的类库实现SQL函数</li></ul><p><br></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>1,2,3,4和8byte的有无符号(signed/unsigned)的整数(integers)</li><li>FLOAT</li><li>DOUBLE</li><li>CHAR, VARCHAR</li><li>BINARY, VARBINARY</li><li>TEXT</li><li>BLOB</li><li>DATE, TIME, DATETIME</li><li>TIMESTAMP</li><li>YEAR</li><li>SET</li><li>ENUM</li><li>OpenGIS</li></ul><p><br></p><h4 id="状态和功能"><a href="#状态和功能" class="headerlink" title="状态和功能"></a>状态和功能</h4><p>statement and function</p><ul><li><code>SELECT</code>和<code>WHERT</code>中包含了所有支持的操作符和函数</li><li>SQL中的<code>GROUP BY</code>和<code>ORDER BY</code>也全部支持</li><li>GROUP functions(<code>COUNT()</code>, <code>AVG()</code>, <code>STD()</code>, <code>SUM()</code>, <code>MAX()</code>, <code>MIN()</code>, <code>GROUP_CONCAT()</code>)</li><li>支持<code>LEFT OUTER JOIN</code>和<code>ROGHT OUTER JOIN</code></li><li>按照SQL标准支持table和columns的别名</li><li>支持<code>DELETE</code>,<code>INSERT</code>,<code>REPLACE</code>,<code>UPDATE</code>，以返回受影响的行数</li><li>支持MySQL特定的<code>SHOW</code>显示语句</li><li>一个<code>EXPLAIN</code>语句显示优化器如何解析查询</li></ul><p><br></p><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>security</p><ul><li>权限(privilege)和密码系统，非常灵活和安全，并且支持基于主机的验证</li><li>当连接到Server时，通过加密(encryption)所有密码通信量来确保密码安全</li></ul><p><br></p><h4 id="扩展性和限制"><a href="#扩展性和限制" class="headerlink" title="扩展性和限制"></a>扩展性和限制</h4><p>Scalability and Limits</p><ul><li>支持大型数据库。包含五千万条记录，二十万个表，五十亿行</li><li>每个表最多支持64个索引，每个索引可以由1到16个列组成</li></ul><p><br></p><p>####　连通性</p><p>Conectivity</p><ul><li>客户端使用如下几种协议连接到MySQL Server<ul><li>TCP/IP sockets</li><li>–enable-named-pipe on Windows</li><li>Unix domain socket files on UNIX</li></ul></li><li>MySQL客户端可用多种语言编写</li><li>APIs对于多数语言是可用的</li></ul><p><br></p><h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>Localization</p><ul><li>Server可以向多种语言的客户端提供错误信息</li><li>完全支持几个不同的字符集(character sets)</li><li>所有数据都被保存在选取的字符集(chracter set)</li><li>排序和比较是根据默认的字符集和排序规则完成</li><li>服务器时区(time zone)可动态更改，个客户端也可修改自己的时区</li></ul><p><br></p><h4 id="客户端和工具"><a href="#客户端和工具" class="headerlink" title="客户端和工具"></a>客户端和工具</h4><p>Clients and Tools</p><ul><li>MySQL包含几个客户机和使用程序<ul><li>command-line： <code>mysqldump</code>, <code>mysqladmin</code></li><li>graphical: MySQL Workbench</li></ul></li><li>MySQL Server内置了对SQL语句的支持来检查、优化和修复表</li><li>MySQL程序可使用<code>--help</code>或<code>-?</code>来获取帮助</li></ul><p><br><br><br></p><h3 id="MySQL历史"><a href="#MySQL历史" class="headerlink" title="MySQL历史"></a>MySQL历史</h3><p>History of MySQL</p><ul><li>MySQL is named after co-founder Monty Widenius’s daughter, My.</li><li>The name of the MySQL Dolphin (our logo) is “Sakila,” which was chosen from a huge list of names suggested by users in our “Name the Dolphin” contest.</li></ul><p><br><br><br></p><h2 id="MySQL5-7新特色"><a href="#MySQL5-7新特色" class="headerlink" title="MySQL5.7新特色"></a>MySQL5.7新特色</h2><p>What Is New in MySQL 5.7</p><p><br></p><h3 id="MySQL5-7新功能"><a href="#MySQL5-7新功能" class="headerlink" title="MySQL5.7新功能"></a>MySQL5.7新功能</h3><p>Features Added in MySQL 5.7</p><p><br><br><br></p><h3 id="MySQL5-7中过期的功能"><a href="#MySQL5-7中过期的功能" class="headerlink" title="MySQL5.7中过期的功能"></a>MySQL5.7中过期的功能</h3><p>Features Deprecated in MySQL 5.7</p><p><br><br><br></p><h3 id="MySQL5-7中移除的功能"><a href="#MySQL5-7中移除的功能" class="headerlink" title="MySQL5.7中移除的功能"></a>MySQL5.7中移除的功能</h3><p>Features Removed in MySQL 5.7</p><p><br><br><br></p><h2 id="Server-and-Status-Variables-and-Options-Added-Deprecated-or-Removed-in-MySQL-5-7"><a href="#Server-and-Status-Variables-and-Options-Added-Deprecated-or-Removed-in-MySQL-5-7" class="headerlink" title="Server and Status Variables and Options Added, Deprecated, or Removed in MySQL 5.7"></a>Server and Status Variables and Options Added, Deprecated, or Removed in MySQL 5.7</h2><p><br><br><br></p><h2 id="MySQL信息源"><a href="#MySQL信息源" class="headerlink" title="MySQL信息源"></a>MySQL信息源</h2><p>MySQL Information Sources</p><p>本章节将列出有关MySQL的帮助信息。</p><p><br></p><h3 id="MySQL站点"><a href="#MySQL站点" class="headerlink" title="MySQL站点"></a>MySQL站点</h3><p>MySQL Websites</p><p>MySQL Documentation is <a href="https://dev.mysql.com/doc" target="_blank" rel="noopener">https://dev.mysql.com/doc</a></p><p><br><br><br></p><hr><p><br></p><h1 id="安装和升级MySQL"><a href="#安装和升级MySQL" class="headerlink" title="安装和升级MySQL"></a>安装和升级MySQL</h1><ul><li>mysql-repo: <a href="http://repo.mysql.com/" target="_blank" rel="noopener">http://repo.mysql.com/</a></li><li>yum-repo: <a href="http://repo.mysql.com/yum/" target="_blank" rel="noopener">http://repo.mysql.com/yum/</a></li></ul><p><br></p><p>安装MySQL一般遵循以下步骤：</p><ul><li>确定MySQL是否支持你的平台(platform)<ul><li>Unix、Linux、FreeBSD</li><li>Windows</li><li>OS X</li></ul></li><li>选择要安装的发行版(distribution)</li><li>下载你想要安装的发行版</li><li>安装发行版</li><li>执行任何必要的安装后设置</li></ul><p><br><br><br></p><h2 id="通用安装指南"><a href="#通用安装指南" class="headerlink" title="通用安装指南"></a>通用安装指南</h2><p>General Installation Guidance</p><p><br><br><br></p><h3 id="安装哪个发行版和MySQL版本"><a href="#安装哪个发行版和MySQL版本" class="headerlink" title="安装哪个发行版和MySQL版本"></a>安装哪个发行版和MySQL版本</h3><p>Which MySQL Version and Distribution to Install</p><p><br></p><p>在准备安装MySQL时，请决定使用哪种版本(version)和发行(distribution)格式(binary or source)</p><p>首先，决定安装开发版还是稳定版。</p><ul><li>Development release<ul><li>具有新功能，但不推荐用于生产环境</li></ul></li><li>General Availability(GA) release<ul><li>也称为稳定版(stable release)，推荐为生产环境使用</li></ul></li></ul><p>MySQL命名方案(naming scheme)， 例如MySQL5.7.1：</p><ul><li>5为主版本号(major)</li><li>7为次版本号(minor)</li><li>1为发行(release)系列版本号<ul><li>系列号描述了稳定的功能集。对于每个新的修补程序，这都会增加。</li></ul></li></ul><p>在选择要安装的MySQL版本之后，决定要为操作系统安装哪个发行版格式。</p><ul><li>二进制(binary)<ul><li>RPM, DMG</li></ul></li><li>源码(source)<ul><li>tar, zip</li></ul></li></ul><p>在某些情况下，最好使用源码安装MySQL：</p><ul><li>想在某个明确的位置安装MySQL</li><li>希望使用二进制发行版中未包含的特性配置mysqld</li><li>希望配置mysqld，而不需要二进制发行版中包含的一些功能</li><li>你希望读取或修改组成MySQL的C、C++源代码</li><li>源码发行版比二进制发行版包含更多的测试和示例</li></ul><p><br><br><br></p><h3 id="如何获取MySQL"><a href="#如何获取MySQL" class="headerlink" title="如何获取MySQL"></a>如何获取MySQL</h3><p>How to Get MySQL</p><p><br></p><ul><li>MySQL当前版本下载页： <a href="https://dev.mysql.com/downloads/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/</a></li><li>完整的MySQL镜像： <a href="https://dev.mysql.com/downloads/mirrors/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mirrors/</a></li><li>基于RPM的Linux平台，MySQL Yum Repository： <a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a></li><li>基于Debian的Linux平台，MySQL APT Repository： <a href="https://dev.mysql.com/downloads/repo/apt/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/apt/</a></li><li>SUSE Linux平台，MySQL SUSE Repository： <a href="https://dev.mysql.com/downloads/repo/suse/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/suse/</a></li></ul><p><br><br><br></p><h3 id="使用MD5校验和或GnuPG验证程序完整性"><a href="#使用MD5校验和或GnuPG验证程序完整性" class="headerlink" title="使用MD5校验和或GnuPG验证程序完整性"></a>使用MD5校验和或GnuPG验证程序完整性</h3><p>Verifying Package Integrity Using MD5 Checksums or GnuPG</p><p><br></p><p>下载好MySQL包并在安装它之前，请确保它是完整的并未被篡改。有如下三种方法：</p><ul><li>MD5 checksums</li><li>Cryptographic signatures using GnuPG, the GNU Privacy Guard</li><li>For RPM packages, the built-in RPM integrity verification mechanism</li></ul><p><br><br><br></p><h4 id="验证MD5校验和"><a href="#验证MD5校验和" class="headerlink" title="验证MD5校验和"></a>验证MD5校验和</h4><p>Verifying the MD5 Checksum</p><p><br></p><p>应确保下载的MySQL包的MD5校验和与MySQL官方提供的校验和相匹配。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">md5sum mysql-standard-5.7.22-linux-i686.tar.gz</div><div class="line"><span class="comment">#aaab65abbec64d5e907dcd41b8699945  mysql-standard-5.7.22-linux-i686.tar.gz</span></div></pre></td></tr></table></figure><p><br></p><h4 id="使用GnuPG进行签名检查"><a href="#使用GnuPG进行签名检查" class="headerlink" title="使用GnuPG进行签名检查"></a>使用GnuPG进行签名检查</h4><p>Signature Checking Using GnuPG</p><p><br></p><p>要验证软件包的签名，首先需要我们的公共GPG密钥的副本。可从<a href="http://pgp.mit.edu/" target="_blank" rel="noopener">http://pgp.mit.edu/</a>下载。<br>你想要获得的密钥名为<strong>mysql-build@oss.oracle.com</strong>，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-----BEGIN PGP PUBLIC KEY BLOCK-----</div><div class="line">Version: GnuPG v1.4.5 (GNU/Linux)</div><div class="line"></div><div class="line">mQGiBD4+owwRBAC14GIfUfCyEDSIePvEW3SAFUdJBtoQHH/nJKZyQT7h9bPlUWC3</div><div class="line">RODjQReyCITRrdwyrKUGku2FmeVGwn2u2WmDMNABLnpprWPkBdCk96+OmSLN9brZ</div><div class="line">fw2vOUgCmYv2hW0hyDHuvYlQA/BThQoADgj8AW6/0Lo7V1W9/8VuHP0gQwCgvzV3</div><div class="line">BqOx后面还有很多，省略</div><div class="line">-----END PGP PUBLIC KEY BLOCK-----</div></pre></td></tr></table></figure><p>使用<code>gpg --import</code>将密钥导入到个人公共GPG密钥环中。如公共密钥为<code>mysql_pubkey.asc</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gpg --import ./mysql_pubkey.asc</div><div class="line"></div><div class="line"></div><div class="line">#或使用public key id下载公共密钥</div><div class="line">gpg --recv-keys $pub-key-id</div></pre></td></tr></table></figure><p>在rpm包中验证:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm --import ./mysql_pubkey.asc</div></pre></td></tr></table></figure><p>确保两个文件都放置于同一目录下，然后运行命令验证签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gpg --verify package_name.asc</div><div class="line"></div><div class="line">gpg --verify mysql-standard-5.7.22-linux-i686.tar.gz.asc</div><div class="line">gpg: Signature made Tue 01 Feb 2011 02:38:30 AM CST using DSA key ID 5072E1F5</div><div class="line">gpg: Good signature from &quot;MySQL Release Engineering &lt;mysql-build@oss.oracle.com&gt;&quot;</div></pre></td></tr></table></figure><p><br></p><h4 id="使用RPM进行签名检查"><a href="#使用RPM进行签名检查" class="headerlink" title="使用RPM进行签名检查"></a>使用RPM进行签名检查</h4><p>Signature Checking Using RPM</p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rpm --checksig package_name.rpm</div><div class="line"></div><div class="line">[zhang@zabbix ~]$ rpm --checksig mysql-community-server-5.7.20-1.el7.x86_64.rpm</div><div class="line">mysql-community-server-5.7.20-1.el7.x86_64.rpm: (sha1) dsa sha1 md5 gpg OK</div></pre></td></tr></table></figure><p>rpm还支持从URL加载密钥:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm --import http://dev.mysql.com/doc/refman/5.7/en/checking-gpg-signature.html</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="安装布局"><a href="#安装布局" class="headerlink" title="安装布局"></a>安装布局</h3><p>Installation Layouts</p><p><br></p><p>不同的安装类型(native packages, binary tarballs, and source tarballs)有不同的安装布局，这样可能会导致混淆。</p><p><br><br><br></p><h2 id="在Unix-Linux上使用通用二进制文件安装MySQL"><a href="#在Unix-Linux上使用通用二进制文件安装MySQL" class="headerlink" title="在Unix/Linux上使用通用二进制文件安装MySQL"></a>在Unix/Linux上使用通用二进制文件安装MySQL</h2><p>Installing MySQL on Unix/Linux Using Generic Binaries</p><p><br></p><p>包括以压缩的tar文件形式的通用二进制发行版，以及针对特定平台封装格式的二进制文件。</p><p>MySQL压缩tar文件二进制发行版具有<strong> mysql-VERSION-OS.tar.gz</strong>的文件格式。</p><p>MySQL依赖于<code>libaio</code> Library：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y libaio</div></pre></td></tr></table></figure><p><br></p><p>默认地，tar文件二进制发行版，解压后安装于<code>/usr/local/mysql</code>目录。会在目录下生产 通用Unix/Linux二进制包的MySQL安装布局目录</p><table><thead><tr><th>目录</th><th>内容</th></tr></thead><tbody><tr><td>bin</td><td>mysqld server, client and utility programs</td></tr><tr><td>docs</td><td>MySQL manual in Info format</td></tr><tr><td>man</td><td>Unix manual pages</td></tr><tr><td>include</td><td>Include (header) files</td></tr><tr><td>lib</td><td>Libraries</td></tr><tr><td>share</td><td>Error messages, dictionary, and SQL for database installation</td></tr><tr><td>support-files</td><td>Miscellaneous support files</td></tr></tbody></table><p>大致命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">shell&gt; groupadd mysql</div><div class="line">shell&gt; useradd -r -g mysql -s /bin/false mysql</div><div class="line">shell&gt; cd /usr/local</div><div class="line">shell&gt; tar zxvf /path/to/mysql-VERSION-OS.tar.gz</div><div class="line">shell&gt; ln -s full-path-to-mysql-VERSION-OS mysql</div><div class="line">shell&gt; cd mysql</div><div class="line">shell&gt; mkdir mysql-files</div><div class="line">shell&gt; chown mysql:mysql mysql-files</div><div class="line">shell&gt; chmod 750 mysql-files</div><div class="line">shell&gt; bin/mysqld --initialize --user=mysql</div><div class="line">shell&gt; bin/mysql_ssl_rsa_setup</div><div class="line">shell&gt; bin/mysqld_safe --user=mysql &amp;</div><div class="line"># Next command is optional</div><div class="line">shell&gt; cp support-files/mysql.server /etc/init.d/mysql.server</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#添加环境变量</div><div class="line">export PATH=$PATH:/usr/local/mysql/bin</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="在Linux上安装MySQL"><a href="#在Linux上安装MySQL" class="headerlink" title="在Linux上安装MySQL"></a>在Linux上安装MySQL</h2><p>Installing MySQL on Linux</p><p><br></p><p>Linux支持多种方法来安装MySQL。建议使用Oracle提供的一个发行版：</p><ul><li>Apt</li><li>Yum</li><li>Zypper</li><li>RPM</li><li>DEB</li><li>Generic</li><li>Source</li><li>Docker</li><li>Oracle Unbreakable Linux Network</li></ul><p>作为一个选择，你可以使用系统中的包管理工具自动下载和安装MySQL。</p><p><br><br><br></p><h3 id="在Linux上使用Yum-Repository安装MySQL"><a href="#在Linux上使用Yum-Repository安装MySQL" class="headerlink" title="在Linux上使用Yum Repository安装MySQL"></a>在Linux上使用Yum Repository安装MySQL</h3><p>Installing MySQL on Linux Using the MySQL Yum Repository</p><p><br></p><p><strong>安装一个全新的MySQL的步骤：</strong></p><ul><li>添加MySQL Yum Repository<ul><li>首先，添加MySQL Yum repository到你的系统仓库列表</li><li>选择和下载对应平台的release 或者 手动添加repository文件</li><li>安装release package</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#yum localinstall platform-and-version-specific-package-name.rpm</span></div><div class="line">yun install http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql57-community-release-el7-10.noarch.rpm</div><div class="line"></div><div class="line"></div><div class="line">yum repolist enabled | grep <span class="string">"mysql.*-community.*"</span></div></pre></td></tr></table></figure><ul><li>选择一个release series</li></ul><p>默认是最新的GA series，当前最新是MySQL5.7。</p><p>查看所有的MySQL Yum repository: <code>yum repolist all | grep mysql</code></p><p>安装最新MySQL不需要配置，而安装先前的版本则需要指定GA series。disable最新的GA series并且enable需要的GA series。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum-config-manager --disable mysql57-community</div><div class="line"></div><div class="line">yum-config-manager --enable mysql56-community</div></pre></td></tr></table></figure><p><strong>或者手动创建repo，可直接定义版本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[mysql57-community]</div><div class="line">name=MySQL 5.7 Community Server</div><div class="line">baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/7/$basearch/</div><div class="line">enabled=1</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</div></pre></td></tr></table></figure><ul><li>安装MySQL</li></ul><p>在安装MySQL过程中出现错误，请务必查看日志文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum install -y mysql-community-server mysql-community-client</div><div class="line"></div><div class="line">#也可不安装客户端</div></pre></td></tr></table></figure><ul><li>开启MySQL Server</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">service mysqld start</div><div class="line">#Starting mysqld:[ OK ]</div><div class="line"></div><div class="line">service mysqld status</div></pre></td></tr></table></figure><p><strong>在服务器初始启动时，如果服务器的数据目录为空，则会发生一下情况：</strong></p><ul><li>服务器已初始化</li><li>SSL certificate and key files 在数据目录中生成</li><li>validate_password已安装并启用</li><li>超级用户账户’root’@’localhost’被创建，超级用户密码被设置并被存储在error log files<ul><li>这一点和以前版本有很大区别，我被坑惨了</li></ul></li></ul><p><strong>注意：</strong></p><blockquote><p>ValidPassword的默认密码策略要求包含大写字母、小写字母、数字和特殊字符，并且密码长度至少为8个字符</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#查看初始密码</div><div class="line">grep &apos;temporary password&apos; /var/log/mysqld.log</div><div class="line"></div><div class="line"></div><div class="line">#无法使用mysqladmin修改密码，需要登录mysql后修改</div><div class="line"></div><div class="line">mysql -uroot -p</div><div class="line"></div><div class="line"></div><div class="line">#重置密码</div><div class="line">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;NewPass4!;</div><div class="line"></div><div class="line"></div><div class="line">#如果找不到初始密码</div><div class="line">vim /etc/my.cnf</div><div class="line"></div><div class="line">#在[mysqld]最后行加上skip-grant-tables实现无认证登录</div><div class="line">#重启MySQL</div><div class="line">UPDATE  mysql.user  SET  authentication_string =PASSWORD(&apos;新密码&apos;)  WHERE  USER=&apos;xxx&apos;;</div><div class="line"></div><div class="line"></div><div class="line">#修改默认密码策略</div><div class="line">#更改密码强度</div><div class="line">set global validate_password_policy=0;</div><div class="line"></div><div class="line">#设置密码最小长度</div><div class="line">set global validate_password_length=4;</div></pre></td></tr></table></figure><p><br></p><p><strong>使用Yum安装额外的MySQL产品和组件</strong></p><p>你可使用Yum安装和管理MySQL的个别组件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">yum --disablerepo=\* --enablerepo=<span class="string">'mysql*-community*'</span> list available</div><div class="line"></div><div class="line">yum install package-name</div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">yum install mysql-community-libs</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="在Linux上使用Oracle提供的RPM包安装MySQL"><a href="#在Linux上使用Oracle提供的RPM包安装MySQL" class="headerlink" title="在Linux上使用Oracle提供的RPM包安装MySQL"></a>在Linux上使用Oracle提供的RPM包安装MySQL</h3><p>Installing MySQL on Linux Using RPM Packages from Oracle</p><p><br></p><p>MySQL Community Edition的rpm包如下：</p><table><thead><tr><th>包名</th><th>描述</th></tr></thead><tbody><tr><td>mysql-community-server</td><td>Database server and related tools</td></tr><tr><td>mysql-community-client</td><td>MySQL client applications and tools</td></tr><tr><td>mysql-community-common</td><td>Common files for server and client libraries</td></tr><tr><td>mysql-community-server-minimal</td><td>Minimal installation of the database server and related tools</td></tr><tr><td>mysql-community-devel</td><td>Development header files and libraries for MySQL database client applications</td></tr><tr><td>mysql-community-libs</td><td>Shared libraries for MySQL database client applications</td></tr><tr><td>mysql-community-libs-compat</td><td>Shared compatibility libraries for previous MySQL installations</td></tr><tr><td>mysql-community-embedded</td><td>MySQL embedded library</td></tr><tr><td>mysql-community-embedded-devel</td><td>Development header files and libraries for MySQL as an embeddable library</td></tr><tr><td>mysql-community-test</td><td>Test suite for the MySQL server</td></tr></tbody></table><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#rpm -qpl mysql-community-server-version-distribution-arch.rpm</div><div class="line"></div><div class="line">#yum install mysql-community-&#123;server,client,common,libs&#125;-*</div><div class="line"></div><div class="line"></div><div class="line">wget http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql-community-server-5.7.20-1.el7.x86_64.rpm</div><div class="line">wget http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql-community-client-5.7.20-1.el7.x86_64.rpm</div><div class="line"></div><div class="line">yum install -y mysql-community-server-5.7.20-1.el7.x86_64.rpm mysql-community-client-5.7.20-1.el7.x86_64.rpm</div></pre></td></tr></table></figure><p><br></p><p><strong>Linux RPM包MySQL开发区的安装布局：</strong></p><table><thead><tr><th>文件或资源</th><th>位置</th></tr></thead><tbody><tr><td>Client programs and scripts</td><td>/usr/bin</td></tr><tr><td>mysqld server</td><td>/usr/sbin</td></tr><tr><td>configuration file</td><td>/etc/my.cnf</td></tr><tr><td>data directory</td><td>/var/lib/mysql</td></tr><tr><td>error log file</td><td>/var/log/mysqld.log</td></tr><tr><td>Value of secure_file_priv</td><td>/var/lib/mysql-files</td></tr><tr><td>System V init script</td><td>/etc/init.d/mysqld</td></tr><tr><td>Systemd service</td><td>mysqld</td></tr><tr><td>pid file</td><td>/var/run/mysql/mysqld.pid</td></tr><tr><td>socket</td><td>/var/lib/mysql/mysql.sock</td></tr><tr><td>Keyring directory</td><td>/var/lib/mysql-keyring</td></tr><tr><td>Unix manual pages</td><td>/usr/share/man</td></tr><tr><td>include (header) files</td><td>/usr/include/mysql</td></tr><tr><td>Libraries</td><td>/usr/lib/mysql</td></tr><tr><td>Miscellaneous support files (for example, error messages, and character set files)</td><td>/usr/share/mysql</td></tr></tbody></table><p><br></p><p>The installation also creates a user named mysql and a group named mysql on the system.</p><blockquote><p><strong>注意</strong><br>安装MySQL会在系统上生成一个名为mysql的用户和群组<br>安装以前的MySQL版本可能会创建<code>my.cnf</code>配置文件。强烈建议先将<code>my.cnf</code>进行迁移，然后删除它。之后才安装MySQL</p></blockquote><p><br><br><br></p><h3 id="用systemd管理MySQL-Server"><a href="#用systemd管理MySQL-Server" class="headerlink" title="用systemd管理MySQL Server"></a>用systemd管理MySQL Server</h3><p>Managing MySQL Server with systemd</p><p><br></p><h4 id="systemd综述"><a href="#systemd综述" class="headerlink" title="systemd综述"></a>systemd综述</h4><p>Overview of systemd</p><p><br></p><p><code>systemd</code>提供了MySQL Server的自动开启和关闭，使用<code>systemctl</code>命令进行管理。</p><p>或者，使用<code>system V</code>系统兼容的<code>service</code>命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">systemctl &#123;start|stop|restart|status&#125; mysqld</div><div class="line"></div><div class="line">service mysqld &#123;start|stop|restart|status&#125;</div></pre></td></tr></table></figure><p>对systemd的支持包括这些文佳：</p><ul><li>mysqld.service<ul><li>systemd服务单元配置文件，以及有关MySQL服务的详细信息</li></ul></li><li>mysqld@.service<ul><li>用于管理多个MySQL实例</li></ul></li><li>mysqld.tmpfiles.d<ul><li>包含支持临时文件功能的信息</li></ul></li><li>mysqld_pre_systemd<ul><li>支持单元文件的脚本</li></ul></li></ul><p><br></p><h4 id="为MySQL配置systemd"><a href="#为MySQL配置systemd" class="headerlink" title="为MySQL配置systemd"></a>为MySQL配置systemd</h4><p>Configuring systemd for MySQL</p><p><br></p><p>为MySQL添加或修改systemd选项，参考如下方法：</p><ul><li>使用一个本地化的systemd配置文件</li><li>安排systemd为MySQL Server进程设置环境变量</li><li>设置MYSQLD_OPTS systemd变量</li></ul><p>创建<code>/etc/systemd/system/mysqld.service</code>本地化systemd配置文件，这里讨论的是将此文件名作为<code>override.conf</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[Service]</div><div class="line">LimitNOFILE=max_open_files</div><div class="line">PIDFile=/path/to/pid/file</div><div class="line">Nice=nice_level</div><div class="line">LimitCore=core_file_limit</div><div class="line">Environment=<span class="string">"LD_PRELOAD=/path/to/malloc/library"</span></div><div class="line">Environment=<span class="string">"TZ=time_zone_setting"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#LimitNOFILE: 文件描述符数量</span></div><div class="line"><span class="comment">#LimitCore: 最大核心文件大小</span></div><div class="line"><span class="comment">#Nice: 优先级</span></div><div class="line"><span class="comment">#LD_PRELOAD: 特定内存分配库</span></div><div class="line"><span class="comment">#TZ: 指定时区</span></div></pre></td></tr></table></figure><p>修改mysqld:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl edit mysqld</div></pre></td></tr></table></figure><p>重新加载systemd配置，然后重启MySQL service：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">systemctl daemon-reload</div><div class="line"></div><div class="line">systemctl restart mysqld</div></pre></td></tr></table></figure><p>可在<code>override.conf</code>中设置如下参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[Service]</div><div class="line">PIDFile=/var/run/mysqld/mysqld-custom.pid</div><div class="line">ExecStart=</div><div class="line">ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld-custom.pid <span class="variable">$MYSQLD_OPTS</span></div></pre></td></tr></table></figure><p>在<code>/etc/sysconfig/mysql</code>下指定值：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LD_PRELOAD=/path/to/malloc/library</div><div class="line">TZ=time_zone_setting</div><div class="line"></div><div class="line"></div><div class="line">systemctl restart mysqld</div></pre></td></tr></table></figure><p><br></p><h4 id="使用systemd配置多个MySQL实例"><a href="#使用systemd配置多个MySQL实例" class="headerlink" title="使用systemd配置多个MySQL实例"></a>使用systemd配置多个MySQL实例</h4><p>Configuring Multiple MySQL Instances Using systemd</p><p><br></p><p>由于systemd具有在平台上管理多个MySQL实例的能力，而不必须需要<code>mysqld_multi</code>和<code>mysqld_multi.server</code>。</p><p>若要使用多实例(multiple-instance)功能，请修改<code>/etc/my.cnf</code>文件以包含每个实例的关键选项配置。<br>例如，管理replication01和replication02两个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">vim /etc/my.cnf</div><div class="line"></div><div class="line"></div><div class="line">[mysqld@replica01]</div><div class="line">datadir=/var/lib/mysql-replica01</div><div class="line">socket=/var/lib/mysql-replica01/mysql.sock</div><div class="line">port=3307</div><div class="line">log-error=/var/log/mysqld-replica01.log</div><div class="line"></div><div class="line"></div><div class="line">[mysqld@replica02]</div><div class="line">datadir=/var/lib/mysql-replica02</div><div class="line">socket=/var/lib/mysql-replica02/mysql.sock</div><div class="line">port=3308</div><div class="line">log-error=/var/log/mysqld-replica02.log</div></pre></td></tr></table></figure><p><strong>这里的名称使用<code>@</code>作为分隔符(delimiter)，因为这个是<code>systemd</code>支持的唯一分隔符。</strong></p><p>管理两个实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">systemctl start mysqld@replica01</div><div class="line">systemctl start mysqld@replica02</div><div class="line"></div><div class="line"></div><div class="line">systemctl enable mysqld@replica01</div><div class="line">systemctl enable mysqld@replica02</div><div class="line"></div><div class="line"></div><div class="line">#使用通配符</div><div class="line">systemctl status &apos;mysqld@replica*&apos;</div><div class="line"></div><div class="line"></div><div class="line">systemctl stop mysqld@replica0&#123;1,2&#125;</div></pre></td></tr></table></figure><p>对于同一个机器上的不同MySQL实例，systemd自动使用不同的单元文件。<br>在unit file中，<code>%I</code>和<code>%i</code>用于<code>@</code>标记后传入参数，用于管理特定实例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#像这样</span></div><div class="line">mysqld --defaults-group-suffix=@%I ...</div><div class="line"></div><div class="line"></div><div class="line">systemctl status mysqld@replica01</div><div class="line"></div><div class="line"><span class="comment"># mysqld@replica01.service - MySQL Server</span></div><div class="line"><span class="comment">#  Loaded: loaded (/usr/lib/systemd/system/mysqld@.service; disabled; vendor preset: disabled)</span></div><div class="line"><span class="comment">#  Active: active (running) since Tue 2018-02-27 12:18:34 CST; 1min 6s ago</span></div><div class="line"><span class="comment">#    Docs: man:mysqld(8)</span></div><div class="line"><span class="comment">#          http://dev.mysql.com/doc/refman/en/using-systemd.html</span></div><div class="line"><span class="comment"># Process: 3927 ExecStart=/usr/sbin/mysqld --defaults-group-suffix=@%I --daemonize --pid-file=/var/run/mysqld/mysqld-%i.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS)</span></div><div class="line"><span class="comment"># Process: 3845 ExecStartPre=/usr/bin/mysqld_pre_systemd %I (code=exited, status=0/SUCCESS)</span></div><div class="line"><span class="comment">#Main PID: 3930 (mysqld)</span></div><div class="line"><span class="comment">#  CGroup: /system.slice/system-mysqld.slice/mysqld@replica01.service</span></div><div class="line"><span class="comment">#          `-3930 /usr/sbin/mysqld --defaults-group-suffix=@replica01 --daemonize --pid-file=/var/run/mysqld/mysqld-replica01.pid</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#eb 27 12:18:27 zabbix.me systemd[1]: Starting MySQL Server...</span></div><div class="line"><span class="comment">#eb 27 12:18:34 zabbix.me systemd[1]: Started MySQL Server.</span></div></pre></td></tr></table></figure><p><br></p><h4 id="从mysqld-safe迁移到systemd"><a href="#从mysqld-safe迁移到systemd" class="headerlink" title="从mysqld_safe迁移到systemd"></a>从mysqld_safe迁移到systemd</h4><p>Migrating from mysqld_safe to systemd</p><p><br></p><p>因为<code>mysqld_safe</code>没有安装在使用<code>systemd</code>管理MySQL的平台上，所以以前需要为该程序指定选项：<code>[mysqld_safe]</code></p><ul><li>一些<code>[mysqld_safe]</code>的选项也能被<code>[mysqld]</code>支持</li><li>一些<code>[mysqld_safe]</code>的选项类似于<code>[mysqld]</code>选项</li></ul><p><br><br><br></p><h2 id="从源码安装MySQL"><a href="#从源码安装MySQL" class="headerlink" title="从源码安装MySQL"></a>从源码安装MySQL</h2><p>Installing MySQL from Source</p><p><br></p><p>从源代码构建MySQL使我们能够自定义构建参数(parameter)、编译器优化(compiler optimization)和安装位置(installation location)。</p><p>在使用源码安装前，请检查Oracle是否为你的平台生成预编译的二进制发行版，以及是否适合你。Oracle付出了很多努力确保提供的二进制文件具有最佳的性能选择。</p><p><strong>源码安装系统需求：</strong><br>使用源码安装MySQL需要多种开发工具。</p><p>使用源码安装MySQL，必须满足一下系统需求：</p><ul><li>CMake, which is used as the build framework on all platforms</li><li>A good make program</li><li>A working ANSI C++ compiler</li><li>The Boost C++ libraries are required to build MySQL</li><li>The ncurses library</li><li>Sufficient free memory</li><li>Perl is needed if you intend to run test scripts</li></ul><p>使用standard source distribution安装MySQL，需要以下工具来unpack分发文件：</p><ul><li>For a .tar.gz compressed tar file: <code>tar</code></li><li>For a .zip Zip archive: <code>zip</code></li><li>For an .rpm RPM package: <code>rpmbuild</code></li></ul><p><br><br><br></p><h3 id="用于源码安装的MySQL布局"><a href="#用于源码安装的MySQL布局" class="headerlink" title="用于源码安装的MySQL布局"></a>用于源码安装的MySQL布局</h3><p>MySQL Layout for Source Installation</p><p><br></p><p>默认地，再从源码编译后安装MySQL时，安装步骤会将文件安装在<code>/usr/local/mysql</code>下。</p><p><br><br><br></p><h3 id="使用标准源码发行版安装MySQL"><a href="#使用标准源码发行版安装MySQL" class="headerlink" title="使用标准源码发行版安装MySQL"></a>使用标准源码发行版安装MySQL</h3><p>Installing MySQL Using a Standard Source Distribution</p><p><br></p><p>从一个标准源码发行版安装MySQL：</p><ol><li>确保系统满足工具需求</li><li>获取发行文件</li><li>配置、构建和安装</li><li>执行安装后程序</li></ol><p><br></p><p>如果是source RPM:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpmbuild --rebuild --clean MySQL-VERSION.src.rpm</div></pre></td></tr></table></figure><p><br></p><p>如果是compressed tar file 或 zip archive source:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Preconfiguration setup</span></div><div class="line">shell&gt; groupadd mysql</div><div class="line">shell&gt; useradd -r -g mysql -s /bin/<span class="literal">false</span> mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Beginning of source-build specific instructions</span></div><div class="line">shell&gt; tar zxvf mysql-VERSION.tar.gz</div><div class="line">shell&gt; <span class="built_in">cd</span> mysql-VERSION</div><div class="line">shell&gt; mkdir bld</div><div class="line">shell&gt; <span class="built_in">cd</span> bld</div><div class="line">shell&gt; cmake ..</div><div class="line">shell&gt; make</div><div class="line">shell&gt; make install</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># End of source-build specific instructions</span></div><div class="line"><span class="comment"># Postinstallation setup</span></div><div class="line">shell&gt; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</div><div class="line">shell&gt; mkdir mysql-files</div><div class="line">shell&gt; chown mysql:mysql mysql-files</div><div class="line">shell&gt; chmod 750 mysql-files</div><div class="line">shell&gt; bin/mysqld --initialize --user=mysql</div><div class="line">shell&gt; bin/mysql_ssl_rsa_setup</div><div class="line">shell&gt; bin/mysqld_safe --user=mysql &amp;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Next command is optional</span></div><div class="line">shell&gt; cp support-files/mysql.server /etc/init.d/mysql.server</div></pre></td></tr></table></figure><p><strong>/sbin/nologin和/bin/false的区别</strong></p><ul><li>/bin/false是最严格的禁止login选项，一切服务都不能用<ul><li><code>mongod:x:996:994:mongod:/var/lib/mongo:/bin/false</code></li></ul></li><li>/sbin/nologin只是不允许系统login，可以使用其他服务<ul><li><code>ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</code></li></ul></li></ul><p><br></p><p><strong>执行预配置(preconfiguration)设置</strong></p><p>在Unix上，设置MySQL用户和组，用于运行和执行MySQL服务器和数据库目录。</p><p><br></p><p><strong>获得和解包distribution</strong></p><p>选择要解压分发的目录，并将位置更改到其中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tar zxvf mysql-VERSION.tar.gz</div><div class="line"></div><div class="line"><span class="comment">#gunzip &lt; mysql-VERSION.tar.gz | tar xvf -</span></div><div class="line"><span class="comment">#cmake -E tar zxvf mysql-VERSION.tar.gz</span></div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用开发源码树安装MySQL"><a href="#使用开发源码树安装MySQL" class="headerlink" title="使用开发源码树安装MySQL"></a>使用开发源码树安装MySQL</h3><p>Installing MySQL Using a Development Source Tree</p><p><br></p><p>install MySQL from the latest development source codew hich is hosted on GitHub: <a href="https://github.com/mysql/mysql-server" target="_blank" rel="noopener">https://github.com/mysql/mysql-server</a></p><p><strong>设置一个MySQL git repository</strong></p><ol><li>克隆MySQL git repository到本机</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/mysql/mysql-server.git</div></pre></td></tr></table></figure><ol><li>查看</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mysql-server</div></pre></td></tr></table></figure><ol><li>使用<code>git branch -r</code>查看远程MySQL分支</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mysql-server</div><div class="line"></div><div class="line">git branch -r</div></pre></td></tr></table></figure><ol><li>查看分支</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mysql-server</div><div class="line"></div><div class="line">git branch</div></pre></td></tr></table></figure><ol><li>切换分支</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mysql-server</div><div class="line"></div><div class="line">git checkout 5.7</div></pre></td></tr></table></figure><ol><li>获取远程MySQL git repository更新</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mysql-server</div><div class="line"></div><div class="line">git pull</div></pre></td></tr></table></figure><ol><li>检查提交历史</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mysql-server</div><div class="line"></div><div class="line">git <span class="built_in">log</span></div><div class="line"></div><div class="line"><span class="comment">#也可在MySQL GitHub上查看commit history</span></div></pre></td></tr></table></figure><ol><li>在克隆MySQL git repository并切换到需要的分支后，便可以从源代码构建MySQL Server。</li></ol><p>在生产机器上从分发源码树安装构件时要小心，安装命令可能会覆盖您的实时发行版安装。</p><p><br><br><br></p><h3 id="MySQL源码配置选项"><a href="#MySQL源码配置选项" class="headerlink" title="MySQL源码配置选项"></a>MySQL源码配置选项</h3><p>MySQL Source-Configuration Options</p><p><br></p><p>CMake程序提供了一个强大的如何配置MySQL源码发行版的控制。</p><p>具体链接参考: <a href="https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html</a></p><p><br><br><br></p><h3 id="处理MySQL编译问题"><a href="#处理MySQL编译问题" class="headerlink" title="处理MySQL编译问题"></a>处理MySQL编译问题</h3><p>Dealing with Problems Compiling MySQL</p><p><br></p><ul><li>如果CMake先前已经运行过，那么现在运行的CMake可能使用先前的调用过程中收集到的信息。这些信息存储在 CMakeCache.txt。在CMake启动时，它会寻找和读取此文件。</li><li>每次运行<code>CMake</code>，必须再次运行<code>make</code>才能重新编译。</li></ul><p>防止使用old object file或配置文件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make clean</div><div class="line">rm CMakeCache.txt</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="安装之后的设置和测试"><a href="#安装之后的设置和测试" class="headerlink" title="安装之后的设置和测试"></a>安装之后的设置和测试</h2><p>Postinstallation Setup and Testing</p><p><br></p><p>在安装MySQL后你应该做的事：</p><ul><li>如有必要，初始化数据目录并创建MySQL授权表</li><li>开启Server并确保它可以正常访问</li><li>将密码分配给授权表中的root用户</li><li>可选地，设置Server自启动</li><li>可选地，填写时区表，以便识别时区</li></ul><p><br></p><h3 id="初始化数据目录"><a href="#初始化数据目录" class="headerlink" title="初始化数据目录"></a>初始化数据目录</h3><p>Initializing the Data Directory</p><p><br></p><p>安装MySQL之后，必须初始化数据目录，包括mysql系统数据库中的表。有些安装方法会自动初始化，有些则需要手动初始化。<br>当然，如果修改了默认数据目录位置，那么也是需要手动初始化的。</p><p>初始化数据库目录，主要是包含了初始MySQL授权表(grant table)的MySQL服务器，这些表确定了如何允许用户连接到服务器。<br>但是，初始化数据目录是不会覆盖(overwrite)任何现有权限表，因此在任何情况下运行都是安全的。</p><p>数据目录初始化会在MySQL数据库汇总创建time zone，但不会填充它，所以它是空的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</div><div class="line"></div><div class="line">mkdir mysql-files</div><div class="line"></div><div class="line">chown mysql:mysql ./mysql-files</div><div class="line">chmod 750 ./mysql-files</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--user</span></div><div class="line"><span class="comment">#使数据库目录文件属于mysql用户，以确保Server有读取权限</span></div><div class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqld --initialize --user=mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#开启安全连接</span></div><div class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysql_ssl_rsa_setup</div></pre></td></tr></table></figure><p><br></p><h4 id="使用mysqld手动初始化数据目录"><a href="#使用mysqld手动初始化数据目录" class="headerlink" title="使用mysqld手动初始化数据目录"></a>使用mysqld手动初始化数据目录</h4><p>Initializing the Data Directory Manually Using mysqld</p><p><br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql/bin</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#使数据库目录文件属于mysql用户，以确保Server有读取权限</span></div><div class="line"><span class="comment">#默认是secure，会生成root初始密码</span></div><div class="line">./mysqld --initialize --user=mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#不生成root初始密码</span></div><div class="line">./bin/mysqld --initialize-insecure --user=mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定目录</span></div><div class="line">--basedir=/usr/<span class="built_in">local</span>/mysql</div><div class="line">--datadir=/var/lib/mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#或者将其写入配置文件</span></div><div class="line">vim /etc/my.cnf</div><div class="line"></div><div class="line">[mysqld]</div><div class="line">basedir=/usr/<span class="built_in">local</span>/mysql</div><div class="line">datadir=/var/lib/mysql</div><div class="line"></div><div class="line"><span class="comment">#指定配置文件初始化</span></div><div class="line">./mysqld --defaults-file=/etc/mysql.cnf --initialize --user=mysql</div></pre></td></tr></table></figure><p><br></p><h4 id="使用mysql-install-db初始化数据目录"><a href="#使用mysql-install-db初始化数据目录" class="headerlink" title="使用mysql_install_db初始化数据目录"></a>使用mysql_install_db初始化数据目录</h4><p>Initializing the Data Directory Manually Using mysql_install_db</p><p><br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql/bin</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#mysql_install_db命令会创建数据目录，并在数据目录下创建mysql数据库和授权表</span></div><div class="line">./mysql_install_db --user=mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定目录是必须的</span></div><div class="line">--basedir=/usr/<span class="built_in">local</span>/mysql</div><div class="line">--datadir=/var/lib/mysql</div><div class="line"></div><div class="line">./mysqld_safe --user=mysql &amp;</div><div class="line"><span class="comment">#systemctl start mysqld</span></div><div class="line"></div><div class="line">mysql -u root -p xxx</div><div class="line"></div><div class="line">mysql&gt;SET PASSWORD FOR <span class="string">'root'</span>@<span class="string">'localhost'</span> = PASSWORD(<span class="string">'new_password'</span>);</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Starting-the-Server"><a href="#Starting-the-Server" class="headerlink" title="Starting the Server"></a>Starting the Server</h3><ul><li>Start the MySQL server like this if your installation includes mysqld_safe<ul><li><code>/usr/local/mysql/binmysqld_safe --user=mysql &amp;</code></li></ul></li><li>Start the server like this if your installation includes systemd support<ul><li><code>systemctl start mysqld</code></li></ul></li><li>使用non-root用户运行MySQL服务很重要</li><li>如有错误请查看日志</li></ul><p><br><br><br></p><h3 id="Testing-the-Server"><a href="#Testing-the-Server" class="headerlink" title="Testing the Server"></a>Testing the Server</h3><p>执行一些简单测试以保证Server正常工作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#使用mysqladmin验证Server正在运行</span></div><div class="line">mysqladmin --<span class="built_in">help</span></div><div class="line"></div><div class="line">mysqladmin -uuser -ppasswd version</div><div class="line"></div><div class="line">mysqladmin -uuser -ppasswd variables</div><div class="line"></div><div class="line">mysqladmin -user -ppasswd shutdown</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 使用mysqlshow查看数据库</span></div><div class="line">mysqlshow -uuser -ppasswd</div><div class="line"></div><div class="line"><span class="comment">#查看指定数据库信息</span></div><div class="line">mysqlshow -uuser -ppasswd mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#读取信息</span></div><div class="line"><span class="comment">#-e,Execute command and quit</span></div><div class="line">mysql -uuser -ppasswd -e <span class="string">"SELECT user, host from mysql.user"</span></div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="保护初始化MySQL账户"><a href="#保护初始化MySQL账户" class="headerlink" title="保护初始化MySQL账户"></a>保护初始化MySQL账户</h3><p>Securing the Initial MySQL Accounts</p><p><br></p><p>在安装MySQL后，root账户密码可能已经被分配。</p><p><code>mysql.user</code>授权表定义了初始化MySQL用户账户和它们的访问权限。<br>MySQL5.7只创建了一个<code>&#39;root&#39;@&#39;localhost&#39;</code>账户，但早期的版本可能有多个用户。</p><p>请务必为每一个MySQL账户创建密码。</p><p>查看用户：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#存储在authentication_string列中的密码可能包含无法正常显示的二进制数据</span></div><div class="line"><span class="comment">#所以将其转换为十六进制</span></div><div class="line">mysql&gt; SELECT user, host, hex(authentication_string) FROM mysql.user;</div><div class="line">mysql&gt; SELECT user, host, authentication_string FROM mysql.user;</div><div class="line"></div><div class="line"><span class="comment">#或</span></div><div class="line">mysql -uuser -ppasswd -e <span class="string">"SELECT user, host, hex(authentication_string) FROM mysql.user;"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#5.7以前的版本</span></div><div class="line">mysql&gt; mysql&gt; SELECT user, host, password FROM mysql.user;</div><div class="line"></div><div class="line"><span class="comment">#或</span></div><div class="line">mysql -uuser -ppasswd -e <span class="string">"SELECT user, host, password FROM mysql.user;"</span></div></pre></td></tr></table></figure><p><br></p><p><strong>为root账户分配密码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#5.7.6</div><div class="line">mysql&gt; ALTER USER user IDENTIFIED BY &apos;new_passwd&apos;;</div><div class="line"></div><div class="line">mysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;new_passwd&apos;;</div><div class="line"></div><div class="line"></div><div class="line">#5.7.6前</div><div class="line">mysql&gt; SET PASSWORD FOR username = PASSWORD(&apos;new_passwd&apos;);</div><div class="line"></div><div class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;new_passwd&apos;);</div></pre></td></tr></table></figure><p><br></p><p><strong>给anonymous账户分配密码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SET PASSWORD FOR &apos;&apos;@&apos;localhost&apos; = PASSWORD(&apos;new_passwd&apos;);</div></pre></td></tr></table></figure><p><br></p><p><strong>移除匿名账户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; DROP USER &apos;&apos;@&apos;localhost&apos;;</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="升级或降级MySQL"><a href="#升级或降级MySQL" class="headerlink" title="升级或降级MySQL"></a>升级或降级MySQL</h2><p>Upgrading or Downgrading MySQL</p><p><br></p><ul><li>升级是一个常见的过程。请在测试系统上确保运行正常后再实施到生产环境</li><li>降级不太常见。一般是由于新版本在生产环境上发生某些兼容性或性能问题，并且是在测试环境中没有发现的情况下，从而需要降级。请现在测试系统上运行正常后再实施到生产环境。</li></ul><p><br><br><br></p><h3 id="升级MySQL"><a href="#升级MySQL" class="headerlink" title="升级MySQL"></a>升级MySQL</h3><p>请使用有管理权限的MySQL账户执行升级相关命令。(如root账户)</p><p><br></p><h4 id="MySQL升级策略"><a href="#MySQL升级策略" class="headerlink" title="MySQL升级策略"></a>MySQL升级策略</h4><p>MySQL Upgrade Strategies</p><p><br></p><p><strong>升级方法</strong></p><ul><li>直接升级(In-Place Upgrade)<ul><li>包含关闭旧版MySQL，替换为新的MySQL版本，在现有数据目录上重启MySQL，运行<code>mysql_upgrade</code></li></ul></li><li>逻辑升级(Logical Upgrade)<ul><li>包含使用<code>mysqldump</code>导出现有数据文件，安装新版MySQL，导入数据文件到新版MySQL，运行<code>mysql_upgrade</code></li></ul></li></ul><p><br></p><p><strong>升级路径</strong></p><ul><li>只支持GA release之间</li><li>这是一个发行系列的升级<ul><li>如5.6.x到5.6.y</li></ul></li><li>升级到下一个版本之前，建议先升级到最新版本<ul><li>如先升级到5.6最新版，再升级到5.7</li></ul></li><li>不支持跳版本升级<ul><li>如5.5到5.7</li></ul></li></ul><p><br></p><p><strong>升级之前</strong></p><ul><li>升级之前，请一定备份数据</li><li>查看新版本的Release Note<ul><li>删除和增加了什么功能</li></ul></li><li>新版本依赖什么</li><li>如果在InnoDB中使用XA事务，则在升级之前运行XA恢复以检查未提交的XA事务</li><li>如果MySQL数据量很大，就地升级以后可能需要很长的时间才能进行转换<ul><li>你可能会发现创建一个”dummy”数据库实例是很有用的，以及评估可能需要哪些转换以及执行这些转换所涉及的工作</li></ul></li><li>无论在你安装或升级到一个MySQL新版本，建议重建和重装MySQL language interface<ul><li>如PHP MySQL扩展</li></ul></li></ul><p><br></p><p><strong>直接升级</strong></p><ul><li>配置MySQL执行slow shutdown</li></ul><p>innoDB在关闭前执行一个完整的清除和更改缓冲区合并，这确保数据文件在不同的版本的文件格式做好充分准备。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u root -p --execute=<span class="string">"SET GLOBAL innodb_fast_shutdown=0"</span></div></pre></td></tr></table></figure><ul><li>关闭MySQL Server</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -uroot -p shutdown</div></pre></td></tr></table></figure><ul><li><p>升级MySQL</p></li><li><p>开启新版MySQL</p></li><li><p>运行mysql_upgrade</p></li></ul><p><code>mysql_upgrade</code>检查所有数据库中的所有表与当前版本MySQL的不兼容性。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql_upgrade -uroot -p</div><div class="line"></div><div class="line"><span class="comment">#Upgrade process completed successfully.</span></div><div class="line"><span class="comment">#Checking if update is needed.</span></div></pre></td></tr></table></figure><ul><li>关闭和重启MySQL Server来确保改变生效</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysqladmin -uroot -p shutdown</div><div class="line"></div><div class="line">systemctl start mysqld</div></pre></td></tr></table></figure><p><br></p><p><strong>逻辑升级</strong></p><ul><li>导出所有数据</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysqldump -uroot -p  --all-databases --force &gt; mysqldb_backup.sql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-f, --force         Continue even if we get an SQL error</span></div><div class="line"><span class="comment">#Use the --routines and --events options if your databases include stored programs</span></div><div class="line"><span class="comment">#--add-drop-database Add a DROP DATABASE before each create.</span></div><div class="line">mysqldump -uroot -p --add-drop-table --routines --events --all-databases --force &gt; mysqldb_backup.sql</div></pre></td></tr></table></figure><ul><li>关闭MySQL Server</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqladmin -uroot -p shutdown</div></pre></td></tr></table></figure><ul><li><p>安装新版MySQL</p></li><li><p>初始化MySQL并启动</p></li><li><p>载入数据文件</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -uroot -p --force &lt; ./mysqldb_backup.sql</div></pre></td></tr></table></figure><ul><li>运行mysql_upgrade</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql_upgrade -uroot -p</div><div class="line"></div><div class="line"><span class="comment">#Upgrade process completed successfully.</span></div><div class="line"><span class="comment">#Checking if update is needed.</span></div></pre></td></tr></table></figure><ul><li>关闭并重启MySQL Server以确保更改生效</li></ul><p><br></p><h4 id="通过MySQL-Yum-Repository进行升级"><a href="#通过MySQL-Yum-Repository进行升级" class="headerlink" title="通过MySQL Yum Repository进行升级"></a>通过MySQL Yum Repository进行升级</h4><p>Upgrading MySQL with the MySQL Yum Repository</p><p><br></p><p><strong>选择一个target series</strong></p><p>默认情况下，MySQL Yum Repository会将MySQL升级到该release系列的最新版本。如5.7.1升级到5.7.10。</p><p>如果要升级到其他release(如5.6到5.7)，就必须要先禁用此subrepository，并选择和启用新的subrepository。</p><p>As a general rule, to upgrade from one release series to another, go to the next series rather than skipping a series.</p><p><br></p><p><strong>升级MySQL</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum update mysql-server mysql-client</div></pre></td></tr></table></figure><p><br></p><p><strong>重启MySQL</strong></p><p>MySQL Server总是在Yum更新之后重启，一旦重启，请运行<code>mysql_upgrade</code>来检查旧数据与升级软件之间的任何不兼容问题。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql_upgrade -uroot -p</div><div class="line"></div><div class="line"><span class="comment">#Upgrade process completed successfully.</span></div><div class="line"><span class="comment">#Checking if update is needed.</span></div></pre></td></tr></table></figure><p><br></p><p><strong>升级Shared Client Libraries</strong></p><p>所以说，用yum repository安装软件是很方便的。不管是在管理还是升级等方面…</p><p><br></p><h4 id="通过直接下载RPM包升级MySQL"><a href="#通过直接下载RPM包升级MySQL" class="headerlink" title="通过直接下载RPM包升级MySQL"></a>通过直接下载RPM包升级MySQL</h4><p>直接下载mysql相应组件的rpm进行升级。<br>建议备份好配置文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql-community-server-5.7.20-1.el7.x86_64.rpm</div><div class="line">wget http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql-community-client-5.7.20-1.el7.x86_64.rpm</div><div class="line"></div><div class="line"></div><div class="line">yum install mysql-community-server-5.7.20-1.el7.x86_64.rpm mysql-community-client-5.7.20-1.el7.x86_64.rpm</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="mysql降级"><a href="#mysql降级" class="headerlink" title="mysql降级"></a>mysql降级</h3><p>MySQL降级类似于MySQL升级。也包含有直接降级和逻辑降级。</p><p><br><br><br></p><h3 id="重建或修复表或索引"><a href="#重建或修复表或索引" class="headerlink" title="重建或修复表或索引"></a>重建或修复表或索引</h3><p>Rebuilding or Repairing Tables or Indexes</p><p><br></p><ul><li>MySQL处理数据类型和字符集的方式的更改</li><li>表维修或升级(mysqlcheck, mysql_upgrade)</li></ul><p>重建表的方法：</p><ul><li>Dump and Reload</li><li>ALTER TABLE</li><li>REPAIR TABLE</li></ul><p><br></p><p><strong>Dump and Reload Method</strong></p><p>由于MySQL升级/降级之后，不同版本的MySQL无法处理这些表，则需要转储和重载的方法来重建表。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysqldump -uroot -p --all-databases --force &gt; mysql_backdb.sql</div><div class="line">mysql -uroot -p --force &lt; mysql_backdb.sql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#某个库或表</span></div><div class="line">mysqldump -uroot -p --databases <span class="built_in">test</span> --force &gt; db_test.sql</div><div class="line">mysql -uroot -p <span class="built_in">test</span> &lt; db_test.sql</div><div class="line"></div><div class="line">mysqldump -uroot -p --databases <span class="built_in">test</span> --tables table222 &gt; table222.sql</div><div class="line">mysql -uroot -p <span class="built_in">test</span>  &lt; table222.sql</div></pre></td></tr></table></figure><p><br></p><p><strong>ALTER TABLE Method</strong></p><p>更改表以使用它已经拥有的存储引擎。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE test ENGINE = InnoDB;</div></pre></td></tr></table></figure><p><br></p><p><strong>REPAIR TABLE Method</strong></p><p><code>REPAIR TABLE</code>仅适用于MyISAM， ARCHIVE和 csv 表。</p><p><code>mysqlcheck --repair</code>提供了对<code>REPAIR TABLE</code>的命令行访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">REPAIR TABLE t1;</div><div class="line"></div><div class="line"></div><div class="line">mysqlcheck --repair --databases db_name ...</div><div class="line">mysqlcheck --repair --all-databases</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="复制MySQL数据库到其他机器"><a href="#复制MySQL数据库到其他机器" class="headerlink" title="复制MySQL数据库到其他机器"></a>复制MySQL数据库到其他机器</h3><p>Copying MySQL Databases to Another Machine</p><p><br></p><p>在需要为不同体系架构之间传输MySQL数据库时，可使用<code>mysqldump</code>创建包含SQL语句的<code>.sql</code>文件，然后复制到另外的计算机上，将其作为输入提供给MySQL客户端。</p><p>不要忘记复制mysql数据库，因为这个存储授权表的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysqldump --host &apos;remote-host&apos; -uxxx -p --compress --all-databases | mysql -uxxx -p</div><div class="line"></div><div class="line">mysqldump --host &apos;remote-host&apos; -uxxx -p --compress db_name | mysql -uxxx -p db_name</div><div class="line"></div><div class="line"></div><div class="line">mysqladmin -uxxx -p flush-privileges</div></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h1><p>如何使用MySQL client程序来创建和使用数据库。</p><p><br></p><h2 id="连接和断开服务器"><a href="#连接和断开服务器" class="headerlink" title="连接和断开服务器"></a>连接和断开服务器</h2><p>Connecting to and Disconnecting from the Server</p><p><br></p><p>Like this:</p><ul><li>不建议把密码直接写在命令行上</li><li>host表示了MySQL Server运行在的机器</li><li>某些MySQL允许匿名用户连接</li><li><code>-ppassword, not as -p password</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql --host host --user username -p</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#maybe not default port</span></div><div class="line">mysql --host host --user username -p  --port port</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#匿名用户连接</span></div><div class="line">mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#退出</span></div><div class="line">mysql&gt; QUIT</div><div class="line"><span class="comment">#Unix</span></div><div class="line">mysql&gt; Ctrl+D</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="输入查询"><a href="#输入查询" class="headerlink" title="输入查询"></a>输入查询</h2><p>Entering Queries</p><p><br></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#简单查询</div><div class="line">mysql&gt; SELECT VERSION(), CURRENT_DATE;</div><div class="line"></div><div class="line"></div><div class="line">#简单计算</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">SIN</span>(<span class="keyword">PI</span>()/<span class="number">2</span>), (<span class="number">4</span>+<span class="number">1</span>)*<span class="number">5</span>;</div><div class="line"></div><div class="line"></div><div class="line">#一行中输入多个语句</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>(); <span class="keyword">SELECT</span> <span class="keyword">NOW</span>();</div><div class="line"></div><div class="line"></div><div class="line">#多行输入一个命令</div><div class="line">mysql&gt; SELECT</div><div class="line">    -&gt; USER()</div><div class="line">    -&gt; ,</div><div class="line">    -&gt; CURRENT_DATE;</div></pre></td></tr></table></figure><p><img src="/images/MySQL/20180301101009.jpg" alt="MySQL简单查询"></p><p><br></p><p>这QUERY说明了有关MySQL的几件事：</p><ul><li>MySQL查询通常由一个<code>SQL statement</code>和<code>;</code>组成</li><li>MySQL将查询发送给服务器并返回结果，然后打印下一个<code>mysql&gt;</code>提示</li><li>MySQL以表格形式(rows and columns)显示查询输出</li><li>MySQL显示返回多少行，以及执行查询花费了多长时间</li><li>MySQL查询不区分大小写，但建议使用大写</li><li>MySQL支持在一行中输入多个语句</li><li>MySQL支持一个命令多行输入</li></ul><p><br></p><p><strong>MySQL提示符：</strong></p><table><thead><tr><th>Prompt</th><th>Meaning</th></tr></thead><tbody><tr><td><code>mysql&gt;</code></td><td>准备新查询</td></tr><tr><td><code>-&gt;</code></td><td>等待多行查询的下一行</td></tr><tr><td><code>&#39;&gt;</code></td><td>等待下一行，等待单引号开头的字符串的完成</td></tr><tr><td><code>&quot;&gt;</code></td><td>等待下一行，等待双引号字开头的字符串的完成</td></tr><tr><td><code>\</code>&gt;`</td><td>等待下一行，等待以反引号开始的标识符的完成</td></tr><tr><td><code>/*&gt;</code></td><td>等待下一行，等待以<code>/*</code>开头的注释的完成–&gt;<code>/*comments*/</code></td></tr></tbody></table><p><br><br><br></p><h2 id="创建和使用数据库"><a href="#创建和使用数据库" class="headerlink" title="创建和使用数据库"></a>创建和使用数据库</h2><p>Creating and Using a Database</p><p><br></p><p>大致操作：</p><ul><li>Create a database</li><li>Create a table</li><li>Load data into the table</li><li>Retrieve data from the table in various ways</li><li>Use multiple tables</li></ul><p><br></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#显示数据库</div><div class="line">#不能显示你没有权限的数据库</div><div class="line">mysql&gt; SHOW DATABASES;</div><div class="line"></div><div class="line">#mysql数据库描述用户访问权限</div><div class="line">#test数据库通常作为用户尝试使用工作区</div><div class="line"></div><div class="line"></div><div class="line">#访问数据库</div><div class="line">mysql&gt; USE test;</div><div class="line"></div><div class="line">#USE和QUIT一样可以不使用分号，使用也无妨</div><div class="line">#USE只能是一个单行</div><div class="line"></div><div class="line"></div><div class="line">#授权</div><div class="line">#GRANT ALL ON da_name.table TO 'username'@'host';</div><div class="line">mysql&gt; GRANT ALL ON test.* TO 'test'@'127.0.0.1';</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="创建和选择数据库"><a href="#创建和选择数据库" class="headerlink" title="创建和选择数据库"></a>创建和选择数据库</h3><p>Creating and Selecting a Database</p><p><br></p><p><strong>Unix是区分大小写的(case-sensitive)，这与SQL keyword不一致。请注意。</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysql&gt; CREATE DATABASE db01;</div><div class="line"></div><div class="line">mysql&gt; USE db01;</div><div class="line"></div><div class="line">#也可在mysql连接时直接指定数据库</div><div class="line">mysql -u username -p db01</div><div class="line"></div><div class="line"></div><div class="line">#查看当前选择的数据库</div><div class="line">mysql&gt; SELECT DATABASE();</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>Creating a Table</p><p><br></p><p><strong>困难的部分是决定数据库的结构应该是什么： 你需要哪些表以及每个表中应该包含哪些列。</strong></p><p><code>VARCHAR</code>对于name，owner，species来说是一个不错的选择，因为column值的长度有所不同。<br><code>DATE</code>对于出生和死亡column来说很不错。<br>如果以后你发现你需要更长的字段，MySQL提供了一个<code>ALTER TABLE</code>语句来修改。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#创建一个宠物表</div><div class="line">mysql&gt; CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),</div><div class="line">    -&gt; species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SHOW TABLES;</div><div class="line"></div><div class="line"></div><div class="line">#验证表格</div><div class="line">#如果你忘记了表中列的名称或类型，使用DESCRIBE</div><div class="line">mysql&gt; DECRIBE pet;</div><div class="line">+<span class="comment">---------+-------------+------+-----+---------+-------+</span></div><div class="line">| Field   | Type        | Null | Key | Default | Extra |</div><div class="line">+<span class="comment">---------+-------------+------+-----+---------+-------+</span></div><div class="line">| name    | varchar(20) | YES  |     | NULL    |       |</div><div class="line">| owner   | varchar(20) | YES  |     | NULL    |       |</div><div class="line">| species | varchar(20) | YES  |     | NULL    |       |</div><div class="line">| sex     | char(1)     | YES  |     | NULL    |       |</div><div class="line">| birth   | date        | YES  |     | NULL    |       |</div><div class="line">| death   | date        | YES  |     | NULL    |       |</div><div class="line">+<span class="comment">---------+-------------+------+-----+---------+-------+</span></div><div class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="将数据载入表格"><a href="#将数据载入表格" class="headerlink" title="将数据载入表格"></a>将数据载入表格</h3><p>Loading Data into a Table</p><p><br></p><p>假设pet表信息如下：</p><table><thead><tr><th>name</th><th>owner</th><th>species</th><th>sex</th><th>birth</th><th>death</th></tr></thead><tbody><tr><td>PetA</td><td>Aa</td><td>cat</td><td>f</td><td>1993-02-04</td><td></td></tr><tr><td>PetB</td><td>Bb</td><td>cat</td><td>m</td><td>1994-03-17</td><td></td></tr><tr><td>PetC</td><td>Cc</td><td>dog</td><td>f</td><td>1989-05-13</td><td></td></tr><tr><td>PetD</td><td>Aa</td><td>dog</td><td>m</td><td>1979-08-25</td><td>1995-02-21</td></tr><tr><td>PetE</td><td>Cc</td><td>bird</td><td></td><td>1991-02-17</td><td></td></tr></tbody></table><p><br></p><p>你可以创建一个<code>pet.txt</code>文本文件，每行包含一个记录，值由制表符分割，并按照<code>CREATE TABLE</code>语句中列出的顺序给出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vim pet.txt</div><div class="line"></div><div class="line"></div><div class="line">PetA    Aa     cat    f      1993-02-04    \N</div><div class="line">PetB    Bb     cat    m      1994-03-17    \N</div><div class="line">PetC    Cc     dog    f      1989-05-13    \N</div><div class="line">PetD    Aa     dog    m      1979-08-25    1995-02-21</div><div class="line">PetE    Cc     bird  \N      1991-02-17    \N</div></pre></td></tr></table></figure><p>将<code>pet.txt</code>载入<code>pet</code>表中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">mysql&gt; LOAD DATA LOCAL INFILE '/path/file.txt' INTO TABLE table_name;</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; LOAD DATA LOCAL INFILE '/home/zhang/pet.txt' INTO TABLE pet;</div><div class="line">Query OK, 5 rows affected, 0 warnings (0.00 sec)</div><div class="line">Records: 5  Deleted: 0  Skipped: 0  Warnings: 0</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM pet;</div><div class="line">+<span class="comment">-------+-------+---------+------+------------+------------+</span></div><div class="line">| name  | owner | species | sex  | birth      | death      |</div><div class="line">+<span class="comment">-------+-------+---------+------+------------+------------+</span></div><div class="line">| PetA  |  Aa   |  cat    | f    | 1993-02-04 | NULL       |</div><div class="line">| PetB  |  Bb   |  cat    | m    | 1994-03-17 | NULL       |</div><div class="line">| PetC  |  Cc   |  dog    | f    | 1989-05-13 | NULL       |</div><div class="line">| PetD  |  Aa   |  dog    | m    | 1979-08-25 | 1995-02-21 |</div><div class="line">| PetE  |  Cc   |  bird   | NULL | 1991-02-17 | NULL       |</div><div class="line">+<span class="comment">-------+-------+---------+------+------------+------------+</span></div><div class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#通过命令行载入</div><div class="line">mysql&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> pet</div><div class="line">    -&gt; <span class="keyword">VALUES</span> (<span class="string">'PetF'</span>, <span class="string">'Ff'</span>, <span class="string">'hamster'</span>, <span class="string">'f'</span>, <span class="string">'1999-03-21'</span>, <span class="literal">NULL</span>)</div><div class="line">    -&gt; ;</div><div class="line">Query OK, 1 row affected (0.00 sec)</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="从表中检索信息"><a href="#从表中检索信息" class="headerlink" title="从表中检索信息"></a>从表中检索信息</h3><p>Retrieving Information from a Table</p><p><br></p><p><code>SELECT</code>语句用于从表中提取信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> what_to_select</div><div class="line"><span class="keyword">FROM</span> which_table</div><div class="line"><span class="keyword">WHERE</span> condition;</div></pre></td></tr></table></figure><p><br></p><h4 id="查询所有数据"><a href="#查询所有数据" class="headerlink" title="查询所有数据"></a>查询所有数据</h4><p>Selecting All Data</p><p><br></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM pet;</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; DELETE FROM pet;</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; UPDATE pet SET birth = '1989-06-17' WHERE name = 'PetC';</div></pre></td></tr></table></figure><p><br></p><h4 id="查询特定行"><a href="#查询特定行" class="headerlink" title="查询特定行"></a>查询特定行</h4><p>Selecting Particular Rows</p><p><br></p><p>当一个表很大时，你通常不想看到整个表。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#条件查询</div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM pet WHERE name = 'PetA';</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM pet WHERE owner = 'Cc';</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM pet WHERE birth &gt;= '1990-01-01';</div><div class="line"></div><div class="line"></div><div class="line">#AND</div><div class="line">mysql&gt; SELECT * FROM pet WHERE species = 'dog' AND sex = 'f';</div><div class="line"></div><div class="line"></div><div class="line">#OR</div><div class="line">mysql&gt; SELECT * FROM pet WHERE species = 'dog' OR species = 'bird';</div><div class="line"></div><div class="line"></div><div class="line">#AND和OR也可以混合使用</div><div class="line">mysql&gt; SELECT * FROM pet WHERE (species = 'cat' AND sex = 'm') OR (species = 'dog' AND sex='f');</div></pre></td></tr></table></figure><p><br></p><h4 id="查询特定列"><a href="#查询特定列" class="headerlink" title="查询特定列"></a>查询特定列</h4><p>Selecting Particular Columns</p><p><br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT name FROM pet;</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SELECT name, species FROM pet;</div><div class="line"></div><div class="line"></div><div class="line">#获取唯一结果</div><div class="line">mysql&gt; SELECT DISTINCT species FROM pet;</div><div class="line">+<span class="comment">---------+</span></div><div class="line">| species |</div><div class="line">+<span class="comment">---------+</span></div><div class="line">| cat     |</div><div class="line">| dog     |</div><div class="line">| bird    |</div><div class="line">+<span class="comment">---------+</span></div><div class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, species, birth <span class="keyword">FROM</span> pet <span class="keyword">WHERE</span> species = <span class="string">'dog'</span> <span class="keyword">OR</span> species = <span class="string">'cat'</span>;</div></pre></td></tr></table></figure><p><br></p><h4 id="行排序"><a href="#行排序" class="headerlink" title="行排序"></a>行排序</h4><p>Sorting Rows</p><p><br></p><p>使用<code>ORDER BY</code>语句对结果进行排序。默认排序顺序是升序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT name, birth FROM pet ORDER BY birth;</div><div class="line">+<span class="comment">------+------------+</span></div><div class="line">| name | birth      |</div><div class="line">+<span class="comment">------+------------+</span></div><div class="line">| PetD | 1979-08-25 |</div><div class="line">| PetC | 1989-06-17 |</div><div class="line">| PetE | 1991-02-17 |</div><div class="line">| PetA | 1993-02-04 |</div><div class="line">| PetB | 1994-03-17 |</div><div class="line">+<span class="comment">------+------------+</span></div><div class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div><div class="line"></div><div class="line"></div><div class="line">#倒序</div><div class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, birth <span class="keyword">FROM</span> pet <span class="keyword">ORDER</span> <span class="keyword">BY</span> birth <span class="keyword">DESC</span>;</div></pre></td></tr></table></figure><p>可对多列进行排序，也可按不同的方向对不同的列进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT name, species, birth FROM pet</div><div class="line">    -&gt; ORDER BY species, birth DESC;</div><div class="line">+<span class="comment">------+---------+------------+</span></div><div class="line">| name | species | birth      |</div><div class="line">+<span class="comment">------+---------+------------+</span></div><div class="line">| PetE | bird    | 1991-02-17 |</div><div class="line">| PetB | cat     | 1994-03-17 |</div><div class="line">| PetA | cat     | 1993-02-04 |</div><div class="line">| PetC | dog     | 1989-06-17 |</div><div class="line">| PetD | dog     | 1979-08-25 |</div><div class="line">+<span class="comment">------+---------+------------+</span></div><div class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, species, birth <span class="keyword">FROM</span> pet</div><div class="line">    -&gt; <span class="keyword">ORDER</span> <span class="keyword">BY</span> species <span class="keyword">DESC</span>, birth <span class="keyword">DESC</span></div></pre></td></tr></table></figure><p><br></p><h4 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h4><p>Date Calculations</p><p><br></p><p>MySQL提供了几个函数用于日期计算。如计算年龄或提取日期一部分等。</p><p><br></p><ul><li><code>TIMESTAMPDIFF()</code><ul><li>使用<code>TIMESTAMPDIFF()</code>函数计算pet的年龄。它的两个参数为两个相隔的日期</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT name, species, birth, CURDATE(),</div><div class="line">    -&gt; TIMESTAMPDIFF(YEAR, birth, CURDATE()) AS age</div><div class="line">    -&gt; FROM pet</div><div class="line">    -&gt; ORDER BY age DESC;</div><div class="line">+<span class="comment">------+---------+------------+------------+------+</span></div><div class="line">| name | species | birth      | CURDATE()  | age  |</div><div class="line">+<span class="comment">------+---------+------------+------------+------+</span></div><div class="line">| PetD | dog     | 1979-08-25 | 2018-03-01 |   38 |</div><div class="line">| PetC | dog     | 1989-06-17 | 2018-03-01 |   28 |</div><div class="line">| PetE | bird    | 1991-02-17 | 2018-03-01 |   27 |</div><div class="line">| PetA | cat     | 1993-02-04 | 2018-03-01 |   25 |</div><div class="line">| PetB | cat     | 1994-03-17 | 2018-03-01 |   23 |</div><div class="line">+<span class="comment">------+---------+------------+------------+------+</span></div><div class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div><div class="line"></div><div class="line"></div><div class="line">#死去的pet的age</div><div class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, species, birth, death,</div><div class="line">    -&gt; <span class="keyword">TIMESTAMPDIFF</span>(<span class="keyword">YEAR</span>, birth, death) <span class="keyword">AS</span> age</div><div class="line">    -&gt; <span class="keyword">FROM</span> pet</div><div class="line">    -&gt; <span class="keyword">WHERE</span> death <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">    -&gt; <span class="keyword">ORDER</span> <span class="keyword">BY</span> age;</div><div class="line">+<span class="comment">------+---------+------------+------------+------+</span></div><div class="line">| name | species | birth      | death      | age  |</div><div class="line">+<span class="comment">------+---------+------------+------------+------+</span></div><div class="line">| PetD | dog     | 1979-08-25 | 1995-02-21 |   15 |</div><div class="line">+<span class="comment">------+---------+------------+------------+------+</span></div><div class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure><p><br></p><ul><li><code>YEAR()</code><ul><li>年</li></ul></li><li><code>MONTH()</code><ul><li>月</li></ul></li><li><code>DAYOFMONTH()</code><ul><li>日</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT name, birth,</div><div class="line">    -&gt; YEAR(birth) AS bir_year,</div><div class="line">    -&gt; MONTH(birth) AS bir_month,</div><div class="line">    -&gt; DAYOFMONTH(birth) AS bir_day</div><div class="line">    -&gt; FROM pet;</div><div class="line">+<span class="comment">------+------------+----------+-----------+---------+</span></div><div class="line">| name | birth      | bir_year | bir_month | bir_day |</div><div class="line">+<span class="comment">------+------------+----------+-----------+---------+</span></div><div class="line">| PetA | 1993-02-04 |     1993 |         2 |       4 |</div><div class="line">| PetB | 1994-03-17 |     1994 |         3 |      17 |</div><div class="line">| PetC | 1989-06-17 |     1989 |         6 |      17 |</div><div class="line">| PetD | 1979-08-25 |     1979 |         8 |      25 |</div><div class="line">| PetE | 1991-02-17 |     1991 |         2 |      17 |</div><div class="line">+<span class="comment">------+------------+----------+-----------+---------+</span></div><div class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#查找生日是<span class="number">2</span>月的pet</div><div class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, birth <span class="keyword">FROM</span> pet <span class="keyword">WHERE</span> <span class="keyword">MONTH</span>(birth) =<span class="number">2</span>;</div><div class="line">+<span class="comment">------+------------+</span></div><div class="line">| name | birth      |</div><div class="line">+<span class="comment">------+------------+</span></div><div class="line">| PetA | 1993-02-04 |</div><div class="line">| PetE | 1991-02-17 |</div><div class="line">+<span class="comment">------+------------+</span></div></pre></td></tr></table></figure><p><br></p><ul><li><code>DATE_ADD()</code><ul><li>将日期间隔添加到给定日期</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT name, birth FROM pet</div><div class="line">    -&gt; WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(), INTERVAL 1 MONTH));</div></pre></td></tr></table></figure><p><br></p><h4 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h4><p>Working with NULL Values</p><p><br></p><p>从概念上讲，NULL value意味着<strong>一个缺失的未知值</strong>，它与其它值在某种程度上是不同的。</p><ul><li>使用<code>IS NULL</code>和<code>IS NOT NULL</code>操作符</li><li>不能对NULL value使用算术运算符(arithmetic cpmparison operators)<ul><li>如：<code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;&gt;</code></li><li>任何对NULL value的算术运算符的结果也是NULL value，所以无法得到有意义的结果</li></ul></li><li>在MySQL中，0或NULL表示false，其他任何值都意味着true</li><li>两个NULL在<code>GROUP BY</code>中被认为是相等的</li><li>NULL在<code>ORDER BY</code>正向排序中首先显示。反之，最后显示</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT 1 IS NULL, 1 IS NOT NULL;</div><div class="line">+<span class="comment">-----------+---------------+</span></div><div class="line">| 1 IS NULL | 1 IS NOT NULL |</div><div class="line">+<span class="comment">-----------+---------------+</span></div><div class="line">|         0 |             1 |</div><div class="line">+<span class="comment">-----------+---------------+</span></div></pre></td></tr></table></figure><p>因此，完全可以将一个<strong>zero</strong>或<strong>empty string</strong>插入到一个<strong>NOT NULL</strong>的column中，因为这些值NOT NULL。</p><p><br></p><h4 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h4><p>Pattern Matching</p><p><br></p><p>MySQL提供标准的SQL模式匹配以及基于扩展正则表达式的模式匹配形式。类似于Unix实用程序(vi, grep, sed…)</p><p>SQL模式匹配允许:</p><ul><li>使用<code>_</code>来匹配可以使用的任意单字符(single character)</li><li>使用<code>%</code>来匹配可以使用的任意数目的字符(arbitrary number of characters)</li><li>SQL模式不区分大小写</li><li>使用<code>LIKE</code>或<code>NOT LIKE</code>而不是<code>=</code>或<code>&lt;&gt;</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM pet WHERE name LIKE '%b';</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| name | owner | species | sex  | birth      | death |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| PetB | Bb    | cat     | m    | 1994-03-17 | NULL  |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM pet WHERE name LIkE '___A' or name LIKE '___C';</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| name | owner | species | sex  | birth      | death |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| PetA | Aa    | cat     | f    | 1993-02-04 | NULL  |</div><div class="line">| PetC | Cc    | dog     | f    | 1989-06-17 | NULL  |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div></pre></td></tr></table></figure><p><br></p><p>MySQL提供的其它类型的模式匹配使用扩展的正则表达式：</p><ul><li><code>REGEXP</code> 或 <code>RLIKE</code></li><li><code>NOT REGEXP</code> 或 <code>NOT RLIKE</code></li><li>了解正则表达式知识</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE '^pet[AB]';</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| name | owner | species | sex  | birth      | death |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| PetA | Aa    | cat     | f    | 1993-02-04 | NULL  |</div><div class="line">| PetB | Bb    | cat     | m    | 1994-03-17 | NULL  |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM pet WHERE owner RLIKE 'c$';</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| name | owner | species | sex  | birth      | death |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| PetC | Cc    | dog     | f    | 1989-06-17 | NULL  |</div><div class="line">| PetE | Cc    | bird    | NULL | 1991-02-17 | NULL  |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#包含某个字符</div><div class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE 'ete';</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| name | owner | species | sex  | birth      | death |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| PetE | Cc    | bird    | NULL | 1991-02-17 | NULL  |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#匹配字符个数</div><div class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE '^....$';</div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE '^.&#123;4&#125;$';</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#强制区分大小写</div><div class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE BINARY '^Pet[AB]';</div></pre></td></tr></table></figure><p><br></p><h4 id="行数计算"><a href="#行数计算" class="headerlink" title="行数计算"></a>行数计算</h4><p>Counting Rows</p><p><br></p><ul><li>使用<code>COUNT()</code>计算行数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#总行数</div><div class="line">mysql&gt; SELECT COUNT(*) AS count FROM pet;</div><div class="line">+<span class="comment">-------+</span></div><div class="line">| count |</div><div class="line">+<span class="comment">-------+</span></div><div class="line">|     5 |</div><div class="line">+<span class="comment">-------+</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#针对某个统计行数</div><div class="line">mysql&gt; SELECT owner, COUNT(*) FROM pet GROUP BY owner;</div><div class="line">+<span class="comment">-------+----------+</span></div><div class="line">| owner | COUNT(*) |</div><div class="line">+<span class="comment">-------+----------+</span></div><div class="line">| Aa    |        2 |</div><div class="line">| Bb    |        1 |</div><div class="line">| Cc    |        2 |</div><div class="line">+<span class="comment">-------+----------+</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#多个条件</div><div class="line">mysql&gt; SELECT species, sex, COUNT(*) FROM pet GROUP BY species, sex;</div><div class="line">+<span class="comment">---------+------+----------+</span></div><div class="line">| species | sex  | COUNT(*) |</div><div class="line">+<span class="comment">---------+------+----------+</span></div><div class="line">| bird    | NULL |        1 |</div><div class="line">| cat     | f    |        1 |</div><div class="line">| cat     | m    |        1 |</div><div class="line">| dog     | f    |        1 |</div><div class="line">| dog     | m    |        1 |</div><div class="line">+<span class="comment">---------+------+----------+</span></div></pre></td></tr></table></figure><p><br></p><h4 id="使用多个表"><a href="#使用多个表" class="headerlink" title="使用多个表"></a>使用多个表</h4><p>Using More Than one Table</p><p><br></p><p>创建一个额外的宠物信息表：</p><table><thead><tr><th>name</th><th>date</th><th>type</th><th>remark</th></tr></thead><tbody><tr><td>Fluffy</td><td>1995-05-15</td><td>litter</td><td>4 kittens, 3 female, 1 male</td></tr><tr><td>Buffy</td><td>1993-06-23</td><td>litter</td><td>5 puppies, 2 female, 3 male</td></tr><tr><td>Buffy</td><td>1994-06-19</td><td>litter</td><td>3 puppies, 3 female</td></tr><tr><td>Chirpy</td><td>1999-03-21</td><td>vet</td><td>needed beak straightened</td></tr><tr><td>Slim</td><td>1997-08-03</td><td>vet</td><td>broken rib</td></tr><tr><td>Bowser</td><td>1991-10-12</td><td>kennel</td><td></td></tr><tr><td>Fang</td><td>1991-10-12</td><td>kennel</td><td></td></tr><tr><td>Fang</td><td>1998-08-28</td><td>birthday</td><td>Gave him a new chew toy</td></tr><tr><td>Claws</td><td>1998-03-17</td><td>birthday</td><td>Gave him a new flea collar</td></tr><tr><td>Whistler</td><td>1998-12-09</td><td>birthday</td><td>First birthday</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mysql&gt; CREATE TABLE event ( name VARCHAR(20), date DATE,</div><div class="line">    -&gt; type VARCHAR(15), remark VARCHAR(255) );</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; LOAD DATA INFILE '/path/event.txt' INTO TABLE event;</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="获取数据库和表的信息"><a href="#获取数据库和表的信息" class="headerlink" title="获取数据库和表的信息"></a>获取数据库和表的信息</h2><p>Getting Information About Databases and Tables</p><p><br></p><ul><li>查看当前数据库<ul><li><code>mysql&gt; SELECT DATABASE();</code></li></ul></li><li>查看当前数据库下的表<ul><li><code>mysql&gt; SHOW TABLES;</code></li></ul></li><li>查看表的结构<ul><li><code>mysql&gt; DESCRIBE pet;</code></li></ul></li><li>创建数据库<ul><li><code>mysql&gt; CREATE DATABASE db_01;</code></li></ul></li><li>创建表<ul><li><code>mysql&gt; CREATE TABLE table_01 {c1 VARCHAR(10), c2 INT, ...};</code></li></ul></li><li>查看索引(如果存在)<ul><li><code>SHOW INDEX FROM table_01;</code></li></ul></li></ul><p><br><br><br></p><h2 id="在批处理下使用mysql"><a href="#在批处理下使用mysql" class="headerlink" title="在批处理下使用mysql"></a>在批处理下使用mysql</h2><p>Using mysql in Batch Mode</p><p><br></p><p>在前面，我们都是使用MySQL交互式(interactively)输入命令并查看结果。但还可在批处理模式下运行MySQL。<br>我们可以创建一个脚本文件，然后以这种方式执行脚本文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql &lt; batch-file</div><div class="line"></div><div class="line">msyql -h host -u user -p &lt; /path/batch-file</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#出现错误也继续运行</span></div><div class="line">msyql -h host -u user -p --force &lt; /path/batch-file</div></pre></td></tr></table></figure><p><br></p><p>为什么要使用脚本：</p><ul><li>如果需要反复(repeat)执行查询，将其写入脚本以避免每次执行时重新输入查询</li><li>通过复制和修改脚本文件从现有查询中生成新的查询</li><li>批处理模型在开发查询时也很有用，特别是对于多行语句。写错了直接修改脚本就好，而不必重新输入</li><li>如果查询产生大量输出，可通过传呼机而不是翻滚到屏幕的最上方<ul><li><code>mysql &lt; batch-file | more</code></li></ul></li><li>可以把输出捕获到一个文件中<ul><li><code>mysql &lt; batch-file &gt; mysql.out</code></li></ul></li><li>可将脚本文件分发给其他人</li><li>批处理模式下的MySQL输出更简洁<ul><li>可使用<code>mysql -t</code>获得交互式数据格式</li><li>使用<code>mysql -v</code>将执行语句回显</li></ul></li><li>在mysql命令行中载入脚本<ul><li><code>mysql&gt; source filename;</code></li><li>或’mysql&gt; . filename;</li></ul></li></ul><p><br><br><br></p><h2 id="常见查询"><a href="#常见查询" class="headerlink" title="常见查询"></a>常见查询</h2><p>Examples of Common Queries</p><p><br></p><ul><li>在命令行使用mysql并选择数据库</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql db_name -u user -p</div></pre></td></tr></table></figure><ul><li>创建和填充表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shop (</div><div class="line">    article <span class="built_in">INT</span>(<span class="number">4</span>) <span class="keyword">UNSIGNED</span> ZEROFILL <span class="keyword">DEFAULT</span> <span class="string">'0000'</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    dealer  <span class="built_in">CHAR</span>(<span class="number">20</span>)                 <span class="keyword">DEFAULT</span> <span class="string">''</span>     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    price   <span class="keyword">DOUBLE</span>(<span class="number">16</span>,<span class="number">2</span>)             <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    PRIMARY <span class="keyword">KEY</span>(article, dealer));</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shop <span class="keyword">VALUES</span></div><div class="line">    (<span class="number">1</span>,<span class="string">'A'</span>,<span class="number">3.45</span>),(<span class="number">1</span>,<span class="string">'B'</span>,<span class="number">3.99</span>),(<span class="number">2</span>,<span class="string">'A'</span>,<span class="number">10.99</span>),(<span class="number">3</span>,<span class="string">'B'</span>,<span class="number">1.45</span>),</div><div class="line">    (<span class="number">3</span>,<span class="string">'C'</span>,<span class="number">1.69</span>),(<span class="number">3</span>,<span class="string">'D'</span>,<span class="number">1.25</span>),(<span class="number">4</span>,<span class="string">'D'</span>,<span class="number">19.95</span>);</div></pre></td></tr></table></figure><ul><li>查看表内容</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> shop;</div></pre></td></tr></table></figure><ul><li>列的最大值(maximum)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(article) <span class="keyword">AS</span> article <span class="keyword">FROM</span> shop;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> article, <span class="keyword">MAX</span>(price) <span class="keyword">AS</span> price</div><div class="line"><span class="keyword">FROM</span>   shop</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> article;</div></pre></td></tr></table></figure><ul><li>使用用户定义的变量(user-defined variables)</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @min_price:=MIN(price),@max_price:=MAX(price) FROM shop;</div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM shop WHERE price=@min_price OR price=@max_price;</div></pre></td></tr></table></figure><ul><li>使用外键(Foreign Keys)</li></ul><p>在MySQL中，InnoDB表支持检查外键约束。<br>外键约束不仅仅需要连接两个表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">SMALLINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">    <span class="keyword">name</span> <span class="built_in">CHAR</span>(<span class="number">60</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</div><div class="line">);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shirt (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">SMALLINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">    <span class="keyword">style</span> ENUM(<span class="string">'t-shirt'</span>, <span class="string">'polo'</span>, <span class="string">'dress'</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    color ENUM(<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'orange'</span>, <span class="string">'white'</span>, <span class="string">'black'</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    owner <span class="built_in">SMALLINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">REFERENCES</span> person(<span class="keyword">id</span>),</div><div class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</div><div class="line">);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person <span class="keyword">VALUES</span> (<span class="literal">NULL</span>, <span class="string">'Antonio Paz'</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> @<span class="keyword">last</span> := <span class="keyword">LAST_INSERT_ID</span>();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shirt <span class="keyword">VALUES</span></div><div class="line">(<span class="literal">NULL</span>, <span class="string">'polo'</span>, <span class="string">'blue'</span>, @<span class="keyword">last</span>),</div><div class="line">(<span class="literal">NULL</span>, <span class="string">'dress'</span>, <span class="string">'white'</span>, @<span class="keyword">last</span>),</div><div class="line">(<span class="literal">NULL</span>, <span class="string">'t-shirt'</span>, <span class="string">'blue'</span>, @<span class="keyword">last</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person <span class="keyword">VALUES</span> (<span class="literal">NULL</span>, <span class="string">'Lilliana Angelovska'</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> @<span class="keyword">last</span> := <span class="keyword">LAST_INSERT_ID</span>();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shirt <span class="keyword">VALUES</span></div><div class="line">(<span class="literal">NULL</span>, <span class="string">'dress'</span>, <span class="string">'orange'</span>, @<span class="keyword">last</span>),</div><div class="line">(<span class="literal">NULL</span>, <span class="string">'polo'</span>, <span class="string">'red'</span>, @<span class="keyword">last</span>),</div><div class="line">(<span class="literal">NULL</span>, <span class="string">'dress'</span>, <span class="string">'blue'</span>, @<span class="keyword">last</span>),</div><div class="line">(<span class="literal">NULL</span>, <span class="string">'t-shirt'</span>, <span class="string">'white'</span>, @<span class="keyword">last</span>);</div></pre></td></tr></table></figure><ul><li>在两个键上查找(Searching on Two Keys)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> field1_index, field2_index <span class="keyword">FROM</span> test_table</div><div class="line"><span class="keyword">WHERE</span> field1_index = <span class="string">'1'</span> <span class="keyword">OR</span>  field2_index = <span class="string">'1'</span></div></pre></td></tr></table></figure><ul><li>使用自动增量</li></ul><p><code>AUTO_INCREMENT</code>属性能够为新行生成一个唯一的标识符。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> animals (</div><div class="line">     <span class="keyword">id</span> MEDIUMINT <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">     <span class="keyword">name</span> <span class="built_in">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">     PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</div><div class="line">);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> animals (<span class="keyword">name</span>) <span class="keyword">VALUES</span></div><div class="line">    (<span class="string">'dog'</span>),(<span class="string">'cat'</span>),(<span class="string">'penguin'</span>),</div><div class="line">    (<span class="string">'lax'</span>),(<span class="string">'whale'</span>),(<span class="string">'ostrich'</span>);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#设置指定增量开始值</div><div class="line">mysql&gt; ALTER TABLE tbl AUTO_INCREMENT = 100;</div></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="MySQL-Programs"><a href="#MySQL-Programs" class="headerlink" title="MySQL Programs"></a>MySQL Programs</h1><p><br></p><h2 id="MySQL程序概述"><a href="#MySQL程序概述" class="headerlink" title="MySQL程序概述"></a>MySQL程序概述</h2><p>Overview of MySQL Programs</p><p><br></p><p><strong>MySQL安装中有多个不同的程序：</strong></p><ul><li><strong>mysqld</strong><ul><li>SQL daemon, MySQL Server, <strong>mysqld</strong>是执行大部分工作的主要程序</li></ul></li><li><strong>mysqld_safe</strong><ul><li>服务器启动脚本</li><li>mysqld_safe尝试去启动mysqld</li></ul></li><li><strong>mysql.server</strong><ul><li>服务器启动脚本</li><li>此脚本用于System V系统，包含启动特定运行级别的系统服务脚本</li><li>它调用mysqld_safe来启动MySQL Server</li></ul></li><li><strong>mysql_multi</strong><ul><li>可启动和关闭安装在系统上的多个服务器的启动脚本</li></ul></li><li><strong>comp_err</strong><ul><li>在MySQL build/installation过程中使用</li><li>从错误源文件中编译错误消息文件</li></ul></li><li><strong>mysql_install_db</strong><ul><li>初始化MySQL(数据目录，授权表，并设置InnoDB系统表空间)</li><li>通常用于首次安装MySQL时</li></ul></li><li><strong>mysql_plugin</strong><ul><li>配置MySQL Server插件</li></ul></li><li><strong>mysql_secure_installation</strong><ul><li>能够提高MySQL安装的安全性</li></ul></li><li><strong>mysql_ssl_rsa_setup</strong><ul><li>如果这些文佳丢失，改程序会创建支持安全连接所需的SSL证书和密钥文件以及RSA密钥对文件</li></ul></li><li><strong>mysql_tzinfo_to_sql</strong><ul><li>从mysql数据库中加载时区表</li></ul></li><li><strong>mysql_upgrade</strong><ul><li>在MySQL升级操作后使用</li><li>它检查表的不兼容性并在必要时修复它们，并用更新版的MySQL的任何更改来更新授权表</li></ul></li><li><strong>mysql</strong><ul><li>交互式输入SQL语句的命令行工具</li><li>或执行一个批处理模式的文件</li></ul></li><li><strong>mysqladmin</strong><ul><li>执行管理操作的客户端</li><li>如创建或删除数据库，重新加载授权表，刷新表的磁盘…</li><li>也可用获取服务器版本、状态、进程信息</li></ul></li><li><strong>mysqlcheck</strong><ul><li>表格客户端</li><li>用于检查、修复、分析和优化表格</li></ul></li><li><strong>mysqldump</strong><ul><li>将MySQL数据库转储为SQL、文本或XML文件的客户端</li></ul></li><li><strong>mysqlimport</strong><ul><li>使用<code>LOAD DATA INFILE</code>将文本文件导入各自表格的客户端</li></ul></li><li><strong>mysqlpump</strong><ul><li>将MySQL数据库转转储为SQL文件的客户端</li></ul></li><li><strong>mysqlsh</strong><ul><li>用于MySQL Server的高级命令行客户端和代码编辑器</li><li>除了SQL外，MySQL Shell还为JS和Python提供了脚本功能</li></ul></li><li><strong>mysqlshow</strong><ul><li>显示有关数据库、表、列和索引的信息的客户端</li></ul></li><li><strong>mysqlslap</strong><ul><li>用于模拟MySQL Server的客户端负载并报告每个阶段的时间</li></ul></li></ul><p><br></p><p><strong>MySQL管理和实用程序：</strong></p><ul><li><strong>innochecksum</strong><ul><li>InnoDB脱机文件校验和程序</li></ul></li><li><strong>myisam_ftdump</strong><ul><li>在MyISAM表中显示有关全文索信息</li></ul></li><li><strong>myisamchk</strong><ul><li>描述，检查，优化和修复MyISAM表</li></ul></li><li><strong>myisamlog</strong><ul><li>处理MyISAM日志文件</li></ul></li><li><strong>myisampack</strong><ul><li>压缩MyISAM表以生成更小的只读表</li></ul></li><li><strong>mysql_config_editor</strong><ul><li>能够将认证凭证存储在名为安全的加密登录路径文件中</li></ul></li><li><strong>mysqlbinlog</strong><ul><li>从二进制日志中读取语句</li></ul></li><li><strong>mysqldumpslow</strong><ul><li>读取和总结慢查询日志内容</li></ul></li></ul><p><br></p><p><strong>MySQL程序开发实用程序：</strong></p><ul><li><strong>mysql_config</strong><ul><li>一个shell脚本，用于在编译MySQL程序是生产所需的选项值</li></ul></li><li><strong>my_print_defaults：</strong><ul><li>显示选项文件的选项组中存在哪些选项</li></ul></li><li><strong>resolve_stack_dump</strong><ul><li>将数值堆栈跟踪转储解析为符号</li></ul></li></ul><p><br></p><p><strong>杂项(Miscellaneous)工具：</strong></p><ul><li><strong>lz4_decompress</strong><ul><li>解压缩使用LZ4压缩格式的mysqldump输出</li></ul></li><li><strong>perror</strong><ul><li>显示系统或MySQL错误代码含义</li></ul></li><li><strong>replace</strong><ul><li>再输入文本中执行字符串替换</li></ul></li><li><strong>resolveip</strong><ul><li>将主机名解析为IP地址，反之亦然</li></ul></li><li><strong>zlib_decompress</strong><ul><li>解压缩使用ZLIB压缩格式的mysqldump输出</li></ul></li></ul><p><br></p><p>Oracle公司还提供了MySQL Workbench GUI工具，用于管理、创建、知悉和评估查询，以及从其它关系数据库管理系统迁移到MySQL系统。</p><p>MySQL Client和Server间的通信使用如下环境变量：</p><table><thead><tr><th>Environment Variable</th><th>Meaning</th></tr></thead><tbody><tr><td>MYSQL_UNIX_PORT</td><td>The default Unix socket file; used for connections to localhost</td></tr><tr><td>MYSQL_TCP_PORT</td><td>The default port number; used for TCP/IP connections</td></tr><tr><td>MYSQL_PWD</td><td>The default password, insecure</td></tr><tr><td>MYSQL_DEBUG</td><td>Debug trace options when debugging</td></tr><tr><td>TMPDIR</td><td>The directory where temporary tables and files are created</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL5.7参考文档： &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7.x86_64&lt;/li&gt;
&lt;li&gt;MySQL5.7&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="https://zhang21.github.io/categories/Database/"/>
    
    
      <category term="MySQL" scheme="https://zhang21.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>2018小计划</title>
    <link href="https://zhang21.github.io/2018/01/15/2018%E5%B0%8F%E8%AE%A1%E5%88%92/"/>
    <id>https://zhang21.github.io/2018/01/15/2018小计划/</id>
    <published>2018-01-15T03:08:11.000Z</published>
    <updated>2018-02-09T01:44:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><ul><li style="list-style: none"><input type="checkbox" checked> 《MongoDB官方文档》： <a href="https://docs.mongodb.com" target="_blank" rel="noopener">https://docs.mongodb.com</a></li><li style="list-style: none"><input type="checkbox"> 《SatlStack官方文档》： <a href="https://docs.saltstack.com" target="_blank" rel="noopener">https://docs.saltstack.com</a></li><li style="list-style: none"><input type="checkbox"> 《MySQL官方文档》： <a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">https://dev.mysql.com/doc/</a></li><li style="list-style: none"><input type="checkbox"> 《TCP/IP协议族》： <a href="https://book.douban.com/subject/5386194/" target="_blank" rel="noopener">https://book.douban.com/subject/5386194/</a></li><li style="list-style: none"><input type="checkbox"> 《Linux性能调优指南》： <a href="https://lihz1990.gitbooks.io/transoflptg/content/" target="_blank" rel="noopener">https://lihz1990.gitbooks.io/transoflptg/content/</a></li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h1><ul><li style="list-style: none"><input type="checkbox"> 《资本论》： <a href="https://book.douban.com/subject/1150503/" target="_blank" rel="noopener">https://book.douban.com/subject/1150503/</a></li><li style="list-style: none"><input type="checkbox"> 《灵飞经小楷》： <a href="https://book.douban.com/subject/1115916/" target="_blank" rel="noopener">https://book.douban.com/subject/1115916/</a></li><li style="list-style: none"><input type="checkbox"> 《经济学原理》： <a href="https://book.douban.com/subject/26435630/" target="_blank" rel="noopener">https://book.douban.com/subject/26435630/</a></li></ul><p><br></p><hr><p><br></p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><ul><li style="list-style: none"><input type="checkbox"> 沉得住气；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h1&gt;&lt;ul&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot; checked&gt; 《MongoDB官方文档》： &lt;a href=&quot;https://docs.mongodb.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.mongodb.com&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《SatlStack官方文档》： &lt;a href=&quot;https://docs.saltstack.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.saltstack.com&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《MySQL官方文档》： &lt;a href=&quot;https://dev.mysql.com/doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《TCP/IP协议族》： &lt;a href=&quot;https://book.douban.com/subject/5386194/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://book.douban.com/subject/5386194/&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《Linux性能调优指南》： &lt;a href=&quot;https://lihz1990.gitbooks.io/transoflptg/content/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://lihz1990.gitbooks.io/transoflptg/content/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Zhang" scheme="https://zhang21.github.io/categories/Zhang/"/>
    
    
      <category term="2018" scheme="https://zhang21.github.io/tags/2018/"/>
    
  </entry>
  
  <entry>
    <title>海明威的《老人与海》</title>
    <link href="https://zhang21.github.io/2018/01/13/%E6%B5%B7%E6%98%8E%E5%A8%81%E7%9A%84%E3%80%8A%E8%80%81%E4%BA%BA%E4%B8%8E%E6%B5%B7%E3%80%8B/"/>
    <id>https://zhang21.github.io/2018/01/13/海明威的《老人与海》/</id>
    <published>2018-01-13T01:49:53.000Z</published>
    <updated>2018-01-15T02:06:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>我不相信人会有所谓的“命运”，但是我相信对于任何人来说，“限度”总是存在的。再聪明再强悍的人，能够做到的事情也总是有限度的。老人桑地亚哥不是无能之辈，然而，尽管他是最好的渔夫，也不能让那些鱼来上他的钩。他遇到他的限度了，就象最好的农民遇上了大旱，最好的猎手久久碰不到猎物一般。每一个人都会遇到这样的限度，仿佛是命运在向你发出停止前行的命令。</p><a id="more"></a><p><br></p><p>可是老人没有沮丧，没有倦怠，他继续出海，向限度挑战。他终于钓到了一条鱼。如同那老人是人中的英雄一样，这条鱼也是鱼中的英雄。鱼把他拖到海上去，把他拖到远离陆地的地方，在海上与老人决战。在这场鱼与人的恶战中，鱼也有获胜的机会。鱼在水下坚持了几天几夜，使老人不能休息，穷于应付，它用酷刑来折磨老人，把他弄得血肉模糊。这时，只要老人割断钓绳，就能使自己摆脱困境，得到解放，但这也就意味着宣告自己是失败者。老人没有作这样得选择，甚至没有产生过放弃战斗的念头。他把那条鲨鱼当作一个可与之交战的敌手，一次又一次地做着限度之外的战斗，他战胜了。</p><p><br></p><p>老人载着他的鱼回家去，鲨鱼在路上抢劫他的猎物。他杀死了一条来袭的鲨鱼，但是折断了他的鱼叉。于是他用刀子绑在棍子上做武器。到刀子又折断的时候，似乎这场战斗已经结束了。他失去了继续战斗的武器，他又遇到了他的限度。这是，他又进行了限度之外的战斗：当夜幕降临，更多的鲨鱼包围了他的小船，他用木棍、用桨、甚至用舵和鲨鱼搏斗，直到他要保卫的东西失去了保卫的价值，直到这场搏斗已经变得毫无意义的时候他才住手。</p><p><br></p><p>老人回到岸边，只带回了一条白骨，只带回了残破不堪的小船和耗尽了精力的躯体。人们怎样看待这场斗争呢？</p><p>有人说老人桑地亚哥是一个失败了得英雄。尽管他是条硬汉，但还是失败了。</p><p>什么叫失败？也许可以说，人去做一件事情，没有达到预期得目的，这就是失败。</p><p><br></p><p>但是，那些与命运斗争的人，那些做接近自己限度的斗争的人，却天生地接近这种失败。老人到海上去，不能期望天天有鱼来咬他的钩，于是他常常失败。一个常常在进行着接近自己限度的斗争的人总是会常常失败的，一个想探索自然奥秘的人也常常会失败，一个想改革社会的人更是会常常失败。只有那些安于自己限度之内的生活的人才总是“胜利”，这种“胜利者”之所以常胜不败，只是因为他的对手是早已降伏的，或者说，他根本没有投入斗争。</p><p><br></p><p>在人生的道路上，“失败“这个词还有另外的含义，即是指人失去了继续斗争的信心，放下了手中的武器。人类向限度屈服，这才是真正的失败。而没有放下手中武器，还在继续斗争，继续向限度挑战的人并没有失败。如此看来，老人没有失败，老人从未放下武器，只不过是丧失了武器。老人没有失去信心，因此不应当说他是“失败了的英雄”。</p><p><br></p><p>那么，什么也没有得到的老人竟是胜利的么？我确是这样看的。我认为，胜利就是战斗到最后的时刻。老人总怀着无比的勇气走向莫测的大海，他的信心是不可战胜的。</p><p>他和其他许多人一样，是强悍的人类的一员。我喜欢这样的人，也喜欢这样的人性。我发现，人们常常把这样的事情当作人性最可贵的表露：七尺男子汉坐在厨房里和三姑六婆磨嘴皮子，或者衣装笔挺的男女们坐在海滨，谈论着高尚的、别人不能理解的感情。我不喜欢人们像这样沉溺在人性软弱的部分之中，更不喜欢人们总是这样描写人性。</p><p><br></p><p>正像老人每天走向大海一样，很多人每天也走向与他们的限度斗争的战场，仿佛他们要与命运一比高低似的。他们是人中的强者。</p><p>人类本身也有自己的限度，但是当人们一再把手伸到限度之外，这个限度就一天一天地扩大了。人类在与限度的斗争中成长。他们把飞船送上太空，他们也用简陋的渔具在加勒比海捕捉巨大的马林鱼。这些事情是同样伟大的。做这样不可思议的事情的人都是英雄。而那些永远不肯或不能越出自己限度的人是平庸的人。</p><p><br></p><p>在人类前进的道路上，强者与弱者的命运是不同的。弱者不羡慕强者的命运，强者也讨厌弱者的命运。强者带有人性中强悍的一面，弱者带有人性中软弱的一面。强者为弱者开辟道路，但是强者往往为弱者所奴役，就像老人是为大腹便便的游客打鱼一样。</p><p><br></p><p>《老人与海》讲了一个老渔夫的故事，但是在这个故事里却揭示了人类共同的命运。我佩服老人的勇气，佩服他不屈不饶的斗争精神，也佩服海明威。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我不相信人会有所谓的“命运”，但是我相信对于任何人来说，“限度”总是存在的。再聪明再强悍的人，能够做到的事情也总是有限度的。老人桑地亚哥不是无能之辈，然而，尽管他是最好的渔夫，也不能让那些鱼来上他的钩。他遇到他的限度了，就象最好的农民遇上了大旱，最好的猎手久久碰不到猎物一般。每一个人都会遇到这样的限度，仿佛是命运在向你发出停止前行的命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="王小波" scheme="https://zhang21.github.io/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>sysctl,ulimit以及/proc</title>
    <link href="https://zhang21.github.io/2018/01/09/sysctl%E3%80%81ulimit%E5%92%8Cproc/"/>
    <id>https://zhang21.github.io/2018/01/09/sysctl、ulimit和proc/</id>
    <published>2018-01-09T09:22:48.000Z</published>
    <updated>2018-01-10T02:44:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="http://man.linuxde.net/sysctl" target="_blank" rel="noopener">sysctl命令</a></li><li><a href="http://man.linuxde.net/ulimit" target="_blank" rel="noopener">ulimit命令</a></li><li><a href="http://www.jianshu.com/p/20a2dd80cbad" target="_blank" rel="noopener">ulimit、limits.conf、sysctl和proc文件系统</a></li><li><a href="http://www.jianshu.com/p/9a8e383b5b49" target="_blank" rel="noopener">sysctl.conf学习和调优</a></li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h1><p><code>sysctl</code> 命令被用于在内核运行时动态地修改内核的运行参数，可用的内核参数在目录 <code>/proc/sys</code> 中。它包含一些<code>Tcp/Ip</code>堆栈和虚拟内存系统的高级选项，可以通过修改某些值来提高系统性能。</p><p><code>sysctl</code>可以读取和设置超过五百个系统变量。<br><code>sysctl</code>变量的设置通常是<strong>字符串、数字或布尔型</strong>（布尔型用1表示yes，0表示no）。</p><p><code>sysctl</code> - configure kernel parameters at runtime.</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#sysctl [options] [variable[=value]] [...]</div><div class="line"></div><div class="line">sysctl -w net.ipv4.tcp_syncookies=1</div></pre></td></tr></table></figure><p><br></p><p>可以通过<code>sysctl</code>命令修改系统变量，也可以通过编辑<code>sysctl.conf</code>配置文件来修改系统变量。</p><p><code>sysctl.conf</code> - sysctl preload/configuration file.</p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysct.conf</div><div class="line"></div><div class="line"></div><div class="line"># Controls source route verification</div><div class="line"># Default should work for all interfaces net.ipv4.conf.default.rp_filter = 1</div><div class="line"># net.ipv4.conf.all.rp_filter = 1</div><div class="line"># net.ipv4.conf.lo.rp_filter = 1</div><div class="line"># net.ipv4.conf.eth0.rp_filter = 1</div><div class="line"></div><div class="line"></div><div class="line"># Disables IP source routing</div><div class="line"># Default should work for all interfaces net.ipv4.conf.default.accept_source_route = 0</div><div class="line"># net.ipv4.conf.all.accept_source_route = 0</div><div class="line"># net.ipv4.conf.lo.accept_source_route = 0</div><div class="line"># net.ipv4.conf.eth0.accept_source_route = 0</div><div class="line"></div><div class="line"></div><div class="line"># Controls the System Request debugging functionality of the kernel</div><div class="line">kernel.sysrq = 0</div><div class="line"></div><div class="line"></div><div class="line"># Controls whether core dumps will append the PID to the core filename</div><div class="line"># Useful for debugging multi-threaded applications</div><div class="line">kernel.core_uses_pid = 1</div><div class="line"></div><div class="line"></div><div class="line"># Increase maximum amount of memory allocated to shm</div><div class="line"># Only uncomment if needed</div><div class="line"># kernel.shmmax = 67108864</div><div class="line"></div><div class="line"></div><div class="line"># Disable ICMP Redirect Acceptance</div><div class="line"># Default should work for all interfaces</div><div class="line">net.ipv4.conf.default.accept_redirects = 0</div><div class="line"># net.ipv4.conf.all.accept_redirects = 0</div><div class="line"># net.ipv4.conf.lo.accept_redirects = 0</div><div class="line"># net.ipv4.conf.eth0.accept_redirects = 0</div><div class="line"></div><div class="line"></div><div class="line"># enable Log Spoofed Packets, Source Routed Packets, Redirect Packets</div><div class="line"># Default should work for all interfaces</div><div class="line">net.ipv4.conf.default.log_martians = 1</div><div class="line">#net.ipv4.conf.all.log_martians = 1</div><div class="line"># net.ipv4.conf.lo.log_martians = 1</div><div class="line"># net.ipv4.conf.eth0.log_martians = 1</div><div class="line"></div><div class="line"></div><div class="line"># Decrease the time default value for tcp_fin_timeout connection</div><div class="line">net.ipv4.tcp_fin_timeout = 25</div><div class="line"></div><div class="line"></div><div class="line"># Decrease the time default value for tcp_keepalive_time connection</div><div class="line">net.ipv4.tcp_keepalive_time = 1200</div><div class="line"></div><div class="line"></div><div class="line"># Turn on the tcp_window_scaling</div><div class="line">net.ipv4.tcp_window_scaling = 1</div><div class="line"></div><div class="line"></div><div class="line"># Turn on the tcp_sack</div><div class="line">net.ipv4.tcp_sack = 1</div><div class="line"></div><div class="line"></div><div class="line"># tcp_fack should be on because of sack</div><div class="line">net.ipv4.tcp_fack = 1</div><div class="line"></div><div class="line"></div><div class="line"># Turn on the tcp_timestamps</div><div class="line">net.ipv4.tcp_timestamps = 1</div><div class="line"></div><div class="line"></div><div class="line"># Enable TCP SYN Cookie Protection</div><div class="line">net.ipv4.tcp_syncookies = 1</div><div class="line"></div><div class="line"></div><div class="line"># Enable ignoring broadcasts request</div><div class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</div><div class="line"></div><div class="line"></div><div class="line"># Disable ping requests</div><div class="line">net.ipv4.icmp_echo_ignore_all = 1</div><div class="line"></div><div class="line"></div><div class="line"># Enable bad error message Protection</div><div class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</div><div class="line"></div><div class="line"></div><div class="line"># make more local ports available</div><div class="line"># net.ipv4.ip_local_port_range = 1024 65000</div><div class="line"></div><div class="line"></div><div class="line"># set TCP Re-Ordering value in kernel to 5</div><div class="line">net.ipv4.tcp_reordering = 5</div><div class="line"></div><div class="line"></div><div class="line"># Lower syn retry rates</div><div class="line">net.ipv4.tcp_synack_retries = 2</div><div class="line">net.ipv4.tcp_syn_retries = 3</div><div class="line"></div><div class="line"></div><div class="line"># Set Max SYN Backlog to 2048</div><div class="line">net.ipv4.tcp_max_syn_backlog = 2048</div><div class="line"></div><div class="line"></div><div class="line"># Various Settings</div><div class="line">net.core.netdev_max_backlog = 1024</div><div class="line"></div><div class="line"></div><div class="line"># Increase the maximum number of skb-heads to be cached</div><div class="line">net.core.hot_list_length = 256</div><div class="line"></div><div class="line"></div><div class="line"># Increase the tcp-time-wait buckets pool size</div><div class="line">net.ipv4.tcp_max_tw_buckets = 360000</div><div class="line"></div><div class="line"></div><div class="line"># This will increase the amount of memory available for socket input/output queues</div><div class="line">net.core.rmem_default = 65535</div><div class="line">net.core.rmem_max = 8388608</div><div class="line">net.ipv4.tcp_rmem = 4096 87380 8388608 net.core.wmem_default = 65535</div><div class="line">net.core.wmem_max = 8388608</div><div class="line">net.ipv4.tcp_wmem = 4096 65535 8388608</div><div class="line">net.ipv4.tcp_mem = 8388608 8388608 8388608</div><div class="line">net.core.optmem_max = 40960</div></pre></td></tr></table></figure><p>重新加载内核参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-p, read values from file</span></div><div class="line">sysctl -p</div><div class="line"></div><div class="line"><span class="comment">#-a, display all variables</span></div><div class="line">sysctl -a</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h1><p>大多Unix-Like系统，都提供了限制每个进程和每个基本用户使用线程，文件和网络连接等系统资源的一些方法。</p><p>假设有这样一种情况，当一台Linux主机上同时登陆了10人，在资源无限制的情况下，这10个用户同时打开了500个文件。假设每个文件的大小有10M，这是系统的内存资源就会收到巨大挑战。<br>但是任何一台主机的资源都不可能是无限的。所以，资源的合理配置和分配，不仅仅是保证系统可用性的必要条件，也与系统上软件运行的性能有着密不可分的联系。</p><p><code>ulimit</code>是指每个user使用各种资源的限制值。<code>ulimit</code> 命令用来限制系统用户对shell资源的访问，它是一种简单并且有效的实现资源限制的方式。</p><ul><li><code>ulimit</code>的设置值是 per-process的，也就是说，每个进程都有自己的limits值；</li><li>使用<code>ulimit</code>进行修改，是立即生效的；</li><li><code>ulimit</code>只影响shell进程及其子进程，用户登出后失效；</li><li>修改<code>ulimit</code>设置之后，要重启程序修改值才会有效。可通过<code>/proc</code>文件系统查看运行进程当前的限制值;</li><li>使用<code>ulimit</code>对系统限制的改变在系统重启后都会恢复到默认值;</li><li>可以在<code>profile</code>中加入<code>ulimit</code>的设置，便能做到永久生效。</li></ul><p><br></p><p><strong>ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：</strong></p><ul><li>所创建的内核文件的大小；</li><li>进程数据块的大小；</li><li>Shell进程创建文件的大小；</li><li>内存锁住的大小；</li><li>常驻内存集的大小；</li><li>打开文件描述符的数量；</li><li>分配堆栈的最大大小；</li><li>CPU时间；</li><li>单个用户的最大线程数；</li><li>Shell进程所能使用的最大虚拟内存；</li><li>它支持硬资源(hard)和软资源(soft)的限制。</li></ul><p><br></p><p><strong>sort和hard</strong></p><ul><li>hard：是指用户在任何时候都可以活动的进程的最大数量，这是上限。没有任何non-root进程能够增加hard ulimit；</li><li>soft：是对会话或进程实际执行的限制，但任何进程都可以将其增加到hard ulimit的最大值。</li></ul><p><br></p><h2 id="设置ulimit"><a href="#设置ulimit" class="headerlink" title="设置ulimit"></a>设置ulimit</h2><p>可以在以下位置进行ulimit的设置：</p><ul><li><code>/etc/profile</code>，所有用户有效，永久生效；</li><li><code>~/.bash_profile</code>,当前用户有效，永久生效；</li><li>直接在控制台修改，当前用户有效，临时生效；</li></ul><p><br></p><p>永久生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div><div class="line"></div><div class="line">vim ~/.bash_profile</div></pre></td></tr></table></figure><p>临时生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">ulimit</span> -a</div><div class="line"></div><div class="line"></div><div class="line">core file size          (blocks, -c) 0</div><div class="line">data seg size           (kbytes, -d) unlimited</div><div class="line">scheduling priority             (-e) 0</div><div class="line">file size               (blocks, -f) unlimited</div><div class="line">pending signals                 (-i) 7170</div><div class="line">max locked memory       (kbytes, -l) 64</div><div class="line">max memory size         (kbytes, -m) unlimited</div><div class="line">open files                      (-n) 1024</div><div class="line">pipe size            (512 bytes, -p) 8</div><div class="line">POSIX message queues     (bytes, -q) 819200</div><div class="line">real-time priority              (-r) 0</div><div class="line">stack size              (kbytes, -s) 8192</div><div class="line">cpu time               (seconds, -t) unlimited</div><div class="line">max user processes              (-u) 7170</div><div class="line">virtual memory          (kbytes, -v) unlimited</div><div class="line">file locks                      (-x) unlimited</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#修改限定值</span></div><div class="line"><span class="built_in">ulimit</span> -n 201400</div><div class="line"><span class="built_in">ulimit</span> -t ulimited</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="limits-conf"><a href="#limits-conf" class="headerlink" title="limits.conf"></a>limits.conf</h1><p><code>limits.conf</code> - configuration file for the pam_limits module</p><p><code>limits.conf</code>是<code>pam_limits.so</code>的配置文件，Linux PAM(Pluggable Authentication Modules，插入式认证模块)。突破系统默认限制，对系统资源有一定保护作用。</p><p><strong>pam_limits模块</strong>对用户的会话进行资源限制，然后<code>/etc/pam.d/</code>下的应用程序调用<code>pam_***.so</code>模块。</p><p><br></p><p><strong><code>limits.conf</code>是针对用户，而<code>sysctl.conf</code>是针对整个系统参数配置。</strong></p><ul><li>一个shell的初始limits就是由pam_limits设定的，用户登录后，pam_limits会给用户的shell设定在limits.conf定义的值；</li><li>pam_limits的设定值也是per-process；</li><li>pam_limits的设置是 永久生效的。</li></ul><p><br></p><p>配置limits.conf：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/security/limits.conf</div></pre></td></tr></table></figure><p><br></p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#&lt;domain&gt;      &lt;type&gt;  &lt;item&gt;         &lt;value&gt;</div><div class="line"></div><div class="line">#*               soft    core            0</div><div class="line">#*               hard    rss             10000</div><div class="line">#@student        hard    nproc           20</div><div class="line">#@faculty        soft    nproc           20</div><div class="line">#@faculty        hard    nproc           50</div><div class="line">#ftp             hard    nproc           0</div><div class="line">#@student        -       maxlogins       4</div></pre></td></tr></table></figure><p>domain：</p><ul><li>username</li><li>@groupname</li></ul><p>type：</p><ul><li>soft</li><li>hard</li><li>-</li></ul><p>item：</p><ul><li>core，限制内核文件的大小</li><li>date，最大数据大小</li><li>fsize，最大文件大小</li><li>memlock，最大锁定内存地址空间</li><li>nofile，打开文件的最大数目</li><li>rss，最大持久设置大小</li><li>stack，最大栈大小</li><li>cpu，以分钟为单位的最多CPU时间</li><li>nproc，进程的最大数目</li><li>as，地址空间限制</li><li>maxlogins，此用户允许登录的最大数目</li></ul><p>value：</p><ul><li>item值的大小</li></ul><p><br></p><hr><p><br></p><h1 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h1><h2 id="什么是-proc文件系统"><a href="#什么是-proc文件系统" class="headerlink" title="什么是/proc文件系统"></a>什么是/proc文件系统</h2><p>Linux内核提供了一种通过<code>/proc</code>文件系统，在运行时访问内核内部数据结构，改变内核设置的机制。</p><p>proc文件系统是一个伪文件系统，它只存在内存当中，不占用外部空间。它以文件系统的方式为访问系统内核数据的操作提供接口。</p><p>对<code>/proc</code>中内核文件的修改，针对的是<strong>整个系统</strong>的<strong>内核参数</strong>，修改后<strong>立即生效</strong>，但修改是 <strong>临时的</strong>，重启后失效。</p><p><br></p><h2 id="proc与sysctl-conf的对应关系"><a href="#proc与sysctl-conf的对应关系" class="headerlink" title="/proc与sysctl.conf的对应关系"></a>/proc与sysctl.conf的对应关系</h2><p>修改<code>/proc</code>文件系统中的参数是临时的，但修改<code>sysctl.conf</code>的参数确是永久有效的。</p><p>配置文件<code>sysctl.conf</code>变量在<code>/proc/sys</code>下，其对应关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#将文件名的 . 变为 /</div><div class="line"></div><div class="line">#/proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line">#net.ipv4.icmp_echo_ignore_all</div><div class="line"></div><div class="line">echo 0 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line"></div><div class="line">vim /etc/sysctl.conf</div><div class="line">net.ipv4.icmp_echo_ignore_all = 0</div></pre></td></tr></table></figure><p><br></p><h2 id="proc文件系统几个常用的内核文件"><a href="#proc文件系统几个常用的内核文件" class="headerlink" title="/proc文件系统几个常用的内核文件"></a>/proc文件系统几个常用的内核文件</h2><ul><li>/proc/meminfo    #内存信息</li><li>/proc/cpuinfo    #CPU信息</li><li>/proc/sys/fs/file-max    #文件打开数</li><li>/proc/sys/fs/file-nr    #整个系统目前使用的文件句柄数量</li></ul><p><br></p><h2 id="proc文件系统中文件的权限"><a href="#proc文件系统中文件的权限" class="headerlink" title="/proc文件系统中文件的权限"></a>/proc文件系统中文件的权限</h2><p>proc中的每个文件都有一组分配给它的非常特殊的文件许可权，并且每个文件属于特定的用户标识。</p><ul><li>只读：任何用户都不能更改该文件，它用于表示系统信息</li><li>root写</li><li>root读</li></ul><p><br></p><h2 id="对-proc进行读写"><a href="#对-proc进行读写" class="headerlink" title="对/proc进行读写"></a>对/proc进行读写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cat /proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line">#0</div><div class="line"></div><div class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line"></div><div class="line">#当然,也可是用sysctl来配置</div></pre></td></tr></table></figure><p><br></p><h2 id="proc内核文件详解"><a href="#proc内核文件详解" class="headerlink" title="/proc内核文件详解"></a>/proc内核文件详解</h2><ul><li>/proc/buddyinfo 每个内存区中的每个order有多少块可用，和内存碎片问题有关</li><li>/proc/cmdline 启动时传递给kernel的参数信息</li><li>/proc/cpuinfo cpu的信息</li><li>/proc/crypto 内核使用的所有已安装的加密密码及细节</li><li>/proc/devices 已经加载的设备并分类</li><li>/proc/dma 已注册使用的ISA DMA频道列表</li><li>/proc/execdomains Linux内核当前支持的execution domains</li><li>/proc/fb 帧缓冲设备列表，包括数量和控制它的驱动</li><li>/proc/filesystems 内核当前支持的文件系统类型</li><li>/proc/interrupts x86架构中的每个IRQ中断数</li><li>/proc/iomem 每个物理设备当前在系统内存中的映射</li><li>/proc/ioports 一个设备的输入输出所使用的注册端口范围</li><li>/proc/kcore 代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于RAM大小加上4kb</li><li>/proc/kmsg 记录内核生成的信息，可以通过/sbin/klogd或/bin/dmesg来处理</li><li>/proc/loadavg 根据过去一段时间内CPU和IO的状态得出的负载状态，与uptime命令有关</li><li>/proc/locks 内核锁住的文件列表</li><li>/proc/mdstat 多硬盘，RAID配置信息(md=multiple disks)</li><li>/proc/meminfo RAM使用的相关信息</li><li>/proc/misc 其他的主要设备(设备号为10)上注册的驱动</li><li>/proc/modules 所有加载到内核的模块列表</li><li>/proc/mounts 系统中使用的所有挂载</li><li>/proc/mtrr 系统使用的Memory Type Range Registers (MTRRs)</li><li>/proc/partitions 分区中的块分配信息</li><li>/proc/pci 系统中的PCI设备列表</li><li>/proc/slabinfo 系统中所有活动的 slab 缓存信息</li><li>/proc/stat 所有的CPU活动信息</li><li>/proc/sysrq-trigger 使用echo命令来写这个文件的时候，远程root用户可以执行大多数的系统请求关键命令，就好- 像在本地终端执行一样。要写入这个文件，需要把/proc/sys/kernel/sysrq不能设置为0。这个文件对root也是不可- 读的</li><li>/proc/uptime 系统已经运行了多久</li><li>/proc/swaps 交换空间的使用情况</li><li>/proc/version Linux内核版本和gcc版本</li><li>/proc/bus 系统总线(Bus)信息，例如pci/usb等</li><li>/proc/driver 驱动信息</li><li>/proc/fs 文件系统信息</li><li>/proc/ide ide设备信息</li><li>/proc/irq 中断请求设备信息</li><li>/proc/net 网卡设备信息</li><li>/proc/scsi scsi设备信息</li><li>/proc/tty tty设备信息</li><li>/proc/net/dev 显示网络适配器及统计信息</li><li>/proc/vmstat 虚拟内存统计信息</li><li>/proc/vmcore 内核panic时的内存映像</li><li>/proc/diskstats 取得磁盘信息</li><li>/proc/schedstat kernel调度器的统计信息</li><li>/proc/zoneinfo 显示内存空间的统计信息，对分析虚拟内存行为很有用</li></ul><p><br></p><p><strong>以下是/proc目录中进程N的信息：</strong></p><ul><li>/proc/N pid为N的进程信息</li><li>/proc/N/cmdline 进程启动命令</li><li>/proc/N/cwd 链接到进程当前工作目录</li><li>/proc/N/environ 进程环境变量列表</li><li>/proc/N/exe 链接到进程的执行命令文件</li><li>/proc/N/fd 包含进程相关的所有的文件描述符</li><li>/proc/N/maps 与进程相关的内存映射信息</li><li>/proc/N/mem 指代进程持有的内存，不可读</li><li>/proc/N/root 链接到进程的根目录</li><li>/proc/N/stat 进程的状态</li><li>/proc/N/statm 进程使用的内存的状态</li><li>/proc/N/status 进程状态信息，比stat/statm更具可读性</li><li>/proc/self 链接到当前正在运行的进程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://man.linuxde.net/sysctl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sysctl命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://man.linuxde.net/ulimit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ulimit命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/20a2dd80cbad&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ulimit、limits.conf、sysctl和proc文件系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/9a8e383b5b49&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sysctl.conf学习和调优&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="系统优化" scheme="https://zhang21.github.io/tags/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>开源许可协议</title>
    <link href="https://zhang21.github.io/2018/01/09/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
    <id>https://zhang21.github.io/2018/01/09/开源许可协议/</id>
    <published>2018-01-09T03:50:27.000Z</published>
    <updated>2018-01-09T05:55:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你为你的产品签发许可，你就是在出让自己的权利。不过，你仍拥有版权和专利（如果申请了专利）。许可的目的，是向使用你产品的人提供一定的权利。</p><p>不管产品是免费分发，还是出售，指定一份许可协议都非常有用。否则，对于免费，你相当于放弃了自己的所有权利，任何人都没有义务表明你的原始作者身份。对于出售，你将不得不花费比开发更多的精力用来处理授权问题。</p><p>而开源许可协议是这些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的身份，使你至少获得认可。开源许可协议还可以阻止其它人将某个产品据为己有。</p><p><br><br><a id="more"></a></p><p><img src="/images/opensourcelicence.png" alt="开源许可协议区别"></p><p><br></p><p><img src="/images/opensourcelicence.jpg" alt="开源许可协议区别"></p><p><br></p><hr><p><br></p><h1 id="几大开源许可协议"><a href="#几大开源许可协议" class="headerlink" title="几大开源许可协议"></a>几大开源许可协议</h1><p><br><br><br></p><h2 id="GNU-Project"><a href="#GNU-Project" class="headerlink" title="GNU Project"></a>GNU Project</h2><ul><li>GNU是“GNU’s Not Unix”的递归缩写，发音为 /‘gnu:’/；</li><li>GNU Project，是一个由自由软件集体协作项目，它的目标是创建一套完全自由的操作系统，称为GNU；</li><li>GNU是一个自由操作系统，其内容软件完全以 GPL 方式发布，它的设计类似于Unix，但它不包含具有著作权的Unix代码。</li></ul><p><br></p><h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GNU(General Public Licence)，GNU通用许可协议(简称GPL)是广泛使用的免费软件许可证，也称为 copyleft，与copyright相对应。<br>GPL保证了所有开发者的权利，同时为使用者提供了足够的复制、分发、修改的权利。</p><p>需要注意的是，分发的时候，需要明确提供源代码和二进制文件。</p><ul><li><strong>可自由复制：</strong> 你可以将软件复制到你的电脑或任何地方，复制份数没有限制；</li><li><strong>可自由分发：</strong> 可下载后拷贝分发；</li><li><strong>可以用来盈利：</strong> 你可以在分发软件的时候收费，但必须在收费前向你的客户提供该软件的 GNU GPL许可协议，以便让他们知道，他们可以从别的渠道免费得到这份软件以及你收费的理由；</li><li><strong>可自由修改：</strong> 你过你想添加或删除某个功能，没问题。如果你想在别的项目中使用部分代码，也没问题，唯一要求是使用了这段代码的项目也必须使用 GPL协议。</li></ul><p><br></p><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>GNU还有另外一种协议，叫做LGPL（Lesser General Public License），它对产品所保留的权利比GPL少。<br>总的来说，LGPL适合那些用于非GPL或非开源产品的开源类库或框架。因为GPL要求，使用了GPL代码的产品也必须使用GPL协议，开发者不允许将GPL代码用于商业产品。LGPL绕过了这一限制。</p><p>GPL和LGPL都属于GNU计划里面的许可证。</p><p><br></p><hr><p><br></p><h2 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h2><p>伯克利软件套件（Berkeley Software Distribution，缩写BSD），也被称为伯克利Unix，是一个操作系统的名称，衍生自Unix，也被用来代表一整套软件发行版。</p><p>BSD许可证（Berkeley Software Distribution License），是自由软件中使用广泛的许可证。BSD软件就是遵照这个许可证来发布，该许可证也因此而得名。</p><p>BSD在软件分发方面的限制比别的开源协议要少，且和GPL兼容，并为开源组织所认可。</p><p><br></p><hr><p><br></p><h2 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h2><p>MIT（Massachusetts Institute of Technology），麻省理工学院。<br>MIT许可协议（The MIT License）是许多软件授权条款中，被广泛使用的其中一种。与其他常见的软件许可协议相比，MIT是相对宽松的软件许可协议，除了必须包含许可声明外，再无任何限制。</p><p>MIT许可协议核心条款：</p><ul><li>该软件及其相关文档对所有人免费，可以任意处置，包括使用、复制、修改、合并、发表、分发、再授权或销售；</li><li>唯一的限制，软件中必须包含上述版权和许可证。</li></ul><p><br></p><hr><p><br></p><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>Apache许可证（Apache License），是一个由Apache软件基金会发布的自由软件许可证。Apache许可证要求被授权者保留版权和放弃权利的声明，但它不是一个反版权的许可证。兼容与GPL。</p><p>除了为用户提供版权许可之外，还有专利许可，对于那些涉及专利内容的开发者而言，该协议最适合。</p><ul><li>永久权利：一旦被授权，永久拥有；</li><li>全球范围的权利：在一个国家获得授权，适用于所有国家；</li><li>授权免费，且无版税：前后期均无任何费用；</li><li>授权不可撤销：一旦获得授权，没有任何人可以取消。</li></ul><p>分发代码方面，要在声明中对参与开发的人给予认可并包含一份许可协议原文。</p><p><br></p><hr><p><br></p><h2 id="MPL"><a href="#MPL" class="headerlink" title="MPL"></a>MPL</h2><p>MPL是The Mozilla[mɔzilə] Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。<br>MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。</p><p>同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA 认定的开源软件许可证）。</p><p>MPL几个特点：</p><ul><li>MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL 许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口；</li><li>MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序；</li><li>对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利；</li><li>对源代码的定义，MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。</li></ul><p><br></p><hr><p><br></p><h2 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h2><p>知识共享许可协议(Creative Commons License，简称CC)，并非严格意义上的开源许可，是一种公共版权许可协议。它主要用于设计，其允许分发受版权保护的作品。</p><p>CC协议主要包含4种基本形式：</p><ul><li>署名权：必须为原始作业署名，然后才可以修改、分发、复制；</li><li>保持一致：作品同样可以在CC协议的基础上修改、分发、复制；</li><li>非商业：不能用于商业用途；</li><li>不能衍生新作品：你可以复制、分发、但不能修改，也不能以此为基础创作自己的作品。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你为你的产品签发许可，你就是在出让自己的权利。不过，你仍拥有版权和专利（如果申请了专利）。许可的目的，是向使用你产品的人提供一定的权利。&lt;/p&gt;
&lt;p&gt;不管产品是免费分发，还是出售，指定一份许可协议都非常有用。否则，对于免费，你相当于放弃了自己的所有权利，任何人都没有义务表明你的原始作者身份。对于出售，你将不得不花费比开发更多的精力用来处理授权问题。&lt;/p&gt;
&lt;p&gt;而开源许可协议是这些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的身份，使你至少获得认可。开源许可协议还可以阻止其它人将某个产品据为己有。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="开源许可协议" scheme="https://zhang21.github.io/tags/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Yum源</title>
    <link href="https://zhang21.github.io/2018/01/09/Yum%E6%BA%90/"/>
    <id>https://zhang21.github.io/2018/01/09/Yum源/</id>
    <published>2018-01-09T03:46:21.000Z</published>
    <updated>2018-03-11T08:32:42.636Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="http://blog.csdn.net/leshami/article/details/78133716" target="_blank" rel="noopener">CentOS 7下配置本地yum源及yum客户端</a></li><li><a href="http://blog.csdn.net/conling_/article/details/70399694" target="_blank" rel="noopener">Centos7 配置本地源+阿里yum源/epel-yum+修改优先级</a></li><li><a href="http://blog.csdn.net/kingfox/article/details/51233153" target="_blank" rel="noopener">调整CentOS 7中yum仓库的优先级</a></li><li><a href="https://segmentfault.com/a/1190000000375848" target="_blank" rel="noopener">国内开源站点</a></li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="国内开源镜像站点"><a href="#国内开源镜像站点" class="headerlink" title="国内开源镜像站点"></a>国内开源镜像站点</h1><ul><li>网易开源镜像站：<a href="http://mirrors.163.com/" target="_blank" rel="noopener">http://mirrors.163.com/</a></li><li>阿里云开源镜像站：<a href="http://mirrors.aliyun.com" target="_blank" rel="noopener">http://mirrors.aliyun.com</a></li><li>清华大学开源镜像站：<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a></li><li>浙江大学开源镜像站： <a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/</a></li><li>中国科技大学开源镜像站：<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a></li></ul><p><br></p><hr><p><br></p><h1 id="CentOS自带源"><a href="#CentOS自带源" class="headerlink" title="CentOS自带源"></a>CentOS自带源</h1><p>rpm包管理方式，对于安装、升级、卸载却难以处理包之间的依赖关系。而yum作为一个rpm包前端管理工具，可以自动处理依赖性，并支持在线现在、安装、升级、卸载rpm软件包。</p><p>CentOS默认自带<code>CentOS-Base.repo</code>源，但官方源在国外，连接速度令人心痛。并且有很多软件在默认源里面是找不到的。</p><h2 id="配置网络yun源"><a href="#配置网络yun源" class="headerlink" title="配置网络yun源"></a>配置网络yun源</h2><p><strong>配置aliyun.repo：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#先备份默认源</div><div class="line">mv CentOS-Base.repo&#123;,.bak&#125;</div><div class="line"></div><div class="line">#下载阿里云源替换默认源</div><div class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</div><div class="line"></div><div class="line">yum clean all</div><div class="line">yum makecache    #重构yum缓存</div><div class="line"></div><div class="line">yum repolist    #查看yum仓库</div></pre></td></tr></table></figure><p><br></p><h2 id="配置本地yum源"><a href="#配置本地yum源" class="headerlink" title="配置本地yum源"></a>配置本地yum源</h2><p><strong>配置本地yum源，考虑到优先使用本地安装包，所以会涉及到一个优先级的概念。</strong></p><p>安装完毕后，就可以在yum源中添加一个优先级<code>priority</code>。</p><p><strong>安装yum优先级插件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">yum install -y yum-plugin-priorities</div><div class="line"></div><div class="line">#检查安装完成后配置</div><div class="line">vim /etc/yum/pluginconf.d/priorities.conf</div><div class="line"></div><div class="line">enable=1</div><div class="line">#enable=0</div></pre></td></tr></table></figure><p><br></p><p><strong>创建本地yum源：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">mv /etc/yum.repos.d/CentOS-Base.repo&#123;,.bak&#125;</div><div class="line"></div><div class="line">vim /etc/yum.repos.d/CentOS-Local.repo</div><div class="line"></div><div class="line">[base-Local]</div><div class="line">name=Centos- Local</div><div class="line">baseurl=file:///mnt/xxx</div><div class="line">gpgcheck=0</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line">priority=1    #优先级为1</div><div class="line"></div><div class="line">[updates-Local]</div><div class="line">name=CentOS- Local</div><div class="line">gpgcheck=0</div><div class="line">baseurl=file:///dir/path/</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line">priority=1</div><div class="line"></div><div class="line">······</div><div class="line">#具体可参考CentOS-Base.repo</div><div class="line">#可将aliyun源优先级写成2</div><div class="line"></div><div class="line">yum clean all</div><div class="line">yum makecache</div></pre></td></tr></table></figure><p><br></p><h2 id="配置ftp方式源"><a href="#配置ftp方式源" class="headerlink" title="配置ftp方式源"></a>配置ftp方式源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">vim /etc/yum.repos.d/ftp.repo</div><div class="line"></div><div class="line">[ftp-media]</div><div class="line">name=name=CentOS-$releasever - media</div><div class="line">baseurl=ftp://ip</div><div class="line">gpgcheck=0</div><div class="line">enable=1</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line"></div><div class="line">yum clean all</div><div class="line">yum makecache</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="其他常见YUM源"><a href="#其他常见YUM源" class="headerlink" title="其他常见YUM源"></a>其他常见YUM源</h1><p>官方的默认<code>yum源</code>提供的软件包往往是很滞后的，(可能为了服务器版本的稳定性和安全性)。并且官方默认源提供的RPM包也不够丰富。</p><p><br></p><h2 id="EPEL源"><a href="#EPEL源" class="headerlink" title="EPEL源"></a>EPEL源</h2><p>EPEL的全称叫 <code>Extra Packages for Enterprise Linux</code> 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。</p><p><code>EPEL源</code>为服务器提供了大量的rpm包(这些包可能有很多在默认源中没有)，并且绝大多数rpm包比官方默认源版本要新。</p><p><strong>添加epel源：</strong><br>epel下载地址：<a href="http://download.fedora.redhat.com/pub/epel/" target="_blank" rel="noopener">http://download.fedora.redhat.com/pub/epel/</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpm -vih http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</div><div class="line"></div><div class="line"><span class="comment">#yum install -y epel-release</span></div></pre></td></tr></table></figure></p><p><br></p><h2 id="remi源"><a href="#remi源" class="headerlink" title="remi源"></a>remi源</h2><p>Remi源大家或许很少听说，不过Remi源GoFace强烈推荐，尤其对于不想编译最新版的linux使用者，因为Remi源中的软件几乎都是最新稳定版。<br>或许您会怀疑稳定不？<br>放心，这些都是Linux骨灰级的玩家编译好放进源里的，他们对于系统环境和软件编译参数的熟悉程度毋庸置疑。</p><p><strong>添加remi源：</strong><br>Remi下载地址：<a href="http://rpms.famillecollet.com" target="_blank" rel="noopener">http://rpms.famillecollet.com</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</div><div class="line"></div><div class="line"><span class="comment">#yum install -y  http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</span></div></pre></td></tr></table></figure></p><p><br></p><h2 id="RPMForge源"><a href="#RPMForge源" class="headerlink" title="RPMForge源"></a>RPMForge源</h2><p><code>RPMForge</code>是<code>CentOS</code>系统下的软件仓库，拥有4000多种的软件包, 被CentOS社区认为是最安全也是最稳定的一个软件仓库。</p><p><strong>添加RPMForge源：</strong><br>RPMForge下载地址：<a href="http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/" target="_blank" rel="noopener">http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/</a><br>GitHub:<a href="https://github.com/repoforge" target="_blank" rel="noopener">https://github.com/repoforge</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpm -ivh http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm</div><div class="line"></div><div class="line">#yum localinstall --nogpgcheckhttp://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/leshami/article/details/78133716&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CentOS 7下配置本地yum源及yum客户端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/conling_/article/details/70399694&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Centos7 配置本地源+阿里yum源/epel-yum+修改优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/kingfox/article/details/51233153&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;调整CentOS 7中yum仓库的优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000375848&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;国内开源站点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Yum" scheme="https://zhang21.github.io/tags/Yum/"/>
    
  </entry>
  
  <entry>
    <title>写给2017</title>
    <link href="https://zhang21.github.io/2018/01/01/%E5%86%99%E7%BB%992017/"/>
    <id>https://zhang21.github.io/2018/01/01/写给2017/</id>
    <published>2018-01-01T02:25:20.000Z</published>
    <updated>2018-01-09T05:42:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2018.jpg" alt="2018"></p><p><br><br><a id="more"></a></p><h1 id="2017大事件"><a href="#2017大事件" class="headerlink" title="2017大事件"></a>2017大事件</h1><ul><li>Feb.27.2017，开始工作；</li><li>May.27.2017，工作转正；</li><li>Jun.25.2017，大学毕业；</li><li>Aug.27.2017，工作半年；</li><li>Aug.30.2017，搭建博客。</li></ul><p>记得大四下期的时候，在学校实在是想出来工作，以为这样就可以有工资有点钱可以实现财务自由。Naive x3!</p><p>记得刚去面试的时候，公司的HR问我期待的薪资是多少。我这个老实人也不敢往高了说，以为能解决温饱就不错。这就导致后面日子过得紧巴巴，生活基本上处于没钱不敢消费不敢出去的惨状。Naive x3!</p><p>记得那天是星期四，从学校收拾了一箱子的衣物加上自己的笔记本就来了成都。还要感谢<strong>强</strong>对我的帮助，在他那借宿了两天。这两天跑到公司附近找房子，这打个电话，那去看看…结果看了看自己兜里不到三千，再看看房租，还是算了吧！后来由于周一就要开始去公司报道了，实在没办法，硬着头皮找了一个750的单间。我现在觉得，人在生活面前真的没有办法。借用张主任的一句话——“是生活，生活强奸了所有人。”一个套三的屋子，硬是被房主改造成了七间房，住了11人。我想各位住户都迫于无奈吧，有谁想和别人挤在一起了，况且还要忍受上厕所的艰难时光。<br>还是说说我住的那间房屋吧。是客厅使用木板隔得房间，手指随便敲几下都铛铛作响，况且隔壁还住了一对情侣。一张床，一个烂小衣柜，一张摆放电脑的桌子。客厅的后面有一个阳台，所以就会有一个大窗户间隔阳台。然而这个阳台是和隔壁公用的，也就是说，这个大窗户是可以互通的。哎！阳台风大，还好我只住到了夏天。<br>五月二十号，和我强一起搬到了中和。也是没有做好十足打算，说搬就搬了。虽说住宿条件好了一些，可这面修路是真的堵，公家车是真的挤，真的是挤得怀疑人生的那种，还是走路吧。由于搬过来中和，房租和其他开支多了一些，刚开始没什么钱的时候，自己带饭去公司。我都佩服自己，那么挤得车上还能坚持带饭几个月，看来还是穷吧。冬天到了，太冷了就没有带饭到公司了。但公司楼下吃饭真的好贵，吃不起吃不起。由于住宿条件好了一些，晚上回来可以自己做饭，还是不错。并且晚上基本有两个小时干干工作之外的事情，看看小说、看看电视、发发呆什么也挺好的！</p><p>记得才开始工作的时候，好像每天都很闲，没有事做。心里担忧的不行，这样怎么有提升呢？每天都急躁不安，这不会那不会，又腼腆害羞…后来慢慢理解，任何事情都不能操之过急，不能带着情绪上班。不喜欢某个同事也不能表现出来，更不能带到工作上。工作是工作，生活是生活，一定要分开。被骂也没有办法，骂吧，你骂高兴。任何人都不会听你的理由，理由对于别人来说只是你没有完成的狡辩。踏踏实实上班，做好自己的事情才是正解！千万不要好为人师，人都是有嫉妒心得，不要太招摇！也不要羡慕别人工作轻松之类，那是人家的工作，和你没有半毛钱关系。上班好好上班，不要搞东搞西。我个人比较看重效率，怀着为了加班而加班的目的真的没有必要。那时由于住单间，条件差，愿意在公司多呆一会，多学习知识。越到后面，觉得自己越得努力学习新知识，需要了解的知识就在那，就等我把它们一个个打上勾，撸起袖子加油干。</p><p><br></p><p><strong>自我批评:</strong></p><ul><li>心胸不够宽广，容易嫉妒别人；</li><li>害羞爱面子，拉不下面子做事情；</li><li>由于自卑心理导致的不敢说不敢争。</li></ul><p>以前我以为自己是讨厌某种方式、讨厌别人炫耀、讨厌别人秀恩爱，现在才知道是由于自己没有，就用自己的不屑和厌恶来突出自己，让自己心安理得。说白了还不是自己嫉妒人家，嫉妒人家比我好，有女票。这点是真的要改，一定要改。千万别用别人的缺点来突出自己，这很SB，切记切记。如同小波所说：“人的一切痛苦，本质都是对于自己无能的愤怒。”</p><p>在学校总幻想自己能成为英雄，总想做一番事业，像历史上的英雄那般。不屑考个老师公务员职位，以为一辈子就那样，混吃等死的咸鱼。其实其它工作不也同样是这样吗。混吃等死的不是任何工作岗位，而是人！任何岗位都可以有所成就。自己也不过只是凡人一个。不过凡人却也可以有自己的一片天地。就像小波说的：“井底之蛙也能拥有自己的一片天地。”</p><p>工作没有高低贵贱之分，不要带着要面子的心情而不愿意做些打杂的活。没有基础的积累，哪来平地起的万丈高楼。不要看不起自己也不要看不起他人。三十年河东三十年河西，此一时彼一时。</p><p>”中国的君子独善其身，这样就没有了尊严。这是因为尊严是属于个人的、不可压缩的空间，这块空间要靠自己来捍卫——捍卫的意思是指敢争、敢打官司、敢动手（勇斗歹徒）。我觉得人还是有点尊严的好，假如个人连个待的地方都没有，就无法为人做事，更不要说做别人的典范。“这句话同样适合我，该说该争该做的时候就应该大胆站出来，有一个男子汉的样子。要敢于亮剑！</p><p>我现在还不太明白我的人生目标是什么，名利？我不知道。我只想做一个懂点道理的人。上班以后感觉也变得世俗化了，不经意间都会主动被动地谈及任何关于钱的话题。我对钱有一些兴趣，但不愿为之受罪。我不想把自己的下半生绑在房子上，虽然我也买不起。找不到人同我谈谈诗歌、文学、历史、足球，谈谈理想和爱情。但正如小波所言：”和我志趣相投的人总不会一个人都没有吧。“我也不顾影自怜了。</p><p><br><br><br></p><h1 id="展望2018"><a href="#展望2018" class="headerlink" title="展望2018"></a>展望2018</h1><ul><li>最重要的事情当然是涨工资啦，哈哈。加油加油，为了涨工资可得好好奋斗；</li><li>如果能找一个离家近一点的工作当然是最好；</li><li>一个人总是孤独寂寞的，能找到一个能相互扶持的人当然最好；</li><li>改善自己的不同，提升自己的优点。扬长避短，向优秀的人多学习。</li></ul><p><br><br><br></p><h1 id="不成熟的想法"><a href="#不成熟的想法" class="headerlink" title="不成熟的想法"></a>不成熟的想法</h1><ul><li>成都这地方什么都要争，连坐个公交地铁也得积极地抢位置，哎；</li><li>人太多，太拥挤，随便去哪都是拥挤的要命。但另一方面却是人越多机会越多；</li><li>原来工作才是一生的主题。但到底图个啥——名？利？</li><li>上班以后认识的人也变少了，圈子也基本没什么了。曾经的同学们也各奔东西了；</li><li>我发觉任何一件事都是矛盾的。正面想是这样，反面想却又是那样，但都有道理。让我想起了一个故事，“一个农夫和一个老板在海边的对话。问：这么努力工作干嘛？答：为了以后能过更轻松的日子。那你看我现在不是挺轻松自在的吗？”</li><li>现在的自媒体为了流量真的是无所不用其极。各种大噱头的标题，完全不负责任的报道，只为吸引流量。到最后都不知道该相信谁，会不会被带节奏…；</li><li>一天24小时。8小时睡觉，8小时上班，3小时上下班，2小时吃饭及其他。It means that I only have 3 hours a day without Rest Day;</li><li>一个人只拥有此生此世是不够的，他还应该拥有诗意的世界。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2018.jpg&quot; alt=&quot;2018&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Zhang" scheme="https://zhang21.github.io/categories/Zhang/"/>
    
    
      <category term="2017" scheme="https://zhang21.github.io/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>君子的尊严</title>
    <link href="https://zhang21.github.io/2017/12/28/%E5%90%9B%E5%AD%90%E7%9A%84%E5%B0%8A%E4%B8%A5/"/>
    <id>https://zhang21.github.io/2017/12/28/君子的尊严/</id>
    <published>2017-12-28T01:58:32.000Z</published>
    <updated>2017-12-28T02:00:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者是个学究，待人也算谦和有礼，自以为算个君子——当然，实际上是不是，还要别人来评判。总的来说，君子是有文化有道德的人，是士人或称知识分子。按照中国的传统，君子是做人的典范。君子不言利。君子忍让不争。君子动口不动手。君子独善其身。这都是老辈子传下来的规矩，时至今日，以君子自居的人还是如此行事。我是宁做君子不做小人的，但我还是以为，君子身上有些缺点，不配作为人的典范；因为他太文弱、太窝囊、太受人欺。</p><a id="more"></a><p><br></p><p>君子既不肯与人争利，就要安于清贫。但有时不是钱的问题，是尊严的问题。前些时候在电视上看到北京的一位人大代表发言，说儿童医院的挂号费是一毛钱，公厕的收费是两毛钱。很显然，这样的收费标准有损医务工作的尊严。当然，发言的结尾是呼吁有关领导注意这个问题，有关领导也点点头说：是呀是呀，这个问题要重视。我总觉得这位代表太君子，没把话讲清楚——直截了当的说法是：我们要收两块钱。别人要是觉得太贵，那你就还个价来——这样三下五除二就切入了正题。这样说话比较能解决问题。</p><p><br></p><p>君子不与人争，就要受气。举例来说，我乘地铁时排队购票，总有些不三不四的人到前面加塞。说实在的，我有很多话要说：我排队，你为什么不排队？你忙，难道我就没有事？但是碍于君子的规范，讲不出口来。话憋在肚子里，难免要生气。有时气不过，就嚷嚷几句：排队，排队啊。这种表达方式不够清晰，人家也不知是在说他。正确的方式是：指住加塞者的鼻子，口齿清楚地说道：先生，大家都在排队，请你也排队。但这样一来，就陷入与人争论的境地，肯定不是君子了。</p><p><br></p><p>常在报纸上看到这样的消息：流氓横行不法，围观者如堵，无人上前制止。我敢断定，围观的都是君子，也很想制止，但怎么制止呢？难道上前和他打架吗？须知君子动口不动手啊。我知道英国有句俗话：绅士动拳头，小人动刀子。假如在场的是英国绅士，就可以上前用拳头打流氓了。</p><p><br></p><p>既然扯到了绅士，就可以多说几句。从前有个英国人到澳大利亚去旅行，过海关时，当地官员问他是干什么的。他答道：我是一个绅士。因为历史的原因，澳大利亚人不喜欢听到这句话，尤其不喜欢听到这句话从一个英国人嘴里说出来。那官员又问：我问你的职业是什么？英国人答道：职业就是绅士。难道你们这里没有绅士吗？这下澳大利亚人可火了，差点揍他，幸亏有人拉开了。在英美，说某人不是绅士，就是句骂人话。当然，在我们这里说谁不是君子，等于说他是小人，也是句骂人话。但君子和绅士不是一个概念。从字面上看，绅士（gentleman）是指温文有礼之人，其实远不止此。绅士要保持个人的荣誉和尊严，甚至可以说是这方面的专业户。坦白地说，他们有点狂傲自大。但也有一种好处：真正的绅士决不在危险面前止步。大战期间，英国绅士大批开赴前线为国捐躯，甚至死在了一般人前面。君子的标准里就不包括这一条。</p><p><br></p><p>中国的君子独善其身，这样就没有了尊严。这是因为尊严是属于个人的、不可压缩的空间，这块空间要靠自己来捍卫——捍卫的意思是指敢争、敢打官司、敢动手（勇斗歹徒）。我觉得人还是有点尊严的好，假如个人连个待的地方都没有，就无法为人做事，更不要说做别人的典范。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者是个学究，待人也算谦和有礼，自以为算个君子——当然，实际上是不是，还要别人来评判。总的来说，君子是有文化有道德的人，是士人或称知识分子。按照中国的传统，君子是做人的典范。君子不言利。君子忍让不争。君子动口不动手。君子独善其身。这都是老辈子传下来的规矩，时至今日，以君子自居的人还是如此行事。我是宁做君子不做小人的，但我还是以为，君子身上有些缺点，不配作为人的典范；因为他太文弱、太窝囊、太受人欺。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="王小波" scheme="https://zhang21.github.io/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>个人尊严</title>
    <link href="https://zhang21.github.io/2017/12/28/%E4%B8%AA%E4%BA%BA%E5%B0%8A%E4%B8%A5/"/>
    <id>https://zhang21.github.io/2017/12/28/个人尊严/</id>
    <published>2017-12-28T01:54:39.000Z</published>
    <updated>2017-12-28T01:56:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>在国外时看到，人们对时事做出价值评判时，总是从两个独立的方面来进行：一个方面是国家或者社会的尊严，这像是时事的经线；另一个方面是个人的尊严，这像是时事的纬线。回到国内，一条纬线就像是没有，连尊严这个字眼也感到陌生了。提到尊严这个概念，我首先想到的英文词＂dignity＂，然后才想到相应的中文词。在英文中，这个词不仅有尊严之义，还有体面、身份的意思。尊严不但指人受到尊重，它还是人价值之所在。从上古到现代，数以亿万计的中国人里，没有几个人有过属于个人的尊严。举个大点的例子，中国历史上有过皇上对大臣施廷杖的事，无论是多大的官，一言不和，就可能受到如此当众羞辱，高官尚且如此，遑论百姓。除了皇上一人，没有一个人能有尊严。有一件最怪的事是，按照传统道德，挨皇帝的板子倒是一种光荣，文死谏嘛。说白了就是：无尊严就是有尊严。此话如有任何古怪之处，罪不在我。到了现代以后，人与人的关系、个人与集体的关系，仍有这种遗风──我们就不必细说文革中、文革前都发生过什么样的事情。到了现在，已经不用见官下跪，也不会在屁股上挨板子，但还是缺少个人的尊严。环境就是这样，公共场所的秩序就是这样，人对人的态度就是这样，不容你有任何自尊。</p><a id="more"></a><p><br></p><p>举个小点的例子，每到春运高潮，大家就会在传媒上看到一辆硬座车厢里挤了三四百人，厕所里也挤了十几人。谈到这件事，大家会说国家的铁路需要建设，说到铁路工人的工作难做，提到安全问题，提到所有的方面，就是不提这些民工这样挤在一起，好像一个团，完全没有了个人的尊严──仿佛这件事很不重要似的。当然，只要民工都在过年时回家，火车总是要挤的；谁也想不出好办法。但个人的尊严毕竟大受损害；这件事总该有人提一提才对。另一件事现在已是老生常谈，人走在街上感到内急，就不得不上公共厕所。一进去就觉得自己的尊严一点都没了。现在北京的公厕正在改观，这是因为外国人到了中国也会内急，所以北京的公厕已经臭名远扬。假如外国人不来，厕所就要臭下去；而且大街上改了，小胡同里还没有改。我认识的一位美国留学生说，有一次他在小胡同里内急，走进公厕撒了一泡尿，出来以后，猛然想到自己刚才满眼都对黄白之物，居然能站住了不倒，觉得自己很了不起，就急忙来告诉我。北京的某些街道很脏很乱，总要到某个国际会议时才能改观，这叫借某某会的东风。不光老百姓这样讲，领导上也这样讲。这话听起来很有点不对味。不雅的景象外人看了丢脸，没有外人时，自己住在里面也不体面──这后一点总是被人忘掉。</p><p><br></p><p>作为一个知识分子，我发现自己曾有一种特别的虚伪之处，虽然一句话说不清，但可以举些例子来说明。假如我看到火车上特别挤，就感慨一声道：这种事居然可以发生在中华人民共和国的土地上！假如我看到厕所特脏，又长叹一声：唉！北京市这是怎么搞的嘛！这其中有点幽默的成份，也有点当真。我的确觉得国家和政府的尊严受到了损失，并为此焦虑着。当然，我自己也想要点个人尊严，但以个人名义提出就过于直露，不够体面──言必称天下，不以个人面目出现，是知识分子的尊严所在。当然，现在我把这做为虚伪提出，已经自外于知识分子。但也有种好处，我找到了自己的个人面目。有关尊严问题，不必引经据典，我个人就是这么看。但中国忽视个人尊严，却不是我的新发现。从大智者到通俗作家，有不少人注意到一个有中国特色的现象：罗素说，中国文化里只重家族内的私德，不重社会的公德公益，这一点造成了很要命的景象；费孝通说，中国社会里有所谓＂差序格局＂，与己关系近的就关心，关系远的就不关心或少关心；结果有些事从来就没人关心。龙应台为这类事而愤怒过，三毛也大发过一通感慨。读者可能注意到了，所有指出这个现象的人，或则是外国人，或则曾在国外生活过，又回到了国内。没有这层关系的中国人，对此浑然不觉。笔者自己曾在外国居住四年，假如没有这种经历，恐怕也发不出这种议论──但这一点并不让我感到开心。环境脏乱的问题，火车拥挤的问题，社会秩序的问题，人们倒是看到了。但总从总体方面提出问题，讲国家的尊严、民族的尊严。其实这些事就发生在我们身边，削我们每个人的面子──对此能够浑然无觉，倒是咄咄怪事。</p><p><br></p><p>人有无尊严，有一个简单的判据，是看他被当作一个人还是一个东西来对待。这件事有点两重性，其一是别人把你当做人还是东西，是你尊严之所在。其二是你把自己看成人还是东西，也是你的尊严所在。挤火车和上公共厕所时，人只被当身体来看待。这里既有其一的成份，也有其二的成份；而且归根结蒂，和我们的文化传统有关。</p><p><br></p><p>说来也奇怪，中华礼仪之邦，一切尊严，都从整体和人与人的关系上定义，就是没有个人的位置。一个人不在单位里、不在家里，不代表国家、民族，单独存在时，居然不算一个人，就算是一块肉。这种算法当然是有问题。我的算法是：一个人独处荒岛而且谁也不代表，就像鲁滨孙那样，也有尊严，可以很好的活着。这就是说，个人是尊严的基本单位。知道了这一点，火车上太挤了之后，我就不会再挤进去而且浑然无觉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在国外时看到，人们对时事做出价值评判时，总是从两个独立的方面来进行：一个方面是国家或者社会的尊严，这像是时事的经线；另一个方面是个人的尊严，这像是时事的纬线。回到国内，一条纬线就像是没有，连尊严这个字眼也感到陌生了。提到尊严这个概念，我首先想到的英文词＂dignity＂，然后才想到相应的中文词。在英文中，这个词不仅有尊严之义，还有体面、身份的意思。尊严不但指人受到尊重，它还是人价值之所在。从上古到现代，数以亿万计的中国人里，没有几个人有过属于个人的尊严。举个大点的例子，中国历史上有过皇上对大臣施廷杖的事，无论是多大的官，一言不和，就可能受到如此当众羞辱，高官尚且如此，遑论百姓。除了皇上一人，没有一个人能有尊严。有一件最怪的事是，按照传统道德，挨皇帝的板子倒是一种光荣，文死谏嘛。说白了就是：无尊严就是有尊严。此话如有任何古怪之处，罪不在我。到了现代以后，人与人的关系、个人与集体的关系，仍有这种遗风──我们就不必细说文革中、文革前都发生过什么样的事情。到了现在，已经不用见官下跪，也不会在屁股上挨板子，但还是缺少个人的尊严。环境就是这样，公共场所的秩序就是这样，人对人的态度就是这样，不容你有任何自尊。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="王小波" scheme="https://zhang21.github.io/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>SaltStack</title>
    <link href="https://zhang21.github.io/2017/12/25/SaltStack/"/>
    <id>https://zhang21.github.io/2017/12/25/SaltStack/</id>
    <published>2017-12-25T01:47:39.000Z</published>
    <updated>2018-01-11T07:31:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>SaltStack官网：<a href="https://saltstack.com" target="_blank" rel="noopener">https://saltstack.com</a> ;</li><li>SaltStack官方文档：<a href="https://docs.saltstack.com" target="_blank" rel="noopener">https://docs.saltstack.com</a> ;</li><li>SaltStack-GitHub：<a href="https://github.com/saltstack" target="_blank" rel="noopener">https://github.com/saltstack</a> ;</li><li>Salt-repo：<a href="https://repo.saltstack.com/" target="_blank" rel="noopener">https://repo.saltstack.com/</a> .</li></ul><p>环境：</p><ul><li>CentOS7_x64;</li><li>Salt-2017.7.2</li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a>Instruction</h1><p><code>SaltStack</code>是一种革命性的用速度(speed)取代复杂性(complexity)的基础设施(infrastucture)管理方法。</p><ul><li>简单(Simple)，可以在几分钟内运行；</li><li>可伸缩性(Scalable)，足以管理数以万计的Server；</li><li>快速(Fast)，能在几秒内与各系统间进行通信。</li></ul><p><br></p><p><strong>You’ll learn how to:</strong></p><ul><li>安装和配置SaltStack；</li><li>在所有托管系统上远程执行命令(Remotely execute commands)；</li><li>设计、开发和部署系统配置；</li><li>使用Salt Reactor是基础设施自动化(automate)；</li><li>使用Salt Orchestration协调复杂管理操作。</li></ul><p><img src="/images/Salt/SaltStack.png" alt="SaltStack"></p><p><br></p><p>Salt是建立在动态通信总线(dynamic communication bus)上的基础设施管理的一种新方法。Salt可以用于数据驱动(data-driven)业务，远程执行(remote execution)任何基础设施，配置管理(configuration management)任意应用堆栈…</p><ul><li>REMOTE EXECUTION;</li><li>CONFIGURATION MANAGEMENT;</li><li>EVENT-DRIVEN INFRASTRUCTURE;</li><li>SALT ESSENTIALS.</li></ul><p><br></p><hr><p><br></p><h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><p>如果是第一次设置环境，你应该在专用的管理服务器上安装<code>Salt master</code>，然后在每个使用Salt管理的系统上安装<code>Salt minion</code>。现在不需要担心你的系统架构(architecture)，你可以在以后轻易添加组件(componet)和修改配置(configuration)而不需要重新安装任何东西。</p><p>The general installation process is as follows:</p><ul><li>安装<code>Salt master</code>，通过各平台说明安装或通过Salt <code>bootstrap.sh</code>脚本来安装；</li><li>确保你的<code>Salt minion</code>能够找到<code>Salt master</code>；</li><li>在想要管理的每个系统上安装<code>Salt minion</code>；</li><li>在<code>Salt minion</code>连接后接受<code>Salt minion key</code>。</li></ul><p>在此之后，就可以<strong>运行一个简单命令</strong>，并从所有的<code>Salt minion</code><strong>接收返回</strong>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#salt &lt;minion-id&gt; &lt;cmd&gt;</span></div><div class="line"></div><div class="line">salt minion1 test.ping</div><div class="line">salt * test.ping</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Quick-Install"><a href="#Quick-Install" class="headerlink" title="Quick Install"></a>Quick Install</h2><p>在绝大多数发行版本上，可以使用<strong>Salt Bootstrap</strong>脚本进行快速安装。</p><p>参考：<a href="https://docs.saltstack.com/en/latest/topics/tutorials/salt_bootstrap.html#salt-bootstrap" target="_blank" rel="noopener">Salt Bootstrap</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#wget</div><div class="line">wget https://bootstrap.saltstack.com -O bootstrap-salt.sh</div><div class="line">sh bootstrap-salt.sh</div><div class="line"></div><div class="line">#curl</div><div class="line">curl -o bootstrap-salt.sh -L https://bootstrap.saltstack.com</div><div class="line">sh bootstrap-salt.sh</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Platform-Specific-Installation"><a href="#Platform-Specific-Installation" class="headerlink" title="Platform-Specific Installation"></a>Platform-Specific Installation</h2><p><a href="https://docs.saltstack.com/en/latest/topics/installation/index.html#platform-specific-installation-instructions" target="_blank" rel="noopener">选择发行版本安装</a></p><p><br></p><h3 id="在CentOS7上安装Salt"><a href="#在CentOS7上安装Salt" class="headerlink" title="在CentOS7上安装Salt"></a>在CentOS7上安装Salt</h3><p>repo: <a href="https://repo.saltstack.com/#rhel" target="_blank" rel="noopener">https://repo.saltstack.com/#rhel</a></p><p><strong>1. 下载SaltStack-Repository进行安装：</strong></p><p><code>systemd</code>和<code>systemd-python</code>是Salt必须的，在安装Salt前需装好。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#安装salt-repo</span></div><div class="line">yum install -y https://repo.saltstack.com/yum/redhat/salt-repo-latest-2.el7.noarch.rpm</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">yum clean expire-cache</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#安装salt组件</span></div><div class="line">yum install -y salt-master salt-master salt-ssh salt-syndic salt-cloud salt-api</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#开启</span></div><div class="line">systemctl start salt-master</div></pre></td></tr></table></figure><p><br></p><p><strong>2. 自建salt-repo：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">vim /etc/yum.repos.d/saltstack.repo</div><div class="line"></div><div class="line"></div><div class="line">[saltstack-repo]</div><div class="line">name=SaltStack repo <span class="keyword">for</span> Cent0S7</div><div class="line">baseurl=https://repo.saltstack.com/yum/redhat/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/latest</div><div class="line">enalbed=1</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=https://repo.saltstack.com/yum/redhat/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/latest/SALTSTACK-GPG-KEY.pub</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Initial-Configuration"><a href="#Initial-Configuration" class="headerlink" title="Initial Configuration"></a>Initial Configuration</h2><h3 id="Configuration-Salt"><a href="#Configuration-Salt" class="headerlink" title="Configuration Salt"></a>Configuration Salt</h3><p><code>salt-master</code> 的默认配置会为安装而工作，唯一要求是在<code>salt-minion</code>的配置文件中设置<code>salt-master</code>的位置。</p><p><br></p><h4 id="salt-master-configuration"><a href="#salt-master-configuration" class="headerlink" title="salt-master configuration"></a>salt-master configuration</h4><p>默认的，<code>salt-master</code>配置文件位于<code>/etc/salt/master</code>，在all interfaces(0.0.0.0)上监听<code>4505</code>和<code>4506</code>端口。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim /etc/salt/master</div><div class="line"></div><div class="line"></div><div class="line">interface: 0.0.0.0</div></pre></td></tr></table></figure><p><br></p><h4 id="salt-minion-configuration"><a href="#salt-minion-configuration" class="headerlink" title="salt-minion configuration"></a>salt-minion configuration</h4><p>默认，一个<code>salt-minion</code>会尝试连接到DNS名称为<code>salt</code>。如果<code>salt-minion</code>能够正确解析(resolve)这个名称，则可以不需要配置文件。如果DNS名称<code>salt</code>未能解析为<code>salt-master</code>的正确位置，那么可在<code>/etc/salt/minion</code>配置文件下重新定义<code>salt</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vim /etc/salt/minion</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#master: salt</span></div><div class="line"><span class="comment">#如果是默认的salt,需要在本地hosts下解析salt</span></div><div class="line"></div><div class="line"><span class="comment">#此处我们修改为salt-master的IP地址</span></div><div class="line">master: 192.168.1.9</div></pre></td></tr></table></figure><p><strong>修改配置文件后，请重启服务。</strong></p><p><br></p><h4 id="Proxy-Minion-Configuration"><a href="#Proxy-Minion-Configuration" class="headerlink" title="Proxy Minion Configuration"></a>Proxy Minion Configuration</h4><p>A Proxy Minion 模仿一个规律的行为和继承(inherit)他们的选项。<br>类似地，它的配置文件存放于<code>/etc/salt/proxy</code>，<code>proxy</code>也将尝试连接DNS名为<code>salt</code>的主机。</p><p>除了<code>salt-minion</code>有规律的选型，<code>proxy</code>还有一些特定的选项。参考:<a href="https://docs.saltstack.com/en/latest/ref/configuration/proxy.html#configuration-salt-proxy" target="_blank" rel="noopener">Proxy minion</a></p><p><br></p><h4 id="Running-Salt"><a href="#Running-Salt" class="headerlink" title="Running Salt"></a>Running Salt</h4><p>以<code>salt</code>命令运行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">salt-master</div><div class="line"></div><div class="line"><span class="comment">#开启守护进程</span></div><div class="line">dalt-master -d</div><div class="line"></div><div class="line"></div><div class="line">salt-minion</div><div class="line">salt-minion -d</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#日志信息</span></div><div class="line">salt-master --<span class="built_in">log</span>-level=debug</div></pre></td></tr></table></figure><p><strong>以non-root user运行salt</strong></p><ul><li>确保此用户有相应的权限；</li><li>可能需要手动创建<code>salt</code>运行需要的目录<code>/etc/salt, /var/cache/salt, /var/log/salt, /var/run/salt</code>。</li></ul><p><br></p><h4 id="Key-Identity"><a href="#Key-Identity" class="headerlink" title="Key Identity"></a>Key Identity</h4><p>在<code>initial key</code>交换之前，<code>Salt</code>会提供命令来验证(validate)<code>salt-master</code>和<code>salt-minion</code>的身份。<br>验证身份有助于避免疏忽地连接到错误的<code>salt-master</code>，并且在建立初始化连接的阻止MiTM攻击。</p><p><strong>Master Key Fingerprint</strong><br>复制<code>master.pub</code>的值，并将其作为<code>salt-minion</code>配置文件<code>/etc/salt/minion</code>中<code>master_finger</code>的值。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#salt-key is used to manage Salt authentication keys</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#显示master的key</span></div><div class="line">salt-key -F master</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看minion的finger</span></div><div class="line"><span class="comment">#salt-key --finger &lt;minion_id&gt;</span></div><div class="line">dalt-key --finger <span class="string">'192.168.1.7'</span></div></pre></td></tr></table></figure><p><strong>Minion Key Fingerprint</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">salt-call is used to execute module <span class="built_in">functions</span> locally on a Salt Minion</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看minion key fingerprint</span></div><div class="line"><span class="comment">#可在master上查看，比对两者是否相同</span></div><div class="line">salt-call --<span class="built_in">local</span> key.finger</div></pre></td></tr></table></figure><p><br></p><h4 id="Key-Management"><a href="#Key-Management" class="headerlink" title="Key Management"></a>Key Management</h4><p>Salt使用AES Encryption加密<code>salt-master</code>与<code>salt-minion</code>间的所有通信。这确保了发送到Minion的命令不会被篡改(tamper)，并保证了master与minion间是认证的和受信任的。</p><p>当命令发送到<code>salt-minion</code>之前，<code>salt-minion</code>的key必须要被<code>salt-master</code>所接受。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#列出salt-master上已知的keys</span></div><div class="line">salt-key -L</div></pre></td></tr></table></figure><p>其中包含四项:</p><ul><li>Accepted Keys:</li><li>Denied Keys:</li><li>Unaccepted keys:</li><li>Rejected keys:</li></ul><p><strong>让<code>salt-master</code>接收key，并允许<code>salt-minion</code>被<code>salt-master</code>控制</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-a 192.168.1.7, --accept=192.168.1.7</span></div><div class="line"><span class="comment">#-A, --accept-all</span></div><div class="line"></div><div class="line">salt-key -A</div></pre></td></tr></table></figure><p><br></p><h4 id="Sending-Commands"><a href="#Sending-Commands" class="headerlink" title="Sending Commands"></a>Sending Commands</h4><p><code>salt-master</code>和<code>salt-minion</code>之间通过运行<code>test.ping</code>命令来证实(verified)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">salt 192.168.1.7 test.ping</div><div class="line"></div><div class="line">salt * test.ping</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Additional-Installation-Guides"><a href="#Additional-Installation-Guides" class="headerlink" title="Additional Installation Guides"></a>Additional Installation Guides</h2><h3 id="Salt-Bootstrap"><a href="#Salt-Bootstrap" class="headerlink" title="Salt Bootstrap"></a>Salt Bootstrap</h3><p>Salt Bootstrap脚本允许用户在各种系统和版本上安装<code>salt-minion</code>和<code>salt-master</code>。shell脚本为<code>bootstrap-salt.sh</code>，运行一系列的检查来确定操作系统的类型和版本，然后通过适当的方法安装salt二进制文件。salt-bootstrap脚本安装运行<code>salt</code>的最小化安装包，如Git便不会安装。</p><p>Salt Bootstrap’s GitHub: <a href="https://github.com/saltstack/salt-bootstrap" target="_blank" rel="noopener">https://github.com/saltstack/salt-bootstrap</a></p><p><br></p><h4 id="Example-Usage"><a href="#Example-Usage" class="headerlink" title="Example Usage"></a>Example Usage</h4><p>Satl Bootstrap脚本有多种可以传递的选项，以及获取引导脚本本身的方法。</p><p><strong>1. Using <code>curl</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -o bootstrap-salt.sh -L https://bootstrap.saltstack.com</div><div class="line">sh bootstrap-salt.sh git develop</div></pre></td></tr></table></figure><p><strong>2. Using <code>wget</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget -O bootstrap-salt.sh https://bootstrap.saltstack.com</div><div class="line">sh bootstrap-salt.sh</div></pre></td></tr></table></figure><p><strong>3. An Insecure one-liner</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -L https://bootstrap.saltstack.com | sh</div><div class="line"></div><div class="line">wget -O - https://bootstrap.saltstack.com | sh</div><div class="line"></div><div class="line">curl -L https://bootstrap.saltstack.com | sh -s -- git develop</div></pre></td></tr></table></figure><p><strong>4. cmd line options</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#查看帮助</div><div class="line">sh bootstrap-salt.sh -h</div></pre></td></tr></table></figure><p><br></p><h3 id="Openging-the-firewall-up-for-salt"><a href="#Openging-the-firewall-up-for-salt" class="headerlink" title="Openging the firewall up for salt"></a>Openging the firewall up for salt</h3><p><code>salt-master</code>和<code>salt-minion</code>间的通信使用AES加密的<code>ZeroMQ</code>，它使用TCP的<code>4505</code>和<code>4506</code>端口，仅需要在<code>salt-master</code>上可访问就行。</p><p>下面概述了关于<code>salt-master</code>的防火墙规则：</p><p><strong>RHEL7/CENTOS7</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --permanent --zone=&lt;zone&gt; --add-port=4505-4506/tcp</div><div class="line">firewall-cmd --reload</div></pre></td></tr></table></figure><p><br></p><h3 id="Preseed-minion-with-accepted-key"><a href="#Preseed-minion-with-accepted-key" class="headerlink" title="Preseed minion with accepted key"></a>Preseed minion with accepted key</h3><p>某些情况下，在<code>salt-master</code>上接受<code>minion-key</code>之前等待<code>salt-minion</code>启动是不方便的。比如，你可能希望<code>minion</code>一上线(online)就引导。</p><p>有多种方式生成<code>minion-key</code>，下面是一般生成<code>minion-key</code>的四个步骤：</p><ol><li>在<code>salt-master</code>上生成<code>key</code>：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#请给key取个名字</div><div class="line">salt-key --gen-keys=[key_name]</div></pre></td></tr></table></figure><ol><li>把公钥(publick key)添加到已接受的<code>salt-minion</code>文件夹中:</li></ol><p>公钥文件和 minion_id 有相同的名字是很有必要的，这就是Salt如何通过key与minions匹配。<br>还有，由于不同操作系统或特定的master配置文件，pki 文件夹可能位于不同的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp &lt;key_name&gt;.pub /etc/salt/pkimaster/minions/&lt;minion_id&gt;</div></pre></td></tr></table></figure><ol><li>分配<code>minion-key</code>：</li></ol><p>对于minion来说，没有单一方法去得到密钥对，难点是找到一种安全的分配方法。</p><p>由于<code>master</code>已经接受了<code>minion-key</code>，因此分发私钥(private key)会有潜在的安全风险。</p><ol><li>配置带key的minion：</li></ol><p>你可能希望在启动<code>salt-miniont daemon</code>之前取得<code>minion-key</code>的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/etc/salt/pki/minion/minion.pem</div><div class="line">/etc/salt/pki/minion/minion.pub</div></pre></td></tr></table></figure><p><br></p><h3 id="Running-salt-as-normal-user-tutorial"><a href="#Running-salt-as-normal-user-tutorial" class="headerlink" title="Running salt as normal user tutorial"></a>Running salt as normal user tutorial</h3><p><strong>以普通用户(non-root)运行salt function</strong></p><p>如果你不想使用<code>root</code>用户安装或运行salt，你可以在你的工作目录中创建一个虚拟根目录(virtual root dir)来配置它。<br>salt system使用<code>salt.syspath</code>module来查找变量。</p><p>如果你运行salt-build，它会生成在: <code>./build/lib.linux-x86_64-2.7/salt/_syspaths.py</code>；</p><p>运行<code>python setup.py build</code>命令来生成它；</p><p>复制生成的module到你的salt dir，<code>cp ./build/lib.linux-x86_64-2.7/salt/_syspaths.py ./salt/_syspaths.py</code></p><p>修改它，并加入需要的变量和新路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># you need to edit this</span></div><div class="line">ROOT_DIR = *your current dir* + <span class="string">'/salt/root'</span></div><div class="line"></div><div class="line"><span class="comment"># you need to edit this</span></div><div class="line">INSTALL_DIR = *location of source code*</div><div class="line"></div><div class="line">CONFIG_DIR =  ROOT_DIR + <span class="string">'/etc/salt'</span></div><div class="line">CACHE_DIR = ROOT_DIR + <span class="string">'/var/cache/salt'</span></div><div class="line">SOCK_DIR = ROOT_DIR + <span class="string">'/var/run/salt'</span></div><div class="line">SRV_ROOT_DIR= ROOT_DIR + <span class="string">'/srv'</span></div><div class="line">BASE_FILE_ROOTS_DIR = ROOT_DIR + <span class="string">'/srv/salt'</span></div><div class="line">BASE_PILLAR_ROOTS_DIR = ROOT_DIR + <span class="string">'/srv/pillar'</span></div><div class="line">BASE_MASTER_ROOTS_DIR = ROOT_DIR + <span class="string">'/srv/salt-master'</span></div><div class="line">LOGS_DIR = ROOT_DIR + <span class="string">'/var/log/salt'</span></div><div class="line">PIDFILE_DIR = ROOT_DIR + <span class="string">'/var/run'</span></div><div class="line">CLOUD_DIR = INSTALL_DIR + <span class="string">'/cloud'</span></div><div class="line">BOOTSTRAP = CLOUD_DIR + <span class="string">'/deploy/bootstrap-salt.sh'</span></div></pre></td></tr></table></figure><p>创建目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir -p root/etc/salt root/var/cache/run root/run/salt root/srv</div><div class="line">root/srv/salt root/srv/pillar root/srv/salt-master root/var/log/salt root/var/run</div></pre></td></tr></table></figure><p>填充配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cp -r conf/* /etc/salt/</div><div class="line"></div><div class="line"></div><div class="line">vi /etc/salt/master</div><div class="line"></div><div class="line">user: *your user name*</div></pre></td></tr></table></figure><p>运行：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PYTHONPATH=`pwd` scripts/salt-cloud</div></pre></td></tr></table></figure><p><br></p><h3 id="Standalone-minion"><a href="#Standalone-minion" class="headerlink" title="Standalone minion"></a>Standalone minion</h3><p>因为<code>salt-minion</code>包含了如此广泛的功能，它可以独立运行。一个<code>standalone minion</code>可以用来做很多事情:</p><ul><li>在没有连接到<code>master</code>的系统上使用<code>salt-call</code>命令；</li><li>无主状态(masterless states)。</li></ul><p>当以无主模式运行salt时，不要运行<code>salt-minion daemon</code>。否则，它将尝试连接到master并失败。<br><code>salt-call</code>命令是独立的，不需要<code>salt-minion daemon</code>。</p><p><br></p><h4 id="minion-configuration"><a href="#minion-configuration" class="headerlink" title="minion configuration"></a>minion configuration</h4><p>有几个参考方法来设置不同的选项来配置<code>masterless minion</code>，<code>salt-minion</code>很容易通过配置文件(默认位于:<code>/etc/salt/minion</code>)进行配置。</p><p><br></p><p><strong>告诉salt运行masterless</strong></p><p><code>salt-call</code>命令用于在<code>salt-minion</code>本地运行模块功能，而不是在<code>salt-master</code>执行他们。通常，<code>salt-call</code>命令检查主机检索文件服务器和支柱数据，当时当运行<code>standalone salt-call</code>时，需要指示不要检查master的这些数据。<br>为了指示<code>minion</code>不要查找<code>master</code>，需要在运行<code>salt-call</code>时设置<code>file_client</code>配置选项。默认情况下，<code>file_client</code>被设置为<code>remote</code>让<code>minion</code>知道将从<code>master</code>中收集文件服务器和支柱数据。当设置<code>file_client</code>为<code>local</code>时，<code>minion</code>将不会从<code>master</code>收集这些数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">file_client:</span> <span class="string">local</span></div><div class="line"></div><div class="line"><span class="comment">#这样，salt-call命令将不会查找master</span></div><div class="line"><span class="comment">#并认为本地系统拥有所有的文件文支柱资源</span></div></pre></td></tr></table></figure><p><br></p><p><strong>masterless运行状态</strong></p><p>the state system在所有需要的文件都在<code>minion</code>本地，轻易地在没有<code>salt-master</code>的情况下运行。为了达到此效果，需要配置<code>minion</code>配置文件，以了解如何像<code>master</code>一样返回file_roots信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">file_roots:</span></div><div class="line"><span class="attr">  base:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">/srv/salt</span></div></pre></td></tr></table></figure><p>现在设置salt state tree, top file和SLS modules，就像在<code>master</code>上设置它们一样。将<code>file_client</code>设置为<code>local</code>，并且一个可用的state tree会调用state module中的function，将使用<code>minion</code>上的file_roots中的信息而不是<code>master</code>。</p><p>当在一个<code>minion</code>上创建一个<code>state tree</code>时，不需要语法或路径的更改。<code>master</code>上的SLS modules不需要进行任何修改就可以与<code>minion</code>一起工作。这就使得salt scrit不需要设置一个<code>master</code>就能轻易部署，并允许这些SLS modules随着部署发展而容易转移到<code>master</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#以声明的状态可以执行</span></div><div class="line">salt-call state.apply</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#无需修改配置文件</span></div><div class="line">salt-call state.apply --<span class="built_in">local</span></div></pre></td></tr></table></figure><p><br></p><h3 id="Salt-masterless-quickstart"><a href="#Salt-masterless-quickstart" class="headerlink" title="Salt masterless quickstart"></a>Salt masterless quickstart</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SaltStack官网：&lt;a href=&quot;https://saltstack.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://saltstack.com&lt;/a&gt; ;&lt;/li&gt;
&lt;li&gt;SaltStack官方文档：&lt;a href=&quot;https://docs.saltstack.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.saltstack.com&lt;/a&gt; ;&lt;/li&gt;
&lt;li&gt;SaltStack-GitHub：&lt;a href=&quot;https://github.com/saltstack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/saltstack&lt;/a&gt; ;&lt;/li&gt;
&lt;li&gt;Salt-repo：&lt;a href=&quot;https://repo.saltstack.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://repo.saltstack.com/&lt;/a&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7_x64;&lt;/li&gt;
&lt;li&gt;Salt-2017.7.2&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="SaltStack" scheme="https://zhang21.github.io/tags/SaltStack/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://zhang21.github.io/2017/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://zhang21.github.io/2017/12/11/数据结构/</id>
    <published>2017-12-11T05:44:38.000Z</published>
    <updated>2017-12-12T01:56:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>在计算机科学中，<strong>数据结构(data structure)</strong>是计算机中存储、组织数据的方式。<br>大多数数据结构都有数列、记录、可辨识联合、引用等基本类型构成。</p><p>数据结构意味着结构和封装，一个数据结构可被视为两个函数之间的接口，或是由数据类型联合组成的存储内容的访问方法和封装。<br>数据结构可通过程序语言所提供的数据类型、引用及其它操作加以实现。不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计。<br>一个涉及良好的数据结构，应该尽可能使用较少的时间与空间资源的前提下，支持各种程序运行。</p><p>正确选择数据结构可以提高算法的效率，在计算机程序设计里，选择适当的数据结构是一项重要工作。</p><a id="more"></a><p><br></p><hr><h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><ul><li>数组(Array);</li><li>栈(Stack): 后进先出，线性表；</li><li>队列(Queue): 先进先出，线性表；</li><li>链表(Linked List): 每个节点包括两部分，一个存储数据元素的数据域，另一个存储下一个节点地址的指针域；</li><li>树(Tree)；</li><li>图(Graph)；</li><li>堆(Heap): 一种动态树形结构；</li><li>散列表(Hash)；</li></ul><p><br></p><hr><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><p>数组数据结构，是由相同类型的元素的集合所组成，分配一块连续的内存来存储。利用数组元素的索引(index)可计算出元素对应存储地址。</p><p>数组有 <strong>一维数组、二维数组、多维数组、可变长数组…</strong>。</p><p><br></p><hr><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h3><p>堆栈又称为栈，是计算机科学中一种特殊的串列形式的抽象资料类别。<br>其特殊之处在于只能允许在链接串列或阵列的一端(栈顶指标:top)，进行加入数据(push)和取出数据(pop)。</p><p>由于栈数据结构只允许在一端进行操作，因为按照后进先出(LIFO, last-in-first-out)的原理运行。</p><p><br></p><hr><h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h3><p>队列，是先进先出(FIFO, first-in-first-out)的线性表。在具体应用中通常用链表或数组来实现。<br>队列只允许在后端(Rear)进行插入操作，在前端(Front)进行删除操作。</p><p><br></p><hr><h3 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表(Linked List)"></a>链表(Linked List)</h3><p>链表是一种线性表，但并不按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。<br>由于不必须按顺序存储，链表再插入的时候可以达到 O(1)的时间复杂度，比另一种线性表顺序表快得多。但查找一个节点或访问特定节点则需要 O(n)的时间，而顺序表相应的时间复杂度分别是 O(logn)和O(1)。</p><p>是用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了节点的指针域，空间开销比较大。</p><p>链表有<strong>单向链表、双向链表、循环链表…</strong>。<br>链表用来构建许多其它数据结构，如栈，队列和他们的派生。</p><p><br></p><hr><h3 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树(Tree)"></a>树(Tree)</h3><p>树是一种抽象数据类型，用来模拟具有树状结构性质的数据集合。</p><p>树有<strong>有序树、无序树（二叉树，B树，霍夫曼树）</strong>。</p><p><br></p><hr><h3 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图(Graph)"></a>图(Graph)</h3><p>在数学上，一个图是表示物体与物体之间的关系的方法，是图论的基本研究对象。</p><p>图有：<strong>有向图、无向图、简单图、多重图</strong>。</p><p><br></p><hr><h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h3><p>堆是计算机科学中一类特殊的数据结构的统称。<br>堆通常是一个可以被看做一棵树的数组对象。在队列中，调度程序反复提取队列中的第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p><p>堆常用于排序，这种算法称作堆排序。</p><p><br></p><hr><h3 id="散列表-Hash"><a href="#散列表-Hash" class="headerlink" title="散列表(Hash)"></a>散列表(Hash)</h3><p>散列表也叫哈希表，是根据<strong>键(key)</strong>而直接访问在内存存储位置的数据结构。<br>它通过计算一个关于键值的函数，将所需查询的数据映射到表中的一个位置来访问记录，这加快了查找速度。这种映射函数称为散列函数，存放记录的数组称为散列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;在计算机科学中，&lt;strong&gt;数据结构(data structure)&lt;/strong&gt;是计算机中存储、组织数据的方式。&lt;br&gt;大多数数据结构都有数列、记录、可辨识联合、引用等基本类型构成。&lt;/p&gt;
&lt;p&gt;数据结构意味着结构和封装，一个数据结构可被视为两个函数之间的接口，或是由数据类型联合组成的存储内容的访问方法和封装。&lt;br&gt;数据结构可通过程序语言所提供的数据类型、引用及其它操作加以实现。不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计。&lt;br&gt;一个涉及良好的数据结构，应该尽可能使用较少的时间与空间资源的前提下，支持各种程序运行。&lt;/p&gt;
&lt;p&gt;正确选择数据结构可以提高算法的效率，在计算机程序设计里，选择适当的数据结构是一项重要工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Database" scheme="https://zhang21.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="https://zhang21.github.io/2017/12/11/MongoDB/"/>
    <id>https://zhang21.github.io/2017/12/11/MongoDB/</id>
    <published>2017-12-11T02:49:52.000Z</published>
    <updated>2018-02-26T06:20:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://docs.mongodb.com/" target="_blank" rel="noopener">MongoDB官方文档</a></li><li><a href="http://www.mongoing.com/docs" target="_blank" rel="noopener">MongoDB中文文档</a></li><li><a href="https://zh.wikipedia.org/wiki/MongoDB" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/MongoDB</a></li><li><a href="http://www.ywnds.com/?p=5635" target="_blank" rel="noopener">http://www.ywnds.com/?p=5635</a></li><li><a href="https://www.centos.bz/2017/08/mongodb-secure-intro-user-auth/" target="_blank" rel="noopener">https://www.centos.bz/2017/08/mongodb-secure-intro-user-auth/</a></li><li><a href="http://www.03sec.com/3176.shtml" target="_blank" rel="noopener">http://www.03sec.com/3176.shtml</a></li><li><a href="http://www.ywnds.com/?p=6502" target="_blank" rel="noopener">http://www.ywnds.com/?p=6502</a></li><li><a href="http://wiki.jikexueyuan.com/project/the-little-mongodb-book/" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/the-little-mongodb-book/</a></li></ul><p>环境：</p><ul><li>CentOS7_x64；</li><li>MongoDB3.4；</li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>NoSQL(Not Only SQL)是对不同于传统的<strong>关系型数据库</strong>的<strong>数据库管理系统(DBMS)</strong>的统称。<br>NoSQL不使用SQL作为查询语言，其数据结构可以不需要固定的表格模式，有横向可扩展性的特征。<br>NoSQL用于超大规模数据的存储，这些类型的数据存储不需要固定的模式，无序多余操作就可以横向扩展。</p><p><br></p><p>关系型数据库的典型实现主要被调整用于执行规模小而读写频繁，或大批量极少写访问的事务。<br>当代典型的关系型数据库在一些数据敏感的应用中表现了糟糕的性能。例如：</p><ul><li>为巨量文档创建索引</li><li>高流量网站的网页服务</li><li>发送流媒体</li></ul><p><br></p><p>NoSQL数据库分类：</p><table><thead><tr><th>类型</th><th>栗子</th><th>特点</th></tr></thead><tbody><tr><td>文档存储</td><td>MongoDB</td><td>用类似json的格式存储，存储的内容是文档型的。这样就有机会对某些字段建立索引，实现关系数据库的某些功能</td></tr><tr><td>图形关系存储</td><td>Neo4j</td><td>图形关系的最佳存储</td></tr><tr><td>键-值(key-value)存储</td><td>最终一致性的键-值存储 <br> 架构性键-值存储</td><td>xxx</td></tr><tr><td>主机式服务</td><td>key-value硬盘存储 <br> key-value RAM存储</td><td>MemcacheDB <br> Redis</td></tr><tr><td>多数据库</td><td>OpenQM</td><td>xxx</td></tr><tr><td>时序型数据库</td><td>Graphite</td><td>xxx</td></tr><tr><td>对象数据库</td><td>ObjecStore</td><td>通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据</td></tr><tr><td>列存储</td><td>HBase</td><td>顾名思义，按列存储数据。方便存储结构化和半结构化数据，方便做数据压缩，针对某一列或某几列的查询有很大的IO优势。</td></tr></tbody></table><p><br><br><br></p><hr><p><br></p><h1 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h1><p><br></p><p><img src="/images/MongoDB/MongoDB.jpeg" alt="MongoDB"></p><p>MongoDB(<a href="https://www.mongodb.com/" target="_blank" rel="noopener">https://www.mongodb.com/</a>)，是一种文档导向的数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。它是一种NoSQL。<br>MongoDB支持的数据结构非常松散，是类似于json的bson格式，因此可以存储比较复杂的数据类型。<br>MongoDB是一个开源文档数据库，提供高性能，高可用性和自动扩展。</p><p><br></p><p><strong>预备知识：</strong></p><ol><li>MongoDB中的<code>database</code>有和数据库一样的概念。一个MongoDB实例中，可以有零个或多个数据库，每个都作为一个高等容器，用于存储数据；</li><li>MongoDB数据库中有零个或多个<code>collections</code>(集合)。集合类似于传统意义上的<code>table</code>(表)；</li><li>MongoDB的集合是由零个或多个<code>documents</code>(文档)组成。文档类似于<code>row</code>(行)；</li><li>MongoDB的文档由零个或多个<code>fields</code>(字段)组成。字段类似于<code>columns</code>(列)；</li><li>MongoDB中<code>Indexes</code>(索引)扮演的角色与RDMS中一样；</li><li>MongoDB中的<code>Cursors</code>(游标)很重要，当你向MongoDB取数据的时候，它会给你返回一个结果集的指针而不是真正的数据，这个指针我们叫它游标。我们可以用游标做任何事情，比如计数或跨行之类。</li></ol><p><br></p><h2 id="MongoDB特点"><a href="#MongoDB特点" class="headerlink" title="MongoDB特点"></a>MongoDB特点</h2><p>不如这样认为，MongoDB是关系型数据库的一个代替案。比如用<code>Lucene</code>作为关系型数据库的全文检索索引的加强，或者是<code>Redis</code>作为持久性<code>key-value</code>存储。</p><p><strong>无模式(Flexible Schema)</strong>：<br>它不需要一个固定的模式，这使得他们比传统的数据库表要灵活更多。</p><p><br><br><strong>写操作(Writes)</strong>：<br>MongoDB可以胜任的一个特殊角色是在日志领域。有两点使得MongoDB的写操作非常快：</p><ol><li>可以选择发送了写操作之后立刻返回，而无需等到操作完成；</li><li>可以控制数据持久性的写行为。</li></ol><p><br><br><strong>高性能(High Performance)</strong>：<br>MongoDB提供了高性能的数据持久性。尤其是：</p><ul><li>对嵌入式数据模型的支持减少了数据库系统上的I/O活动；</li><li>索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。</li></ul><p><br><br><strong>高可用(High Availability)</strong>：<br>MongoDB的复制工具，称为副本集。提供：自动故障转移和数据冗余。</p><p><br><br><strong>持久性(Durability)</strong>：<br>在MongoDB中，日志(Journaling)是默认启动的，该功能允许快速恢复服务器，比如遭遇到了服务器奔溃或停电的问题。</p><p><br><br><strong>丰富的查询语言(Rich Query Language)</strong>：<br>MongoDB支持丰富的查询语言来支持读写操作(CRUD)，数据聚合(Data Aggregation)，全文搜索(Text Search)。</p><p><br><br><strong>水平可伸缩性(Horizontal Scalability)</strong>：<br>MongoDB提供了横向可伸缩性。</p><p><br><br><strong>支持多个存储引擎(Support for Multiple Storage Engines)</strong>：<br>在MongoDB3.2以后默认引擎为: WiredTiger Storage Engine，允许第三方为MongoDB开发存储引擎。</p><p><br></p><h2 id="database和collection"><a href="#database和collection" class="headerlink" title="database和collection"></a>database和collection</h2><p>MongoDB stores BSON documents.</p><p><img src="/images/MongoDB/collection.png" alt="collection"></p><p><br></p><h3 id="databases"><a href="#databases" class="headerlink" title="databases"></a>databases</h3><p>In MongoDB,databases hold collections of documents.<br>如果一个数据库不存在，当你第一次存储数据时，MongoDB会自动创建数据库。这意味着可以切换到不存在的数据库。</p><p>默认情况下，集合不要求其文档具有相同的模式；文档不要求具有相同的字段集；字段的数据类型在集合的文档间可以有所不同。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#select a db</span></div><div class="line">use &lt;db&gt;</div><div class="line"></div><div class="line"><span class="comment">#create a db</span></div><div class="line">use newdb</div><div class="line">db.newcoll.insert(&#123;name:<span class="string">'zhang'</span>&#125;)</div><div class="line">db.newcoll.insert(&#123;filed01:<span class="string">'filed01'</span>, filed02:<span class="string">'filed02'</span>, filed03:<span class="string">'filed03'</span>, filed04:<span class="string">'filed04'</span>&#125;)</div><div class="line">db.newcoll.insert(&#123;groups: [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]&#125;)</div><div class="line">db.newcoll.find().pretty()</div></pre></td></tr></table></figure><p><br></p><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><p>MongoDB stores documents in collections.<br>collection类似于关系型数据库中的table。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.coll02.insert(&#123;x:1&#125;)</div><div class="line">db.coll03.createIndex(&#123;y:1&#125;)</div></pre></td></tr></table></figure><p><br></p><h3 id="显式创建-explicit-creation"><a href="#显式创建-explicit-creation" class="headerlink" title="显式创建(explicit creation)"></a>显式创建(explicit creation)</h3><p>MongoDB提供了<code>db.createCollection()</code>方法来显式创建一个附带各种选项的集合。如设置document最大大小，文件验证规则等选项。<br>如果不需要指定这些选项，就不需要使用显式创建集合，而直接向集合中插入数据即可。<br>修改collection选项，使用<code>collMod</code>方法。</p><p><br></p><h3 id="视图-View"><a href="#视图-View" class="headerlink" title="视图(View)"></a>视图(View)</h3><p>视图的定义是公开的，视图的解释操作将包括定义视图的管道。因此，避免直接引用视图定义中的敏感字段和值。</p><p><strong>创建/删除视图：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">db.runCommand(</div><div class="line">&#123;</div><div class="line">crete: &lt;view&gt;,</div><div class="line">viewOn: &lt;<span class="built_in">source</span>&gt;,</div><div class="line">pipeline: &lt;pipeline&gt;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">db.createView(&lt;view&gt;, &lt;<span class="built_in">source</span>&gt;, &lt;pipeline&gt;, &lt;collation&gt;)</div><div class="line"></div><div class="line">db.collection.drop()</div></pre></td></tr></table></figure><p><br><br><strong>视图行为：</strong></p><p>视图存在以下行为：</p><ul><li>视图只读，视图上的写操作将会出错；</li><li>视图使用底层集合的索引；</li><li>如果视图的基础集合被分割，视图也被认为可分割；</li><li>不能重命名视图；</li><li>视图上的字符串使用视图的默认排序规则。</li></ul><p><br></p><h3 id="限制集"><a href="#限制集" class="headerlink" title="限制集"></a>限制集</h3><p>限制集是固定大小的集合支持基于文档插入顺序的高吞吐率的插入、检索、删除操作。<br>限制集工作在某种程度上类似于循环缓冲区：一旦一个文档填满分配给它的空间，它将通过在限制集中重写老文档来给新文档让出空间。</p><p><br></p><h4 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h4><p><strong>插入顺序</strong><br>限制集合能够保留插入顺序。因此，查询并不需要索引来保证以插入顺序来返回文档。减少了索引的消耗，限制集可以支持更高的插入吞吐量。</p><p><strong>最旧文档的自动删除</strong><br>为了给新文档腾出空间，再不需要脚本或显示删除操作的前提下，限制集自动删除集合中最旧的文档。</p><p>例如replication set中的oplog.rs集合。考虑潜在用于集合封顶的用例：</p><ul><li>存储高容量系统生成的日志信息。没有索引的情况下向限制集中插入文档的速度接近于直接在文件系统中写日志的速度；</li><li>在限制集中缓存少量的数据。</li></ul><p><strong>_id索引</strong><br>限制集合有一个_id字段并且默认在_id字段上创建索引。</p><p><br></p><h4 id="限制和建议"><a href="#限制和建议" class="headerlink" title="限制和建议"></a>限制和建议</h4><p><strong>更新</strong><br>更新限制集中的文档，创建一个索引保证这些更新操作不需要进行集合扫描。</p><p><strong>文档大小</strong><br>一个更新或替换操作改变了文档大小，操作将会失败。</p><p><strong>文档删除</strong><br>不能从一个限制集中删除文档！<br>为了从一个集合中删除所有文档，使用<code>drop()</code>方法来删除集合然后重新创建限制集。</p><p><strong>分片</strong><br>不能对限制集分片。</p><p><strong>查询效率</strong><br>用自然顺序监视限制集中大部分最近插入的文档。</p><p><br></p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><p><strong>创建一个限制集</strong><br>必须使用<code>db.createCollection()</code>方法创建限制集。且必须指定<strong>以字节为单位</strong>的最大集合大小。MongoDB将会预先分配集合。<br>另外，可为限制集指定最大文档数据，用<code>max</code>字段。</p><p>大小参数是必须的。MongoDB会在达到最大限制前删除旧的文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use &lt;db&gt;</div><div class="line"></div><div class="line"><span class="comment">#限制集大小</span></div><div class="line">db.createCollection(<span class="string">"log"</span>, &#123;capped: <span class="literal">true</span>, size: 1000000&#125;)</div><div class="line"></div><div class="line"><span class="comment">#限制集和文档大小</span></div><div class="line">db.createCollection(<span class="string">"log"</span>, &#123;capped: <span class="literal">true</span>, size: 5242880, max: 5000&#125;)</div></pre></td></tr></table></figure><p><strong>查询一个限制集</strong><br>如果没有对限制集指定排序，则MongoDB的结果顺序和插入顺序相同。</p><p><strong>检查一个集合是否是限制集</strong><br><code>isCapped()</code>方法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.collection.isCapped()</div><div class="line"><span class="comment">#db.coll01.isCapped()</span></div><div class="line"><span class="comment">#false</span></div></pre></td></tr></table></figure><p><strong>将集合转换为限制集</strong><br><code>convertToCapped()</code>方法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.runCommand(&#123;<span class="string">"covertToCapped"</span>: <span class="string">"coll01"</span>, size: 1000000&#125;);</div><div class="line"><span class="comment">#db.coll01.isCapped()</span></div><div class="line"><span class="comment">#true</span></div></pre></td></tr></table></figure><p><strong>在规定的时间周期之后将自动移除数据</strong><br>通过设置MongoDB的TTL时集合中的数据过期。<br>TTL collection与限制集不兼容。</p><p><strong>Tailable游标</strong><br>类似于Unix中的<code>taif -f</code></p><p><br><br><br></p><h2 id="document"><a href="#document" class="headerlink" title="document"></a>document</h2><p>MongoDB存储数据记录为BSON文档。<br>BSON是JSON文档的二进制表示，因此它包含比JSON更多的数据类型。</p><p><br></p><h3 id="document-structure"><a href="#document-structure" class="headerlink" title="document structure"></a>document structure</h3><p>MongoDB字段由key-value对组成。<br>字段值可以是任一BSON数据类型，包括其他文档，数组，阵列。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">filed1: value1;</div><div class="line">filed2: value2;</div><div class="line">    ...</div><div class="line">    filedN: valueN</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#data type</span></div><div class="line">var mydoc =&#123;</div><div class="line">_id: ObjectId(<span class="string">"5099803df3f4948bd2f98391"</span>),</div><div class="line">name: &#123; first: <span class="string">"Alan"</span>, last: <span class="string">"Turing"</span> &#125;,</div><div class="line">birth: new Date(<span class="string">'Jun 23, 1912'</span>),</div><div class="line">death: new Date(<span class="string">'Jun 07, 1954'</span>),</div><div class="line">contribs: [ <span class="string">"Turing machine"</span>, <span class="string">"Turing test"</span>, <span class="string">"Turingery"</span> ],</div><div class="line">views : NumberLong(1250000)</div><div class="line">&#125;</div><div class="line"></div><div class="line">_id是ObjectID；</div><div class="line">name是嵌入式文档；</div><div class="line">birth是日期类型；</div><div class="line">contribs是字符串数组；</div><div class="line">view是NumberLong类型。</div></pre></td></tr></table></figure><p><strong>字段名(field name)</strong><br>字段名是字符串。<br>document对field name有以下限制:</p><ul><li>字段名称<code>_id</code>保留用作主键(primary key)，它的值在collection中必须唯一，不可变。它的类型可以是数组外的任何类型；</li><li>字段名称不能以<code>$</code>字符开头；</li><li>字段名称不能包含<code>.</code>字符；</li><li>字段名称不能包含<code>null</code>字符。</li></ul><p>BSON documents 可能有多个字段名称相同的字段。然而，大多数的MongoDB Interface，MongoDB结构（如hash表），并不支持重复字段名称。<br>如果需要操作具有多个相同名称字段的文档，请参考 mongo driver。</p><p>一些由内部MongoDB进程创建的documents可能会有重复的字段，但是没有MongoDB进程会向一个已经存在的user document中添加重复字段。</p><p><strong>字段值限制(field value limit)</strong><br>For <code>indexed collections</code>，indexed fields的值有一个最大索引值长度限制(maximum index key length)。</p><p><br></p><h3 id="圆点表示法-dot-notation"><a href="#圆点表示法-dot-notation" class="headerlink" title="圆点表示法(dot notation)"></a>圆点表示法(dot notation)</h3><p>MongoDB使用圆点表示法来访问数组中的元素，访问嵌套文档中的字段。</p><p><strong>数组(array)</strong><br>通过基于0的索引位置来指定或访问数组中的元素。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;array&gt;.&lt;index&gt;</div><div class="line"></div><div class="line">&#123;</div><div class="line">contribs: [ <span class="string">'Turing machine'</span>, <span class="string">'Turing test'</span>, <span class="string">'Turingery'</span> ]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#contribs.0 == 'Turing machine'</span></div><div class="line"><span class="comment">#contribs.1 == 'Turing test'</span></div><div class="line"><span class="comment">#contribs.2 == 'Turingery'</span></div></pre></td></tr></table></figure><p><strong>嵌套文档(embedded documents)</strong><br>通过圆点表示法来指定或访问嵌套文档中的字段。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;embedded document&gt;.&lt;field&gt;</div><div class="line"></div><div class="line">&#123;</div><div class="line">name: &#123; first: <span class="string">'AAA'</span>, last: <span class="string">'ZZZ'</span>&#125;,</div><div class="line">    contact: &#123; phone: &#123; <span class="built_in">type</span>: <span class="string">'cell'</span>, number: <span class="string">'1-22-333'</span> &#125;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#name.first == 'AAA'</span></div><div class="line"><span class="comment">#contact.phone.number == '1-22-333'</span></div></pre></td></tr></table></figure><p><br></p><h3 id="文档限制-document-limitation"><a href="#文档限制-document-limitation" class="headerlink" title="文档限制(document limitation)"></a>文档限制(document limitation)</h3><p><strong>文档大小限制(size limit)</strong><br>BSON document最大size为：16MB。</p><p>最大document size确保一个单一document不能使用过量的RAM，或是传输期间的过量带宽。<br>MongoDB提供了<code>GridFS API</code>，用来保存超过最大size的文档。</p><p><strong>文档字段序列(field order)</strong><br>MongoDB用write operation来作为document的序列，除了一下情况：</p><ul><li><code>_id</code>字段总是document中的第一个field；</li><li>包含重命名的<code>update</code>操作，会导致document中的field重新排序。</li></ul><p><strong>_id字段</strong><br>在MongoDB中，每个保存在collection中的document都要求一个唯一的<code>_id</code>，用以担任主键(primary key)。<br>如果向document中<code>insert</code>数据是忽略的<code>_id</code>字段，则MongoDB driver会为<code>_id字段</code>自动生成一个ObjectID。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#默认生成_id</span></div><div class="line">db.coll01.insert(&#123;name: <span class="string">'zhang'</span>, sex: <span class="string">'man'</span>, hobby: <span class="string">'woman'</span>&#125;)</div><div class="line"><span class="comment"># "_id" : ObjectId("5a32166ebf2c986e8106f891")</span></div><div class="line"></div><div class="line"><span class="comment">#自定义_id</span></div><div class="line">db.coll01.insert(&#123;_id:<span class="string">'ZhangCustomDefine'</span>, name:<span class="string">'zhang'</span>, sex: <span class="string">'man'</span>, arr: [0, 1, 2, 3], emmdoc: &#123;emm01:<span class="string">'Emm01'</span>, emm02: <span class="string">'Emm02'</span>, emm03: <span class="string">'Emmo3'</span>&#125;&#125;)</div><div class="line"><span class="comment">#"_id" : "ZhangCustomDefine"</span></div></pre></td></tr></table></figure><p><code>_id字段</code>有以下行为和约束：</p><ul><li>默认情况下，MongoDB在collection创建document时，会创建一个唯一的<code>_id</code>作为索引；</li><li><code>_id字段</code>总是document中的第一个字段。如果server接受的document中<code>_id</code>不在第一个字段，那么Server会移动<code>_id</code>到第一个字段；</li><li><code>_id</code>字段的数据类型除了数组外的任意BSON 数据类型；</li><li>不要存储BSON正则表达式的类型在<code>_id</code>字段中。</li></ul><p><code>_id</code>字段值的常用选项：</p><ul><li>使用ObjectId；</li><li>使用了自然唯一的标识符，节省了空间并避免了额外的索引；</li><li>生成一个自动递增的数字；</li><li>在应用程序代码中生成UUID；</li></ul><p><br></p><h3 id="文档结构的其他用途"><a href="#文档结构的其他用途" class="headerlink" title="文档结构的其他用途"></a>文档结构的其他用途</h3><p><strong>查询过滤文档(query filter)</strong><br>使用<key>:<value>表达式来指定条件。</value></key></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&lt;field1&gt;: &lt;value1&gt;</div><div class="line">    &lt;field2&gt;: &lt;value2&gt;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>更新特定文档(update)</strong><br>使用<code>db.collection.update()</code>操作更新数据。</p><p><br><br><br></p><h2 id="BSON类型"><a href="#BSON类型" class="headerlink" title="BSON类型"></a>BSON类型</h2><p>BSON是一个用来存储document和MongoDB进行远程调用的二进制序列化格式。<br>BSON支持以下数据类型作为文档中的值。每个数据类型都有一个相应的数字和字符串别名，可与<code>$type</code>操作符一起使用，以便按照bson类型查询文档。</p><table><thead><tr><th>Type</th><th>Number</th><th>Alias</th></tr></thead><tbody><tr><td>double</td><td>1</td><td>“double”</td></tr><tr><td>字符串</td><td>2</td><td>“string”</td></tr><tr><td>对象</td><td>3</td><td>“object”</td></tr><tr><td>数组</td><td>4</td><td>“array”</td></tr><tr><td>二进制数据</td><td>5</td><td>“binData”</td></tr><tr><td>未定义</td><td>6</td><td>“undefined”</td></tr><tr><td>ObjectId</td><td>7</td><td>“objectId”</td></tr><tr><td>Boolean</td><td>8</td><td>“bool”</td></tr><tr><td>日期</td><td>9</td><td>“date”</td></tr><tr><td>空</td><td>10</td><td>“null”</td></tr><tr><td>正则表达式</td><td>11</td><td>“regex”</td></tr><tr><td>DBPointer</td><td>12</td><td>“dbPointer”</td></tr><tr><td>JavaScript</td><td>13</td><td>“javascript”</td></tr><tr><td>符号</td><td>14</td><td>“symbol”</td></tr><tr><td>JavaScript(带范围)</td><td>15</td><td>“javascriptWithScope”</td></tr><tr><td>32位整数</td><td>16</td><td>“int”</td></tr><tr><td>时间戳</td><td>17</td><td>“timestamp”</td></tr><tr><td>64位整数</td><td>18</td><td>“long”</td></tr><tr><td>Decimal128</td><td>19</td><td>“decimal”</td></tr><tr><td>Min key</td><td>-1</td><td>“minKey”</td></tr><tr><td>Max key</td><td>127</td><td>—</td></tr></tbody></table><p>如果你想要将BSON转换为JSON，参考Extended JSON。</p><p><br></p><h3 id="ObjectId"><a href="#ObjectId" class="headerlink" title="ObjectId"></a>ObjectId</h3><p>ObjcetIds are small, likely unique, fast to generate, and ordered.<br>ObjectIds由12个字节组成，其中前4个字节是反映ObjectId创建的时间戳(timestamp)。</p><ul><li>一个4字节的值，代表从Unix纪元开始的秒数；</li><li>一个3字节的机器标识符；</li><li>日期对象排在时间戳对象之前；</li><li>MongoDB在比较过程中，会把一些类型看成相等。</li></ul><p>栗子：<code>{ &quot;_id&quot; : ObjectId(&quot;5a33354068b6c5e5fb6f213f&quot;), &quot;name&quot; : &quot;ZHANG&quot; }</code>。</p><p>在mongo shell中，可以访问ObjectId的创建时间，使用<code>ObjectId.getTimestamp()</code>方法。<br>在<code>_id</code>字段中存储的ObjectId值的排序，大致相当于按其创建时间排序。<br>ObjectId的值顺序与生成时间之间并不严格。</p><p><br></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>BSON字符串都是UTF-8编码。一般来说，每种编程语言的驱动程序在序列化和反序列化BSON的时候，都会从语言的字符串形式转化为UTF-8。这就使得使用BSON字符串简单存储大多数国际字符变为可能。</p><p><br></p><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>BSON有一个特殊的时间戳类型用于MongoDB内部使用，与普通的日期类型无关。而在应用开发中可使用BSON日期类型。<br>时间戳值是一个64位的值： 前32位是与Unix纪元相差的秒数，后32位是在某秒总操作的一个递增的序列数。</p><p>在MongoDB复制集中，<code>oplog</code>有一个ts字段。这个字段的值使用BSON时间戳表示了操作时间。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.coll02.insert( &#123; ts: new Timestamp() &#125; )</div><div class="line"></div><div class="line">db.coll02.find()</div><div class="line"><span class="comment">#&#123; "_id" : ObjectId("5a333e3f68b6c5e5fb6f2141"), "ts" : Timestamp(1513307711, 1) &#125;</span></div></pre></td></tr></table></figure><p><br></p><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p>BSON日期是一个64位整数，表示利当前Unix新纪元(1970.01.01)的毫秒数，可到未来的2.9亿年。<br>BSON日期类型是有符号的，负数表示1970年之前的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var date1 = new Date()</div><div class="line">var date2 = ISODate()</div><div class="line"></div><div class="line">#date1</div><div class="line">#date2</div><div class="line">#ISODate(&quot;2017-12-15T03:28:08.227Z&quot;)</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="MongoDB-Extended-JSON"><a href="#MongoDB-Extended-JSON" class="headerlink" title="MongoDB Extended JSON"></a>MongoDB Extended JSON</h2><p>JSON只能表示BSON类型的一个子集。为了保留类型信息，MongoDB对JSON格式添加了如下扩展性：</p><ul><li>Strict mode： Any JSON parser can parse these strict mode representations as key/value pairs;</li><li>mongo shell mode： The MongoDB internal JSON parser and the mongo shell can parse this mode.</li></ul><p>多种数据类型的表示取决于JSON解析的上下文！</p><p><br></p><h3 id="解析器-parser-和支持的格式-format"><a href="#解析器-parser-和支持的格式-format" class="headerlink" title="解析器(parser)和支持的格式(format)"></a>解析器(parser)和支持的格式(format)</h3><p><strong>Input in Strict mode</strong><br>如下可在严格模式下被解析并识别类型信息。</p><ul><li>REST Interface;</li><li>mongo import;</li><li>–query;</li><li>MongoDB Compass.</li></ul><p><br><br><strong>Input in mongo shell mode</strong><br>如下可在严格模式下被解析并识别类型信息。</p><ul><li>REST Interface;</li><li>mongo import;</li><li><code>--query</code>;</li><li>MongoDB Compass</li></ul><p><br><br><strong>Output in Strict mode</strong><br><code>mongoexport</code>, REST, HTTP Interfaces.</p><p><br><br><strong>Output in mongo shell mode</strong><br><code>bsondump</code></p><p><br></p><h3 id="BSON数据类型和关联表示"><a href="#BSON数据类型和关联表示" class="headerlink" title="BSON数据类型和关联表示"></a>BSON数据类型和关联表示</h3><p><strong>Binary</strong></p><table><thead><tr><th>Strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$binary”: “<bindata>“, “$type”: “<t>“ }</t></bindata></td><td>BinData ( <t>, <bindata> )</bindata></t></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;bindata&gt;是二进制base64表示；</div><div class="line">&lt;t&gt;是由单字节的数据类型表示。</div></pre></td></tr></table></figure><p><br><br><strong>Date</strong></p><table><thead><tr><th>Strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$date”: “<date>“ }</date></td><td>new Date ( <date> )</date></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In Strict mode, &lt;date&gt;是 ISO-8601的日期格式的时区字段，类型如**YYYY-MM-DDTHH:mm:ss.mm&lt;+/-offset&gt;;</div><div class="line">MongoDb JSON解析器目前暂不支持载入ISO-8601日期类型。</div></pre></td></tr></table></figure><p><br><br><strong>Timestamp</strong></p><table><thead><tr><th>Strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$timestamp” ; { “t”: <t>, “i” } }</t></td><td>Timestamp( <t>, <i> )</i></t></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;t&gt;是32位无符号整数的JSON表现形式；</div><div class="line">&lt;i&gt;是增量的32位无符号整数。</div></pre></td></tr></table></figure><p><br><br><strong>Regular Expression</strong></p><table><thead><tr><th>Strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$regex”: <sregex>, “$options”: “<soptions>“ }</soptions></sregex></td><td>/<jregex>/<joptions></joptions></jregex></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;sRegex&gt;是有效地JSON字符串；</div><div class="line">&lt;jRegex&gt;是一个可能包含有效的JSON字符和未转义的双引号(&quot;)，但可能不包括未转义的斜杠(/)字符；</div><div class="line">&lt;sOptions&gt;是一个正则表达式选项；</div><div class="line">&lt;jOptions&gt;是一个只能包含字符&quot;g&quot;, &quot;i&quot;, &quot;m&quot;, &quot;s&quot;的字符串。</div></pre></td></tr></table></figure><p><br><br><strong>OID</strong></p><table><thead><tr><th>Strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$oid”: “<id>“ }</id></td><td>ObjectId( “<id>“ )</id></td></tr></tbody></table><p><code>&lt;id&gt;是一个24字符的十六进制(hexadecimal)字符串</code></p><p><br><br><strong>DB Reference</strong></p><table><thead><tr><th>strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$ref”: “<name>“, “$id”: “<id>“ }</id></name></td><td>DBRef(“<name>“, “<id>“)</id></name></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;name&gt;是一个有效的JSON字符；</div><div class="line">&lt;id&gt;是任一extended JSON type。</div></pre></td></tr></table></figure><p><br><br><strong>Undefined Type</strong></p><table><thead><tr><th>strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{  “$undefined”: true }</td><td>undefined</td></tr></tbody></table><p><br><br><strong>MinKey/MaxKey</strong></p><table><thead><tr><th>strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$minkey”: 1 }</td><td>MinKey</td></tr><tr><td>{ “$maxkey”: 1 }</td><td>MaxKey</td></tr></tbody></table><p><br><br><strong>NumberLong</strong></p><table><thead><tr><th>strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$numberLong”: “<number>“ }</number></td><td>NumberLong( “<number>“ )</number></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Number是一个64位有符号整数。必须使用&quot;，否则它将被解释为浮点数，从而导致损失精度；</div><div class="line">db.json.insert&#123;&#123; longquoted: NumberLong(&quot;12345678901234345&quot;) &#125;)</div></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="MongoDB安装"><a href="#MongoDB安装" class="headerlink" title="MongoDB安装"></a>MongoDB安装</h1><p>参考:</p><ul><li><a href="https://docs.mongodb.com/manual/administration/install-on-linux/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/administration/install-on-linux/</a>;</li><li><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</a>;</li></ul><p>MongoDB有社区版(Community)和企业版(Enterprise)。社区版免费，企业版在商业方面收费。</p><p><br><br>MongoDB在仓库中提供官方支持的包，包含以下软件包：</p><table><thead><tr><th>Package</th><th>Description</th></tr></thead><tbody><tr><td>monogdb-org</td><td>将自动安装下面四个组件包</td></tr><tr><td>mongodb-org-server</td><td>包含<code>mongod</code>守护进程和相关配置和<code>init</code>脚本</td></tr><tr><td>mongodb-org-mongos</td><td>包含<code>mongos</code>守护进程</td></tr><tr><td>mongodb-org-shell</td><td>包含<code>mongo-shell</code></td></tr><tr><td>mongodb-org-tools</td><td>包含相关MongoDB工具，如<code>mongoimport</code>,<code>mongoexport</code>,<code>mongodump</code>,<code>mongorestore</code>…</td></tr></tbody></table><p><code>mongodb-org-server</code>包提供了一个<code>/etc/mongod.conf</code>配置文件来开始和初始化<code>mongod</code>。默认配置文件默认bind_ip为 <code>127.0.0.1</code>，当你有需要和副本集时请修改它。</p><p><br></p><h2 id="自建mongodb-repo仓库安装"><a href="#自建mongodb-repo仓库安装" class="headerlink" title="自建mongodb.repo仓库安装"></a>自建mongodb.repo仓库安装</h2><p>仓库地址：<a href="https://repo.mongodb.org" target="_blank" rel="noopener">https://repo.mongodb.org</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">vim /etc/yum.repos.d/mongodb34.repo</div><div class="line"><span class="comment">#编辑仓库</span></div><div class="line"></div><div class="line"></div><div class="line">[mongodb34]</div><div class="line">name=MongoDB34 Repository</div><div class="line">baseurl=https://repo.mongodb.org/yum/redhat/<span class="variable">$releasever</span>/mongodb-org/3.4/x86_64/</div><div class="line">gpgcheck=0</div><div class="line">enabled=1</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#安装mongodb</span></div><div class="line">yum install -y mongodb-org</div></pre></td></tr></table></figure><p><br></p><h2 id="下载rpm包安装"><a href="#下载rpm包安装" class="headerlink" title="下载rpm包安装"></a>下载rpm包安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /root/mongodb</div><div class="line">wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/3.4/x86_64/RPMS/mongodb-org-3.4.10-1.el7.x86_64.rpm</div><div class="line">wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/3.4/x86_64/RPMS/mongodb-xxx-3.4.10-1.el7.x86_64.rpm</div><div class="line"><span class="comment">#共五个包</span></div><div class="line"></div><div class="line"></div><div class="line">yum ./mongo-org*</div></pre></td></tr></table></figure><p><br></p><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.0.tgz</div><div class="line"></div><div class="line">tar -axvf mongodb-linux-x86_64-rhel70-3.6.0.tgz -C ./</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#默认路径/usr/local</span></div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure><p><br></p><h2 id="开启mongodb"><a href="#开启mongodb" class="headerlink" title="开启mongodb"></a>开启mongodb</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#默认启动方式</span></div><div class="line">systemctl start mongod</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定配置文件启动</span></div><div class="line"><span class="comment">#注意修改配置文件里面的某些路径和名称，不然会和默认配置文件冲突</span></div><div class="line">mongod -f /etc/mongo_27018.conf</div><div class="line">mongod -f /etc/mongo_27019.conf</div><div class="line">``</div><div class="line"></div><div class="line"></div><div class="line">&lt;br&gt;</div><div class="line"><span class="comment">## 卸载mongodb</span></div><div class="line"></div><div class="line">```sh</div><div class="line">systemctl stop mongod</div><div class="line"></div><div class="line">yum remove $(rpm -qa | grep mongodb-org)</div><div class="line"></div><div class="line">rm -rf /var/<span class="built_in">log</span>/mongodb</div><div class="line">rm -rf /var/dbpath/mongo</div></pre></td></tr></table></figure><h2 id="mongodb异常关闭后"><a href="#mongodb异常关闭后" class="headerlink" title="mongodb异常关闭后"></a>mongodb异常关闭后</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#首先查看日志文件</span></div><div class="line">tail /var/<span class="built_in">log</span>/mongodb/mongod.log</div><div class="line"></div><div class="line"><span class="comment">#删除</span></div><div class="line">rm /var/run/mongodb/mongod.pid /var/db/mongodb/mongod.lock</div></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="MongoDB配置文件"><a href="#MongoDB配置文件" class="headerlink" title="MongoDB配置文件"></a>MongoDB配置文件</h1><p>MongoDB的配置文件格式使用了YAML格式。<br><a href="https://zh.wikipedia.org/wiki/YAML" target="_blank" rel="noopener">YAML维基百科</a>，Yet Another Markup Language。强调以数据为中心，而不是标记语言为重点，用方向缩略语重命名。</p><p><br><br>默认配置文件<code>/etc/mongod.conf</code> 的几个大块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">systemLog:        #日志</div><div class="line"></div><div class="line">storage:          #存储</div><div class="line"></div><div class="line">processManagement:        #进程管理</div><div class="line"></div><div class="line">net:        #网络</div><div class="line"></div><div class="line">security:        #安全</div><div class="line"></div><div class="line">operationProfiling:        #性能分析器</div><div class="line"></div><div class="line">replication:        #主从复制</div><div class="line"></div><div class="line">sharding:        #架构</div><div class="line"></div><div class="line">setParameter:        #自定义变量</div><div class="line"></div><div class="line">auditLog:        #检测日志</div><div class="line"></div><div class="line">snmp:        #简单网络管理协议</div></pre></td></tr></table></figure><p><br></p><h2 id="systemLog"><a href="#systemLog" class="headerlink" title="systemLog"></a>systemLog</h2><p>日志相关参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">systemLog:</div><div class="line">  verbosity: &lt;int&gt;                #日志级别，默认0,1-5均会包含debug信息</div><div class="line">  quiet: &lt;boolean&gt;                #安静，true时mongod将会减少日志的输出量</div><div class="line">  traceAllExceptions: &lt;boolean&gt;        #打印异常详细信息</div><div class="line">  syslogFacility:  &lt;string&gt;                #指定用于登录时信息到syslog Facility水平，前提是启用syslog</div><div class="line">  path:  &lt;string&gt;          #日志路径，默认情况下，MongoDB将覆盖现有的日志文件</div><div class="line">  logAppend: &lt;boolean&gt;        #mongod重启后，在现有日志后继续添加日志，否则备份当前日志，然后创建新日志</div><div class="line">  logRotate: rename|reopen        #日志轮询，防止一个日志文件特别大。rename重命名日志文件，默认值；reopen使用Linuxrotate特性，关闭并重新打开日志文件，前提为logAppend: true</div><div class="line">  destination: &lt;string&gt;        #日志输出目的地，可为file或syslog，若不指定，则会输出到 std out</div><div class="line">  timeStampFormat: &lt;string&gt;        #指定日志格式的时间戳，有 ctime, Iso869-utc, iso8691-local</div><div class="line">  component:            #为不同的组件指定各自的日志信息级别</div><div class="line">      accessControl:</div><div class="line">          verbosity: &lt;int&gt;</div><div class="line">      command:</div><div class="line">          verbosity: &lt;int&gt;</div></pre></td></tr></table></figure><p><br></p><h2 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h2><p>存储引擎相关参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">storage:</div><div class="line">  dbPath: &lt;string&gt;        #mongodb进程存储数据目录，此配置进队此mongod进程有效，你使用配置文件开启的mongod就可以指定额外的数据目录</div><div class="line">  indexBuildRetry:  &lt;boolean&gt;        #当构件索引时mongod意外关闭，那么在此启动是否重建索引，默认true</div><div class="line">  repairPath: &lt;string&gt;        #在repair期间使用此目录存储临时数据，repair结束后此目录下数据将被删除</div><div class="line">  journal:</div><div class="line">      enabled: &lt;boolean&gt;        #journal日志持久存储，journal日志用来数据恢复，通常用于故障恢复，建议开启</div><div class="line">      commitIntervalMs: &lt;num&gt;        #mongod日志刷新值，范围1-500毫秒，默认100，不建议修改</div><div class="line">  directoryPerDB:  &lt;boolean&gt;        #是否将不同的数据存储在不同的目录中，dbPath子目录</div><div class="line">  syncPeriodSecs:  &lt;int&gt;        #fsync操作将数据flush到磁盘的时间间隔，默认为60秒，不建议修改</div><div class="line">  engine:  &lt;string&gt;        #存储引擎</div><div class="line"></div><div class="line">  mmapv1:    #mmapv1存储引擎，3.2前默认</div><div class="line">      preallocDataFiles:  &lt;boolean&gt;</div><div class="line">      nsSize: &lt;int&gt;</div><div class="line">      quota:</div><div class="line">          enforced: &lt;boolean&gt;</div><div class="line">          maxFilesPerDB: &lt;int&gt;</div><div class="line">      smallFiles: &lt;boolean&gt;</div><div class="line">      journal:</div><div class="line">          debugFlags: &lt;int&gt;</div><div class="line">          commitIntervalMs: &lt;num&gt;</div><div class="line">  wiredTiger:    #WiredTiger存储引擎，3.2后默认</div><div class="line">      engineConfig:</div><div class="line">          cacheSizeGB: &lt;number&gt;    #最大缓存大小</div><div class="line">          journalCompressor: &lt;string&gt;    #日志压缩算法，可选值有 none，snappy(默认)，zlib</div><div class="line">          directoryForIndexes: &lt;boolean&gt;    #是否将索引和collections数据分别存储在dbPath单独的目录中</div><div class="line">      collectionConfig:</div><div class="line">          blockCompressor: &lt;string&gt;    #collection数据压缩算法，可选none, snappy，zlib</div><div class="line">      indexConfig:</div><div class="line">          prefixCompression: &lt;boolean&gt;    #是否对索引数据使用前缀压缩。对那些经过排序的值存储有很大帮助，可有效减少索引数据的内存使用量。</div><div class="line">  inMemory:    #inMemory内存存储引擎，bate版</div><div class="line">      engineConfig:</div><div class="line">          inMemorySizeGB: &lt;number&gt;</div></pre></td></tr></table></figure><p><br></p><h2 id="processManagement"><a href="#processManagement" class="headerlink" title="processManagement"></a>processManagement</h2><p>进程相关参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">processManagement:</div><div class="line">  fork: &lt;boolean&gt;        #是否以fork模式运行mongod进程，默认情况下，mongod不作为守护进程运行</div><div class="line">  pidFilePath: &lt;string&gt;        #将mongod进程ID写入指定文件，如未指定，将不会创建PID文件</div></pre></td></tr></table></figure><p><br></p><h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><p>网络相关参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">net:</div><div class="line">  prot: &lt;int&gt;    #监听端口，默认27017</div><div class="line">  bindIp: &lt;string&gt;    #绑定IP，如果此值是“0.0.0.0”则绑定所有接口</div><div class="line">  maxIncomingConnections: &lt;int&gt;    #mongod进程允许的最大连接数，如果此值超过系统配置的连接数阈值，将不会生效(ulimit)</div><div class="line">  wireObjectCheck: &lt;boolean&gt;    #当客户端写入数据时，检查数据的有效性（BSON）。如果数据格式不良，update,insert等操作将会被拒绝</div><div class="line">  ipv6: &lt;boolean&gt;    #是否支持多实例之间使用ipv6</div><div class="line">  unixDomainSocker:    #适用于Unix系统</div><div class="line">      enabled: &lt;boolean&gt;</div><div class="line">      pathPrefix: &lt;string&gt;</div><div class="line">      filePermissions: &lt;int&gt;</div><div class="line">  http:    #</div><div class="line">      enabled: &lt;boolean&gt;</div><div class="line">      JSONEnabled: &lt;boolean&gt;</div><div class="line">      RESTInterfaceEnabled: &lt;boolean&gt;</div><div class="line">  ssl:</div><div class="line">      sslOnNormalPorts: &lt;boolean&gt;</div><div class="line">      mode: &lt;string&gt;</div><div class="line">      PEMKeyFile: &lt;string&gt;</div><div class="line">      PEMKeyPassword: &lt;string&gt;</div><div class="line">      clusterFile: &lt;string&gt;</div><div class="line">      clusterPassword: &lt;string&gt;</div><div class="line">      CAFile: &lt;string&gt;</div><div class="line">      CRLFile: &lt;string&gt;</div><div class="line">      allowConnectionsWithoutCertificates: &lt;boolean&gt;</div><div class="line">      allowInvalidCertificates: &lt;boolean&gt;</div><div class="line">      allowInvalidHostnames: &lt;boolean&gt;</div><div class="line">      disabledProtocols: &lt;string&gt;</div><div class="line">      FIPSMode: &lt;boolean&gt;</div><div class="line">  compression:</div><div class="line">      compressors: &lt;string&gt;</div></pre></td></tr></table></figure><p><br></p><h2 id="security"><a href="#security" class="headerlink" title="security"></a>security</h2><p>安全相关参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">security:</div><div class="line">  authorization: enabled    #MondoDB认证功能</div><div class="line">  keyFile: /path/mongo.key    #MongoDB副本集节点身份验证密钥文件</div><div class="line">  clusterAuthMode: &lt;string&gt;    #集群members间的认证模式</div><div class="line">  transitionToAuth: &lt;boolean&gt;</div><div class="line">   javascriptEnabled:  &lt;boolean&gt;    #是否允许执行JavaScript脚本</div><div class="line">   redactClientLogData: &lt;boolean&gt;</div><div class="line">   sasl:</div><div class="line">      hostName: &lt;string&gt;</div><div class="line">      serviceName: &lt;string&gt;</div><div class="line">      saslauthdSocketPath: &lt;string&gt;</div><div class="line">   enableEncryption: &lt;boolean&gt;</div><div class="line">   encryptionCipherMode: &lt;string&gt;</div><div class="line">   encryptionKeyFile: &lt;string&gt;</div><div class="line">   kmip:</div><div class="line">      keyIdentifier: &lt;string&gt;</div><div class="line">      rotateMasterKey: &lt;boolean&gt;</div><div class="line">      serverName: &lt;string&gt;</div><div class="line">      port: &lt;string&gt;</div><div class="line">      clientCertificateFile: &lt;string&gt;</div><div class="line">      clientCertificatePassword: &lt;string&gt;</div><div class="line">      serverCAFile: &lt;string&gt;</div><div class="line">   ldap:</div><div class="line">      servers: &lt;string&gt;</div><div class="line">      bind:</div><div class="line">         method: &lt;string&gt;</div><div class="line">         saslMechanism: &lt;string&gt;</div><div class="line">         queryUser: &lt;string&gt;</div><div class="line">         queryPassword: &lt;string&gt;</div><div class="line">         useOSDefaults: &lt;boolean&gt;</div><div class="line">      transportSecurity: &lt;string&gt;</div><div class="line">      timeoutMS: &lt;int&gt;</div><div class="line">      userToDNMapping: &lt;string&gt;</div><div class="line">      authz:</div><div class="line">         queryTemplate: &lt;string&gt;</div></pre></td></tr></table></figure><p><br></p><h2 id="operationProfiling"><a href="#operationProfiling" class="headerlink" title="operationProfiling"></a>operationProfiling</h2><p>慢查询相关参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">operationProfiling:</div><div class="line">  slowOpThresholdMs: &lt;int&gt;    #数据库profiler判定一个操作是“慢查询”的时间阈值，单位毫秒。mongod会把慢查询记录到日志中，默认100ms</div><div class="line">  mode: &lt;string&gt;    #数据库profiler级别，操作的性能信息将会被写入日志文件中，可选值“off”--关闭profiling，“slowOp”--只包包含慢操作，“all”--记录所有操作</div><div class="line">  #数据库profiling会影响性能，建议只在性能调试阶段开启</div></pre></td></tr></table></figure><p><br></p><h2 id="replication"><a href="#replication" class="headerlink" title="replication"></a>replication</h2><p>副本集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">replication:</div><div class="line">  oplogSizeMB: &lt;int&gt;    #replication操作日志的最大尺寸，如果太小，secondary将不能通过oplog来同步数据，只能全量同步</div><div class="line">  replSetName: &lt;string&gt;    #副本集名称，副本集中所有的mongod实例都必须有相同的名字，Sharding分布式下，不同的sharding应该使用不同的repSetName</div><div class="line">  secondaryIndexPrefetch: &lt;string&gt;    #副本集中的secondary，从oplog中应用变更操作之前，将会先把索引加载到内存</div><div class="line">  enalbeMajorityReadConcern: &lt;boolean&gt;    #允许readConcern的级别为“majority”</div></pre></td></tr></table></figure><p><br></p><h2 id="sharding"><a href="#sharding" class="headerlink" title="sharding"></a>sharding</h2><p>分片相关参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sharding:</div><div class="line">  clusterRole: &lt;string&gt;    #在sharding集群中，此mongod实例可选的角色。configsvr,默认监听27019端口 和 shardsvr,默认监听27018端口</div><div class="line">  archiveMovedChunks: &lt;boolean&gt;    #当chunks因为“负载均衡”而迁移到其他节点时，mongod是否将这些chunks归档，并保存在dbPath/movechunk目录下，mongod不会删除moveChunk下的文件</div></pre></td></tr></table></figure><p><br></p><h2 id="setParameter"><a href="#setParameter" class="headerlink" title="setParameter"></a>setParameter</h2><p>自定义变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setParameter:</div><div class="line">  &lt;parameter1&gt;: &lt;value1&gt;</div><div class="line">  &lt;parameter2&gt;: &lt;value2&gt;</div><div class="line">  enableLocalhostAuthBypass: false    #栗子</div></pre></td></tr></table></figure><p><br></p><h2 id="auditLog"><a href="#auditLog" class="headerlink" title="auditLog"></a>auditLog</h2><p>审计相关参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">auditLog:</div><div class="line">  destination: &lt;string&gt;    #指定审计记录的输出方式，有syslog, console, file</div><div class="line">  format: &lt;string&gt;    #输出格式，有JSON 和 BSON</div><div class="line">  path: &lt;string&gt;    #如果审计时间输入为文件，那么就需要指定文件完整路径及文件名</div><div class="line">  filter: &lt;string&gt;    #过滤器，可限制审计系统记录的操作类型，该选项需要一个表单的查询文档的字符串表示形式</div></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="Mongo-Shell"><a href="#Mongo-Shell" class="headerlink" title="Mongo Shell"></a>Mongo Shell</h1><p><strong>mongo shell</strong>是一个交互式的JavaScript结构的MongoDB。使用mongo shell来查询和更新数据以及执行管理操作。</p><h2 id="mongo-shell基础知识"><a href="#mongo-shell基础知识" class="headerlink" title="mongo shell基础知识"></a>mongo shell基础知识</h2><h3 id="启动monso-shell"><a href="#启动monso-shell" class="headerlink" title="启动monso shell"></a>启动monso shell</h3><p>启动mongo shell前确保MongoDB实例正在运行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mongo [option] [db address] [.js]</div><div class="line"></div><div class="line"><span class="comment">#以默认配置启动</span></div><div class="line">mongo</div><div class="line"></div><div class="line"><span class="comment">#以特定配置启动</span></div><div class="line">mongo --port 27018</div><div class="line"></div><div class="line"><span class="comment">#连接远程mongo shell</span></div><div class="line">mongo --host <span class="variable">$host</span> --port <span class="variable">$port</span> -u <span class="variable">$user</span> -p <span class="variable">$passwd</span></div><div class="line"></div><div class="line">mongo &lt;db&gt;</div><div class="line">mongo &lt;host&gt;/&lt;db&gt;</div><div class="line">mongo &lt;hsot:port&gt;/&lt;db&gt;</div></pre></td></tr></table></figure><p><br><br><strong>.mongorc.js文件</strong><br>mongo shell开始运行时，mongo将在用户主目录下检查<code>.mongorc.js</code>的js文件。如果找到，mongo将在首次命令行之前解释执行.mongorc.js的内容。<br>如果你使用mongo shell执行一个js或表达式，无论是通过<code>mongo --eval</code>，或指定一个.js文件，mongo都将在js处理完成之后读取.mongorc.js文件。可使用 <code>--norc</code>选项禁止加载.mongorc.js。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ll /root/.mongorc.js</div><div class="line"><span class="comment"># -rw------- 1 root root 0 Dec 27  2016 /root/.mongorc.js</span></div></pre></td></tr></table></figure><p><br></p><h3 id="使用mongo-shell"><a href="#使用mongo-shell" class="headerlink" title="使用mongo shell"></a>使用mongo shell</h3><p>可能在启动mongo shell的时候会警告:</p><ul><li>WARNING: /sys/kernel/mm/transparent_hugepage/defrag is ‘always’. We suggest setting it to ‘never’.</li><li>WARNING: /sys/kernel/mm/transparent_hugepage/defrag is ‘always’. We suggest setting it to ‘never’</li><li>WARNING: Access control is not enabled for the database.</li></ul><p>hugepage(大内存页面)，是Linux操作系统一种管理内存的方式。和通常方式相比，hugepage模式下内存分配管理会有所差异。<br>MongoDB显然不希望这个特定被启用。<br>新版MongoDB增加了安全性设计，推荐用户创建使用数据库时进行验证。所以我们需要创建用户认证。</p><p>关闭hugepage:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vim /etc/rc.d/rc.local</div><div class="line"></div><div class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</div><div class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/defrag</div><div class="line"></div><div class="line">chmox a+x /etc/rc.d/rc.local</div></pre></td></tr></table></figure><p>创建用户认证:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;use admin</div><div class="line">&gt;db.createUser(</div><div class="line">&#123;</div><div class="line">user: <span class="string">"zhang"</span>,</div><div class="line">    <span class="built_in">pwd</span>: <span class="string">"zhang"</span>,</div><div class="line">    roles: [&#123; role: <span class="string">"root"</span>, db: <span class="string">"admin"</span>&#125;]</div><div class="line">&#125;</div><div class="line">)</div><div class="line"></div><div class="line">mongo -u zhang -p zhang --authenticationDatabase admin</div><div class="line"><span class="comment">#或</span></div><div class="line">mongo</div><div class="line">use admin</div><div class="line">db.auth(<span class="string">"zhang"</span>, <span class="string">"1314520"</span>)</div></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mongo</div><div class="line"></div><div class="line"><span class="comment">#显示当前使用数据库</span></div><div class="line">&gt;db</div><div class="line"></div><div class="line"><span class="comment">#切换数据库</span></div><div class="line">&gt;use &lt;database&gt;</div><div class="line"></div><div class="line"><span class="comment">#查看所有数据库</span></div><div class="line">&gt;show dbs</div></pre></td></tr></table></figure><p><br><br>你可以切换到一个并不存在的数据库。当你第一次向数据库存储数据，如创建一个集合，MongoDB将自动创建数据库。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">use nodb</div><div class="line"></div><div class="line">db.nocollestion.insert(&#123;x:1&#125;);</div></pre></td></tr></table></figure><p><br></p><h3 id="格式化打印结果"><a href="#格式化打印结果" class="headerlink" title="格式化打印结果"></a>格式化打印结果</h3><p><code>db.collection.find()</code>方法返回一个<code>cursor</code>(游标)。如果返回的游标未使用var关键字指定变量，则游标将自动迭代最多20次，以打印出与查询匹配的前20个<code>documents</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#在操作中添加`.pretty()`，以格式化打印结果</span></div><div class="line"><span class="comment">#使用.pretty显示结果很舒服</span></div><div class="line">db.collection.find().pretty()</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">print</span>()<span class="comment">#无格式打印</span></div><div class="line">printjson() <span class="comment">#用JSON打印</span></div></pre></td></tr></table></figure><p><br></p><h3 id="mongo-shell中的多行操作"><a href="#mongo-shell中的多行操作" class="headerlink" title="mongo shell中的多行操作"></a>mongo shell中的多行操作</h3><p>mongo shell中如果你以<code>( , { , [</code>开始，那么知道你输入了对应的<code>) , } , ]</code>才算结束命令。</p><p><br></p><h3 id="Tab命令补全和键盘快捷键"><a href="#Tab命令补全和键盘快捷键" class="headerlink" title="Tab命令补全和键盘快捷键"></a>Tab命令补全和键盘快捷键</h3><p>mongo shell支持键盘快捷键，例如：</p><ul><li>使用 <code>上/下箭头</code> 进行历史命令切换；</li><li>使用 <code>Tab键</code> 自动补全命令。</li></ul><p><br></p><h3 id="mongo-shell批量操作"><a href="#mongo-shell批量操作" class="headerlink" title="mongo shell批量操作"></a>mongo shell批量操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mongo -u xxx -p xxx --authenticationDatabase=xxx &lt;&lt; EOF</div><div class="line">show dbs</div><div class="line">use zhang</div><div class="line">db.coll01.drop()</div><div class="line">db.coll02.update( &#123; _id: <span class="string">"xxx"</span> &#125;, &#123; name: <span class="string">"zhang"</span> &#125;)</div><div class="line">EOF</div></pre></td></tr></table></figure><p><br></p><h3 id="退出mongo-shell"><a href="#退出mongo-shell" class="headerlink" title="退出mongo shell"></a>退出mongo shell</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">quit()</div><div class="line"></div><div class="line"><span class="built_in">exit</span></div><div class="line"></div><div class="line">Ctrl+c</div></pre></td></tr></table></figure><p><br></p><h2 id="配置mongo-shell"><a href="#配置mongo-shell" class="headerlink" title="配置mongo shell"></a>配置mongo shell</h2><p>可在mongo shell中设置变量<code>prompt</code>的值来修改提示符内容。<br>prompt变量可以存储字符串以及JavaScript代码。</p><p>也可以在<code>.mongorc.js</code>文件中增加提示符的逻辑操作来设置每次启动mongo shell的提示符。</p><p><br></p><h3 id="自定义提示符"><a href="#自定义提示符" class="headerlink" title="自定义提示符"></a>自定义提示符</h3><p><strong>自定义提示符展示操作符：</strong></p><p>在mongo shell中定义一下变量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cmdCount = 1;</div><div class="line">prompt = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> (cmdCount++) + <span class="string">'&gt; '</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#效果</span></div><div class="line">1&gt;</div><div class="line">2&gt;</div><div class="line">...</div></pre></td></tr></table></figure><p><br><br><strong>自定义提示符显示数据库和主机名：</strong></p><p>形式为：<database>@<hostname>$</hostname></database></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">host = db.serverStatus().host;</div><div class="line">prompt = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> db+<span class="string">'@'</span>+host+<span class="string">'$'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#效果</span></div><div class="line"><span class="built_in">test</span>@localhost$</div></pre></td></tr></table></figure><p><br><br><strong>自定义提示符展示服务器启动时间和文档数：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">prompt = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> <span class="string">'Uptime:'</span> + db.serverStatus().uptime + <span class="string">'Documents:'</span> + db.stats().objects + <span class="string">'&gt; '</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#效果</span></div><div class="line">Uptime:1234 Documents:5 &gt;</div></pre></td></tr></table></figure><p><br><br><strong>注意：</strong><br>在mongo shell里面定义的<code>prompt</code>变量知识临时生效的，退出shell后便没有。<br>如果想要当前用户永久生效，可写入<code>~/.mongorc.js</code>文件。则此用户每次启动mongo shell前都会执行这个文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vim ~/.mongorc.js</div><div class="line"></div><div class="line">host = db.serverStatus().host;</div><div class="line">prompt = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">             <span class="built_in">return</span> db+<span class="string">"@"</span>+host+<span class="string">"&gt; "</span>;</div><div class="line">         &#125;</div></pre></td></tr></table></figure><p><br></p><h3 id="在mongo-shell中使用外部编辑器"><a href="#在mongo-shell中使用外部编辑器" class="headerlink" title="在mongo shell中使用外部编辑器"></a>在mongo shell中使用外部编辑器</h3><p>可在启动mongo shell之前设置<code>EDITOR</code>环境变量来在mongo shell中使用自己的编辑器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> EDITOR=vim</div><div class="line">mongo</div><div class="line"></div><div class="line"><span class="comment">#edit &lt;variable&gt;|&lt;function&gt;</span></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">myfunc</span></span>()&#123;&#125;</div><div class="line"></div><div class="line">edit myfunc</div><div class="line"><span class="comment">#此时是edit使用vim编辑myfunc</span></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">myfunc</span></span>()&#123;</div><div class="line"><span class="built_in">print</span>(<span class="string">"It was edited by vim!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">myfunc()</div></pre></td></tr></table></figure><p><br></p><h3 id="修改mongo-shell批处理大小"><a href="#修改mongo-shell批处理大小" class="headerlink" title="修改mongo shell批处理大小"></a>修改mongo shell批处理大小</h3><p><code>db.collection.find()</code>是一种JavaScript方法，返回一个<code>cursor</code>(游标)。如果返回的游标未使用var关键字指定变量，则游标将自动迭代最多20次，以打印出与查询匹配的前20个<code>documents</code>。<br>可以设置<code>DBQuery.shellBatchSize</code>属性来修改默认20篇文档。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DBQuery.shellBatchSize = 10;</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="获取mongo-shell帮助"><a href="#获取mongo-shell帮助" class="headerlink" title="获取mongo shell帮助"></a>获取mongo shell帮助</h2><p>合理运用<code>Tab键</code>补全命令！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###命令行帮助</span></div><div class="line">mongo --<span class="built_in">help</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###mongo shell里查看帮助列表</span></div><div class="line"><span class="built_in">help</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###数据库帮助</span></div><div class="line"><span class="comment">#db.&lt;method&gt;</span></div><div class="line">show dbs</div><div class="line">db.help()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###集合帮助</span></div><div class="line"><span class="comment">#db.&lt;collection&gt;.&lt;method&gt;</span></div><div class="line">show collections</div><div class="line">db.collections.help()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###游标帮助</span></div><div class="line">db.collection.find().<span class="built_in">help</span>()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###封装对象帮助</span></div><div class="line"><span class="built_in">help</span> misc</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="给mongo-shell写脚本"><a href="#给mongo-shell写脚本" class="headerlink" title="给mongo shell写脚本"></a>给mongo shell写脚本</h2><p>可使用JavaScript为mongo shell编写脚本，用于处理MongoDB中的数据或执行管理操作。</p><p><br></p><h3 id="打开新连接"><a href="#打开新连接" class="headerlink" title="打开新连接"></a>打开新连接</h3><p>在mongo shell或JavaScript文件中，可使用<code>Mongo()</code>构造函数来实例化数据库连接：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">new Mongo()</div><div class="line">new Mongo(&lt;host&gt;)</div><div class="line">new Mongo(&lt;host:port&gt;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">conn = new Mongo();</div><div class="line">db = conn.getDB(<span class="string">'mydb'</span>);<span class="comment">#将全局db变量设置为mydb</span></div><div class="line"></div><div class="line"><span class="comment">#连接</span></div><div class="line">db = connect(<span class="string">'localhost:27017/mydb'</span>);</div><div class="line"></div><div class="line"><span class="comment">#认证</span></div><div class="line">db.auth(&lt;user&gt;, &lt;passwd&gt;)</div><div class="line"></div><div class="line">db.auth(&#123;</div><div class="line">user: &lt;user&gt;,</div><div class="line">    <span class="built_in">pwd</span>: &lt;passed&gt;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><br></p><h3 id="交互式和脚本化mongo的区别"><a href="#交互式和脚本化mongo的区别" class="headerlink" title="交互式和脚本化mongo的区别"></a>交互式和脚本化mongo的区别</h3><p>mongo shell中的帮助与JavaScript中帮助不一样！</p><table><thead><tr><th>mongo shell帮助</th><th>JavaScript等量</th></tr></thead><tbody><tr><td>show dbs</td><td>db.adminCommand(‘listDatabases’)</td></tr><tr><td>use <db></db></td><td>db = db.getSiblingDB(‘<db>‘)</db></td></tr><tr><td>show collections</td><td>db.getCollectionNames()</td></tr><tr><td>show users</td><td>db.getUsers()</td></tr><tr><td>show log <logname></logname></td><td>db.adminCommand({‘getLog’ : ‘<logname>‘})</logname></td></tr></tbody></table><p><br></p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>使用mongo shell来计算JavaScript的值。</p><p><br><br><strong>–eval <javascript></javascript></strong><br><code>mongo</code>执行 <code>--eval</code>后的js命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongo test --eval &quot;printjson(db.getCollectionNames())&quot;</div></pre></td></tr></table></figure><p><br><br><strong>执行JavaScript文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mongo localhost:27017/<span class="built_in">test</span> myjs.js</div><div class="line"></div><div class="line"><span class="comment">#在shell中执行.js</span></div><div class="line">&gt;load(<span class="string">"myjs.js"</span>)</div><div class="line">&gt;loca(<span class="string">"/root/mongo/myjs.js"</span>)</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="mongo-shell中的数据类型"><a href="#mongo-shell中的数据类型" class="headerlink" title="mongo shell中的数据类型"></a>mongo shell中的数据类型</h2><p>MongoDB BSON提供了除JSON之外的其它数据类型的支持。Driver提供了对这些数据类型在主机语言的本地化支持，mongo shell也提供了一些帮助类来支持这些数据类型在mongo javascript shell中的使用。</p><p><br></p><h3 id="日期-1"><a href="#日期-1" class="headerlink" title="日期"></a>日期</h3><p>mongo shell提供了多种方法返回日期:</p><ul><li><code>Date()</code> 方法返回当前日期为一个字符串；</li><li><code>new Date()</code> 构造函数返回一个使用ISODate()包装返回的Date对象；</li><li><code>ISODate()</code> 构造函数返回一个使用ISODate()包装返回的Date对象。</li></ul><p><br><br>返回一个日期为字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myDateString = Date();</div><div class="line">#查看变量值</div><div class="line">myDateString</div></pre></td></tr></table></figure><p><br><br>验证类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typeof myDateString()</div><div class="line">#string</div></pre></td></tr></table></figure><p><br><br>返回Date：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var myDate = new Date();</div><div class="line">myDate</div><div class="line">#ISODate(&quot;2017-12-12T08:43:31.405Z&quot;)</div><div class="line"></div><div class="line">#验证</div><div class="line">myDate instanceof Date</div></pre></td></tr></table></figure><p><br></p><h3 id="ObjectId-1"><a href="#ObjectId-1" class="headerlink" title="ObjectId"></a>ObjectId</h3><p>mongo shell对objectid数据类型提供objectId()包装类。</p><p><code>new ObjectId</code></p><p><br></p><h3 id="NumberLong"><a href="#NumberLong" class="headerlink" title="NumberLong"></a>NumberLong</h3><p>mongo shell默认将所有数字处理为浮点值。</p><p>用<code>numberlong()</code>包装来处理64位整数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NumberLong(<span class="string">"2090845886852"</span>)</div></pre></td></tr></table></figure><p><br></p><h3 id="NumberInt"><a href="#NumberInt" class="headerlink" title="NumberInt"></a>NumberInt</h3><p>用<code>NumberInt()</code>构造函数来显式指定32位整数。</p><p><br></p><h3 id="NumberDecimal"><a href="#NumberDecimal" class="headerlink" title="NumberDecimal"></a>NumberDecimal</h3><p><code>mongo shell</code>默认将所有的数字处理为64位浮点的<code>double</code>值。<code>mongo shell</code>提供了<code>NumberDecimal()</code>构造函数限制指定128位基于十进制的浮点值，能够以精确的精度仿效十进制近似值。<br>这个功能在金融、税务以及科学计算等方面应用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;NumberDecimal(<span class="string">'1000.55'</span>)</div><div class="line"><span class="comment">#强烈建议加上引号，没加引号可能会存在精度丢失的情况</span></div></pre></td></tr></table></figure><p><br></p><p>###　在mongo shell中检查类型</p><p><code>instanceof</code>返回一个bool值来验证一个值是否为某些类型的实例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mydoc._id instanceof ObjectId</div><div class="line"><span class="comment">#true</span></div></pre></td></tr></table></figure><p><code>typeof</code>返回一个字段的类型。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typeof mydoc._id</div><div class="line"><span class="comment">#object</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="mongo-shell快速参考"><a href="#mongo-shell快速参考" class="headerlink" title="mongo shell快速参考"></a>mongo shell快速参考</h2><h3 id="mongo-shell-历史命令"><a href="#mongo-shell-历史命令" class="headerlink" title="mongo shell 历史命令"></a>mongo shell 历史命令</h3><p>mongo shell历史命令保存在<code>~/.dbshell</code>文件中，<code>cat ~/.dbshell</code>。也可以使用<strong>上/下键</strong>切换历史命令。</p><p><br></p><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><table><thead><tr><th>option</th><th>description</th></tr></thead><tbody><tr><td><code>--help</code></td><td>显示命令行选项</td></tr><tr><td><code>--nodb</code></td><td>启动mongo shell而不连接到数据库</td></tr><tr><td><code>--shell</code></td><td>执行文件后运行mongo shell</td></tr></tbody></table><p><br></p><h3 id="mongo-shell命令助手"><a href="#mongo-shell命令助手" class="headerlink" title="mongo shell命令助手"></a>mongo shell命令助手</h3><table><thead><tr><th>help methods and commands</th><th>description</th></tr></thead><tbody><tr><td><code>help</code></td><td>显示帮助</td></tr><tr><td><code>db.help</code></td><td>显示数据库方法的帮助</td></tr><tr><td><code>db.collection.help()</code></td><td>显示集合方法的帮助</td></tr><tr><td><code>show dbs</code></td><td>打印服务器上的所有数据库列表</td></tr><tr><td><code>show databases</code></td><td>打印所有可获取的数据库列表</td></tr><tr><td><code>use &lt;db&gt;</code></td><td>切换数据库</td></tr><tr><td><code>show collections</code></td><td>打印当前数据库上的所有集合列表</td></tr><tr><td><code>show users</code></td><td>打印当前数据库的用户列表</td></tr><tr><td><code>show roles</code></td><td>打印当前数据库的所有角色(user-define and built-in)列表</td></tr><tr><td><code>show profile</code></td><td>打印花费1ms或更多时间的五个最近的操作</td></tr><tr><td><code>load()</code></td><td>在shell中执行一个JavaScript文件，建议使用绝对路径</td></tr></tbody></table><p><br></p><h3 id="mongo-shell的基本JavaScript操作"><a href="#mongo-shell的基本JavaScript操作" class="headerlink" title="mongo shell的基本JavaScript操作"></a>mongo shell的基本JavaScript操作</h3><p>mongo shell为数据库操作提供了一个JavaScript API。<br>db引用当的是前数据库的变量。</p><table><thead><tr><th>JavaScript db-operation</th><th>description</th></tr></thead><tbody><tr><td><code>db.auth()</code></td><td>在安全模式下认证用户</td></tr><tr><td><code>coll = db.&lt;collection&gt;</code></td><td>将当前db中的特定collection设置为coll，可在此变量上执行操作，如<code>coll.find();</code></td></tr><tr><td><code>db.collection.find()</code></td><td>查找集合中的所有文档，并返回一个游标</td></tr><tr><td><code>db.collection.insert()</code></td><td>插入一个新文档到集合中</td></tr><tr><td><code>db.collection.update()</code></td><td>更新集合中一个存在的文档</td></tr><tr><td><code>db.collection.save()</code></td><td>插入或更新 集合中的文档</td></tr><tr><td><code>db.collection.remove()</code></td><td>从集合中删除文档</td></tr><tr><td><code>db.collection.drop()</code></td><td>删除整个集合</td></tr><tr><td><code>db.collection.createIndex()</code></td><td>在集合中创建索引</td></tr><tr><td><code>db.getSiblingDB()</code></td><td>跨数据库查询</td></tr></tbody></table><p><br></p><h3 id="键盘快捷键"><a href="#键盘快捷键" class="headerlink" title="键盘快捷键"></a>键盘快捷键</h3><table><thead><tr><th>keysrtoke</th><th>function</th></tr></thead><tbody><tr><td>Up/Down arrow</td><td>前/后 历史命令</td></tr><tr><td>Left/Right arrow</td><td>左右移动</td></tr><tr><td>Home/End</td><td>行首/行尾</td></tr><tr><td>Tab</td><td>自动补全</td></tr><tr><td>ctrl+c</td><td>退出</td></tr><tr><td>ctrl+L</td><td>清屏</td></tr></tbody></table><p><br></p><h3 id="mongo-shell查询方法"><a href="#mongo-shell查询方法" class="headerlink" title="mongo shell查询方法"></a>mongo shell查询方法</h3><p>在mongo shell中，使用<code>find()</code>和<code>findOne()</code>方法执行读操作。</p><table><thead><tr><th>read-operations</th><th>description</th></tr></thead><tbody><tr><td><code>db.collection.find(&lt;query&gt;)</code></td><td>查找集合中与<query>匹配的文档，如果未指定<query>或为空，则读取操作会选择集合中的所有文档</query></query></td></tr><tr><td><code>db.collection.find(&lt;query&gt;, &lt;projection&gt;)</code></td><td>查找与<query>匹配的文档，返回<projection>特定字段</projection></query></td></tr><tr><td><code>db.collection.find().sort(&lt;sort order&gt;)</code></td><td>返回<sort order="">排序结果</sort></td></tr><tr><td><code>db.collection.find(&lt;query&gt;).sort(&lt;sort order&gt;)</code></td><td>返回匹配<query>和<sort order="">排序结果</sort></query></td></tr><tr><td><code>db.collection.find(...).limit(&lt;n&gt;)</code></td><td>限制输出结果为<n>行</n></td></tr><tr><td><code>db.collection.find().pretty().limit()</code></td><td>匹配，格式化，限制输出</td></tr><tr><td><code>db.collection.find().limit().pretty()</code></td><td>同上</td></tr><tr><td><code>db.collection.find(...).skip(&lt;n&gt;)</code></td><td>跳过前<n>行</n></td></tr><tr><td><code>db.collection.count()</code></td><td>返回集合中文档总数</td></tr><tr><td><code>db.collection.find().count()</code></td><td>返回匹配文档总数</td></tr><tr><td><code>db.collection.findOne(&lt;query&gt;)</code></td><td>查找并返回单一的文档，null表示未找到</td></tr></tbody></table><p><br></p><h3 id="管理命令助手"><a href="#管理命令助手" class="headerlink" title="管理命令助手"></a>管理命令助手</h3><table><thead><tr><th>js db-administrative-methods</th><th>description</th></tr></thead><tbody><tr><td><code>db.cloneDatabase(&lt;host&gt;)</code></td><td>从指定主机克隆当前数据库，noauth mode</td></tr><tr><td><code>db.copyDatabase(&lt;from&gt;, &lt;to&gt;, &lt;host&gt;)</code></td><td>copy <from>db to <to>db</to></from></td></tr><tr><td><code>db.fromColl.renameCollection(&lt;toColl&gt;)</code></td><td>rename collection</td></tr><tr><td><code>db.repairDatabase()</code></td><td>修复当前db</td></tr><tr><td><code>db.dropDatabases()</code></td><td>删除当前数据库</td></tr></tbody></table><p><br></p><h3 id="打开附加连接"><a href="#打开附加连接" class="headerlink" title="打开附加连接"></a>打开附加连接</h3><p>可以在mongo shell中创建一个新连接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;db = connect(<span class="string">"&lt;host&gt;:&lt;port&gt;/&lt;db&gt;"</span>)</div><div class="line">#db = connect("192.168.1.11/admin")</div><div class="line"></div><div class="line">&gt;conn = <span class="keyword">new</span> Mongo()</div><div class="line">&gt;db = conn.getDB(<span class="string">"dbname"</span>)</div></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="MongoDB-CRUD操作"><a href="#MongoDB-CRUD操作" class="headerlink" title="MongoDB CRUD操作"></a>MongoDB CRUD操作</h1><p><code>CRUD</code>操作就是<em>创建(create)，读取(read)，更新(update)，删除(delete)</em>文档(document)!</p><p><br><br><strong>创建(create)操作</strong><br>创建或插入， 即是向 collection 添加新的 document。如果插入时集合不存在，插入操作会创建该集合。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.collection.insert()</div><div class="line">db.collection.insertOne()</div><div class="line">db.collection.insertMany()</div></pre></td></tr></table></figure><p><br><br><strong>读取(read)操作</strong><br>读操作，获取 collection 中的 document。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.collection.find()</div></pre></td></tr></table></figure><p><br><br><strong>更新(update)操作</strong><br>更新操作，修改 collection 中已经存在的 document。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.collection.update()</div><div class="line">db.collection.updateOne()</div><div class="line">db.collection.updateMany()</div><div class="line">db.collection.replaceOne()</div></pre></td></tr></table></figure><p><br><br><strong>删除(delete)操作</strong><br>删除操作，是从一个 collection 中删除 document 的操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.collection.remove()</div><div class="line">db.collection.deleteOne()</div><div class="line">db.collection.deleteMany()</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="插入文档-Insert"><a href="#插入文档-Insert" class="headerlink" title="插入文档(Insert)"></a>插入文档(Insert)</h2><p><br></p><h3 id="插入方法"><a href="#插入方法" class="headerlink" title="插入方法"></a>插入方法</h3><p>MongoDB提供了如下插入方法向collection中插入document：</p><ul><li><code>db.collection.insert()</code>, 向集合中插入一个或多个文档;</li><li><code>db.collection.insertOne()</code>, 向集合中插入一个文档;</li><li><code>db.collection.insertMany()</code>, 向集合中插入多个文档.</li></ul><p><br></p><h4 id="db-collection-insert"><a href="#db-collection-insert" class="headerlink" title="db.collection.insert()"></a>db.collection.insert()</h4><p><code>db.collection.insert()</code>,向collection中插入一个或多个document。<br>要想插入一个document，传递<strong>一个文档</strong>给该方法；要想插入多个documents，传递<strong>文档数组</strong>给该方法。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#插入一个文档</span></div><div class="line">db.user.insert(</div><div class="line">&#123;</div><div class="line">    _id: <span class="string">"ZhangTest"</span>,</div><div class="line">    name: <span class="string">"zhang"</span>,</div><div class="line">        age: 2017,</div><div class="line">        sex: <span class="string">"man"</span></div><div class="line">    &#125;</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#插入多个文档</span></div><div class="line">db.user.insert(</div><div class="line">[</div><div class="line">    &#123; name: <span class="string">"AAA"</span>, age: 20, status: <span class="string">"A"</span> &#125;,</div><div class="line">        &#123; name: <span class="string">"BBB"</span>, age: 21, status: <span class="string">"B"</span> &#125;,</div><div class="line">        &#123; name: <span class="string">"CCC"</span>, age: 22, status: <span class="string">"C"</span> &#125;</div><div class="line">    ]</div><div class="line">)</div></pre></td></tr></table></figure><p><br></p><h4 id="db-collection-insertOne"><a href="#db-collection-insertOne" class="headerlink" title="db.collection.insertOne()"></a>db.collection.insertOne()</h4><p><code>db.collection.insertOne()</code>,向collection中插入单个document。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">db.user.insertOne(</div><div class="line">&#123;</div><div class="line">name: <span class="string">"zhang"</span>,</div><div class="line">        age: <span class="string">"2017"</span>,</div><div class="line">        sex: <span class="string">"man"</span>,</div><div class="line">        education: <span class="string">"bachelor"</span></div><div class="line">&#125;</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">#此处并未自定义_id字段，因此它会自动添加_id字段</span></div></pre></td></tr></table></figure><p><br></p><h4 id="db-collection-insertMany"><a href="#db-collection-insertMany" class="headerlink" title="db.collection.insertMany()"></a>db.collection.insertMany()</h4><p><code>db.collection.insertMany()</code>,向collection插入多个documents。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.user.insertMany(</div><div class="line">[</div><div class="line">    &#123; name: <span class="string">"AAA"</span>, age: <span class="string">"20"</span>, status: <span class="string">"A"</span> &#125;,</div><div class="line">        &#123; name: <span class="string">"BBB"</span>, age: <span class="string">"21"</span>, status: <span class="string">"B"</span> &#125;,</div><div class="line">        &#123; name: <span class="string">"CCC"</span>, age: <span class="string">"22"</span>, status: <span class="string">"C"</span> &#125;</div><div class="line">    ]</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">#自动生成3个document的_id字段</span></div></pre></td></tr></table></figure><p><br></p><h3 id="插入操作的行为表现"><a href="#插入操作的行为表现" class="headerlink" title="插入操作的行为表现"></a>插入操作的行为表现</h3><p><strong>创建集合</strong><br>插入的时候如果collection不存在，那么插入操作会创建collection。</p><p><strong>_id字段</strong><br>在MongoDB中，存储于collection中的每一个document都需要一个唯一的<code>_id</code>字段作为<code>primary_key</code>。如果一个插入的document操作遗漏了<code>_id</code>字段，则<code>MongoDB driver</code>会自动生成一个<code>ObjectId</code>。</p><p><strong>原子性</strong><br>MongoDB中所有的写操作在单一文档层级上是原子的。</p><p><br><br><br></p><h2 id="查询文档-Read"><a href="#查询文档-Read" class="headerlink" title="查询文档(Read)"></a>查询文档(Read)</h2><p>MongoDB提供了<code>db.collection.find()</code>方法从collection中读取document。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.collection.find( &lt;query filter&gt;, &lt;projection&gt; )</div><div class="line"></div><div class="line"><span class="comment">#&lt;query filter&gt;指明返回哪些document</span></div><div class="line"><span class="comment">#&lt;projection&gt;指明返回匹配document的那些filed</span></div></pre></td></tr></table></figure><p><br></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">db.user.insertMany(</div><div class="line">  [</div><div class="line">  &#123;</div><div class="line">_id: 1,</div><div class="line">name: <span class="string">"A"</span>,</div><div class="line">favorites: &#123; artist: <span class="string">"Picasso"</span>, food: <span class="string">"pizza"</span> &#125;,</div><div class="line">        finished: [ 11, <span class="string">"AA"</span> ],</div><div class="line">        points: [ &#123; points: 85, bonus: 30 &#125;, &#123; points: 85, bonus: 10 &#125; ]</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">    _id: 2,</div><div class="line">        name: <span class="string">"B"</span>,</div><div class="line">    favorites: &#123; artist: <span class="string">"Miro"</span>, food: <span class="string">"merigue"</span> &#125;,</div><div class="line">        finished: [ 22, <span class="string">"BB"</span> ],</div><div class="line">        points: [ &#123; points: 85, bonus: 20 &#125;, &#123; points: 64, bonus: 12 &#125; ]</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">    _id: 3,</div><div class="line">        name: <span class="string">"C"</span>,</div><div class="line">        favorites: &#123; artist: <span class="string">"Gaogeng"</span>, food: <span class="string">"cake"</span> &#125;,</div><div class="line">        finished: [ 33, <span class="string">"CC"</span> ],</div><div class="line">        points: [ &#123; points: 67, bonus: 8 &#125;, &#123; points: 55, bonus: 21 &#125; ]</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">)</div></pre></td></tr></table></figure><p><br></p><h3 id="查询和规划操作符"><a href="#查询和规划操作符" class="headerlink" title="查询和规划操作符"></a>查询和规划操作符</h3><p><strong>Comparison:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$eq</div><div class="line">$gt</div><div class="line">$gte</div><div class="line">$lt</div><div class="line">$ne</div><div class="line">$in</div><div class="line">$nin</div></pre></td></tr></table></figure><p><strong>Logical：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$or</div><div class="line">$and</div><div class="line">$not</div><div class="line">$nor</div></pre></td></tr></table></figure><p><strong>Element:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$exists</div><div class="line">$type</div></pre></td></tr></table></figure><p><strong>Evaluation:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$mod</div><div class="line">$regex</div><div class="line">$text</div><div class="line">$where</div></pre></td></tr></table></figure><p><strong>Geospatial:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$geoWithin</div><div class="line">$geoIntersects</div><div class="line">$near</div><div class="line">$nearSphere</div></pre></td></tr></table></figure><p><strong>Array:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$all</div><div class="line">$eleMatch</div><div class="line">$size</div></pre></td></tr></table></figure><p><strong>Bitwise:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$bitsAllSet</div><div class="line">$bitsAnySet</div><div class="line">$bitsAllClear</div><div class="line">$bitsAnyClear</div></pre></td></tr></table></figure><p><strong>Comments:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$comment</div></pre></td></tr></table></figure><p><strong>Projection Operators:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$</div><div class="line">$eleMatch</div><div class="line">$meta</div><div class="line">$slice</div></pre></td></tr></table></figure><p><br></p><h4 id="选择collectino中所有document"><a href="#选择collectino中所有document" class="headerlink" title="选择collectino中所有document"></a>选择collectino中所有document</h4><p>一个空的<code>query filter</code>会选择集合汇总所有文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.users.find(&#123;&#125;)</div><div class="line">db.user.find()</div></pre></td></tr></table></figure><p><br></p><h4 id="指定查询过滤条件"><a href="#指定查询过滤条件" class="headerlink" title="指定查询过滤条件"></a>指定查询过滤条件</h4><p><strong>1. 指定等于条件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; &lt;field1&gt;: &lt;value1&gt;, ...&#125;</div><div class="line"></div><div class="line">#栗子</div><div class="line">db.user.find( &#123; name: &quot;C&quot; &#125; )</div></pre></td></tr></table></figure><p><strong>2. 使用查询操作符指定条件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; &lt;field1&gt;: &#123; &lt;operator1&gt;: &lt;value1&gt; &#125;, ... &#125;</div><div class="line"></div><div class="line">#栗子</div><div class="line">db.user.find( &#123; name: &#123; $in: [ &quot;A&quot;, &quot;B&quot; ] &#125; &#125; )</div></pre></td></tr></table></figure><p><strong>3. 指定逻辑查询条件条件</strong><br>逻辑查询(AND, OR, NOT)。符合查询可以在集合文档的多个字段上指定条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#AND</div><div class="line">db.user.find( &#123; name: &quot;A&quot;, age: &#123; $lt: 30&#125; &#125; )</div><div class="line"></div><div class="line"></div><div class="line">#OR</div><div class="line">db.user.find( &#123;</div><div class="line">$or: [ &#123; name: &quot;A&quot; &#125;, &#123; age: &#123; $lt: 30 &#125; &#125; ]</div><div class="line">&#125; )</div><div class="line"></div><div class="line"></div><div class="line">#AND和OR</div><div class="line">db.user.find( &#123;</div><div class="line">name: &quot;A&quot;,</div><div class="line">    $or: [ &#123;age: &#123; $lt: 30 &#125; &#125;, &#123; type: 1 &#125; ]</div><div class="line">&#125; )</div></pre></td></tr></table></figure><p><br></p><h4 id="嵌入式文档的查询"><a href="#嵌入式文档的查询" class="headerlink" title="嵌入式文档的查询"></a>嵌入式文档的查询</h4><p>当字段中包含嵌入文档时，查询可以指定嵌入文档中的精确匹配或使用<code>圆点(.)表示法</code>对嵌入文档的单个字段指定匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#精确匹配</div><div class="line">db.user.find(&#123;</div><div class="line">favorites: &#123; artist: &quot;Picasso&quot;, food: &quot;pizza&quot; &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">#圆点.表示法，记得加引号</div><div class="line">db.user.find( &#123; &quot;favorites.artist&quot;: &quot;Picasso&quot; &#125; )</div></pre></td></tr></table></figure><p><br></p><h4 id="数组上的查询"><a href="#数组上的查询" class="headerlink" title="数组上的查询"></a>数组上的查询</h4><p>当字段包含数组，可查询精确的匹配数组或数组中特定的值。如果数组包含嵌入文档，可使用<code>圆点表示法</code>查询内嵌文档中特定的字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#精确匹配</div><div class="line">db.user.find(&#123; finished: [ 11, &quot;AA&quot; ] &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#匹配一个数组元素，会显示整个文档</div><div class="line">db.user.find(&#123; finished: &quot;BB&quot; &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#匹配数组中指定元素，会返回整个文档</div><div class="line">db.user.find(&#123; &quot;finished.1&quot;: &quot;CC&quot; &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#指定数组中的多个查询条件</div><div class="line">db.user.find(&#123; finished: &#123; $elemMatch: &#123;$gte: 11, $lt: 33&#125; &#125; &#125;)</div><div class="line"></div><div class="line">db.user.find(&#123; finished: &#123; $gt: 11, $lt: 33 &#125; &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#嵌入文档数组</div><div class="line">db.user.find(&#123; &apos;points.points&apos;: &#123;$lte: 80 &#125; &#125;)</div><div class="line">db.user.find(&#123; &quot;points.0.points&quot;: &#123;$lte: 80&#125; &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#元素组合满足查询条件</div><div class="line">db.user.find(&#123;</div><div class="line">&quot;points.points&quot;: &#123;$lte: 80&#125;, &quot;points.bouns&quot;: 20</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><br></p><h3 id="返回查询的映射字段"><a href="#返回查询的映射字段" class="headerlink" title="返回查询的映射字段"></a>返回查询的映射字段</h3><p>默认地，MongoDB中的查询返回匹配文档中的所有字段。为了限制MongoDB发送给应用的数据量，我们可以在查询操作中包括一个<code>projection</code>文档。</p><p><br></p><h4 id="映射文档"><a href="#映射文档" class="headerlink" title="映射文档"></a>映射文档</h4><p>映射文档限制了返回所有匹配文档的字段。映射文档可以致命包括哪些字段或排除哪些字段。<br>这个就很不错了，可以过滤掉我们不需要的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.users.find( &#123;name: &quot;AAA&quot;&#125; ,&#123;_id: 0, name: 1, age: ture&#125; )</div><div class="line">db.user.find( &#123; name: &quot;BBB&quot;&#125;, &#123;_id: false&#125; )</div><div class="line"></div><div class="line">1或true，表示在返回的文档中包含字段；</div><div class="line">0或false，排除该字段；</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="更新文档-Update"><a href="#更新文档-Update" class="headerlink" title="更新文档(Update)"></a>更新文档(Update)</h2><p><strong>更新方法：</strong></p><ul><li><code>db.collection.updateOne()</code>, 更新一个文档</li><li><code>db.collection.updateMany()</code>, 更新多个文档</li><li><code>db.replaceOne()</code>, 替换一个文档</li><li><code>db.collection.update()</code>, 更新或替换一个文档</li></ul><p><br></p><h3 id="更新的行为表现"><a href="#更新的行为表现" class="headerlink" title="更新的行为表现"></a>更新的行为表现</h3><ul><li><p>原子性：<br>MongoDB中所有的写操作在单一文档层级上是原子的。</p></li><li><p>_id字段：<br>不能更新<code>_id</code>字段的值，也不能用不同<code>_id</code>字段值的替换文档来替换已存在的文档。</p></li><li><p>文档大小：<br>当执行更新操作增加的文档大小超过了为该文档分配的空间时，更新操作会在磁盘上重定位该文档。</p></li><li><p>字段顺序：<br>MongoDB按照文档写入的顺序整理文档字段。但<code>_id</code>字段始终是文档中第一个字段；<code>renaming</code>操作可能会导致文档中的字段重新排序。</p></li></ul><p><br></p><h3 id="Update-Operator"><a href="#Update-Operator" class="headerlink" title="Update Operator"></a>Update Operator</h3><p><strong>Fields</strong></p><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody><tr><td>$currentDate</td><td>将字段值设置为当前日期(date or timestamp)</td></tr><tr><td>$inc</td><td>按指定的数字递增字段的值</td></tr><tr><td>$min</td><td>指定的值小于字段的值时才更新</td></tr><tr><td>$max</td><td>指定的值大于字段的值时才更新</td></tr><tr><td>$mul</td><td>将字段的值乘以指定的数字</td></tr><tr><td>$rename</td><td>重命名一个字段</td></tr><tr><td>$set</td><td>设置文档中字段的值</td></tr><tr><td>$setOnInsert</td><td>如果更新导致文档插入，则设置字段的值</td></tr><tr><td>$unset</td><td>从文档中删除指定的字段，</td></tr></tbody></table><p><br></p><p><strong>Array</strong></p><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody><tr><td>$</td><td>用作更新与查询条件匹配的第一个元素的占位符</td></tr><tr><td>$[]</td><td>用作更新与查询条件匹配的文档的数组的所有元素的占位符</td></tr><tr><td>$[<identifier>]</identifier></td><td>xxx</td></tr><tr><td>$addToSet</td><td>在集合中不存在元素时添加元素到数组</td></tr><tr><td>$pop</td><td>移除数组中的第一项或最后一项</td></tr><tr><td>$pull</td><td>删除所有匹配指定查询的数组元素</td></tr><tr><td>$push</td><td>向数组中添加项</td></tr><tr><td>$pullAll</td><td>从数组中删除所有匹配的值</td></tr></tbody></table><p><br></p><p><strong>Modifiers</strong></p><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody><tr><td>$each</td><td>修饰$push and $addToSet， 向数组中添加多个项</td></tr><tr><td>$position</td><td>修饰$push，在数组中指定位置添加元素</td></tr><tr><td>$slice</td><td>修饰$push，限制更新数组的大小</td></tr><tr><td>$sort</td><td>修饰$push，重新排列存储在数组中的文档</td></tr></tbody></table><p><br></p><p><strong>BitWise</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$bit执行按位AND,OR,XOR更新</div></pre></td></tr></table></figure><p><br></p><h3 id="更新文档字段中指定字段"><a href="#更新文档字段中指定字段" class="headerlink" title="更新文档字段中指定字段"></a>更新文档字段中指定字段</h3><p>为了修改文档中的字段，MongoDB提供了<code>update operators</code>，如用来修改值的<code>$set</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&lt;update operator&gt;: &#123; &lt;field&gt;: &lt;value&gt;, ...&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">#更改指定字段的值</div><div class="line">db.user.update(</div><div class="line">&#123; _id: 1 &#125;,</div><div class="line">    &#123; $set: &#123;name: &quot;SET&quot;&#125; &#125;</div><div class="line">)</div><div class="line"></div><div class="line">#删除指定字段，文档中其他字段还在</div><div class="line">db.user.update(</div><div class="line">&#123; _id: 1 &#125;,</div><div class="line">    &#123; $unset: &#123;name: &quot;SET&quot;&#125; &#125;</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line">#</div><div class="line">db.user.updateMany(</div><div class="line">&#123; _id: 2&#125;,</div><div class="line">    &#123; $set: &#123;name: &quot;AAA&quot;, age: 222&#125; &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p><br></p><h3 id="文档替换-Replace"><a href="#文档替换-Replace" class="headerlink" title="文档替换(Replace)"></a>文档替换(Replace)</h3><p>当替换文档时，替换的文档必须仅仅有 <code>&lt;field&gt;: &lt;value&gt;</code>组成。<br>替换文档可以有不同于源文档的字段，但<code>_id</code>字段是不变的。</p><p>**建议使用<code>_id</code>作为过滤条件，因为它是唯一的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">db.collection.replaceOne()</div><div class="line"></div><div class="line"></div><div class="line">db.user.replaceOne(</div><div class="line">&#123; name: &quot;AAA&quot; &#125;,</div><div class="line">    &#123; name: &quot;A&quot;, age: 2, sex: &quot;man&quot;, favorites: &#123; artist: &quot;Dali&quot;, food: &quot;banana&quot; &#125; &#125;</div><div class="line">)</div><div class="line"></div><div class="line">db.user.update(</div><div class="line">&#123; _id: 1&#125;,</div><div class="line">    &#123; name: &quot;A&quot;, age: 2, sex: &quot;man&quot;, favorites: &#123; artist: &quot;Dali&quot;, food: &quot;banana&quot; &#125; &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="删除文档-Delete"><a href="#删除文档-Delete" class="headerlink" title="删除文档(Delete)"></a>删除文档(Delete)</h2><p><strong>方法：</strong></p><ul><li><code>db.collection.remove()</code>, 删除一个文档，或所有满足匹配的文档;</li><li><code>db.collection.deleteOne()</code>, 删除匹配最多条件的单个文档，即使可能有多个文档可能与指定过滤条件匹配;</li><li><code>db.collection.deleteMany()</code>, 删除所有匹配指定过滤条件的文档。</li></ul><p><br></p><h3 id="删除的行为表现"><a href="#删除的行为表现" class="headerlink" title="删除的行为表现"></a>删除的行为表现</h3><ul><li><p>Indexes<br>删除操作不会删除索引，即使从集合中删除了所有的文档。</p></li><li><p>原子性<br>MongoDB中所有的写操作在单一文档层级上是原子的。</p></li></ul><p><br></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#删除所有文档</div><div class="line">db.collectin.deleteMany(&#123;&#125;)</div><div class="line">db.collection.remove(&#123;&#125;)</div><div class="line"></div><div class="line"></div><div class="line">#删除所有满足条件的文档</div><div class="line">db.user.remove( &#123; name: &quot;A&quot; &#125; )</div><div class="line">db.user.deleteMany( &#123; name: &quot;A: &#125; )</div><div class="line"></div><div class="line"></div><div class="line">#仅删除一个满足条件最多的文档</div><div class="line">db.user.deleteOne( &#123; name: &quot;A&quot; &#125; )</div><div class="line"></div><div class="line">db.users.remove( &#123; name: &quot;A&quot;&#125;, 1)</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="聚合-Agrregation"><a href="#聚合-Agrregation" class="headerlink" title="聚合(Agrregation)"></a>聚合(Agrregation)</h1><p>聚合操作处理数据记录并返回计算的结果。聚合操作将多个文档中的值(value)分组，并对分组的数据进行各类操作以返回单个结果。</p><p>MongoDB提供了三种方式进行聚合：</p><ul><li>aggregation pipeline(聚合管道);</li><li>map-reduce function(映射化简);</li><li>single aggregation methods(聚合指南)</li></ul><p><br></p><p><strong>Aggregation Pipeline(聚合管道)</strong></p><p>MongoDB的聚合框架(aggregation framework)是仿照数据处理管道的概念(concept)。Document输入多级管道，它将Document转换为聚合结果。</p><p>最基本的pipeline stage提供了：类似查询(query)操作的过滤器(filter)和类似修改(modify)输出文档格式的文档转换。</p><p>其他pipeline operation提供了按特定字段对文档进行分组和排序的工具，以及聚合数组内容(包括文档数组)的字段或工具。此外，pipeline stage可以使用运算符(operators)来处理任务。(如计算平均值和连接等…)</p><p>pipeline通过在MongoDB中使用本地操作，从而提供了高效的数据聚合。所以也是MongoDB中数据聚合的首选方法。</p><p>aggregation pipeline能够在一个共享的集合上操作。</p><p>aggregation pipeline可以使用索引来提高某些阶段的性能(performance)。另外，管道聚合还有一个内部优化阶段(optimization phase)。</p><p><img src="/images/MongoDB/aggregation-pipeline.png" alt="aggregation-pipeline"></p><p><br></p><p><strong>Map-Reduce(映射化简)</strong></p><p>一般来说，map-reduce操作有两个阶段：</p><ul><li>map stage: 处理每个文档并未每个输入文档发出一个或多个对象(object)；</li><li>reduce stage: 结合映射操作的输出。</li></ul><p>可选地，map-reduce有一个对结果做最后修改的最后阶段。与aggregation-operation类似，map-reduce可以指定查询条件来选择一个输入文档，以及对结果进行排序和限制。</p><p>map-reduce使用自定义的JavaScript函数执行映射和化简操作，以及可选的最终操作。与聚合管线相比，自定义的JavaScript提供了很大的灵活性。一般来说，map-reduce比aggregation pipeline效率更低，更复杂。</p><p>map-reduce能够在一个共享的集合上操作，同样也可以输出到共享集合。</p><p><img src="/images/MongoDB/map-reduce.png" alt="map-reduce"></p><p><br></p><p><strong>Single Purpose Aggregation Operations(聚合指南)</strong></p><p>MongoDB同样提供了<code>db.collection.count()</code>和<code>db.collection.distinct()</code>。</p><p>所有这些操作都从单个集合中聚合文档，虽然这些操作提供了对常见聚合过程的简单访问，但它们缺少aggregation pipeline和map-reduce的灵活性和功能。</p><p><img src="/images/MongoDB/distinct.png" alt="distinct"></p><p><br><br><br></p><h2 id="Aggregation-Pipeline-聚合管道"><a href="#Aggregation-Pipeline-聚合管道" class="headerlink" title="Aggregation Pipeline(聚合管道)"></a>Aggregation Pipeline(聚合管道)</h2><p>MongoDB的聚合框架是仿照数据处理管道的概念。文档输入多级管道，它将文档转换为聚合结果。</p><p>当map-reduce的复杂性可能是没有保证的，aggregation pipeline为map-reduce提供了一个可选也可能是聚合任务的首选解决方案。<br>aggregation pipeline对key value和result size有一些限制。</p><p><br><br><br></p><h2 id="映射化简"><a href="#映射化简" class="headerlink" title="映射化简"></a>映射化简</h2><p><br><br><br></p><h2 id="聚合指南"><a href="#聚合指南" class="headerlink" title="聚合指南"></a>聚合指南</h2><p><br></p><hr><p><br></p><h1 id="MongoDB文本索引"><a href="#MongoDB文本索引" class="headerlink" title="MongoDB文本索引"></a>MongoDB文本索引</h1><p>MongoDB支持在字符串内容上执行文本检索(text search)的查询操作。视图不支持文本检索。<br>为了执行文本检索，MongoDB使用<code>text index</code>和<code>$text</code>操作符。text索引可以包括任何值为字符串或字符串元素数组的字段。</p><p>栗子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.sample.insert(</div><div class="line">[</div><div class="line">&#123; _id: 1, name: <span class="string">"A"</span>, description: <span class="string">"AAA"</span> &#125;,</div><div class="line">        &#123; _id: 2, name: <span class="string">"B"</span>, description: <span class="string">"BBB"</span> &#125;,</div><div class="line">        &#123; _id: 3, name: <span class="string">"C"</span>, description: <span class="string">"CCC"</span> &#125;</div><div class="line">]</div><div class="line">)</div></pre></td></tr></table></figure><p>为了执行文本检索查询，你必须在集合有一个text索引，一个集合只能有<strong>一个</strong>文本检索索引，但是这个索引可以覆盖多个字段。</p><p>启动在<code>name</code>和<code>description</code>字段上的文本检索：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.sample.createIndex(</div><div class="line">&#123; name: <span class="string">"text"</span>, description: <span class="string">"text"</span> &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p>使用<code>$text</code>查询操作符在一个有<code>text index</code>的集合上执行文本检索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">db.sample.find(&#123;</div><div class="line">$text: &#123; $search: &quot;A B&quot; &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">#精确检索</div><div class="line">db.sample.find(&#123;</div><div class="line">$text: &#123; $search: &quot;A \&quot;B\&quot;&quot; &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">#词语排除</div><div class="line">db.sample.find(&#123;</div><div class="line">$text: &#123; $search: &quot;A B -AAA&quot; &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>MongoDB默认返回没排序的结果。然而文本检索将会对每个文档计算一个相关性分数，表明该文档与查询的匹配程度。<br>为了使用相关性分数进行排序，你必须使用 <code>$meta textScore</code>字段进行映射然后基于该字段进行排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.sample.find(</div><div class="line">&#123; $text: &#123; $search: &quot;A AAA B&quot; &#125; &#125;,</div><div class="line">    &#123; score: &#123; $meta: &quot;textScore&quot; &#125; &#125;</div><div class="line">).sort( &#123; score: &#123; $meta: &quot;textScore&quot; &#125; &#125;)</div></pre></td></tr></table></figure><p>文本检索可以在聚合管道中使用。</p><p><br><br><br></p><h2 id="文本索引"><a href="#文本索引" class="headerlink" title="文本索引"></a>文本索引</h2><p><br><br><br></p><h2 id="文本检索操作符"><a href="#文本检索操作符" class="headerlink" title="文本检索操作符"></a>文本检索操作符</h2><p><br><br><br></p><h2 id="在管道聚合中使用文本索引"><a href="#在管道聚合中使用文本索引" class="headerlink" title="在管道聚合中使用文本索引"></a>在管道聚合中使用文本索引</h2><p><br><br><br></p><h2 id="使用基本技术Rosette语义平台的文本索引"><a href="#使用基本技术Rosette语义平台的文本索引" class="headerlink" title="使用基本技术Rosette语义平台的文本索引"></a>使用基本技术Rosette语义平台的文本索引</h2><p><br><br><br></p><h2 id="文本检索语言"><a href="#文本检索语言" class="headerlink" title="文本检索语言"></a>文本检索语言</h2><p><br></p><hr><p><br></p><h1 id="MongoDB数据模型"><a href="#MongoDB数据模型" class="headerlink" title="MongoDB数据模型"></a>MongoDB数据模型</h1><p>MongoDB的数据具有灵活的模式，集合本身没有对文档结构的规则性校验。</p><p><br></p><h2 id="数据模型设计介绍"><a href="#数据模型设计介绍" class="headerlink" title="数据模型设计介绍"></a>数据模型设计介绍</h2><p>关系型数据库要求你再插入数据之前必须先定义好一个表的模式结构，而MongoDB的集合并不限制文档结构。<br>这种灵活性让对象和数据库文档之间的映射变得很容易。即使数据记录之间有很大的变化，每个文档也可以很好的映射到各条不同的记录。<br>当然，在实际使用中，同一个集合中的文档往往都有一个比较类似的结构。</p><p>数据模型设计中最具挑战性的是在应用程序需求，数据库引擎性能要求和数据读写模式之间的权衡考量。</p><p><br></p><h3 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h3><p><strong>引用(reference)</strong><br>引用方式通过<strong>存储链接</strong>或<strong>引用信息</strong>来实现两个不同文档之间的关联。<br>应用程序可以通过解析这些数据库引用来访问相关数据。简单来讲，这就是规范化的数据模型。</p><p><img src="/images/MongoDB/data-model-normalized.png" alt="规范化数据模型"></p><p><strong>内嵌(embedded data)</strong><br>内嵌方式指把相关联的数据保存在同一个文档之内。<br>MongoDB的文档结构允许一个字段或一个数组内的值为一个嵌套的文档。这种<strong>冗余</strong>的数据模型可以让应用程序在一个数据库内完成对相关数据的读取或修改。</p><p><img src="/images/MongoDB/data-model-denormalized.png" alt="内嵌式数据模型"></p><p><br></p><h3 id="写操作的原子性"><a href="#写操作的原子性" class="headerlink" title="写操作的原子性"></a>写操作的原子性</h3><p>在MongoDB中，写操作在文档级别是原子的(atomic)，没有一个单独的写操作可以原子地影响多个文档或多个集合。但，对原子性写操作利好的内嵌数据模型会限制应用程序对数据的使用场景。</p><ul><li>嵌入(embdded)数据的非规格化(denormalized)数据模型将单个文档所表示的实体(entity)的所有相关数据组合在一起。这有利于原子写操作，因为单个写操作可以插入或更新实体的数据；</li><li>规格化(normalizing)数据通过多个集合拆分数据，并需要多个不是原子集合的写操作。</li></ul><p><br></p><h3 id="文档的增长"><a href="#文档的增长" class="headerlink" title="文档的增长"></a>文档的增长</h3><p>如果文档的大小超出分配给文档的原空间大小，那么MongoDB就需要把文档从磁盘上的现有位置移动到一个新的位置以存放更多的数据。这种数据增长的情况也会影响到是否要使用规范化或非规范化。</p><p><br></p><h3 id="数据的使用和性能"><a href="#数据的使用和性能" class="headerlink" title="数据的使用和性能"></a>数据的使用和性能</h3><p>设计文档模型时，一定要考虑应用程序会如何使用你的数据。</p><p>例如：</p><ul><li>假如应用程序通常只会使用最近插入的文档，那么可以考虑使用限制集；</li><li>假如应用会做大量的读操作，那么可以加多一些索引的方法来提升常见查询的性能。</li></ul><p><br><br><br></p><h2 id="文档验证"><a href="#文档验证" class="headerlink" title="文档验证"></a>文档验证</h2><p>MongoDB提供了在更新和插入期间验证(validate)文档的功能(capability)。验证规则是在每个集合中指定使用验证符(validator)选项，利用一个文档指定验证堆栈或表达式。</p><ul><li>通过<code>collMod</code>命令附带验证符选项向一个已经存在的集合添加文档验证；</li><li>利用<code>db.createCollection()</code>命令附带验证符选项来创建文档验证规则。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.createCollection( <span class="string">"contacts"</span>,</div><div class="line">   &#123; validator: &#123; <span class="variable">$or</span>:</div><div class="line">      [</div><div class="line">         &#123; phone: &#123; <span class="variable">$type</span>: <span class="string">"string"</span> &#125; &#125;,</div><div class="line">         &#123; email: &#123; <span class="variable">$regex</span>: /@mongodb\.com$/ &#125; &#125;,</div><div class="line">         &#123; status: &#123; <span class="variable">$in</span>: [ <span class="string">"Unknown"</span>, <span class="string">"Incomplete"</span> ] &#125; &#125;</div><div class="line">      ]</div><div class="line">   &#125;</div><div class="line">&#125; )</div></pre></td></tr></table></figure><p>MongoDb同样提供了<code>validationLevel</code>选项，它确定了MongoDb在更新期间如何将验证规则应用到已有文档，以及验证操作选项。它确定MongoDB是否错误并<strong>拒绝</strong>违反验证规则的文档，或者<strong>警告</strong>日志中的违规，但允许无效的文档。</p><p><br></p><h3 id="行为-1"><a href="#行为-1" class="headerlink" title="行为"></a>行为</h3><p>验证发生在更新和插入期间。当向一个文档添加验证，在修改之前，现有文档不会进行验证检查。</p><p><br></p><p><strong>现有文档</strong></p><p>可使用<code>validationLevel</code>选项来控制MongoDB怎样处理现有文档。</p><p>默认情况下，<code>MongoDB</code>是严格的，并且将验证规则应用于所有插入和更新操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#moderate level</span></div><div class="line"><span class="comment">#在中等级别下，对不符合验证标准的现有文档更新将不会检查有效性</span></div><div class="line"></div><div class="line">db.runCommand(&#123;</div><div class="line">collMod: <span class="string">"contacts"</span>,</div><div class="line">    validator: &#123; <span class="variable">$or</span>: [ &#123; phone: &#123; <span class="variable">$exists</span>: <span class="literal">true</span> &#125; &#125;, &#123; email: &#123; <span class="variable">$exists</span>: <span class="literal">true</span>&#125;&#125; ] &#125;,</div><div class="line">    validationLevel: <span class="string">"moderate"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>设置<code>validationLevel</code>为<code>off</code>以禁用验证功能。</p><p><br></p><p><strong>接受或拒绝无效文档</strong></p><p><code>validationAction</code>选项决定了MongoDB如何处理违反(violate)验证规则的文档。</p><p>默认情况下，<code>validationAction</code>是错误的，并且拒绝任何违反验证条件的插入和更新操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#当validationAction为warn时，MongoDB记录所有违反行为，但允许插入或更新操作。</span></div><div class="line"></div><div class="line">db.createCollection( <span class="string">"contacts"</span>,</div><div class="line">   &#123;</div><div class="line">      validator: &#123; <span class="variable">$or</span>:</div><div class="line">         [</div><div class="line">            &#123; phone: &#123; <span class="variable">$type</span>: <span class="string">"string"</span> &#125; &#125;,</div><div class="line">            &#123; email: &#123; <span class="variable">$regex</span>: /@mongodb\.com$/ &#125; &#125;,</div><div class="line">            &#123; status: &#123; <span class="variable">$in</span>: [ <span class="string">"Unknown"</span>, <span class="string">"Incomplete"</span> ] &#125; &#125;</div><div class="line">         ]</div><div class="line">      &#125;,</div><div class="line">      validationAction: <span class="string">"warn"</span></div><div class="line">   &#125;</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#如下违规操作将会报警，并由于是warn，所以写入成功</span></div><div class="line">db.contacts.insert( &#123; name: <span class="string">"Amanda"</span>, status: <span class="string">"Updated"</span> &#125; )</div></pre></td></tr></table></figure><p><br></p><p><strong>约束(restriction)</strong></p><p>无法在<code>admin</code>,<code>local</code>,<code>config</code>数据库的集合 和 <code>system.*</code>集合 里面指定验证符(validator)。</p><p><br></p><p><strong>绕过文档验证</strong></p><p>通过<code>bypassDocumentValidation</code>选项来绕过文档验证。</p><p><br><br><br></p><h2 id="数据建模理论"><a href="#数据建模理论" class="headerlink" title="数据建模理论"></a>数据建模理论</h2><h3 id="数据模型设计"><a href="#数据模型设计" class="headerlink" title="数据模型设计"></a>数据模型设计</h3><p>一个高效的数据模型能够很好的满足应用程序的需求。设计一个文档数据结构最关键的考量就是决定是使用<strong>嵌套(embdded)</strong>还是<strong>引用(reference)</strong>。</p><p><br></p><h4 id="内嵌式数据模型-非规范化"><a href="#内嵌式数据模型-非规范化" class="headerlink" title="内嵌式数据模型(非规范化)"></a>内嵌式数据模型(非规范化)</h4><p>在MongoDB里面，可以把相关的数据包括在一个单个的结构或者文档下面。这样的数据模型也叫作<strong>非规范化</strong>模式。</p><p>内嵌数据可以让应用程序把相关的数据保存在同一条数据记录里面，这样，应用程序就可以发送较少的请求给MongoDB来完成常用的查询和更新请求。</p><p><br></p><p>一般来说，下述情况建议使用内嵌数据模型：</p><ul><li>数据对象之间有包含(contain)关系；</li><li>数据对象间有一对多的关系。</li></ul><p>通常情况下，内嵌数据会对读操作有比较好的性能提高，可以使应用程序在一个单个操作就可以完成对数据的读取。同时，内嵌数据也对更新相关数据提供了一个原子性写操作。</p><p><br></p><h4 id="规范化数据模型"><a href="#规范化数据模型" class="headerlink" title="规范化数据模型"></a>规范化数据模型</h4><p>一般来说，下述情况可以使用规范化模型：</p><ul><li>内嵌数据会导致很多数据的重复，并且读性能的优势又不足与盖过数据重复的弊端时；</li><li>需要表达比较复杂的多对多关系时；</li><li>大型多层次结构数据集。</li></ul><p><br></p><h3 id="MongoDB特性和数据模型的关系"><a href="#MongoDB特性和数据模型的关系" class="headerlink" title="MongoDB特性和数据模型的关系"></a>MongoDB特性和数据模型的关系</h3><p>MongoDB的数据建模不仅仅取决于应用程序的数据需求，也要考虑MongoDB本身的一些特性。</p><p><br></p><h4 id="文档增长性-increase"><a href="#文档增长性-increase" class="headerlink" title="文档增长性(increase)"></a>文档增长性(increase)</h4><p>如果更新操作导致文档大小增加，那么可能需要重新设计数据模型，在不同文档之间使用引用的方式而非内嵌、冗余的数据结构。<br>MongoDB会自动调整空白填充的大小以尽可能的减小文档迁移。你也可以使用一个<strong>预分配策略</strong>来防止文档的增长。</p><p><br></p><h4 id="原子性-atomic"><a href="#原子性-atomic" class="headerlink" title="原子性(atomic)"></a>原子性(atomic)</h4><p>在MongoDB中，所有在文档级别的操作都具有原子性。一个单个写操作最多只可以修改一个文档。即使是一个会改变同一个集合中多个文档的命令，在同一时间也只会操作一个文档。即便是涉及多个子文档的多个操作，只要是在同一文档之内，这些操作仍旧是有原子性的。</p><p>尽可能保证那些需要在一个原子操作内进行修改的字段定义在同一个文档里面。如果你的应用程序允许对两个数据的非原子性更新操作，那么可把这些数据定义在不同的文档内。</p><p>把相关数据定义到同一个文档里的内嵌方式有利于这种原子性操作。对于那些使用引用来关联相关数据的数据模型，应用程序必须再用额外的读和写操作去取回和修改相关的数据。</p><p><br></p><h4 id="分片-sharding"><a href="#分片-sharding" class="headerlink" title="分片(sharding)"></a>分片(sharding)</h4><p>MongoDB使用分片来实现水平扩展。使用分片的集群可以支持海量的数据和高并发读写。使用分片技术把一个数据库内的某一个集合的数据进行分区，从而达到把数据分到多个mongod实例(或分片上)的目的。</p><p>MongoDB依据<strong>分片键</strong>分发数据和应用程序的事务请求。选择一个合适的分片键对性能有很大的影响，也会促进或阻碍MongoDB的定向分片查询和增强的写性能。所以在选择分片键的时候要仔细考量分片键所用的字段。</p><p><br></p><h4 id="索引-index"><a href="#索引-index" class="headerlink" title="索引(index)"></a>索引(index)</h4><p>对常用操作可以使用索引来提高性能。对查询条件中常见的字段，以及需要排序的字段创建索引。<br>MongoDB会对<code>_id</code>自动创建唯一索引。</p><p>创建索引时，需要考虑索引的下述特征：</p><ul><li>每个索引要求至少8KB的数据空间；</li><li>每增加一个索引，就会对写操作性能有一些影响。对于一个写多读少的集合，索引会变得很费时。因为每个插入必须要更新所有索引；</li><li>每个索引都会占一定的硬盘空间和内存(对于活跃的索引)。索引可能会用到很多这样的资源，因此对这些资源要进行管理和规划，特别是在计算热点数据大小的时候。</li></ul><p><br></p><h4 id="集合的数量"><a href="#集合的数量" class="headerlink" title="集合的数量"></a>集合的数量</h4><p>某些情况下，可能需要把相关的数据保存到多个集合里面。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; log: &quot;dev&quot;, ts:..., info: ... &#125;</div><div class="line">&#123; log: &quot;debug&quot;, ts:..., info: ... &#125;</div></pre></td></tr></table></figure><p>一般来说，很大的集合数量对性能没有什么影响，反而在某些场景下有不错的性能。使用不同的集合在高并发批处理场景下会有很好的帮助。</p><p>当使用有大量集合的数据模型时，请注意：</p><ul><li>每个集合有几KB的额外开销；</li><li>每个索引(包含<code>_id</code>)，需要至少8KB的数据空间；</li><li>每个MongoDB的数据库有且仅有一个命名文件(namespace file)(<db>.ns)。这个命名文件保存了数据库的所有元数据，每个索引和集合在这个文件里都有一条记录；</db></li><li>MongoDB的命名文件有大小的限制(默认16MB)。利用<code>db.system.namespaces.count()</code>查看。</li></ul><p><br></p><h4 id="包含大量小文档的集合"><a href="#包含大量小文档的集合" class="headerlink" title="包含大量小文档的集合"></a>包含大量小文档的集合</h4><p>如果你有一个包含大量小文档的集合，则应该考虑为了性能而嵌入。如果你可以通过一些逻辑关系将这些小文档分组，并且你经常通过这个分组来检索文档，那么你应该考虑将小文档”卷起来”成为包含一系列嵌入式文档的大文档。</p><p>将这些小文档“卷起来”成为逻辑分组，意味着检索一组文档的查询设计顺序读取和较少的随机磁盘访问。此外，将文档“卷起”并将公共字段移动到较大的文档会使字段上的索引受益。公共字段的副本将会减少，并且相应索引中的关联键条目也会减少。</p><p>然而，如果你通常只需要检索分组中的一个文档的子集，那么“滚动”文档可能无法提供更好的性能。此外，如果晓得，独立的文档代表数据的自然模型，那你应该维护改模型。</p><p><br></p><h4 id="小文档的存储优化-storage-optimization"><a href="#小文档的存储优化-storage-optimization" class="headerlink" title="小文档的存储优化(storage optimization)"></a>小文档的存储优化(storage optimization)</h4><p>每个MongoDB文档都包含一定的开销(overhead)，这些开销通常是无关紧要的。但如果文档只有几个字节，那就相当重要了。</p><p>考虑以下有关优化这些集合的存储利用率的建议：</p><ul><li>显示地使用<code>_id</code>字段；</li><li>使用较短的字段名称；</li><li>嵌套文档。</li></ul><p><br></p><h4 id="数据生命周期管理"><a href="#数据生命周期管理" class="headerlink" title="数据生命周期管理"></a>数据生命周期管理</h4><p>数据模型决策应考虑数据生命周期管理。</p><p>集合的<em>*TTL功能</em>在一段时间后标识文档到期。如果应用程序需要一些数据才能在数据库中持久化一段有限的时间，请考虑使用TTL特性。</p><p>此外，你的应用程序仅使用最近插入的文档，请考虑限制集。</p><p><br><br><br></p><h2 id="数据模型例子与范式"><a href="#数据模型例子与范式" class="headerlink" title="数据模型例子与范式"></a>数据模型例子与范式</h2><h3 id="文档关系建模"><a href="#文档关系建模" class="headerlink" title="文档关系建模"></a>文档关系建模</h3><h4 id="一对一关系建模：内嵌文档模型"><a href="#一对一关系建模：内嵌文档模型" class="headerlink" title="一对一关系建模：内嵌文档模型"></a>一对一关系建模：内嵌文档模型</h4><p>用内嵌文档方式实现一对一关系。</p><h4 id="一对多关系建模：内嵌文档模型"><a href="#一对多关系建模：内嵌文档模型" class="headerlink" title="一对多关系建模：内嵌文档模型"></a>一对多关系建模：内嵌文档模型</h4><p>用内嵌文档方式实现一对多关系。</p><h4 id="一对多关系建模：文档引用模式"><a href="#一对多关系建模：文档引用模式" class="headerlink" title="一对多关系建模：文档引用模式"></a>一对多关系建模：文档引用模式</h4><p>用文档引用实现一对多关系。</p><p><br></p><h3 id="树结构建模"><a href="#树结构建模" class="headerlink" title="树结构建模"></a>树结构建模</h3><h4 id="父文档引用"><a href="#父文档引用" class="headerlink" title="父文档引用"></a>父文档引用</h4><p>父文档引用模式用一个文档来表示树的一个节点。每一个文档除了存储节点的信息，同时也保存该节点父节点文档的id值。</p><p><img src="/images/MongoDB/data-model-tree.png" alt="data-model-tree"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, parent: <span class="string">"Databases"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, parent: <span class="string">"Programming"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Programming"</span>, parent: <span class="string">"Books"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Books"</span>, parent: null &#125;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查询父节点</span></div><div class="line">db.test.findOne(&#123; _id: <span class="string">"MongoDB"</span> &#125;).parent</div><div class="line"></div><div class="line"><span class="comment">#对parent字段创建索引，这样可以快速的按照父节点查找</span></div><div class="line">db.test.createIndex(&#123; parent: 1 &#125;)</div><div class="line"></div><div class="line"><span class="comment">#查询一个父节点的所有子节点</span></div><div class="line">db.test.find(&#123; parent: <span class="string">"Databases"</span> &#125;)</div></pre></td></tr></table></figure><p><br></p><h4 id="子文档引用"><a href="#子文档引用" class="headerlink" title="子文档引用"></a>子文档引用</h4><p>子文档引用模式用一个文档来表示树的一个节点。每一个文档除了存储节点信息外，同时也用一个数组来保存该节点的所有子节点的id值。</p><p><img src="/images/MongoDB/data-model-tree.png" alt="data-model-tree"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, children: [] &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, children: [ <span class="string">"MongoDB"</span>, <span class="string">"dbm"</span> ]&#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Programming"</span>, children: [ <span class="string">"Languages"</span>, <span class="string">"Databases"</span> ]&#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Books"</span>, children: [ <span class="string">"Programming"</span> ]&#125;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查询子节点</span></div><div class="line">db.test.findOne(&#123; _id: <span class="string">"Databases"</span>&#125;).children</div><div class="line"></div><div class="line"><span class="comment">#对children字段创建索引，这样就可以快速按照子节点查找</span></div><div class="line">db.test.createIndex(&#123; children: 1 &#125;)</div><div class="line"></div><div class="line"><span class="comment">#查找一个子节点的父节点和同级节点</span></div><div class="line">db.test.find(&#123; children: <span class="string">"MongoDB"</span> &#125;)</div></pre></td></tr></table></figure><p><br></p><h4 id="祖先数组-ancestors-array"><a href="#祖先数组-ancestors-array" class="headerlink" title="祖先数组(ancestors array)"></a>祖先数组(ancestors array)</h4><p>祖先数组模式用一个文档来表示树的一个节点。每一个文档除了存储节点的信息，同时也存储了对父文档及祖先文档的id值。</p><p><img src="/images/MongoDB/data-model-tree.png" alt="data-model-tree"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, ancestors: [ <span class="string">"Books"</span>, <span class="string">"Programming"</span>, <span class="string">"Databases"</span> ], parent: <span class="string">"Databases"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, ancestors: [ <span class="string">"Books"</span>, Programming<span class="string">" ], parent: [ "</span>MongoDB<span class="string">", "</span>dbm<span class="string">" ]&#125;)</span></div><div class="line"><span class="string">db.test.insert(&#123; _id: "</span>Programming<span class="string">", ancestors: [ "</span>Books<span class="string">" ], parent: "</span>Books<span class="string">" &#125;)</span></div><div class="line"><span class="string">db.test.insert(&#123; _id: "</span>Books<span class="string">", ancestors: [ ], parent: null &#125;)</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#查询一个节点的祖先节点</span></div><div class="line"><span class="string">db.test.findOne(&#123; _id: "</span>MongoDB<span class="string">" &#125;).ancestors</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#对ancestors创建索引</span></div><div class="line"><span class="string">db.test.createIndex(&#123; ancestors: 1 &#125;)</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#利用ancestors字段来查找某个节点的所有子代节点</span></div><div class="line"><span class="string">db.test.find(&#123; ancetors: "</span>Programmming<span class="string">" &#125;)</span></div></pre></td></tr></table></figure><p><br></p><h4 id="物化路径-materialized-path"><a href="#物化路径-materialized-path" class="headerlink" title="物化路径(materialized path)"></a>物化路径(materialized path)</h4><p>物化路径模式将每个树节点存储在文档中。除了存储节点信息外，同时也存储了祖先文档或路径的id值。</p><p><img src="/images/MongoDB/data-model-tree.png" alt="data-model-tree"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"Books"</span>, path: null &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Programming"</span>, path: <span class="string">",Books,"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, path: <span class="string">",Books,Programming,"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, path: <span class="string">",Books,Programming,Databases,"</span> &#125;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查询整个树的所有节点并按path排序</span></div><div class="line">db.test.find().sort(&#123; path: 1 &#125;)</div><div class="line"></div><div class="line"><span class="comment">#可以在path字段上使用re来查询</span></div><div class="line">db.test.find(&#123; path: /,Programming,/ &#125;)</div><div class="line">db.test.find(&#123; path: /^,Books,/ &#125;)</div><div class="line"></div><div class="line"><span class="comment">#在path字段上创建索引</span></div><div class="line">db.test.createIndex(&#123; path: 1 &#125;)</div></pre></td></tr></table></figure><p><br></p><h4 id="嵌套集合-nested-set"><a href="#嵌套集合-nested-set" class="headerlink" title="嵌套集合(nested set)"></a>嵌套集合(nested set)</h4><p>嵌套集合模式对整个树结构进行一次深度优先的遍历。遍历时候对每个节点的压栈和出栈作为两个不同的步骤记录下来。每一个节点就是一个文档，除了节点信息外，文档还保存父节点的id以及遍历的两个步骤编号。压栈是的步骤保存到<strong>left字段</strong>里，而出栈时的步骤编号则保存到<strong>right字段</strong>里。</p><p><img src="/images/MongoDB/data-model-example-nested-set.png" alt="data-model-example-nested-set"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"Books"</span>, parent: 0, left: 1, right: 12 &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Programming"</span>, parent: <span class="string">"Books"</span>, left: 2, right: 11 &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, parent: <span class="string">"Programming"</span>, left: 5, right: 10 &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, parent: <span class="string">"Databases"</span>, left: 6, right: 7 &#125;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查询摸个节点的子代节点</span></div><div class="line">db.test.find(&#123; left: &#123; <span class="variable">$gt</span>: db.test.findOne(&#123; _id: <span class="string">"Databases"</span> &#125;), right: &#123; <span class="variable">$lt</span>: db.test.findOne(&#123;<span class="string">"_id: "</span>Databases<span class="string">"&#125;) &#125; &#125;)</span></div></pre></td></tr></table></figure><p><br></p><h3 id="具体应用模型举例"><a href="#具体应用模型举例" class="headerlink" title="具体应用模型举例"></a>具体应用模型举例</h3><h4 id="原子性事务建模"><a href="#原子性事务建模" class="headerlink" title="原子性事务建模"></a>原子性事务建模</h4><p>如何使用内嵌技术来保证同一文档内相关字段更新操作的原子性。</p><p>举例来说，假设你在设计一个图书馆的借书系统，你需要管理书的库存量以及出借记录。一本书的可借数量加上借出数量的和必须等于总的保有量，那么对这两个字段的更新必须是原子性的。</p><p><br></p><h4 id="关键词搜索建模"><a href="#关键词搜索建模" class="headerlink" title="关键词搜索建模"></a>关键词搜索建模</h4><p>描述了一种把关键词保存在数组里并使用多键索引来实现关键词搜索功能的方法。</p><p>为实现关键词搜索，在文档内增加一个数组字段并把每一个关键词加到数组里。然后你可以对该字段建一个 多键索引。这样你就可以对数组里面的关键词进行查询了。</p><p><br></p><h4 id="货币数据建模"><a href="#货币数据建模" class="headerlink" title="货币数据建模"></a>货币数据建模</h4><p>处理货币数据的应用程序通常需要捕获小数(franctional)货币单位，并在执行算术时需要精确地模拟十进制四舍五入。许多现代系统(float,double)使用的基于二级制的浮点运算不能精确地表示小数，而且需要某种程度的近似，因而不适合于货币运算。因此，在货币数据建模时，这一约束是一个重要的考虑因素。</p><ul><li><p>数字模型<br>如果需要查询数据库中精确、数学书有效匹配或需要执行Server端算术，则数字模型可能是适合的。</p></li><li><p>非数字模型<br>如果需要在Server端做一些对货币数值的数学计算，那么严格精度可能会更合适一些。</p></li></ul><p><br></p><h4 id="时间数据模型"><a href="#时间数据模型" class="headerlink" title="时间数据模型"></a>时间数据模型</h4><p>MongoDB默认存储UTC时间，并将任何本地时间转换成这种形式。</p><p><br></p><hr><p><br></p><h1 id="MongoDB管理"><a href="#MongoDB管理" class="headerlink" title="MongoDB管理"></a>MongoDB管理</h1><p>administration</p><p><br></p><p>The administration 文档说明了MongoDB实例和部署正在进行的操作和维护。本文档包括这些问题的高级概述，以及涵盖操作MongoDB的特定过程的教程。</p><p><br><br><br></p><h2 id="操作清单-operation-checklist"><a href="#操作清单-operation-checklist" class="headerlink" title="操作清单(operation checklist)"></a>操作清单(operation checklist)</h2><p>如下清单，提供了帮助你避免在MongoDB部署中出现问题的建议。</p><p><br></p><h3 id="文件系统-file-system"><a href="#文件系统-file-system" class="headerlink" title="文件系统(file system)"></a>文件系统(file system)</h3><ul><li>将磁盘分区与RAID配置对齐；</li><li>避免对<code>dbpath</code>使用NFS。使用NFS会导致性能下降和不稳定；</li><li>针对Linux/Unix的文件格式，建议使用XFS或EXT4。如果可能的话，对MongoDB使用XFS性能会更好；</li><li>对于WiredTiger存储引擎，强烈建议使用XFS来避免使用EXT4时发现的性能问题；</li><li>针对Windows，不要使用FAT(FAT16/32/exFAT)文件系统，请使用NTFS文件系统。</li></ul><p><br></p><h3 id="复制-replication"><a href="#复制-replication" class="headerlink" title="复制(replication)"></a>复制(replication)</h3><ul><li>验证所有非隐藏副本集成员的RAM, CPU, 磁盘, 网络设置, 配置等方面是否相同；</li><li>配置<code>oplog</code>的大小来适合你的用例；</li><li>确保副本集包好至少3个以journaling方式运行的数据承载节点；</li><li>在配置副本集成员时使用主机名(hostname)，而不是IP地址；</li><li>确保所有的mongod实例之间使用全双工网络；</li><li>确保每台主机都能解析它自己；</li><li>确保副本集包含奇数个投票的成员(voting members)，确保票数不会相等则一定会有主被选举出来；</li><li>确保mongod实例有0或1票；</li><li>为了高可用(high availability)，副本集集群最少部署3台数据中心。</li></ul><p><br></p><h3 id="分片-sharding-1"><a href="#分片-sharding-1" class="headerlink" title="分片(sharding)"></a>分片(sharding)</h3><ul><li>将配置服务器放置于专用硬件，以便在大型集群中实现最佳性能。确保硬件有足够的RAM来讲数据文件完全存储到内存中，并且有专门的存储；</li><li>使用NTP同步分片集群上所有组件的时钟；</li><li>确保Mongod, mongos和配置服务器之间的全双工网络连接；</li><li>使用CNAME将配置服务器标识到集群中，以便可以在不停机的情况下重命名和重新编号配置服务器。</li></ul><p><br></p><h3 id="Journaling"><a href="#Journaling" class="headerlink" title="Journaling"></a>Journaling</h3><ul><li>确保所有实例都使用journaling；</li><li>将journal放置于低延迟(low-latency)磁盘上，用于编写密集的工作负载。注意，这将影响快照式备份(snapshot)，因为构成数据库状态的文件将驻留在单独的volume上。</li></ul><p><br></p><h3 id="硬件-hardware"><a href="#硬件-hardware" class="headerlink" title="硬件(hardware)"></a>硬件(hardware)</h3><ul><li>使用RAID10和SSD能够获得最佳性能；</li><li>确保每个mongod为它的dbpath提供了IOPS；</li><li>在虚拟环境中运行时，避免动态内存功能；</li><li>避免将所有副本集成员放置于相同的SAN(存储区网络)中。</li></ul><p><br></p><h3 id="部署到云上"><a href="#部署到云上" class="headerlink" title="部署到云上"></a>部署到云上</h3><ul><li>AWS;</li><li>Azure;</li><li>Aliyun;</li><li>Tencent.</li></ul><p><br></p><h3 id="操作系统配置"><a href="#操作系统配置" class="headerlink" title="操作系统配置"></a>操作系统配置</h3><p><strong>Linux</strong></p><ul><li>关闭<code>hugepages</code>和<code>defrag</code>；</li><li>调整存储数据库文件设备上的readahead设置，以适应用例；</li><li>在虚拟环境中的RHEL7/CENTOS7上禁用优化工具；</li><li>为SSD驱动使用<code>noop</code>或<code>deadline</code>磁盘调度；</li><li>禁用<code>NUMA</code>或将<code>vm.zone_reclaim_mode</code>设置为0，并运行<code>node interleaving</code>的mongod实例；</li><li>调整硬件的<code>ulimit</code>值以适应实例；</li><li>对dbpath挂载点使用<code>noatime</code>；</li><li>对你的部署配置足够的文件句柄(fs.file-max value of 98000)，内核pid限制(kernel.pid_max value of 64000)，每个进程的最大线程数(kernel.threads-max value 0f 64000)；</li><li>确保你的系统配置有swap交换分区；</li><li>确保系统默认TCP keepalived设置正确。</li></ul><p><strong>Windows</strong></p><ul><li>考虑禁用NTFS的最后访问时间更新。这类似与在Unix-like系统上禁用atime。</li></ul><p><br></p><h3 id="备份-backup"><a href="#备份-backup" class="headerlink" title="备份(backup)"></a>备份(backup)</h3><ul><li>安排备份和恢复过程的定期测试，以便手头有时间估计，并恢复其功能。</li></ul><p><br></p><h3 id="监控-monitor"><a href="#监控-monitor" class="headerlink" title="监控(monitor)"></a>监控(monitor)</h3><ul><li>监视Server的硬件统计信息(磁盘使用，CPU，可用磁盘空间…)</li><li>监视mongodb的状态。</li></ul><p><br></p><h3 id="负载均衡-load-balance"><a href="#负载均衡-load-balance" class="headerlink" title="负载均衡(load balance)"></a>负载均衡(load balance)</h3><ul><li>配置负载均衡启用”sticky session”或“client affinity”，对现有连接有足够的超时时间；</li><li>避免放置负载均衡器在MongoDb集群或副本集组件。</li></ul><p><br><br><br></p><h2 id="开发清单-development-checklist"><a href="#开发清单-development-checklist" class="headerlink" title="开发清单(development checklist)"></a>开发清单(development checklist)</h2><p>如下清单，提供了帮助你避免在MongoDB部署期间出现的问题的建议。</p><p><br></p><h3 id="数据持久性-data-durability"><a href="#数据持久性-data-durability" class="headerlink" title="数据持久性(data durability)"></a>数据持久性(data durability)</h3><ul><li>确保副本集至少包含3个(带有w:majority)数据承载节点，这3个数据承载节点需要为副本集的高数据持久性；</li><li>确保所有实例都是用了journaling。</li></ul><p><br></p><h3 id="架构设计-schema-design"><a href="#架构设计-schema-design" class="headerlink" title="架构设计(schema design)"></a>架构设计(schema design)</h3><p>MongoDB中的数据具有动态结构。collection并不要求document结构。这有助于迭代开发和多态性。然而，集合中的文档通常具有高度的同类结构。</p><ul><li>确保你需要的集合集中的索引(indexes)支持你的查询(query)。除了<code>_id</code>索引，你必须显式的创建所有索引；</li><li>确保你的架构设计支持你的开发类型；</li><li>确保你的架构设计不依赖于长度不受绑定的索引数组；</li><li>再架构设计时考虑文档大小限制。</li></ul><p><br></p><h3 id="复制-replication-1"><a href="#复制-replication-1" class="headerlink" title="复制(replication)"></a>复制(replication)</h3><ul><li>使用奇数个副本集成员以确保选举顺利进行。如果有偶数个成员，请使用仲裁者(arbiter)以确保级数的选票；</li><li>确保使用监控工具和适当的写关注来保持从库数据最新；</li><li>不要使用从库读取来扩展整体读取吞吐量。</li></ul><p><br></p><h3 id="分片-sharding-2"><a href="#分片-sharding-2" class="headerlink" title="分片(sharding)"></a>分片(sharding)</h3><ul><li>确保你的<code>sharded key</code>将负载均匀地分配到分片上；</li><li>对需要按分片数进行缩放的工作负载(workload)使用有针对性的操作；</li><li>对非目标(non-targeted)查询，总是从主节点读取可能对陈旧或孤立的数据很敏感；</li><li>当向新的非散列(hash)分片集合中插入大数据集时，Pre-split and manually balance chunks。</li></ul><p><br></p><h3 id="驱动-drivers"><a href="#驱动-drivers" class="headerlink" title="驱动(drivers)"></a>驱动(drivers)</h3><ul><li>使用连接池(connection pooling)；</li><li>确保你的应用程序在复制集选举期间还能够处理瞬时写入(transient write)和错误读取；</li><li>确保你的应用程序处理失败的请求并适时地重试它们；</li><li>使用指数退避逻辑重试数据库请求；</li><li>如果需要计算数据库操作的编译执行时间，对读操作使用<code>cursor.maxTimeMS()</code>，对写操作使用<code>wtimeout</code>。</li></ul><p><br><br><br></p><h2 id="性能-MongoDB-Perfomance"><a href="#性能-MongoDB-Perfomance" class="headerlink" title="性能(MongoDB Perfomance)"></a>性能(MongoDB Perfomance)</h2><ul><li>当遇到性能下降时，通常与数据库的访问策略、硬件可用性和开放的数据库连接数相关；</li><li>一些用户可能由于不适当的索引策略或结果不足而经历性能限制，或由于架构设计模式差；</li><li>性能问题可能表明数据库正以最大限度运行，是时候给数据库添加额外的容量(capacity)了。尤其是，应用程序的工作集应该有足够的物理内存。</li></ul><p><br></p><h3 id="锁紧性能-lock-performance"><a href="#锁紧性能-lock-performance" class="headerlink" title="锁紧性能(lock performance)"></a>锁紧性能(lock performance)</h3><ul><li>MongoDB使用锁系统来确保数据集的一致性。如果某些操作需要长时间运行(long-running)，或队列窗体，随着请求和操作等待<code>lock</code>，性能将会下降；</li><li>锁相关的减速是可以间歇的，可查看<code>lock</code>部分是否影响了性能；</li><li><code>locak.deadlockCount</code>提供了遭遇死锁(deadlocks)的次数；</li><li>如果<code>globalLock.currentQueue.total</code>很高，则可能有大量的请求在等待<code>lock</code>。这表明并发问题(concurrency issue)可能影响性能；</li><li>如果<code>globalLock.totalTime</code>时间比<code>uptime</code>高，那么数据库在锁定状态中存在了大量时间；</li><li>长查询(long query)可能会导致索引无效使用、非最佳(non-optimal)建构设计、差的查询结构、系统体系结构问题、RAM不足导致页面错误(page fault)和磁盘读取。</li></ul><p><br></p><h3 id="连接数-number-of-connections"><a href="#连接数-number-of-connections" class="headerlink" title="连接数(number of connections)"></a>连接数(number of connections)</h3><p>在某些情况下，应用程序和数据库之间的连接数量可能超出服务器处理请求的能力。<code>serverStatus</code>文档中的以下字段可以提供观察：</p><ul><li><code>globalLock.activeClients</code>包含正在进行或排队的活动操作的客户端总数；</li><li><code>connnections</code>由以下两个字段组成： 1，<code>connections.current</code>连接到数据库实例的当前客户端总数； 2，<code>connections.available</code>可用的连接总数。</li></ul><p>如果有大量的并发程序请求，则数据库可能无法满足需求。那么就需要增加部署的容量。</p><p>对于读操作巨大(read-heavy)的应用程序，增加你的副本集大小并将读操作分发给SECONDARY。<br>对于写操作巨大(write-heavy)的应用程序，部署分片并将一个或多个分片添加到分片集群中，以便在mongod实例之间分配负载。</p><p>连接数到达峰值也可能是应用程序或驱动错误所导致的结果。</p><p>除非收到系统范围的限制，否则MongoDB对传入连接没有限制。在基于Unix系统上，可使用<code>ulimit</code>命令或修改<code>/etc/sysctl</code>系统文件来修改系统限制。</p><p><br></p><h3 id="数据库性能分析-database-profiling"><a href="#数据库性能分析-database-profiling" class="headerlink" title="数据库性能分析(database profiling)"></a>数据库性能分析(database profiling)</h3><p>MongoDB的<strong>profiler</strong>是一种数据库分析系统，可以帮助识别低效的查询和操作。</p><p>有如下分析级别(profiling-level)可用：</p><table><thead><tr><th>Level</th><th>Settiing</th></tr></thead><tbody><tr><td>0</td><td>Off.No profiling</td></tr><tr><td>1</td><td>On.Only includes “slow” operations</td></tr><tr><td>2</td><td>On.Includes all operations</td></tr></tbody></table><p>在mongo shell中运行如下命令来配置性能分析器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#dbsetProfilingLever()</span></div><div class="line"></div><div class="line">db.setProfilingLevel(1)</div></pre></td></tr></table></figure><p><code>slowOpThresholdMs</code>的设置定义了什么是一个<code>slow</code>操作，要设置一个慢操作的阈值(threshold)，可以在运行时作为<code>db.setProfilingLevel()</code>操作的一个参数来配置<code>slowOpThresholdMs</code>。</p><p>默认情况下，mongod将会把所有的慢查询(slow query)记录到日志，这是由<code>slowOpThresholdMs</code>定义的。</p><p>通过在mongo shell中使用<code>show profile</code>，你可以在数据库中的<code>system.profile</code>集合中查看性能分析器的输出。<br>或者执行如下操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#返回超过100ms的所有操作，这个值请高于阈值`slowOpThresholdMs`</span></div><div class="line"></div><div class="line">db.system.profile.find(</div><div class="line">&#123; millis: &#123; <span class="variable">$gt</span>: 100 &#125; &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p>你必须使用查询操作符去访问<code>system.profile</code>文档中的查询字段。</p><p><br></p><h3 id="数据库性能分析器-databases-profiler"><a href="#数据库性能分析器-databases-profiler" class="headerlink" title="数据库性能分析器(databases profiler)"></a>数据库性能分析器(databases profiler)</h3><p>数据库性能分析器(db profiler)收集有关MongoDB的<strong>写操作、游标和运行在mongod实例上的命令</strong>的细微数据，你可以在每个数据库或每个实例基础上启用性能分析(profiling)。默认情况系，分析器是关闭的。启用profiling的时候需要配置<code>profiling leverl</code>。</p><p>The <code>database profiler</code>将所有的数据收集到<code>system.profile</code>集合中，它是一个限制集(capped collection)。</p><p><br></p><h4 id="分析等级-Profiling-levels"><a href="#分析等级-Profiling-levels" class="headerlink" title="分析等级(Profiling levels)"></a>分析等级(Profiling levels)</h4><ul><li>0， 关闭分析器，不收集任何数据。<code>mongod</code>总是将操作时间长于<code>slowOpThresholdMs</code>的值写入日志。这是默认分析器级别；</li><li>1， 只收集慢操作的分析数据。默认是以100ms；</li><li>2， 收集所有数据库操作的分析数据。</li></ul><p><br></p><h4 id="启用分析器-profiling-和设置分析级别-profiling-level"><a href="#启用分析器-profiling-和设置分析级别-profiling-level" class="headerlink" title="启用分析器(profiling)和设置分析级别(profiling level)"></a>启用分析器(profiling)和设置分析级别(profiling level)</h4><p>当启用<code>profiling</code>，也要设置<code>profiling level</code>，分析器将数据记录到<code>system.profile</code>集合。当你在数据库中启用profiling后，MongoDB会在数据库中创建<code>system.profile</code>集合。</p><p>使用<code>db.setProfilingLevel()</code>来设置<code>profiling level</code>和启用profiling。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.setProfilingLevel(1)</div></pre></td></tr></table></figure><p><br></p><p><strong>指定慢操作的阈值(the Threshold for slow operations)</strong></p><p>慢操作的阈值(threshold)应用于整个mongod实例。当你修改了阈值，那你就对所有的数据库实例进行了修改。修改了数据库慢操作的阈值同样也会影响整个mongod实例性能分析子系统的慢操作阈值。<br>默认情况下，慢操作的阈值为100ms。性能分析<code>level-1</code>将会记录长于阈值的慢操作到日志。</p><p>要更改阈值，请将两个参数(parameter)在<code>mongo shell</code>传递给<code>db.setProfilingLevel()</code>。第一个参数是为当前的数据库设置<code>profiling level</code>，第二个参数是为整个mongod实例设置默认的慢操作阈值。</p><p>栗子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mongo</div><div class="line"></div><div class="line">&gt;use zhang</div><div class="line">&gt;db.serProfilingLevel(1,100)</div><div class="line"></div><div class="line"><span class="comment">#会在zhang数据库下生产system.profile集合</span></div></pre></td></tr></table></figure><p><br></p><p><strong>检查分析等级(check profiling level)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.getProfilingStatus()</div><div class="line">#default</div><div class="line">#&#123; &quot;was&quot; : 0, &quot;slowms&quot; : 100 &#125;</div><div class="line"></div><div class="line"></div><div class="line">db.getProfilingLevel()</div><div class="line">#0</div></pre></td></tr></table></figure><p><br></p><p><strong>为一个完整的mongod实例启用profiling</strong></p><p>在测试环境中，处于开发目的，你可以为一个完整的mongod实例启用profiling功能。性能分析等级应用于mongod实例中的所有数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#设置level：1，slowOpThresholdMs: 50</div><div class="line">mongod --profile 1 --slowms 50</div></pre></td></tr></table></figure><p><br></p><p><strong>数据库分析和分片</strong></p><p>无法对mongos实例启用profiling。要对分片集群启用profiling功能，你必须对分片集群中的每个mongod实例启用profiling功能才行。</p><p><br></p><h4 id="查看性能分析器的数据-profiler-data"><a href="#查看性能分析器的数据-profiler-data" class="headerlink" title="查看性能分析器的数据(profiler data)"></a>查看性能分析器的数据(profiler data)</h4><p>数据库性能分析器关于数据库操作的日志信息放置于<code>system.profile</code>集合中。如需查看性能信息，请查询该集合。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">db.system.profile.find()</div><div class="line"></div><div class="line">db.system.profile.find().limit(10).sort(&#123; ts: -1 &#125;).pretty()</div><div class="line"></div><div class="line">#指定时间</div><div class="line">db.system.profile.find( &#123; millis: &#123; $gt: 5 &#125; &#125; ).pretty()</div><div class="line"></div><div class="line"></div><div class="line">#除了某个命令外</div><div class="line">db.system.profile.find(&#123; op: &#123; $ne: &apos;cmd&apos; &#125; &#125;).pretty</div><div class="line"></div><div class="line">#某个特定集合</div><div class="line">db.system.profile.find( &#123; ns: &apos;db.collection&apos; &#125; ).pretty()</div><div class="line"></div><div class="line"></div><div class="line">#显示最近的事件</div><div class="line">show profile</div></pre></td></tr></table></figure><p><br></p><h4 id="分析器开销-profiler-overhead"><a href="#分析器开销-profiler-overhead" class="headerlink" title="分析器开销(profiler overhead)"></a>分析器开销(profiler overhead)</h4><p>分析器对性能影响很小。<code>system.profile</code>集合是一个默认大小为1MB的限制集。这样大小的集合通常可以存储上千份分析文档，但一些应用程序可能在每次操作中只使用或多或少的分析数据。</p><p><br></p><p><strong>在Primary上面修改<code>system.profile</code>集合的大小</strong></p><ol><li>停止profiling；</li><li>删除(drop)<code>system.profile</code>集合；</li><li>新建一个<code>system.profile</code>集合；</li><li>重启profiling。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use db</div><div class="line">db.serProfilingLevel(0)</div><div class="line">db.system.profile.drop()</div><div class="line">db.createCollection( &quot;system.profile&quot;, &#123; capped: true, size: 4000000 &#125; )</div><div class="line">db.setProfilingLevel(1)</div></pre></td></tr></table></figure><p><br></p><p><strong>在Secondary上修改<code>system.profile</code>集合的大小</strong></p><p>在Secondary上修改<code>system.profile</code>集合的大小，你必须停止Secondary，然后以standalone模式运行它，之后执行修改步骤。当做完上述步骤之后，以一个副本集成员的方式使用standalone模式重启它。</p><p><br><br><br></p><h3 id="禁用显见的大页面-Disable-Transparent-Huge-Pages"><a href="#禁用显见的大页面-Disable-Transparent-Huge-Pages" class="headerlink" title="禁用显见的大页面(Disable Transparent Huge Pages)"></a>禁用显见的大页面(Disable Transparent Huge Pages)</h3><p>Transpatent Huge Pages(THP)是一个Linux的内存管理系统，通过使用更大的内存页，减少了在具有大量内存的机器上进行Translation Lookaside Buffer(TLB)查找的开销。</p><p>然而，数据库工作负载(workload)在THP中的性能往往很差，因为它们往往具有稀疏的(sparse)而不是连续的(contiguous)内存访问模式。你应该在Linux机器上禁用THP来确保MongoDB获得最佳的性能。</p><p><br></p><p><strong>1. 创建<code>init.d</code>脚本</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment">### BEGIN INIT INFO</span></div><div class="line"><span class="comment"># Provides:          disable-transparent-hugepages</span></div><div class="line"><span class="comment"># Required-Start:    $local_fs</span></div><div class="line"><span class="comment"># Required-Stop:</span></div><div class="line"><span class="comment"># X-Start-Before:    mongod mongodb-mms-automation-agent</span></div><div class="line"><span class="comment"># Default-Start:     2 3 4 5</span></div><div class="line"><span class="comment"># Default-Stop:      0 1 6</span></div><div class="line"><span class="comment"># Short-Description: Disable Linux transparent huge pages</span></div><div class="line"><span class="comment"># Description:       Disable Linux transparent huge pages, to improve</span></div><div class="line"><span class="comment">#                    database performance.</span></div><div class="line"><span class="comment">### END INIT INFO</span></div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></div><div class="line">  start)</div><div class="line">    <span class="keyword">if</span> [ -d /sys/kernel/mm/transparent_hugepage ]; <span class="keyword">then</span></div><div class="line">      thp_path=/sys/kernel/mm/transparent_hugepage</div><div class="line">    <span class="keyword">elif</span> [ -d /sys/kernel/mm/redhat_transparent_hugepage ]; <span class="keyword">then</span></div><div class="line">      thp_path=/sys/kernel/mm/redhat_transparent_hugepage</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="built_in">return</span> 0</div><div class="line">    <span class="keyword">fi</span></div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">'never'</span> &gt; <span class="variable">$&#123;thp_path&#125;</span>/enabled</div><div class="line">    <span class="built_in">echo</span> <span class="string">'never'</span> &gt; <span class="variable">$&#123;thp_path&#125;</span>/defrag</div><div class="line"></div><div class="line">    re=<span class="string">'^[0-1]+$'</span></div><div class="line">    <span class="keyword">if</span> [[ $(cat <span class="variable">$&#123;thp_path&#125;</span>/khugepaged/defrag) =~ <span class="variable">$re</span> ]]</div><div class="line">    <span class="keyword">then</span></div><div class="line">      <span class="comment"># RHEL 7</span></div><div class="line">      <span class="built_in">echo</span> 0  &gt; <span class="variable">$&#123;thp_path&#125;</span>/khugepaged/defrag</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="comment"># RHEL 6</span></div><div class="line">      <span class="built_in">echo</span> <span class="string">'no'</span> &gt; <span class="variable">$&#123;thp_path&#125;</span>/khugepaged/defrag</div><div class="line">    <span class="keyword">fi</span></div><div class="line"></div><div class="line">    <span class="built_in">unset</span> re</div><div class="line">    <span class="built_in">unset</span> thp_path</div><div class="line">    ;;</div><div class="line"><span class="keyword">esac</span></div></pre></td></tr></table></figure><p><strong>2. 使之可执行</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 755 /etc/init.d/<span class="built_in">disable</span>-transparent-hugepages</div></pre></td></tr></table></figure><p><strong>3. 配置操作系统以在开机的时候运行它</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Debian系列</span></div><div class="line">update-rc.d <span class="built_in">disable</span>-transparent-hugepages defaults</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#RedHat系列</span></div><div class="line">chkconfig --add <span class="built_in">disable</span>-transparent-hugepages</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#SUSE</span></div><div class="line">insserv /etc/init.d/<span class="built_in">disable</span>-transparent-hugepages</div></pre></td></tr></table></figure><p><strong>4. 如果适用，覆盖(override)tuned和ktune</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#RedHat/CentOS7</span></div><div class="line">mkdir /etc/tuned/no-thp</div><div class="line"></div><div class="line"></div><div class="line">vim /etc/tuned/no-thp/tuned.conf</div><div class="line"></div><div class="line">[main]</div><div class="line">include=virtual-guest</div><div class="line">[vm]</div><div class="line">transparent_hugepages=never</div><div class="line"></div><div class="line"></div><div class="line">tuned-adm profile no-thp</div></pre></td></tr></table></figure><p><strong>5. 测试你做的改变</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cat /sys/kernel/mm/redhat_transparent_hugepage/enabled</div><div class="line">cat /sys/kernel/mm/redhat_transparent_hugepage/defrag</div><div class="line"></div><div class="line"><span class="comment">#always madvise [never]</span></div></pre></td></tr></table></figure><p><br></p><p><strong>另一种简便的方式来禁用THP</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vim /etc/rc.d/rc.local</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">'never'</span> &gt; /sys/kernel/mm/transparent_hugepage/enabled</div><div class="line"><span class="built_in">echo</span> <span class="string">'never'</span> &gt; /sys/kernel/mm/transparent_hugepage/defrag</div><div class="line"></div><div class="line">chmod u+x /etc/rc.d/rc.local</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Unix系统下的ulimit的设置"><a href="#Unix系统下的ulimit的设置" class="headerlink" title="Unix系统下的ulimit的设置"></a>Unix系统下的<code>ulimit</code>的设置</h3><p>大多Unix-Like系统，都提供了限制每个进程和每个基本用户使用线程，文件和网络连接等系统资源的一些方法。<br><strong>ulimits</strong>防止单个用户使用太多的系统资源。有时，这些限制的默认值太小，这会导致MongoDB操作过程中出现一系列问题。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#限制文件</span></div><div class="line"><span class="comment">#/etc/security/limits.conf</span></div><div class="line"><span class="comment">#/etc/security/limits.d/</span></div></pre></td></tr></table></figure><p><br></p><h4 id="资源利用"><a href="#资源利用" class="headerlink" title="资源利用"></a>资源利用</h4><p>mongod和mongos每次使用线程和文件描述符来跟踪连接和管理内部操作。</p><p>通常情况下，所有的mongod和mongos实例：</p><ul><li>利用每一个文件描述符和线程来跟踪每个即将到来的连接；</li><li>将每个内部线程或pthread作为一个系统进程来跟踪。</li></ul><p><br></p><p><strong>mongod</strong></p><ul><li>mongod实例使用的每个数据文件都有一个文件描述符；</li><li>当<code>storage.journal.enabled</code>为true是，mongod进程实例使用的每个日志文件都有一个文件描述符；</li><li>在复制集中，每个mongod保持一个连接复制集中所有其他集合成员的连接。</li></ul><p><strong>mongos</strong></p><ul><li>mongos实例与每个分片都保持一个连接池，所有mongos可以重用连接，这样因为不用建立新连接，从而能快速的满足请求；</li><li>通过限制连接数，可以防止mongos因在mongod实例上创建太多连接而产生级联效应。</li></ul><p><br></p><h4 id="资源限制的设置"><a href="#资源限制的设置" class="headerlink" title="资源限制的设置"></a>资源限制的设置</h4><p><code>ulimit</code>是指每个user使用各种资源的限制值。因此，无论你的mongod实例是以单个用户多进程执行还是以多mongod进程执行，都可以看到对这些资源的连接。</p><p>ulimits有<strong>hard</strong>和<strong>soft</strong>两个方式。</p><ul><li>hard：是指用户在任何时候都可以活动的进程的最大数量，这是上限。没有任何non-root进程能够增加hard ulimit；</li><li>soft：是对会话或进程实际执行的限制，但任何进程都可以将其增加到hard ulimit的最大值。</li></ul><p>较低的soft limit可能无法创建新线程(thread)，如果连接数太高，则关闭错误连接。因此，将soft和hard的值都设置为推荐值是非常重要的。</p><p>修改<code>ulimit</code>设置之后，要重启程序修改值才会有效。可通过<code>/proc</code>文件系统查看运行进程当前的限制值。</p><p>使用<code>ulimit</code>对系统限制的改变在系统重启后都会恢复到默认值。需要修改其它文件来确保修改一直生效。</p><p><strong>ulimit</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">ulimit</span> -a</div><div class="line"></div><div class="line">core file size          (blocks, -c) 0</div><div class="line">data seg size           (kbytes, -d) unlimited</div><div class="line">scheduling priority             (-e) 0</div><div class="line">file size               (blocks, -f) unlimited</div><div class="line">pending signals                 (-i) 7170</div><div class="line">max locked memory       (kbytes, -l) 64</div><div class="line">max memory size         (kbytes, -m) unlimited</div><div class="line">open files                      (-n) 1024</div><div class="line">pipe size            (512 bytes, -p) 8</div><div class="line">POSIX message queues     (bytes, -q) 819200</div><div class="line">real-time priority              (-r) 0</div><div class="line">stack size              (kbytes, -s) 8192</div><div class="line">cpu time               (seconds, -t) unlimited</div><div class="line">max user processes              (-u) 7170</div><div class="line">virtual memory          (kbytes, -v) unlimited</div><div class="line">file locks                      (-x) unlimited</div></pre></td></tr></table></figure><p><br></p><p><strong>修改ulimit</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-f (文件大小)</span></div><div class="line"><span class="comment">#-t (cpu 时间)</span></div><div class="line"><span class="comment">#-v (虚拟内存)</span></div><div class="line"><span class="comment">#-n (单个进程文件打开数)</span></div><div class="line"><span class="comment">#-m (memory size)</span></div><div class="line"><span class="comment">#-u (可打开的进程/线程)</span></div><div class="line"></div><div class="line"><span class="built_in">ulimit</span> -t unlimited</div><div class="line"><span class="built_in">ulimit</span> -u 64000</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="配置和维护-maintenance"><a href="#配置和维护-maintenance" class="headerlink" title="配置和维护(maintenance)"></a>配置和维护(maintenance)</h2><h3 id="Run-time-databases-configuration"><a href="#Run-time-databases-configuration" class="headerlink" title="Run-time databases configuration"></a>Run-time databases configuration</h3><p>command line和configuration file interfaces为MongoDB管理员提供了控制数据库系统操作的大量选项和设置。</p><p>使用配置文件启动MongoDB实例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mongod --config /etc/mongod.conf</div><div class="line">mongod -f /etc/mongod.conf</div></pre></td></tr></table></figure><p><br></p><h4 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h4><p>mongodb的配置文件从MongoDB3.0以后使用YAML格式。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line"></div><div class="line">processManagement:</div><div class="line">   fork: <span class="literal">true</span></div><div class="line">net:</div><div class="line">   bindIp: 127.0.0.1</div><div class="line">   port: 27017</div><div class="line">storage:</div><div class="line">   dbPath: /var/lib/mongodb</div><div class="line">systemLog:</div><div class="line">   destination: file</div><div class="line">   path: <span class="string">"/var/log/mongodb/mongod.log"</span></div><div class="line">   logAppend: <span class="literal">true</span></div><div class="line">storage:</div><div class="line">   journal:</div><div class="line">      enabled: <span class="literal">true</span></div></pre></td></tr></table></figure><p>对于大多数以standalone模式运行的servers，以上是一个足够的基本配置。<br>Unix-Like操作系统需要以超级用户(root)权限才能运行端口小于1024的程序。</p><p><br></p><h4 id="安全考虑-security-consideration"><a href="#安全考虑-security-consideration" class="headerlink" title="安全考虑(security consideration)"></a>安全考虑(security consideration)</h4><p>下面的配置选项集合对于限制对于mongod实例的访问非常有用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">net:</div><div class="line">   port: 27017</div><div class="line">   bindIp: 127.0.0.1,192.168.1.11</div><div class="line"></div><div class="line">security:</div><div class="line">   authorization: enabled</div></pre></td></tr></table></figure><p><br></p><h4 id="复制集和分片配置-replication-and-sharding-configuration"><a href="#复制集和分片配置-replication-and-sharding-configuration" class="headerlink" title="复制集和分片配置(replication and sharding configuration)"></a>复制集和分片配置(replication and sharding configuration)</h4><p>复制集的配置非常简单，只需要replSetName在集合中的所有成员具有一致的副本集名字。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">replication:</div><div class="line">  replSetName: zhang</div></pre></td></tr></table></figure><p>开启副本集认证：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#利用openssl生成keyFile</span></div><div class="line">openssl rand -base64 256 &gt; /dir/path/mongodb/keyFile</div><div class="line"></div><div class="line"></div><div class="line">security:</div><div class="line">  replSetName: zhang</div><div class="line">  keyFile: /dir/path/mongodb/keyfile</div><div class="line"></div><div class="line"></div><div class="line">chown -R mongod:mongod /dir/path/mongodb</div></pre></td></tr></table></figure><p>设置<code>keyFile</code>启用身份认证，并为复制集成员在相互身份认证时使用的认证文件指定一个密钥文件。密钥文件的内容是任意的，但在复制集中的所有成员和连接到该集合的mongos实例之间必须相同。不然怎么能认证通过呢。<br>秘钥文件的大小必须<strong>小于1KB</strong>，并且只能包含<strong>base64集</strong>中的字符，并且此密钥文件在Unix系统上必须<strong>not have group</strong>或<strong>not have world permissions</strong>。</p><p><br></p><h4 id="分片配置-sharding-configuration"><a href="#分片配置-sharding-configuration" class="headerlink" title="分片配置(sharding configuration)"></a>分片配置(sharding configuration)</h4><p>分片要求配置服务器和分片服务器的Mongod实例具有不同的mongod配置文件。配置服务器存储集群的元数据(metadata)，而分片服务器存储数据(data)。</p><p>在配置文件中给mongod实例配置<strong>配置服务器(config-server)</strong>，给<code>sharding.clusterRole</code>指定配置服务器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#配置config-server</span></div><div class="line"></div><div class="line">net:</div><div class="line">  bindIp: 192.168.1.11</div><div class="line">  port:27001</div><div class="line">replication:</div><div class="line">  replSetName: zhang</div><div class="line">sharding:</div><div class="line">  clusterRole: configserver</div><div class="line"><span class="comment">#configserver必须要是一个部署的副本集</span></div></pre></td></tr></table></figure><p><br></p><h4 id="在同一个系统上运行多个数据库实例-multiple-database-instances"><a href="#在同一个系统上运行多个数据库实例-multiple-database-instances" class="headerlink" title="在同一个系统上运行多个数据库实例(multiple database instances)"></a>在同一个系统上运行多个数据库实例(multiple database instances)</h4><p><strong>在许多情况下，在单个系统(single system)上运行多个数据库实例是不推荐的。</strong></p><p>但可能由于一些部署或者测试的目的，你需要在单个系统上运行多个mongod实例。在这些情况下，请为每一个mongod实例使用一个基本的配置文件，但要额外配置如下值：</p><ul><li>dbpath(必须);</li><li>pidFilePath(必须);</li><li>systemLog(非必须，但建议开启);</li></ul><p>栗子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#mongod_27017实例</span></div><div class="line">vim /etc/mongod_27017.conf</div><div class="line"></div><div class="line">systemLog:</div><div class="line">  path: /var/<span class="built_in">log</span>/mongod_27017.log</div><div class="line">storage:</div><div class="line">  dbPath: /var/lib/mongodb27017</div><div class="line">processManagement:</div><div class="line">  pidFilePath: /var/lib/mongodb27017/mongod_27017.pid</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#mongod_27018实例</span></div><div class="line">vim /etc/mongod_27018.conf</div><div class="line"></div><div class="line">systemLog:</div><div class="line">  path: /var/<span class="built_in">log</span>/mongod_27018.log</div><div class="line">storage:</div><div class="line">  dbPath: /var/lib/mongodb27018</div><div class="line">processManagement:</div><div class="line">  pidFilePath: /var/lib/mongodb27018/mongod_27018.pid</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##启动实例</span></div><div class="line">mongod -f /etc/mongod_27017.conf</div><div class="line">mongod -f /etc/mongod_27018.conf</div></pre></td></tr></table></figure><p><br></p><h4 id="诊断配置-diagnostic-configuration"><a href="#诊断配置-diagnostic-configuration" class="headerlink" title="诊断配置(diagnostic configuration)"></a>诊断配置(diagnostic configuration)</h4><p>以下配置选项可控制各种mongod行为，用以诊断的目的：</p><ul><li><code>operationProfiling.mode</code>设置<code>database profiler level</code>。profiler在默认情况下不处于活动状态，因为它本身可能会影响性能。除非启用它，否则不会对查询进行分析；</li><li><code>operationProfiling.slowOpThresholdMs</code>配置慢操作的阈值以确定查询是否<strong>慢</strong>，用以作为分析器记录日志的目的。默认阈值是100ms；</li><li><code>systemLog.verbosity</code>控制mongod写入日志的日志输出量。只有在遇到未在正常日志记录级别中反映的问题是才启用此选项。</li></ul><p><br><br><br></p><h3 id="升级-upgrade-到最新的MongoDB"><a href="#升级-upgrade-到最新的MongoDB" class="headerlink" title="升级(upgrade)到最新的MongoDB"></a>升级(upgrade)到最新的MongoDB</h3><p>修订(revisions)提供了security patches、bug fixes以及不包含任何反向破坏更改的新的或更改的功能。但是，最新版本也可能存在一些兼容性问题，请注意。</p><p><br></p><h4 id="升级之前-before-upgrading"><a href="#升级之前-before-upgrading" class="headerlink" title="升级之前(before upgrading)"></a>升级之前(before upgrading)</h4><ul><li>确保备份了最新的数据集；</li><li>有关特定MongoDb版本的特殊事项和兼容性问题，请注意查看；</li><li>如果你的安装包包括了复制集，在升级期间预定维护窗口(maintanence window)。</li></ul><p><br></p><h4 id="升级程序-upgrade-procedure"><a href="#升级程序-upgrade-procedure" class="headerlink" title="升级程序(upgrade procedure)"></a>升级程序(upgrade procedure)</h4><p><strong>在升级之前请一定要备份所有数据！</strong></p><p>按照如下步骤升级：</p><ol><li>对于使用认证的部署，首先升级所有的MongoDB drivers；</li><li>升级分片集群；</li><li>升级任一standalone实例；</li><li>升级不属于分片集群的任一副本集。</li></ol><p><br></p><h4 id="升级一个MongoDB实例"><a href="#升级一个MongoDB实例" class="headerlink" title="升级一个MongoDB实例"></a>升级一个MongoDB实例</h4><p>要升级mongod或mongos实例，使用如下方法之一：</p><ul><li>使用操作系统的包管理工具和官方MongoDB包进行升级(推荐的方法)；</li><li>使用新二进制文件替换现有二进制文件来升级实例。</li></ul><p><br></p><h4 id="替换现有二级制文件-replace-the-existing-binaries"><a href="#替换现有二级制文件-replace-the-existing-binaries" class="headerlink" title="替换现有二级制文件(replace the existing binaries)"></a>替换现有二级制文件(replace the existing binaries)</h4><p><strong>在升级MongoDB前请一定备份你的所有数据！</strong></p><p>首选的升级方式是使用包管理工具和官方的MongoDB包。</p><p>通过替换现有二进制文件来升级mongod或mongos实例，执行如下操作：</p><ol><li>下载最新MongoDB二进制文件到本地，并解压缩到MongoDB安装目录；</li><li>关闭实例；</li><li>替换二进制文件；</li><li>重启实例。</li></ol><p><br></p><h4 id="升级分片集群"><a href="#升级分片集群" class="headerlink" title="升级分片集群"></a>升级分片集群</h4><ol><li>禁用分片集群的平衡器(blancer)；</li><li>升级配置服务器(config-server)；</li><li>升级每个分片；</li><li>升级每个mongos实例；</li><li>重新启用平衡器。</li></ol><p><br></p><h4 id="升级复制集"><a href="#升级复制集" class="headerlink" title="升级复制集"></a>升级复制集</h4><p>若要升级复制集，请单独升级每个副本集成员。从Secondary开始，最后以Primary结束。</p><p><br></p><p><strong>升级SECONDARY</strong></p><ol><li>升级SECONDARY的mongod实例；</li><li>升级一个Secondary之后，在升级下一个实例之前，请等待Secondary恢复(recover)到SECONDARY state。使用<code>rs.status()</code>命令来检查复制集成员的状态。</li></ol><p><strong>升级PRIMARY</strong></p><ol><li>使用<code>rs.stepDown</code>命令来退出primary，以启动正常的故障转移过程；</li><li>查看是否有另外的SECONDARY节点成为了PRIMARY节点；</li><li>关闭并升级实例。</li></ol><p><br><br><br></p><h3 id="管理mongod进程"><a href="#管理mongod进程" class="headerlink" title="管理mongod进程"></a>管理mongod进程</h3><h4 id="开启mongod进程"><a href="#开启mongod进程" class="headerlink" title="开启mongod进程"></a>开启mongod进程</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mongod</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定数据目录</span></div><div class="line">mongod --dbpath /dir/mongodb/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定TCP端口</span></div><div class="line">mondod --port 12345</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#将mongod以守护进程的方式启动</span></div><div class="line">mongod --fork --logpath /var/<span class="built_in">log</span>/mongod.log</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#其他选项</span></div><div class="line">mongod --<span class="built_in">help</span></div></pre></td></tr></table></figure><p><br></p><h4 id="停止mongod进程"><a href="#停止mongod进程" class="headerlink" title="停止mongod进程"></a>停止mongod进程</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#使用shutdownServer()</span></div><div class="line">use admin</div><div class="line">db.shutdownServer()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#使用--shutdown</span></div><div class="line">mongod --shutdown</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#使用ctrl+c</span></div><div class="line">ctrl+c</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#使用kill</span></div><div class="line"><span class="comment">#千万不要使用kill -9(SIGKILL)来终止mongod</span></div><div class="line"><span class="built_in">kill</span> mongod_pid</div><div class="line"><span class="built_in">kill</span> -2 mongod_pid</div></pre></td></tr></table></figure><p><br></p><h4 id="停止一个复制集"><a href="#停止一个复制集" class="headerlink" title="停止一个复制集"></a>停止一个复制集</h4><p>步骤：</p><ol><li>检查SECONDARY的oplog的时间戳；</li><li>如果从节点的时间戳落后于主节点10s内，mongod将会返回不会被关闭的消息。你可以传递一个<code>timeoutSecs</code>参数给shutdown命令来等待从节点追上主节点；</li><li>一旦从节点追上进度或60s后，主节点将会关闭。</li></ol><p>强制关闭复制集：<code>db.adminCommand( { shutdown: 1, force: true } )</code></p><p>如果没有节点能立刻更新到最新的数据，发送<code>shutdown</code>加上<code>timeoutSecs</code>参数来在指定的时间内保持对从节点的检查。如果在分配的时间内有任意的一个从节点追上，主节点将会关闭。反之，主节点不会关闭。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.adminCommand(&#123; <span class="attr">shutdown</span>: <span class="number">1</span>, <span class="attr">timeoutSecs</span>: <span class="number">5</span> &#125;)</div><div class="line"></div><div class="line">#或</div><div class="line">db.shutdownServer(&#123; <span class="attr">timeoutSecs</span>: <span class="number">5</span>&#125;)</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="终止-Terminate-运行的操作"><a href="#终止-Terminate-运行的操作" class="headerlink" title="终止(Terminate)运行的操作"></a>终止(Terminate)运行的操作</h3><p>MongoDB提供了两种方法来终止正在运行的操作。</p><ul><li><code>maxTimeMS()</code></li><li><code>db.killOp()</code></li></ul><p><br></p><h4 id="maxTimeMS"><a href="#maxTimeMS" class="headerlink" title="maxTimeMS()"></a>maxTimeMS()</h4><p><code>maxTimeMS()</code>方法给一个操作(operation)设置了时间限制(time limit)。这个时间单位默认是毫秒(ms)。当这个操作达到了指定的时间限制时，MongoDB将在下一个中断点(interrupt point)中断这个操作。</p><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">db.location.find(</div><div class="line">  &#123;</div><div class="line"><span class="string">"town"</span>: &#123; <span class="string">"$regex"</span>: <span class="string">"(Pine Lumber)"</span>,</div><div class="line">    <span class="string">"$options"</span>: <span class="string">'i'</span> &#125;</div><div class="line">  &#125; ).maxTimeMS(<span class="number">30</span>)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">db.runCommand(</div><div class="line">  &#123;</div><div class="line">distinct: <span class="string">"collection"</span>,</div><div class="line">    key: <span class="string">"city"</span>,</div><div class="line">    maxTimeMS: <span class="number">45</span></div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p><br></p><h4 id="killOp"><a href="#killOp" class="headerlink" title="killOp"></a>killOp</h4><p><code>killOp()</code>方法将在下一个中断节点中断正在运行的操作。<code>killOp()</code>方法通过<strong>操作ID</strong>(operation ID)来标识目标操作。</p><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.killOp(&lt;opID&gt;)</div><div class="line"></div><div class="line"></div><div class="line">#查看正在运行的操作</div><div class="line">db.currentOp()</div></pre></td></tr></table></figure><p><strong>注意：</strong><br>终止正在运行的操作时一定要谨慎！只使用<code>db.killOp()</code>方法来终止由客户端发起的操作，而不要终止内部数据库(internal database)的操作。</p><p><br><br><br></p><h3 id="轮询-rotate-日志文件"><a href="#轮询-rotate-日志文件" class="headerlink" title="轮询(rotate)日志文件"></a>轮询(rotate)日志文件</h3><p>当使用<code>--logpath</code>选项或<code>systemLog.path</code>设置时，mongod或mongos实例会将所有活动和操作的实时账户报告给日志文件。默认情况下，只有当使用了<code>logRotate</code>命令，或者mongod或mongos进程从操作系统接收到一个<code>SIGUSR1</code>信号时，才会进行日志轮询响应。</p><p>MongoDB的标准日志轮询方法会存档当前日志文件并启动一个新的日志文件。为此，mongod或mongos实例将通过ISODate日期格式的UTC时间戳来重命名当前日志文件。然后它会打开一个新的日志文件，关闭旧的日志文件，并将所有新的日志发送到新的日志文件。</p><p>你也可以通过配置MongoDB的<code>systemLog.logRatate</code>或<code>--logRotate</code>选项，来支持Unix/Linux的日志轮询功能。<br>最后，你可以使用<code>--syslog</code>选项来配置mongod发送日志数据到系统日志。在这种情况下，你可以选用其他的日志轮询工具。</p><p><br></p><h4 id="默认日志轮询行为"><a href="#默认日志轮询行为" class="headerlink" title="默认日志轮询行为"></a>默认日志轮询行为</h4><p><strong>在mongo shell中轮询日志：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#开启一个实例</span></div><div class="line">mongod -v --logpath /var/<span class="built_in">log</span>/mongodb/test01.log</div><div class="line"></div><div class="line"><span class="comment">#列出日志文件</span></div><div class="line">ls /var/<span class="built_in">log</span>/mongodb/test01.log*</div><div class="line"></div><div class="line"><span class="comment">#轮询日志文件</span></div><div class="line">mongo</div><div class="line">&gt;use admin</div><div class="line">&gt;db.runCommand(&#123; logRotate: 1 &#125;)</div><div class="line"></div><div class="line"><span class="comment">#查看新的日志文件</span></div><div class="line">ls /var/<span class="built_in">log</span>/mongodb/test01.log*</div><div class="line"><span class="comment">#new: test01.log</span></div><div class="line"><span class="comment">#old: test01.log-2018-01-11T08-22-50</span></div></pre></td></tr></table></figure><p><strong>使用<code>--logRotate reopen</code>选项轮询日志：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mongod -v --logpath /var/<span class="built_in">log</span>/mongodb/test01.log --logRotate reopen --logapend</div><div class="line"></div><div class="line">ls /var/<span class="built_in">log</span>/mongodb/test01.log*</div><div class="line"></div><div class="line">mongo</div><div class="line">&gt;use admin</div><div class="line">&gt;db.runCommand(&#123; logRotate: 1 &#125;)</div></pre></td></tr></table></figure><p><br></p><h4 id="系统日志轮询-Syslog-log-rotate"><a href="#系统日志轮询-Syslog-log-rotate" class="headerlink" title="系统日志轮询(Syslog log rotate)"></a>系统日志轮询(Syslog log rotate)</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod --syslog</div></pre></td></tr></table></figure><p><br></p><h4 id="使用SIGUSR1强制日志轮询"><a href="#使用SIGUSR1强制日志轮询" class="headerlink" title="使用SIGUSR1强制日志轮询"></a>使用SIGUSR1强制日志轮询</h4><p>对于基于Unix/Linux的系统，可以使用<strong>SIGUSR1</strong>信号来轮询单个进程的日志。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">kill</span> -SIGUSR1 &lt;mongod-pid&gt;</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="数据中心意识-data-center-awareness"><a href="#数据中心意识-data-center-awareness" class="headerlink" title="数据中心意识(data center awareness)"></a>数据中心意识(data center awareness)</h2><h3 id="MongoDB部署中的分离-segregation-操作"><a href="#MongoDB部署中的分离-segregation-操作" class="headerlink" title="MongoDB部署中的分离(segregation)操作"></a>MongoDB部署中的分离(segregation)操作</h3><p>MongoDB拥有许多特性，包括允许数据库管理员和开发者在部署数据库的过程中通过一些功能或地理组群对数据库应用进行分割操作。</p><p>MongoDB支持跨越不同维度的操作的分段，这可能包括了在单个数据中心(single data center)的部署中的多数据中心(multi-date center)部署、机架、网络或电源电路的多个数据中心和地理区域。</p><p>MongoDB还支持基于功能或操作参数的数据库分离操作，以确保某些mongod实例仅用于报告工作负载，或只在特定的分片上分离集合的某些高频部分。</p><p><br></p><p>特别是在MongoDB中你可以：</p><ul><li>确保写操作传播到复制集的特定成员；</li><li>确保复制集中的特定成员响应了查询操作；</li><li>确保分片键在具体范围上的平衡，并且驻留在特定的分片上。</li></ul><p><br></p><h3 id="区域-zone"><a href="#区域-zone" class="headerlink" title="区域(zone)"></a>区域(zone)</h3><h4 id="管理分片区域-manage-shard-zones"><a href="#管理分片区域-manage-shard-zones" class="headerlink" title="管理分片区域(manage shard zones)"></a>管理分片区域(manage shard zones)</h4><p><br></p><h4 id="按位置分割数据-segementing-data-by-location"><a href="#按位置分割数据-segementing-data-by-location" class="headerlink" title="按位置分割数据(segementing data by location)"></a>按位置分割数据(segementing data by location)</h4><p><br></p><h4 id="为SLA或SLO改变分层硬件"><a href="#为SLA或SLO改变分层硬件" class="headerlink" title="为SLA或SLO改变分层硬件"></a>为SLA或SLO改变分层硬件</h4><p><br></p><h4 id="按应用程序或客户分割数据"><a href="#按应用程序或客户分割数据" class="headerlink" title="按应用程序或客户分割数据"></a>按应用程序或客户分割数据</h4><p><br></p><h4 id="Distributed-Local-Writes-for-Insert-Only-Workloads"><a href="#Distributed-Local-Writes-for-Insert-Only-Workloads" class="headerlink" title="Distributed Local Writes for Insert Only Workloads"></a>Distributed Local Writes for Insert Only Workloads</h4><p><br></p><h4 id="管理分片区域"><a href="#管理分片区域" class="headerlink" title="管理分片区域"></a>管理分片区域</h4><p><br><br><br></p><h2 id="MongoDB备份方案-backup-methods"><a href="#MongoDB备份方案-backup-methods" class="headerlink" title="MongoDB备份方案(backup methods)"></a>MongoDB备份方案(backup methods)</h2><p><strong>在生存中部署MongoDB时，如果发生数据丢失的事件，你应该指定一个捕获和恢复备份的策略(strategy)。</strong></p><p><br></p><p><strong>back up with MongoDB cloud manager or Ops manager</strong></p><ul><li>MongoDB Cloud Manager</li><li>Ops Manager</li></ul><p><br></p><p><strong>复制底层数据文件进行备份(back up by copying underlying data files)</strong></p><ul><li>使用文件系统快照备份(back up with filesystem snapshots)</li></ul><p>你可以通过复制MongoDB的底层数据文件来创建MongoDB部署的备份。<br>如果MongoDB储存其数据文件的卷(volume)支持时间点快照(point-in-time snapshots)，则可以使用这些快照在某个时刻创建MongoDB系统的备份。<br>文件系统的快照是一个操作系统的卷管理器的功能，并没有具体到MongoDB。通过文件系统快照，操作系统将卷的快照用作数据备份的基准。快照的机制取决于底层的存储系统。<br>例如，在Linux上，逻辑卷管理器(LVM)可以创建快照。</p><p>要获得运行中的MongoDB进程的正确快照，必须启用日志记录(jorunaling)，并且日志必须与其它MongoDB数据文件存储在相同的逻辑卷上。如果没有启用日志记录，则无法保证快照将是一致有效地。</p><p>为了获得分片集群一致的快照，你必须禁用平衡器(balancer)和捕捉每一个分片的快照以及大约在同一时刻的配置服务器。</p><ul><li>使用<code>cp</code>或<code>scp</code>备份</li></ul><p>如果你的系统不支持快照功能，则可以使用<code>cp</code>，<code>rsync</code>或类似的工具直接复制文件。<br>由于复制多个文件不是原子操作，因此你必须在复制文件之前停止对mongod的所有写入。否则，你将复制处于无效状态的文件。</p><p>复制底层数据而产生的备份不支持复制集的时间恢复节点，并且难以管理更大的共享集群。此外，这些备份很大。因为它们包括索引和复制底层存储填充和分片。<br>相反，<code>mongodump</code>会创建较小的备份。</p><ul><li>使用<code>mongodump</code>备份</li></ul><p>如果在<code>mongodump</code>创建备份的同时，应用程序对数据进行修改，那么<code>mongodump</code>将会与这些应用竞争资源。</p><p><code>mongodump</code>从一个MongoDB数据库中读取数据，并创建高保真度(high fidelity)的BSON文件。<code>mongorestore</code>工具可使用这个文件来进行MongoDB数据库恢复。<br><code>mongodump</code>和<code>mongorestore</code>是用于备份和恢复小型MongoDB部署的简单和高效的工具，但对于捕获较大的系统并不理想。</p><p><code>mongodump</code>和<code>mongorestore</code>针对正在运行的mongod进程进行操作，可以直接操纵底层的数据文件。默认情况下，<code>mongodump</code>不会捕获<code>local database</code>数据库的内容。</p><p><code>mongodump</code>只捕获数据库中的文档(documents)，用以给备份节省空间，但<code>mongorestore</code>或mongod必须在恢复数据之后重建索引。</p><p>当连接到MongoDB实例时，<code>mongodump</code>可能会对MongoDB的性能产生不利影响。如果你的数据大小大于系统内存，查询可能会将工作单元从内存中推开，从而导致页面错误。</p><p>当<code>mongodump</code>在捕获输出时，应用程序可以继续修改数据。对于复制集来说，<code>mongodump</code>提供了<code>--oplog</code>选项来用以在<code>mongodump</code>操作期间包含数据的oplog条目。这允许相应的<code>mongorestore</code>操作去还原所捕获的oplog。</p><p>然而，对于复制集来说，请考虑使用MongoDB Cloud Manager 或 Ops Manager来备份。</p><p><br><br><br></p><h3 id="使用文件系统快照进行备份和恢复-back-up-and-restore-with-filesystem-snapshots"><a href="#使用文件系统快照进行备份和恢复-back-up-and-restore-with-filesystem-snapshots" class="headerlink" title="使用文件系统快照进行备份和恢复(back up and restore with filesystem snapshots)"></a>使用文件系统快照进行备份和恢复(back up and restore with filesystem snapshots)</h3><p>使用系统工具创建MongoDB系统的备份，诸如<strong>LVM</strong>，或<strong>block-level</strong>备份方法。使用系统工具来创建MongoDB数据文件的设备的副本。这些方法完成迅速、工作可靠，但是需要在MongoDB之外进行额外的系统配置。</p><p><br></p><h4 id="快照综述-snapshots-overview"><a href="#快照综述-snapshots-overview" class="headerlink" title="快照综述(snapshots overview)"></a>快照综述(snapshots overview)</h4><p>快照的工作方式是在实时数据(live data)和一个特定快照卷之间创建指针(pointer)。这个指针在理论上等同于<strong>硬链接(hard link)</strong>。作为工作数据偏离的快照，快照过程使用<strong>写时复制</strong>(copy-on-write)策略。结果，快照又只存储修改的数据。</p><p>创建快照后，在文件系统上挂载(mount)快照镜像，并从中复制数据。生成的备份包含所有数据的完整副本。</p><p><br></p><p><strong>Valid database at the time of snapshot</strong></p><p>当快照生成时数据库必须有效。这就意味着数据库所接收的所有写入(write)都需要完整的写入磁盘————无论是<code>journal</code>还是数据文件。<br>如果备份发生时磁盘上没有写入(write)，备份将不反映这些更改。</p><p>对于WiredTiger storage engine，数据文件反映了最后一个检查点(last checkpoint)的一致状态。每2GB的数据或每分钟就会出现检查点。</p><p><br></p><p><strong>Entire disk image</strong></p><p>快照创建一个整个磁盘镜像的镜像。除非你需要备份你的整个系统，否则考虑隔离(isolate)你的MongoDB数据文件、journal，并配置一个不包含任何其他数据的逻辑磁盘。<br>或者，将所有的MongoDB数据文件保存在一个专用的设备上，这样你就可以在没有重复(duplicating)和无关(extraneous)数据的情况下进行备份。</p><p><br></p><p><strong>Site failure precaution</strong></p><p>确保将数据从快照复制到其他系统。这确保了在站点故障(site failure)的时候数据是安全的。</p><p><br></p><p><strong>No incremental backups</strong></p><p>本教程不包含增量备份(incremental backups)的过程。虽然不同的快照方法提供了不同的功能，但下面列出的LVM方法不提供捕获增量备份的任何容量。</p><p><br></p><p><strong>Snapshots with journaling</strong></p><p>如果你的mongod实例启用了journaling，则可以使用任何类型的文件系统和volume/block level快照工具来创建备份。</p><p>如果你在基于Linux的系统上管理你自己的基础架构，请使用LVM配置你的系统以提供磁盘包并提供快照功能。</p><p><br></p><h4 id="在Linux上使用LVM进行备份和还原"><a href="#在Linux上使用LVM进行备份和还原" class="headerlink" title="在Linux上使用LVM进行备份和还原"></a>在Linux上使用LVM进行备份和还原</h4><p>生产备份系统必须考虑一些特定环境的应用程序特定需求和因素。</p><p><br></p><p><strong>Crete a snapshot</strong></p><ul><li>确保你创建的快照具有足够的空间来考虑数据的增长；</li><li>如果快照超出了空间，快照镜像将无法使用。请放弃这个逻辑卷并创建另外一个；</li><li>命令执行完毕时快照将存在。你可以随时直接从快照进行还原，也可以创建新的逻辑卷并从此快照还原到备用镜像；</li><li>虽然快照对于快速创建高质量的备份非常好，但它们并不是理想的作为存储备份数据的格式；</li><li>快照通常取决于并位于与原始磁盘镜像相同的存储基础架构上。因此，将这些快照存档并将其存储在别处至关重要。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#下面的这个vg-name指卷组名，这个卷组首先需要建立</span></div><div class="line"><span class="comment">#系统卷组和设备的位置和路径可能因LVM的配置二略有不同</span></div><div class="line"><span class="comment">#此大小不反映数据大小</span></div><div class="line"></div><div class="line">lvcreate --size 1G --snapshot --name mongodb-snap20180111 /dev/vg-name/mongodb</div></pre></td></tr></table></figure><p><br></p><p><strong>Archive a snapshot</strong></p><p>创建好snapshot之后，挂载<code>mount</code>快照并将数据复制到单独的存储中。</p><p>压缩快照：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">umount /dev/vg-name/mongodb-snap01</div><div class="line">dd <span class="keyword">if</span>=/dev/vg-name/mongodb-snap01 | gzip &gt; mongodb-snap01.gz</div></pre></td></tr></table></figure><p><br></p><p><strong>Restore a snapshot</strong></p><p>同样适用LVM进行还原。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#lv-mongodb, vg0-vgname</span></div><div class="line"></div><div class="line">lvcreate --size 1G --name mongodb vg0</div><div class="line">gzip -d -c mongodb-snap01.gz | dd of=/dev/vg0/mongodb</div><div class="line">mount /dev/bg0/mongodb /dir/path</div></pre></td></tr></table></figure><p>还原的快照中有一个陈旧的<code>mongo.lock</code>文件，如果你没有从快照中删除此文件，那么MongoDB可能会认为锁文件指示的是不正常的关闭。如果你开启了<code>storage.journal.enabled</code>，但没有使用<code>db.fsyncLock()</code>的话，那不需要删除<code>mongo.lock</code>文件，反之，删除它。</p><p><br></p><p><strong>Restore directly form a snapshot</strong></p><p>不使用gz压缩文件下还原备份。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">umount /dev/vg-name/mongodb-snap01</div><div class="line">lvcreate --size 1G --name mongodb vg0</div><div class="line">dd <span class="keyword">if</span>=/dev/vg0/mongodb-snap01 of=/dev/vg0/mongodb</div><div class="line">mount /dev/vg0/mongodb /dir/path</div></pre></td></tr></table></figure><p><br></p><p><strong>Remote backup storage</strong></p><p>可以使用组合的进程和SSH实施离线备份。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">umount /dev/vg-name/mongodb-snap01</div><div class="line">dd <span class="keyword">if</span>=/dev/vg0/mongodb-snap01 | ssh user@host gzip &gt; /dir/path/mongodb-snap01.gz</div><div class="line">lvcreate --size 1G --name mongodb vg0</div><div class="line">ssh user@host gzip -d -c /dir/path/mongodb-snap-01.gz | dd of =/dev/vg0/mongodb</div><div class="line">mount /dev/vg0/mongodb /dir/path</div></pre></td></tr></table></figure><p><br></p><h4 id="使用单独卷上的Journal日志文件或没有Journal日志文件进行备份实例"><a href="#使用单独卷上的Journal日志文件或没有Journal日志文件进行备份实例" class="headerlink" title="使用单独卷上的Journal日志文件或没有Journal日志文件进行备份实例"></a>使用单独卷上的Journal日志文件或没有Journal日志文件进行备份实例</h4><p>从MongoDB3.2开始，为了使用WiredTiger对MongoDB实例进行volume-level备份，数据文件和Journal日志文件不再要求驻留在一个卷上。</p><p>如果你的mongod实例没有使用Journal，或者启用了将Journal志文件放置于一个单独的卷上，则必须刷新(flush)对磁盘的所有写入，并在备份期间锁住数据库用以阻止写操作。<br>如果有复制集(replica set)配置，那么你可以在SECONDARY上不接收读取用以备份数据。</p><p><br></p><p><strong>1. 刷新写入磁盘并锁定数据库以防止进一步的写入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#锁住数据库</div><div class="line">db.fsyncLock();</div></pre></td></tr></table></figure><p><strong>2. 使用快照备份数据库：</strong></p><p><strong>3. 解锁数据库：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#解锁数据库</div><div class="line">db.fsyncUnlock();</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用MongoDB工具进行备份和恢复-back-up-and-restore-with-MongoDB-tools"><a href="#使用MongoDB工具进行备份和恢复-back-up-and-restore-with-MongoDB-tools" class="headerlink" title="使用MongoDB工具进行备份和恢复(back up and restore with MongoDB tools)"></a>使用MongoDB工具进行备份和恢复(back up and restore with MongoDB tools)</h3><p>使用MongoDB提供的备份还原工具——<code>mongodump</code>和<code>mongorestore</code>来处理BSON data，对于创建小型部署的备份是很有用的。<br>对于弹性(resilient)备份和非破坏性(non-disruptive)备份，使用文件系统或块级磁盘快照。</p><p>因为<code>mongodump</code>和<code>mongorestore</code>操作通过与正在运行中的<code>mongod</code>实例进行交互(interacting)，它们会影响正在运行的数据库的性能(performance)。这些工具不仅会为正在运行的数据库实例创建流量，还会强制数据库通过内存读取所有的数据。当MongoDB读取不经常(infrequently)使用的数据时，它会驱逐(evict)频繁(frequently)访问的数据，导致数据库正常工作负载的性能下降。</p><p><br></p><p>当使用MongoDB’s tools 来备份你的数据时，考虑如下建议：</p><ul><li>标签文件(label file)，以便你可以识别备份的内容以及备份所反映的时间点</li><li>如果对你来说，<code>mongodump</code>和<code>mongorestore</code>对性能的影响是不可接受的，请使用替代备份策略——filesystem snapshot或MongoDB CloudManager</li><li>使用<code>--oplog</code>去捕获在<code>mongodump</code>期间的传入写(write)操作，以确保备份一致性的数据状态</li><li>通过将备份文件还原到测试环境中，以确认备份是可用的</li></ul><p><br></p><h4 id="MongoDB-tools"><a href="#MongoDB-tools" class="headerlink" title="MongoDB tools"></a>MongoDB tools</h4><p><strong>MongoDB工具介绍及区别：</strong></p><ul><li><p>mongoexport<br><code>mongoexport</code> is a utility that produces a <strong>JSON or CSV</strong> export of data stored in a MongoDB instance.</p></li><li><p>mongoimport<br>The <code>mongoimport</code> tool imports content from an <strong>Extended JSON, CSV, or TSV</strong> export created by mongoexport, or potentially, another third-party export tool.</p></li><li><p>mongodump<br><code>mongodump</code> is a utility for creating a <strong>binary export of the contents of a database</strong>. mongodump can export data from either mongod or mongos instances.<br>mongodump excludes the content of the local database in its output.<br>The mongodump utility backs up data by connecting to a running mongod or mongos instance.</p></li><li><p>mongorestore<br>The <code>mongorestore</code> program writes data from a <strong>binary database dump</strong> created by mongodump to a MongoDB instance.</p></li></ul><p><br></p><h4 id="步骤-Procedures"><a href="#步骤-Procedures" class="headerlink" title="步骤(Procedures)"></a>步骤(Procedures)</h4><h5 id="使用mongodump备份"><a href="#使用mongodump备份" class="headerlink" title="使用mongodump备份"></a>使用mongodump备份</h5><ul><li>`mongodump·备份数据库，如果数据库启用了访问控制，则必须拥有每个备份的数据库查询的权限。内置的备份角色提供了执行任何和数据库备份有关所需的权限。</li><li>这就意味着你使用<code>mongodump</code>的user必须要对所备份的数据库有读取权限。</li><li><code>mongodump</code>能够为<strong>整个服务器、数据库或集合</strong>创建备份，或者使用查询仅备份集合的一部分。</li><li><code>mongodump</code>默认排除<code>local</code>数据库。</li><li><code>mongodump</code>必须要能够连接到正在运行的mongod或mongos实例。默认连接为127.0.0.1:27017。</li><li><code>mongodump</code>默认创建在当前目录下创建./dump备份文件。</li><li>如果<code>mongodump</code>备份目录中已经存在备份数据目录，那么<code>mongodump</code>将会覆盖它们。</li><li>指定认证库来认证你的用户名和密码。</li></ul><p><br></p><p><strong>使用oplog进行时间点操作</strong></p><ul><li>在<code>mongodump</code>中使用<code>--oplog</code>选项来收集oplog条目，用以在副本集中构建数据库的实时快照。</li><li>使用<code>--oplog</code>，<code>mongodump</code>会从源数据库复制所有的数据，包括备份开始到结束这段时间所有的oplog记录。</li><li>在<code>mongorestore</code>还原时使用<code>--oplogReplay</code>选项，允许你还原特定时间节点的备份。这就对应在<code>mongodump</code>期间oplog的记录。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#127.0.0.1:27017 ./dump</span></div><div class="line">mongodump</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--host,-h  --port</span></div><div class="line">mongodump -h mongodb.example.net --port 27107</div><div class="line">mongudump -h 127.0.0.1 --port 27018</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-o, --out</span></div><div class="line">mongoodump -o /var/mongodb_backup/</div><div class="line">mongodump --host 127.0.0.1 --port 27017 --out /var/mongodb_backup/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--collection, --db</span></div><div class="line">mongodump --db zhang --out /var/mongodb_backup/zhang</div><div class="line">mongodump --db zhang --collection <span class="built_in">test</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--authenticationDatabase</span></div><div class="line">mongodump --port 27018 -u zhang -p <span class="string">"passwd"</span>  --authenticationDatabase admin -d zhang -o /var/mongodb_backup/zhang</div></pre></td></tr></table></figure><p><br></p><h4 id="使用mongorestore还原"><a href="#使用mongorestore还原" class="headerlink" title="使用mongorestore还原"></a>使用mongorestore还原</h4><p>若要将数据还原到启用了访问控制的MongoDB部署，如果备份数据不包括<code>system.profile</code>集合数据，则restore角色提供了对数据库的访问权限。</p><p>如果备份数据包含了<code>system.profile</code>集合并且目标数据库不包含<code>system.profile</code>集合，那么<code>mongorestore</code>会去创建这个集合即使<code>mongorestore</code>并没有还原<code>system.profile</code>文档。因此，用户就需要额外的权限才能在<code>system.profile</code>集合中上执行<code>createCollection</code>和<code>convertToCapped</code>。</p><p>如果使用<code>--oplogReplay</code>，这个restore角色还不足以重放oplog。所以如果需要重放oplog，请使用一个能够重放oplog的角色。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mongorestore /var/mnogodb_backup</div><div class="line"></div><div class="line"></div><div class="line">mongorestore /var/mnogodb_backup --oplogReplay</div><div class="line"></div><div class="line"></div><div class="line">mongorestore --port 27018 -u zhang -p <span class="string">"passwd"</span> --authecticationDatabase admin -d zhang /var/mongodb_back/zhang</div></pre></td></tr></table></figure><p><br></p><h4 id="批量化操作mongo-shell-EOF"><a href="#批量化操作mongo-shell-EOF" class="headerlink" title="批量化操作mongo shell(EOF)"></a>批量化操作mongo shell(<code>EOF</code>)</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> coll <span class="keyword">in</span> &#123;collection1,collection2,...&#125;</div><div class="line"><span class="keyword">do</span></div><div class="line">mongo host:port/db -u x -p xx &lt;&lt; EOF</div><div class="line">    use db</div><div class="line">    db.<span class="variable">$coll</span>.drop()</div><div class="line">    EOF</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="从MongoDB备份中还原副本集"><a href="#从MongoDB备份中还原副本集" class="headerlink" title="从MongoDB备份中还原副本集"></a>从MongoDB备份中还原副本集</h3><p>你不能将单个数据集(data set)还原为三个新的mongod实例，然后为此创建一个副本集(replication set)。<br>如果你将数据集复制到每个mongod实例，然后创建副本集，则MongoDB将强制SECONDARY执行<code>initial sync</code>。</p><p><br></p><h4 id="向一个单一副本集节点中还原数据-Restore-Database-into-a-Single-Node-Replica-Set"><a href="#向一个单一副本集节点中还原数据-Restore-Database-into-a-Single-Node-Replica-Set" class="headerlink" title="向一个单一副本集节点中还原数据(Restore Database into a Single Node Replica Set)"></a>向一个单一副本集节点中还原数据(Restore Database into a Single Node Replica Set)</h4><ol><li><p>获取备份数据库文件</p></li><li><p>使用备份数据库文件作为数据库路径启动一个mongod实例</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#方法1，直接启动</span></div><div class="line">mongod --dbpath /dir/path/mongodump --replSet &lt;replName&gt;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#方法2，使用配置文件启动，推荐</span></div><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">storage:</div><div class="line">  dbPath: /dir/path/mongodump</div><div class="line">replication:</div><div class="line">  replSetName: zhang</div></pre></td></tr></table></figure><ol><li><p>连接到mongo shell</p></li><li><p>初始化这个新的副本集</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#对于有且仅有一个成员的副本集使用rs.initiate()</div><div class="line">rs.initiate()</div></pre></td></tr></table></figure><p><br></p><h4 id="向副本集中添加成员-Add-Members-to-the-Replica-Set"><a href="#向副本集中添加成员-Add-Members-to-the-Replica-Set" class="headerlink" title="向副本集中添加成员(Add Members to the Replica Set)"></a>向副本集中添加成员(Add Members to the Replica Set)</h4><p>MongoDB对于还原副本集SECONDARY节点提供了两种选择：</p><ol><li>手动复制数据库文件到数据目录</li><li>允许<code>initial sync</code></li></ol><p><strong>建议：</strong></p><blockquote><p>如果备份的数据库文件很大，那么<code>initial sync</code>可能需要很长的时间才能完成。对于大型数据库，最好将数据库文件复制到每台主机上。</p></blockquote><p><br></p><h5 id="Copy-Database-File-and-Restart-mongod-Instance"><a href="#Copy-Database-File-and-Restart-mongod-Instance" class="headerlink" title="Copy Database File and Restart mongod Instance"></a>Copy Database File and Restart mongod Instance</h5><ol><li>Shut down the mongod instance that you restored</li></ol><blockquote><p>使用 <code>--shutdown</code> 或 <code>db.shutdownServer()</code>来确保一个正常干净的关闭</p></blockquote><ol><li><p>复制Primary的数据目录到每个从节点</p></li><li><p>Start the mongod instance that you restorerd</p></li><li><p>Add the secondaries to the replica set</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PRIMARY&gt;rs.add()</div></pre></td></tr></table></figure><p><br></p><h5 id="Update-Secondaries-using-Initial-Sync"><a href="#Update-Secondaries-using-Initial-Sync" class="headerlink" title="Update Secondaries using Initial Sync"></a>Update Secondaries using Initial Sync</h5><ol><li>确保副本集成员的数据目录为空</li><li>将每个潜在成员添加到副本集</li></ol><p><br><br><br></p><h3 id="备份和还原分片集群-sharded-cluster"><a href="#备份和还原分片集群-sharded-cluster" class="headerlink" title="备份和还原分片集群(sharded cluster)"></a>备份和还原分片集群(sharded cluster)</h3><p><br></p><h4 id="通过文件系统快照-fs-snapshots-备份一个分片集群"><a href="#通过文件系统快照-fs-snapshots-备份一个分片集群" class="headerlink" title="通过文件系统快照(fs snapshots)备份一个分片集群"></a>通过文件系统快照(fs snapshots)备份一个分片集群</h4><p><br></p><h4 id="通过Database-Dumps备份一个分片集群"><a href="#通过Database-Dumps备份一个分片集群" class="headerlink" title="通过Database Dumps备份一个分片集群"></a>通过Database Dumps备份一个分片集群</h4><p><br></p><h4 id="Schedule-Backup-Window-for-Sharded-Clusters"><a href="#Schedule-Backup-Window-for-Sharded-Clusters" class="headerlink" title="Schedule Backup Window for Sharded Clusters"></a>Schedule Backup Window for Sharded Clusters</h4><p><br></p><h4 id="还原一个分片集群"><a href="#还原一个分片集群" class="headerlink" title="还原一个分片集群"></a>还原一个分片集群</h4><p><br><br><br></p><h3 id="从意外关闭中恢复-Recover-a-standalone-after-an-unexpected-shutdow"><a href="#从意外关闭中恢复-Recover-a-standalone-after-an-unexpected-shutdow" class="headerlink" title="从意外关闭中恢复(Recover a standalone after an unexpected shutdow)"></a>从意外关闭中恢复(Recover a standalone after an unexpected shutdow)</h3><p>当一个standalone模式的mongod实例关闭了journaling功能后，一个unclean的shutdown可能会导致数据处于不一致的状态。<br>当unclean shutdown之后，如果在dbPath下存在一个非空的<code>mongod.lock</code>文件，则mongod实例会记录如下信息：</p><blockquote><p>Dectected unclean shutdown - mongod.lock is not empty</p></blockquote><p>这样的话你必须要修复你的数据库，才能正常的启动mongod。</p><blockquote><p><strong>警告：</strong><br>不要用如下方法处理副本集 unclean shutdown。相反，你应该从备份或者从另一个副本集的成员恢复。</p></blockquote><p>默认情况下，MongoDB在启用journaling的情况下运行，以防止发生unclean shutdown时数据不一致的问题。</p><p>使用运行mongod实例的那个用户来进行修复，避免由权限不一致而导致的新问题。</p><ol><li>Create a backup of the data files</li><li>Start mongod with –repair</li></ol><p><br><br><br></p><h2 id="监控-Monitoring-MongoDB"><a href="#监控-Monitoring-MongoDB" class="headerlink" title="监控(Monitoring)MongoDB"></a>监控(Monitoring)MongoDB</h2><p>监控是数据库管理的重要组成部分，充分了解MongoDB的运行状态，并在没有危机的情况下维护和部署。此外，了解MongoDB的正常操作参数将允许你在问题升级成为故障前诊断他们。</p><p><br></p><h3 id="Monitoring-for-MongoDB"><a href="#Monitoring-for-MongoDB" class="headerlink" title="Monitoring for MongoDB"></a>Monitoring for MongoDB</h3><p><br></p><h4 id="Monitoring-Strategies-策略"><a href="#Monitoring-Strategies-策略" class="headerlink" title="Monitoring Strategies(策略)"></a>Monitoring Strategies(策略)</h4><p>有三种方法可以从运行中的MongoDB实例中收集状态信息：</p><ol><li>MongoDB提供的一组实时上报程序，提供数据库活动的实时报告；</li><li>数据库命令以更大的保真度返回有关当前数据库状态的统计信息；</li><li>MongoDB Atlas，MongoDB Cloud Manager；</li></ol><p>每个策略在不同的情况下都是很有用的，所以它们能够很好地进行互补。</p><p><br></p><h4 id="MongoDB-Reporting-Tools"><a href="#MongoDB-Reporting-Tools" class="headerlink" title="MongoDB Reporting Tools"></a>MongoDB Reporting Tools</h4><p><strong>Utilities</strong></p><p>MongoDB提供了许多可以返回活动统计信息的实用工具，这对于诊断问题和评估操作非常有用。</p><ul><li><code>mongostat</code><br>  <code>mongostat</code>按类型捕获并返回数据库操作的计数(insert,query,update,delete…)</li></ul><p><img src="/images/MongoDB/mongostat.png" alt="mongostat"></p><ul><li><code>mongotop</code><br>  <code>mongotop</code>通过类型捕获和返回数据库操作(insert,query,update,delete)</li></ul><p><img src="/images/MongoDB/mongotop.png" alt="mongotop"></p><p><br></p><h4 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h4><p>MongoDB包含了许多上报数据库状态的命令。这些命令可以提供比上面的实用程序更精细的粒度级别。考虑在脚本和程序中使用它们的输出来开发自定义警报。<br><code>db.currentOp</code>方法是一个识别当前数据库实例正在进行的操作。</p><ul><li><p><code>db.serverStatus()</code><br>  <code>db.serverStatus()</code>，返回数据库状态的一般概述，详细的磁盘使用，内存使用，连接，journaling日志和索引访问。它返回快速并不影响MongoDB性能。</p></li><li><p><code>db.stats()</code><br>  <code>db.stats()</code>，提供了database上的统计信息。返回使用的存储量，数据库包含的数据量及对象，collection和索引计数器。</p></li></ul><p><img src="/images/MongoDB/dbstats.png" alt="dbStats"></p><ul><li><p><code>db.collection.stats()</code><br>  <code>db.collection.stats()</code>，提供了collection上的统计信息。包含集合中的对象数量，结合大小，集合磁盘空间用量，索引信息。</p></li><li><p><code>rs.status()</code><br>  <code>rs.status()</code>，返回一个复制集状态的概述。</p></li></ul><p><br></p><h4 id="第三方工具"><a href="#第三方工具" class="headerlink" title="第三方工具"></a>第三方工具</h4><p>许多第三方(third party)工具支持对MongoDB的监控。</p><ul><li>Nagios</li><li>Zabbix</li><li>Ganglia</li><li>Motop</li><li>…</li></ul><p><br><br><br></p><h3 id="Monitor-MongoDB-with-SNMP-on-Linux"><a href="#Monitor-MongoDB-with-SNMP-on-Linux" class="headerlink" title="Monitor MongoDB with SNMP on Linux"></a>Monitor MongoDB with SNMP on Linux</h3><p><strong>SNMP is only available in MongoDB Enterprise</strong></p><p><br></p><h3 id="Monitor-MongoDB-Windows-with-SNMP"><a href="#Monitor-MongoDB-Windows-with-SNMP" class="headerlink" title="Monitor MongoDB Windows with SNMP"></a>Monitor MongoDB Windows with SNMP</h3><p><br></p><hr><p><br></p><h1 id="MongoDB索引"><a href="#MongoDB索引" class="headerlink" title="MongoDB索引"></a>MongoDB索引</h1><p>Indexes</p><p><br></p><p>索引支持在MongoDB中高效地(effecient)执行查询。没有索引，MongoDB就必须采取collection scan。扫描每个集合中的每个文档，用以匹配查询。如果查询存在适当的索引，则MongoDB可以使用该索引来限制它必须检查的文档数量。</p><p>索引是特殊的数据结构，将集合数据集中的一小部分以易于遍历(traverse)的形式存储。索引存储特定字段或字段集的值，按字段值排序。索引条目的排序支持高效的相等匹配和基于范围的查询操作。除此之外，MongoDB可以使用索引中的排序返回排序后的结果。</p><p><img src="/images/MongoDB/index_sort.png" alt="栗子"></p><p><br></p><p>从根本上来说(fundamentally)，MongoDB中的索引类似于其他数据库的索引。MongoDB在collection级别定义索引，并支持集合的文档的任何字段或子字段上的索引。</p><p><br></p><p><strong>默认<code>_id</code>索引</strong><br>    在创建一个collection期间，MongoDB在<code>_id</code>字段上创建一个唯一的索引。你也可以自定义<code>_id</code>的值。你不能在<code>_id</code>字段上删除此索引。</p><p><strong>创建一个索引</strong><br>    <code>db.collection.createIndex</code>方法只有在同一规范不存在时才创建索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.collection.createIndex(&lt;key and index type&gt;, option)</div></pre></td></tr></table></figure><p><strong>索引类型</strong><br>MongoDB提供了许多不同的索引类型来支持特定类型的数据和查询。</p><ul><li><p>Single Field<br>  除了MongoDB定义的<code>_id</code>索引，MongoDB还支持在文档的单个字段上创建用户自定义的升序(ascending)/降序(descending)索引。<br>  对于单字段索引和排序操作，MongoDB可以在任何方向遍历索引。<br><img src="/images/MongoDB/SingleField.png" alt="单字段索引"></p></li><li><p>Compound(复合) Index<br>  MongoDB也支持多个字段的用户自定义索引。<br><img src="/images/MongoDB/CompundIndex.png" alt="复合索引"></p></li><li><p>Multikey Index<br>  MongoDB使用多键索引来索引存储在数组中的内容。<br><img src="/images/MongoDB/MultikeyIndex.png" alt="多键索引"></p></li><li><p>Geospatial(地理空间) Index<br>  为了支持对地理空间坐标数据的有效查询，MongoDB提供了两个特殊的索引：<code>2d index</code>返回平面几何的2D索引；<code>2dsphere index</code>返回球形几何结果。</p></li><li><p>Text Index<br>  MongoDB提供了一个文本(text)类型索引，用以支持搜索集合中的字符串内容(string content)。</p></li><li><p>Hashed(散列) Index<br>  为了支持基于散列的分片，MongoDB提供了散列索引类型，它索引字段值的散列值。但只支持相等的匹配，而不能支持基于范围的查询。</p></li></ul><p><br></p><p><strong>Index Properties(特性)</strong></p><ul><li><p>Unique Index<br>  索引的唯一性是MongoDB拒绝索引字段的重复值。</p></li><li><p>Partial Index<br>  部分索引仅索引复合指定过滤器表达式的集合中的文档。</p></li><li><p>Sparse(稀疏) Index<br>  索引的稀疏属性确保索引仅包含具有索引字段的文档的条目，跳过没有索引字段的文档。</p></li><li><p>TTL Index<br>  TTL索引是MongoDB可以用来在一定时间后自动从集合中删除文档的特殊索引。对于某些类型的消息，如机器生成的事件数据，日志和会话信息等，只需在数据库库中保存有限的时间，这是非常理想的。</p></li></ul><p><br></p><p><strong>Index Use</strong><br>索引能够提高读操作的效率。</p><p><br></p><p><strong>Index and Collation</strong><br>要使用索引进行字符串比较，操作还必须指定相同的排序规则。</p><p><br><br><strong>Coverd Query</strong><br>当查询条件和查询投影仅包含索引字段时，MongoDB将直接从索引返回结果，而不扫描任何文档或将文档带入内存。</p><p><br></p><h2 id="Single-Filed-Index"><a href="#Single-Filed-Index" class="headerlink" title="Single Filed Index"></a>Single Filed Index</h2><p><br><br><br></p><h2 id="Compound-Index"><a href="#Compound-Index" class="headerlink" title="Compound Index"></a>Compound Index</h2><p><br><br><br></p><h2 id="Multikey-Index"><a href="#Multikey-Index" class="headerlink" title="Multikey Index"></a>Multikey Index</h2><p><br><br><br></p><h2 id="Text-Index"><a href="#Text-Index" class="headerlink" title="Text Index"></a>Text Index</h2><p><br></p><h2 id="2dsphere-Index"><a href="#2dsphere-Index" class="headerlink" title="2dsphere Index"></a>2dsphere Index</h2><p><br><br><br></p><h2 id="2d-Index"><a href="#2d-Index" class="headerlink" title="2d Index"></a>2d Index</h2><p><br><br><br></p><h2 id="geoHaystack-Index"><a href="#geoHaystack-Index" class="headerlink" title="geoHaystack Index"></a>geoHaystack Index</h2><p><br><br><br></p><h2 id="Hashed-Index"><a href="#Hashed-Index" class="headerlink" title="Hashed Index"></a>Hashed Index</h2><p><br><br><br></p><h2 id="Index-Property"><a href="#Index-Property" class="headerlink" title="Index Property"></a>Index Property</h2><p><br><br><br></p><h2 id="Index-Build-Operation-on-a-Populated-Collection"><a href="#Index-Build-Operation-on-a-Populated-Collection" class="headerlink" title="Index Build Operation on a Populated Collection"></a>Index Build Operation on a Populated Collection</h2><p><br><br><br></p><h2 id="Index-Intersection"><a href="#Index-Intersection" class="headerlink" title="Index Intersection"></a>Index Intersection</h2><p><br><br><br></p><h2 id="Manage-Index"><a href="#Manage-Index" class="headerlink" title="Manage Index"></a>Manage Index</h2><p><br><br><br></p><h2 id="Measure-Index-Use"><a href="#Measure-Index-Use" class="headerlink" title="Measure Index Use"></a>Measure Index Use</h2><p><br><br><br></p><h2 id="Indexing-Strategy"><a href="#Indexing-Strategy" class="headerlink" title="Indexing Strategy"></a>Indexing Strategy</h2><p><br><br><br></p><h2 id="Index-Reference"><a href="#Index-Reference" class="headerlink" title="Index Reference"></a>Index Reference</h2><p><br></p><hr><p><br></p><h1 id="MongoDB存储"><a href="#MongoDB存储" class="headerlink" title="MongoDB存储"></a>MongoDB存储</h1><p>Storage</p><p><br></p><p>FAQ: MongoDB Storage: <a href="https://docs.mongodb.com/v3.4/faq/storage/" target="_blank" rel="noopener">https://docs.mongodb.com/v3.4/faq/storage/</a></p><p><br></p><p>存储引擎(storage engine)是MongoDB管理数据库主要的组件。</p><p>journal日志，用于数据库不正常关闭时修复数据库。有几种可选的配置项，用以平衡数据库的性能和可用性。</p><p><strong>GridFS</strong>是一个适合处理大文件的多功能的存储系统，例如那些超过16MB文档大小限制的文件。</p><p><br><br><br></p><h2 id="Storage-Engine"><a href="#Storage-Engine" class="headerlink" title="Storage Engine"></a>Storage Engine</h2><p>存储引擎是数据库的组件，负责管理数据库在内存(in-memory)和磁盘中(on-disk)两种存储方式。<br>由于不同的存储引擎在特定的工作负载下有更好的性能，所以，为你的应用程序选择一个适当的存储引擎会提高性能。</p><p><br></p><p><strong><a href="#WiredTiger存储引擎">WiredTiger</a></strong>是从MongoDB3.2开始的默认存储引擎。它非常适合大多数工作负载，并推荐使用它来进行部署。WiredTiger提供了文档级并发模型，检查点和要说等特性。</p><p><strong><a href="#MMAPv1存储引擎">MMAPv1</a></strong>是一个原始的MongoDB存储引擎，它是MongoDB3.2以前的默认存储引擎。它在大量读取和写入以及更新方面的工作负载表现良好。</p><p><strong><a href="#In-Memory存储引擎">In-Memory</a></strong>要在MongoDB Enterprise中才能获取。它不是将文档保存在磁盘上，而是将它们保留在内存中，以获得可预测的数据延迟。</p><p><br><br><br></p><h3 id="WiredTiger存储引擎"><a href="#WiredTiger存储引擎" class="headerlink" title="WiredTiger存储引擎"></a>WiredTiger存储引擎</h3><p>MongoDB3.2以后使用WiredTiger存储引擎作为默认存储引擎。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mongod --storageEngine wiredTiger</div><div class="line"></div><div class="line"></div><div class="line">#或</div><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">storage:</div><div class="line">  engine:  wriedTiger</div></pre></td></tr></table></figure><p><br></p><h4 id="文档级别并发-currency"><a href="#文档级别并发-currency" class="headerlink" title="文档级别并发(currency)"></a>文档级别并发(currency)</h4><p>WiredTiger使用文档级并发来控制写操作。因此，多个客户端可以同时修改一个集合中的不同文档。</p><p>对于大多数读写操作，WiredTiger使用乐观的并发控制。WiredTiger仅在global、database和collection-levels使用intent lock。<br>当存储引擎检测到两个操作之间的冲突时，其中一个操作将引发写冲突，从而导致MongoDB透明地重试该操作。</p><p><br></p><h4 id="快照和检查点"><a href="#快照和检查点" class="headerlink" title="快照和检查点"></a>快照和检查点</h4><p>WiredTiger users multiVersion Concurrency Control(MVCC).在操作开始时，WiredTiger向事务提供数据的实时快照。快照显示内存中数据的一致性视图。</p><p>当写入磁盘时，WiredTiger将快照中的所有数据以一致性的方式跨越所有数据文件写入磁盘。持久(durable)的数据充当数据文件中的检查点。检查点确保数据文件与最后一个检查点保持一致性，并包括最后一个检查点。</p><p>MongoDB配置WiredTiger来创建检查点(即将快照数据写入磁盘)，间隔时间为60s，或2G日志数据。</p><p>在写入新检查点期间，前一个检查点仍然有效。</p><p>当WiredTiger的元数据表被原子地更新以引用新的检查点，新的检查点将变得可访问和永久。一旦新检查点可以访问，WiredTiger就会从旧的检查点这种释放页面(free page)。</p><p><br></p><h4 id="Journal"><a href="#Journal" class="headerlink" title="Journal"></a>Journal</h4><p>WiredTiger采用预写事务日志联合检查点，用以确保数据的持久性(durability)。<br>你也可以关闭journal功能来减少维护日志的开销。</p><p>WiredTiger日志坚持在检查点之间修改所有数据。如果MongoDB在检查点之间退出，它将使用日志重放自上一个检查点以来修改的所有数据。</p><p>WiredTiger journal使用snappy compression Library来进行压缩。</p><p><strong>WiredTiger最小日志记录的大小是128Byte，如果日志记录小于等于128Byte，则WiredTiger不会压缩日志文件。</strong></p><p>对于以standalone模式运行的mongo实例，关闭journal日志功能意味着当MongoDB意外地在检查点之前退出时，你将丢失一些数据修改。对于复制集成员，复制过程和恒提供足够的持久性保证。</p><p><br></p><h4 id="Compression"><a href="#Compression" class="headerlink" title="Compression"></a>Compression</h4><p>使用WiredTiger，MongoDB支持压缩所有的collections和indexes。通过使用CPU进行压缩，减少了储存空间的使用。</p><p>默认地，WiredTiger使用snappy compression library对所有的collections进行block压缩，对所有索引进行前缀(prefix)压缩。</p><p>对于collection，也可以使用zlib进行block压缩。可通过<code>storage.wiredTiger.collectionConfig.blockCompressor</code>设置压缩方法。<br>对于index，使用<code>storage.wiredTiger.indexConfig.prefixCompression</code>关闭prefix压缩。</p><p>对于大多数工作负载，默认压缩设置平衡了存储效率和处理要求。</p><p><br></p><h4 id="Memory-Use"><a href="#Memory-Use" class="headerlink" title="Memory Use"></a>Memory Use</h4><p>对于WiredTiger，MongodB使用WiredTiger内部缓存和文件缓存。</p><p>从MongoDB3.4开始，WiredTiger内部缓存将使用一下两种类型中更大的一种：</p><ul><li>50% of RAM minus 1GB</li><li>256MB</li></ul><p><br></p><p>WiredTiger内部缓存中的数据与磁盘上格式的数据使用不同的表现形式：</p><ul><li>文件系统缓存的数据与磁盘上的格式相同，包括了对数据文件进行压缩的好处。操作系统使用文件系统缓存来减少磁盘I/O</li><li>指标加载在WiredTiger内部缓存有一个不同的磁盘上的数据表示格式，但仍然可利用 prefix index compression来减少内存使用。索引前缀压缩重复数据删除常用前缀的索引字段。</li><li>WiredTiger内存缓存的collection数据是未压缩的，并使用与磁盘格式不同的表现形式。block compression能够节省大量磁盘空间，但必须解压缩数据后服务器才能操作。</li></ul><p><strong>通过文件系统缓存，MongoDB自动使用 (WiredTiger缓存或其他进程不使用)空闲内存。</strong></p><p>调整WiredTiger内部缓存的大小，避免将WiredTiger的内初缓存值增加到默认值之上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#命令行</div><div class="line">--wiredTigerCacheSizeGB</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#配置文件</div><div class="line">storage.wiredTiger.engineConfig.cacheSizeGB</div></pre></td></tr></table></figure><p><br></p><h4 id="Change-Standalone-to-wiredTiger"><a href="#Change-Standalone-to-wiredTiger" class="headerlink" title="Change Standalone to wiredTiger"></a>Change Standalone to wiredTiger</h4><p>MongoDB version 3.0 or later in order to use wiredTiger storage engine!</p><p>过程：</p><ol><li>mongod is running</li><li>export data using mongodump</li><li>create a data directory for the new mongod running with wiredTiger</li><li>start mongod with wiredTiger</li><li>upload the dumpdata using mongorestore</li></ol><p><br></p><h4 id="Change-Replica-Set-to-wiredTiger"><a href="#Change-Replica-Set-to-wiredTiger" class="headerlink" title="Change Replica Set to wiredTiger"></a>Change Replica Set to wiredTiger</h4><p>Replica sets can have members with different storage engines.<br>因此，你可以把所有成员的存储引擎更换为WiredTiger。<br>MongoDB version 3.0 or later in order to use wiredTiger storage engine!</p><p>过程：</p><ol><li>shutdown the secondary member.–<code>db.shutdownServer</code></li><li>prepare a data directory for the new mongod running with wiredTiger</li><li>start mongod with wiredTiger</li><li>repeat the procedure for other replica set secodaries you wish to upgrade</li></ol><p><br></p><h4 id="Change-Sharded-Cluster-to-wiredTiger"><a href="#Change-Sharded-Cluster-to-wiredTiger" class="headerlink" title="Change Sharded Cluster to wiredTiger"></a>Change Sharded Cluster to wiredTiger</h4><p>if the shard is a standalone, see <a href="#Change Standalone to wiredTiger">Change Standalone to wiredTiger</a>;<br>if the shard is a replica set, see <a href="#Change Replica Set to wiredTiger">Change Replica Set to wiredTiger</a>.</p><p><br></p><h5 id="Change-config-server-to-wriedTiger"><a href="#Change-config-server-to-wriedTiger" class="headerlink" title="Change config server to wriedTiger"></a>Change config server to wriedTiger</h5><p>如果你打算更新config server使用WiredTiger，那么必须全部更新！</p><p>过程：</p><ol><li>disable the balancer–<code>sh.disableBalancer()</code></li><li>shutdown the third config server to ensure read-only metadata.–<code>db.shutdownServer()</code></li><li>export the data of the second config server with mongodump</li><li>For the second config server, create a new data directory for use with WiredTiger.</li><li>Stop the second config server.–<code>db.shutdownServer()</code></li><li>Start the second config server mongod with the WiredTiger storage engine option.</li><li>Upload the exported data using mongorestore to the second config server.</li><li>Shut down the second config server to ensure read-only metadata.–<code>db.shutdownServer()</code></li><li>Restart the third config server to prepare for its upgrade.</li><li>Export the data of the third config server with mongodump</li><li>For the third config server, create a new data directory for use with WiredTiger.</li><li>Stop the third config server.</li><li>Start the third config server with the WiredTiger storage engine option.</li><li>Upload the exported data using mongorestore to the third config server.</li><li>Export data of the first config server with mongodump.</li><li>For the first config server, create a new data directory for use with WiredTiger.</li><li>Stop the first config server.</li><li>Start the first config server with the WiredTiger storage engine option.</li><li>Upload the exported data using mongorestore to the first config server.</li><li>Restart the second config server to enable writes to the sharded cluster’s metadata</li><li>Re-enable the balancer.–<code>sh.startBalancer()</code></li></ol><p><br><br><br></p><h3 id="MMAPv1存储引擎"><a href="#MMAPv1存储引擎" class="headerlink" title="MMAPv1存储引擎"></a>MMAPv1存储引擎</h3><p><br><br><br></p><h3 id="In-Memory存储引擎"><a href="#In-Memory存储引擎" class="headerlink" title="In-Memory存储引擎"></a>In-Memory存储引擎</h3><p><br><br><br></p><h2 id="Journaling-1"><a href="#Journaling-1" class="headerlink" title="Journaling"></a>Journaling</h2><p><strong>为了在发生故障时提供持久性，MongoDB使用了县写日志记录到磁盘的日志文件。</strong><br>To provide durability in the event of a failure, MongoDB uses write ahead logging to on-disk journal files.</p><p><br></p><h3 id="journaling-and-the-wiredTiger-storage-engine"><a href="#journaling-and-the-wiredTiger-storage-engine" class="headerlink" title="journaling and the wiredTiger storage engine"></a>journaling and the wiredTiger storage engine</h3><p>本节所指的log指的是WiredTiger的 write-ahead log(journal)，而不是MongoDB日志文件。</p><p>WiredTiger使用checkpoints在磁盘上提供一致的数据视图，并允许MongoDB从上一个checkpoint修复。然而，如果MongoDB在检查点之间以外退出，则需要使用journaling来修复上次检查点之后发生的信息。</p><p>使用journaling的修复过程：</p><ol><li>在数据文件中查找上一个检查点的标识符(identifier)</li><li>在journaling文件中搜索与上一个检查点标识符匹配的记录</li><li>应用自上一个检查节点依赖journal文件中的操作</li></ol><p><br></p><h4 id="journal-process"><a href="#journal-process" class="headerlink" title="journal process"></a>journal process</h4><p>通过journaling，WiredTiger为每个客户端启动的写操作创建一个journal记录。journal record包括有初始写入引起的任何内部写入操作。</p><p>例如，集合中文档的更新可能导致对index的修改，WiredTiger创建一个包含update操作及其相关index修改的单独的journal record。</p><p>MongoDB将WiredTiger配置为in-memory的buffering来存储日志记录。线程坐标来分配和复制到他们的缓冲区的一部分。所有日志记录高达128KB是缓存的。<br>WiredTiger根据如下条件将journal record同步到磁盘。</p><ul><li>每50ms</li><li>MongoDB在WiredTiger中设置60s为间隔的用户数据检查点或2GBjournal数据已被写入，以先发生为准。</li><li>如果写操作包含有<code>j:true</code>的写关注点，则WiredTiger强制对journal文件进行同步。</li><li>MongoDB限制了journal文件大小为100MB，因此WiredTiger每100MB就会创建一个新的journal文件。当创建了一个新的journal文件时，WiredTiger会同步上一个journal文件。</li></ul><p><strong>在写操作之间，虽然日志记录保留在WiredTiger缓冲区中，但在mongod实例hard shutdown之后可能会丢失更新。</strong></p><p><img src="/images/Zabbix/journalSize.png" alt="Journal大小"></p><p><br></p><h4 id="Journal-File"><a href="#Journal-File" class="headerlink" title="Journal File"></a>Journal File</h4><p>MongoDB在数据库目录下创建一个<code>journal</code>子目录存放journal文件。名字为<code>WiredTigerLog.&lt;sequence&gt;</code>，从<code>0000000001</code>开始。如上图所示。</p><p>Journal文件包含对每一个写操作的记录。每个记录都有唯一的标识符。</p><p>MongoDB将WiredTiger配置为对journal数据使用快速压缩。最小日志大小为128KB，如果小于此，WiredTiger不会压缩此记录。最大大小为100MB，超过此，WiredTiger会创建一个新的journal文件。</p><p>MongoDB自动删除旧日志文件，以维护从上一个检查点恢复所需的文件。</p><p><br><br><br></p><h3 id="Journaling-and-the-MMAPv1-Storage-Engine"><a href="#Journaling-and-the-MMAPv1-Storage-Engine" class="headerlink" title="Journaling and the MMAPv1 Storage Engine"></a>Journaling and the MMAPv1 Storage Engine</h3><p><br><br><br></p><h3 id="Journaling-and-the-In-Memory-Storage-Engine"><a href="#Journaling-and-the-In-Memory-Storage-Engine" class="headerlink" title="Journaling and the In-Memory Storage Engine"></a>Journaling and the In-Memory Storage Engine</h3><p><br><br><br></p><h2 id="Manage-Journaling"><a href="#Manage-Journaling" class="headerlink" title="Manage Journaling"></a>Manage Journaling</h2><p>MongoDB uses write ahead logging to an on-disk journal to guarantee write operation durability.</p><p>启用journal后，如果MongodB意外退出，则程序可以恢复写入了journal日志文件的所有内容。MongoDB将在重启时重新应用写操作，并保持一致性。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><br></p><h4 id="Enable-journaling"><a href="#Enable-journaling" class="headerlink" title="Enable journaling"></a>Enable journaling</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mongod --jouranl</div><div class="line"></div><div class="line"></div><div class="line">##或</div><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">storage:</div><div class="line">  journal:</div><div class="line">    enabled: true</div></pre></td></tr></table></figure><p><br></p><h4 id="Disable-journaling"><a href="#Disable-journaling" class="headerlink" title="Disable journaling"></a>Disable journaling</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mongod --noJournal</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###或</span></div><div class="line">修改配置文件</div></pre></td></tr></table></figure><blockquote><p><strong>警告</strong><br>不要在生产系统上禁用日记功能。<br>如果在一个副本集上使用<code>--noJournal</code>关闭了journal日志，则还应该修改副本集配置文件。</p></blockquote><p><br></p><h4 id="Monitor-journal-status"><a href="#Monitor-journal-status" class="headerlink" title="Monitor journal status"></a>Monitor journal status</h4><ul><li><code>serverStatus</code></li></ul><p><br></p><h4 id="Recover-data-after-unexpected-shutdown"><a href="#Recover-data-after-unexpected-shutdown" class="headerlink" title="Recover data after unexpected shutdown"></a>Recover data after unexpected shutdown</h4><p>在奔溃后重启时，MongoDB会在服务器可用之前replay journal日志记录中的所有日志文件。</p><p><br><br><br></p><h2 id="GridFS"><a href="#GridFS" class="headerlink" title="GridFS"></a>GridFS</h2><p>GridFS是一种用于存储和检索超过BSON文档大小限制值16MB的文件规范。</p><p>GridFS没有将单个文件存储到单个的文档中，而是将文件分割成部分(parts)或块(chunks)，并将每个块存储到单独的文档中。默认情况下，GridFS的块大小为255KB。也就是说，GridFS将文件分成255KB的块，最后一块大小就不确定了。</p><p>GridFS使用两个集合来存储文件。一个存储文件块(chunks)，另一个存储文件元数据(metadata)。</p><p>当你查询(query)GridFS文件时，驱动程序会根据需要重新组装这些块。你可对通过GridFS存储的文件执行范围查询。还可以从任意文件部分访问信息。</p><p>GridFS不仅可用于存储超过16MB的文件，还可用于存储需要访问的任何文件，而不必将整个文件加载到内存中。</p><p><br></p><h3 id="何时使用GridFS"><a href="#何时使用GridFS" class="headerlink" title="何时使用GridFS"></a>何时使用GridFS</h3><p>在MongoDB中，使用GridFS存储大于16MB的文件。</p><p>某些情况下，在MongoDB数据库中存储大文件可能比在系统级文件系统上更有效。</p><ul><li>如果文件系统限制了一个目录中的文件数量，则可使用GridFS存储所需的文件</li><li>当你想要访问大文件的部分信息时而不想将整个文件加载到内存中时，可使用GridFS收回文件的各个部分，而不必将整个文件读入内存</li><li>当你希望文件和元数据自动同步并部署在多个系统和设施中时，可使用GridFS</li></ul><p>如果需要原子地(atomically)更新整个文件的内容，请不要使用GridFS。作为一种选择，你可以为每个文件存储多个版本，并在元数据中指定该文件的当前版本。</p><p>此外，如果文件都是小于16MB的BSON文件大小限制，则考虑手动存储在一个单文档中，而不必使用GridFS。</p><p><br><br><br></p><h3 id="使用GridFS"><a href="#使用GridFS" class="headerlink" title="使用GridFS"></a>使用GridFS</h3><p>使用GridFS存储和检索文件，请使用如下任何一项：</p><ul><li>A MongoDB Driver</li><li>The mongofile cmd-line tool</li></ul><p><br><br><br></p><h3 id="GridFS集合"><a href="#GridFS集合" class="headerlink" title="GridFS集合"></a>GridFS集合</h3><p>GridFS把文件存储在两个集合里：</p><ol><li>chunks collection<ul><li>stores the binary chunks</li></ul></li><li>files collection<ul><li>stores the file’s metadata</li></ul></li></ol><p>GridFS将这些集合放在一个普通的存储区(bucket)中，每个存储区前面加上名称。默认地，GridFS使用两个名为<code>fs</code>的存储区集合：</p><ol><li>fs.files</li><li>fs.chunks</li></ol><p>币可以选择一个不同的存储区名字，也可以在一个数据库中创建多个存储区。</p><p><br></p><h4 id="The-chunks-collection"><a href="#The-chunks-collection" class="headerlink" title="The chunks collection"></a>The chunks collection</h4><p>块集合中的每个文档都表示一个独立的文件块。格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;_id&quot;: &lt;ObjectId&gt;,</div><div class="line">    &quot;files_id&quot;: &lt;ObjectId&gt;,</div><div class="line">    &quot;n&quot;: &lt;num&gt;,</div><div class="line">    &quot;data&quot;: &lt;binary&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>块集合中的文档包含如下字段：</p><ul><li>chunks._id<ul><li>The unique ObjectId of the chunk</li></ul></li><li>chunks.files_id<ul><li>The _id of the “parent” document</li></ul></li><li>chunks.n<ul><li>The sequence number of the chunk，GridFS从0开始标号所有块</li></ul></li><li>chunks.data<ul><li>BSON Binary type</li></ul></li></ul><p><br></p><h4 id="file集合"><a href="#file集合" class="headerlink" title="file集合"></a>file集合</h4><p>GridFS的file集合，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;_id&quot;: &lt;ObjectId&gt;,</div><div class="line">    &quot;length&quot;: &lt;num&gt;,</div><div class="line">    &quot;chunkSize&quot;: &lt;num&gt;,</div><div class="line">    &quot;uploadData&quot;: &lt;timestamp&gt;,</div><div class="line">    &quot;md5&quot;: &lt;hash&gt;,</div><div class="line">    &quot;filename&quot;: &lt;string&gt;,</div><div class="line">    &quot;contentType&quot;: &lt;string&gt;,</div><div class="line">    &quot;aliases&quot;: &lt;string array&gt;,</div><div class="line">    &quot;metadata&quot;: &lt;any&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>files._id<ul><li>The unique identifier for this document</li></ul></li><li>files.length<ul><li>The size of the document in bytes</li></ul></li><li>files.chunSize<ul><li>The size of each chunk in bytes</li></ul></li><li>files.uploadDate<ul><li>The date the document was first stored by GridFS</li></ul></li><li>files.md5<ul><li>An MD5 hash of the complete file</li></ul></li><li>file.filename<ul><li>Optional. A human-readable name for the GridFS file</li></ul></li><li>file.contentType<ul><li>Optional. A valid MIME type for the GridFS file</li></ul></li><li>files.aliases<ul><li>Optional. An array of alias strings</li></ul></li><li>files.metadata<ul><li>Optional. The metadata field may be of any data type and can hold any additional information you want to store</li></ul></li></ul><p><br></p><h3 id="GridFS索引"><a href="#GridFS索引" class="headerlink" title="GridFS索引"></a>GridFS索引</h3><p>为了提高效率，GridFS在每个chunks and files collections上使用索引。</p><p><br></p><h4 id="chunks索引"><a href="#chunks索引" class="headerlink" title="chunks索引"></a>chunks索引</h4><p>GridFS使用一个唯一的、混合的索引。在chunks集合上使用<code>files_id</code>和<code>n</code>字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.fs.chunks.find( &#123; files_id: myFileID &#125; ).sort( &#123; n:1 &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#创建索引</div><div class="line">db.fs.chunks.createIndex(&#123; files_id: 1, n:1 &#125;, &#123; unique: true &#125;);</div></pre></td></tr></table></figure><p><br></p><h4 id="files索引"><a href="#files索引" class="headerlink" title="files索引"></a>files索引</h4><p>GridFS使用索引，在files集合上使用<code>filename</code>和<code>uploadDate</code>字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.fs.files.find(&#123; filename: myFileName &#125;).sort(&#123; uploadDate: 1 &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#创建索引</div><div class="line">db.fs.files.createIndex(&#123; filename:1, uploadDate: 1 &#125;);</div></pre></td></tr></table></figure><p><br></p><h3 id="分片GridFS"><a href="#分片GridFS" class="headerlink" title="分片GridFS"></a>分片GridFS</h3><p>如果需要分片GridFS数据存储，使用chunks集合设置: <code>{ files_id: 1, n:1}</code> or <code>{ files_id: 1 }</code>作为分片key索引。</p><p>不能对chunks集合使用hash分片。</p><p>files_id是一个ObjectId。</p><p><br><br><br></p><hr><p><br></p><h1 id="MongoDB安全"><a href="#MongoDB安全" class="headerlink" title="MongoDB安全"></a>MongoDB安全</h1><p>Security</p><p><br></p><p>MongoDB提供了各种特性(features)，如身份认证(authentication)、访问控制(access control)、加密(encryption)，以保护MongoDB部署。</p><p><br><br><br></p><h2 id="Security-Checklist"><a href="#Security-Checklist" class="headerlink" title="Security Checklist"></a>Security Checklist</h2><ul><li>启用访问控制和强制认证<ul><li>Enable Access Control and Enforce Authentication</li><li>可使用默认的MongoDB认证机制或现有的外部框架</li></ul></li><li>配置基于角色的访问控制<ul><li>Configure Role-Based Access Control</li><li>首先创建administrator，接着在创建其他用户</li><li>创建角色，定义一组用户所需的确切访问权限</li></ul></li><li>加密通信<ul><li>Encrypt Communication</li><li>配置MongoDB使用TLS/SSL加密连接</li></ul></li><li>加密和保护数据<ul><li>Encrypt and Protect Data</li></ul></li><li>限制网络曝光<ul><li>Limit Network Exposure</li><li>确保MongoDB运行在一个受信任的网络环境上，并限制MongoDB的监听接口</li></ul></li><li>审计系统活动<ul><li>Audit System Activity</li><li>跟踪对数据库配置和数据的访问和更改</li></ul></li><li>使用专用用户运行MongoDB<ul><li>Run MongoDB with a Dedicated User</li><li>使用专用的操作系统用户账户运行MongoDB进程</li></ul></li><li>使用安全配置选项运行MongoDB<ul><li>Run MongoDB with Secure Configuration Options</li><li>MongoDB为了支持某些服务端操作执行：<code>mapReduce</code>,<code>group</code>,<code>$where</code></li><li>如果你不使用这些操作，请关闭服务器端脚本执行<code>--noscripting</code></li></ul></li><li>请求一个安全技术执行指南<ul><li>Request a Security Technical Implementation Guide</li></ul></li><li>考虑安全标准合格性<ul><li>Consider Security Standards Compliance</li></ul></li></ul><p><br><br><br></p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>Authentication</p><p><br></p><p>要作为用户进行身份认证，必须提供用户名(username)，密码(password)和与用户关联的身份验证数据库(authentication database)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mongo --host --username --password --authenticationDatabase</div><div class="line"></div><div class="line"></div><div class="line">#Or</div><div class="line">mongo</div><div class="line">&gt;use &lt;authenticationDatabase&gt;</div><div class="line">&gt;db.auth(&apos;username&apos;,&apos;password&apos;)</div></pre></td></tr></table></figure><p><br></p><ul><li>认证机制<ul><li>Authentication Mechanisms</li><li>MongoDB支持多种认证机制<ul><li>SCRAM-SHA-1</li><li>MongoDB Challenge and Response (MONGODB-CR)</li><li>x.509 Certificate Authentication</li><li>LDAP proxy authentication(MongoDB Enterprise)</li><li>Kerberos authentication(MongoDB Enterprise)</li></ul></li></ul></li><li>内部认证<ul><li>Internal Authentication</li><li>除了验证客户端的身份外。MongoDB还可以要求副本集和分片集的成员对其各自的成员进行认证</li></ul></li></ul><p><br></p><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>Users</p><p><br></p><p>要在MongoDB中验证客户端，必须向MongoDB添加相应的用户。</p><ul><li>用户管理接口<ul><li>User Management Interface</li><li>使用<code>db.createUser()</code>方法创建用户</li><li>添加用户时，可为用户分配角色以授予权限</li><li>在数据库管理中创建的第一个用户应该是具有管理其他用户权限的administrator</li><li>也可以更新/删除一个已经存在的用户的权限</li></ul></li><li>认证数据库<ul><li>Authentication Database</li><li>在特定的数据库中创建用户，这个数据库是用户的认证库</li><li>用户名和认证库充当该用户的唯一标识符。如果两个用户具有相同的用户名，但是在不同的数据库中创建，则它们是两个单独的用户</li><li>用户可拥有不同数据库的权限，而不限于认证库</li><li>通过数据库角色给用户分配相应的权限</li></ul></li><li>认证一个用户<ul><li>Authentication Database</li><li>使用用户名、密码、认证库验证一个用户</li></ul></li><li>集中的用户数据<ul><li>Centralized User Data</li><li>MongoDB将所有的用户名、密码和认证库信息，保存到admin库的syste.users集合中</li><li>使用用户管理命令而不要直接访问这个集合</li></ul></li><li>分片集群用户<ul><li>Sharded Cluster Users</li></ul></li></ul><p><br></p><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><p>Add Users</p><p><br></p><p>MongoDB使用基于角色的访问控制(RBAC)来确定用户的访问权限。用户被授予一个或多个角色，这些角色确定用户对MongoDB资源的访问或权限，以及用户可以执行的操作。<br>用户应该只具有确保系统最小权限所需要的最小权限。</p><p><br></p><p><strong>前提(Prerequisites)</strong></p><p>对于用户创建，你必须拥有以下权限</p><ul><li>在数据库中创建一个新用户，必须在数据库资源上有<code>createUser</code>操作</li><li>对一个用户授权角色，必须在角色数据库中有<code>grantRole</code>操作</li></ul><p><br></p><p><strong>栗子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">use admin</div><div class="line">db.createUser(</div><div class="line">&#123;</div><div class="line">user: &apos;zhang&apos;,</div><div class="line">        pwd: &apos;passwd123&apos;,</div><div class="line">        roles: [</div><div class="line">        &#123; role: &apos;root&apos; &#125;,</div><div class="line">            &#123; db: &apos;admin&apos; &#125;</div><div class="line">        ]</div><div class="line">&#125;</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line">#在配置文件中开启用户认证</div><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">security:</div><div class="line">    authorization: enabled</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="认证机制"><a href="#认证机制" class="headerlink" title="认证机制"></a>认证机制</h3><p>Authentication Mechanisms</p><p><br></p><h4 id="SCRAM-SHA-1"><a href="#SCRAM-SHA-1" class="headerlink" title="SCRAM-SHA-1"></a>SCRAM-SHA-1</h4><p><br></p><h4 id="MONGODB-CR"><a href="#MONGODB-CR" class="headerlink" title="MONGODB-CR"></a>MONGODB-CR</h4><p><br></p><h4 id="x-509"><a href="#x-509" class="headerlink" title="x.509"></a>x.509</h4><p>MongoDB对于客户端身份认证和副本集、分片集成员的内部认证支持x.509证书认证。</p><p>x.509证书认证需要安全的TLS/SSL连接。</p><p><br></p><p><strong>证书授权(Certificate Authority)</strong></p><p>在生产使用中，MongoDB的部署应该使用由认证机构签名和生成的有效证书。</p><p><br></p><p><strong>Client x.509 Certificates</strong></p><p>要想服务器验证身份，客户端可以使用x.509证书而不是用户名和密码。</p><p>Client Certificate Requirements：</p><ul><li>单个证书颁发机构(CA)必须同时为客户端和服务器颁发证书</li><li><p>客户端证书必须包含如下字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">keyUsage = digitalSignature</div><div class="line">extendedKeyUsage = clientAuth</div></pre></td></tr></table></figure></li><li><p>每个唯一的MongoDB用户必须有一个唯一的证书</p></li><li>一个客户端x.509证书的主题，包含了可辨识名称(DN)。必须不同于成员x.509证书</li></ul><p><br></p><p>MongoDB user and $external database</p><p>若要使用客户端证书进行认证，必须先将客户端证书中的subject值添加为MongoDB用户。每个唯一的x.509客户端证书对因孤独一个MongoDB用户。</p><p>在$external database中添加用户，认证库便是外部数据库。</p><p><br></p><p>Authenticate</p><p>使用x.509客户端进行身份验证，请通过TLS/SSL连接到MongoDB。<code>--ssl</code> and <code>--sslPEMKeyFile</code></p><p><br></p><p><strong>Member x.509 Certificates</strong></p><p>对于内部认证，分片集和副本集的成员可以使用x.509证书来代替使用SCRAM-SHA-1认证机制的keyfile。</p><p><strong>Member Certificate Requirements</strong></p><ul><li>CA必须为所有分片集，副本集成员颁发x.509证书</li><li>成员证书的主题中找到Distinguished Name(DN)必须为以下至少一个属性指定非空值：Organization(O)，Organization Unit(OU)，Domain Component(DC)</li><li>组织属性，组织单元属性和域组件必须与其他集群成员的证书相匹配。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CN=host1,OU=Dept1,O=MongoDB,ST=NY,C=US</div><div class="line">C=US, ST=CA, O=MongoDB, OU=Dept1, CN=host2</div></pre></td></tr></table></figure></li></ul><p><br></p><p><strong>MongoDB Configuration</strong></p><ul><li>配置文件：security.clusterAuthMode and net.ssl.clusterFile</li><li>cmd-line options: –clusterAuthMode and –sslClusterFile</li></ul><p><br></p><p><strong>Member Certificate and PEMKeyFile</strong></p><ul><li>配置文件： net.ssl.PEMKeyFile</li><li>cmd-line option: –sslPEMKeyFile</li></ul><p><br><br><br></p><h3 id="Enterprise-Authentication-Mechanisms"><a href="#Enterprise-Authentication-Mechanisms" class="headerlink" title="Enterprise Authentication Mechanisms"></a>Enterprise Authentication Mechanisms</h3><p><br><br><br></p><h3 id="MongoDB认证和角色"><a href="#MongoDB认证和角色" class="headerlink" title="MongoDB认证和角色"></a>MongoDB认证和角色</h3><p>要想了解MongoDB的权限必须先了解如下一些关键字：</p><ul><li>user<ul><li>用户，用于提供客户端连接MongoDB的认证账户</li></ul></li><li>role<ul><li>角色，数据权限的集合，创建用户的时候必须要指定对应的角色，否则用户无法操作数据库</li></ul></li><li>resource<ul><li>资源，包括database或collection 也可以是database和collection的组合</li></ul></li><li>actions<ul><li>权限操作，定义了 user 能够对 resource document 执行的操作。如 增、删、改、查</li></ul></li><li>privilege<ul><li>权限，privilege 是一组 resource 和 action的组合，对资源拥有什么操作称为权限</li></ul></li><li>authenticationDatabase<ul><li>认证库，即创建角色或用户时所在的库</li></ul></li></ul><p><br></p><h4 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h4><p>MondoDB支持基于角色的访问控制（RBAC）来管理对MongoDB系统的访问。一个用户可以被授权一个或多个角色以决定该用户对数据库资源和操作的访问权限。在权限以外，用户是无法访问系统的。</p><p>数据库角色在创建用户的role参数中设置。角色分为內建角色和自定义角色。</p><p><br></p><p><strong>内建角色</strong></p><ul><li>数据库用户角色<ul><li>read：允许用户读取指定数据库</li><li>readWrite：允许用户读写指定数据库</li></ul></li><li>数据库管理员角色<ul><li>dbAdmin：允许用户进行索引创建、删除，查看统计或访问system.profile，但没有角色和用户管理的权限</li><li>userAdmin：提供了在当前数据库中创建和修改角色和用户的能力</li><li>dbOwner：提供对数据库执行任何操作的能力。这个角色组合了readWrite、dbAdmin和userAdmin角色授权的特权</li></ul></li><li>集群管理角色<ul><li>hostManager：提供监视和管理服务器的能力</li><li>clusterManager：在集群上提供管理和监视操作。可以访问配置和本地数据库，这些数据库分别用于分片和复制</li><li>clusterMonitor：提供对监控工具的只读访问</li><li>clusterAdmin：提供最强大的集群管理访问(副本集、分片、主从等)。组合了clusterManager、clusterMonitor和hostManager角色的能力，还提供了dropDatabase操作</li></ul></li><li>备份恢复角色<ul><li>backup：提供备份数据所需的能力</li><li>restore： 提供使用mongorestore恢复数据的能力</li></ul></li><li>所有数据库角色<ul><li>readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限</li><li>readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限</li><li>userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</li><li>dbAdminAnyDataBase：只在admin数据库中可用，赋予用户所有数据库的adAdmin权限</li></ul></li><li>超级用户角色<ul><li>root：超级权限，只能针对admin库</li></ul></li><li>内部角色<ul><li>__system：提供对数据库中任何对象的任何操作的特权</li></ul></li></ul><p><br></p><p><strong>自定义角色</strong></p><p>MongoDB内置角色一般来说都是够用的，但当内置角色不满足需求时就可以自定义角色了。使用 db.createRole() 方法来自定义角色。</p><p>只能在admin库中创建角色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">use admin</div><div class="line">db.createRole(</div><div class="line">    &#123;</div><div class="line">        role:&lt;role_name&gt;,#定义角色名称</div><div class="line">        privilege:[    #权限集</div><div class="line">            &#123; resource:&#123;cluster:true, actions:[&lt;action_name&gt;] &#125;,</div><div class="line">            &#123; resource: &#123;db:&lt;db_name&gt;, collection:&lt;coll_name&gt; &#125;,</div><div class="line">        &#123; actions:[&lt;action_name&gt;] &#125;    #定义对这个库或集合可进行的权限操作，这是一个数组</div><div class="line">        ],</div><div class="line">        roles:[ &#123; role:&lt;role_name&gt;, db:&lt;db_name&gt; &#125; ]    #是否继承其他的角色</div><div class="line">    &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p>角色创建完毕后MongoDB会在系统库admin下创建一个collection名叫 system.roles，里面存储的即是角色相关的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.system.roles.find()</div></pre></td></tr></table></figure><p><br></p><h4 id="操作角色"><a href="#操作角色" class="headerlink" title="操作角色"></a>操作角色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#查看角色</div><div class="line">db.getRole()</div><div class="line"></div><div class="line"></div><div class="line">#角色继承</div><div class="line"></div><div class="line">#角色授权</div><div class="line">db.grantRolesToRole()</div><div class="line"></div><div class="line">#角色移权</div><div class="line">db.revokeRolesfromRole()</div></pre></td></tr></table></figure><p><br></p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p><strong>创建用户</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">db.createUser(&#123;</div><div class="line">    user:&quot;xxx&quot;, pwd:&quot;xxxx&quot;, customDate:&quot;xxx&quot;,</div><div class="line">    roles:[&#123;    #指定角色名称以及认证库</div><div class="line">        role:&quot;xxx&quot;, db:&quot;xxxx&quot;</div><div class="line">    &#125;]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><br></p><p><strong>开启认证</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">vim /etc/mongo.conf</div><div class="line"></div><div class="line">security:</div><div class="line">    authorization：enabled</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">db.auth(&quot;user&quot;,&quot;passwd&quot;)    #在use db后</div><div class="line">或</div><div class="line">mongo -u user -p passwd --authenticationDatabase xxx</div><div class="line">#在哪个库创建的用户就需要使用哪个库进行认证</div></pre></td></tr></table></figure><p><br></p><p><strong>查看用户</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.getUser(&quot;user&quot;)</div><div class="line">db.system.users.find()</div></pre></td></tr></table></figure><p><br></p><p><strong>删除用户</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.dropUser(&quot;user&quot;)</div><div class="line">db.dropAllUsers()</div></pre></td></tr></table></figure><p><br></p><p><strong>添加用权限</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.grantRolesToUser()</div></pre></td></tr></table></figure><p><br></p><p><strong>修改用户密码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.changeUserPassword(&quot;user&quot;,&quot;new_passwd&quot;)</div></pre></td></tr></table></figure><p><br></p><p>在MongoDB中删除库和集合并不会级联删除对应的角色和用户。因此如果想彻底删除对应的业务应该先删除库与其对应的角色和用户。</p><p>如果既想实现精细化权限控制又想简化用户管理，原则上建议只给开发创建一个账户，并且使用admin做认证库，这样可以避免清理过期业务库而导致无法登陆的问题。</p><p><br><br><br></p><h3 id="内部认证"><a href="#内部认证" class="headerlink" title="内部认证"></a>内部认证</h3><p>Internal Authentication</p><p><br></p><p>可以对副本集和分片集成员进行验证。<br>对于成员的内部认证，MongoDB可以使用keyfile或x.509证书。</p><p><br></p><p><strong>KeyFile</strong></p><p>keyfiles的内容作为成员的共享密码，其长度必须在6-1024个字符之间，只能包含base64 set中的字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">openssl rand -base64 512 &gt; /etc/mongodb.keyfile</div><div class="line">chmod 600 /etc/mongodb.keyfile</div><div class="line">chown mongod:mongod /etc/mongodb.keyfile</div><div class="line"></div><div class="line"></div><div class="line">#配置文件：security.keyFile</div><div class="line">#cmd-line option: --keyFile</div><div class="line"></div><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">security:</div><div class="line">  authorization: enabled</div><div class="line">  keyFile: &quot;/etc/mongodb.keyfile&quot;</div><div class="line">  clusterAuthMode: &quot;keyFile&quot;</div></pre></td></tr></table></figure><p><br></p><p><strong>x.509</strong></p><p>内部认证使用x.509进行验证。</p><ul><li>CA必须为所有分片集，副本集成员颁发x.509证书</li><li>成员证书的主题中找到Distinguished Name(DN)必须为以下至少一个属性指定非空值：Organization(O)，Organization Unit(OU)，Domain Component(DC)</li><li>组织属性，组织单元属性和域组件必须与其他集群成员的证书相匹配。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CN=host1,OU=Dept1,O=MongoDB,ST=NY,C=US</div><div class="line">C=US, ST=CA, O=MongoDB, OU=Dept1, CN=host2</div></pre></td></tr></table></figure></li></ul><p><br></p><p><strong>MongoDB Configuration</strong></p><ul><li>配置文件：security.clusterAuthMode and net.ssl.clusterFile</li><li>cmd-line options: –clusterAuthMode and –sslClusterFile</li></ul><p><br></p><h4 id="在副本集中强制秘钥文件访问控制"><a href="#在副本集中强制秘钥文件访问控制" class="headerlink" title="在副本集中强制秘钥文件访问控制"></a>在副本集中强制秘钥文件访问控制</h4><p>Enforce Keyfile Access Control in a Replica Set</p><p><br></p><p>对副本集执行访问控制需要配置：</p><ul><li>使用内部身份验证副本集成员之间的安全性</li><li>使用用户访问控制连接客户端和副本集间的安全性</li></ul><p>步骤：</p><ol><li>创建一个密钥文件</li></ol><p>Create a keyfile</p><p>通过密钥文件进行身份验证，副本集中的每个mongod实例都使用密钥文件的内容作为共享密码，用于验证部署中的其它成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#yum install -y openssl</div><div class="line"></div><div class="line">openssl rand -base64 756 &gt; &lt;path-to-keyfile&gt;</div><div class="line">chmod 400 &lt;path-to-keyfile&gt;</div><div class="line">chown &lt;owner&gt;:&lt;owner&gt;</div></pre></td></tr></table></figure><p><br></p><ol><li>复制密钥文件到每个副本集成员</li></ol><p>Copy the keyfile to each replica set member</p><p>将密钥文件复制到每一台主机的副本集成员中。<br>确保运行mongod实例的用户就是keyfile的所有者，并可以访问密钥文件。</p><p><br></p><ol><li>关闭所有的副本集成员</li></ol><p>Shut down all members of the replica set</p><p>关闭每个副本集中的mongod，从Secondary开始。知道所有的成员都脱机为止，包括任何仲裁者(Arbiter)。Primary是最后一个关闭的成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use admin</div><div class="line">db.shutdownServer()</div></pre></td></tr></table></figure><p><br></p><ol><li>启动访问控制并重启副本集成员</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">security:</div><div class="line">  keyFile: &lt;path-to-keyfile&gt;</div><div class="line">  clusterAuthMode: keyfile</div><div class="line">replication:</div><div class="line">  replSetName: &lt;replcaSetName&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#cmd-line</div><div class="line">mongod --keyFile &lt;path-to-keyfile&gt; --clusterAuthMode keyfile --replSet &lt;replicaSetName&gt;</div></pre></td></tr></table></figure><p><br></p><ol><li>连接到mongo shell</li></ol><p>在Primary上使用<code>rs.status()</code>来标识副本集成员。</p><p><br></p><ol><li>创建一个administrator</li></ol><p>Create the user administrator</p><p>必须在Primary上创建用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">admin = db.getSiblingDB(&quot;admin&quot;)</div><div class="line">admin.createUser(</div><div class="line">  &#123;</div><div class="line">user: &apos;zhang&apos;,</div><div class="line">    pwd: &apos;password&apos;,</div><div class="line">    roles: [&#123; role: &apos;userAdminAnyDatabase&apos;, db: &apos;admin&apos; &#125;]</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p><br></p><ol><li>开启用户认证</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">security:</div><div class="line">  authorization: enabled</div><div class="line">  keyFile: &lt;path-to-keyfile&gt;</div><div class="line">  clusterAuthMode: keyfile</div><div class="line">replication:</div><div class="line">  replSetName: &lt;replcaSetName&gt;</div></pre></td></tr></table></figure><p><br></p><ol><li>以管理员身份进行认证</li></ol><p>Authenticate as the User Administrator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mogno</div><div class="line">&gt;db.getSiblingDB(&quot;admin&quot;).auth(&apos;zhang&apos;,&apos;password&apos;)</div><div class="line"></div><div class="line"></div><div class="line">#or</div><div class="line">mongo -u &apos;zhang&apos; -p &apos;password&apos; --authenticationDatabase &apos;admin&apos;</div></pre></td></tr></table></figure><p><br></p><ol><li>创建集群管理员(可选)</li></ol><p>Create the cluster administrator (Optional)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.getSiblingDB(&quot;admin&quot;).createUser(</div><div class="line">  &#123;</div><div class="line">    &quot;user&quot; : &quot;ravi&quot;,</div><div class="line">    &quot;pwd&quot; : &quot;changeme2&quot;,</div><div class="line">    roles: [ &#123; &quot;role&quot; : &quot;clusterAdmin&quot;, &quot;db&quot; : &quot;admin&quot; &#125; ]</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p><br></p><h4 id="在不停机的副本集中强制实施keyfile访问控制"><a href="#在不停机的副本集中强制实施keyfile访问控制" class="headerlink" title="在不停机的副本集中强制实施keyfile访问控制"></a>在不停机的副本集中强制实施keyfile访问控制</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.mongodb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MongoDB官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mongoing.com/docs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MongoDB中文文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/MongoDB&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/MongoDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ywnds.com/?p=5635&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ywnds.com/?p=5635&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.centos.bz/2017/08/mongodb-secure-intro-user-auth/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.centos.bz/2017/08/mongodb-secure-intro-user-auth/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.03sec.com/3176.shtml&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.03sec.com/3176.shtml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ywnds.com/?p=6502&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ywnds.com/?p=6502&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/the-little-mongodb-book/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://wiki.jikexueyuan.com/project/the-little-mongodb-book/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7_x64；&lt;/li&gt;
&lt;li&gt;MongoDB3.4；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="https://zhang21.github.io/categories/Database/"/>
    
    
      <category term="MongoDB" scheme="https://zhang21.github.io/tags/MongoDB/"/>
    
  </entry>
  
</feed>
