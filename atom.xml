<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风继续吹</title>
  
  <subtitle>Yesterday, you said tomorrow!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhang21.github.io/"/>
  <updated>2018-07-04T07:39:02.000Z</updated>
  <id>https://zhang21.github.io/</id>
  
  <author>
    <name>Zhang21</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes</title>
    <link href="https://zhang21.github.io/2018/06/26/Kubernetes/"/>
    <id>https://zhang21.github.io/2018/06/26/Kubernetes/</id>
    <published>2018-06-26T03:38:33.000Z</published>
    <updated>2018-07-04T07:39:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>Kubernetes: <a href="https://zh.wikipedia.org/wiki/Kubernetes" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Kubernetes</a></li><li>官方文档: <a href="https://kubernetes.io/cn/docs/" target="_blank" rel="noopener">https://kubernetes.io/cn/docs/</a></li><li>中文文档: <a href="http://docs.kubernetes.org.cn/" target="_blank" rel="noopener">http://docs.kubernetes.org.cn/</a></li><li>GitHub: <a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes</a></li></ul><p>环境：</p><ul><li>CentOSx86_64</li><li>Kubernetes v1.10</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><p><img src="/images/K8s/Kubernetes_logo.png" alt="Kubernetes"></p><p><br></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Kubernetes（常简称为K8s），Kubernetes的名字来自希腊语，意思是“舵手”或“领航员”。K8s是将8个字母“ubernete”替换为“8”的缩写。<br>它用于自动部署、扩展和管理容器化（containerized）应用程序的开源系统。它旨在提供“跨主机集群的自动部署、扩展以及运行应用程序容器的平台”。它支持一系列容器工具, 包括Docker等。</p><p>通过Kubernetes你可以：</p><ul><li>快速部署应用</li><li>快速扩展应用</li><li>无缝对接新的应用功能</li><li>优化硬件资源，降低成本</li></ul><p>Kubernetes特点：</p><ul><li>可移植(portable)</li><li>可扩展( extensible)</li><li>自动化(automatic)</li></ul><p>容器优点：</p><ul><li>快速创建/部署应用</li><li>持续开发、集成和部署(CI/CD)</li><li>开发和运维相分离</li><li>开发、测试、生产环境的一致性</li><li>可移植性</li><li>松耦合、分布式、弹性伸缩、微服务化</li><li>资源隔离</li><li>资源利用</li></ul><p><br></p><p><strong>Kubernetes能做什么</strong><br>Kubernetes还允许开发人员从物理和虚拟机脱离，从以主机为中心的基础架构转移到以容器为中心的基础架构。这样可以使用容器固有的全部优点。</p><p>Kubernetes满足的应用程序常见需求：</p><ul><li>Pod</li><li>挂载外部存储</li><li>分布式secrets</li><li>应用健康检查</li><li>副本应用实例</li><li>横向自动伸缩</li><li>服务发现</li><li>负载均衡</li><li>滚动更新</li><li>资源监控</li><li>日志采集和存储</li><li>自检和调试</li><li>认证和授权</li></ul><p>这提供了<strong>平台即服务(PAAS)</strong>的简单性以及<strong>基础架构即服务(IAAS)</strong>的灵活性，并促进基础设施供应商的可移植性。</p><p><br></p><p><strong>Kubernetes不是什么</strong><br>Kubernetes 不是一个传统意义上，包罗万象的PaaS(平台即服务)系统。</p><ul><li>不限制支持的应用程序类型，不限制应用程序框架</li><li>不提供中间件(如消息中间件)、数据处理框架(如spark)，数据库或集群存储系统</li><li>不提供点击即部署的服务市场</li><li>不部署代码不构建应用</li><li>允许用户选择日志、监控和报警</li><li>不提供或授权一个全面的应用程序配置系统/语言</li><li>不提供任何机器配置、维护、管理或自我修复系统</li></ul><p>你可以自定义你的PAAS，与你选择的CI系统集成，或与Kubernetes一起使用，将你的容器镜像部署到Kubernetes。<br>由于Kubernetes在应用级别而不仅仅在硬件级别上运行，因此它提供了PAAS产品通用的一些功能。如部署、扩展、负载均衡、日志记录、监控等。</p><p><br><br><br></p><h2 id="标准词汇"><a href="#标准词汇" class="headerlink" title="标准词汇"></a>标准词汇</h2><p>Standardized Glossary</p><p><br></p><ul><li><p><strong>Annotation</strong><br>用于将任意非标识元数据(metadata)附加到随想的键值对。</p></li><li><p><strong>Application Architect</strong><br>负责程序高级设计的人员。</p></li><li><p><strong>Application Developer</strong><br>编写在Kubernetes集群中运行的应用程序的人。</p></li><li><p><strong>Approver</strong><br>可以审批Kubernetes代码贡献的人。</p></li><li><p><strong>CLA(Contributor License Agreement)</strong><br>贡献者向开源项目授予其贡献许可的条款。</p></li><li><p><strong>Certificate</strong><br>一个加密安全文件，用于验证对Kubernetes集群的访问的加密。</p></li><li><p><strong>Cloud Controller Manager</strong></p></li><li><p><strong>Cloud Provider</strong></p></li><li><p><strong>Cluster</strong><br>一组称为节点(node)的机器，运行着由Kubernetes管理的容器化的应用程序。</p></li><li><p><strong>Cluster Architect</strong><br>设计一个或多个Kubernetes集群的基础架构的人。</p></li><li><p><strong>Cluster Operator</strong><br>配置，控制和监控集群的人。</p></li><li><p><strong>Code Contributor</strong><br>为Kubernetes开源代码库开发和共享代码的人。</p></li><li><p><strong>ConfigMap</strong><br>一个API对象，用于在键值对中存储非机密的数据。可认为是环境变量，命令行参数…</p></li><li><p><strong>Container</strong><br>一个轻量化和可移植的包含应用程序及其依赖项的可执行的镜像。</p></li><li><p><strong>Container Environment Variables</strong><br>容器环境变量是<code>name/value</code>对，为Pod中运行的容器提供有用的信息。</p></li><li><p><strong>Contributor</strong><br>捐赠代码，文档或时间来帮助Kubernetes项目或社区的人。</p></li><li><p><strong>Controller</strong><br>一个控制循环，通过APIServer监视集群的共享状态，并进行修改，尝试将当前状态移至理想(desired)状态。</p></li><li><p><strong>CronJob</strong><br>管理一个定期运行的工作。</p></li><li><p><strong>CustomResourceDefinition</strong><br>自定义码，用于定义要添加到Kubernetes APIServer的资源，而无需构建完整的自定义服务器。</p></li><li><p><strong>DaemonSet</strong><br>确保Pod的副本在集群的一组节点上运行。</p></li><li><p><strong>Deployment</strong><br>一个管理副本应用程序的API对象</p></li><li><p><strong>Dynamic Volume Provision</strong><br>允许用户请求自动创建存储卷。</p></li><li><p><strong>etcd</strong><br>一致且高度可用的键值存储，用作Kubernetes所有集群数据的备份存储。</p></li><li><p><strong>Helm Chart</strong><br>可以使用Helm工具管理的预配置Kubernetes资源包。</p></li><li><p><strong>Horizontal Pod Autoscaler</strong><br>一个API资源，可根据目标CPU利用率或自定义的指标自动调整Pod副本数。</p></li><li><p><strong>Image</strong><br>一个容器的存储实例，其中包含运行一个应用程序需要的一组软件。</p></li><li><p><strong>Ingress</strong><br>一个管理集群中服务的外部访问的API对象，通常是HTTP。</p></li><li><p><strong>Init Container</strong><br>一个或多个初始化容器，必须在任意应用程序容器运行之前完成运行。</p></li><li><p><strong>Istio</strong><br>一个开放平台，提供统一的方式来继承微服务，管理流量，实施策略和聚合遥测数据。</p></li><li><p><strong>Job</strong><br>运行完成的 有限/一批 任务。</p></li><li><p><strong>Kops</strong><br>一个命令行工具，可帮助你创建，销毁，升级和维护生产级，号可以性的Kubernetes集群。</p></li><li><p><strong>Kubeadm</strong><br>一个快速安装Kubernetes和设置安全集群的工具。</p></li><li><p><strong>Kubectl</strong><br>用于与Kubernetes APIServer通信的命令行工具。</p></li><li><p><strong>Kubelet</strong><br>在集群的每个节点上运行的Agent。它确保容器运行在Pod中。</p></li><li><p><strong>Kubernetes API</strong><br>通过RESTful接口提供Kubernetes功能的应用程序，用于存储集群的状态。</p></li><li><p><strong>Label</strong><br>标记与用户有意义且相关的标识属性的对象。</p></li><li><p><strong>Minikube</strong><br>一个在本地运行Kubernetes的工具。</p></li><li><p><strong>Name</strong><br>客户端提供的字符串，用于引用资源URL中的对象。如<code>/api/vi/pods/some-name</code>.</p></li><li><p><strong>Namespace</strong><br>一个抽象概念，用于Kubernetes支持同一物理集群上的多个虚拟集群。</p></li><li><p><strong>Network Policy</strong><br>允许Pod组如何与其它网络端点进行通信的规范。</p></li><li><p><strong>Node</strong><br>节点是Kubernetes中的一个工作机器。</p></li><li><p><strong>Persistent Volume</strong><br>一个表示集群中一块存储的API对象。</p></li><li><p><strong>Persistent Volume Claim</strong><br>声明定义在一个PersistentVolume中的存储资源，以便可以作为一个volume挂载到容器中。</p></li><li><p><strong>Pod</strong><br>最小和最简单的Kubernetes对象。Pod表示集群上一组正在运行的容器。</p></li><li><p><strong>Pod Security Policy</strong><br>启用Pod创建和更新的细粒度授权。</p></li><li><p><strong>PodPreset</strong><br>一个API对象，在创建时将信息(secrets, volume, env var…)注入到Pod中。</p></li><li><p><strong>RBAC（role-basesd access control)</strong><br>管理授权决策，允许管理员通过Kubernetes API动态配置访问策略。</p></li><li><p><strong>ReplicaSet</strong><br>副本集是下一代副本控制器。</p></li><li><p><strong>Resource Quotas</strong><br>提供限制每个命名空间的聚合资源消耗的约束。</p></li><li><p><strong>Reviemer</strong><br>在项目的某些部分检查代码质量和正确性的人。</p></li><li><p><strong>Secret</strong><br>存储敏感信息，如密码，token…</p></li><li><p><strong>Security Context</strong><br><code>securityContext</code>字段定义Pod或容器的权限和访问控制设置，包括运行时UID和GID。</p></li><li><p><strong>Selector</strong><br>允许用户根据label过滤资源列表。</p></li><li><p><strong>Service</strong><br>一个API对象，描述如何访问应用程序，并可以描述端口和负载均衡器。</p></li><li><p><strong>Service Account</strong><br>为运行在Pod中的进程提供一个标识。</p></li><li><p><strong>Service Catalog</strong><br>一个扩展API，允许Kubernetes集群中运行的应用程序能够轻松使用外部托管软件，如数据库存储服务。</p></li><li><p><strong>StatefulSet</strong><br>管理一组Pods的部署和伸缩，并提供有关这些Pod的排序和唯一性的保证。</p></li><li><p><strong>UID</strong><br>Kubernetes系统生成的一个字符串，用于唯一标识对象。</p></li><li><p><strong>Volume</strong><br>一个包含数据的目录，可供Pod中的容器访问。</p></li><li><p><strong>Volume Plugin</strong><br>卷插件可在Pod中集成存储。</p></li><li><p><strong>kube-apiserver</strong><br>一个Master组件，用于暴露Kubernetes API。它是Kubernetes控制面的前端。</p></li><li><p><strong>kube-controller-manager</strong><br>一个Master组件，用于运行控制器。</p></li><li><p><strong>kube-proxy</strong><br>运行在集群中的每一个节点上的网络代理。</p></li><li><p><strong>kube-scheduler</strong><br>Master上的组件，用于监测未创建节点新创建的Pod，并选择一个节点供其运行。</p></li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>Kubernetes 所需的各种二进制组件, 用于提供齐全的功能。</p><p><br><br><br></p><h3 id="Master组件"><a href="#Master组件" class="headerlink" title="Master组件"></a>Master组件</h3><p>Master组件提供的集群控制。<br>Master组件可在集群中任何节点上运行。然而，为了简单，通常在一台机器上启动所有Master组件，并且不会在此机器上运行用户容器。<br>可使用多个机器的设置来构建<strong>高可用性能集群</strong>。</p><p>master组件：</p><ul><li><p>APIserver<br><code>kube-apiserver</code>对外暴露Kubernetes API。它是Kubernetes前端控制层，任何的资源请求/调用都是通过它提供的接口进行。<br>它被设计为水平扩展，即通过部署更多实例来缩放。</p></li><li><p>etcd<br><code>etcd</code>用于Kubernetes的后端存储。所有集群数据都存储于此。<br>请始终为k8s集群的etcd数据做备份。</p></li><li><p>kube-controller-manager</p><ul><li>节点控制器</li><li>副本控制器</li><li>端点控制器</li><li>服务账户和令牌控制器</li></ul></li></ul><p><code>kube-controller-manager</code>运行控制器,它们是集群中处理常规任务的后台线程。逻辑上，每个控制器是一个单独的进程。但为了降低复杂性，它们都被编译成独立的二进制可执行文件，并在单个进程中运行。</p><p>节点(node)控制器：当节点移除时，负责注意和相应<br>副本(replication)控制器：维护系统中每个副本对象正确数量的pod<br>端点(endpoint)控制器：填充端点对象<br>服务账户(service account)和令牌(token)控制器：为新的命名空间(namespace)创建默认账户和API访问令牌</p><ul><li>cloud-controller-manager<br>云控制器管理器是用于与底层云提供商交互的控制器。它仅运行云提供商特定的控制器循环。你必须在<code>kube-controller-manager</code>中禁用这些控制器循环。</li></ul><p>以下控制器具有云提供商依赖关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">节点控制器</span><br><span class="line">路由控制器</span><br><span class="line">服务控制器</span><br><span class="line">数据卷控制器</span><br></pre></td></tr></table></figure><ul><li><p>kube-scheduler<br>调度器监视没有分配节点的新创建的pod，选择一个节点供他们运行。</p></li><li><p>addons</p><ul><li>DNS</li><li>用户界面</li><li>容器资源监控</li><li>集群层面日志(cluster-level logging)</li></ul></li></ul><p>插件是实现集群功能的Pod和Service。addon管理器用于创建和维护附加资源。</p><p>DNS: 所有k8s集群都应该具有cluster dns。它是一个DNS服务器，为Kubernetes服务提供DNS记录。Kubernetes启动的容器自动将DNS服务器包含在DNS搜索中。<br>集群层面日志机制负责将容器的日志数据保存到一个集中的日志存储中，该存储能够提供搜索和浏览接口。</p><p><br></p><h3 id="节点组件"><a href="#节点组件" class="headerlink" title="节点组件"></a>节点组件</h3><p>节点(node)组件在每个节点上运行，维护运行的pod并提供Kubernetes运行时环境。</p><p>节点组件：</p><ul><li>kubelet<ul><li>挂载pod所需的数据卷</li><li>下载pod的secrets</li><li>pod中运行docker容器</li><li>周期性的容器健康检查</li><li>如有需要，通过创建<code>mirror pod</code>将pod的状态报告回系统的其余部分</li><li>将节点的状态报告回系统的其余部分</li></ul></li></ul><p><code>kubelet</code>是主要的节点代理，它监测已分配给节点的pod，提供这些功能。</p><ul><li><p>kube-proxy<br><code>kube-proxy</code>通过维护主机上的网络规则并执行连接转发，来实现Kubernetes服务抽象。</p></li><li><p>docker<br><code>docker</code>用于运行容器。</p></li><li><p>rkt<br><code>rkt</code>运行容器，作为docker的替代方案。</p></li><li><p>supervisord<br><code>supervisord</code>是一个轻量级的进程监控系统，可用来保证<code>kubelet</code>和<code>docker</code>运行。</p></li><li><p>fluentd<br><code>fluentd</code>是一个守护进程，有助于提供集群层面的日志。</p></li></ul><p><br><br><br></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>在Kubernetes系统中，Kubernetes对象 是持久化的实体。Kubernetes使用这些实体去表示整个集群的状态。特别地，它们描述了如下信息：</p><ul><li>哪些容器化应用正在运行(以及在哪个节点上)</li><li>可以被应用使用的资源</li><li>应用运行的策略(重启、升级、容错)</li></ul><p>Kubernetes 对象是 “目标性记录” —— 一旦创建对象，Kubernetes 系统将持续工作以确保对象存在。通过创建对象，本质上是在告知 Kubernetes 系统，所需要的集群工作负载看起来是什么样子的，这就是 Kubernetes 集群的 期望状态（Desired State）。<br>操作 Kubernetes 对象 —— 是否创建、修改，或者删除 —— 需要使用 Kubernetes API</p><p><br></p><p><strong>对象规约(Spec)与状态(Status)</strong><br>每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置：对象<code>spec</code>和对象<code>status</code>。 spec是必需的，它描述了对象的<strong>期望状态（Desired State）</strong> —— 希望对象所具有的特征。 status 描述了对象的<strong>实际状态（Actual State）</strong>，它是由 Kubernetes 系统提供和更新的。在任何时刻，Kubernetes 控制面一直努力地管理着对象的实际状态以与期望状态相匹配。</p><p><br></p><p><strong>描述Kubernetes对象</strong><br>当创建 Kubernetes 对象时，必须提供对象的规约，用来描述该对象的期望状态，以及关于对象的一些基本信息（如名称）。</p><p>创建对象：</p><ul><li><p><code>Kubernetes API</code><br>API请求必须使用JSON格式</p></li><li><p><code>kubectl</code><br>在<code>.yaml</code>配置文件中为<code>kubectl</code>提供这些信息。<code>kubectl</code>在发起API请求时，将这些信息转换成JSON格式。<br>在创建Kubernetes对象的yaml文件时，必须配置如下字段。</p></li><li><p>apiVersion<br>Kubernetes API版本</p></li><li><p>kind<br>想要创建的对象类型</p></li><li><p>metadata<br>识别对象唯一性的数据，包括<code>name</code>, <code>UID</code>和可选的<code>namespace</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#栗子</span><br><span class="line"># for versions before 1.9.0 use apps/v1beta2</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.7.9</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#创建</span><br><span class="line">kubectl create -f /tmp/nginx-deployment.yaml --record</span><br><span class="line"></span><br><span class="line">#输出</span><br><span class="line">deployment &quot;nginx-deployment&quot; created</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="names"><a href="#names" class="headerlink" title="names"></a>names</h2><p>Kubernetes REST API中所有对象都用<strong>name</strong>和<strong>UID</strong>来明确标识。</p><p><br><br><br></p><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p>Kubernetes使用namespace(命名空间)创建多个虚拟集群。命名空间是一种将集群资源划分为多个用途的方法。<br>命名空间名称满足正则表达式，最大长度为63位。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过命令创建</span></span><br><span class="line">kubectl create namespace my-namespace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过文件创建</span></span><br><span class="line">vim my-namespace</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: my-namespace</span><br><span class="line"></span><br><span class="line">kubectl create -f /tmp/my-namespace.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">kubectl get namespace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">kubectl delete namespace my-namespace</span><br></pre></td></tr></table></figure><p>Kubernetes有两个初始的命名空间开始：</p><ul><li>default</li><li>kube-system: 对象的命名空间</li></ul><p>注意：</p><ul><li>删除一个命名空间会自动删除所有属于该命名空间的资源</li><li>k8s初始化的两个命名空间无法删除</li><li>持久化卷(persistent volume)不属于任何命名空间，但持久化卷声明(persistent volume claim)是属于某个特定命名空间的</li><li>事件(event)是否属于命名空间取决于产生事件的对象</li></ul><p><br><br><br></p><h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><p>标签其实是一对<code>key/value</code>，被关联到对象上。标签能够标识对象的特殊特点。每个对象可拥有多个标签，但key必须唯一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;labels&quot;: &#123;</span><br><span class="line">  &quot;key1&quot; : &quot;value1&quot;,</span><br><span class="line">  &quot;key2&quot; : &quot;value2&quot;,</span><br><span class="line">  &quot;keyN&quot; : &quot;valueN&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子</span><br><span class="line">&quot;release&quot; : &quot;stable&quot;</span><br><span class="line">&quot;environment&quot; : &quot;dev&quot;</span><br><span class="line">&quot;track&quot; : &quot;daily&quot;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h2><p>默认情况下，容器中的文件是非持久化的。Kubernetes Volume用于解决如下问题：</p><ul><li>容器挂掉后，kubelet重启它时，文件会丢失</li><li>当pod中同时运行多个容器，容器间需要共享文件时</li></ul><p>要使用volume，pod需要指定volume的类型和内容，以及映射到容器的位置。</p><p><br></p><p><strong>Kubernetes支持的volume类型</strong></p><ul><li>emptyDir</li><li>hostPath</li><li>gcePersistentDisk</li><li>awsElasticBlockStore</li><li>nfs</li><li>iscsi</li><li>fc</li><li>flocker</li><li>glusterfs</li><li>rbd</li><li>cephfs</li><li>secret</li><li>persistentVolumeClaim</li><li>downwardAPI</li><li>projected</li><li>vsphereVolume</li><li>local</li><li>StorageOS</li><li>portworxVolume</li></ul><p><br><br><br></p><h2 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h2><p>Kubernetes可使用annotation(注释)将任何非标识metadata附加到对象。它也由<code>key/value</code>组成。<br>Annotations不会被Kubernetes直接使用，其主要目的是方便用户阅读查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;annotations&quot;: &#123;</span><br><span class="line">  &quot;key1&quot; : &quot;value1&quot;,</span><br><span class="line">  &quot;key2&quot; : &quot;value2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p><code>node</code>是Kubernetes的工作节点，以前称为<code>minion</code>。也就是集群中的一台主机。每个节点都有用于运行<code>pods</code>的必要服务，并由master组件管理。<br>节点上的服务包括<code>docker</code>, <code>kubelet</code>, <code>kube-proxy</code>。</p><p><br></p><h3 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h3><p>一个节点的状态包含以下信息：</p><ul><li><p>地址(address)</p><ul><li>hostname</li><li>ExternalIP</li><li>InternalIP</li></ul></li><li><p>条件(condition)<br>描述所有运行中节点的状态。节点调试使用JSON对象表示。</p></li></ul><table><thead><tr><th>条件</th><th>描述</th></tr></thead><tbody><tr><td>OutOfDisk</td><td>True 表示 node 的空闲空间不足以用于添加新 pods, 否则为 False</td></tr><tr><td>Ready</td><td>True 表示 node 是健康的并已经准备好接受 pods；False 表示 node 不健康而且不能接受 pods；Unknown 表示 node 控制器在最近 40 秒内没有收到 node 的消息</td></tr><tr><td>MemoryPressure</td><td>True 表示 node 不存在内存压力 – 即 node 内存用量低, 否则为 False</td></tr><tr><td>DiskPressure</td><td>True 表示 node 不存在磁盘压力 – 即磁盘用量低, 否则为 False</td></tr></tbody></table><p><br></p><p>一个健康的节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;conditions&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;kind&quot;: &quot;Ready&quot;,</span><br><span class="line">    &quot;status&quot;: &quot;True&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><p>容量(capacity)<br>描述节点上的可用资源：CPU、内存和可调度到节点上的最大pods数。</p></li><li><p>信息(info)<br>关于节点的统一信息，如内核版本、Kubernetes版本、Docker版本等。</p></li></ul><p><br></p><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><p>Kubernetes创建一个节点时，它其实仅仅创建了一个对象来代表这个节点。创建以后，Kubernetes将检查这个节点是否可用。<br>如果节点可用，意即所有必要服务都已运行，它就符合了运行一个pod的条件。否则它将被所有的集群动作忽略知道变为可用。请注意，Kubernetes将保持不可用节点的对象，除非它被手动删除。Kubernetes将持续检查节点是否变得可用。</p><p>有3个组件同Kubernetes节点接口交互：</p><ul><li>节点控制器</li><li>kubelet</li><li>kubectl</li></ul><p><br></p><p><strong>节点自注册</strong><br>当<code>kubelet</code>标志<code>--register-node</code>为<code>true</code>（默认）时，它会尝试向 API 服务注册自己。这是首选模式，被绝大多数发行版选用。</p><p>如果管理员希望手动创建节点对象，请设置<code>kubelet</code>标记<code>--register-node=false</code>。</p><p><br></p><h3 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h3><p>Master节点(APIserver)和Kubernetes集群之间的通信。</p><ul><li><strong>cluster-&gt;master</strong><br>所有从集群到master的通信路径都终止于APIserver。<br>应该使用集群的公共根证书开通节点，如此它们就能够基于有效的客户端凭据安全的连接 apiserver。<br>想要连接到 apiserver 的 Pods 可以使用一个 service account 安全的进行连接。<br>Master 组件通过非安全（没有加密或认证）端口和集群的 apiserver 通信。</li></ul><p><br></p><ul><li><strong>master-&gt;cluster</strong><br>从 master（apiserver）到集群有两种主要的通信路径。第一种是从 apiserver 到集群中每个节点上运行的 kubelet 进程。第二种是从 apiserver 通过它的代理功能到任何 node、pod 或者 service。</li></ul><p>Google Kubernets Engine使用SSH隧道保护Master-&gt;Cluster通信路径。</p><p><br><br><br></p><h2 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h2><p>pod是Kubernetes最基本的调度单位。它可以包更高级的抽象内容增加到容器化组件。一个pod代表集群上正在运行的一个进程。<br>一个pod一般包含一个或多个容器，这样可以保证它们一直位于主机上，并且可以共享资源。<br>每个pod都被分配一个唯一的(集群内)IP地址。<br>每个pod都是运行应用的单个实例，如需水平扩展应用，则应该使用多个pods。这在Kubernetes中通常称为Replication。</p><p>docker是Kubernetes pod中最常见的runtime，当然还有其它runtime。</p><p>pod提供两种共享资源：</p><ul><li>网络</li><li>存储</li></ul><p><br></p><p>你很少会直接在Kubernetes中创建单个pod，因为它的生命周期是短暂的，是用后即焚的实体。当它被创建后，都会被Kubernetes调度到集群的节点上。<br>pod不会自愈，如果pod运行的节点或调度器故障，则pod就会被删除。</p><p>注意，重启pod中的容器和重启pod不是一回事。pod只提供容器的运行环境并保持容器的运行状态，重启容器不会造成pod重启。</p><p>控制器可以创建和管理多个pod，提供副本管理、滚动升级和集群级别的自愈能力。例如，如果一个节点故障，控制器就能自动将该节点上的pod调度到其它健康的节点上。</p><p>pod template是包含了其它对象中的pod定义。控制器使用pod模板来创建实际需要的pod。</p><p><br><br><br></p><h3 id="pod安全策略"><a href="#pod安全策略" class="headerlink" title="pod安全策略"></a>pod安全策略</h3><p>Pod Security Policy 类型的对象能够控制，是否可以向Pod发送请求，该Pod能够影响被应用到Pod和容器的 SecurityContext。<br>pod 安全策略是集群级别的资源，它能够孔子pod运行的行为，以及它既有访问什么的能力。</p><p>有如下方面：</p><ul><li>privileged</li><li>defaultAddCapabilities</li><li>requiredDropCapabilities</li><li>allowCapabilities</li><li>volumes</li><li>hostNetwork</li><li>hostPorts</li><li>hostPID</li><li>hostIPC</li><li>allowedHostPaths</li><li>selinux</li><li>runAsUser</li><li>supplementalGroups</li><li>fsGroups</li><li>readOnlyRootFilesystem</li></ul><p><br></p><p><strong>创建pod安全策略</strong><br>如下的栗子，所有字段都被允许</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: PodSecurityPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: permissive</span><br><span class="line">spec:</span><br><span class="line">  seLinux:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  supplementalGroups:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  runAsUser:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  fsGroup:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  hostPorts:</span><br><span class="line">  - min: 8000</span><br><span class="line">    max: 8080</span><br><span class="line">  volumes:</span><br><span class="line">  - &apos;*&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#创建</span><br><span class="line">kubectl create -f ./psp.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">kubectl get psp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改</span><br><span class="line">kubectl edit psp permissive</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">kubectl delete psp permissive</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="pod生命周期"><a href="#pod生命周期" class="headerlink" title="pod生命周期"></a>pod生命周期</h3><p><strong>pod phase</strong><br>pod的<code>status</code>定义在PodStatus对象中，有一个<code>phase</code>字段。<br>pod的运行阶段(phase)是pod在其生命周期中的简单宏观概述。</p><p><code>phase</code>可能是如下值：</p><ul><li><p>挂起(pending)<br>Pod 已被 Kubernetes 系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度 Pod 的时间和通过网络下载镜像的时间，这可能需要花点时间。</p></li><li><p>运行中(running)<br>该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态。</p></li><li><p>成功(succeeded)<br>Pod 中的所有容器都被成功终止，并且不会再重启。</p></li><li><p>失败(failed)<br>Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止。</p></li><li><p>未知(unknown)<br>因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。</p></li></ul><p><br></p><p><strong>pod status</strong><br>pod有一个PodStatus对象，其中包含一个PodCondition数组，数组的每个元素都有一个<code>type</code>和<code>status</code>字段。type 字段是字符串，可能的值有 PodScheduled、Ready、Initialized 和 Unschedulable。status 字段是一个字符串，可能的值有 True、False 和 Unknown。</p><p><br></p><p><strong>容器探针</strong><br>探针 是由 kubelet 对容器执行的定期诊断。要执行诊断，kubelet 调用由容器实现的 Handler。有三种类型的处理程序：</p><ul><li>ExecAction：在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</li><li>TCPSocketAction：对指定端口上的容器的 IP 地址进行 TCP 检查。如果端口打开，则诊断被认为是成功的。</li><li>HTTPGetAction：对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。如果响应的状态码大于等于200 且小于 400，则诊断被认为是成功的。</li></ul><p>每次探测都将获得以下三种结果之一:</p><ul><li>成功：容器通过了诊断。</li><li>失败：容器未通过诊断。</li><li>未知：诊断失败，因此不会采取任何行动。</li></ul><p>Kubelet 可以选择是否执行在容器上运行的两种探针执行和做出反应：</p><ul><li>livenessProbe：指示容器是否正在运行。如果存活探测失败，则 kubelet 会杀死容器，并且容器将受到其 重启策略 的影响。如果容器不提供存活探针，则默认状态为 Success。</li><li>readinessProbe：指示容器是否准备好服务请求。如果就绪探测失败，端点控制器将从与 Pod 匹配的所有 Service 的端点中删除该 Pod 的 IP 地址。初始延迟之前的就绪状态默认为 Failure。如果容器不提供就绪探针，则默认状态为 Success。</li></ul><p><br><br><br></p><h3 id="init容器"><a href="#init容器" class="headerlink" title="init容器"></a>init容器</h3><p><br><br><br></p><h3 id="设置pod的资源"><a href="#设置pod的资源" class="headerlink" title="设置pod的资源"></a>设置pod的资源</h3><p><br><br><br></p><h3 id="pod-preset"><a href="#pod-preset" class="headerlink" title="pod preset"></a>pod preset</h3><p><br><br><br></p><h3 id="pod服务质量等级"><a href="#pod服务质量等级" class="headerlink" title="pod服务质量等级"></a>pod服务质量等级</h3><p><br><br><br></p><h3 id="pod优先级和抢占"><a href="#pod优先级和抢占" class="headerlink" title="pod优先级和抢占"></a>pod优先级和抢占</h3><p><br><br><br></p><h2 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h2><p>Replica Sets</p><p>Kubernetes ReplicaSet(RS)是Replication Controller(RC)的升级版本。<br>虽然副本集可以独立使用，但它主要被部署(Deployment)用作pod机制的创建、删除和更新。当使用部署时，你不必担心创建pod的副本集，因为可通过部署实现管理。<br>副本集能确保运行指定数量的pod。然而，部署是一个更高层次的概念，我们建议你使用管理来管理副本集。这意味着你可能永远不需要操作副本集对象，而是使用部署替代管理。</p><p><br></p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: ReplicaSet</span><br><span class="line">metadata:</span><br><span class="line">  name: frontend</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      tier: frontend</span><br><span class="line">    matchExpressions:</span><br><span class="line">      - &#123;key: tier, operator: In, values: [frontend]&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: guestbook</span><br><span class="line">        tier: frontend</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: php-redis</span><br><span class="line">        image: gcr.io/google_samples/gb-frontend:v3</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 100Mi</span><br><span class="line">        env:</span><br><span class="line">        - name: GET_HOSTS_FROM</span><br><span class="line">          value: dns</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure><p>创建并查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f frontend.yaml</span><br><span class="line">replicaset &quot;frontend&quot; created</span><br><span class="line">$ kubectl describe rs/frontend</span><br><span class="line">Name:          frontend</span><br><span class="line">Namespace:     default</span><br><span class="line">Image(s):      gcr.io/google_samples/gb-frontend:v3</span><br><span class="line">Selector:      tier=frontend,tier in (frontend)</span><br><span class="line">Labels:        app=guestbook,tier=frontend</span><br><span class="line">Replicas:      3 current / 3 desired</span><br><span class="line">Pods Status:   3 Running / 0 Waiting / 0 Succeeded / 0 Failed</span><br><span class="line">No volumes.</span><br><span class="line">Events:</span><br><span class="line">  FirstSeen    LastSeen    Count    From                SubobjectPath    Type        Reason            Message</span><br><span class="line">  ---------    --------    -----    ----                -------------    --------    ------            -------</span><br><span class="line">  1m           1m          1        &#123;replicaset-controller &#125;             Normal      SuccessfulCreate  Created pod: frontend-qhloh</span><br><span class="line">  1m           1m          1        &#123;replicaset-controller &#125;             Normal      SuccessfulCreate  Created pod: frontend-dnjpy</span><br><span class="line">  1m           1m          1        &#123;replicaset-controller &#125;             Normal      SuccessfulCreate  Created pod: frontend-9si5l</span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME             READY     STATUS    RESTARTS   AGE</span><br><span class="line">frontend-9si5l   1/1       Running   0          1m</span><br><span class="line">frontend-dnjpy   1/1       Running   0          1m</span><br><span class="line">frontend-qhloh   1/1       Running   0          1m</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>Deployment</p><p>一个部署控制器(Deployment Controller)为pod和副本集提供了声明式更新。<br>你只需要在部署中描述你想要的目标状态是什么，部署控制器就会帮你将pod和副本集的实际状态改变到你的目标状态。你可以定义一个全新的部署来创建副本集，或删除已有的部署并创建一个新的来替换。</p><p>你不应该管理由Deployment部署的副本集。所有用例都应该通过操作Deployment对象来覆盖。</p><p><br></p><p>以下是部署的典型用例：</p><ul><li>创建副本集</li><li>通过更新部署的PodTemplateSpec字段来声明pod的新状态</li><li>回滚到之前的部署版本</li><li>伸缩部署</li><li>暂停部署使用部署状态</li><li>清理旧的副本集</li></ul><h3 id="创建部署"><a href="#创建部署" class="headerlink" title="创建部署"></a>创建部署</h3><p><br><br><br></p><h3 id="更新部署"><a href="#更新部署" class="headerlink" title="更新部署"></a>更新部署</h3><p><br><br><br></p><h3 id="回滚部署"><a href="#回滚部署" class="headerlink" title="回滚部署"></a>回滚部署</h3><p><br><br><br></p><h3 id="暂停和恢复部署"><a href="#暂停和恢复部署" class="headerlink" title="暂停和恢复部署"></a>暂停和恢复部署</h3><p><br><br><br></p><h3 id="伸缩部署"><a href="#伸缩部署" class="headerlink" title="伸缩部署"></a>伸缩部署</h3><p><br><br><br></p><h3 id="部署状态"><a href="#部署状态" class="headerlink" title="部署状态"></a>部署状态</h3><p><br><br><br></p><h3 id="清理策略"><a href="#清理策略" class="headerlink" title="清理策略"></a>清理策略</h3><p><br><br><br></p><h3 id="编写Deployment-spec"><a href="#编写Deployment-spec" class="headerlink" title="编写Deployment spec"></a>编写Deployment spec</h3><p><br><br><br></p><h3 id="替代部署"><a href="#替代部署" class="headerlink" title="替代部署"></a>替代部署</h3><p><br><br><br></p><h2 id="副本控制器"><a href="#副本控制器" class="headerlink" title="副本控制器"></a>副本控制器</h2><p>Kubernetes Replication Controller</p><p>建议使用副本控制器(RC)配置副本集(RS)来控制副本数。</p><p><br><br><br></p><h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p><br><br><br></p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>Kubernetes Service</p><p>k8s pod是有生命周期的，它们可被创建和销毁。通过副本控制器(RC)能动态地创建和销毁pod。每个pod都会获取它自己的IP地址，即使这些IP地址不总是稳定可依赖的。<br>如果k8s集群中，一组pod(backend)为其它pod(frontend)提供服务，那么那些frontend该如何发现，并连接到哪些backend呢？</p><p>k8s service定义了这样一种抽象： 一个pod的逻辑分组，一种可以访问它们的策略(微服务)。<br>这一组pod能够被service访问到，通常是通过<code>Label Selector</code>实现的。</p><p><br><br><br></p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>Kubernetes 垃圾收集器的角色是删除指定的对象，这些对象曾经有但以后不再拥有 Owner 了。</p><p>某些Kubernetes对象是其它一些对象的Owner。如，一个副本集是一组pod的Owner。<br>具有Owner的对象被称为是Owner的<strong>Dependent</strong>。每个Dependent对象具有一个执行所属对象的<code>metadata.ownerReference</code>字段。</p><p>有时，Kubernetes会自动设置<code>ownerReference</code>的值。<br>也可以手动设置<code>ownerReference</code>的值，来指定Owner和Dependent之间的关系。</p><p><br></p><p><strong>控制垃圾收集器删除Dependent</strong></p><ul><li><p>级联删除</p><ul><li>background</li><li>foreground<br>删除对象时自动删除Dependent。<br>在bg级联删除模式下，k8s会立即删除Owner对象，然后垃圾收集器会在后台删除这些Dependent。<br>在fg级联删除模式下，根对象首先进入删除中状态。一旦对象被设置为删除中状态，垃圾收集器会删除对象的所有Dependent。</li></ul></li><li><p>孤儿<br>删除对象时，不自动删除它的Dependent。这些Dependent就被称作孤儿。垃圾收集器在删除了所有 “Blocking” 状态的 Dependent（对象的 ownerReference.blockOwnerDeletion=true）之后，它会删除 Owner 对象。</p></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p>Tutorials</p><p>教程展示了如何实现比单个任务更大的目标(task)。</p><p><br></p><hr><p><br><br><br></p><h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>安装Kubernetes和配置Kubernetes cluster。</p><p><br></p><h2 id="使用kubeadm引导集群"><a href="#使用kubeadm引导集群" class="headerlink" title="使用kubeadm引导集群"></a>使用kubeadm引导集群</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes: &lt;a href=&quot;https://zh.wikipedia.org/wiki/Kubernetes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;官方文档: &lt;a href=&quot;https://kubernetes.io/cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://kubernetes.io/cn/docs/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中文文档: &lt;a href=&quot;http://docs.kubernetes.org.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://docs.kubernetes.org.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub: &lt;a href=&quot;https://github.com/kubernetes/kubernetes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kubernetes/kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOSx86_64&lt;/li&gt;
&lt;li&gt;Kubernetes v1.10&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Kubernetes" scheme="https://zhang21.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>性能分析</title>
    <link href="https://zhang21.github.io/2018/05/14/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>https://zhang21.github.io/2018/05/14/性能分析/</id>
    <published>2018-05-14T07:11:16.000Z</published>
    <updated>2018-05-22T02:08:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>环境：</p><ul><li>CentOS7.x84_64</li></ul><p>参考:</p><ul><li>strace命令: <a href="http://man.linuxde.net/strace" target="_blank" rel="noopener">http://man.linuxde.net/strace</a></li><li>pstack命令: <a href="http://man.linuxde.net/pstack" target="_blank" rel="noopener">http://man.linuxde.net/pstack</a></li><li>lsof命令: <a href="http://man.linuxde.net/lsof" target="_blank" rel="noopener">http://man.linuxde.net/lsof</a></li><li>系统调用: <a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8</a></li><li>Linux系统调用列表: <a href="https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html#8" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html#8</a></li><li>高CPU分析: <a href="http://blog.51cto.com/yaocoder/1543352" target="_blank" rel="noopener">http://blog.51cto.com/yaocoder/1543352</a></li></ul><p><br><br><br></p><a id="more"></a><p><br></p><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>系统调用(system call)，指运行在用户态的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。<br>操作系统的进程空间可分为用户态和内核态，它们需要不同的执行权限。其中系统调用运行在内核态。</p><p>大多数系统交互式操作需求在内核态运行。如设备I/O或进程间通信。</p><p><br></p><ul><li><p>内核态(kernel space)<br>内核、核心扩充、驱动程序运行在内核空间上。</p></li><li><p>用户态(user space)<br>其它的应用程序，则运行在用户空间上。<br>所有运行在用户空间的应用程序，都被统称为用户级(userland)。</p></li><li><p>库函数<br>系统调用和普通库函数调用非常相似，只是系统调用由操作系统内核提供，运行于内核核心态；而普通的库函数调用由函数库或用户自己提供，运行于用户态。</p></li></ul><p><br></p><p><strong>系统调用的意义</strong></p><p>内核提供用户空间程序与内核空间进行交互的一套标准接口，这些接口让用户态程序能受限访问硬件设备，比如申请系统资源，操作设备读写，创建新进程等。用户空间发生请求，内核空间负责执行，这些接口便是用户空间和内核空间共同识别的桥梁，这里提到两个字“受限”，是由于为了保证内核稳定性，而不能让用户空间程序随意更改系统，必须是内核对外开放的且满足权限的程序才能调用相应接口。</p><p>在用户空间和内核空间之间，有一个叫做Syscall(系统调用, system call)的中间层，是连接用户态和内核态的桥梁。这样即提高了内核的安全型，也便于移植，只需实现同一套接口即可。Linux系统，用户空间通过向内核空间发出Syscall，产生软中断，从而让程序陷入内核态，执行相应的操作。对于每个系统调用都会有一个对应的系统调用号，比很多操作系统要少很多。</p><p>安全性与稳定性：内核驻留在受保护的地址空间，用户空间程序无法直接执行内核代码，也无法访问内核数据，通过系统调用</p><p>性能：Linux上下文切换时间很短，以及系统调用处理过程非常精简，内核优化得好，所以性能上往往比很多其他操作系统执行要好。</p><p><br><br><br></p><h2 id="Linux系统调用方法"><a href="#Linux系统调用方法" class="headerlink" title="Linux系统调用方法"></a>Linux系统调用方法</h2><ul><li><p>futex<br>Futex 是fast userspace mutex的缩写，意思是快速用户空间互斥体。Linux内核把它们作为快速的用户空间的锁和信号量的预制构件提供给开发者。</p></li><li><p>select<br>select系统调用允许程序同时在多个底层文件表述符上，等待输入的到达或输出的完成。</p></li></ul><p><br></p><p><strong>进程控制</strong></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>fork</td><td>创建一个新进程</td></tr><tr><td>clone</td><td>按指定条件创建子进程</td></tr><tr><td>execve</td><td>运行可执行文件</td></tr><tr><td>exit</td><td>中止进程</td></tr><tr><td>_exit</td><td>立即中止当前进程</td></tr><tr><td>getdtablesize</td><td>进程所能打开的最大文件数</td></tr><tr><td>getpgid</td><td>获取指定进程组标识号</td></tr><tr><td>setpgid</td><td>设置指定进程组标志号</td></tr><tr><td>getpgrp</td><td>获取当前进程组标识号</td></tr><tr><td>setpgrp</td><td>设置当前进程组标志号</td></tr><tr><td>getpid</td><td>获取进程标识号</td></tr><tr><td>getppid</td><td>获取父进程标识号</td></tr><tr><td>getpriority</td><td>获取调度优先级</td></tr><tr><td>setpriority</td><td>设置调度优先级</td></tr><tr><td>modify_ldt</td><td>读写进程的本地描述表</td></tr><tr><td>nanosleep</td><td>使进程睡眠指定的时间</td></tr><tr><td>nice</td><td>改变分时进程的优先级</td></tr><tr><td>pause</td><td>挂起进程，等待信号</td></tr><tr><td>personality</td><td>设置进程运行域</td></tr><tr><td>prctl</td><td>对进程进行特定操作</td></tr><tr><td>ptrace</td><td>进程跟踪</td></tr><tr><td>sched_get_priority_max</td><td>取得静态优先级的上限</td></tr><tr><td>sched_get_priority_min</td><td>取得静态优先级的下限</td></tr><tr><td>sched_getparam</td><td>取得进程的调度参数</td></tr><tr><td>sched_getscheduler</td><td>取得指定进程的调度策略</td></tr><tr><td>sched_rr_get_interval</td><td>取得按RR算法调度的实时进程的时间片长度</td></tr><tr><td>sched_setparam</td><td>设置进程的调度参数</td></tr><tr><td>sched_setscheduler</td><td>设置指定进程的调度策略和参数</td></tr><tr><td>sched_yield</td><td>进程主动让出处理器,并将自己等候调度队列队尾</td></tr><tr><td>vfork</td><td>创建一个子进程，以供执行新程序，常与execve等同时使用</td></tr><tr><td>wait</td><td>等待子进程终止</td></tr><tr><td>wait3</td><td>参见wait</td></tr><tr><td>waitpid</td><td>等待指定子进程终止</td></tr><tr><td>wait4</td><td>参见waitpid</td></tr><tr><td>capget</td><td>获取进程权限</td></tr><tr><td>capset</td><td>设置进程权限</td></tr><tr><td>getsid</td><td>获取会晤标识号</td></tr><tr><td>setsid</td><td>设置会晤标识号</td></tr></tbody></table><p><br></p><p><strong>文件系统控制：</strong></p><ul><li>文件读写操作</li></ul><table><thead><tr><th>fcntl</th><th>文件控制</th></tr></thead><tbody><tr><td>open</td><td>打开文件</td></tr><tr><td>creat</td><td>创建新文件</td></tr><tr><td>close</td><td>关闭文件描述字</td></tr><tr><td>read</td><td>读文件</td></tr><tr><td>write</td><td>写文件</td></tr><tr><td>readv</td><td>从文件读入数据到缓冲数组中</td></tr><tr><td>writev</td><td>将缓冲数组里的数据写入文件</td></tr><tr><td>pread</td><td>对文件随机读</td></tr><tr><td>pwrite</td><td>对文件随机写</td></tr><tr><td>lseek</td><td>移动文件指针</td></tr><tr><td>_llseek</td><td>在64位地址空间里移动文件指针</td></tr><tr><td>dup</td><td>复制已打开的文件描述字</td></tr><tr><td>dup2</td><td>按指定条件复制文件描述字</td></tr><tr><td>flock</td><td>文件加/解锁</td></tr><tr><td>poll</td><td>I/O多路转换</td></tr><tr><td>truncate</td><td>截断文件</td></tr><tr><td>ftruncate</td><td>参见truncate</td></tr><tr><td>umask</td><td>设置文件权限掩码</td></tr><tr><td>fsync</td><td>把文件在内存中的部分写回磁盘</td></tr></tbody></table><ul><li>文件系统操作</li></ul><table><thead><tr><th>access</th><th>确定文件的可存取性</th></tr></thead><tbody><tr><td>chdir</td><td>改变当前工作目录</td></tr><tr><td>fchdir</td><td>参见chdir</td></tr><tr><td>chmod</td><td>改变文件方式</td></tr><tr><td>fchmod</td><td>参见chmod</td></tr><tr><td>chown</td><td>改变文件的属主或用户组</td></tr><tr><td>fchown</td><td>参见chown</td></tr><tr><td>lchown</td><td>参见chown</td></tr><tr><td>chroot</td><td>改变根目录</td></tr><tr><td>stat</td><td>取文件状态信息</td></tr><tr><td>lstat</td><td>参见stat</td></tr><tr><td>fstat</td><td>参见stat</td></tr><tr><td>statfs</td><td>取文件系统信息</td></tr><tr><td>fstatfs</td><td>参见statfs</td></tr><tr><td>readdir</td><td>读取目录项</td></tr><tr><td>getdents</td><td>读取目录项</td></tr><tr><td>mkdir</td><td>创建目录</td></tr><tr><td>mknod</td><td>创建索引节点</td></tr><tr><td>rmdir</td><td>删除目录</td></tr><tr><td>rename</td><td>文件改名</td></tr><tr><td>link</td><td>创建链接</td></tr><tr><td>symlink</td><td>创建符号链接</td></tr><tr><td>unlink</td><td>删除链接</td></tr><tr><td>readlink</td><td>读符号链接的值</td></tr><tr><td>mount</td><td>安装文件系统</td></tr><tr><td>umount</td><td>卸下文件系统</td></tr><tr><td>ustat</td><td>取文件系统信息</td></tr><tr><td>utime</td><td>改变文件的访问修改时间</td></tr><tr><td>utimes</td><td>参见utime</td></tr><tr><td>quotactl</td><td>控制磁盘配额</td></tr></tbody></table><p><br></p><p><strong>系统控制：</strong></p><table><thead><tr><th>ioctl</th><th>I/O总控制函数</th></tr></thead><tbody><tr><td>_sysctl</td><td>读/写系统参数</td></tr><tr><td>acct</td><td>启用或禁止进程记账</td></tr><tr><td>getrlimit</td><td>获取系统资源上限</td></tr><tr><td>setrlimit</td><td>设置系统资源上限</td></tr><tr><td>getrusage</td><td>获取系统资源使用情况</td></tr><tr><td>uselib</td><td>选择要使用的二进制函数库</td></tr><tr><td>ioperm</td><td>设置端口I/O权限</td></tr><tr><td>iopl</td><td>改变进程I/O权限级别</td></tr><tr><td>outb</td><td>低级端口操作</td></tr><tr><td>reboot</td><td>重新启动</td></tr><tr><td>swapon</td><td>打开交换文件和设备</td></tr><tr><td>swapoff</td><td>关闭交换文件和设备</td></tr><tr><td>bdflush</td><td>控制bdflush守护进程</td></tr><tr><td>sysfs</td><td>取核心支持的文件系统类型</td></tr><tr><td>sysinfo</td><td>取得系统信息</td></tr><tr><td>adjtimex</td><td>调整系统时钟</td></tr><tr><td>alarm</td><td>设置进程的闹钟</td></tr><tr><td>getitimer</td><td>获取计时器值</td></tr><tr><td>setitimer</td><td>设置计时器值</td></tr><tr><td>gettimeofday</td><td>取时间和时区</td></tr><tr><td>settimeofday</td><td>设置时间和时区</td></tr><tr><td>stime</td><td>设置系统日期和时间</td></tr><tr><td>time</td><td>取得系统时间</td></tr><tr><td>times</td><td>取进程运行时间</td></tr><tr><td>uname</td><td>获取当前UNIX系统的名称、版本和主机等信息</td></tr><tr><td>vhangup</td><td>挂起当前终端</td></tr><tr><td>nfsservctl</td><td>对NFS守护进程进行控制</td></tr><tr><td>vm86</td><td>进入模拟8086模式</td></tr><tr><td>create_module</td><td>创建可装载的模块项</td></tr><tr><td>delete_module</td><td>删除可装载的模块项</td></tr><tr><td>init_module</td><td>初始化模块</td></tr><tr><td>query_module</td><td>查询模块信息</td></tr><tr><td>*get_kernel_syms</td><td>取得核心符号,已被query_module代替</td></tr><tr><td>ioctl</td><td>I/O总控制函数</td></tr><tr><td>_sysctl</td><td>读/写系统参数</td></tr><tr><td>acct</td><td>启用或禁止进程记账</td></tr><tr><td>getrlimit</td><td>获取系统资源上限</td></tr><tr><td>setrlimit</td><td>设置系统资源上限</td></tr><tr><td>getrusage</td><td>获取系统资源使用情况</td></tr><tr><td>uselib</td><td>选择要使用的二进制函数库</td></tr><tr><td>ioperm</td><td>设置端口I/O权限</td></tr><tr><td>iopl</td><td>改变进程I/O权限级别</td></tr><tr><td>outb</td><td>低级端口操作</td></tr><tr><td>reboot</td><td>重新启动</td></tr><tr><td>swapon</td><td>打开交换文件和设备</td></tr><tr><td>swapoff</td><td>关闭交换文件和设备</td></tr><tr><td>bdflush</td><td>控制bdflush守护进程</td></tr><tr><td>sysfs</td><td>取核心支持的文件系统类型</td></tr><tr><td>sysinfo</td><td>取得系统信息</td></tr><tr><td>adjtimex</td><td>调整系统时钟</td></tr><tr><td>alarm</td><td>设置进程的闹钟</td></tr><tr><td>getitimer</td><td>获取计时器值</td></tr><tr><td>setitimer</td><td>设置计时器值</td></tr><tr><td>gettimeofday</td><td>取时间和时区</td></tr><tr><td>settimeofday</td><td>设置时间和时区</td></tr><tr><td>stime</td><td>设置系统日期和时间</td></tr><tr><td>time</td><td>取得系统时间</td></tr><tr><td>times</td><td>取进程运行时间</td></tr><tr><td>uname</td><td>获取当前UNIX系统的名称、版本和主机等信息</td></tr><tr><td>vhangup</td><td>挂起当前终端</td></tr><tr><td>nfsservctl</td><td>对NFS守护进程进行控制</td></tr><tr><td>vm86</td><td>进入模拟8086模式</td></tr><tr><td>create_module</td><td>创建可装载的模块项</td></tr><tr><td>delete_module</td><td>删除可装载的模块项</td></tr><tr><td>init_module</td><td>初始化模块</td></tr><tr><td>query_module</td><td>查询模块信息</td></tr><tr><td>*get_kernel_syms</td><td>取得核心符号,已被query_module代替</td></tr></tbody></table><p><br></p><p><strong>内存管理：</strong></p><table><thead><tr><th>brk</th><th>改变数据段空间的分配</th></tr></thead><tbody><tr><td>sbrk</td><td>参见brk</td></tr><tr><td>mlock</td><td>内存页面加锁</td></tr><tr><td>munlock</td><td>内存页面解锁</td></tr><tr><td>mlockall</td><td>调用进程所有内存页面加锁</td></tr><tr><td>munlockall</td><td>调用进程所有内存页面解锁</td></tr><tr><td>mmap</td><td>映射虚拟内存页</td></tr><tr><td>munmap</td><td>去除内存页映射</td></tr><tr><td>mremap</td><td>重新映射虚拟内存地址</td></tr><tr><td>msync</td><td>将映射内存中的数据写回磁盘</td></tr><tr><td>mprotect</td><td>设置内存映像保护</td></tr><tr><td>getpagesize</td><td>获取页面大小</td></tr><tr><td>sync</td><td>将内存缓冲区数据写回硬盘</td></tr><tr><td>cacheflush</td><td>将指定缓冲区中的内容写回磁盘</td></tr></tbody></table><p><br></p><p><strong>网络管理：</strong></p><table><thead><tr><th>getdomainname</th><th>取域名</th></tr></thead><tbody><tr><td>setdomainname</td><td>设置域名</td></tr><tr><td>gethostid</td><td>获取主机标识号</td></tr><tr><td>sethostid</td><td>设置主机标识号</td></tr><tr><td>gethostname</td><td>获取本主机名称</td></tr><tr><td>sethostname</td><td>设置主机名称</td></tr></tbody></table><p><br></p><p><strong>socket控制：</strong></p><table><thead><tr><th>socketcall</th><th>socket系统调用</th></tr></thead><tbody><tr><td>socket</td><td>建立socket</td></tr><tr><td>bind</td><td>绑定socket到端口</td></tr><tr><td>connect</td><td>连接远程主机</td></tr><tr><td>accept</td><td>响应socket连接请求</td></tr><tr><td>send</td><td>通过socket发送信息</td></tr><tr><td>sendto</td><td>发送UDP信息</td></tr><tr><td>sendmsg</td><td>参见send</td></tr><tr><td>recv</td><td>通过socket接收信息</td></tr><tr><td>recvfrom</td><td>接收UDP信息</td></tr><tr><td>recvmsg</td><td>参见recv</td></tr><tr><td>listen</td><td>监听socket端口</td></tr><tr><td>select</td><td>对多路同步I/O进行轮询</td></tr><tr><td>shutdown</td><td>关闭socket上的连接</td></tr><tr><td>getsockname</td><td>取得本地socket名字</td></tr><tr><td>getpeername</td><td>获取通信对方的socket名字</td></tr><tr><td>getsockopt</td><td>取端口设置</td></tr><tr><td>setsockopt</td><td>设置端口参数</td></tr><tr><td>sendfile</td><td>在文件或端口间传输数据</td></tr><tr><td>socketpair</td><td>创建一对已联接的无名socket</td></tr></tbody></table><p><br></p><p><strong>用户管理：</strong></p><table><thead><tr><th>getuid</th><th>获取用户标识号</th></tr></thead><tbody><tr><td>setuid</td><td>设置用户标志号</td></tr><tr><td>getgid</td><td>获取组标识号</td></tr><tr><td>setgid</td><td>设置组标志号</td></tr><tr><td>getegid</td><td>获取有效组标识号</td></tr><tr><td>setegid</td><td>设置有效组标识号</td></tr><tr><td>geteuid</td><td>获取有效用户标识号</td></tr><tr><td>seteuid</td><td>设置有效用户标识号</td></tr><tr><td>setregid</td><td>分别设置真实和有效的的组标识号</td></tr><tr><td>setreuid</td><td>分别设置真实和有效的用户标识号</td></tr><tr><td>getresgid</td><td>分别获取真实的,有效的和保存过的组标识号</td></tr><tr><td>setresgid</td><td>分别设置真实的,有效的和保存过的组标识号</td></tr><tr><td>getresuid</td><td>分别获取真实的,有效的和保存过的用户标识号</td></tr><tr><td>setresuid</td><td>分别设置真实的,有效的和保存过的用户标识号</td></tr><tr><td>setfsgid</td><td>设置文件系统检查时使用的组标识号</td></tr><tr><td>setfsuid</td><td>设置文件系统检查时使用的用户标识号</td></tr><tr><td>getgroups</td><td>获取后补组标志清单</td></tr><tr><td>setgroups</td><td>设置后补组标志清单</td></tr></tbody></table><p><br><br><br></p><p><strong>进程间通信：</strong></p><ul><li><p>ipc, 进程间通信总控制调用</p></li><li><p>信号</p></li></ul><table><thead><tr><th>sigaction</th><th>设置对指定信号的处理方法</th></tr></thead><tbody><tr><td>sigprocmask</td><td>根据参数对信号集中的信号执行阻塞/解除阻塞等操作</td></tr><tr><td>sigpending</td><td>为指定的被阻塞信号设置队列</td></tr><tr><td>sigsuspend</td><td>挂起进程等待特定信号</td></tr><tr><td>signal</td><td>参见signal</td></tr><tr><td>kill</td><td>向进程或进程组发信号</td></tr><tr><td>*sigblock</td><td>向被阻塞信号掩码中添加信号,已被sigprocmask代替</td></tr><tr><td>*siggetmask</td><td>取得现有阻塞信号掩码,已被sigprocmask代替</td></tr><tr><td>*sigsetmask</td><td>用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替</td></tr><tr><td>*sigmask</td><td>将给定的信号转化为掩码,已被sigprocmask代替</td></tr><tr><td>*sigpause</td><td>作用同sigsuspend,已被sigsuspend代替</td></tr><tr><td>sigvec</td><td>为兼容BSD而设的信号处理函数,作用类似sigaction</td></tr><tr><td>ssetmask</td><td>ANSI-C的信号处理函数,作用类似sigaction</td></tr></tbody></table><ul><li>消息</li></ul><table><thead><tr><th>msgctl</th><th>消息控制操作</th></tr></thead><tbody><tr><td>msgget</td><td>获取消息队列</td></tr><tr><td>msgsnd</td><td>发消息</td></tr><tr><td>msgrcv</td><td>取消息</td></tr></tbody></table><ul><li><p>管道</p><ul><li>pipe, 创建管道</li></ul></li><li><p>信号量</p></li></ul><table><thead><tr><th>shmctl</th><th>控制共享内存</th></tr></thead><tbody><tr><td>shmget</td><td>获取共享内存</td></tr><tr><td>shmat</td><td>连接共享内存</td></tr><tr><td>shmdt</td><td>拆卸共享内存</td></tr></tbody></table><ul><li>共享内存</li></ul><table><thead><tr><th>shmctl</th><th>控制共享内存</th></tr></thead><tbody><tr><td>shmget</td><td>获取共享内存</td></tr><tr><td>shmat</td><td>连接共享内存</td></tr><tr><td>shmdt</td><td>拆卸共享内存</td></tr></tbody></table><p><br><br><br></p><hr><p><br></p><h1 id="strace命令"><a href="#strace命令" class="headerlink" title="strace命令"></a>strace命令</h1><p>strace命令是一个集诊断、调试、统计与一体的工具，我们可以使用strace对应用的系统调用和信号传递的跟踪结果来对应用进行分析，以达到解决问题或者是了解应用工作过程的目的。当然strace与专业的调试工具比如说gdb之类的是没法相比的，因为它不是一个专业的调试器。</p><p>strace的最简单的用法就是执行一个指定的命令，在指定的命令结束之后它也就退出了。在命令执行的过程中，strace会记录和解析命令进程的所有系统调用以及这个进程所接收到的所有的信号值。</p><p>strace可跟踪一个命令或进程。</p><p><br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strace - trace system calls and signals</span><br><span class="line"></span><br><span class="line">strace --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="问题案例"><a href="#问题案例" class="headerlink" title="问题案例"></a>问题案例</h2><p>当发现进程或服务异常时，我们可以通过strace来跟踪其系统调用，“看看它在干啥”，进而找到异常的原因。熟悉常用系统调用，能够更好地理解和使用strace。<br>当然，万能的strace也不是真正的万能。当目标进程卡死在用户态时，strace就没有输出了。</p><ul><li>定位进程异常退出</li><li>定位共享内存异常</li><li>性能分析</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="pstack命令"><a href="#pstack命令" class="headerlink" title="pstack命令"></a>pstack命令</h1><p>pstack命令可显示每个进程(线程)的栈跟踪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gdb</span><br><span class="line"></span><br><span class="line">pstack $PID</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="lsof命令"><a href="#lsof命令" class="headerlink" title="lsof命令"></a>lsof命令</h1><p>lsof命令用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-a：列出打开文件存在的进程</span><br><span class="line">-c&lt;进程名&gt;：列出指定进程所打开的文件</span><br><span class="line">-g：列出GID号进程详情</span><br><span class="line">-d&lt;文件号&gt;：列出占用该文件号的进程</span><br><span class="line">+d&lt;目录&gt;：列出目录下被打开的文件</span><br><span class="line">+D&lt;目录&gt;：递归列出目录下被打开的文件</span><br><span class="line">-n&lt;目录&gt;：列出使用NFS的文件</span><br><span class="line">-i&lt;条件&gt;：列出符合条件的进程（4、6、协议、:端口、 @ip ）</span><br><span class="line">-p&lt;进程号&gt;：列出指定进程号所打开的文件</span><br><span class="line">-u：列出UID号进程详情</span><br><span class="line">-h：显示帮助信息</span><br><span class="line">-v：显示版本信息</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="高CPU占用分析"><a href="#高CPU占用分析" class="headerlink" title="高CPU占用分析"></a>高CPU占用分析</h1><p>步骤：</p><ul><li>查看进程 <code>top</code></li><li>查看线程 <code>top -H -p $pid</code></li><li>查看进程打开连接数 <code>lsof -p ${pid}</code></li><li>追踪 <code>strace -T -r -c -p $pid</code></li><li>栈 <code>pstack $pid</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7.x84_64&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;strace命令: &lt;a href=&quot;http://man.linuxde.net/strace&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://man.linuxde.net/strace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;pstack命令: &lt;a href=&quot;http://man.linuxde.net/pstack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://man.linuxde.net/pstack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;lsof命令: &lt;a href=&quot;http://man.linuxde.net/lsof&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://man.linuxde.net/lsof&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;系统调用: &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux系统调用列表: &lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html#8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html#8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;高CPU分析: &lt;a href=&quot;http://blog.51cto.com/yaocoder/1543352&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.51cto.com/yaocoder/1543352&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Linux" scheme="https://zhang21.github.io/tags/Linux/"/>
    
      <category term="系统调优" scheme="https://zhang21.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="https://zhang21.github.io/2018/05/06/Python/"/>
    <id>https://zhang21.github.io/2018/05/06/Python/</id>
    <published>2018-05-06T08:11:16.000Z</published>
    <updated>2018-07-13T08:18:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>环境:</p><ul><li>CentOS7x86_64</li><li>Python3.5</li></ul><p>参考:</p><ul><li>Python教程: <a href="https://docs.python.org/3.5/tutorial/index.html" target="_blank" rel="noopener">https://docs.python.org/3.5/tutorial/index.html</a></li><li>Python词汇表: <a href="https://docs.python.org/3.5/glossary.html" target="_blank" rel="noopener">https://docs.python.org/3.5/glossary.html</a></li><li>Python语言参考: <a href="https://docs.python.org/3.5/reference/index.html" target="_blank" rel="noopener">https://docs.python.org/3.5/reference/index.html</a></li><li>Python HOWTOs: <a href="https://docs.python.org/3.5/howto/index.html" target="_blank" rel="noopener">https://docs.python.org/3.5/howto/index.html</a></li><li>Python标准库: <a href="https://docs.python.org/3.5/library/" target="_blank" rel="noopener">https://docs.python.org/3.5/library/</a></li><li>PyPI: <a href="https://pypi.org/" target="_blank" rel="noopener">https://pypi.org/</a></li><li>Awesome-Python<ul><li><a href="https://github.com/vinta/awesome-python" target="_blank" rel="noopener">https://github.com/vinta/awesome-python</a></li><li><a href="https://github.com/jobbole/awesome-python-cn" target="_blank" rel="noopener">https://github.com/jobbole/awesome-python-cn</a></li></ul></li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><h1 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h1><ul><li><p><code>&gt;&gt;&gt;</code><br>交互式shell的默认Python提示符</p></li><li><p><code>...</code><br>在为缩进代码块输入代码时，或在一对匹配的左右分隔符中，交互式shell的默认Python提示符</p></li><li><p><code>2to3</code><br>将Python2.x代码转换为Python3.x代码的工具</p></li><li><p>抽象基类(abstract base class)</p></li><li><p>参数(argument)<br>调用函数时传递给(或方法)的值: 关键字参数/可选参数</p></li><li><p>异步上下文管理器(asynchronous context manager)<br>控制在异步语句中看到的环境对象</p></li><li><p>异步生成器(asynchronous generator)<br>返回一个生成器迭代器的函数</p></li><li><p>异步生成器迭代器(asynchronous generator iterator)<br>由异步生成器创建的对象</p></li><li><p>异步可迭代(asynchronous iterable)<br>一个对象</p></li><li><p>异步迭代器(asynchronous iterator)<br>一个对象</p></li><li><p>属性(attribute)<br>按名称引用的对象关联的值</p></li><li><p>awaitable<br>一个对象</p></li><li><p>二进制文件(binary file)<br>能读写bytes-like对象的文件对象</p></li><li><p>bytes-like对象<br>支持Buffer Protocol并可以导出C-contiguous buffer的对象</p></li><li><p>字节码(bytecode)<br>Python源代码被编译成字节码</p></li><li><p>类(class)<br>用于创建用户对象的模板</p></li><li><p>coercion<br>在涉及两个相同类型参数的操作中，将一个类型的实例隐式转换为另一个类型的实例</p></li><li><p>复数(complex number)</p></li><li><p>上下文管理器(context manager)</p></li><li><p>contiguous</p></li><li><p>协程(coroutine)</p></li><li><p>coroutine function</p></li><li><p>CPython<br>Python语言的规范实现</p></li><li><p>修饰器(decorator)<br>返回另一个函数的函数</p></li><li><p>描述(descriptor)</p></li><li><p>字典(dictionary)</p></li><li><p>字典视图(dictionary view)<br>从<code>dict.keys()</code>, <code>dict.values()</code>, <code>dict.items()</code>返回的对象称为字典视图</p></li><li><p>文档字符串(docstring)<br>在类，函数，或模块中的第一个表达式出现的字符串文字</p></li><li><p>duck-typing<br>一种编程风格</p></li><li><p>表达式(expression)</p></li><li><p>扩展模块(extension module)<br>由C/C++编写，通过Python API与核心和用户代码交互</p></li><li><p>f-string</p></li><li><p>文件对象(file object)</p></li><li><p>finder<br>为正在导入的模块查找加载程序的对象</p></li><li><p>地板除(floor division)</p></li><li><p>函数(function)</p></li><li><p>函数注释(function annotation)</p></li><li><p><code>__future__</code><br>可使用伪模块来启用与当前解释器不兼容的新语言功能</p></li><li><p>垃圾回收(garbage collection)<br>不再使用时释放内存的过程</p></li><li><p>生成器(generator)</p></li><li><p>generator iterator</p></li><li><p>生成器表达式(generator expression)<br>返回迭代器的表达式</p></li><li><p>通用函数(generic function)<br>由多个函数组成的函数</p></li><li><p>global interpreter lock<br>确保一次只有一个线程执行Python字节码的机制</p></li><li><p>hashable<br>如果一个对象具有在其生命周期内从不改变的hash值，并且可与其它对象相比，那么这个对象就是可hash的</p></li><li><p>IDLE<br>Python的集成开发环境</p></li><li><p>一成不变的(immutable)<br>具有固定值的对象</p></li><li><p>易变的(mutable)<br>可改变它们值得对象</p></li><li><p>import path</p></li><li><p>importing<br>一个模块中的Python代码在另一个Python代码中可获取</p></li><li><p>importer<br>既能找到又能加载模块的对象</p></li><li><p>交互式(interactive)</p></li><li><p>解释型(interpreted)<br>Python是一种解释型语言，与编译型语言相反</p></li><li><p>interpreter shutdown</p></li><li><p>迭代(iterable)<br>一次能够返回其成员的对象</p></li><li><p>迭代器(iterator)<br>表示数据流的对象</p></li><li><p>关键函数(key function)<br>关键函数或整理函数是一个可调用函数，它返回用于排序的值</p></li><li><p>关键字参数(keyword argument)</p></li><li><p>lambda<br>一个匿名内联函数，由调用该函数时评估的单个表达式组成</p></li><li><p>LBYL<br>三思而后行(Look before you leap)</p></li><li><p>列表(list)<br>一个内建Python序列</p></li><li><p>list comprehension<br>一种紧凑的方式来处理序列中的全部或部分元素，并返回列表和结果</p></li><li><p>loader<br>加载模块的对象</p></li><li><p>映射(mapping)<br>支持任意键查找并实现映射中指定方法的容器对象</p></li><li><p>meta path finder</p></li><li><p>metaclass<br>The class of a class</p></li><li><p>方法(method)<br>类里面定义的函数</p></li><li><p>method resolution order</p></li><li><p>模块(module)<br>Python代码的组织单元的对象</p></li><li><p>module spec</p></li><li><p>named tuple</p></li><li><p>命名空间(namespace)<br>变量存储的地方</p></li><li><p>namespace package<br>仅用作子包的包</p></li><li><p>嵌套范围(nested scope)<br>能够在封闭变量中引用变量</p></li><li><p>new-style class</p></li><li><p>对象(object)<br>具有状态和定义行为的任一数据</p></li><li><p>包(package)<br>可包含子模块或递归子模块的Python模块</p></li><li><p>参数(parameter)<br>函数或方法定义中的一个命名实体，用于指定该函数可接受的参数。<br>有5中参数:</p><ul><li>positional-or-keyword:</li><li>positional-only</li><li>keyword-only</li><li>var-positional</li><li>var-keyword</li></ul></li><li><p>path entry</p></li><li><p>path entry finder</p></li><li><p>path entry hook</p></li><li><p>path based finder</p></li><li><p>path-like object</p></li><li><p>portion<br>单目录中的一组文件</p></li><li><p>positional argument</p></li><li><p>provisional API</p></li><li><p>provisional package</p></li><li><p>Python 3000<br>Python3.x发行版的昵称</p></li><li><p>Python化(Pythonic)<br>与Python语言最常见的习惯用法密切相关的想法或代码片段，而不是使用其它语言通用的概念来实现该代码</p></li><li><p>合格的名字(qualified name)</p></li><li><p>引用计数(reference count)<br>对某个对象的引用次数</p></li><li><p>regular package</p></li><li><p><code>__slots__</code><br>类中的声明，通过预先声明实例属性的空间并消除实例字典来节省内存</p></li><li><p>序列(sequence)</p></li><li><p>单一调度(single dispatch)<br>通用函数调度的一种形式</p></li><li><p>切片(slice)<br>通常包含一部分序列的对象</p></li><li><p>special method<br>一种由Python隐式调用的方法</p></li><li><p>声明(statement)</p></li><li><p>struct sequence<br>具有命名元素的元组</p></li><li><p>text encoding</p></li><li><p>text file</p></li><li><p>三重引号(triple-quoted string)</p></li><li><p>type</p></li><li><p>通用换行符(universal newlines)<br>Unix: <code>\n</code>; Windows: <code>\r\n</code></p></li><li><p>变量注释(variable annotation)<br>与模块全局变量或类属性关联的类型元数据值</p></li><li><p>虚拟环境(virtual environment)</p></li><li><p>虚拟机(virtual machine)</p></li><li><p>Zen of Python<br>Pythono的设计原理和哲学</p></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p>官网: <a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a></p><p>Python教程非正式地向读者介绍了Python语言和系统的基本概念和功能。<br>Python是一种易于学习，功能强大的编程语言。它具有高效的高级数据结构以及面向对象(object-oriented)编程的简单而有效的方法。优雅的语法和动态类型以及其解释的特性，使其成为大多数平台上许多领域脚本编写(scripting)和快速应用程序开发的理想语言。<br>Python解释器很容易用C或C++实现新功能和数据类型进行扩展。Python也适合作为定制程序的扩展语言。</p><p>本教程非正式地向读者介绍了Python语言和系统的基本概念和功能，不会涵盖每个功能。相反，它引入了许多Python最值得注意的功能和语言风格。</p><p><br><br><br></p><h2 id="激起你的胃口"><a href="#激起你的胃口" class="headerlink" title="激起你的胃口"></a>激起你的胃口</h2><p>Whetting Your Appetite</p><p><br></p><p>将一些工作自动化，或编写一个小程序。</p><p>C/C++/Java，编写/编译/测试/重编译周期太慢，但你又不想为你的应用程序开发和设计一门全新的语言。</p><p>这样的话，Python就是适合你的语言！</p><p><br></p><p>为一些任务编写Unix shell script或Windows batch file，但它们只适合文本数据，而不适合GUI应用程序…<br>你可以编写C/C++/Java程序，但需要很长的开发时间。Python简单易用，可帮助你更快完成工作。</p><p>Python为大型程序提供更多的结构和支持，它提供了更多的错误检查。作为一种非常高级的语言，它有内建的高级数据类型(如灵活的数组和字典)。<br>由于其更通用的数据类型，Python适用于比<code>awk</code>甚至<code>Perl</code>更大的问题域，但Python中的许多事情至少与这些语言一样容易。</p><p>Python允许你将你的程序拆分成模块，使其它Python程序能重用。它附带了大量的标准模块，你可将它们作为学习Python编程的基础。包括了: 文件I/O；系统调用；socket；GUI…</p><p>Python是一种解释型语言，在程序开发中节省大量时间，因为不需要编译和链接。</p><p>Python可以使程序紧凑而易读，由Python编写的程序通常比等效的C/C++/Java程序代码少得多。原因如下:</p><ul><li>高级数据类型允许你在单个语句中表达复杂的操作</li><li>语句分组通过缩进(4个空格)来完成，而不是开始和结束</li><li>无需声明变量和参数</li></ul><p>Python是可扩展的，如果你会C编程的话，很容易为解释器添加一个新的内置函数或模块，或将Python程序链接到可用库的二进制形式。也可将Python解释器链接到C编写的应用程序中。</p><p>顺便说一句，该语言是根据BBC节目<strong>Monty Python’s Flying Circus</strong>命名，与爬行动物无关。</p><p>学习语言的最好方法就是使用它，以工代练！</p><p><br><br><br><br><br></p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>Python Interpreter</p><p><br></p><p>My Linux:</p><ul><li><code>/usr/bin/python3</code></li><li><code>/lib64/python3.5/</code></li></ul><p><br><br><br></p><h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><p>Interactive Mode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python3</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;for i in range(4):</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>Argument Passing</p><p><br></p><p>使用<code>sys</code>模块的<code>argv</code>变量给脚本传递参数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = len(sys.argv)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num != <span class="number">3</span>:</span><br><span class="line">    print(<span class="string">'Usage: xxx.py argv1 argv2'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'argu[0] is '</span> + sys.argv[<span class="number">0</span>])</span><br><span class="line">    print(<span class="string">'argu[1] is '</span> + sys.argv[<span class="number">1</span>])</span><br><span class="line">    print(<span class="string">'argu[2] is '</span> + sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chmod u+x xxx.py</span><br><span class="line"></span><br><span class="line">./argvPass.py <span class="number">1</span> <span class="number">22</span></span><br><span class="line">argu[<span class="number">0</span>] <span class="keyword">is</span> ./argvPass.py</span><br><span class="line">argu[<span class="number">1</span>] <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">argu[<span class="number">2</span>] <span class="keyword">is</span> <span class="number">22</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>Source Code Encoding</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>An Informal Introduction to Python</p><p><br></p><p>注意Python的两个默认提示符:</p><ul><li><code>&gt;&gt;&gt;</code></li><li><code>...</code></li></ul><p><br><br><br></p><h3 id="作为计算器"><a href="#作为计算器" class="headerlink" title="作为计算器"></a>作为计算器</h3><p>Using Python as a Calculator</p><p><br></p><h4 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+</span><br><span class="line"> -</span><br><span class="line">*</span><br><span class="line">/</span><br><span class="line">//(取商)</span><br><span class="line">%(取余)</span><br><span class="line">**</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">float</span><br><span class="line">decimal</span><br><span class="line">fraction(分数)</span><br><span class="line">comlex number(复数)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'(single quote)</span></span><br><span class="line"><span class="string">"(double quote)</span></span><br><span class="line"><span class="string">\(转义)</span></span><br><span class="line"><span class="string">r(元字符)</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">+</span></span><br><span class="line"><span class="string">*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">index</span></span><br><span class="line"><span class="string">string[-1]</span></span><br><span class="line"><span class="string">string[0:2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">len()</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list = [xx, x, ...]</span><br><span class="line"></span><br><span class="line">index</span><br><span class="line">list[index]</span><br><span class="line">list[start:stop]</span><br><span class="line"></span><br><span class="line">method</span><br><span class="line">append()</span><br><span class="line">pop()</span><br><span class="line">del()</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="编程第一步"><a href="#编程第一步" class="headerlink" title="编程第一步"></a>编程第一步</h3><p>First Steps Towards Programming</p><p><br></p><p>斐波那契数列(Fibonacci series)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> b &lt; <span class="number">10</span>:</span><br><span class="line">    print(b, end=<span class="string">','</span>)</span><br><span class="line">a, b = b, a+b</span><br><span class="line"></span><br><span class="line"> <span class="comment">#多重赋值(multiple assignment)</span></span><br><span class="line"> <span class="comment">#关键字参数(keyword argument)</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>Control Flow Tools</p><p><br></p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while Statements</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = input(int(<span class="string">'Please input an int: '</span>))</span><br><span class="line"></span><br><span class="line">whiel a &lt; <span class="number">50</span>:</span><br><span class="line">a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if Statements</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = int(input(<span class="string">"please input an int: "</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    print(<span class="string">'Negative changed to zero'</span>)</span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'Zero'</span>)</span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">'Single'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'More'</span>)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>for Statements</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">'a'</span>, <span class="string">'bb'</span>, <span class="string">'ccc'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">print(w, len(w))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">如果需要修改迭代中的序列，建议先制作副本，遍历一个序列并不会隐式地创建一个副本</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">words = [<span class="string">'a'</span>, <span class="number">22</span>, <span class="string">'ccc'</span>]</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words[:]:</span><br><span class="line">    <span class="keyword">if</span> type(w) <span class="keyword">is</span> int:</span><br><span class="line">words.insert(<span class="number">0</span>, w)</span><br><span class="line"></span><br><span class="line">words</span><br><span class="line">[<span class="number">22</span>, <span class="string">'a'</span>, <span class="number">22</span>, <span class="string">'ccc'</span>]</span><br></pre></td></tr></table></figure><p><br></p><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>The range() Function<br>遍历一系列数字</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">print(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>, <span class="number">10</span>):</span><br><span class="line">print(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">22</span>, <span class="string">'A'</span>, <span class="string">'AA'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a))</span><br><span class="line">print(i, a[i])</span><br><span class="line"></span><br><span class="line">list(range(<span class="number">5</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><br></p><p><strong>注意</strong><br>在许多方面，由<code>range()</code>返回的对象的行为就好像它是一个列表，但事实并非如此。它是一个对象，在你迭代时才返回所需序列，但它并不真正生成列表，从而节省空间。<br>我们说这样一个对象是可迭代的(iterable)。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(range(<span class="number">10</span>))</span><br><span class="line">range(<span class="number">0</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="break-continue"><a href="#break-continue" class="headerlink" title="break/continue"></a>break/continue</h3><p>break and continue Statements, and else Clauses on Loops</p><ul><li><code>break</code><ul><li>结束循环</li></ul></li><li><code>continue</code><ul><li>结束本次循环</li></ul></li></ul><p><br></p><h3 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h3><p>pass Statements<br><code>pass</code>语句什么也不做！当语句需要语法而程序不需要任何操作时，可使用它。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">emptyClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>Defining Functions<br>关键字<code>def</code>引入一个函数定义，必须跟随函数名称和形式参数。函数主体语句必须缩进</p><p>函数主体的第一个语句是可选的字符串文字(sting literal)，用于描述函数。<br>在编写的代码中包含文档字符串是一种很好的做法，请养成此习惯。</p><p>函数中的所有变量赋值都将值存储在本地符号表中，而变量引用首先在本地符号表中查找，然后是封闭函数的本地符号表，然后是全局符号表，最后是内置名称表。<br>因此，全局变量不能直接在函数内赋值(除非是<code>global</code>语句)，尽管它们可能被引用。</p><p>事实上即使是没有<code>return</code>语句的函数也会返回一个值，它被称为<code>None</code>(一个内建名)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="string">"""function's documentation</span></span><br><span class="line"><span class="string">   print a Fibonacci series up to n.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> a &lt; n:</span><br><span class="line">print(a, end=<span class="string">'  '</span>)</span><br><span class="line">a, b = b, a+b</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">fib(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">f = fib</span><br><span class="line">f(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">print(fib())</span><br><span class="line"><span class="keyword">None</span></span><br></pre></td></tr></table></figure><p><br></p><p>也可以使用可变数量的参数来定会函数。</p><p><br></p><h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>Default Argument Values</p><p>最有用的形式是为一个或多个参数指定默认值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ask_ok</span><span class="params">(prompt, retries=<span class="number">4</span>, reminder=<span class="string">'Please try again!'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        ok = input(prompt)</span><br><span class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">'y'</span>, <span class="string">'ye'</span>, <span class="string">'yes'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">'n'</span>, <span class="string">'no'</span>, <span class="string">'nop'</span>, <span class="string">'nope'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        retries = retries - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> retries &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid user response'</span>)</span><br><span class="line">        print(reminder)</span><br></pre></td></tr></table></figure><p>函数可通过如下方法调用:</p><ul><li>只给出必须的参数: <code>ask_os(&#39;Prompt xxx&#39;)</code></li><li>给出可选参数: <code>ask_ok(&#39;Prompt xx&#39;, 3)</code></li><li>给出所有参数: <code>ask_ok(agr1, arg2, arg3)</code></li></ul><p><br></p><h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>Keyword Arguments</p><p>也可使用<code>kwarg = value</code>来调用函数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parrot</span><span class="params">(voltage, state=<span class="string">'a stiff'</span>, action=<span class="string">'voom'</span>, type=<span class="string">'Norwegian Blue'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"-- This parrot wouldn't"</span>, action, end=<span class="string">' '</span>)</span><br><span class="line">    print(<span class="string">"if you put"</span>, voltage, <span class="string">"volts through it."</span>)</span><br><span class="line">    print(<span class="string">"-- Lovely plumage, the"</span>, type)</span><br><span class="line">    print(<span class="string">"-- It's"</span>, state, <span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parrot(<span class="number">1000</span>)                                          <span class="comment"># 1 positional argument</span></span><br><span class="line">parrot(voltage=<span class="number">1000</span>)                                  <span class="comment"># 1 keyword argument</span></span><br><span class="line">parrot(voltage=<span class="number">1000000</span>, action=<span class="string">'VOOOOOM'</span>)             <span class="comment"># 2 keyword arguments</span></span><br><span class="line">parrot(action=<span class="string">'VOOOOOM'</span>, voltage=<span class="number">1000000</span>)             <span class="comment"># 2 keyword arguments</span></span><br><span class="line">parrot(<span class="string">'a million'</span>, <span class="string">'bereft of life'</span>, <span class="string">'jump'</span>)         <span class="comment"># 3 positional arguments</span></span><br><span class="line">parrot(<span class="string">'a thousand'</span>, state=<span class="string">'pushing up the daisies'</span>)  <span class="comment"># 1 positional, 1 keyword</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="name-name"><a href="#name-name" class="headerlink" title="*name/**name"></a><code>*name/**name</code></h4><p><code>**name</code>，它接收一个字典(<code>keyword=value</code>)。可能与<code>*name</code>结合使用。<code>*name</code>必须出现在<code>**name</code>之前。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shop</span><span class="params">(kind, *arguments, **keywords)</span>:</span></span><br><span class="line">    print(<span class="string">"-- Do you have any "</span>, kind, <span class="string">"?"</span>)</span><br><span class="line">    print(<span class="string">"-- I'm sorry, we're all out of "</span>, kind)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> arguments:</span><br><span class="line">        print(arg)</span><br><span class="line">    print(<span class="string">'\n-----\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> kw <span class="keyword">in</span> keywords:</span><br><span class="line">        print(kw, <span class="string">':'</span>, keywords[kw])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shop(<span class="string">'Kind'</span>, <span class="string">'arg1'</span>, <span class="string">'arg2'</span>, kw1=<span class="string">'KW1'</span>, kw2=<span class="string">'KW2'</span>, kw3=<span class="string">'KW3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">-- Do you have any  Kind ?</span></span><br><span class="line"><span class="string">-- I'm sorry, we're all out of  Kind</span></span><br><span class="line"><span class="string">arg1</span></span><br><span class="line"><span class="string">arg2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-----</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">kw3 : KW3</span></span><br><span class="line"><span class="string">kw1 : KW1</span></span><br><span class="line"><span class="string">kw2 : KW2</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="任意参数列表"><a href="#任意参数列表" class="headerlink" title="任意参数列表"></a>任意参数列表</h4><p>Arbitrary Argument Lists</p><p>最不经常使用的选项是指定可以用任意数量的参数调用一个函数，这些参数将被封装在一个元组中。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arb</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">print(arg)</span><br><span class="line"></span><br><span class="line">art(<span class="number">1</span>, <span class="number">22</span>, <span class="string">'CCC'</span>)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="解包参数"><a href="#解包参数" class="headerlink" title="解包参数"></a>解包参数</h4><p>Unpacking Argument Lists</p><p>当参数已经在一个列表或元组中时，会出现相反的情况。需要对单独的位置参数的函数调用进行解包。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list(range(<span class="number">5</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">args = [<span class="number">5</span>]</span><br><span class="line">list(range(*args))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><br></p><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>可以使用<code>lambda</code>关键字创建小的匿名函数。<br>Lambda函数可用于需要函数对象的任何地方，它在语法上受限于单个表达式。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lambdaTest</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">lambda</span> x: x + n</span><br><span class="line"></span><br><span class="line">f = lambdaTest(<span class="number">10</span>)</span><br><span class="line">f(<span class="number">1</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">5</span>)</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h4><p>Documentation Strings</p><p>以下是关于文档字符串内容和格式的一些约定:</p><ul><li>第一行应该始终是对象目的的简短摘要</li><li>第二行应该是空白，如果有多行的话</li><li>以下几行应该是描述</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Document it.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This func just print one argument.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(sys.argv[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(func.__doc__)</span><br><span class="line"></span><br><span class="line">Document it.</span><br><span class="line">    This func just <span class="keyword">print</span> one argument.</span><br></pre></td></tr></table></figure><p><br></p><h4 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h4><p>Function Annotations</p><p>函数注释完全是关于用户定义函数使用的类型的可选元数据信息。</p><p>Annotations以字典的形式存储在函数的<code>__annotations__</code>属性中，并且不影响函数的其它部分。参数注释由参数名称后面的冒号<code>:</code>定义，后跟表达式评估注释的值。注释由参数列表和<code>def</code>语句结束的冒号之间的<code>-&gt;</code>定义，后跟一个表达式。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name: str, age: int = <span class="number">18</span>)</span> -&gt; str:</span></span><br><span class="line">    print(<span class="string">"Annotations: "</span>, f.__annotations__)</span><br><span class="line">    print(<span class="string">"Arguments: "</span>, name, age)</span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">'and'</span> + str(age)</span><br><span class="line"></span><br><span class="line">f(<span class="string">'Zhang21'</span>)</span><br></pre></td></tr></table></figure><p><br></p><h3 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h3><p>不同的语言有不同的编码风格。但是，让别人很轻松便能阅读你的代码总是一个好主意！</p><p>对于Python而言，PEP(Python Enhanced Proposals) 8 已成为大多数项目遵循的风格指南。它促进了非常可读和令人喜爱的编码风格，每个Python开发者都应该阅读它。<br>以下是最重要的几点：</p><ul><li>使用<code>4空格</code>缩进，而不是<code>tab</code></li><li><code>自动换行</code>，不要超过79个字符</li><li>使用<code>空白行</code>来分割函数和类，以及函数内的更大快代码</li><li>如有可能，请将<code>注释</code>放在它们的上一行</li><li>使用<code>文档字符串</code></li><li>在运算符和逗号后面使用空格，但不要直接在包围结构中使用空格 -&gt; <code>(a + b)</code></li><li>一致地命名函数和类</li><li>建议使用<code>UTF-8</code>编码方式</li><li>建议不要在标识符中使用non-ASCII字符，如果有其它语言的人会去维护代码</li></ul><p><br><br><br><br><br></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Data Structures</p><p><br></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>More on Lists</p><p><br></p><p>列表数据类型有多种方法：</p><ul><li><p><code>list.append(x)</code><br>添加一个项到列表的末尾</p></li><li><p><code>list.extend(iterable)</code><br>通过添加迭代中的所有项来扩展列表</p></li><li><p><code>list.insert(i, x)</code><br>在列表中给定位置插入一个项</p></li><li><p><code>list.remove(x)</code><br>删除列表中给定值的第一项</p></li><li><p><code>list.pop()</code><br>返回并删除列表中给定位置的项<br>如果未指定index，则默认为最后一项</p></li><li><p><code>list.clear()</code><br>删除列表中的所有项</p></li><li><p><code>list.index(x)</code><br>返回指定值的第一个索引<br>如果没有此值，返回ValueError</p></li><li><p><code>list.count(x)</code><br>返回列表中指定值出现的次数</p></li><li><p><code>list.sort()</code><br>对列表中的项进行排序</p></li><li><p><code>list.reverse()</code><br>反转列表中的元素</p></li><li><p><code>list.copy()</code><br>返回列表的shallow copy</p></li></ul><p><br></p><p><strong>列表用处：</strong></p><ul><li><p>Stack</p></li><li><p>Queue</p></li></ul><ul><li>列表解析<br>List Comprehensions</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#列表解析提供了一个简洁的方式来创建列表</span></span><br><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    l.append(i**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">#lambda</span></span><br><span class="line">l = list(map(<span class="keyword">lambda</span> i: i**<span class="number">2</span>, range(<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line"> <span class="comment">#or</span></span><br><span class="line">l = [x**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] <span class="keyword">if</span> x != y]</span><br></pre></td></tr></table></figure><ul><li>嵌套列表解析<br>Nested List Comprehensions</li></ul><p>列表解析中的初始表达式可以是任意表达式，包括另一个列表解析。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">[<span class="number">9</span>, <span class="number">10</span> ,<span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">[[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> l] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="del语句"><a href="#del语句" class="headerlink" title="del语句"></a>del语句</h3><p><code>del</code>语句可从列表中删除切片或整个列表。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a[:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="元组和序列"><a href="#元组和序列" class="headerlink" title="元组和序列"></a>元组和序列</h3><p>Tuples and Sequences</p><p><br></p><p>列表和字符串由许多共同属性，如索引和切片操作。<br>列表是可变的，它们的元素通常是同类，并且通过遍历列表可访问。</p><p>元组是不可变的！无法对元组项赋值，但可创建包含可变对象的元组。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">123</span>, <span class="number">321</span>, <span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line">tt = t, (<span class="string">'a'</span>, <span class="string">'bb'</span>)</span><br><span class="line"></span><br><span class="line">(<span class="number">123</span>, <span class="number">321</span>, <span class="string">'hello), ('</span>a<span class="string">', '</span>b<span class="string">b')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> #对元组赋值会出错</span></span><br><span class="line"><span class="string">t[0] = 888</span></span><br><span class="line"><span class="string">TypeError: '</span>tuple<span class="string">' object does not support item assignment</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> #序列拆包(unpacking)</span></span><br><span class="line"><span class="string"> #要求变量数量等于元素数量</span></span><br><span class="line"><span class="string">x, y, z = t</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">x</span></span><br><span class="line"><span class="string">123</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">y</span></span><br><span class="line"><span class="string">321</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">z</span></span><br><span class="line"><span class="string">'</span>hello<span class="string">'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Sets</p><p><br></p><p>Python中的集合是没有重复元素的无序集合，并支持数学操作:</p><ul><li>并集 <code>a | b</code></li><li>交集 <code>a &amp; b</code></li><li>差集 <code>a - b</code></li><li>异或 <code>a ^ b</code></li></ul><p>使用大(花)括号<code>{}</code>或<code>set()</code>创建集合，但创建一个空集合使用<code>set()</code>，而不是<code>{}</code>——后者创建一个空字典。</p><p>集合也支持集合解析。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">alpha = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>&#125;</span><br><span class="line"></span><br><span class="line">alpha</span><br><span class="line">&#123;<span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'c'</span> <span class="keyword">in</span> alpha</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#数学运算</span></span><br><span class="line">a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line">b = set(<span class="string">'alacazam'</span>)</span><br><span class="line"></span><br><span class="line">a | b</span><br><span class="line">a &amp; b</span><br><span class="line">a - b</span><br><span class="line">a ^ b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#集合解析</span></span><br><span class="line">&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abcdefgabc'</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'abc'</span>&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>Dictionaries</p><p><br></p><p>字典数据类型在其它语言中被称为“associative memories” or “associative arrays”。与由数字索引的序列不同，字典由<code>key</code>索引(可以是任何不可变类型)，字符串和数字都可作为<code>key</code>。如果元组只包含字符串，数字或元组，则可作为<code>key</code>。若包含任何可变对象，则不能作为<code>key</code>。你不能使用列表作为<code>key</code>。</p><p>可将字典视为无序的键:值对，并要求键是唯一！<br>花括号<code>{}</code>创建一个空字典。</p><p>字典的主要操作是用某个<code>key</code>存储<code>value</code>，并提取给定<code>key</code>的<code>value</code>。使用<code>del</code>语句删除一个键值对；新键值对会替换旧键值对。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">'name'</span>: <span class="string">'AA'</span>, <span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'tel'</span>: <span class="number">155</span>&#125;</span><br><span class="line">info[<span class="string">'addr'</span>] = <span class="string">'Chengdu'</span></span><br><span class="line"></span><br><span class="line">info</span><br><span class="line">info[<span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> info[<span class="string">'id'</span>]</span><br><span class="line"></span><br><span class="line">list(info.keys())</span><br><span class="line">print(info.values())</span><br><span class="line">print(info.items())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#dict()构造函数</span></span><br><span class="line">dict([(<span class="string">'name'</span>, <span class="string">'A'</span>), (<span class="string">'age'</span>, <span class="number">11</span>)])</span><br><span class="line">dict(&#123;<span class="string">'name'</span>: <span class="string">'A'</span>, <span class="string">'age'</span>: <span class="number">11</span>&#125;)</span><br><span class="line">dict(name=<span class="string">'zhang'</span>, age=<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">#字典解析</span></span><br><span class="line">&#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="循环技巧"><a href="#循环技巧" class="headerlink" title="循环技巧"></a>循环技巧</h3><p>Looping Techniques</p><p><br></p><ul><li>字典循环</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">'name'</span>: <span class="string">'AA'</span>, <span class="string">'age'</span>: <span class="number">11</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> info.items():</span><br><span class="line">    print(k, v, sep=<span class="string">':'</span>)</span><br><span class="line"></span><br><span class="line">name:AA</span><br><span class="line">age:<span class="number">11</span></span><br></pre></td></tr></table></figure><ul><li>序列循环<br>可使用<code>enumerate()</code>函数同时检索位置索引和相应值</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]):</span><br><span class="line">    print(i, v)</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> a</span><br><span class="line"><span class="number">1</span> b</span><br><span class="line"><span class="number">2</span> c</span><br></pre></td></tr></table></figure><ul><li>同时循环多个序列<br>要同时循环多个序列，可将这些条目与<code>zip()</code>函数配对</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aa = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">bb = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a, b <span class="keyword">in</span> zip(aa, bb):</span><br><span class="line">    print(<span class="string">'&#123;0&#125;, &#123;1&#125;'</span>.format(a, b))</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>, a</span><br><span class="line"><span class="number">2</span>, b</span><br><span class="line"><span class="number">3</span>, c</span><br></pre></td></tr></table></figure><ul><li>反向循环序列</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">6</span>)):</span><br><span class="line">    print(i, end=<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br></pre></td></tr></table></figure><ul><li>循环排序</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">'ac'</span>, <span class="string">'fb'</span>, <span class="string">'nx'</span>, <span class="string">'by'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sorted(l):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">ac</span><br><span class="line">by</span><br><span class="line">fb</span><br><span class="line">nx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll = [<span class="string">'ac'</span>, <span class="string">'fb'</span>, <span class="string">'nx'</span>, <span class="string">'by'</span>, <span class="string">'ac'</span>, <span class="string">'by'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sorted(set(ll)):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">ac</span><br><span class="line">by</span><br><span class="line">fb</span><br><span class="line">nx</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="关于条件"><a href="#关于条件" class="headerlink" title="关于条件"></a>关于条件</h3><p>More on Conditions</p><p><br></p><p><code>while</code>和<code>if</code>语句中使用的条件可以包含任何运算符，而不仅仅是比较。</p><p>比较操作符<code>in</code>和<code>not in</code>检查值是否在序列中<br>操作符<code>is</code>和<code>is not</code>比较两个对象是否相同，这适用于可变对象(如list)</p><p>比较操作可以使用布尔运算符<code>and</code>和<code>or</code>进行组合，结果可用<code>not</code>。它们的优先级低于比较操作<br>所有的比较操作符(comparison operators)具有相同的优先级，都低于数值运算符</p><p><br><br><br><br><br></p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>Modules</p><p><br></p><p>如果你从Python解释器中退出并重新进入，你所做的定义(函数和变量)将会丢失。因此，如果编写一个稍长的程序，最好使用文本编辑器，然后将代码文件作文输入来运行它。这就被称为创建一个脚本。<br>随着程序变长，可能需要将其分割为便于维护的多个文件。你可能还想使用你在多个程序中编写的某个功能(函数)，而不是将其定义复制到每个程序中。</p><p>为了支持此，Python有一种方法可将定义(definition)放入一个文件中，并在脚本或交互式实例中使用它们。这样的文件被称为模块(module)。<br>来自模块的定义可以被导入到其它模块或主模块中。</p><p>模块是一个包含Python定义和语句的文件。文件名是带有<code>.py</code>的模块名。<br>在模块中，模块的名称(string)用作全局变量<code>__name__</code>的值。</p><p><br></p><p><strong>编写一个模块：</strong><br><code>vim /path/fibo.py</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#Fibonacci numbers module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> b &lt; n:</span><br><span class="line">    print(b, end=<span class="string">' , '</span>)</span><br><span class="line">a, b = b, a+b</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib2</span><span class="params">(n)</span>:</span></span><br><span class="line">result = []</span><br><span class="line">a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> b &lt; n:</span><br><span class="line">result.appen(b)</span><br><span class="line">a, b = b, a+b</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>载入此模块：</strong><br>如果没有将此模块放入Python默认lib目录(如/usr/lib64/python3.5/)的话，则需要进入模块所在目录打开Python解释器。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd /path</span><br><span class="line"></span><br><span class="line">python3</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.fb(<span class="number">100</span>)</span><br><span class="line"><span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>,</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.fib2(<span class="number">100</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.__name__</span><br><span class="line"><span class="string">'fibo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.__str__()</span><br><span class="line">module <span class="string">'fibo'</span> <span class="keyword">from</span> <span class="string">'/path/fibo.py'</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="更多模块信息"><a href="#更多模块信息" class="headerlink" title="更多模块信息"></a>更多模块信息</h3><p>More on Modules</p><p>一个模块可以包含可执行语句以及函数定义。这些语句旨在初始化模块，它们仅在<code>import</code>语句中第一次遇到模块名称时执行。</p><p>每个模块都有自己的私人符号表(private symbol table)，它被模块中定义的所有函数(functions)用作全局符号表(global symbol talbe)。因此，模块的作者可以在模块中使用全局变量(global variable)，而不用担心与用户的全局变量发生意外冲突。</p><p>模块可以导入其它模块。习惯上(但不是硬性要求)，将<code>import</code>语句放在模块(脚本)的开头。导入模块的名称被放置在导入模块的全局符号表中。</p><p><br></p><ul><li>将模块名称直接导入到导入模块的符号表中，这不会在本地符号表中引入导入模块的名称</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#fibo模块名并没有被定义</span></span><br><span class="line"><span class="keyword">from</span> fibo <span class="keyword">import</span> fib, fib2</span><br></pre></td></tr></table></figure><ul><li>导入模块中定义的所有名称<br>在大多数情况下，Python程序员不会使用这个工具。因为它会向解释器引入一组未知的名称，可能会隐藏你已经定义的一些东西。<br>注意，通常从模块或包中<code>import *</code>的做法是不被接受的，因为它经常会导致代码可读性很差。但是，可以使用它来保存交互式会话中的输入。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#这会导入除了以下划线开头的所有名称</span></span><br><span class="line"><span class="keyword">from</span> fibo <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><ul><li>将导入模块名称绑定到指定名称</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fibo <span class="keyword">as</span> fib</span><br><span class="line"></span><br><span class="line">fib.fib(<span class="number">100</span>)</span><br><span class="line">fib.fib2(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fibo <span class="keyword">import</span> fib2 <span class="keyword">as</span> fibonacci</span><br><span class="line"></span><br><span class="line">fibonacci(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="把模块作为脚本来执行"><a href="#把模块作为脚本来执行" class="headerlink" title="把模块作为脚本来执行"></a>把模块作为脚本来执行</h4><p>Executing modules as scripts</p><p>如果你将模块中的<code>__name__</code>设置为<code>__main__</code>，模块中的代码就会被执行，就像导入它一样。这意味着你需要在你的模块的末尾添加它们。<br>如果模块被导入，代码也不会执行。</p><p>这通常用于为模块提供用户接口，或测试。</p><p><br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">fib(int(sys.argv[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">python3 fibo.py &#123;args&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="模块的搜索路径"><a href="#模块的搜索路径" class="headerlink" title="模块的搜索路径"></a>模块的搜索路径</h4><p>The Module Search Path</p><p>当<code>import fibo</code>模块时，解释器首先在内建模块中搜索此名称。如果找不到，它会在<code>sys.path</code>给出的目录列表中搜索<code>fibo.py</code>文件。</p><p><code>sys.path</code>从以下位置初始化：</p><ul><li>包含输入脚本的目录(未指定文件时的当前目录)</li><li>PYTHONPATH</li><li>依赖于安装的默认值</li><li>包含符号链接的目录不会被添加到模块的搜索路径中</li></ul><p><br></p><h4 id="编译的Python文件"><a href="#编译的Python文件" class="headerlink" title="编译的Python文件"></a>编译的Python文件</h4><p>“Compiled” Python files</p><p>为了加速载入模块，Python将每个模块的编译版本缓存在名为<code>module.version.pyc</code>的<code>__pycache__</code>目录下，对编译文件的格式进行编码，它通常包含Python版本号。<br>Python根据编译后的版本检查源代码的修改日期，看它是否过期并需要重新编译。这是一个完全自动的过程。另外，编译后的模块时独立于平台的，因此可以在不同体系结构的系统之间共享相同的库。</p><p>有两种情况，Python不会检查缓存：</p><ul><li>总是重新编译并且不存储从命令行直接加载的模块的结果</li><li>没有源模块</li></ul><p><br></p><p><strong>专家提示：</strong></p><ul><li>可以Python命令中使用<code>-0</code>或<code>-00</code>来减少已编译模块的大小</li><li>读取<code>.pyc</code>文件不会比<code>.py</code>文件快，唯一更快的事情是它们被加载的速度</li><li>模块<code>compileall</code>可以为目录中的所有模块创建<code>.pyc</code>文件</li><li>更多细节，参见PEP 3147</li></ul><p><br><br><br></p><h3 id="标准模块"><a href="#标准模块" class="headerlink" title="标准模块"></a>标准模块</h3><p>Standard Modules</p><p><br></p><p>Python提供了一个标准模块库。</p><p>一些模块被内置到解释器中，提供了对操作的访问。这些操作不属于语言核心的一部分，但是为了提高效率或提供对操作系统的访问权限。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.ps1</span><br><span class="line"><span class="string">'&gt;&gt;&gt;'</span></span><br><span class="line">sys.ps2</span><br><span class="line"><span class="string">'...'</span></span><br><span class="line"></span><br><span class="line">sys.ps1 = <span class="string">'&lt;&lt;&lt;'</span></span><br><span class="line">sys.ps1</span><br><span class="line"><span class="string">'&lt;&lt;&lt;'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#查看PYTHONPATH</span></span><br><span class="line">sys.path.__str__</span><br><span class="line"> <span class="comment">#添加PYTHONPATH</span></span><br><span class="line">sys.path.append(<span class="string">'/home/zhang/venv/python'</span>)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a><code>dir()</code>函数</h3><p>内建函数<code>dir()</code>用于找出模块定义的名称。<br>它列出所有类型的名称： 变量，模块，函数…</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fibo, sys</span><br><span class="line"></span><br><span class="line">dir(fibo)</span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__cached__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__file__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'fib'</span>, <span class="string">'fib2'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dir(sys)</span><br><span class="line">[<span class="string">'__displayhook__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__excepthook__'</span>, <span class="string">'__interactivehook__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'__stderr__'</span>, <span class="string">'__stdin__'</span>, <span class="string">'__stdout__'</span>, <span class="string">'_clear_type_cache'</span>, <span class="string">'_current_frames'</span>, <span class="string">'_debugmallocstats'</span>, <span class="string">'_getframe'</span>, <span class="string">'_home'</span>, <span class="string">'_mercurial'</span>, <span class="string">'_xoptions'</span>, <span class="string">'abiflags'</span>, <span class="string">'api_version'</span>, <span class="string">'argv'</span>, <span class="string">'base_exec_prefix'</span>, <span class="string">'base_prefix'</span>, <span class="string">'builtin_module_names'</span>, <span class="string">'byteorder'</span>, <span class="string">'call_tracing'</span>, <span class="string">'callstats'</span>, <span class="string">'copyright'</span>, <span class="string">'displayhook'</span>, <span class="string">'dont_write_bytecode'</span>, <span class="string">'exc_info'</span>, <span class="string">'excepthook'</span>, <span class="string">'exec_prefix'</span>, <span class="string">'executable'</span>, <span class="string">'exit'</span>, <span class="string">'flags'</span>, <span class="string">'float_info'</span>, <span class="string">'float_repr_style'</span>, <span class="string">'getallocatedblocks'</span>, <span class="string">'getcheckinterval'</span>, <span class="string">'getdefaultencoding'</span>, <span class="string">'getdlopenflags'</span>, <span class="string">'getfilesystemencoding'</span>, <span class="string">'getprofile'</span>, <span class="string">'getrecursionlimit'</span>, <span class="string">'getrefcount'</span>, <span class="string">'getsizeof'</span>, <span class="string">'getswitchinterval'</span>, <span class="string">'gettrace'</span>, <span class="string">'hash_info'</span>, <span class="string">'hexversion'</span>, <span class="string">'implementation'</span>, <span class="string">'int_info'</span>, <span class="string">'intern'</span>, <span class="string">'last_traceback'</span>, <span class="string">'last_type'</span>, <span class="string">'last_value'</span>, <span class="string">'maxsize'</span>, <span class="string">'maxunicode'</span>, <span class="string">'meta_path'</span>, <span class="string">'modules'</span>, <span class="string">'path'</span>, <span class="string">'path_hooks'</span>, <span class="string">'path_importer_cache'</span>, <span class="string">'platform'</span>, <span class="string">'prefix'</span>, <span class="string">'ps1'</span>, <span class="string">'ps2'</span>, <span class="string">'setcheckinterval'</span>, <span class="string">'setdlopenflags'</span>, <span class="string">'setprofile'</span>, <span class="string">'setrecursionlimit'</span>, <span class="string">'setswitchinterval'</span>, <span class="string">'settrace'</span>, <span class="string">'stderr'</span>, <span class="string">'stdin'</span>, <span class="string">'stdout'</span>, <span class="string">'thread_info'</span>, <span class="string">'version'</span>, <span class="string">'version_info'</span>, <span class="string">'warnoptions'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#它不会列出内建函数和变量的名称，除非如下操作</span></span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line">dir(builtins)</span><br><span class="line"></span><br><span class="line">[<span class="string">'ArithmeticError'</span>, <span class="string">'AssertionError'</span>, <span class="string">'AttributeError'</span>, <span class="string">'BaseException'</span>, <span class="string">'BlockingIOError'</span>, <span class="string">'BrokenPipeError'</span>, <span class="string">'BufferError'</span>, <span class="string">'BytesWarning'</span>, <span class="string">'ChildProcessError'</span>, <span class="string">'ConnectionAbortedError'</span>, <span class="string">'ConnectionError'</span>, <span class="string">'ConnectionRefusedError'</span>, <span class="string">'ConnectionResetError'</span>, <span class="string">'DeprecationWarning'</span>, <span class="string">'EOFError'</span>, <span class="string">'Ellipsis'</span>, <span class="string">'EnvironmentError'</span>, <span class="string">'Exception'</span>, <span class="string">'False'</span>, <span class="string">'FileExistsError'</span>, <span class="string">'FileNotFoundError'</span>, <span class="string">'FloatingPointError'</span>, <span class="string">'FutureWarning'</span>, <span class="string">'GeneratorExit'</span>, <span class="string">'IOError'</span>, <span class="string">'ImportError'</span>, <span class="string">'ImportWarning'</span>, <span class="string">'IndentationError'</span>, <span class="string">'IndexError'</span>, <span class="string">'InterruptedError'</span>, <span class="string">'IsADirectoryError'</span>, <span class="string">'KeyError'</span>, <span class="string">'KeyboardInterrupt'</span>, <span class="string">'LookupError'</span>, <span class="string">'MemoryError'</span>, <span class="string">'NameError'</span>, <span class="string">'None'</span>, <span class="string">'NotADirectoryError'</span>, <span class="string">'NotImplemented'</span>, <span class="string">'NotImplementedError'</span>, <span class="string">'OSError'</span>, <span class="string">'OverflowError'</span>, <span class="string">'PendingDeprecationWarning'</span>, <span class="string">'PermissionError'</span>, <span class="string">'ProcessLookupError'</span>, <span class="string">'ReferenceError'</span>, <span class="string">'ResourceWarning'</span>, <span class="string">'RuntimeError'</span>, <span class="string">'RuntimeWarning'</span>, <span class="string">'StopIteration'</span>, <span class="string">'SyntaxError'</span>, <span class="string">'SyntaxWarning'</span>, <span class="string">'SystemError'</span>, <span class="string">'SystemExit'</span>, <span class="string">'TabError'</span>, <span class="string">'TimeoutError'</span>, <span class="string">'True'</span>, <span class="string">'TypeError'</span>, <span class="string">'UnboundLocalError'</span>, <span class="string">'UnicodeDecodeError'</span>, <span class="string">'UnicodeEncodeError'</span>, <span class="string">'UnicodeError'</span>, <span class="string">'UnicodeTranslateError'</span>, <span class="string">'UnicodeWarning'</span>, <span class="string">'UserWarning'</span>, <span class="string">'ValueError'</span>, <span class="string">'Warning'</span>, <span class="string">'ZeroDivisionError'</span>, <span class="string">'_'</span>, <span class="string">'__build_class__'</span>, <span class="string">'__debug__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__import__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'abs'</span>, <span class="string">'all'</span>, <span class="string">'any'</span>, <span class="string">'ascii'</span>, <span class="string">'bin'</span>, <span class="string">'bool'</span>, <span class="string">'bytearray'</span>, <span class="string">'bytes'</span>, <span class="string">'callable'</span>, <span class="string">'chr'</span>, <span class="string">'classmethod'</span>, <span class="string">'compile'</span>, <span class="string">'complex'</span>, <span class="string">'copyright'</span>, <span class="string">'credits'</span>, <span class="string">'delattr'</span>, <span class="string">'dict'</span>, <span class="string">'dir'</span>, <span class="string">'divmod'</span>, <span class="string">'enumerate'</span>, <span class="string">'eval'</span>, <span class="string">'exec'</span>, <span class="string">'exit'</span>, <span class="string">'filter'</span>, <span class="string">'float'</span>, <span class="string">'format'</span>, <span class="string">'frozenset'</span>, <span class="string">'getattr'</span>, <span class="string">'globals'</span>, <span class="string">'hasattr'</span>, <span class="string">'hash'</span>, <span class="string">'help'</span>, <span class="string">'hex'</span>, <span class="string">'id'</span>, <span class="string">'input'</span>, <span class="string">'int'</span>, <span class="string">'isinstance'</span>, <span class="string">'issubclass'</span>, <span class="string">'iter'</span>, <span class="string">'len'</span>, <span class="string">'license'</span>, <span class="string">'list'</span>, <span class="string">'locals'</span>, <span class="string">'map'</span>, <span class="string">'max'</span>, <span class="string">'memoryview'</span>, <span class="string">'min'</span>, <span class="string">'next'</span>, <span class="string">'object'</span>, <span class="string">'oct'</span>, <span class="string">'open'</span>, <span class="string">'ord'</span>, <span class="string">'pow'</span>, <span class="string">'print'</span>, <span class="string">'property'</span>, <span class="string">'quit'</span>, <span class="string">'range'</span>, <span class="string">'repr'</span>, <span class="string">'reversed'</span>, <span class="string">'round'</span>, <span class="string">'set'</span>, <span class="string">'setattr'</span>, <span class="string">'slice'</span>, <span class="string">'sorted'</span>, <span class="string">'staticmethod'</span>, <span class="string">'str'</span>, <span class="string">'sum'</span>, <span class="string">'super'</span>, <span class="string">'tuple'</span>, <span class="string">'type'</span>, <span class="string">'vars'</span>, <span class="string">'zip'</span>]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>Packages</p><p><br></p><p>包是通过”dotted(.) module names“，来构造Python模块命名空间的一种方式。</p><p>假设你想设计一个模块集(包)来统一处理声音文件和声音数据。有许多不同的声音文件格式。因此你需要创建和维护不断增长的模块集合，以便在各种文件格式之间进行转换。你还可能需要对声音数据执行各种不同的操作，因此你还需要编写无止境的模块流以执行这些操作。</p><p>这可能是一个包结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sound/                          Top-level package</span><br><span class="line">      __init__.py               Initialize the sound package</span><br><span class="line">      formats/                  Subpackage for file format conversions</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              aiffread.py</span><br><span class="line">              aiffwrite.py</span><br><span class="line">              auread.py</span><br><span class="line">              auwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects/                  Subpackage for sound effects</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters/                  Subpackage for filters</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure><p>当导入包时，Python将搜索<code>sys.path</code>，并查找包的子目录。<br>需要<code>__init__.py</code>文件才能使Python将目录视为包含包。这是为了防止具有通用名称的目录(如字符串)无意中隐藏稍后在模块搜索路径中发生的有效模块。<br>在最简单的情况下，<code>__init__.py</code>可以是一个空文件，但它也可以执行包的初始化代码。</p><p>导入包:</p><ul><li><p><code>from package import item</code><br>item可以是子模块，子包，函数，类，变量<br>import语句首先测试项目是否在包中定义。 如果不在，它假定它是一个模块并尝试加载它。如果找不到它，则会引发ImportError异常</p></li><li><p><code>import item.subitem.subsubitem</code><br>相反，当使用这种语法时，除最后一项外必须都是一个包，最后一项可以是模块或包，但不能是类或函数或变量</p></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</span><br></pre></td></tr></table></figure><p><br></p><h4 id="importing-from-a-package"><a href="#importing-from-a-package" class="headerlink" title="importing * from a package"></a>importing * from a package</h4><p>当输入<code>from sound.effects import *</code>会发生什么？理想情况下，人们会希望以某种方式进入文件系统，查找包中存在哪些子模块，然后将它们全部导入。这可能需要很长时间，并且导入子模块可能具有不希望的副作用，这些副作用在明确导入子模块时才会发生。</p><p>唯一的解决方案是软件包作者提供包的明确索引。<code>import</code>使用以下声明: 如果某个包的<code>__init__.py</code>定义了一个名为<code>__all__</code>的列表，则它将成为<code>from package import *</code>时应该导入的模块名称列表。<br>当软件包新版本发布时，软件包作者需要保持该列表是最新版本。</p><p>栗子<code>sound/effects/__init__.py</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> #这意味着from sound.effects import *只会导入以下子模块</span><br><span class="line">__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]</span><br></pre></td></tr></table></figure><p><br></p><p>如果<code>__all__</code>没有被定义，则<code>from sound.effcts import *</code>语句不会将包<code>sound.effects</code>中所有子模块导入到当前命名空间。它只能确保包<code>sound.effects</code>被导入，然后导入包中定义的任何名称。这包括<code>__init__.py</code>定义的任何名称，还包括由以前的导入语句显示加载的软件包的任何子模块。</p><p>请记住，使用<code>from packagee import submodule</code>没有任何问题。事实上，这也是推荐的方法。除非导入模块需要使用不同包中具有相同名称的子模块。</p><p><br></p><h4 id="内部包装"><a href="#内部包装" class="headerlink" title="内部包装"></a>内部包装</h4><p>Intra-package References</p><p>当包被构建为子包时，可以使用绝对导入来引用邻包中的模块。<br>同样，也可以使用相对导入来导入邻包中的模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> #Absolute</span><br><span class="line">from sound.effects import echo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> #Relative</span><br><span class="line">from . import echo</span><br><span class="line">from .. import formats</span><br><span class="line">from ..filter import equalizer</span><br></pre></td></tr></table></figure><p><br></p><h4 id="多个目录中的包"><a href="#多个目录中的包" class="headerlink" title="多个目录中的包"></a>多个目录中的包</h4><p>Packages in Multiple Directories</p><p>包还支持一个特殊的属性<code>__path__</code>。在执行该文件中的代码之前，它被初始化为一个包含<code>__init__.py</code>的目录名称的列表。这个变量可以修改，这样做会影响将对包中包含的模块和子包的搜索。</p><p>虽然此功能通常不是必需的，但它可用于扩展包中找到的一组模块。</p><p><br><br><br></p><hr><p><br></p><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>Input and Output<br>有多种方式来呈现程序的输出；数据也可以打印成人类可读的形式，或写入文件供将来使用。</p><p><br></p><h3 id="幻想的输出格式"><a href="#幻想的输出格式" class="headerlink" title="幻想的输出格式"></a>幻想的输出格式</h3><p>Fancier Output Formatting</p><p>到目前为止，我们知晓两种写入值的方法:</p><ul><li>表达式语句</li><li><code>print()</code>函数</li></ul><p>有两种方法可以格式化输出：</p><ul><li>自己完成所有的字符串处理(使用切片和连接操作，你可创建任何你能想到的布局)</li><li>格式化字符串文字或<code>str.format()</code>方法</li></ul><p><br></p><p>string模块提供了一个Template类，它提供了另一种将值替换为字符串的方法。<br>Python有办法将任何值转换为字符串：将它传递给<code>repr()</code>或<code>str()</code>函数。</p><p><code>str()</code>函数，用于返回相当可读(human-readable)的值的表示<br><code>repr()</code>函数，用于生成可由解释器读取的表示<br>对于没有人定义的特定表示的对象，<code>str()</code>将返回与<code>repr()</code>相同的值</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    print(repr(x).rjust(<span class="number">2</span>), repr(x**<span class="number">2</span>).rjust(<span class="number">3</span>), end=<span class="string">' '</span>)</span><br><span class="line">print(repr(x**<span class="number">3</span>).rjust(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"> <span class="comment">#Or</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    print(<span class="string">'&#123;0:2d&#125; &#123;1:3d&#125; &#123;2:4d&#125;'</span>.format(x, x**<span class="number">2</span>, x**<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>   <span class="number">1</span>    <span class="number">1</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">4</span>    <span class="number">8</span></span><br><span class="line">  <span class="number">3</span>   <span class="number">9</span>   <span class="number">27</span></span><br><span class="line">  <span class="number">4</span>  <span class="number">16</span>   <span class="number">64</span></span><br><span class="line">  <span class="number">5</span>  <span class="number">25</span>  <span class="number">125</span></span><br></pre></td></tr></table></figure><p><br></p><p>字符串对象的<code>str.rjust()方法</code>，它在给定宽度的字段中通过填充左边的空格来右对齐字符串。类似方法还有: <code>str.ljust()</code>, <code>str.center()</code>。这些方法不写入任何东西，它们只是返回一个新的字符串。</p><p>还有一种<code>str.zfill()</code>方法，它在数字字符串的左边填充数字0，它能识别加号和减号：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'12'</span>.zfill(<span class="number">5</span>)</span><br><span class="line"><span class="string">'00012'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'-3.14'</span>.zfill(<span class="number">7</span>)</span><br><span class="line"><span class="string">'-003.14'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'3.1415678'</span>.zfill(<span class="number">5</span>)</span><br><span class="line"><span class="string">'3.1415678'</span></span><br></pre></td></tr></table></figure><p><br></p><p><code>str.formatt()</code>方法:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#&#123;&#125;</span></span><br><span class="line">print(<span class="string">'We are &#123;&#125; who say &#123;&#125; is "&#123;&#125;!".format('</span>A<span class="string">', '</span>BB<span class="string">', '</span>WONDERFUL<span class="string">'))</span></span><br><span class="line"><span class="string">We are A who say BB is "WONDERFUL!"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> #括号中的数字用来指向传入的位置</span></span><br><span class="line"><span class="string"> #&#123;index&#125;,从0开始</span></span><br><span class="line"><span class="string">print('</span>&#123;<span class="number">0</span>&#125; <span class="keyword">and</span> &#123;<span class="number">1</span>&#125;<span class="string">'.format('</span>A<span class="string">', '</span>BB<span class="string">'))</span></span><br><span class="line"><span class="string">A and BB</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print('</span>&#123;<span class="number">1</span>&#125; <span class="keyword">and</span> &#123;<span class="number">0</span>&#125;<span class="string">'.format('</span>A<span class="string">', '</span>BB<span class="string">'))</span></span><br><span class="line"><span class="string">BB and A</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> #关键字参数</span></span><br><span class="line"><span class="string">print('</span>My name <span class="keyword">is</span> &#123;name&#125;, I\<span class="string">'m &#123;age&#125; years old!'</span>.format(name=<span class="string">'Zhang21'</span>, age=<span class="number">21</span>))</span><br><span class="line">My name <span class="keyword">is</span> Zhang21, I<span class="string">'m 21 years old!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> #位置参数和关键字参数的组合</span></span><br><span class="line"><span class="string">print('</span>The story of &#123;<span class="number">0</span>&#125;, &#123;<span class="number">1</span>&#125;, <span class="keyword">and</span> &#123;other&#125;<span class="string">'.format('</span>A<span class="string">', '</span>BB<span class="string">', other='</span>CCC<span class="string">'))</span></span><br><span class="line"><span class="string">The story of A, BB, and CCC</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line">!a, 应用ascii()</span><br><span class="line">!s, 应用str()</span><br><span class="line">!r, 应用repr()</span><br><span class="line">:, 更好的控制格式</span><br><span class="line">:<span class="number">5</span></span><br><span class="line">:<span class="number">7</span>d</span><br><span class="line">:<span class="number">.3</span>f</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">print('My full name is &#123;!s&#125;'.format('Zhang21'))</span></span><br><span class="line"><span class="string">My full name is Zhang21</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print('My full name is &#123;!r&#125;'.format('Zhang21'))</span></span><br><span class="line"><span class="string">My full name is 'Zhang21'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print('The value of &#123;&#125; is approximately &#123;:.3f&#125;'.format('PI', 3.141567))</span></span><br><span class="line"><span class="string">The value of PI is approximately 3.142</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">info = &#123;'A': 68, 'BB': 79, 'CCC': 89&#125;</span></span><br><span class="line"><span class="string">for k, v in info.items():</span></span><br><span class="line"><span class="string">     print('&#123;0:5&#125; ==&gt; &#123;1:6d&#125;'.format(k, v))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">A     ==&gt;     68</span></span><br><span class="line"><span class="string">BB    ==&gt;     79</span></span><br><span class="line"><span class="string">CCC   ==&gt;     89</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print('A: &#123;A:d&#125;; B: &#123;BB:d&#125;, C: &#123;CCC:d&#125;'.format(**info))</span></span><br><span class="line"><span class="string">A: 68; B: 79, C: 89</span></span><br></pre></td></tr></table></figure><p><br></p><p><code>%</code>操作符同样可用于字符格式化:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'The value of %s is approximately %5.3f'</span> % (<span class="string">'PI'</span>, <span class="number">3.1415678</span>))</span><br><span class="line">The value of PI <span class="keyword">is</span> approximately <span class="number">3.142</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>Reading and Writing Files</p><p><code>open()</code>返回一个文件对象，它最常用的两个参数：<code>open(filename, mode)</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'/tmp/1.txt, '</span><span class="string">r')</span></span><br><span class="line"><span class="string">f.readline()</span></span><br><span class="line"><span class="string">'</span><span class="number">1</span>\n<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">f.closed</span></span><br><span class="line"><span class="string">Fasle</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">f.close()</span></span><br><span class="line"><span class="string">f.closed</span></span><br><span class="line"><span class="string">True</span></span><br></pre></td></tr></table></figure><p>mode:</p><ul><li><code>r</code>: read only，未指定模式时的默认模式</li><li><code>w</code>: only writing</li><li><code>a</code>: appending</li><li><code>r+</code>: reading and writing</li><li><code>b</code>: binary mode</li></ul><p>通常情况下，文件以文本模式打开，这意味着你可读写文件中的字符串，并以特定编码方式进行编码(如UTF-8)。如果未指定编码，则默认值取决于平台。<br><code>b</code>以二进制模式打开文件，数据以字节对象的形式读写，该模式应该用于所有不包含文本的文件。在读写文件时要非常小心的使用二进制模式。</p><p>推荐使用<code>with</code>关键字处理文件对象，优点是，即使在某个时间点出现异常，文件在其套件结束后也能正常关闭。也比<code>try-finally</code>块短得多。<br>如果没有使用<code>with</code>关键字，则你需要调用<code>f.close()</code>来关闭文件，并立即释放它使用的系统资源。如果你没有明确关闭一个文件，Python的垃圾回收器最终会摧毁这个对象并为你关闭吧这个打开的文件，但这个文件可能会保持打开一段时间。<br>在关闭文件对象之后，尝试使用文件对象将会自动失败。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/1.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    read_Data = f.read()</span><br><span class="line"></span><br><span class="line">f.closed</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f.read()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: I/O operation on closed file.</span><br></pre></td></tr></table></figure><p><br></p><h4 id="文件对象方法"><a href="#文件对象方法" class="headerlink" title="文件对象方法"></a>文件对象方法</h4><p>Methods of File Objects</p><p><code>f.read(size)</code>读取文件内容，以字符串或字节对象的形式返回。size是一个可选的数值参数，当size被忽略或为负数时，文件的全部内容被读取并返回。如果超过内存限制，那就是你的问题了。<br><code>f.readline()</code>从文件读取一行，换行符Unix<code>\n</code>，Windows<code>\r\n</code><br><code>f.readlines()</code>, <code>list(f)</code>读取文件的所有行<br><code>f.write(string)</code>向文件中写入字符内容，并返回写入的字符数<br><code>f.tell()</code>返回一个整数，表示二进制模式下文件开头的字节数<br><code>f.seek(offset, from_what)</code>改变文件对象的位置</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'/tmp/1.txt'</span>, <span class="string">'r+'</span>)</span><br><span class="line">f.write(<span class="string">'Line4\n'</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"></span><br><span class="line">string = (<span class="string">'AAA'</span>, <span class="number">11</span>)</span><br><span class="line">s = str(string)</span><br><span class="line">f.write(s)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'/tmp/1.txt'</span>, <span class="string">'rb+'</span>)</span><br><span class="line">f.write(<span class="string">b'0123456789abcde'</span>)</span><br><span class="line"></span><br><span class="line">f.seek(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">f.read(<span class="number">1</span>)</span><br><span class="line"><span class="string">b'1'</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="使用json保存结构化数据"><a href="#使用json保存结构化数据" class="headerlink" title="使用json保存结构化数据"></a>使用json保存结构化数据</h4><p>Saving structured data with json</p><p>字符串可以很容易地读写文件和从文件读取。当你想要保存更复杂的数据类型——如嵌套列表和字典，手动解析和序列化将变得很复杂。</p><p>JSON格式通常被现代应用程序用于数据交换。<br>Python允许你使用名为JSON的流行数据交换格式。称为json的标准模块可采用Python数据层次结构，并将其转换为字符串表示形式，这个过程被称为序列化(serializing)。重建字符串表示中的数据称为反序列化(deserializing)。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">json.dumps([<span class="number">1</span>, <span class="string">'simple'</span>, <span class="string">'list'</span>])</span><br><span class="line"><span class="string">'[1, "simple", "list"]'</span></span><br><span class="line"></span><br><span class="line">json.dump(x, f)</span><br><span class="line">x = json.load(f)</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><p>Errors and Exceptions</p><p>至少有两种可区分的错误:</p><ul><li>syntax errors</li><li>exceptions</li></ul><p><br><br><br></p><h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><p>Syntax Errors<br>语法错误，也称为解析错误。这是最常见的语法问题错误。</p><p><br><br><br></p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>Exceptions<br>即使语法是正确的，但在执行时也可能导致错误。执行过程中检查到的错误称为异常。<br>Built-in Exceptions列出了内置的异常及其含义。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> &gt;&gt;&gt; <span class="number">10</span> * (<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line"> &gt;&gt;&gt; <span class="number">4</span> + spam*<span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'spam'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br><span class="line"> &gt;&gt;&gt; <span class="string">'2'</span> + <span class="number">2</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Can<span class="string">'t convert '</span>int<span class="string">' object to str implicitly</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>Handling Exceptions<br>编写处理选定异常的程序是可能的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = int(input(<span class="string">"Please enter a number: "</span>))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        print(<span class="string">"Oops!  That was no valid number.  Try again..."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#多个异常放入一个元组</span></span><br><span class="line"><span class="keyword">except</span> (RuntimeError, TypeError, NameError):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong><code>try</code>语句工作原理：</strong></p><ul><li>首先，<code>try</code>子句(<code>try...except</code>之间的语句)被执行</li><li>如果没有异常发生，则执行<code>try</code>语句并跳过<code>except</code>子句后便结束</li><li>如果在执行<code>try</code>子句时发生异常，则跳过子句的其余部分。然后，如果<strong>异常类型</strong>匹配<code>execpt</code>后面的异常名称，则<code>except</code>子句被执行，然后在<code>try</code>语句后继续执行</li><li>如果产生的异常与<code>except</code>的异常名称不匹配，它将传递给外部<code>try</code>语句。如果没有找到处理程序，则它是一个未处理的异常，执行停止并显示错误消息</li><li><code>try</code>语句可能有多个<code>except</code>子句，用于处理不同的异常。最多只有一个处理程序被执行</li><li>处理程序只处理发生在相应<code>try</code>子句中的异常，而不处理相同<code>try</code>语句的其它处理程序</li><li><code>except</code>子句可将多个异常名放入一个元组</li><li>如果是相同的类或其基类，则<code>except</code>子句中的类与异常兼容</li><li>未使用异常名称的<code>except</code>子句作为通配符<ul><li>请谨慎使用此功能，因为以这种方式很容易掩盖真正的编程错误</li></ul></li><li><code>try...except</code>语句还有一个可选的<code>else</code>子句。当存在时，它必须遵循所有<code>except</code>子句。如果<code>try</code>子句不引发异常，则必须执行该代码</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'/tmp/1.txt'</span>)</span><br><span class="line">    s = f.readline()</span><br><span class="line">    i = int(s.strip())</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">'OS error: &#123;&#125;'</span>.format(err))</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">"Could not convert data to an integer."</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"Unexpected erros"</span>, sys.exc_info()[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sum = <span class="string">'a'</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> TypeError:</span><br><span class="line">    print(<span class="string">'TypeError'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'else: '</span>, sum)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="引发异常"><a href="#引发异常" class="headerlink" title="引发异常"></a>引发异常</h3><p>Raising Exceptions</p><p><code>raise</code>语句允许程序员强制执行指定的异常。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> NameError(<span class="string">'HiThere'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: HiThere</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> NameError(<span class="string">'HiThere'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> NameError:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'An exception flew by!'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span></span><br><span class="line">...</span><br><span class="line">An exception flew by!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="用户定义的异常"><a href="#用户定义的异常" class="headerlink" title="用户定义的异常"></a>用户定义的异常</h3><p>User-defined Exceptions</p><p>程序可以通过创建一个新的异常类(exception class)来为自己的异常命名。异常通常应该直接或间接地从 Exception class 派生。</p><p>可以定义异常类，它可以执行任何其它类可以执行的任何操作，但通常很简单，通常只提供一些属性，以便处理程序为异常提取有关错误的信息。<br>创建可引发多个不同错误的模块时，通常的做法是为该模块定义的异常创建基类，并创建用于为不同错误条件创建特定异常类的子类:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Error</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""Base class for exceptions in this module."""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputError</span><span class="params">(Error)</span>:</span></span><br><span class="line">    <span class="string">"""Exception raised for errors in the input.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        expression -- input expression in which the error occurred</span></span><br><span class="line"><span class="string">        message -- explanation of the error</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, expression, message)</span>:</span></span><br><span class="line">        self.expression = expression</span><br><span class="line">        self.message = message</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransitionError</span><span class="params">(Error)</span>:</span></span><br><span class="line">    <span class="string">"""Raised when an operation attempts a state transition that's not</span></span><br><span class="line"><span class="string">    allowed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        previous -- state at beginning of transition</span></span><br><span class="line"><span class="string">        next -- attempted new state</span></span><br><span class="line"><span class="string">        message -- explanation of why the specific transition is not allowed</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, previous, next, message)</span>:</span></span><br><span class="line">        self.previous = previous</span><br><span class="line">        self.next = next</span><br><span class="line">        self.message = message</span><br></pre></td></tr></table></figure><p>大多数异常的名称都以<strong>Error</strong>结尾来定义，类似于标准异常的命名。<br>许多标准模块定义了它们自己的异常，用于在其定义的功能中可能发生的错误。</p><p><br><br><br></p><h3 id="定义清理行为"><a href="#定义清理行为" class="headerlink" title="定义清理行为"></a>定义清理行为</h3><p>Defining Clean-up Actions</p><p>try语句还有一个可选的子句，用于定义在任何情况下都必须执行的清理操作(clean-up actions).</p><p>finally子句总是在离开try语句之前执行，无论是否发生异常。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> KeyboardInterrupt</span><br><span class="line"><span class="meta">... </span><span class="keyword">finally</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Goodbye, world!'</span>)</span><br><span class="line">...</span><br><span class="line">Goodbye, world!</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="预定义的清理操作"><a href="#预定义的清理操作" class="headerlink" title="预定义的清理操作"></a>预定义的清理操作</h3><p>Predefined Clean-up Actions</p><p>某些对象定义了在不再需要对象是要执行的标准清楚操作，而不管使用对象的操作是成功还是失败。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"myfile.txt"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        print(line, end=<span class="string">""</span>)</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Classes</p><p>类提供了将数据和功能捆绑在一起的手段。每个类实例都可附加属性以保持其状态。类实例也可以有方法来修改其状态。</p><p>与其它编程语言相比，Python的类机制为其添加了最少量的新语法和语义。Python类 提供了面向对象编程的所有标准功能: 类继承机制(inheritance mechanism)允许多个基类(base class)，派生类(derived class)可以重写其基类或类的任何方法，并且方法(method)可以调用具有相同名称的基类的方法。对象(object)可以包含任意数量和种类的数据。与模块一样，类也具有Python的动态特性: 它们是在运行时创建的，并且可以在创建后进一步修改。</p><p><br><br><br></p><h3 id="关于名称和对象"><a href="#关于名称和对象" class="headerlink" title="关于名称和对象"></a>关于名称和对象</h3><p>A Word About Names and Objects</p><p>Objects have individuality, 并且可以将多个名称(在多作用域中)绑定到同一个对象。这在其它语言中被称为别名。别名在不可变类型中被安全地忽略。但对涉及可变对象(dict, list…)的Python代码的语义可能会有惊人的影响。这通常有利于程序，因为别名在某些方面表现得像指针。</p><p><br><br><br></p><h3 id="作用域和命名空间"><a href="#作用域和命名空间" class="headerlink" title="作用域和命名空间"></a>作用域和命名空间</h3><p>Python Scopes and Namespaces</p><p>类定义在命名空间中扮演一些巧妙的技巧，并且你需要知道作用域和命名空间如何工作才能完全理解正在发生的事情。顺便一提，有关此主题的知识对于任何高级Python程序员都很有用。</p><p>让我们从一些定义开始:</p><p>命名空间是名称到对象的映射。大多数命名空间目前都是作为Python字典实现的，但通常不会以任何方式显示。<br>命名空间的例子： 内建名称的集合；模块中的全局名称；函数调用中的本地名称。<br>从某种意义上说，对象的一组属性也构成一个命名空间。了解命名空间的重要之处在于，不同命名空间中的名称之间没有绝对的关系。</p><p>顺便一提，使用单词属性来表示任意一个点<code>.</code>后面的名称——<code>z.real</code>，real是对象z的属性。严格地说，对模块中的名称引用是属性引用——<code>modname.funcname</code>，modname是一个模块对象，并且funcname是它的一个属性。<br>在这种情况下，模块的属性和模块中定义的全局名称之间会有一个直接的映射关系: 它们共享相同的命名空间。</p><p>属性可以是只读或可写。</p><p>命名空间是在不同的时刻创建的，并且具有不同的生命周期。包含内建名称的命名空间是在Python解释器启动时创建的，并且永远不会被删除。读取模块定义时创建模块的全局命名空间，通常，模块命名空间也会持续到解释器退出。<br>由解释器的顶层调用执行的语句，无论是从脚本文件读取还是交互式读取，都被视为名为<code>__main__</code>模块的一部分，因此它们具有其自己的全局命名空间。</p><p>函数的本地命名空间是在调用函数时创建，并在函数返回时删除或引发(raise)不在函数内处理的异常。当然，递归调用每个都有自己的本地命名空间。</p><p>作用域(scope)是Python程序的文本区域，可以直接访问命名空间(namespace)。这意味着对名称的非限定引用(unqualified reference)会尝试在命名空间中查找名称。</p><p>尽管作用域是静态确定的，但它们是动态使用的。在执行期间的任何时候，至少有三个作用域的命名空间都可以直接访问:</p><ul><li>最先搜索的最内层作用域，包含本地名称</li><li>从最近封闭作用域开始搜索的任何封闭函数的作用域，包含非本地名称，也包含非全局名称</li><li>倒数第二个作用域包含当前模块的全局名称</li><li>最外层的作用域是包含内建名称的命名空间</li></ul><p><br></p><p>如果某个名称被声明为全局(global)，则所有的引用(reference)和赋值(assignment)都将直接转到包含模块全局名称的中间作用域。要重新绑定(rebind)最内层作用域外发现的变量，可以使用<code>nonlocal</code>语句；如果没有声明<code>nonlocal</code>，那些变量是只读的。</p><p>通常，本地作用域引用当前函数的本地名称。在外部函数中，本地作用域引用与全局作用域相同的命名空间:模块的命名空间。类定义在本地作用域中放置另一个命名空间。</p><p>认识到作用域是以文本方式确定是很重要的: 模块中定义的函数的全局作用域是该模块的命名空间，无论从何处调用函数或调用函数的别名。另一方面，名称的实际搜索是在运行时动态完成的——但是，在编译时间，语言定义正在向静态名称解析发展，因此不要依赖动态名称解析。</p><p>Python的特殊之处在于——如果<code>global</code>语句没有生效，对名称的赋值总是进入最内层的范围。赋值不会分配数据——它们只是将名称绑定到对象。删除操作也是如此: 语句<code>del x</code>从本地作用域引用的命名空间中删除x的绑定。实际上，所有引用新名称的操作都是用本地作用域: 特别是，<code>import</code>语句和函数定义将模块或函数名称绑定到本地作用域。</p><p><code>global</code>声明可以用来表明特定变量存在于全局作用域内，应该在此rebound(反弹)。<code>nonlocal</code>声明表明特定变量存在于封闭作用域内，应该在那里rebound.</p><p><br></p><p><strong>作用域和命名空间的栗子</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scope_test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_local</span><span class="params">()</span>:</span></span><br><span class="line">        spam = <span class="string">"local spam"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_nonlocal</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> spam</span><br><span class="line">        spam = <span class="string">"nonlocal spam"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_global</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">global</span> spam</span><br><span class="line">        spam = <span class="string">"global spam"</span></span><br><span class="line"></span><br><span class="line">    spam = <span class="string">"test spam"</span></span><br><span class="line"></span><br><span class="line">    do_local()</span><br><span class="line">    print(<span class="string">"After local assignment: "</span>, spam)</span><br><span class="line"></span><br><span class="line">    do_nonlocal()</span><br><span class="line">    print(<span class="string">"After nonlocal assignment: "</span>, spam)</span><br><span class="line"></span><br><span class="line">    do_global()</span><br><span class="line">    print(<span class="string">"After global assignment: "</span>, spam)</span><br><span class="line"></span><br><span class="line">scope_test()</span><br><span class="line">print(<span class="string">"In global scope: "</span>, spam)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">After local assignment: test spam</span><br><span class="line">After <span class="keyword">nonlocal</span> assignment: <span class="keyword">nonlocal</span> spam</span><br><span class="line">After <span class="keyword">global</span> assignment: <span class="keyword">nonlocal</span> spam</span><br><span class="line">In <span class="keyword">global</span> scope: <span class="keyword">global</span> spam</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="首先看类"><a href="#首先看类" class="headerlink" title="首先看类"></a>首先看类</h3><p>A first look at class</p><p>类引入了一些新的语法，三种新的对象类型和一些新的语义。</p><p><br></p><h4 id="类定义语法"><a href="#类定义语法" class="headerlink" title="类定义语法"></a>类定义语法</h4><p>Class Definition Syntax</p><p>类定义，像函数定义，必须在它们有效之前被执行。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>实际上，类定义中的语句通常是函数定义，但其他语句是允许的，有时也是有用的。类中的函数定义通常有一个特殊形式的参数列表，由方法的调用约定决定。</p><p>当输入一个类定义时，会创建一个新的命名空间，并将其用作本地作用域——因此，所有对局部变量的赋值都会进入这个新的命名空间。特别是，函数定义在此绑定新函数的名称。</p><p>当类定义保持正常时，会创建一个类对象。这基本上是由类定义创建的命名空间的内容的一个包装。最初的本地作用域被恢复，并且类对象在这里被绑定到类定义头中给出的类名。</p><p><br></p><h4 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h4><p>Class Objects</p><p>类对象支持两种操作: 属性引用(attribute reference)和实例化(instantiation).</p><p>属性引用使用 用于Python中所有属性引用的标准语法: <code>obj.name</code>. 有效的属性名称在创建类对象时时位于类命名空间中的所有名称。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="string">"""A simple example class"""</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure><p><code>MyClass.i</code>和<code>MyClass.f</code>是有效的属性引用，分别返回一个整数和函数对象。类属性也可以被分配，所以也可以通过赋值来改变<code>MyClass.i</code>的值。<code>__doc__</code>也是一个有效的属性，返回该类的文档字符串”A simple example class”.</p><p>类实例化使用函数表示法。假设类对象是一个返回类的新实例的无参数函数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建类的新实例，并将该对象分配给局部变量x</span></span><br><span class="line">x = MyClass()</span><br></pre></td></tr></table></figure><p>实例化操作(“调用”一个类对象)创建一个空对象。许多类喜欢创建具有定制(customized)到特定初始状态(initial state)的实例对象。因此，类可以定义一个名为<code>__init__()</code>的特殊方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.data = []</span><br></pre></td></tr></table></figure><p>当一个类定义了一个<code>__init__()</code>方法时，类实例化会自动为新创建的类实例调用<code>__init__()</code>.</p><p>当然，<code>__init__()</code>方法可能有更多灵活的参数。在这种情况下，给类实例化操作符的参数被传递给<code>__init__()</code>.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, realpart, imagpart)</span>:</span></span><br><span class="line">        self.r = realpart</span><br><span class="line">        self.i = imagpart</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = Complex(<span class="number">3.0</span>, <span class="number">-4.5</span>)</span><br><span class="line">x.r, x.i</span><br><span class="line"><span class="number">3.0</span>, <span class="number">-4.5</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h4><p>Instance Objects</p><p>实例对象理解的唯一操作是属性引用。有两种有效的属性名称，数据属性和方法。</p><p>数据属性不需要声明，像局部变量一样，当它们在第一次分配时就会弹出。<br>另一种实力属性引用是一种方法。方法是属于对象的函数。</p><p>实例对象的有效方法名称取决于它的类。根据定义，作为函数对象的类的所有属性都定义其实例的相应方法。</p><p><br></p><h4 id="方法对象"><a href="#方法对象" class="headerlink" title="方法对象"></a>方法对象</h4><p>Method Objects</p><p>关于方法的特殊之处在于 实例对象作为函数的第一个参数传递。一般来说，调用带有n个参数列表的方法相当于使用通过在第一个参数之前插入方法实例对象创建的参数列表来调用相应的函数。</p><p>当引用不是数据属性的实例属性时，将搜索类。如果名称表示一个有效的类属性，它是一个函数对象，则通过打包实例对象和在抽象对象中一起找到的函数对象来创建方法对象，这就是方法对象。当使用参数列表调用方法对象时，会从实例对象和参数列表构造一个新参数列表，并使用此新参数列表调用函数对象。</p><p><br></p><h4 id="类变量和实例变量"><a href="#类变量和实例变量" class="headerlink" title="类变量和实例变量"></a>类变量和实例变量</h4><p>Class and Instance Variables</p><p>一般来说，实例变量是针对每个实例唯一的数据，而类变量是针对类的所有实例共享的属性和方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    kind = <span class="string">'canine'</span>         <span class="comment"># class variable shared by all instances</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name    <span class="comment"># instance variable unique to each instance</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog(<span class="string">'Fido'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Dog(<span class="string">'Buddy'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.kind                  <span class="comment"># shared by all dogs</span></span><br><span class="line"><span class="string">'canine'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.kind                  <span class="comment"># shared by all dogs</span></span><br><span class="line"><span class="string">'canine'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.name                  <span class="comment"># unique to d</span></span><br><span class="line"><span class="string">'Fido'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.name                  <span class="comment"># unique to e</span></span><br><span class="line"><span class="string">'Buddy'</span></span><br></pre></td></tr></table></figure><p>共享数据可能会带来令人惊讶的影响，涉及列表和字典等可变对象:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    tricks = []             <span class="comment"># mistaken use of a class variable</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_trick</span><span class="params">(self, trick)</span>:</span></span><br><span class="line">        self.tricks.append(trick)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog(<span class="string">'Fido'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Dog(<span class="string">'Buddy'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.add_trick(<span class="string">'roll over'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.add_trick(<span class="string">'play dead'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.tricks                <span class="comment"># unexpectedly shared by all dogs</span></span><br><span class="line">[<span class="string">'roll over'</span>, <span class="string">'play dead'</span>]</span><br></pre></td></tr></table></figure><p>正确的类设计应该使用实例变量:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.tricks = []    <span class="comment"># creates a new empty list for each dog</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_trick</span><span class="params">(self, trick)</span>:</span></span><br><span class="line">        self.tricks.append(trick)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog(<span class="string">'Fido'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Dog(<span class="string">'Buddy'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.add_trick(<span class="string">'roll over'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.add_trick(<span class="string">'play dead'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.tricks</span><br><span class="line">[<span class="string">'roll over'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.tricks</span><br><span class="line">[<span class="string">'play dead'</span>]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="随机备注"><a href="#随机备注" class="headerlink" title="随机备注"></a>随机备注</h3><p>Random Remarks</p><p>数据属性覆盖具有相同名称的方法属性；为了避免意外的名称冲突，这可能会在大型程序中导致难以发现的错误，使用某种最小化冲突几率的约定是明智的。可能的约定(convention)包括: 大写的方法名称，小唯一字符串(可能只是下划线)为数据属性名称加前缀，或者为方法和名词使用动词来表示数据属性。</p><p>数据属性可由方法及对象的普通用户引用。换句话说，累不可用于实现纯粹的抽象数据类型。事实上，Python中没有任何东西可以强制执行数据隐藏——它都基于约定。</p><p>客户端应该小心使用数据属性。请注意，客户端可以将自己的数据属性添加到实例对象，而不会影响方法的有效性，只要避免名称冲突——再次注意，命名约定可在此节省大量令人头痛的问题。</p><p>从方法中引用数据类型没有简写，这增加了方法的可读性: 在浏览方法时，不会混淆局部变量和实例变量。</p><p>通常，方法的第一个参数称为<code>self</code>。这只不过是一个约定: 名字<code>self</code>对Python来说绝对没有特殊含义。但是，请注意，不遵循约定的Python代码对于Python程序员来说可能不易读取。</p><p>任何作为类属性的函数对象都为该类的实例定义了一个方法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Function defined outside the class</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> min(x, x+y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    f = f1</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line">    h = g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#f, g, h都是类C的所有属性，它们都是指向函数对象的，因此它们都是C实例的所有方法。</span></span><br></pre></td></tr></table></figure><p>方法可以通过使用<code>self</code>参数的方法属性来调用其它方法:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.data.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addtwice</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.add(x)</span><br><span class="line">        self.add(x)</span><br></pre></td></tr></table></figure><p>方法可以像普通函数一样引用全局名称。与方法关联的全局作用域是包含其定义的模块。(一个类永远不会被用作全局作用域) 虽然很少有人在方法中使用全局数据，但全局作用域有许多合法用途: 首先，导入全局作用域的函数和模块可以被方法使用，以及在其中定义的函数和类。通常，包含该方法的类本身是在全局作用域内定义的。</p><p>每个值都是一个对象，因此有一个类(类型)。它被存储为<code>object.__class__</code></p><p><br><br><br></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Inheritance</p><p>当然，如果不支持继承，语言特性就不值得称为”类”。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#派生(derived)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(BaseClassName)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>基类(BaseClassName)必须在包含派生类(derived class)定义的作用域中定义。代替基类名称，其它表达式也是允许的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当基类在另一个模块中被定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(modname.BaseClassName)</span>:</span></span><br></pre></td></tr></table></figure><p>派生类(derived class)定义的执行过程与基类(base class)相同。当构造(constructed)类对象时，基类将被记住。这用于解析属性引用: 如果在类中未找到请求的属性，则搜索继续查找基类。如果基类本身是从其它类派生的，则此规则将递归应用。</p><p>派生类的实例化么有什么特别的: <code>DerivedXlassName()</code>创建一个新的类实例。方法解析如下: 如果需要，搜索相应的类属性，沿着基类链降序排列，如果产生函数对象，则方法引用是有效的。</p><p>派生类可以覆盖(override)基类的方法。由于方法在调用同一对象的其它方法时没有特殊的权限，因此调用另一个在同一基类中定义的方法的基类方法可能最终会调用派生类的方法来覆盖它。</p><p>派生类的覆盖(override)方法事实上可能需要扩展而不是简单地替换同名的基类方法。有一种简单的方法可以直接调用基类方法: 只需调用<code>BaseClassName.methodname(self, arguments)</code>即可。</p><p><br></p><p>Python有两个与继承有关的内建函数:</p><ul><li><p><code>isinstance()</code><br>检查一个实例的类型。<code>isinstance(obj, int)</code>只有在<code>obj.__class__</code>是int或从int派生的某个类时才为true</p></li><li><p><code>issubclass()</code><br>检查类继承。</p></li></ul><p><br></p><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>Multiple Inheritance</p><p>Python支持多重继承的形式。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(Base1, Base2, Base3)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>在最简单的情况下，你可以将从父类继承的属性视为深度优先(depth first)，从左到右搜索，而不是在同一个类中进行两次搜索，其中层次结构中存在重叠。<br>因此，如果在DerivedClassName中找不到属性，则在Base1中搜索该属性，然后(递归)在Base1的基类中搜索该属性。如果未找到，则在Base2中搜索该属性，依此类推。</p><p>动态排序是必要的，因为多重继承的情况都表现出一个或多个菱形关系。例如，所有类都从对象继承，所以任何多重继承的情况都会提供多条路径来达到对象。为了避免基类被多次访问，动态算法使搜索顺序线性化，以保留没各类众指定的从左到右的顺序，每个父类只调用一次，这是单调的。</p><p><br></p><h4 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h4><p>Private Variables</p><p>Python中不存在私有(private)实例变量，这些变量除了在对象内部以外不能访问。不过，大多数Python代码都有一个约定，以下划线<code>_spam</code>为前缀的名称应被视为API的非公共部分(无论是函数，方法或数据成员)。</p><p>由于私有类(class-private)成员有一个有效的用例(即为了避免名称与由子类定义的名称的冲突)，所以对这种称为<code>name mangling</code>的机制的支持有限。任何<code>__spam</code>形式的标识符在文本上用<code>_classname__spam</code>替换，其中<code>classname</code>是当前类名称，前导下划线被去除。只要它在类的定义类发生，就不会考虑标识符位置。</p><p>Name mangling 有助于让子类重写方法而不会破坏intraclass方法调用:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mapping</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self.items_list = []</span><br><span class="line">        self.__update(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">            self.items_list.append(item)</span><br><span class="line"></span><br><span class="line">    __update = update   <span class="comment"># private copy of original update() method</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MappingSubclass</span><span class="params">(Mapping)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, keys, values)</span>:</span></span><br><span class="line">        <span class="comment"># provides new signature for update()</span></span><br><span class="line">        <span class="comment"># but does not break __init__()</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> zip(keys, values):</span><br><span class="line">            self.items_list.append(item)</span><br></pre></td></tr></table></figure><p>请注意，强化规则的设计主要是为了避免事故；它仍然可以访问或修改被认为是私有的变量。<br>注意传递给<code>exec()</code>或<code>eval()</code>的代码并不认为调用类的类名是当前类；这与<code>global</code>语句的效果类似，其效果同样局限于一起进行字节编译的代码。<code>getattr()</code>, <code>setattr()</code>和<code>delattr()</code>以及直接使用<code>__dict__</code>时也有相同的限制。</p><p><br><br><br></p><h3 id="Odds-and-Ends"><a href="#Odds-and-Ends" class="headerlink" title="Odds and Ends"></a>Odds and Ends</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">john = Employee()  <span class="comment"># Create an empty employee record</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the fields of the record</span></span><br><span class="line">john.name = <span class="string">'John Doe'</span></span><br><span class="line">john.dept = <span class="string">'computer lab'</span></span><br><span class="line">john.salary = <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>一段期望特定抽象数据类型的Python代码通常通常可以传递一个模拟该数据类型方法的类。<br>例如，如果你有一个函数可以格式化文件对象中的某些数据，则可以使用方法<code>read()</code>和<code>readline()</code>来定义一个类，以便从字符串缓冲区总获取数据，然后将其作为参数传递。</p><p><br><br><br></p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>Iterators</p><p>你可能注意到大多数容器对象可以使用for语句循环遍历:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    print(element)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">    print(element)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> &#123;<span class="string">'one'</span>:<span class="number">1</span>, <span class="string">'two'</span>:<span class="number">2</span>&#125;:</span><br><span class="line">    print(key)</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">"123"</span>:</span><br><span class="line">    print(char)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">"myfile.txt"</span>):</span><br><span class="line">    print(line, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>这种访问方式清晰，简洁，方便。迭代器的使用贯穿并统一了Python。<code>for</code>语句在容器对象上调用<code>iter()</code>。该函数返回一个迭代器对象，该对象定义一次访问容器中元素的方法<code>__next__()</code>。当没有更多元素是，<code>__next__()</code>引发一个<strong>StopIteration</strong>异常，它告诉<code>for</code>循环终止。<br>你可使用<code>next()</code>内置函数调用<code>__next__()</code>方法:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it</span><br><span class="line">&lt;iterator object at <span class="number">0x00A1DB50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(it)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    next(it)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p><br></p><p>看到了迭代器协议背后的机制，很容易将迭代器行为添加到类中。定义一个<code>__iter__()</code>方法，该方法使用<code>__next__()</code>方法返回一个对象。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reverse</span>:</span></span><br><span class="line">    <span class="string">"""Iterator for looping over a sequence backwards."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = len(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.index = self.index - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.data[self.index]</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rev = Reverse(<span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(rev)</span><br><span class="line">&lt;__main__.Reverse object at <span class="number">0x00A1DB50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> rev:</span><br><span class="line"><span class="meta">... </span>    print(char)</span><br><span class="line">...</span><br><span class="line">m</span><br><span class="line">a</span><br><span class="line">p</span><br><span class="line">s</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>Generators</p><p>生成器是创建迭代器的简单而强大的工具。它们像常规函数一样编写，但只要它们想返回数据就是用<code>yield</code>语句。每次<code>next()</code>被调用时，生成器都会从停止的地方恢复(它记住所有的数据值以上次执行的代码)。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(data)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">yield</span> data[index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> reverse(<span class="string">'golf'</span>):</span><br><span class="line"><span class="meta">... </span>    print(char)</span><br><span class="line">...</span><br><span class="line">f</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">g</span><br></pre></td></tr></table></figure><p>任何可用生成器完成的事情也可用前面的基于类的迭代器完成。使生成器如此紧凑的原因是<code>__iter__()</code>和<code>__next__()</code>方法时自动创建的。</p><p>另一个关键特性是本地变量和执行状态在调用之间自动保存。这使得该函数更容易编写，并且比使用<code>self.index</code>和<code>self.data</code>等实例变量的方法更加清晰。<br>除了自动方法创建和保存程序状态之外，当生成器终止时，它们会自动产生StopIteration。结合起来，这些功能可以轻松创建迭代器，而无需编写常规函数。</p><p><br><br><br></p><h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>Generator Expressions</p><p>一些简单的生成器可以使用与列表解析类似的语法简洁地编码为表达式，带括号而不是方括号。这些表达式适用于通过封闭函数立即使用生成器的情况。<br>生成器表达式比完整的生成器定义更紧凑但功能更少，并且倾向于比等效的列表解析更具有内存友好性。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(i*i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))                 <span class="comment"># sum of squares</span></span><br><span class="line"><span class="number">285</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xvec = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>yvec = [<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(x*y <span class="keyword">for</span> x,y <span class="keyword">in</span> zip(xvec, yvec))         <span class="comment"># dot product</span></span><br><span class="line"><span class="number">260</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi, sin</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sine_table = &#123;x: sin(x*pi/<span class="number">180</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">91</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unique_words = set(word  <span class="keyword">for</span> line <span class="keyword">in</span> page  <span class="keyword">for</span> word <span class="keyword">in</span> line.split())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>valedictorian = max((student.gpa, student.name) <span class="keyword">for</span> student <span class="keyword">in</span> graduates)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = <span class="string">'golf'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(data[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>))</span><br><span class="line">[<span class="string">'f'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'g'</span>]</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><p>Virtual Environments and Packages</p><p>应用程序有时候需要特定的模块版本，或者某个模块只支持特定Python版本。<br>这就意味着一个Python安装版本可能无法满足每个应用程序的要求。(如某个应用程序支持Python2.7，而某个应用程序支持Python3.x)</p><p>此问题的解决方案是创建一个虚拟环境(virtual environment)——一个包含特定Python安装包和软件包的目录树。<br>这样，不同的应用程序就可以使用不同的虚拟环境。</p><p><br><br><br></p><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><p>Creating Virtual Environments</p><p>用于创建和管理虚拟环境额模块称为<code>venv</code>.它通常会为你安装最新版本的Python，你也可以选择Python版本。</p><p>激活虚拟环境后，会改变提示符并修改环境，以便提供特定的Python版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#创建虚拟环境</span><br><span class="line">python3 -m venv /tmp/pythonVenv</span><br><span class="line"></span><br><span class="line">#激活</span><br><span class="line">source /tmp/pythonVenv/vin/activate</span><br><span class="line">(pythonVenv) [zhang@zhang21 ~]$</span><br><span class="line"></span><br><span class="line">(pythonVenv) [zhang@zhang21 ~]$ python</span><br><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path</span><br><span class="line">[&apos;&apos;, &apos;/usr/lib64/python34.zip&apos;, &apos;/usr/lib64/python3.4&apos;, &apos;/usr/lib64/python3.4/plat-linux&apos;, &apos;/usr/lib64/python3.4/lib-dynload&apos;, &apos;/tmp/pythonVenv/lib64/python3.4/site-packages&apos;, &apos;/tmp/pythonVenv/lib/python3.4/site-packages&apos;]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="pip包管理"><a href="#pip包管理" class="headerlink" title="pip包管理"></a>pip包管理</h3><p>你可以使用pip程序进行搜索、安装、升级和移除软件包。pip程序默认从<pypi.org>安装软件包。</pypi.org></p><p><code>pip freeze</code> 以requirements的格式输出已安装软件包。这很重要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pip search sh</span><br><span class="line"></span><br><span class="line">#默认安装最新版本</span><br><span class="line">pip install sh</span><br><span class="line"></span><br><span class="line">#安装指定版本</span><br><span class="line">pip install sh=1.10.2</span><br><span class="line"></span><br><span class="line">pip install --upgrade sh</span><br><span class="line"></span><br><span class="line">pip uninstall sh</span><br><span class="line"></span><br><span class="line">#显示已安装的模块的详细信息</span><br><span class="line">pip show sh</span><br><span class="line"></span><br><span class="line">#列出已安装模块</span><br><span class="line">pip list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pip freeze &gt; requirements.txt</span><br><span class="line">#安装依赖</span><br><span class="line">pip install -r ./requirements.txt</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="语言参考"><a href="#语言参考" class="headerlink" title="语言参考"></a>语言参考</h1><p>The Python Language Reference</p><p>Python参考手册描述了该语言的语法(syntax)和核心语义(core semantics)。</p><p><br><br><br></p><hr><p><br></p><h1 id="HOWTOs"><a href="#HOWTOs" class="headerlink" title="HOWTOs"></a>HOWTOs</h1><p>Python HOWTOs是覆盖单个特定主机的文档，并尝试完全包含它。此文档比Python参考库更详细。</p><p><br><br><br></p><hr><p><br></p><h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><p><br><br><br></p><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>Python标准库包含了各种不同类型的组件。</p><p>一些模块提供了特定于Python的接口；一些提供特定于特定操作系统的接口，一些提供特定于特定应用程序的接口。<br>一些模块适用于所有Python版本和端口；一些只有在底层系统支持或需要它们是才可用；还有一些只有在编译和安装Python特定配置时才可用。</p><p><br><br><br></p><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>Python解释器内置了许多功能和类型，它们始终可用。</p><table><thead><tr><th><code></code></th><th><code></code></th><th>内建函数</th><th><code></code></th><th><code></code></th></tr></thead><tbody><tr><td><code>abs()</code></td><td><code>dict()</code></td><td><code>help()</code></td><td><code>min()</code></td><td><code>setattr()</code></td></tr><tr><td><code>all()</code></td><td><code>dir()</code></td><td><code>hex()</code></td><td><code>next()</code></td><td><code>slice()</code></td></tr><tr><td><code>any()</code></td><td><code>divmod()</code></td><td><code>id()</code></td><td><code>object()</code></td><td><code>sorted()</code></td></tr><tr><td><code>ascii()</code></td><td><code>enumerate()</code></td><td><code>input()</code></td><td><code>oct()</code></td><td><code>staticmethod()</code></td></tr><tr><td><code>bin()</code></td><td><code>eval()</code></td><td><code>int()</code></td><td><code>open()</code></td><td><code>str()</code></td></tr><tr><td><code>bool()</code></td><td><code>exec()</code></td><td><code>isinstance()</code></td><td><code>ord()</code></td><td><code>sum()</code></td></tr><tr><td><code>bytearray()</code></td><td><code>filter()</code></td><td><code>issubclass()</code></td><td><code>pow()</code></td><td><code>super()</code></td></tr><tr><td><code>bytes()</code></td><td><code>float()</code></td><td><code>iter()</code></td><td><code>print()</code></td><td><code>tuple()</code></td></tr><tr><td><code>callable()</code></td><td><code>format()</code></td><td><code>len()</code></td><td><code>property()</code></td><td><code>type()</code></td></tr><tr><td><code>chr()</code></td><td><code>frozenset()</code></td><td><code>list()</code></td><td><code>range()</code></td><td><code>vars()</code></td></tr><tr><td><code>classmethod()</code></td><td><code>getattr()</code></td><td><code>locals()</code></td><td><code>repr()</code></td><td><code>zip()</code></td></tr><tr><td><code>compile()</code></td><td><code>globals()</code></td><td><code>map()</code></td><td><code>reversed()</code></td><td><code>__import__()</code></td></tr><tr><td><code>complex()</code></td><td><code>hasattr()</code></td><td><code>max()</code></td><td><code>round()</code></td><td><code></code></td></tr><tr><td><code>delattr()</code></td><td><code>hash()</code></td><td><code>memoryview()</code></td><td><code>set()</code></td><td><code></code></td></tr></tbody></table><p><br></p><ul><li><p><strong>abs(x)</strong><br>返回一个数字的绝对值</p></li><li><p><strong>all(iterable)</strong><br>如果迭代的所有元素均为真(或为空)，返回<code>True</code></p></li><li><p><strong>any(iterable)</strong><br>如果迭代的任一元素为真，返回<code>True</code>；为空返回<code>False</code></p></li><li><p><strong>ascii(object)</strong></p></li><li><p><strong>bin(x)</strong><br>将整数转换为二进制字符串</p></li><li><p><strong>bool([x])</strong><br>返回一个布尔值，<code>True</code>或<code>False</code></p></li><li><p><strong>bytearray()</strong><br>返回一个新的字节数组</p></li><li><p><strong>byte()</strong><br>返回一个新的字节对象，它是一个在<code>0&lt;=x&lt;256</code>范围内的不可变整数序列</p></li><li><p><strong>callable(object)</strong><br>如果对象参数显示为可调用，返回<code>True</code>；否则返回<code>False</code></p></li><li><p><strong>chr(i)</strong><br>返回代表Unicode编码为整数i的字符的字符串</p></li><li><p><strong>classmethod(function)</strong><br>为函数返回一个类方法</p></li><li><p><strong>compile()</strong><br>将源编译为代码或AST对象</p></li><li><p><strong>complex()</strong><br>返回一个复数，或将字符串或数字转换为复数</p></li><li><p><strong>delattr(object, name)</strong><br>这是<code>setattr()</code>的相对值</p></li><li><p><strong>dict(kwarg)</strong><br>创建一个新的字典</p></li><li><p><strong>dir(object)</strong><br>无参数，返回当前本地作用域中的名称列表<br>有参数，尝试返回该对象的有效属性列表</p></li><li><p><strong>divmod(a, b)</strong><br>以两个数字(非复数)为参数，使用整数除法时返回由它们的商和余数组成的一对数字</p></li><li><p><strong>enumerate(iterable, start=0)</strong><br>返回一个枚举对象</p></li><li><p><strong>eval(expression, globals, locals)</strong></p></li><li><p><strong>exec()</strong><br>动态执行Python代码</p></li><li><p><strong>filter(function, iterable)</strong><br>从函数返回true的可迭代元素构造一个迭代器</p></li><li><p><strong>float()</strong><br>返回由数字或字符串构造的浮点数</p></li><li><p><strong>format()</strong><br>将值转换为特定格式</p></li><li><p><strong>frozenset()</strong><br>返回一个新的<code>frozenset</code>对象，可选用来自迭代的元素</p></li><li><p><strong>getattr()</strong><br>返回对象命名属性的值</p></li><li><p><strong>globals()</strong><br>返回表示当前全局符号表的字典</p></li><li><p><strong>hasattr(obj, name)</strong><br>参数是一个对象和一份字符串，如果字符串是对象属性之一的名称，结果为<code>True</code>，否则<code>False</code></p></li><li><p><strong>hash(obj)</strong><br>返回对象的hash值</p></li><li><p><strong>help()</strong><br>调用内建的帮助系统</p></li><li><p><strong>hex(x)</strong><br>将整数转换为十六进制数</p></li><li><p><strong>id(obj)</strong><br>返回一个对象的标识</p></li><li><p><strong>input()</strong><br>从标准输入中读取一行，转换为字符串，然后返回该行</p></li><li><p><strong>int(x)</strong><br>返回一个整数对象，如果没有参数，则返回0</p></li><li><p><strong>isinstance(obj, classinfo)</strong><br>如果对象参数是classinfo参数的实例或其子类的实例，返回true</p></li><li><p><strong>issubclass(class, classinfo)</strong><br>如果class是类信息的子类，返回true</p></li><li><p><strong>iter(obj)</strong><br>返回一个迭代器对象</p></li><li><p><strong>len()</strong><br>返回对象的长度</p></li><li><p><strong>list()</strong><br>列表实际上是一个可变的序列类型，而不是一个函数</p></li><li><p><strong>locals()</strong><br>更新并返回表示当前本地符号表的字典</p></li><li><p><strong>map()</strong><br>返回一个将函数应用于每个迭代项的迭代器，从而产生结果</p></li><li><p><strong>max()</strong><br>返回最大项</p></li><li><p><strong>memoryview(obj)</strong><br>从给定参数返回内存视图对象</p></li><li><p><strong>min()</strong><br>返回最小项</p></li><li><p><strong>next()</strong><br>从迭代器中检索下一项</p></li><li><p><strong>object()</strong><br>返回一个新的无特征的对象</p></li><li><p><strong>oct()</strong><br>将整数转换为八进制字符串</p></li><li><p><strong>open()</strong><br>打开文件并返回相应的文件对象</p></li><li><p><strong>ord()</strong><br>给定一个表示一个Unicode编码的字符，返回一个表示该字符的Unicode编码的整数</p></li><li><p><strong>pow()</strong></p></li><li><p><strong>print()</strong><br>将对象打印到流文件</p></li><li><p><strong>property()</strong><br>返回一个property属性</p></li><li><p><strong>range()</strong><br>范围一个不可变的序列类型，而不是函数</p></li><li><p><strong>repr()</strong><br>返回一个包含对象可打印表示的字符串</p></li><li><p><strong>reversed()</strong><br>返回一个反向迭代器</p></li><li><p><strong>round()</strong><br>返回数字小数点后ndigits精度</p></li><li><p><strong>set()</strong><br>返回一个新的集合对象，可选来自迭代的元素</p></li><li><p><strong>setattr()</strong><br><code>getattr</code>的对应部分</p></li><li><p><strong>slice()</strong><br>返回由范围指定的一组索引的切片(slice)对象</p></li><li><p><strong>sorted()</strong><br>从迭代项中返回一个新的排序列表</p></li><li><p><strong>staticmethod()</strong><br>为函数返回一个静态方法</p></li><li><p><strong>str()</strong><br>返回一个字符串对象</p></li><li><p><strong>sum()</strong><br>对迭代项求和</p></li><li><p><strong>super()</strong><br>返回将方法调用委托个父类或同类的代理对象</p></li><li><p><strong>tuple()</strong><br>元组是一个不可变的序列类型，而不是函数</p></li><li><p><strong>vars()</strong><br>返回对象的<code>__dict__</code>属性</p></li><li><p><strong>zip()</strong><br>制作一个迭代器，用于聚合来自每个迭代器的元素</p></li><li><p><code>__import__</code><br>这个函数被<code>import</code>语句调用</p></li></ul><p><br><br><br></p><h2 id="内建常量"><a href="#内建常量" class="headerlink" title="内建常量"></a>内建常量</h2><p>少量常量存在于命名空间中。</p><ul><li><strong>False</strong></li><li><strong>True</strong></li><li><strong>None</strong></li><li><strong>NotImplemented</strong></li><li><strong>Ellipsis</strong></li><li><code>__debug__</code></li></ul><p><br><br><br></p><h2 id="内建类型"><a href="#内建类型" class="headerlink" title="内建类型"></a>内建类型</h2><p>主要的内建类型有：</p><ul><li>数字(numeric)</li><li>序列(sequence)</li><li>映射(mapping)</li><li>类(class)</li><li>实例(instance)</li><li>异常(exception)</li></ul><p><br><br><br></p><h3 id="真值测试"><a href="#真值测试" class="headerlink" title="真值测试"></a>真值测试</h3><p>任何对象都可进行真值测试。</p><p><br><br><br></p><h3 id="布尔操作"><a href="#布尔操作" class="headerlink" title="布尔操作"></a>布尔操作</h3><ul><li>and</li><li>or</li><li>not</li></ul><p><br><br><br></p><h3 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h3><p>Python中有8个比较操作：</p><ul><li><code>&lt;</code></li><li><code>&lt;=</code></li><li><code>&gt;</code></li><li><code>&gt;=</code></li><li><code>==</code></li><li><code>!=</code></li><li><code>is</code></li><li><code>isnot</code></li></ul><p><br><br><br></p><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><ul><li>int</li><li>float</li><li>complex</li></ul><p><br><br><br></p><h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3><p>Python支持对容器进行迭代的概念。</p><p><br><br><br></p><h3 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h3><ul><li>list<ul><li>列表是可变序列，通常用于存储同类项目的集合</li></ul></li><li>tuple<ul><li>元组是不可变序列，通常用于存储异构数据的集合</li></ul></li><li>range<ul><li>范围表示一个不可变的数字序列，通常用于<code>for</code>循环</li><li>range(start, stop, step)</li></ul></li></ul><p><br></p><h4 id="通用序列操作"><a href="#通用序列操作" class="headerlink" title="通用序列操作"></a>通用序列操作</h4><ul><li><code>in</code></li><li><code>not in</code></li><li><code>+</code></li><li><code>*</code></li><li><code>[i]</code></li><li><code>[i:j]</code></li><li><code>[i:j:k]</code></li><li><code>len()</code></li><li><code>min()</code></li><li><code>max()</code></li><li><code>count()</code></li><li><code>index()</code></li></ul><p><br></p><h4 id="不可变序列类型"><a href="#不可变序列类型" class="headerlink" title="不可变序列类型"></a>不可变序列类型</h4><p><br></p><h4 id="可变序列类型"><a href="#可变序列类型" class="headerlink" title="可变序列类型"></a>可变序列类型</h4><p>可变定义类型的操作：</p><ul><li><code>[i]</code></li><li><code>[i:j]</code></li><li><code>del [i:j:k]</code></li><li><code>append()</code></li><li><code>clear()</code></li><li><code>copy()</code></li><li><code>+=</code></li><li><code>*=</code></li><li><code>insert()</code></li><li><code>pop</code></li><li><code>remove()</code></li><li><code>reverse()</code></li></ul><p><br><br><br></p><h3 id="文本序列类型"><a href="#文本序列类型" class="headerlink" title="文本序列类型"></a>文本序列类型</h3><p>Python中的文本数据由str对象处理，字符串是Unicode编码点的不可变序列。</p><p>字符串以各种方式书写：</p><ul><li>单引号</li><li>双引号</li><li>三引号</li></ul><p><br></p><h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><ul><li><a href="https://docs.python.org/3.5/library/stdtypes.html#string-methods" target="_blank" rel="noopener">https://docs.python.org/3.5/library/stdtypes.html#string-methods</a></li></ul><p><br></p><h4 id="样式字符串格式"><a href="#样式字符串格式" class="headerlink" title="样式字符串格式"></a>样式字符串格式</h4><p>字符串对象有一个唯一的内建操作: <code>%</code>操作符，也称为字符串格式化操作符。</p><p>转换类型：</p><ul><li><code>%</code></li><li><code>s</code></li><li><code>i</code></li><li><code>x</code></li><li><code>f</code></li><li><code>c</code></li></ul><p><br><br><br></p><h3 id="二进制序列类型"><a href="#二进制序列类型" class="headerlink" title="二进制序列类型"></a>二进制序列类型</h3><ul><li>bytes<ul><li>字节对象是单字节的不可变序列</li></ul></li><li>bytearray<ul><li>是字节对象的可变对象</li></ul></li><li>memoryview<ul><li>运行Python代码访问支持缓冲区协议的对象的内部数据，而无需复制</li></ul></li></ul><p>字节和字节数组对象操作符都支持普通序列操作符，同样也支持字节格式。</p><p><br><br><br></p><h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><ul><li>set</li><li>frozenset</li></ul><p>集合对象是不同可散列对象的无序集合。常见用途包含成员测试、删除重复项，数学计算(交集，并集，差集)</p><p><br><br><br></p><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><ul><li>dict</li></ul><p>映射对象可将散列值映射到任意对象，它是可变对象。</p><p><br></p><h4 id="字典视图对象"><a href="#字典视图对象" class="headerlink" title="字典视图对象"></a>字典视图对象</h4><ul><li><code>dict.keys()</code></li><li><code>dict.values()</code></li><li><code>dict.items()</code></li></ul><p><br><br><br></p><h3 id="上下文管理类型"><a href="#上下文管理类型" class="headerlink" title="上下文管理类型"></a>上下文管理类型</h3><p>Python的<code>with</code>语句支持由上下文管理器定义的运行时上下文的概念。</p><p><br><br><br></p><h3 id="其它内建类型"><a href="#其它内建类型" class="headerlink" title="其它内建类型"></a>其它内建类型</h3><h4 id="模块-1"><a href="#模块-1" class="headerlink" title="模块"></a>模块</h4><h4 id="类和类实例"><a href="#类和类实例" class="headerlink" title="类和类实例"></a>类和类实例</h4><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h4 id="代码对象"><a href="#代码对象" class="headerlink" title="代码对象"></a>代码对象</h4><h4 id="类型对象"><a href="#类型对象" class="headerlink" title="类型对象"></a>类型对象</h4><h4 id="null对象"><a href="#null对象" class="headerlink" title="null对象"></a>null对象</h4><h4 id="ellipsis对象"><a href="#ellipsis对象" class="headerlink" title="ellipsis对象"></a>ellipsis对象</h4><h4 id="notImplimented对象"><a href="#notImplimented对象" class="headerlink" title="notImplimented对象"></a>notImplimented对象</h4><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><h4 id="内部对象"><a href="#内部对象" class="headerlink" title="内部对象"></a>内部对象</h4><p><br><br><br></p><h3 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h3><p>一些特殊的只读属性：</p><ul><li><code>object.__dict__</code></li><li><code>instance.__class__</code></li><li><code>class.__bases__</code></li><li><code>definition.__name__</code></li><li><code>definition.__qualname__</code></li><li><code>class.__mro__</code></li><li><code>class.__subclasses__()</code></li></ul><p><br><br><br></p><h2 id="内建异常"><a href="#内建异常" class="headerlink" title="内建异常"></a>内建异常</h2><p>在Python中，所有异常(exception)都必须是派生自Baseexception的类的实例。</p><p><br><br><br></p><h3 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h3><ul><li>BaseException</li><li>Exception</li><li>ArithmeticError</li><li>bufferError</li><li>LookupError</li></ul><p><br><br><br></p><h3 id="具体异常"><a href="#具体异常" class="headerlink" title="具体异常"></a>具体异常</h3><ul><li>AssertionError</li><li>AttributeError</li><li>EOFError</li><li>FloatingPointError</li><li>GeneratorExit</li><li>ImportError</li><li>IndexError</li><li>KeyError</li><li>KerboardInterrupt</li><li>MemoryError</li><li>NameError</li><li>NotImplementedError</li><li>OSError</li><li>OverflowError</li><li>RecursionError</li><li>ReferenceError</li><li>RuntimeError</li><li>StopAsyncIteration</li><li>SyntaxError</li><li>IndentationError</li><li>TabError</li><li>SystemError</li><li>SystemExit</li><li>TypeError</li><li>UnboundLocalError</li><li>UnicodeError</li><li>UnicodeEncodeError</li><li>UnicodeDecodeError</li><li>UnicodeTranslateError</li><li>ValueError</li><li>ZeroDivisionError</li><li>EnvironmentError</li><li>IOError</li></ul><p><br><br><br></p><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p><code>string</code>模块，字符串操作</p><p><br><br><br></p><h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><p><code>re</code>模块，提供了正则表达式匹配操作。</p><p><strong>字符串模式匹配</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r'f[a-z]*'</span>, <span class="string">'which foot or hand fell fastest'</span>)</span><br><span class="line">[<span class="string">'foot'</span>, <span class="string">'fell'</span>, <span class="string">'fastest'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#替换</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'aaa and bbb'</span>.replace(<span class="string">'bbb'</span>, <span class="string">'BBB'</span>)</span><br><span class="line"><span class="string">'aaa and BBB'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="difflib"><a href="#difflib" class="headerlink" title="difflib"></a>difflib</h3><p>difflib，助手计算三角洲。<br>该模块提供用于比较序列的类和函数。</p><p><br><br><br></p><h3 id="textwrap"><a href="#textwrap" class="headerlink" title="textwrap"></a>textwrap</h3><p><code>textwrap</code>模块，文本环绕和填充。<br>将段落文本格式化以适应给定的屏幕宽度。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> textwrap</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc = <span class="string">""" 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="string"><span class="meta">... </span>2222 2222 2222 2222 2222 2222</span></span><br><span class="line"><span class="string"><span class="meta">... </span>3333 3333 3333 3333 3333 3333"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(textwrap.fill(doc, width=<span class="number">50</span>))</span><br><span class="line"> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">2222</span> <span class="number">2222</span> <span class="number">2222</span> <span class="number">2222</span></span><br><span class="line"><span class="number">2222</span> <span class="number">2222</span> <span class="number">3333</span> <span class="number">3333</span> <span class="number">3333</span> <span class="number">3333</span> <span class="number">3333</span> <span class="number">3333</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="unicodedata"><a href="#unicodedata" class="headerlink" title="unicodedata"></a>unicodedata</h3><p>unicodedata，Unicode数据库。<br>该模块提供对Unicode字符数据库(UCD)的访问，此数据库为所有Unicode字符定义字符属性。</p><p><br><br><br></p><h3 id="stringprep"><a href="#stringprep" class="headerlink" title="stringprep"></a>stringprep</h3><p>stringprep，因特网字符串准备。</p><p><br><br><br></p><h3 id="readline"><a href="#readline" class="headerlink" title="readline"></a>readline</h3><p>readline，GNU读行接口。<br>该模块定义了许多方便Python解释器完成和读写历史文件的函数。</p><p><br><br><br></p><h3 id="rlcompleter"><a href="#rlcompleter" class="headerlink" title="rlcompleter"></a>rlcompleter</h3><p>rlcompleter，GNU读行的完成函数。<br>该模块通过完成有效的Python标识符合关键字来定义适用于readline模块的完成函数。</p><p><br><br><br></p><h2 id="二进制数据"><a href="#二进制数据" class="headerlink" title="二进制数据"></a>二进制数据</h2><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p><code>struct</code>模块，将字节解释为打包的二进制数据。<br>提供了<code>pack()</code>和<code>unpack()</code>函数来处理可变长度的二进制记录格式。</p><p><br><br><br></p><h3 id="codecs"><a href="#codecs" class="headerlink" title="codecs"></a>codecs</h3><p>codes，编解码注册和基类。</p><p><br><br><br></p><h2 id="数据和时间"><a href="#数据和时间" class="headerlink" title="数据和时间"></a>数据和时间</h2><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p><code>time</code>模块，提供了许多操作时间值(time value)的函数，用于取得Unix纪元时间戳。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#Unix时间</span></span><br><span class="line">time.time()</span><br><span class="line"><span class="comment">#1531364576.3187952</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#delay for a number of seconds given as a float</span></span><br><span class="line">time.sleep()</span><br><span class="line">time.time();time.sleep(<span class="number">10</span>);time.time()</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h3><p><code>datetime</code>模块，基本日期和时间类型。<br>支持日期和时间计算，并对输出做格式化处理。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">datetime.datetime.now()</span><br><span class="line"><span class="comment">#datetime.datetime(2018, 7, 12, 13, 45, 43, 127838)</span></span><br><span class="line">datetime.datetime.now().year, datetime.datetime.now().month, datetime.datetime.now().hour</span><br><span class="line"></span><br><span class="line"><span class="comment">#Unix纪元转换</span></span><br><span class="line">datetime.datetime.fromtimestamp(<span class="number">1531374507.8268566</span>)</span><br><span class="line"><span class="comment">#datetime.datetime.fromtimestamp(time.time())</span></span><br><span class="line"><span class="comment">#datetime.datetime(2018, 7, 12, 13, 48, 27, 826857)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#日期比较</span></span><br><span class="line">yesterday = datetime.datetime(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">00</span>, <span class="number">00</span>, <span class="number">00</span>, <span class="number">00000</span>)</span><br><span class="line">today = datetime.datetime.now()</span><br><span class="line">future = datetime.datetime(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">00</span>, <span class="number">00</span>, <span class="number">00</span>, <span class="number">00000</span>)</span><br><span class="line">today &gt; yesterday</span><br><span class="line"><span class="keyword">while</span> future &gt; today:</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#timedelta表示一段时间</span></span><br><span class="line"><span class="comment">#周，时，分，秒，毫秒，微秒</span></span><br><span class="line">period = datetime.timedelta(days=<span class="number">7</span>, hours=<span class="number">6</span>, minutes=<span class="number">20</span>, seconds=<span class="number">55</span>)</span><br><span class="line">str(period)</span><br><span class="line"><span class="comment">#'7 days, 6:20:55'</span></span><br></pre></td></tr></table></figure><p><code>datetime.datetime.strftime()</code>将<code>datetime</code>对象转换为字符串<br><code>datetime.datetime.strptime()</code>将字符串转换为<code>datetime</code>对象<br>格式栗子:</p><ul><li><code>%Y</code>: 2018</li><li><code>%y</code>: 18</li><li><code>%m</code>: 07</li><li><code>%B</code>: July</li><li><code>%b</code>: Jul</li><li><code>%d</code>: 一月中的第几天</li><li><code>%j</code>: 一年中的第几天</li><li><code>%w</code>: 一周中的第几天(0-6)</li><li><code>%A</code>: Thursday</li><li><code>%a</code>: Thu</li><li><code>%H</code>: 14(00-23)</li><li><code>%I</code>: 2(0-12)</li><li><code>%M</code>: 分(00-59)</li><li><code>%S</code>: 秒(00-59)</li><li><code>%p</code>: AM/PM</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line"><span class="comment">#'2018-07-12 14:11:20'</span></span><br><span class="line"></span><br><span class="line">datetime.datetime.strptime(<span class="number">2018</span><span class="number">-07</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">11</span>:<span class="number">20</span><span class="string">', '</span>%Y-%m-%d %H:%M:%S<span class="string">')</span></span><br><span class="line"><span class="string">#datetime.datetime(2018, 7, 12, 14, 11, 20)</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="calendar"><a href="#calendar" class="headerlink" title="calendar"></a>calendar</h3><p>calendar，日历相关函数。</p><p><br><br><br></p><h3 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h3><p>collections，容器数据类型。</p><p><br><br><br></p><h3 id="collections-abc"><a href="#collections-abc" class="headerlink" title="collections.abc"></a>collections.abc</h3><p>collections.abc，容器的抽象基类</p><p><br><br><br></p><h3 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h3><p>heapq，堆队列算法。</p><p><br><br><br></p><h3 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h3><p>bisect，数组二等分算法。</p><p><br><br><br></p><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p><code>array</code>模块，有效的数值数组。<br>它提供了一个<code>array()</code>对象，就像一个只存储同质数据并将其存储更紧凑的列表。</p><p><br><br><br></p><h3 id="weakref"><a href="#weakref" class="headerlink" title="weakref"></a>weakref</h3><p>weakref，弱引用。<br>weakref模块提供了用于跟踪对象而不创建参考的工具。当不再需要该对象时，它将自动从弱参考表中移除，并为弱参考对象触发回调。</p><p>Python支持自动内存管理，内存在最后一次被删除后不久就被释放。</p><p><br><br><br></p><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>copy，浅层和深层操作。</p><p><br><br><br></p><h3 id="pprint"><a href="#pprint" class="headerlink" title="pprint"></a>pprint</h3><p><code>pprint</code>模块，漂亮打印。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t =[[[[<span class="string">'black'</span>, <span class="string">'cyan'</span>], <span class="string">'white'</span>, [<span class="string">'green'</span>, <span class="string">'red'</span>]], [[<span class="string">'magenta'</span>,<span class="string">'yellow'</span>], <span class="string">'blue'</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(t, width=<span class="number">30</span>)</span><br><span class="line">[[[[<span class="string">'black'</span>, <span class="string">'cyan'</span>],</span><br><span class="line">   <span class="string">'white'</span>,</span><br><span class="line">   [<span class="string">'green'</span>, <span class="string">'red'</span>]],</span><br><span class="line">  [[<span class="string">'magenta'</span>, <span class="string">'yellow'</span>],</span><br><span class="line">   <span class="string">'blue'</span>]]]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="reprlib"><a href="#reprlib" class="headerlink" title="reprlib"></a>reprlib</h3><p><code>reprlib</code>模块，提供repr自定义显示</p><p><br><br><br></p><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>enum，支持枚举。</p><p><br><br><br></p><h2 id="数字和数学"><a href="#数字和数学" class="headerlink" title="数字和数学"></a>数字和数学</h2><h3 id="numbers"><a href="#numbers" class="headerlink" title="numbers"></a>numbers</h3><p>numbers，数字抽象基类。</p><p><br><br><br></p><h3 id="round"><a href="#round" class="headerlink" title="round"></a>round</h3><p>按指定精度四舍五入一个浮点数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">round(1.23456, 4)</span><br><span class="line">#1.236</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="math"><a href="#math" class="headerlink" title="math"></a>math</h3><p><code>math</code>模块，数学函数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.sin(math.pi / <span class="number">2</span>)</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.log(<span class="number">256</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">8.0</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="cmath"><a href="#cmath" class="headerlink" title="cmath"></a>cmath</h3><p>cmath，复数数学函数。</p><p><br><br><br></p><h3 id="decimal"><a href="#decimal" class="headerlink" title="decimal"></a>decimal</h3><p>decimal，十进制定点和浮点运算。</p><p><br><br><br></p><h3 id="fractions"><a href="#fractions" class="headerlink" title="fractions"></a>fractions</h3><p>fractions，有理数。</p><p><br><br><br></p><h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><p>random，生成伪随机数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.choice([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.sample(range(<span class="number">10</span>), <span class="number">2</span>)</span><br><span class="line">[<span class="number">2</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.random()</span><br><span class="line"><span class="number">0.9714711378164909</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randrange(<span class="number">10</span>)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="statistics"><a href="#statistics" class="headerlink" title="statistics"></a>statistics</h3><p><code>statistics</code>模块，数学统计函数。<br>计算基本的统计属性：</p><ul><li>平均数(mean)</li><li>中位数(median)</li><li>方差(variance)</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> statistics</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statistics.mean(num)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statistics.median(num)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statistics.variance(num)</span><br><span class="line"><span class="number">2.5</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="函数式编程模块"><a href="#函数式编程模块" class="headerlink" title="函数式编程模块"></a>函数式编程模块</h2><p>本章模块提供了支持函数式编程风格的函数和类，以及可调用函数的一般操作。</p><p><br><br><br></p><h3 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h3><p>itertools，为高校循环创建迭代器。</p><p><br><br><br></p><h3 id="functools"><a href="#functools" class="headerlink" title="functools"></a>functools</h3><p>functools，可调用对象的高阶函数和操作</p><p><br><br><br></p><h3 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h3><p>operator，作为函数的标准操作符</p><p><br><br><br></p><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>本章介绍的模块处理磁盘文件和目录。</p><p><br><br><br></p><h3 id="pathlib"><a href="#pathlib" class="headerlink" title="pathlib"></a>pathlib</h3><p>pathlib，面向对象的文件系统路径<br>此模块提供了代表文件系统路径的类，其语义适用于不同的操作系统。</p><p><br><br><br></p><h3 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h3><p>os.path，通用路径名操作<br>该模块在路径名上实现了一些有用的功能。</p><p><br><br><br></p><h3 id="fileinput"><a href="#fileinput" class="headerlink" title="fileinput"></a>fileinput</h3><p>fileinput，迭代来自多个输入流的行<br>该模块实现了从一个帮助类和函数，可在标准输入或文件列表上快速编写循环。</p><p><br><br><br></p><h3 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h3><p>stat，解释<code>stat()</code>结果<br>此模块定义用于解释<code>os.stat()</code>,<code>os.fstat()</code>,<code>os.lstat()</code>的结果的常量和函数。</p><p><br><br><br></p><h3 id="filecmp"><a href="#filecmp" class="headerlink" title="filecmp"></a>filecmp</h3><p>filecmp，文件和目录比较<br>此模块定义了比较文件和目录的函数，以及各种可选的时间和权衡。</p><p><br><br><br></p><h3 id="tempfile"><a href="#tempfile" class="headerlink" title="tempfile"></a>tempfile</h3><p>tempfile，生成临时文件和目录<br>此模块创建临时文件和目录。</p><p><br><br><br></p><h3 id="glob"><a href="#glob" class="headerlink" title="glob"></a>glob</h3><p>glob，Unix样式路径名称模式扩展<br>此模块根据Unix shell使用的规则查找与指定模式匹配的所有路径名，结果以任意顺序返回。</p><p><br><br><br></p><h3 id="fnmatch"><a href="#fnmatch" class="headerlink" title="fnmatch"></a>fnmatch</h3><p>fnmatch，Unix文件名模式匹配<br>此模块提供了对Unix shell风格的通配符的支持，它与正则表达式不同。</p><p>通配符:</p><ul><li><code>*</code></li><li><code>?</code></li><li><code>[seq]</code></li><li><code>[!seq]</code></li></ul><p><br><br><br></p><h3 id="linecache"><a href="#linecache" class="headerlink" title="linecache"></a>linecache</h3><p>linecache，随机访问文本行<br>此模块允许从Python源文件中获取任意行，同时尝试使用缓存进行内部优化，这是一种从单个文件中读取多行的常见情况。</p><p><br><br><br></p><h3 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h3><p>shutil，高级文件操作<br>此模块提供了许多关于文件和文件集合的高级操作。</p><ul><li>目录和文件操作<ul><li>copytree</li><li>rmtree</li></ul></li><li>归档操作</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>shutil.copyfile(<span class="string">'/tmp/1.txt'</span>, <span class="string">'/tmp/111.txt'</span>)</span><br><span class="line"><span class="string">'/tmp/111.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shutil.move(<span class="string">'/tmp/today'</span>, <span class="string">'/tmp/TODAY'</span>)</span><br><span class="line"><span class="string">'/tmp/TODAY</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="glob-1"><a href="#glob-1" class="headerlink" title="glob"></a>glob</h3><p><code>glob</code>模块，从通配符中搜索创建文件列表</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'/tmp/*.txt'</span>)</span><br><span class="line">[<span class="string">'/tmp/1.txt'</span>, <span class="string">'/tmp/2.txt'</span>, <span class="string">'/tmp/111.txt'</span>]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>本章介绍的模块支持将Python数据持久化存储到磁盘上。</p><p><br><br><br></p><h3 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h3><p>pickle，Python对象序列化<br>此模块用于实现序列化(serializing)和反序列化Python对象结构的二进制协议。</p><p><br><br><br></p><h3 id="copyreg"><a href="#copyreg" class="headerlink" title="copyreg"></a>copyreg</h3><p>copyreg，注册pickle支持函数<br>该模块提供了一种定义胭脂(pickle)特定对象时使用的函数方法。</p><p><br><br><br></p><h3 id="shelve"><a href="#shelve" class="headerlink" title="shelve"></a>shelve</h3><p>shelve，Python对象持久化<br>shelf是一个持久的，类似字典的对象。</p><p><br><br><br></p><h3 id="marshal"><a href="#marshal" class="headerlink" title="marshal"></a>marshal</h3><p>marshal，内部Python对象序列化<br>此模块包含了可以以二进制格式读写Python值得函数。</p><p><br><br><br></p><h3 id="dbm"><a href="#dbm" class="headerlink" title="dbm"></a>dbm</h3><p>dbm，到Unix数据库的接口<br>dbm是DBM数据库变体的通用接口。</p><p><br><br><br></p><h3 id="sqlite3"><a href="#sqlite3" class="headerlink" title="sqlite3"></a>sqlite3</h3><p>sqlite3，SQLite数据库的DB-API 2.0接口<br>SQLite是一个C库，它提供了一个轻量级的基于磁盘的数据库，它不需要单独的服务器进程，并允许使用SQL查询语言的非标准变体访问数据库。</p><p><br><br><br></p><h2 id="数据压缩和归档"><a href="#数据压缩和归档" class="headerlink" title="数据压缩和归档"></a>数据压缩和归档</h2><p>本章介绍的模块，支持使用zlib, gzip, bzip2, lzma算法进行数据压缩，以及创建zip和tar格式的归档文件。</p><p><br><br><br></p><h3 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h3><p>zlib，兼容gzip的压缩<br>对于需要数据压缩的应用程序，此模块中的功能允许使用zlib库进行压缩(compression)和解压缩(decompression)。</p><p><br><br><br></p><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p>gzip，支持gzip文件<br>此模块提供了一个简单的接口来压缩和解压缩文件，就行GNU程序gzip和gunzip一样。</p><p><br><br><br></p><h3 id="bz2"><a href="#bz2" class="headerlink" title="bz2"></a>bz2</h3><p>bz2，支持bz2压缩<br>该模块提供了一个全面的接口，用于使用bzip2压缩算法进行压缩和解压缩数据。</p><p><br><br><br></p><h3 id="lzma"><a href="#lzma" class="headerlink" title="lzma"></a>lzma</h3><p>lzma，使用lzma算法进行压缩<br>该模块提供了类和函数，用于使用lzma进行压缩和解压缩数据。</p><p><br><br><br></p><h3 id="zipfile"><a href="#zipfile" class="headerlink" title="zipfile"></a>zipfile</h3><p>zipfile，使用zip归档<br>zip文件格式是一个常用的归档和压缩标准。此模块提供了工具，用于创建，读写，追加和列出zip文件的工具。</p><p><br><br><br></p><h3 id="tarfile"><a href="#tarfile" class="headerlink" title="tarfile"></a>tarfile</h3><p>tarfile，读写tar归档文件<br>该模块可读写tar归档文件，包括使用gzip，bz2和lzma压缩。</p><p><br><br><br></p><h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p>本章描述的模块，解析各种各样的文件格式，不包含标记语言和e-mail。</p><p><br><br><br></p><h3 id="csv"><a href="#csv" class="headerlink" title="csv"></a>csv</h3><p>csv，读写CSV文件</p><p>所谓的CSV(comma separated values)逗号分隔值，它是一种简化的电子表格，保存为纯文本文件。是电子表格和数据库最常用的导入和导出格式。<br>该模块实现了以CSV格式读写表格数据。</p><p>CSV文件很简单，缺少了Excel表格的许多功能：</p><ul><li>值没有类型，都是字符串</li><li>没有字体大小或颜色</li><li>没有多个工作表</li><li>不能指定单元格的宽度和高度</li><li>不能合并单元格</li><li>不能签入图像和图标</li></ul><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"></span><br><span class="line">file = open(&apos;/tmp/test.csv&apos;)</span><br><span class="line">reader = csv.reader(file)</span><br><span class="line">data = list(reder)</span><br><span class="line"></span><br><span class="line">#写</span><br><span class="line">file = open(&apos;/tmp/test.csv&apos;, &apos;w&apos;, newline=&apos;&apos;)</span><br><span class="line">writer = csv.writer(file)</span><br><span class="line">writer.writerow(&apos;[1, 11, 111]&apos;)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="configparser"><a href="#configparser" class="headerlink" title="configparser"></a>configparser</h3><p>configparser，配置文件解析器<br>此模块提供了ConfigParser类，它实现了一种基本配置，你可以使用它来编写可由最终用户轻松定制的Python程序。</p><p><br><br><br></p><h3 id="netrc"><a href="#netrc" class="headerlink" title="netrc"></a>netrc</h3><p>netrc文件处理<br>netrc类解析和封装Unix FTP程序和其它FTP客户端使用的netrc文件格式。</p><p><br><br><br></p><h3 id="xdrlib"><a href="#xdrlib" class="headerlink" title="xdrlib"></a>xdrlib</h3><p>xdrlib，编码(encode)和解码(decode)XDR数据<br>该模块支持外部数据表示标准(External Data Representation Standard)。此模块定义了两个类，一个将变量打包(packing)到XDR，另一个从XDR中解包(unpack)。</p><p><br><br><br></p><h2 id="加密服务"><a href="#加密服务" class="headerlink" title="加密服务"></a>加密服务</h2><p>本章描述的模块，实现了各种加密(cryptographic)算法</p><p><br><br><br></p><h3 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h3><p>hashlib，安全散列和消息摘要(digest)<br>该模块为许多不同安全散列和消息摘要算法实现了通用接口。</p><ul><li>SHA1</li><li>SHA224</li><li>SHA256</li><li>SHA384</li><li>MD5</li></ul><p><br><br><br></p><h3 id="hmac"><a href="#hmac" class="headerlink" title="hmac"></a>hmac</h3><p>hmac，用于消息认证的键控散列</p><p><br><br><br></p><h2 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h2><p>本章介绍的模块，提供了操作系统功能的接口。</p><p><br><br><br></p><h3 id="os"><a href="#os" class="headerlink" title="os"></a>os</h3><p><code>os</code>，各种操作系统接口<br>该模块为使用操作系统相关的功能提供了一种便携方式。</p><ul><li>文件名，命令行参数，环境变量</li><li>进程参数</li><li>文件对象创建</li><li>文件描述符操作</li><li>文件和目录的Linux扩展属性</li><li>进程管理</li><li>调度程序的接口</li><li>各种各样的系统信息</li><li>各种各样的功能</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd()</span><br><span class="line"><span class="string">'/home/zhang'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.chdir(<span class="string">'/tmp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在shell中运行命令</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">'mkdir /tmp/today'</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="io"><a href="#io" class="headerlink" title="io"></a>io</h3><p>io，流处理的核心工具<br>该模块提供了Python用于处理各种类型I/O的主要工具。</p><ul><li>text i/o</li><li>binary i/o</li><li>raw i/o</li></ul><p><br><br><br></p><h3 id="time-1"><a href="#time-1" class="headerlink" title="time"></a>time</h3><p>time，访问和转换时间<br>此模块提供了各种与时间相关的函数</p><p><br><br><br></p><h3 id="argparse"><a href="#argparse" class="headerlink" title="argparse"></a>argparse</h3><p>argparse，解析命令行选项、参数和子命令<br>该模块可以轻松编写用户友好的命令行接口。</p><p><br><br><br></p><h3 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h3><p>getopt，用于命令行选项的C风格解析器<br>该模块帮助脚本解析<code>sys.argv</code>中的命令行参数。</p><p><br><br><br></p><h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>logging，Python的日志工具<br>该模块定义了函数和类，为应用程序和库实现灵活事件记录系统</p><p>log level:</p><ul><li><p>DEBUG<br>最低级别。用于小细节，通常只有在诊断问题时，才需要关心这些信息。</p></li><li><p>INFO<br>用于记录程序中的一般事件的信息。</p></li><li><p>WARNING<br>用于表示可能的问题</p></li><li><p>ERROR<br>用于记录错误</p></li><li><p>CRITICAL<br>最高级别，用于表示致命的错误</p></li></ul><p><br></p><p><strong>日志级别是一种建议。归根到底，还是由你来决定日志消息属于哪一种类型。</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, format=<span class="string">'%(asctime)s - %(levelname)s - %(lineno)d - %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">'Debugging information'</span>)</span><br><span class="line">logging.info(<span class="string">'Informational message'</span>)</span><br><span class="line">logging.warning(<span class="string">'Warning:config file %s not found'</span>, <span class="string">'server.conf'</span>)</span><br><span class="line">logging.error(<span class="string">'Error occurred'</span>)</span><br><span class="line">logging.critical(<span class="string">'Critical error -- shutting down'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="number">2018</span><span class="number">-07</span><span class="number">-10</span> <span class="number">14</span>:<span class="number">50</span>:<span class="number">13</span>,<span class="number">060</span> - INFO - <span class="number">6</span> - Informational message</span><br><span class="line"><span class="number">2018</span><span class="number">-07</span><span class="number">-10</span> <span class="number">14</span>:<span class="number">50</span>:<span class="number">13</span>,<span class="number">061</span> - WARNING - <span class="number">7</span> - Warning:config file server.conf <span class="keyword">not</span> found</span><br><span class="line"><span class="number">2018</span><span class="number">-07</span><span class="number">-10</span> <span class="number">14</span>:<span class="number">50</span>:<span class="number">13</span>,<span class="number">061</span> - ERROR - <span class="number">8</span> - Error occurred</span><br><span class="line"><span class="number">2018</span><span class="number">-07</span><span class="number">-10</span> <span class="number">14</span>:<span class="number">50</span>:<span class="number">13</span>,<span class="number">061</span> - CRITICAL - <span class="number">9</span> - Critical error -- shutting down</span><br></pre></td></tr></table></figure><p><br></p><p>log format:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|  %(name)s            Name of the logger (logging channel)</span><br><span class="line">|  %(levelno)s         Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL)</span><br><span class="line">|  %(levelname)s       Text logging level for the message (&quot;DEBUG&quot;, &quot;INFO&quot;, &quot;WARNING&quot;, &quot;ERROR&quot;, &quot;CRITICAL&quot;)</span><br><span class="line">|  %(pathname)s        Full pathname of the source file where the logging call was issued (if available)</span><br><span class="line">|  %(filename)s        Filename portion of pathname</span><br><span class="line">|  %(module)s          Module (name portion of filename)</span><br><span class="line">|  %(lineno)d          Source line number where the logging call was issued (if available)</span><br><span class="line">|  %(funcName)s        Function name</span><br><span class="line">|  %(created)f         Time when the LogRecord was created (time.time() return value)</span><br><span class="line">|  %(asctime)s         Textual time when the LogRecord was created</span><br><span class="line">|  %(msecs)d           Millisecond portion of the creation time</span><br><span class="line">|  %(relativeCreated)d Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded (typically at application startup time)</span><br><span class="line">|  %(thread)d          Thread ID (if available)</span><br><span class="line">|  %(threadName)s      Thread name (if available)</span><br><span class="line">|  %(process)d         Process ID (if available)</span><br><span class="line">|  %(message)s         The result of record.getMessage(), computed just as the record is emitted</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="logging-config"><a href="#logging-config" class="headerlink" title="logging.config"></a>logging.config</h3><p>logging.config，日志配置</p><p><br><br><br></p><h3 id="logging-handlers"><a href="#logging-handlers" class="headerlink" title="logging.handlers"></a>logging.handlers</h3><p>logging.handlers，日志处理程序</p><p><br><br><br></p><h3 id="getpass"><a href="#getpass" class="headerlink" title="getpass"></a>getpass</h3><p>getpass，便携式密码输入</p><p><br><br><br></p><h3 id="curses"><a href="#curses" class="headerlink" title="curses"></a>curses</h3><p>curses，字符单元显示的终端处理</p><p><br><br><br></p><h3 id="curses-textpad"><a href="#curses-textpad" class="headerlink" title="curses.textpad"></a>curses.textpad</h3><p>curses.textpad，用于curses程序的文本输入小部件<br>此模块提供了一个Textbox类，他在curses窗口中处理基本的文本编辑。</p><p><br><br><br></p><h3 id="curses-ascii"><a href="#curses-ascii" class="headerlink" title="curses.ascii"></a>curses.ascii</h3><p>curses.ascii，用于ASCII字符的使用程序<br>该模块为ASCII字符提供名称常量，并为各种ASCII字符类中的成员测试函数。</p><p><br><br><br></p><h3 id="curses-panel"><a href="#curses-panel" class="headerlink" title="curses.panel"></a>curses.panel</h3><p>curses.panel，curses的面板堆栈扩展<br>面板是具有深度附加功能的窗口，因此它可堆叠在彼此的顶部，并且只显示每个窗口的可见部分。</p><p><br><br><br></p><h3 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h3><p>platform，访问底层平台的识别数据</p><p><br><br><br></p><h3 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h3><p>errno，标准的errno系统符号</p><p><br><br><br></p><h3 id="ctypes"><a href="#ctypes" class="headerlink" title="ctypes"></a>ctypes</h3><p>ctypes，一个Python的外部函数库<br>该模块提供了C兼容的数据类型，并允许在DLL或共享中调用函数。</p><p><br><br><br></p><h2 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h2><p>本章介绍的模块，为并发执行(consurrent execution)代码提供了支持。</p><p><br><br><br></p><h3 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h3><p>threading，基于线程的并行<br>此模块在较低级别的<code>_thread</code>模块之上构建较高级别的线程接口。</p><p>如果多线程同时读写变量，导致互相干扰，就会发生所谓的并发问题。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, threading</span><br><span class="line"></span><br><span class="line">print(<span class="string">'thread start.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wakeup</span><span class="params">(times)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">n = times</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(<span class="string">'Wake Up!'</span>)</span><br><span class="line"></span><br><span class="line">thread01 = threading.Thread(target=wakeup, args=[<span class="number">3</span>])</span><br><span class="line"><span class="comment">#thread01 = threading.Thread(target=wakeup, kwargs=&#123;'times': 3&#125;)</span></span><br><span class="line">thread01.start()</span><br><span class="line">print(<span class="string">'End of program!'</span>)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><p>multiprocessing，基于进程的并行<br>它是一个使用类似线程模块的API来支持产生进程的包。</p><p><br><br><br></p><h3 id="concurrent"><a href="#concurrent" class="headerlink" title="concurrent"></a>concurrent</h3><p>concurrent包中只有一个模块<br>concurrent.futures，启动并行任务<br>该模块为异步(asynchronously)执行可调用提供了一个高级的接口。</p><p><br><br><br></p><h3 id="subprocess"><a href="#subprocess" class="headerlink" title="subprocess"></a>subprocess</h3><p>subprocess，子进程管理<br>该模块允许你生成新的进程，连接到它们的input/output/error pipes，并获得它们返回的代码。<br>每个进程可以有多个线程。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment">#在Python脚本中启动一个外部程序</span></span><br><span class="line">subprocess.Popen(‘/tmp/hello.py’)</span><br><span class="line"><span class="comment">#hello world!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用Popen传递参数，这需要传递一个列表</span></span><br><span class="line">subprocess.Popen([‘/tmp/hello.py’, <span class="string">'argv1'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#它还有许多参数</span></span><br><span class="line">help(subprocess.Popen)</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><h3 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h3><p>sched，事件调度程序(scheduler)<br>该模块定义了一个实现通用时间调度器的类。</p><p><br><br><br></p><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue，一个同步队列类<br>该模块实现了多生产者、多消费者队列。当信息必须在多线程之间安全地交换时，它在线程编程中特别有用。</p><p><br><br><br></p><h2 id="进程间的通信和网络"><a href="#进程间的通信和网络" class="headerlink" title="进程间的通信和网络"></a>进程间的通信和网络</h2><p>本章介绍的模块，提供了不同进程进行通信的机制。</p><p><br><br><br></p><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>socket，低级网络接口<br>该模块提供了对BSD socket的访问。</p><p>Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。<br>tcp需要建立连接，udp不需要建立连接，因此udp每次需要指定发送地址。</p><p>socket类型：</p><ul><li><p><code>socket.AF_UNIX</code><br>本机通信</p></li><li><p><code>socket.AF_INET</code><br>服务器间的网络通信</p></li><li><p><code>socket.AF_INET6</code><br>IPv6的服务器间的通信</p></li><li><p><code>socket.SOCK_STREAM</code><br>基于TCP的流式socket通信</p></li><li><p><code>socket.SOCK_DGRAM</code><br>基于UDP数据包的socket通信</p></li><li><p><code>socket.SOCK_RAM</code><br>原始套接字</p></li><li><p><code>socket.SOCK_SEQPACKET</code><br>可靠的连续数据包服务</p></li></ul><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#服务端socket函数：</span><br><span class="line">bind()    在AF_INET下，以tuple(host, port)的方式传入，如s.bind((host, port))</span><br><span class="line">listen()    可设置挂起的最大连接数</span><br><span class="line">accept()    接收tcp连接并返回(conn, address), conn是新的套接字对象, address是客户端地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#客户端socket函数：</span><br><span class="line">connect()</span><br><span class="line">connect_ex()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#公共socket函数</span><br><span class="line">#tcp</span><br><span class="line">recv()    接受TCP套接字的数据，数据以字符串形式返回，buffsize指定要接受的最大数据量</span><br><span class="line">send()</span><br><span class="line">sendall()    完整发送tcp数据</span><br><span class="line">#udp</span><br><span class="line">recvfrom()</span><br><span class="line">sendto()</span><br><span class="line"></span><br><span class="line">close()</span><br></pre></td></tr></table></figure><p><br></p><p>socket编程思想：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#Server-side</span><br><span class="line">1. 创建socket</span><br><span class="line">2. 监听</span><br><span class="line">3. 接收client请求</span><br><span class="line">4. 接收C端数据</span><br><span class="line">5. 关闭头街子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Client-side</span><br><span class="line">1. 创建socket</span><br><span class="line">2. 连接到S端</span><br><span class="line">3. 发送数据</span><br><span class="line">4. 关闭套接字</span><br></pre></td></tr></table></figure><p><br></p><p><strong>注意</strong><br>在Python3.x中，byte strings 和 unicodestrings是两种不同的类型，相互之间需要进行<code>decode()</code>和<code>encode()</code><br><code>send()</code>和<code>recv()</code>都是bytes类型，需要与str类型进行转换。</p><p><br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tcp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#S端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">host = <span class="string">'localhost'</span></span><br><span class="line">port = <span class="number">5678</span></span><br><span class="line">bf = <span class="number">1024</span></span><br><span class="line">maxConn = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">tcpS = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">tcpS.bind((host, port))</span><br><span class="line">tcpS.listen(maxConn)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Server start at &#123;host&#125;:&#123;port&#125;'</span>.format(host=host, port=port))</span><br><span class="line">print(<span class="string">'Waiting for connection...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    conn, addr = tcpS.accept()</span><br><span class="line">    print(<span class="string">'Connected by: &#123;addr&#125;'</span>.format(addr=addr))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        data = conn.recv(bf)</span><br><span class="line">        print(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">        conn.send(<span class="string">'server received message.'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    tcpS.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#C端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">host = <span class="string">'localhost'</span></span><br><span class="line">port = <span class="number">5678</span></span><br><span class="line">bf = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">tcpC = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">tcpC.connect((host, port))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    msg = input(<span class="string">'Please input message: \n'</span>)</span><br><span class="line">    tcpC.send(msg.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    data = tcpC.recv(bf)</span><br><span class="line">    print(data.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#udp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#S端</span></span><br><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"><span class="keyword">import</span> socket, datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">host = <span class="string">'localhost'</span></span><br><span class="line">port = <span class="number">5679</span></span><br><span class="line">bf = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">mongoPort = <span class="number">27017</span></span><br><span class="line">mongoUser = <span class="string">'zhang'</span></span><br><span class="line">mongoPw = <span class="string">'password'</span></span><br><span class="line">mongoDb = <span class="string">'zhang'</span></span><br><span class="line">mongoColl = <span class="string">'udpS'</span></span><br><span class="line"></span><br><span class="line">udpS = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">udpS.bind((host, port))</span><br><span class="line"></span><br><span class="line">collection = MongoClient(host=host, port=mongoPort, \</span><br><span class="line">             username=mongoUser, password=mongoPw).zhang.udpS</span><br><span class="line"></span><br><span class="line">print(<span class="string">'udp socket on &#123;host&#125;:&#123;port&#125;...'</span>.format(host=host, port=port))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    data, addr = udpS.recvfrom(bf)</span><br><span class="line">    print(<span class="string">'Received from &#123;addr&#125;'</span>.format(addr=addr))</span><br><span class="line">    print(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    msg = <span class="string">'Server has recived!\n'</span></span><br><span class="line">    udpS.sendto(msg.encode(<span class="string">'utf-8'</span>), addr)</span><br><span class="line"></span><br><span class="line">    dateTime = datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line">    post = &#123;</span><br><span class="line">      <span class="string">'author'</span>: <span class="string">'Server'</span>,</span><br><span class="line">      <span class="string">'date'</span>: dateTime,</span><br><span class="line">      <span class="string">'message'</span>: data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    collection.insert_one(post)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#C端</span></span><br><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"><span class="keyword">import</span> socket, datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">host = <span class="string">'localhost'</span></span><br><span class="line">port = <span class="number">5679</span></span><br><span class="line">bf = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">mongoPort = <span class="number">27017</span></span><br><span class="line">mongoUser = <span class="string">'zhang'</span></span><br><span class="line">mongoPw = <span class="string">'password'</span></span><br><span class="line">mongoDb = <span class="string">'zhang'</span></span><br><span class="line">mongoColl = <span class="string">'udpC'</span></span><br><span class="line"></span><br><span class="line">udpC = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">collection = MongoClient(host=host, port=mongoPort, \</span><br><span class="line">             username=mongoUser, password=mongoPw).zhang.udpC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    msg = str(input(<span class="string">'Please input message: \n'</span>))</span><br><span class="line">    udpC.sendto(msg.encode(<span class="string">'utf-8'</span>), (host, port))</span><br><span class="line">    data = udpC.recv(bf)</span><br><span class="line">    print(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    dateTime = datetime.datetime.now().strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line">    post = &#123;</span><br><span class="line">      <span class="string">'author'</span>: <span class="string">'Client'</span>,</span><br><span class="line">      <span class="string">'date'</span>: dateTime,</span><br><span class="line">      <span class="string">'message'</span>: data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    collection.insert_one(post)</span><br><span class="line"></span><br><span class="line">    udpC.close()</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="ssl"><a href="#ssl" class="headerlink" title="ssl"></a>ssl</h3><p>ssl，套接字对象的TLS/SSL封装<br>此模块提供了对网络套接字的传输层安全(通常称为安全套接字层)的加密和对等身份验证功能。</p><p><br><br><br></p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select，等待I/O完成<br>该模块提供对大多数操作系统中可用的<code>select()</code>和<code>poll()</code>函数的访问。</p><p><br><br><br></p><h3 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h3><p>selector，高级I/O复用<br>该模块基于<code>select()</code>模块构建，有序高级和高效的I/O复用。</p><p><br><br><br></p><h3 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h3><p>asyncio，异步I/O，事件循环，协同程序和任务<br>该模块提供了使用协同程序编写单线程并发代码的基础结构，在套接字和其它资源上多路复用I/O访问，运行网络客户端和服务器以及其它相关基元。</p><p><br><br><br></p><h3 id="asyncore"><a href="#asyncore" class="headerlink" title="asyncore"></a>asyncore</h3><p>asyncore，异步套接字处理器<br>该模块为编写异步套接字服务(客户端和服务端)提供了基本的基础结构。</p><p><br><br><br></p><h3 id="asynchat"><a href="#asynchat" class="headerlink" title="asynchat"></a>asynchat</h3><p>asynchat，异步套接字命令/响应处理器<br>该模块构建在asyncore之上，简化了异步客户端和服务端，并更容易处理其元素被任何字符串终止和长度可变的协议。</p><p><br><br><br></p><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>signal，为异步事件设置处理器<br>该模块提供了在Python中使用信号处理程序的机制。</p><p><br><br><br></p><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>mmap，内存映射文件支持<br>内存映射文件对象的行为与bytearray和文件对象类似。</p><p><br><br><br></p><h2 id="网络数据处理"><a href="#网络数据处理" class="headerlink" title="网络数据处理"></a>网络数据处理</h2><p>本章介绍的模块，支持处理常用网络数据格式。</p><p><br><br><br></p><h3 id="email"><a href="#email" class="headerlink" title="email"></a>email</h3><p>email，一个email和MIME处理包<br>该包是用于管理电子邮件信息的库，包含MIME和其它基于RFC 2822的消息文档。</p><p>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展，是一种标准化的方式来标识文档的性质和格式。浏览器通常使用MIME类型(而不是文件扩展名)来确定如何处理文档。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type/subtype</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">text/plain</span><br><span class="line">text/html</span><br><span class="line">image/jpeg</span><br><span class="line">image/png</span><br><span class="line">audio/mpeg</span><br><span class="line">audio/ogg</span><br><span class="line">audio/*</span><br><span class="line">video/mp4</span><br><span class="line">application/octet-stream</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p><br></p><h4 id="email-message"><a href="#email-message" class="headerlink" title="email.message"></a>email.message</h4><p>表示一个电子邮件信息</p><p><br></p><h4 id="email-parser"><a href="#email-parser" class="headerlink" title="email.parser"></a>email.parser</h4><p>解析电子邮件信息</p><p><br></p><h4 id="email-generator"><a href="#email-generator" class="headerlink" title="email.generator"></a>email.generator</h4><p>生成MIME文档</p><p><br></p><h4 id="email-policy"><a href="#email-policy" class="headerlink" title="email.policy"></a>email.policy</h4><p>政策对象</p><p><br></p><h4 id="email-headerregistry"><a href="#email-headerregistry" class="headerlink" title="email.headerregistry"></a>email.headerregistry</h4><p>自定义头对象</p><p><br></p><h4 id="email-contentmanager"><a href="#email-contentmanager" class="headerlink" title="email.contentmanager"></a>email.contentmanager</h4><p>管理MIME内容</p><p><br></p><h4 id="email-mime"><a href="#email-mime" class="headerlink" title="email.mime"></a>email.mime</h4><p>从抓挠中创建电子邮件和MIME对象。</p><p><br></p><h4 id="email-header"><a href="#email-header" class="headerlink" title="email.header"></a>email.header</h4><p>Internationalized headers</p><p><br></p><h4 id="email-charset"><a href="#email-charset" class="headerlink" title="email.charset"></a>email.charset</h4><p>表示字符集</p><p><br></p><h4 id="email-encoders"><a href="#email-encoders" class="headerlink" title="email.encoders"></a>email.encoders</h4><p>编码器</p><p><br></p><h4 id="email-errors"><a href="#email-errors" class="headerlink" title="email.errors"></a>email.errors</h4><p>异常和缺陷类</p><p><br></p><h4 id="email-utils"><a href="#email-utils" class="headerlink" title="email.utils"></a>email.utils</h4><p>各种各样的功能</p><p><br></p><h4 id="email-iterators"><a href="#email-iterators" class="headerlink" title="email.iterators"></a>email.iterators</h4><p>迭代器</p><p><br><br><br></p><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>json，JSON编码器和解码器<br>JSON(JavaScript Object Notation)，是一个受JavaScript对象语法启发的轻量级的数据交换格式。</p><p>json只能包含如下Python数据类型的值：</p><ul><li>字符串</li><li>整型</li><li>浮点数</li><li>布尔型</li><li>列表</li><li>字典</li><li>NoneType</li></ul><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">JSONDATA = &apos;&#123;&quot;name&quot;: &quot;zhang&quot;, &quot;age&quot;: 21, &quot;likeFootball&quot;: true&#125;</span><br><span class="line"></span><br><span class="line">loadData = json.loads(JSONDATA)</span><br><span class="line">dumpData = json.dumps(jsonData)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="mailcap"><a href="#mailcap" class="headerlink" title="mailcap"></a>mailcap</h3><p>mailcap，mailcap文件处理<br>mailcap文件用于配置感知MIME的应用程序(如邮件阅读器和Web浏览器)，如何对具有不同MIME类型的文件做出反应。</p><p><br><br><br></p><h3 id="mailbox"><a href="#mailbox" class="headerlink" title="mailbox"></a>mailbox</h3><p>mailbox，以各种格式操作邮箱<br>该模块定义了两个类: Mailbox和Message，用于访问和操作磁盘邮箱及其包含的邮件。</p><p><br><br><br></p><h3 id="mimetypes"><a href="#mimetypes" class="headerlink" title="mimetypes"></a>mimetypes</h3><p>mimetypes，将文件名映射到MIME类型<br>该模块在文件名或URL和MIME类型之间进行转换。</p><p><br><br><br></p><h3 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h3><p>base64，base16、base32，base64，base85数据编码<br>该模块提供了将二进制数据编码为可打印的ASCII字符，并将这些编码解码回二进制数据的函数。</p><p><br><br><br></p><h3 id="binhex"><a href="#binhex" class="headerlink" title="binhex"></a>binhex</h3><p>binhex，编码和解码binhex4文件</p><p><br><br><br></p><h3 id="binascii"><a href="#binascii" class="headerlink" title="binascii"></a>binascii</h3><p>binascii，在二进制和ASCII之间进行转换<br>该模块包含了许多方法，用于转换在二进制和各种ASCII编码的二进制表示之进行转换的方法。</p><p><br><br><br></p><h3 id="quopri"><a href="#quopri" class="headerlink" title="quopri"></a>quopri</h3><p>quopri，编码和解码MIME引用打印数据</p><p><br><br><br></p><h3 id="uu"><a href="#uu" class="headerlink" title="uu"></a>uu</h3><p>uu，编码和解码uuencode文件<br>该模块以uuencode格式对文件进行编码和解码，允许任意二进制数据仅通过ASCII连接进行传输。</p><p><br><br><br></p><h2 id="结构化标记处理工具"><a href="#结构化标记处理工具" class="headerlink" title="结构化标记处理工具"></a>结构化标记处理工具</h2><p>Python支持用以处理各种形式的结构化数据标记的模块。</p><ul><li>标准通用标记语言，SGML()</li><li>超文本标记语言，HTML</li><li>扩展标记语言，XML</li></ul><p><br><br><br></p><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><p>html，支持超文本标记语言<br>该模块定义了用以操作HTML的实用程序。</p><p><br><br><br></p><h3 id="html-parser"><a href="#html-parser" class="headerlink" title="html.parser"></a>html.parser</h3><p>html.parser，简单HTML和XHTML解析器<br>该模块提供了一个类，用来解析HTML和XHTML格式的文本文件的基础。</p><p><br><br><br></p><h3 id="html-entities"><a href="#html-entities" class="headerlink" title="html.entities"></a>html.entities</h3><p>html.entities，HTML一般实体的定义</p><p><br><br><br></p><h3 id="XML处理模块"><a href="#XML处理模块" class="headerlink" title="XML处理模块"></a>XML处理模块</h3><p>用于处理XML的Python接口被分组到xml包</p><p><br><br><br></p><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>本章介绍的模块，实现了网络协议并支持相关技术。</p><p><br><br><br></p><h3 id="webbrowser"><a href="#webbrowser" class="headerlink" title="webbrowser"></a>webbrowser</h3><p>webbrowser - Interfaces for launching and remotely controlling Web browsers.<br>webbrowser，便利的web浏览器控制器<br>该模块提供了一个高级interface，允许向用户显示基于web的文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import webbrowser</span><br><span class="line"></span><br><span class="line">webbrowser.open(&apos;https://www.baidu.com&apos;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="cgi"><a href="#cgi" class="headerlink" title="cgi"></a>cgi</h3><p>cgi，通用网关接口支持<br>CGI 脚本的支持模块；<br>该模块定义了许多用Python编写的CGI脚本的实用功能。</p><p><br><br><br></p><h3 id="cgitb"><a href="#cgitb" class="headerlink" title="cgitb"></a>cgitb</h3><p>cgitb，CGI脚本的追溯管理器<br>此模块为Python脚本提供了一个特殊的异常处理程序。</p><p><br><br><br></p><h3 id="wsgiref"><a href="#wsgiref" class="headerlink" title="wsgiref"></a>wsgiref</h3><p>wsgiref，WSGI功能和参考实现<br>Web服务器网关接口(WSGI)，是Web服务器软件和Web应用程序(Python编写)之间的标准接口。拥有标准接口可以轻松使用支持WSGI和多个不同Web服务器的应用程序。</p><p><br><br><br></p><h3 id="urllb"><a href="#urllb" class="headerlink" title="urllb"></a>urllb</h3><p><code>urllib</code>模块，处理URL</p><p><br><br><br></p><h3 id="urllib-request"><a href="#urllib-request" class="headerlink" title="urllib.request"></a>urllib.request</h3><p><code>urllib.request</code>模块，用于打开URL的可扩展库<br>该模块定义了函数和类，用于在复杂的世界中打开URL——基本和身份认证，重定向，cookie等</p><p><br><br><br></p><h3 id="urllib-response"><a href="#urllib-response" class="headerlink" title="urllib.response"></a>urllib.response</h3><p>urllib.response，响应类<br>该模块定义了向接口这样的最小文件的函数和类。</p><p><br><br><br></p><h3 id="urllib-parse"><a href="#urllib-parse" class="headerlink" title="urllib.parse"></a>urllib.parse</h3><p>urllib.parse，将URL解析为组件<br>此模块定义了一个标准接口，用于在组件中分解统一资源定位符(URL)字符串，将组件重新组合为URL，并将相对URL转换为基本URL的绝对URL。</p><p><br><br><br></p><h3 id="urlllib-error"><a href="#urlllib-error" class="headerlink" title="urlllib.error"></a>urlllib.error</h3><p>urllib.error，由urllib.request引起的异常类<br>该模块定义了由urllib.request引发的异常类。</p><p><br><br><br></p><h3 id="urllib-robotparser"><a href="#urllib-robotparser" class="headerlink" title="urllib.robotparser"></a>urllib.robotparser</h3><p>urllib.robotparser，解析robot.txt<br>此模块提供了一个<code>RobotFileParser</code>类，它回答了有关特定用户代理是否可以在发布robots.txt文件的Web站点上获取URL的问题。</p><p><br><br><br></p><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>http，HTTP模块</p><p><br><br><br></p><h3 id="http-client"><a href="#http-client" class="headerlink" title="http.client"></a>http.client</h3><p>http.client，HTTP协议客户端<br>该模块定义了实现HTTP和HTTPS协议客户端的类。</p><p><br><br><br></p><h3 id="ftplib"><a href="#ftplib" class="headerlink" title="ftplib"></a>ftplib</h3><p>ftplib，FTP协议客户端<br>此模块定义了FTP类和一些相关项。FTP类实现了FTP协议的客户端。</p><p><br><br><br></p><h3 id="poplib"><a href="#poplib" class="headerlink" title="poplib"></a>poplib</h3><p>poplib，POP3协议客户端<br>此模块定义了POP3类，它封装了一个到POP3服务器的连接，并实现了该协议。</p><p><br><br><br></p><h3 id="imaplib"><a href="#imaplib" class="headerlink" title="imaplib"></a>imaplib</h3><p>imaplib，IMAP4协议客户端<br>此模块定义了三个类，封装一个到IMAP服务器的连接，并实现IAP4客户端协议的大部分子集。</p><p><br><br><br></p><h3 id="nntplib"><a href="#nntplib" class="headerlink" title="nntplib"></a>nntplib</h3><p>nntplib，NNTP协议客户端<br>此模块定义了NNTP类，它实现网络新闻传输协议(NNTP)客户端。</p><p><br><br><br></p><h3 id="smtplib"><a href="#smtplib" class="headerlink" title="smtplib"></a>smtplib</h3><p><code>smtplib</code>模块，SMTP协议客户端<br>此模块定义了一个SMTP客户端会话对象，可使用SMTP守护进程发送邮件给任一互联网计算机。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"><span class="comment">#send = smtplib.STMP('smtp.example.com', port=xxx)</span></span><br><span class="line">send = smtplib.SMTP_SSL(‘smpt.exmail.qq.com’, <span class="number">465</span>)</span><br><span class="line"></span><br><span class="line">send.helo()</span><br><span class="line"><span class="comment">#(250, b'smtp.qq.com')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#登录需要提前设置邮箱授权码，使用授权码作为密码登录</span></span><br><span class="line">send.login(user, passed)</span><br><span class="line"></span><br><span class="line">send.sendmail(<span class="keyword">from</span>, to, message)</span><br><span class="line">send.quti()</span><br></pre></td></tr></table></figure><h3 id="smtpd"><a href="#smtpd" class="headerlink" title="smtpd"></a>smtpd</h3><p>smtpd，SMTP服务器<br>该模块提供了几个类来实现SMTP服务器。</p><p><br><br><br></p><h3 id="telnetlib"><a href="#telnetlib" class="headerlink" title="telnetlib"></a>telnetlib</h3><p>telnetlib，Telnet客户端<br>此模块提供了一个telnet类，用于执行Telnet协议。</p><p><br><br><br></p><h3 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h3><p>uuid，UUID对象<br>此模块提供了不可修改的UUID对象和uuid[1-5]函数。</p><p><br><br><br></p><h3 id="socketserver"><a href="#socketserver" class="headerlink" title="socketserver"></a>socketserver</h3><p>socketserver，一个网络服务器的框架<br>此模块简化了编写网络服务器的任务。</p><p><br><br><br></p><h3 id="http-server"><a href="#http-server" class="headerlink" title="http.server"></a>http.server</h3><p>http.server，HTTP服务器<br>此模块定义了类，用于实现HTTP服务器。</p><p><br><br><br></p><h3 id="http-cookie"><a href="#http-cookie" class="headerlink" title="http.cookie"></a>http.cookie</h3><p>http.cookie，HTTP状态管理<br>此模块定义了类，用于抽象cookie概念(HTTP状态管理机制)。</p><p><br><br><br></p><h3 id="http-cookiejar"><a href="#http-cookiejar" class="headerlink" title="http.cookiejar"></a>http.cookiejar</h3><p>http.cookiejar，HTTP客户端的cookie处理<br>此模块定义了类，用于自动处理HTTPcookie。</p><p><br><br><br></p><h3 id="xmlrpc"><a href="#xmlrpc" class="headerlink" title="xmlrpc"></a>xmlrpc</h3><p>xmlrpc，XMLRPC服务器和客户端模块<br>XML-RPC是一种远程过程调用方法，它使用通过HTTP传递的XML传输。</p><p><br><br><br></p><h3 id="xmlrpc-client"><a href="#xmlrpc-client" class="headerlink" title="xmlrpc.client"></a>xmlrpc.client</h3><p>xmlrpc.client，XML-RPC客户端访问</p><p><br><br><br></p><h3 id="xmlrpc-server"><a href="#xmlrpc-server" class="headerlink" title="xmlrpc.server"></a>xmlrpc.server</h3><p>xmlrpc.server，基本的XML-RPC服务器</p><p><br><br><br></p><h3 id="ipaddress"><a href="#ipaddress" class="headerlink" title="ipaddress"></a>ipaddress</h3><p>ipaddress，IPv4/IPv6操作库<br>此模块提供了创建、修改和操作IPv4和IPv6和网络的功能。</p><p><br><br><br><br><br></p><h2 id="多媒体服务"><a href="#多媒体服务" class="headerlink" title="多媒体服务"></a>多媒体服务</h2><p>本章介绍的模块，实现了用于多媒体应用的各种算法和接口。</p><p><br><br><br></p><h3 id="audioop"><a href="#audioop" class="headerlink" title="audioop"></a>audioop</h3><p>audioop，操作原始音频数据<br>此模块包含一些对声音片段有用的操作。</p><p><br><br><br></p><h3 id="aifc"><a href="#aifc" class="headerlink" title="aifc"></a>aifc</h3><p>aifc，读写AIFF和AIFC文件<br>此模块提供了对读写AIFF和AIFC文件的支持。</p><ul><li>AIFF is Audio Interchange File Format<ul><li>一种用于将数字音频样本存储在文件中的格式</li></ul></li><li>AIFC是一种更新的格式，包括压缩音频数据</li></ul><p><br><br><br></p><h3 id="sunau"><a href="#sunau" class="headerlink" title="sunau"></a>sunau</h3><p>sunau，读写Sun AU文件<br>此模块为Sun AU声音格式提供了一个便利的接口。</p><p><br><br><br></p><h3 id="wave"><a href="#wave" class="headerlink" title="wave"></a>wave</h3><p>wave，读写WAV文件<br>此模块为WAV声音格式提供了一个便利的接口。</p><p><br><br><br></p><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>chunk，读取IFF分块数据<br>此模块为读取使用EA IFF块的文件提供了接口。</p><p><br><br><br></p><h3 id="colorsys"><a href="#colorsys" class="headerlink" title="colorsys"></a>colorsys</h3><p>colorsys，颜色系统之家的转换<br>此模块定义了计算机显示器RGB和其它三个坐标系统：YIQ, HLS, HSV中使用的RGB颜色空间中表示的颜色之间的颜色值的双向转换。</p><p><br><br><br></p><h3 id="imghdr"><a href="#imghdr" class="headerlink" title="imghdr"></a>imghdr</h3><p>imghdr，确定图像类型<br>此模块确定文件或字节流中包含的图像类型。</p><p><br><br><br></p><h3 id="sndhdr"><a href="#sndhdr" class="headerlink" title="sndhdr"></a>sndhdr</h3><p>sndhdr，确定声音文件类型<br>此模块提供了实用功能，视图确定文件中的声音数据类型。</p><p><br><br><br></p><h3 id="ossaudiodev"><a href="#ossaudiodev" class="headerlink" title="ossaudiodev"></a>ossaudiodev</h3><p>ossaudiodev，访问与OSS兼容的音频设备<br>此模块允许你访问OSS(open sound system)音频接口。OSS是Linux和FreeBSD的标准音频接口。</p><p><br><br><br><br><br></p><h2 id="语言环境"><a href="#语言环境" class="headerlink" title="语言环境"></a>语言环境</h2><p>本章介绍的模块，可帮助你编写独立于语言和语言环境的软件。</p><p><br><br><br></p><h3 id="gettext"><a href="#gettext" class="headerlink" title="gettext"></a>gettext</h3><p>gettext，多语言国际化服务<br>此模块为你的Python模块和应用程序提供了国际化和本地化服务。</p><p><br><br><br></p><h3 id="locale"><a href="#locale" class="headerlink" title="locale"></a>locale</h3><p><code>locale</code>语言环境模块，打开对POSIX语言环境数据库和功能的访问。</p><p><br><br><br><br><br></p><h2 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h2><p>本章介绍的模块，是基本上决定程序结构的框架。</p><p><br><br><br></p><h3 id="turtle"><a href="#turtle" class="headerlink" title="turtle"></a>turtle</h3><p>turtle，乌龟图形<br>乌龟图形是向孩子们介绍编程的一种流行方式。</p><p><br><br><br></p><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><p>cmd，支持面向行的命令解释器<br>此类为编写面向行的命令解释器提供了一个简单的框架。</p><p><br><br><br></p><h3 id="shlex"><a href="#shlex" class="headerlink" title="shlex"></a>shlex</h3><p>shlex，简单的词法分析<br>此类可以容易地编写词法分析器，以获得类似Unix shell的简单语法。</p><p><br><br><br><br><br></p><h2 id="带有Tk的图形用户界面"><a href="#带有Tk的图形用户界面" class="headerlink" title="带有Tk的图形用户界面"></a>带有Tk的图形用户界面</h2><p>Tk/Tcl是Python的一部分。它提供了一个强大且独立于平台的窗口工具包，可供Python程序员使用的tkinter包。</p><ul><li>Tcl(Tool Command Language)，是一种脚本语言</li><li>Tk，是基于Tcl的图形界面开发工具箱</li></ul><p><br><br><br></p><h3 id="tkinter"><a href="#tkinter" class="headerlink" title="tkinter"></a>tkinter</h3><p>tkinter，与Tcl/Tk的Python接口<br>此包是到Tk GUI工具箱的标准Python接口。</p><p><br><br><br></p><h3 id="tkinter-ttk"><a href="#tkinter-ttk" class="headerlink" title="tkinter.ttk"></a>tkinter.ttk</h3><p>tkinter.ttk，Tk主题小部件<br>此模块提供了对Tk主题小部件集的访问。</p><p><br><br><br></p><h3 id="tkinter-tix"><a href="#tkinter-tix" class="headerlink" title="tkinter.tix"></a>tkinter.tix</h3><p>tkinter，Tk扩展小工具<br>此模块提供了一组额外的小工具。</p><p><br><br><br></p><h3 id="tkinter-scrolledtext"><a href="#tkinter-scrolledtext" class="headerlink" title="tkinter.scrolledtext"></a>tkinter.scrolledtext</h3><p>滚动(scrolled)文本工具<br>此模块提供了一个相同名称的类，它实现了基本的文本小部件，具有一个垂直滚动条，用于执行正确的事情。</p><p><br><br><br></p><h3 id="IDEL"><a href="#IDEL" class="headerlink" title="IDEL"></a>IDEL</h3><p>IDEL是Python的集成开发和学习环境。</p><p><br><br><br></p><h3 id="其它GUI包"><a href="#其它GUI包" class="headerlink" title="其它GUI包"></a>其它GUI包</h3><ul><li>PyGObject</li><li>PyGTK</li><li>PyQt</li><li>PySide</li><li>wxPython</li></ul><p><br><br><br><br><br></p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>本章介绍的模块可帮助你你编写软件。</p><p>开发高质量软件的一种方法是在开发过程中为每个函数编写测试，并在开发过程中频繁运行这些测试。</p><p><br><br><br></p><h3 id="typing"><a href="#typing" class="headerlink" title="typing"></a>typing</h3><p>typing，支持类型提示<br>此模块支持PEP 484指定的类型提示。</p><p><br><br><br></p><h3 id="pydoc"><a href="#pydoc" class="headerlink" title="pydoc"></a>pydoc</h3><p>pydoc，文档生成器和在线帮助系统<br>此模块从Python模块自动生成文档，文档可作为控制台上的文本页面呈现，提供个Web浏览器或保存到HTML文件。</p><p><br><br><br></p><h3 id="doctest"><a href="#doctest" class="headerlink" title="doctest"></a>doctest</h3><p><code>doctest</code>模块，测试交互式Python示例<br>此模块搜索类似于交互式Python会话的文本片段，然后执行这些会话以验证它们是否完全安装所示工作。</p><p><br><br><br></p><h3 id="unittest"><a href="#unittest" class="headerlink" title="unittest"></a>unittest</h3><p>unittest，单元测试框架</p><p><br><br><br></p><h3 id="2to3"><a href="#2to3" class="headerlink" title="2to3"></a>2to3</h3><p>2to3，自动翻译Python2-3代码<br>获取Python2源代码并应用一系列修复程序将其转换为有效的Python3代码。</p><p><br><br><br></p><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>test，用于Python的回归测试包<br>此包包含了Python的所有回归测试。</p><p><br><br><br></p><h3 id="test-support"><a href="#test-support" class="headerlink" title="test.support"></a>test.support</h3><p>test.support，Python测试套件功能</p><p><br><br><br><br><br></p><h2 id="调试和分析"><a href="#调试和分析" class="headerlink" title="调试和分析"></a>调试和分析</h2><ul><li>调试器(Debugger)使你能遍历代码，分析堆栈并设置断点</li><li>分析器(Profiler)运行代码并给出执行时间的详细分类，使你识别程序中的瓶颈</li></ul><p><br><br><br></p><h3 id="bdb"><a href="#bdb" class="headerlink" title="bdb"></a>bdb</h3><p>bdb，调试器框架<br>此模块处理基本的调试器功能。</p><p><br><br><br></p><h3 id="faulthandler"><a href="#faulthandler" class="headerlink" title="faulthandler"></a>faulthandler</h3><p>faulthandler，转储Python回溯(traceback)</p><p><br><br><br></p><h3 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h3><p>pdb，Python调试器<br>此模块为Python程序定义了一个交互式源代码调试器。</p><p><br><br><br></p><h3 id="Python分析器"><a href="#Python分析器" class="headerlink" title="Python分析器"></a>Python分析器</h3><p>cProfile和profile提供了Python程序的确定性分析。</p><p><br><br><br></p><h3 id="timeit"><a href="#timeit" class="headerlink" title="timeit"></a>timeit</h3><p><code>timeit</code>模块，测量小代码片段的执行时间<br>此模块提供了一个简单的方法类计算一小段Python代码的时间。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Timer(<span class="string">'a,b = b,a'</span>, <span class="string">'a=1; b=2'</span>).timeit()</span><br><span class="line"><span class="number">0.020318730967119336</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>trace，追踪Python语句的执行<br>此模块允许你追踪程序执行，生成带注释的语句覆盖列表，打印调用关系和在程序运行期间执行的函数列表。</p><p><br><br><br></p><h3 id="tracemalloc"><a href="#tracemalloc" class="headerlink" title="tracemalloc"></a>tracemalloc</h3><p>tracemalloc，追踪内存分配<br>此模块是一个追踪由Python分配的内存块的调试工具。</p><p><br><br><br><br><br></p><h2 id="软件打包和分发"><a href="#软件打包和分发" class="headerlink" title="软件打包和分发"></a>软件打包和分发</h2><p>这些库可帮助你发布和安装Python软件。这些模块被设计来与PyPi结合使用，但它们也可以与本地索引服务器一起使用，或根本不需要任何索引服务器。</p><p><br><br><br></p><h3 id="distutils"><a href="#distutils" class="headerlink" title="distutils"></a>distutils</h3><p>distutils，构建和安装Python模块<br>此软件包为构建和安装其它模块到Python提供支持。</p><p><br><br><br></p><h3 id="ensurepip"><a href="#ensurepip" class="headerlink" title="ensurepip"></a>ensurepip</h3><p>ensurepip，引导pip安装程序<br>此软件包支持将pip安装程序引导到现有的Python或虚拟环境中。</p><p><br><br><br></p><h3 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h3><p>venv，创建虚拟环境<br>此模块为创建轻量虚拟环境提供支持，可选地域系统目录隔离。</p><p><br><br><br></p><h3 id="zipapp"><a href="#zipapp" class="headerlink" title="zipapp"></a>zipapp</h3><p>zipapp，管理可执行的python zip归档<br>Python提供了管理创建包含Python代码的zip文件的工具。</p><p><br><br><br><br><br></p><h2 id="Python服务组件"><a href="#Python服务组件" class="headerlink" title="Python服务组件"></a>Python服务组件</h2><p>本章介绍的模块，提供了与Python解释器及其与环境交互相关的各种服务。</p><p><br><br><br></p><h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p><code>sys</code>模块，系统特定的参数和功能<br>此模块提供了对解释器使用或维护的一些变量以及与解释器交互的函数非访问。</p><p><strong>命令行参数</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.argv)</span><br></pre></td></tr></table></figure><p><strong>错误输出重定向和程序终止(termination)</strong><br><code>sys</code>模块还具有stdin, stdout, stderr属性。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stderr.write(<span class="string">'Warning, log file not found starting a new one\n'</span>)</span><br><span class="line">Warning, log file <span class="keyword">not</span> found starting a new one</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="sysconfig"><a href="#sysconfig" class="headerlink" title="sysconfig"></a>sysconfig</h3><p>sysconfig，提供对Python配置信息的访问<br>此模块提供对Python配置信息的访问，如安装路径列表和当前平台相关的配置变量。</p><p><br><br><br></p><h3 id="builtins"><a href="#builtins" class="headerlink" title="builtins"></a>builtins</h3><p>builtins，内建对象<br>此模块提供了对Python所有内置标识符的直接访问。例如，<code>builtins.open</code>是内建函数<code>open()</code>的全名。</p><p><br><br><br></p><h3 id="main"><a href="#main" class="headerlink" title="__main__"></a><code>__main__</code></h3><p><code>__main__</code>，顶级脚本环境<br><code>__main__</code>是顶级代码执行的范围的名称。从标准输入、脚本或交互式提示读取时，模块的<code>__name__</code>设置为等于<code>__main__</code></p><p><br><br><br></p><h3 id="warnings"><a href="#warnings" class="headerlink" title="warnings"></a>warnings</h3><p>warnings，警告控制<br>警告信息通常在有用的情况下发出，以提醒用户程序中的某些条件，该条件不能保证引发异常并终止程序。<br>Python程序员通过调用此模块中的<code>warn()</code>函数来发出警告。</p><p><br><br><br></p><h3 id="contextlib"><a href="#contextlib" class="headerlink" title="contextlib"></a>contextlib</h3><p>contextlib，with语句上下文实用程序<br>此模块为涉及with语句的常见任务提供使用程序。</p><p><br><br><br></p><h3 id="abc"><a href="#abc" class="headerlink" title="abc"></a>abc</h3><p>abc，抽象基类(Abstract Base Classes)<br>此模块提供了在Python中定义抽象基类的基础结构。</p><p><br><br><br></p><h3 id="atexit"><a href="#atexit" class="headerlink" title="atexit"></a>atexit</h3><p>atexit，退出处理程序<br>此模块定义了注册和注销清理函数的函数。</p><p><br><br><br></p><h3 id="traceback"><a href="#traceback" class="headerlink" title="traceback"></a>traceback</h3><p>traceback，打印或取回堆栈回溯<br>该模块提供了一个标准接口，用来提取、格式化和打印Python程序的堆栈追踪。</p><p><br><br><br></p><h3 id="future"><a href="#future" class="headerlink" title="__future__"></a><code>__future__</code></h3><p><code>__future__</code>，未来的声明定义</p><p><br><br><br></p><h3 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h3><p>gc，垃圾收集器接口(Garbage Collector interface)<br>此模块为可选的垃圾收集器提供了一个接口。</p><p><br><br><br></p><h3 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h3><p>inspect，检查活对象(Inspect live objects)<br>此模块提供了几个有用的功能来帮助获取有关活动对象的信息，如模块、类、函数、回溯、框架对象和代码对象。</p><p><br><br><br></p><h3 id="site"><a href="#site" class="headerlink" title="site"></a>site</h3><p>site，Site-specific configuration hook</p><p><br><br><br></p><h3 id="fpectl"><a href="#fpectl" class="headerlink" title="fpectl"></a>fpectl</h3><p>fpectl，浮点异常控制(Floating point exception control)</p><p><br><br><br><br><br></p><h2 id="自定义Python解释器"><a href="#自定义Python解释器" class="headerlink" title="自定义Python解释器"></a>自定义Python解释器</h2><p>本章介绍的模块，允许编写类似于Python的交互式解释器接口。</p><p><br><br><br></p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><p>code，解释器基本类<br>此模块提供了一些工具，来实现Python的read-eval-print循环。</p><p><br><br><br></p><h3 id="codeop"><a href="#codeop" class="headerlink" title="codeop"></a>codeop</h3><p>codeop，编译Python代码<br>此模块提供了实用程序，用于模拟Python read-eval-print循环，像code模块中做的那样</p><p><br><br><br><br><br></p><h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><p>本章介绍的模块，提供了导入其它Python模块和以自定义导入进程的hook的新方法。</p><p><br><br><br></p><h3 id="zipimport"><a href="#zipimport" class="headerlink" title="zipimport"></a>zipimport</h3><p>zipimport，从zip归档文件导入模块<br>此模块增加了从Zip格式的归档中导入Python模块和软件包的功能。<br>通常不需要明确使用zipimport模块，内置导入机制将自动使用zip归档文件的路径(sys.path)。</p><p><br><br><br></p><h3 id="pkgutil"><a href="#pkgutil" class="headerlink" title="pkgutil"></a>pkgutil</h3><p>pkgutil，包扩展程序<br>此模块为导入system提供实用程序，尤其是软件包的支持。</p><p><br><br><br></p><h3 id="modulefinder"><a href="#modulefinder" class="headerlink" title="modulefinder"></a>modulefinder</h3><p>modulefinder，查找脚本使用的模块<br>此模块可用于确定脚本导入的模块集。</p><p><br><br><br></p><h3 id="runpy"><a href="#runpy" class="headerlink" title="runpy"></a>runpy</h3><p>runpy，定位和执行Python模块<br>此模块用于定位和运行Python模块，而不必先导入它们。</p><p><br><br><br></p><h3 id="importlib"><a href="#importlib" class="headerlink" title="importlib"></a>importlib</h3><p>importlib，执行import<br>此软件包有两个目的：</p><ul><li>在Python源代码中提供import语句的实现(<code>__import__</code>函数)</li><li>实现import组件暴露在此软件包中，使用户更容易创建它们自己的定制对象参与导入过程</li></ul><p><br><br><br><br><br></p><h2 id="Python语言服务"><a href="#Python语言服务" class="headerlink" title="Python语言服务"></a>Python语言服务</h2><p>Python提供了许多模块来协助处理Python语言。包括：</p><ul><li>标记</li><li>解析</li><li>语法分析</li><li>字节码反汇编</li><li>…</li></ul><p><br><br><br></p><h3 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h3><p>parser，访问Python解析树<br>此模块为python内部解析器和字节码编译器提供了一个接口。</p><p><br><br><br></p><h3 id="ast"><a href="#ast" class="headerlink" title="ast"></a>ast</h3><p>ast，抽象语法树(Abstract Syntax Trees)<br>此模块帮助Python应用程序处理Python抽象语法的树。</p><p><br><br><br></p><h3 id="symtable"><a href="#symtable" class="headerlink" title="symtable"></a>symtable</h3><p>symtable，访问编译器的符号<br>符号表由AST编译器在字节码生成之前生成。</p><p><br><br><br></p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>symbol，用于Python解析的常量<br>该模块提供了，表示解析树内部节点数值的常量。</p><p><br><br><br></p><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>token，与Python解析树一起使用的常量<br>此模块提供了，表示解析树(终端令牌)的叶子节点数值的常量。</p><p><br><br><br></p><h3 id="keyword"><a href="#keyword" class="headerlink" title="keyword"></a>keyword</h3><p>keyword，测试Python关键字<br>此模块允许Python程序确定字符串是否为关键字。</p><p><br><br><br></p><h3 id="tokenize"><a href="#tokenize" class="headerlink" title="tokenize"></a>tokenize</h3><p>tokenize，用于Python源代码的令牌器<br>此模块为Python源代码提供了一个用Python实现的语言扫描器。</p><p><br><br><br></p><h3 id="tabnanny"><a href="#tabnanny" class="headerlink" title="tabnanny"></a>tabnanny</h3><p>tabnanny，检查不明确的缩进(Detection of ambiguous indentation)</p><p><br><br><br></p><h3 id="pyclbr"><a href="#pyclbr" class="headerlink" title="pyclbr"></a>pyclbr</h3><p>pyclbr，Python类浏览器支持<br>此模块可用于，确定有关模块中定义的类、方法和顶级函数的一些限制信息。</p><p><br><br><br></p><h3 id="py-compile"><a href="#py-compile" class="headerlink" title="py_compile"></a>py_compile</h3><p><code>py_compile</code>，编译Python源文件<br>此模块提供了功能，从源文件生成字节码文件，以及当模块源文件作为脚本被调用时使用。</p><p><br><br><br></p><h3 id="compileall"><a href="#compileall" class="headerlink" title="compileall"></a>compileall</h3><p>compileall，字节编译Python库<br>此模块提供了实用功能来支持安装Python库。</p><p><br><br><br></p><h3 id="dis"><a href="#dis" class="headerlink" title="dis"></a>dis</h3><p>dis，用于Python字节码的反汇编器<br>此模块支持通过反汇编来支持CPython字节码的分析。</p><p><br><br><br></p><h3 id="pickletools"><a href="#pickletools" class="headerlink" title="pickletools"></a>pickletools</h3><p>pickletools，pickle开发者的工具<br>此模块包含了各种常量，涉及到pickle模块的细节，一些关于实现的冗长的评论，一些用于分析pickle数据的有用函数。</p><p><br><br><br><br><br></p><h2 id="杂项服务"><a href="#杂项服务" class="headerlink" title="杂项服务"></a>杂项服务</h2><p>本章介绍的模块，提供了在所有Python版本中可用的杂项(miscellaneous)服务。</p><p><br><br><br></p><h3 id="formatter"><a href="#formatter" class="headerlink" title="formatter"></a>formatter</h3><p>formatter，通用输出格式<br>此模块支持两种接口定义，每种都有多种实现方式：</p><ul><li>格式化接口</li><li>格式化接口所需的写入接口</li></ul><p><br><br><br><br><br></p><h2 id="Windows特定服务"><a href="#Windows特定服务" class="headerlink" title="Windows特定服务"></a>Windows特定服务</h2><p>本章介绍的模块仅可在MS windows平台上可获取。</p><p><br><br><br></p><h3 id="msilib"><a href="#msilib" class="headerlink" title="msilib"></a>msilib</h3><p>msillib，读写微软安装程序文件<br>此模块支持创建Microsoft Installer (<code>.msi</code>) 文件。</p><p><br><br><br></p><h3 id="msvcrt"><a href="#msvcrt" class="headerlink" title="msvcrt"></a>msvcrt</h3><p>msvcrt，MS VC++运行时的有用例程<br>此函数可访问Windows平台上的一些有用功能。</p><p><br><br><br></p><h3 id="winreg"><a href="#winreg" class="headerlink" title="winreg"></a>winreg</h3><p>winreg，Windows注册表访问<br>此模块将Windows注册表的API暴露给Python。</p><p><br><br><br></p><h3 id="winsound"><a href="#winsound" class="headerlink" title="winsound"></a>winsound</h3><p>winsound，Windows的声音播放接口<br>此模块提供了对Windows平台提供的基本声音播放机器的访问。</p><p><br><br><br><br><br></p><h2 id="Unix特定服务"><a href="#Unix特定服务" class="headerlink" title="Unix特定服务"></a>Unix特定服务</h2><p>本章介绍的模块，提供了Unix操作系统(Unix-Like)特有的功能的接口。</p><p><br><br><br></p><h3 id="posix"><a href="#posix" class="headerlink" title="posix"></a>posix</h3><p>posix，最基本的POSIX系统调用<br>此模块提供了对由C标准和POSIX标准 标准化的操作系统功能的访问。</p><p><br><br><br></p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>pwd， The password database<br>此模块提供了对Unix用户账户和密码数据库的访问。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pwd</span><br><span class="line"></span><br><span class="line">pwd.getpwdnam(<span class="string">'zhang'</span>)</span><br><span class="line">pwd.struct_passwd(pw_name=<span class="string">'zhang'</span>, pw_passwd=<span class="string">'x'</span>, pw_uid=<span class="number">1000</span>, pw_gid=<span class="number">1000</span>, pw_gecos=<span class="string">'zhang'</span>, pw_dir=<span class="string">'/home/zhang'</span>, pw_shell=<span class="string">'/bin/bash'</span>)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="spwd"><a href="#spwd" class="headerlink" title="spwd"></a>spwd</h3><p>spwd，The shadow password database<br>此模块提供了对Unix shadow password database的访问。</p><p><br><br><br></p><h3 id="grp"><a href="#grp" class="headerlink" title="grp"></a>grp</h3><p>grp，The group database<br>此模块提供了对Unix group database的访问。</p><p><br><br><br></p><h3 id="crypt"><a href="#crypt" class="headerlink" title="crypt"></a>crypt</h3><p>crypt，Function to check Unix passwords<br>此模块实现crypt(3)例程的接口，该例程是基于修改的DES算法的单向散列函数。</p><p><br><br><br></p><h3 id="termios"><a href="#termios" class="headerlink" title="termios"></a>termios</h3><p>termios，POSIX风格的tty控件<br>此模块提供了一个接口，用于I/O控制的POSIX调用。</p><p><br><br><br></p><h3 id="tty"><a href="#tty" class="headerlink" title="tty"></a>tty</h3><p>tty，终端控制函数<br>此模块定义了将tty置入cbreak和raw模式的函数。</p><p><br><br><br></p><h3 id="pty"><a href="#pty" class="headerlink" title="pty"></a>pty</h3><p>pty，伪(Pseudo)终端程序<br>此模块定义了处理伪终端概念的操作： 启动另一个进程并以编程方式写入和读取其控制终端。</p><p><br><br><br></p><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><p>fcntl，The fcntl and ioctl system calls<br>此模块对文件描述符执行文件控制和I/O控制。</p><p><br><br><br></p><h3 id="pipes"><a href="#pipes" class="headerlink" title="pipes"></a>pipes</h3><p>pipes，shell pipelines的接口<br>此模块定义了一个类来抽象管道的概念——从一个文件到另一个文件的一系列转换器。</p><p><br><br><br></p><h3 id="resource"><a href="#resource" class="headerlink" title="resource"></a>resource</h3><p>resource，资源使用信息<br>此模块提供了测量和控制程序使用系统资源的基本机制。</p><p><br><br><br></p><h3 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h3><p>syslog，Unix syslog library routines<br>此模块为Unix系统日志库例程提供了一个接口。</p><p><br><br><br></p><hr><p><br></p><h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><p>基本上可将第三方库理解为开源库！</p><p><br></p><p>Awesome-Python: <a href="https://github.com/jobbole/awesome-python-cn" target="_blank" rel="noopener">https://github.com/jobbole/awesome-python-cn</a><br>PyPI: <a href="https://pypi.org/" target="_blank" rel="noopener">https://pypi.org/</a></p><p><br><br><br></p><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><ul><li>sh</li><li>Watchdog</li></ul><p><br><br><br></p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>PyMySQL</li><li>pymongo</li><li>redis</li></ul><p><br></p><h3 id="PyMySQL"><a href="#PyMySQL" class="headerlink" title="PyMySQL"></a>PyMySQL</h3><p>PyMySQL：<a href="https://pypi.org/project/PyMySQL/" target="_blank" rel="noopener">https://pypi.org/project/PyMySQL/</a></p><p><br></p><p><strong>首先创建数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`users`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_bin</span><br><span class="line">AUTO_INCREMENT=<span class="number">1</span> ;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>连接</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">connection = pymysql.connect(</span><br><span class="line">    host=<span class="string">'localhost'</span>,</span><br><span class="line">    user=<span class="string">'username'</span>,</span><br><span class="line">    password=<span class="string">'password'</span>,</span><br><span class="line">    port=<span class="number">3306</span>,</span><br><span class="line">    db=<span class="string">'DBname'</span>,</span><br><span class="line">    charset=<span class="string">'utf8'</span>,</span><br><span class="line">    cursorclass=pymysql.cursors.DictCursor)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">        sql = <span class="string">"INSERT INTO `users` (`email`, `password`) VALUES (%s, %s)"</span></span><br><span class="line">        cursor.execute(sql, (<span class="string">'webmaster@python.org'</span>, <span class="string">'very-secret'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#commit to save</span></span><br><span class="line">    connection.commit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">        sql = <span class="string">"SELECT `id`, `password` FROM `users` WHERE `email`=%s"</span></span><br><span class="line">        cursor.execute(sql, (<span class="string">'webmaster@python.org'</span>,))</span><br><span class="line">        result = cursor.fetchone()</span><br><span class="line">        print(result)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    connection.close()</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="pyMongo"><a href="#pyMongo" class="headerlink" title="pyMongo"></a>pyMongo</h3><p>pyMongo Docs: <a href="https://api.mongodb.com/python/current/" target="_blank" rel="noopener">https://api.mongodb.com/python/current/</a></p><p>pyMongo是一个用于使用MongoDB的工具的Python发行版，并且是从Python工作于MongoDB的推荐方式。</p><p><br></p><p><strong>依赖</strong></p><ul><li>mongodb</li><li>pyMongo</li></ul><p><br></p><p><strong>连接</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"></span><br><span class="line"><span class="comment">#host and port</span></span><br><span class="line">client = MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#url format</span></span><br><span class="line">client = MongoClient(<span class="string">'mongodb://localhost:27017'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#认证</span></span><br><span class="line">client = MongoClient(host=<span class="string">'localhost'</span>, port=<span class="number">27017</span>, username=<span class="string">'user'</span>, password=<span class="string">'pass'</span>)</span><br></pre></td></tr></table></figure><p><br></p><p><strong>获取数据库</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db = client.$&#123;database&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"></span><br><span class="line">db = client[<span class="string">'$&#123;database&#125;'</span>]</span><br></pre></td></tr></table></figure><p><br></p><p><strong>获取集合</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">collection = db.$&#123;collection&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">collection = db[<span class="string">'$&#123;collection&#125;'</span>]</span><br></pre></td></tr></table></figure><p><br></p><p><strong>文档</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">post = &#123;</span><br><span class="line">  <span class="string">'_id'</span>: <span class="string">'post01'</span>,</span><br><span class="line">  <span class="string">'author'</span>: <span class="string">'Zhang21'</span>,</span><br><span class="line">  <span class="string">'text'</span>: <span class="string">'My first post!'</span>,</span><br><span class="line">  <span class="string">'tags'</span>: [ <span class="string">'mongodb'</span>, <span class="string">'python'</span>, <span class="string">'pymongo'</span> ],</span><br><span class="line">  <span class="string">'date'</span>: datetime.datetime.now()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>插入文档</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新建集合</span></span><br><span class="line">$&#123;collection&#125; = db.posts</span><br><span class="line">$&#123;collection&#125;.insert_one(post)</span><br><span class="line"></span><br><span class="line"><span class="comment">#已有集合</span></span><br><span class="line">collection.insert_one(post)</span><br></pre></td></tr></table></figure><p><strong>批量插入</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">new_post = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">'_id'</span>: <span class="string">'post02'</span>,</span><br><span class="line">    <span class="string">'author'</span>: <span class="string">'Zhang02'</span>,</span><br><span class="line">    <span class="string">'text'</span>: <span class="string">'2nd post'</span>,</span><br><span class="line">    <span class="string">'tags'</span>: [<span class="string">'bulk'</span>, <span class="string">'insert'</span>],</span><br><span class="line">    <span class="string">'date'</span>: datetime.datetime.now()</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">'_id'</span>: <span class="string">'post03'</span>,</span><br><span class="line">    <span class="string">'author'</span>: <span class="string">'Zhang03'</span>,</span><br><span class="line">    <span class="string">'text'</span>: <span class="string">'3rd post'</span>,</span><br><span class="line">    <span class="string">'tags'</span>: [<span class="string">'bulk'</span>, <span class="string">'insert'</span>],</span><br><span class="line">    <span class="string">'date'</span>: datetime.datetime.now()</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">collection.insert_many(new_post)</span><br></pre></td></tr></table></figure><p><br></p><p><strong>获取文档</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">collection.find_one()</span><br><span class="line"></span><br><span class="line">collection.find_one(&#123; <span class="string">'_id'</span>: <span class="string">'post01'</span>&#125;)</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">collection.find_one(&#123;<span class="string">'author'</span>: <span class="string">'Zhang21'</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">pprint.pprint(collection.find_one(&#123; <span class="string">'_id'</span>: <span class="string">'post01'</span>&#125;))</span><br></pre></td></tr></table></figure><p><strong>查询多个文档</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> post <span class="keyword">in</span> collection.find():</span><br><span class="line">    pprint.pprint(post)</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">'_id'</span>: <span class="string">'post01'</span>,</span><br><span class="line"> <span class="string">'author'</span>: <span class="string">'Zhang21'</span>,</span><br><span class="line"> <span class="string">'date'</span>: datetime.datetime(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">372000</span>),</span><br><span class="line"> <span class="string">'tags'</span>: [<span class="string">'mongodb'</span>, <span class="string">'python'</span>, <span class="string">'pymongo'</span>],</span><br><span class="line"> <span class="string">'text'</span>: <span class="string">'My first post!'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: <span class="string">'post02'</span>,</span><br><span class="line"> <span class="string">'author'</span>: <span class="string">'Zhang02'</span>,</span><br><span class="line"> <span class="string">'date'</span>: datetime.datetime(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">47</span>, <span class="number">93000</span>),</span><br><span class="line"> <span class="string">'tags'</span>: [<span class="string">'bulk'</span>, <span class="string">'insert'</span>],</span><br><span class="line"> <span class="string">'text'</span>: <span class="string">'2nd post'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: <span class="string">'post03'</span>,</span><br><span class="line"> <span class="string">'author'</span>: <span class="string">'Zhang03'</span>,</span><br><span class="line"> <span class="string">'date'</span>: datetime.datetime(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">47</span>, <span class="number">93000</span>),</span><br><span class="line"> <span class="string">'tags'</span>: [<span class="string">'bulk'</span>, <span class="string">'insert'</span>],</span><br><span class="line"> <span class="string">'text'</span>: <span class="string">'3rd post'</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"><span class="keyword">for</span> post <span class="keyword">in</span> collection.find(&#123;<span class="string">'tags'</span>: [<span class="string">'bulk'</span>, <span class="string">'insert'</span>]&#125;):</span><br><span class="line">     pprint.pprint(post)</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">'_id'</span>: <span class="string">'post02'</span>,</span><br><span class="line"> <span class="string">'author'</span>: <span class="string">'Zhang02'</span>,</span><br><span class="line"> <span class="string">'date'</span>: datetime.datetime(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">47</span>, <span class="number">93000</span>),</span><br><span class="line"> <span class="string">'tags'</span>: [<span class="string">'bulk'</span>, <span class="string">'insert'</span>],</span><br><span class="line"> <span class="string">'text'</span>: <span class="string">'2nd post'</span>&#125;</span><br><span class="line">&#123;<span class="string">'_id'</span>: <span class="string">'post03'</span>,</span><br><span class="line"> <span class="string">'author'</span>: <span class="string">'Zhang03'</span>,</span><br><span class="line"> <span class="string">'date'</span>: datetime.datetime(<span class="number">2018</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">47</span>, <span class="number">93000</span>),</span><br><span class="line"> <span class="string">'tags'</span>: [<span class="string">'bulk'</span>, <span class="string">'insert'</span>],</span><br><span class="line"> <span class="string">'text'</span>: <span class="string">'3rd post'</span>&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>删除文档</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">collection.delete_one(&#123;<span class="string">"_id"</span> : <span class="string">"post01"</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除多个</span></span><br><span class="line">collection.delete_many(&#123;<span class="string">"_id"</span> : <span class="string">"post02"</span>, <span class="string">"_id"</span> : <span class="string">"post03"</span>&#125;)</span><br></pre></td></tr></table></figure><p><br></p><p><strong>计数</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">collection.count()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">collection.count(&#123;<span class="string">'tags'</span>: [<span class="string">'bulk'</span>, <span class="string">'insert'</span>]&#125;)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><br></p><p>**索引</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = db.profiles.create_index([(<span class="string">'user_id'</span>, pymongo.ASCENDING)],</span><br><span class="line">                                 unique=<span class="keyword">True</span>)</span><br><span class="line">sorted(list(db.profiles.index_information()))</span><br><span class="line">[<span class="string">u'_id_'</span>, <span class="string">u'user_id_1'</span>]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>The Python interface to the Redis key-value store.<br>redis模块: <a href="https://pypi.org/project/redis/" target="_blank" rel="noopener">https://pypi.org/project/redis/</a></p><p><br></p><p>redis模块提供两个类Redis和StrictRedis用于实现Redis的命令:</p><ul><li>redis.Strictredis(推荐)<br>StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">help(redis.StrictRedis)</span><br><span class="line"></span><br><span class="line">__init__(self, host=&apos;localhost&apos;, port=6379, db=0, password=None, socket_timeout=None, socket_connect_timeout=None, socket_keepalive=None, socket_keepalive_options=None, connection_pool=None, unix_socket_path=None, encoding=&apos;utf-8&apos;, encoding_errors=&apos;strict&apos;, charset=None, errors=None, decode_responses=False, retry_on_timeout=False, ssl=False, ssl_keyfile=None, ssl_certfile=None, ssl_cert_reqs=None, ssl_ca_certs=None, max_connections=None)</span><br></pre></td></tr></table></figure><ul><li>redis.Redis(不推荐)<br>Redis是StrictRedis的子类，用于向后兼容旧版本的redis模块</li></ul><p><br></p><p><strong>连接</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">r = redis.StrictRedis()</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">r = redis.StrictRedis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, password=<span class="string">'password'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#字符串操作</span></span><br><span class="line">r.set(<span class="string">'name'</span>, <span class="string">'Zhang21'</span>)</span><br><span class="line">r.get(<span class="string">'name'</span>)</span><br><span class="line">r.type(<span class="string">'name'</span>)</span><br><span class="line">r.delete(<span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#列表操作</span></span><br><span class="line">r.rpush(<span class="string">'LIST'</span>, <span class="string">'list-01'</span>, <span class="string">'list-02'</span>)</span><br><span class="line">r.type(<span class="string">'LIST'</span>)</span><br><span class="line">r.llen(<span class="string">'LIST'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#help(r.lrane)</span></span><br><span class="line"><span class="comment">#lrange(name, start, end)</span></span><br><span class="line">lrange(<span class="string">'LIST'</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#其它redis数据类型操作方法类同</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>Connection Pools</strong><br>假设Redis服务器与客户端分处在异地，虽然基于内存的Redis数据库有着超高的性能，但是底层的网络通信却占用了一次数据请求的大量时间，因为每次数据交互都需要先建立连接，假设一次数据交互总共用时30ms，超高性能的Redis数据库处理数据所花的时间可能不到1ms，也即是说前期的连接占用了29ms，连接池则可以实现在客户端建立多个链接并且不释放，当需要使用连接的时候通过一定的算法获取已经建立的连接，使用完了以后则还给连接池，这就免去了数据库连接所占用的时间。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#help(redis.ConnectionPool)</span></span><br><span class="line"></span><br><span class="line">pool = redis.ConnectionPool()</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, passeord=<span class="string">'password'</span>)</span><br><span class="line"></span><br><span class="line">r = redis.StrictRedis(connection_pool=pool)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Web抓取"><a href="#Web抓取" class="headerlink" title="Web抓取"></a>Web抓取</h2><ul><li>request</li><li>BeautifulSoup</li><li>selenium</li></ul><p><br><br><br></p><h3 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h3><p>从Internet上下载文件和网页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import requests, pprint</span><br><span class="line"></span><br><span class="line">#help(requests)</span><br><span class="line"></span><br><span class="line">r = request.get(&apos;https://www.baidu.com&apos;)</span><br><span class="line">r.status_code</span><br><span class="line">r.headers</span><br><span class="line">r.url</span><br><span class="line">r.text</span><br><span class="line">pprint.pprint(r.text)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="beautifulsoup"><a href="#beautifulsoup" class="headerlink" title="beautifulsoup"></a>beautifulsoup</h3><p>解析HTML</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install beautifulsoup4</span><br><span class="line"></span><br><span class="line">import bs4</span><br></pre></td></tr></table></figure><p>栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import requests, bs4</span><br><span class="line"></span><br><span class="line">r = request.get(&apos;https://www.baidu.com&apos;)</span><br><span class="line">soup = bs4.BeautifulSoup(r.text)</span><br><span class="line">type(soup)</span><br><span class="line"></span><br><span class="line">#soup.select()</span><br><span class="line">#soup.find()</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h3><p>启动并控制一个Web浏览器。selenium能够填写表单，并模拟鼠标在此浏览器找那个点击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.get(&apos;https://www.baidu.com&apos;)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="文档处理"><a href="#文档处理" class="headerlink" title="文档处理"></a>文档处理</h2><ul><li>openpyxl</li><li>PyPDF2</li><li>pytho-docx</li></ul><p><br><br><br></p><h3 id="openpyxl"><a href="#openpyxl" class="headerlink" title="openpyxl"></a>openpyxl</h3><p>openpyxl is a Python library to read/write Excel 2010 xlsx/xlsm/xltx/xltm files.</p><p><strong>关于Excel电子表格：</strong><br>一个Excel电子表格文档称为一个工作簿。一个工作簿保存在扩展名为<code>.xlsx</code>的文件中。每个工作簿可以包含多个表(工作表)。用户当前查看的表被称为活动表。<br>每个表有一些列(地址为从A开始的字母)，一些行(地址从1开始的数字)。在特定行和列的方格被称为单元格。单元格形成的网格和数据构成了表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pip3 install openpyxl</span><br><span class="line"></span><br><span class="line">import openpyxl</span><br><span class="line"></span><br><span class="line">workbook = openpyxl.load_workbook(&apos;/tmp/test.xlsx&apos;)</span><br><span class="line">type(workbook)</span><br><span class="line">#&lt;class &apos;openpyxl.workbook.workbook.Workbook&apos;&gt;</span><br><span class="line"></span><br><span class="line">workbook.get_sheet_names()</span><br><span class="line">#[&apos;Sheet1&apos;, &apos;Sheet2&apos;, &apos;Sheet3&apos;]</span><br><span class="line"></span><br><span class="line">sheet1 = workbook.get_sheet_by_name(&apos;Sheet1&apos;)</span><br><span class="line">type(sheet1)</span><br><span class="line"></span><br><span class="line">sheet1.title</span><br><span class="line">#&apos;Sheet1&apos;</span><br><span class="line"></span><br><span class="line">workbook.get_active_sheet()</span><br><span class="line">#&lt;Worksheet &quot;Sheet1&quot;&gt;</span><br><span class="line"></span><br><span class="line">sheet1[&apos;A1&apos;].value</span><br><span class="line">#&apos;1A&apos;</span><br><span class="line">sheet1[&apos;A1&apos;].row</span><br><span class="line">#1</span><br><span class="line">sheet1[&apos;A1&apos;].colume</span><br><span class="line">#A</span><br><span class="line"></span><br><span class="line">sheet1.cell(row=2, column=2).value</span><br><span class="line">#2B</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="PyPDF2"><a href="#PyPDF2" class="headerlink" title="PyPDF2"></a>PyPDF2</h3><p>PDF和Word文档是二进制文件，它们比文本文件要复制得多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pip3 install PyPDF2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import PyPDF2</span><br><span class="line"></span><br><span class="line">pdfFile = open(&apos;/tmp/test.pdf&apos;, &apos;rb&apos;)</span><br><span class="line">pdfReader = PyPDF2.pdfFileReader(pdfFile)</span><br><span class="line">pdfWriter = PyPDF2.pdfFileWriter()</span><br><span class="line"></span><br><span class="line">page = pdfReader.getPage()</span><br><span class="line">page.extractText()</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="python-docx"><a href="#python-docx" class="headerlink" title="python-docx"></a>python-docx</h3><p>利用python-docx模块，Python可创建和修改Word文档，它带有<code>.docx</code>文件扩展名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pip3 insntall python-docx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import docx</span><br><span class="line"></span><br><span class="line">doc = docx.Document(&apos;/tmp/test.docx&apos;)</span><br><span class="line">len(doc.paragraphs)</span><br><span class="line"></span><br><span class="line">#paragraphs和run属性</span><br><span class="line">doc.paragraphs[0].text</span><br><span class="line">doc.paragraphs[0].run[0].text</span><br><span class="line"></span><br><span class="line">#写入</span><br><span class="line">doc.add_paragraph(&apos;Add line01&apos;)</span><br><span class="line">doc.add_paragraph(&apos;Add line02&apos;).add_run(&apos;tail !&apos;)</span><br><span class="line">doc.save(&apos;/tmp/test.docx&apos;)</span><br><span class="line"></span><br><span class="line">#标题</span><br><span class="line">doc.add_heading(&apos;Header 0&apos;, 0)</span><br><span class="line">doc.add_heading(&apos;Header 4&apos;, 4)</span><br><span class="line"></span><br><span class="line">#分页</span><br><span class="line">doc.add_page_broke()</span><br><span class="line"></span><br><span class="line">#图像</span><br><span class="line">doc.add_picture(xxx)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><ul><li>pillow(PIL)</li></ul><p><br><br><br></p><h3 id="pillow"><a href="#pillow" class="headerlink" title="pillow"></a>pillow</h3><p>PIL - the Python Imaging Library.</p><p>请了解RGB和CMYK颜色方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pillow</span><br><span class="line"></span><br><span class="line">import PIL</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7x86_64&lt;/li&gt;
&lt;li&gt;Python3.5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python教程: &lt;a href=&quot;https://docs.python.org/3.5/tutorial/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.python.org/3.5/tutorial/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python词汇表: &lt;a href=&quot;https://docs.python.org/3.5/glossary.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.python.org/3.5/glossary.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python语言参考: &lt;a href=&quot;https://docs.python.org/3.5/reference/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.python.org/3.5/reference/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python HOWTOs: &lt;a href=&quot;https://docs.python.org/3.5/howto/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.python.org/3.5/howto/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python标准库: &lt;a href=&quot;https://docs.python.org/3.5/library/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.python.org/3.5/library/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PyPI: &lt;a href=&quot;https://pypi.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pypi.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Awesome-Python&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/vinta/awesome-python&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/vinta/awesome-python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jobbole/awesome-python-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/jobbole/awesome-python-cn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://zhang21.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://zhang21.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Elatic Stack</title>
    <link href="https://zhang21.github.io/2018/04/15/Elastic/"/>
    <id>https://zhang21.github.io/2018/04/15/Elastic/</id>
    <published>2018-04-15T14:08:11.000Z</published>
    <updated>2018-06-12T10:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>Elastic指南: <a href="https://www.elastic.co/guide/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/index.html</a></li><li>Elasticsearch文档: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></li><li>Logstash文档: <a href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/index.html</a></li><li>Kibana文档: <a href="https://www.elastic.co/guide/en/kibana/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/kibana/current/index.html</a></li><li>Filebeat文档: <a href="https://www.elastic.co/guide/en/beats/filebeat/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/index.html</a></li><li>Metricbeat文档: <a href="https://www.elastic.co/guide/en/beats/metricbeat/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/metricbeat/current/index.html</a></li><li>Lucence查询语法: <a href="https://wizardforcel.gitbooks.io/mastering-elasticsearch/content/chapter-1/114_README.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/mastering-elasticsearch/content/chapter-1/114_README.html</a></li></ul><p>环境：</p><ul><li>CentOS7.x86_64</li><li>Elastcisearch v6.2.3</li><li>Kibana v6.2.3</li><li>Logstash v6.2.3</li><li>Beats v6.2.3</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>开源的 Elastic Stack:<br>能够安全可靠地获取任何来源、任何格式的数据，并且能够实时地对数据进行搜索、分析和可视化。</p><p><br></p><p><img src="/images/ELK/ELK.jpg" alt="ELK流程图"></p><p><img src="/images/ELK/elk.png" alt="ELK流程图"></p><p><br></p><p>Elastic指的是<a href="https://www.elastic.co" target="_blank" rel="noopener">elastic</a>公司下的几款产品：</p><ul><li>Elasticsearch</li><li>Logstash</li><li>Kibana</li><li>Beats</li><li>X-Pack</li></ul><p><br><br><br></p><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ul><li>开放源码且自由使用</li><li>License: Apache License 2.0</li><li>GitHub: <a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch</a></li><li>Doc: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></li></ul><p><br></p><p>搜索、分析和存储您的数据。<br>Elasticsearch 是基于 JSON 的分布式搜索和分析引擎，专为实现水平扩展、高可用和管理便捷性而设计。<br>Elasticsearch 是一个分布式的 RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p><p>基于Lucene。Lucene是一套用于全文检索和搜寻的开放源码程式库，由Apache软件基金会支持和提供。<br>Lucene提供了一个简单却强大的应用程式介面，能够做全文索引和搜寻，在Java开发环境里Lucene是一个成熟的免费开放原始码工具；就其本身而论，Lucene是现在并且是这几年，最受欢迎的免费Java资讯检索程式库。</p><p><br><br><br></p><h2 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h2><ul><li>开放源码且自由使用</li><li>GitHub: <a href="https://github.com/elastic/logstash" target="_blank" rel="noopener">https://github.com/elastic/logstash</a></li><li>Doc: <a href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/index.html</a></li></ul><p><br></p><p>集中、转换和存储数据<br>Logstash 是动态数据收集管道，拥有可扩展的插件生态系统，能够与 Elasticsearch 产生强大的协同作用。<br>Logstash 是开源的服务器端数据处理管道，能够同时 从多个来源采集数据、转换数据，然后将数据发送到您最喜欢的 “存储库” 中。（我们的存储库当然是 Elasticsearch。）</p><p><br><br><br></p><h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><ul><li>开放源码且自由使用</li><li>GitHub: <a href="https://github.com/elastic/kibana" target="_blank" rel="noopener">https://github.com/elastic/kibana</a></li><li>Doc: <a href="https://www.elastic.co/guide/en/kibana/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/kibana/current/index.html</a></li></ul><p><br></p><p>实现数据可视化<br>Kibana 让您能够可视化 Elasticsearch 中的数据并操作 Elastic Stack，因此您可以在这里解开任何疑问：例如，为何会在凌晨 2:00 被传呼，雨水会对季度数据造成怎样的影响。</p><p><br><br><br></p><h2 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h2><ul><li>开放源码且自由使用</li><li>GitHub: <a href="https://github.com/elastic/beats" target="_blank" rel="noopener">https://github.com/elastic/beats</a></li><li>Doc: <a href="https://www.elastic.co/guide/en/beats/libbeat/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/libbeat/current/index.html</a></li></ul><p><br></p><p>Beats 是轻量型采集器的平台，从边缘机器向 Logstash 和 Elasticsearch 发送数据。<br>Beats 平台集合了多种单一用途数据采集器。这些采集器安装后可用作轻量型代理，从成百上千或成千上万台机器向 Logstash 或 Elasticsearch 发送数据。</p><p><br><br><br></p><h2 id="X-Pack"><a href="#X-Pack" class="headerlink" title="X-Pack"></a>X-Pack</h2><ul><li>Doc: <a href="https://www.elastic.co/guide/en/x-pack/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/x-pack/current/index.html</a></li></ul><p><br></p><p>一个程序包，带来丰富的可能性<br>单就其自身而言，Elastic Stack 就是一款值得考虑的强大工具。X-Pack 将诸多强大功能集合到一个单独的程序包中，更将它带上了一个新的层次。<br>X-Pack 是集成了多种便捷功能的单个插件 — security、alerting、monitoring、reporting、graph 探索和 machine learning — 您可以在 Elastic Stack 中放心地使用这些功能。</p><p><br><br><br></p><hr><p><br></p><h1 id="使用Docker"><a href="#使用Docker" class="headerlink" title="使用Docker"></a>使用Docker</h1><p>突然发觉可以使用docker运行centos7，然后在此容器中安装ELK及其它相关软件，然后重新构建一个镜像，之后如果对此镜像新增了其它软件，又可以再次构建一个新镜像。并且可以将镜像上传到我们的Hub中，简直是太方便了。</p><p><br></p><p><strong>在docker中运行centos7</strong></p><p>直接拉取的centos没有systemd的权限，需要在运行添加<code>docker run -id --privileged &lt;image-id&gt; /usr/sbin/init</code>选项。</p><p>或者使用Docker Hub上CentOS提供的支持systemd的Dockerfile来构建centos: <a href="https://hub.docker.com/_/centos/" target="_blank" rel="noopener">https://hub.docker.com/_/centos/</a><br>其实Dockfile就是有这条命令<code>CMD [&quot;/usr/sbin/init</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              e934aafc2206        2 weeks ago         199MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行docker</span></span><br><span class="line"><span class="comment">#此处如果没有/bin/bash的话，生成的container立马就停止了</span></span><br><span class="line"><span class="comment">#端口映射什么的后面再弄</span></span><br><span class="line">docker run -d -i &lt;image-id&gt; /bin/bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看容器</span></span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">27b10f5015be        e934aafc2206        <span class="string">"/bin/bash"</span>         About an hour ago   Up About an hour                        ecstatic_boyd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#进入docker</span></span><br><span class="line">docke <span class="built_in">exec</span> -it &lt;container-id&gt; /bin/bash</span><br><span class="line"><span class="comment">#当然，你也可以运行SSHD，通过端口映射，连接到docker内</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[root@27b10f5015be /]#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在docker中安装各类需要的软件了</span></span><br><span class="line"><span class="comment">#可能需要设置一下/etc/resolv.conf</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>将安装了各类软件的容器构建为一个新的镜像</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从运行的容器中重构镜像</span></span><br><span class="line"><span class="comment">#docker commit -m "centos7+elk" &lt;container-id&gt; user/repo:tag</span></span><br><span class="line">docker commit -m <span class="string">'centos7+elk'</span> 27b10f5015be zhang21/centos7:elk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看新镜像</span></span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">zhang21/centos7     elk                 0b22d93f7353        16 minutes ago      1.04GB</span><br><span class="line">centos              latest              e934aafc2206        2 weeks ago         199MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行新镜像</span></span><br><span class="line">docker run -id -p 80:80 9200:9200 &lt;image-id&gt; /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#此处遇到一个错，因为docker的网络是通过iptables来转发的，因此主机上不能关闭firewalld，不能无法启动容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进入新容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;container-id&gt; /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#此处无法使用systemctl，原因已写到前面</span></span><br><span class="line"><span class="comment">#Failed to get D-Bus connection: Operation not permitted</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#获得systemd权限启动</span></span><br><span class="line">docker run -id --privileged -p 80:80 &lt;image-id&gt; /usr/sbin/init</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;container-id&gt; /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动Nginx</span></span><br><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><p><br></p><p><strong>将新镜像上传到Hub</strong></p><p>我用的是Docker Hub免费版，当然线上的话可能是阿里云或腾讯云。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker login -u zhang21</span><br><span class="line"></span><br><span class="line">#上传镜像到我的Hub</span><br><span class="line">docker push zhang21/centos7:elk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#拉取镜像</span><br><span class="line">docker pull zhang21/centos7:elk</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装步骤：</p><ul><li>Elasticsearch</li><li>Kibana</li><li>Logstash</li><li>Install X-Pack into Elasticsearch</li><li>Install X-Pack into Kibana</li></ul><p><br></p><h2 id="安装ELKF"><a href="#安装ELKF" class="headerlink" title="安装ELKF"></a>安装ELKF</h2><p>需要依赖JDK（java），请先安装。<br>我是直接使用的RPM包安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#安装Java</span><br><span class="line">yum install java-1.8.0-openjdk-headless-1.8.0.161-0.b14.el7_4.x86_64 -y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#编写repo</span><br><span class="line">vim /etc/yum.repo.d/elk.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[elasticsearch-6.x]</span><br><span class="line">name=Elasticsearch repository for 6.x packages</span><br><span class="line">baseurl=https://artifacts.elastic.co/packages/6.x/yum</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line">enabled=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#安装</span><br><span class="line">yum install -y elasticsearch logstash kibana filebeat</span><br></pre></td></tr></table></figure><p><br></p><p><strong>由于elk默认将软件安装到<code>/usr/share/</code>下，因此我把它们的<code>bin</code>路径加入PATH。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/usr/share/elasticsearch/bin:/usr/share/kibana/bin:/usr/share/logstash/bin:/usr/share/elasticsearch/bin/x-pack:/usr/share/filebeat/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#执行</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p><br></p><p>ELKF使用RPM安装的布局说明：</p><ul><li>主目录<ul><li><code>/usr/share/elasticsearch</code></li><li><code>/usr/share/kibana</code></li><li><code>/usr/share/logstash</code></li><li><code>/usr/share/filebeat</code></li></ul></li><li>二进制文件<ul><li><code>/usr/share/elasticsearch/bin</code></li><li><code>/usr/share/kibana/bin</code></li><li><code>/usr/share/logstash/bin</code></li><li><code>/usr/share/filebeat/bin</code></li></ul></li><li>配置文件<ul><li><code>/etc/elastcisearch</code></li><li><code>/etc/kibana</code></li><li><code>/etc/logstash</code></li><li><code>/etc/filebeat</code></li></ul></li><li>环境变量<ul><li><code>/etc/sysconfig/elasticsearch</code></li></ul></li><li>插件<ul><li><code>/usr/share/elastcisearch/plugins</code></li><li><code>/usr/share/kibana/plugins</code></li></ul></li></ul><p><br><br><br></p><h2 id="安装X-Pack"><a href="#安装X-Pack" class="headerlink" title="安装X-Pack"></a>安装X-Pack</h2><p>安装X-Pack前，请先安装ELK。<br>请安装匹配版本的X-Pack。</p><ul><li>Install X-Pack on Elasticsearch</li><li>Install X-Pack on Kibana</li><li>Install X-Pack on Logstash</li></ul><p><br></p><p><img src="/images/ELK/InstallationFlow.jpg" alt="安装流程图"></p><p><br></p><p><strong>启用或禁用X-Pack功能</strong></p><p>有些功能默认开启，有些默认关闭。请在配置文件中查看详情。<br>添加某些功能可能导致软件无法启动，请注意查看日志。</p><p>在以下文件中配置它们：</p><ul><li><code>elasticsearch.yml</code></li><li><code>kibana.yml</code></li><li><code>logstash.yml</code></li><li><code>filebeat.yml</code></li></ul><p>X-Pack功能：</p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>xpack.graph.enabled</td><td>X-Pack图形功能</td></tr><tr><td>xpack.ml.enabled</td><td>X-Pack机器学习功能</td></tr><tr><td>xpack.monitoring.enabled</td><td>X-Pack监视功能</td></tr><tr><td>xpack.reporting.enabled</td><td>X-Pack报告功能</td></tr><tr><td>xpack.security.enabled</td><td>X-Pack安全功能</td></tr><tr><td>xpack.watcher.enabled</td><td>X-Pack观察器</td></tr></tbody></table><p><br></p><p><strong>在ELK中启动X-Pack monitoring功能</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#xpack.graph.enabled</span><br><span class="line">#xpack.ml.enabled</span><br><span class="line">#xpack.monitoring.enabled</span><br><span class="line">#xpack.reporting.enabled</span><br><span class="line">#xpack.security.enabled</span><br><span class="line">#xpack.watcher.enabled</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在Elasticsearch和kibana中禁用验证后，不用在logstash中输入，否则会报错。</span><br><span class="line">xpack.security.enabled: false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启用验证</span><br><span class="line">#具体可参考官方文档</span><br><span class="line"></span><br><span class="line">#在logstash.yml中配置xpack.monitoring</span><br><span class="line">xpack.monitoring.enabled: true</span><br><span class="line">#xpack.monitoring.elasticsearch.url: &quot;http://127.0.0.1:9200&quot;</span><br><span class="line">#xpack.monitoring.elasticsearch.username: logstash_system</span><br><span class="line">#xpack.monitoring.elasticsearch.password: logstash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在Filebeat中添加monitoring</span><br><span class="line">xpack.monitoring:</span><br><span class="line">  enabled: true</span><br><span class="line">  #elasticsearch:</span><br><span class="line">        #url: &quot;http://localhost:9200&quot;</span><br><span class="line">#usernaem: &quot;elastic&quot;</span><br><span class="line">#password: &quot;elastic&quot;</span><br></pre></td></tr></table></figure><p><br></p><p>安装：<br>建议使用密码！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#Elastcisearch安装X-Pack</span><br><span class="line">elasticsearch-plugin install x-pack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启动</span><br><span class="line">#9200, 9300端口</span><br><span class="line">#elasticsearch不能使用root启动，所以我把elastic用户修改为/bin/bash</span><br><span class="line">su elasticsearch</span><br><span class="line">elasticsearch -d</span><br><span class="line">#elasticsearch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#生成默认用户密码，此密码针对elastic和kibana用户</span><br><span class="line">#/usr/share/elasticsearch/bin/x-pack</span><br><span class="line">#将此加入PATH</span><br><span class="line">setup-passwords auto</span><br><span class="line"></span><br><span class="line">#或手动输入密码</span><br><span class="line">setup-passwords interactive</span><br><span class="line">elastic</span><br><span class="line">#elastic</span><br><span class="line">kibana</span><br><span class="line">#kibana</span><br><span class="line">logstash_system</span><br><span class="line">#logstash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Kibana安装X-Pack</span><br><span class="line">kibana-plugin install x-pack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#对kibana.yml添加用户和密码</span><br><span class="line">#此密码是前面默认生成的</span><br><span class="line">vim /etc/kibana/kibana.yml`</span><br><span class="line"></span><br><span class="line">elasticsearch.username: &quot;elastic&quot;</span><br><span class="line">elasticsearch.password:  &quot;elastic&quot;</span><br><span class="line">#修改监听地址</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line"></span><br><span class="line">logging.dest: /var/log/kibana/kibana.log</span><br><span class="line">#kibana日志默认是stdout</span><br><span class="line">#修改为/var/log/kibana/kibana.log</span><br><span class="line">mkdir /var/log/kibana</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启动kibana</span><br><span class="line">#5601端口</span><br><span class="line">#kibana可用root启动</span><br><span class="line">kibana</span><br><span class="line">#或</span><br><span class="line">systemctl start kibana</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Logstash安装X-Pack</span><br><span class="line">logstash-plugin install x-pack</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="启动ELK"><a href="#启动ELK" class="headerlink" title="启动ELK"></a>启动ELK</h2><p>建议给他们加上密码！<br>不知道为什么，我的ElasticStack都能用systemd来管理了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#最便捷</span><br><span class="line">systemctl start elasticsearch logstash filebeat metricbeat heartbeat packetbeat auditbeat</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#Elasticsearch</span><br><span class="line">su elasticsearch</span><br><span class="line">#elasticsearch，查看输出</span><br><span class="line">elasticsearch -d</span><br><span class="line">#kill -15 pid &amp;&amp; elasticsearch -d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Kibana</span><br><span class="line">kibana&amp;</span><br><span class="line">systemctl start kibana</span><br><span class="line">#kill -15 pid &amp;&amp; kibana&amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Logstash</span><br><span class="line">#logstash -f xxx.conf</span><br><span class="line">systemctl start logstash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Filebeat</span><br><span class="line">#filebeat -e -c filebeat.yml，查看输出信息</span><br><span class="line">systemctl start filebeat</span><br></pre></td></tr></table></figure><p><br></p><p><strong>启动时可能遇到的问题</strong></p><ol><li><p>can not run elasticsearch as root</p><ul><li>专门建立一个管理ELK的用户，切换到此用户后运行，注意修改ELK相关目录权限</li><li>或者修改ELK各自用户的/etc/passwd，切换到对应用户后运行。注意权限 – <code>su elasticsearch &amp;&amp; elasticsearch</code></li></ul></li><li><p>elasticsearch process is too low, increase to at least [65536]</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* soft nofile 655350</span><br><span class="line">* hard nofile 655350</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ulimit -a</span><br></pre></td></tr></table></figure><p><br></p><p><strong>访问elasticsearch</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ip:9200</span><br><span class="line">#此处访问是需要用户名和密码的</span><br><span class="line">#使用前面X-Pack生成的默认用户名和密码</span><br><span class="line"></span><br><span class="line">elastic elastic</span><br><span class="line">#登录之后便可看到node，cluster相关信息</span><br></pre></td></tr></table></figure><p><img src="/images/ELK/9200auth.png" alt="认证后相关信息"></p><p><br></p><p><strong>访问kibana</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#5601端口</span><br><span class="line">http://0.0.0.0:5601</span><br></pre></td></tr></table></figure><p><img src="/images/ELK/5601kibana.png" alt=""></p><p><br><br><br></p><h2 id="启用xpack注意事项"><a href="#启用xpack注意事项" class="headerlink" title="启用xpack注意事项"></a>启用xpack注意事项</h2><p>启用X-PACK后，请注意在kibana配置文件中认证Elasticsearch用户和密码，并且使用Elasticsearch的用户和密码登录Kibana的前端界面。</p><p>由于我使用kibana用户登录，导致很多地方访问Elasticsearch都没有权限。请注意。</p><p>这样使用Elasticsearch登录后，便可以之间在<code>Dev Tools</code>中通过REST API获取和更新相关信息，并且创建和管理相关用户和角色。</p><p><br><br><br></p><h2 id="安装Filebeat"><a href="#安装Filebeat" class="headerlink" title="安装Filebeat"></a>安装Filebeat</h2><p>由于前面我们添加了ELK-repo，所以这里我们可以直接安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum install -y filebeat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启X-Pack monitor</span></span><br><span class="line"><span class="comment">#默认关闭</span></span><br><span class="line">vim /etc/filebeat/filebeat.yml</span><br><span class="line"></span><br><span class="line">xpack.monitoring.enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="修改ELK-jvm内存大小"><a href="#修改ELK-jvm内存大小" class="headerlink" title="修改ELK jvm内存大小"></a>修改ELK jvm内存大小</h2><p>在此版本中，可直接在配置文件目录下的<code>jvm.options</code>里修改JVM 内存大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#最小</span><br><span class="line">-Xms</span><br><span class="line">#最大</span><br><span class="line">-Xmx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim /etc/elasticsearch/jvm.options</span><br><span class="line"></span><br><span class="line">-Xms4g</span><br><span class="line">-Xmx4g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#其它如此</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="与Nginx结合使用"><a href="#与Nginx结合使用" class="headerlink" title="与Nginx结合使用"></a>与Nginx结合使用</h1><p>将Kibana展现到Nginx上的话，便可以不对Kibana开放外网访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#安装Nginx</span><br><span class="line"></span><br><span class="line">vim /etc/yum.repo.d/nginx.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum install -y nginx  nginx-mod-stream</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#配置</span><br><span class="line">vim /etc/nginx/conf.d/kibana.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#可把IP换成kibana相应的域名</span><br><span class="line">#再将域名解析到此IP</span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 172.16.129.150;</span><br><span class="line"></span><br><span class="line">#Kibana</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:5601;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &apos;upgrade&apos;;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_cache_bypass $http_upgrade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>可能会遇到的问题</strong></p><ul><li>Nignx错误日志: Permission denied) while connecting to upstream</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /var/log/audit/audit.log | grep nginx | grep denied</span><br><span class="line"></span><br><span class="line">#后来判断是SELinux的问题</span><br><span class="line">getenforce</span><br><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改SELinux</span><br><span class="line">vim /etc/selinux/config</span><br><span class="line"></span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="Logstash文档"><a href="#Logstash文档" class="headerlink" title="Logstash文档"></a>Logstash文档</h1><p><br></p><p><img src="/images/ELK/basic_logstash_pipeline.png" alt="logstash流程图"></p><p><br></p><p>Logstash的pipeline有两个必须的元素：</p><ul><li>input<ul><li>消耗来自source的数据</li></ul></li><li>output<ul><li>将修改后的数据写入destination</li></ul></li></ul><p>以及一个可选元素：</p><ul><li>filter<ul><li>根据你的定义来修改数据</li></ul></li></ul><p><br><br><br></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Logstash是一个具有实时流水线(pipeling)功能的开源数据收集引擎。它可以动态统一来自不同source的数据，并将数据正常化的你的destination。</p><p>任何类型的事件都可以通过大量的输入、过滤和输出插件进行丰富和转换，通过本地编解码器进一步简化了摄取过程。</p><p><br><br><br></p><h3 id="Logstash的能量"><a href="#Logstash的能量" class="headerlink" title="Logstash的能量"></a>Logstash的能量</h3><p>具有强大的Elasticsearch和Kibana系统的水平可伸缩数据处理流水线。</p><p><img src="/images/ELK/logstash.png" alt=""></p><p><br><br><br></p><h4 id="Logstash喜欢的数据"><a href="#Logstash喜欢的数据" class="headerlink" title="Logstash喜欢的数据"></a>Logstash喜欢的数据</h4><p>所有数据来者不拒！</p><p><br></p><h4 id="Logs-and-Metrics"><a href="#Logs-and-Metrics" class="headerlink" title="Logs and Metrics"></a>Logs and Metrics</h4><ul><li>处理所有类型的日志数据<ul><li>Apache</li><li>Nginx</li><li>Syslog</li></ul></li><li>使用<strong>Filebeat</strong>享受互补的安全日志转发功能</li><li>从<code>Ganglia</code>, <code>JMx</code>, <code>NetFlow</code>和<code>TCP</code>,<code>UDP</code>收集<strong>metrics</strong></li></ul><p><br></p><h4 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h4><ul><li>将<code>http request</code>转换为<code>events</code><ul><li>分析Web服务</li><li>支持Webhook</li></ul></li><li>通过轮询<code>HTTP endpoint</code>创建事件<ul><li>通过Web API捕获健康状况、性能和其它类型的数据</li></ul></li></ul><p><br></p><h4 id="数据存储和流"><a href="#数据存储和流" class="headerlink" title="数据存储和流"></a>数据存储和流</h4><p>从你已经拥有的数据中发现更多价值。</p><p><br></p><h4 id="Sensors-and-IoT"><a href="#Sensors-and-IoT" class="headerlink" title="Sensors and IoT"></a>Sensors and IoT</h4><p>探索广泛的其它数据。</p><p><br><br><br></p><h3 id="轻松丰富一切"><a href="#轻松丰富一切" class="headerlink" title="轻松丰富一切"></a>轻松丰富一切</h3><p>在摄取过程中清理并转换数据，以便在index或output时立即获得实时信息。Logstash具有许多聚合和突变以及模式匹配，地理映射和动态查找功能。</p><ul><li><strong>Grok</strong>是Logstash filter的金刚钻，用于从非结构化数据中派生出结构化数据</li><li>通过解析来自IP的地理坐标，标准化提起复杂性，简单K-V对和CSV数据，并通过本地查找或Elasticsearch查询进一步丰富你的数据，从而扩展你的视野</li><li>编解码器通常用于缓解JSON和多行事件等常见事件结构的处理</li></ul><p><br><br><br></p><h3 id="选择你的储藏室"><a href="#选择你的储藏室" class="headerlink" title="选择你的储藏室"></a>选择你的储藏室</h3><p>将数据放在最重要的位置。通过存储，分析和对数据采取行动，解锁各种downstream分析和操作用例。</p><ul><li>Analysis<ul><li>Elasticsearch</li><li>Data stores(MongoDB, Redis)</li></ul></li><li>Archiving<ul><li>HDFS</li><li>S3</li></ul></li><li>Monitoring<ul><li>Nagios</li><li>Zabbix</li><li>Ganglia</li></ul></li><li>Alerting<ul><li>Watcher(Elasticsearch)</li><li>Email</li></ul></li></ul><p><br><br><br></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>安装，储藏，解析，汇聚多个Input/Output。</p><p><br><br><br></p><h3 id="储藏第一个事件"><a href="#储藏第一个事件" class="headerlink" title="储藏第一个事件"></a>储藏第一个事件</h3><p><strong>测试Logstash和运行一个基本的pipeline</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logstash -e &apos;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&apos;</span><br><span class="line"></span><br><span class="line">#等待启动，输入hello world</span><br><span class="line">#Logstash将时间戳和主机名添加到message</span><br><span class="line">#2018-04-13T08:17:51.702Z zhang22 helloworld</span><br></pre></td></tr></table></figure><p><br></p><p>启动logstsh时的一个问题： <code>WARNING: Could not find logstash.yml which is typically located in $LS_HOME/config or /etc/logstash</code></p><p>虽然通过RPM安装Logstash存在<code>/etc/logstash</code>文件，但是还是会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/logstash/bin</span><br><span class="line"></span><br><span class="line">ln -s /etc/logstash ./config</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="通过Logstash解析Logs"><a href="#通过Logstash解析Logs" class="headerlink" title="通过Logstash解析Logs"></a>通过Logstash解析Logs</h3><p>前面我们创建了一个基本的Logstash pipeline来测试Logstash，但真正处理logs的Logstash pipeline不会这么简单，它可能会有多个input, filter, output。</p><p>本节利用一个Filebeat，将Nginx Web Logs作为Logstash pipeline的input，解析这些logs中创建的特定命名字段，并将解析的数据写入Elasticsearch集群。</p><p><br></p><p><strong>配置Filebeat以发送Log Lines到Logstash</strong></p><p>在创建Logstash pipeline之前，你将配置Filebeat以发送Log lines到Logstash。Filebeat从服务器上的文件收集日志，并将这些日志转发给Logstash实例进行处理。<br>Filebeat专为可靠性和低延迟而设计。它占用的资源极少，<code>beats input</code>插件(默认安装)最大限度地减少了Logstash实例的资源需求。任何Beat框架编写的beat都可以讲事件数据发送到Logstash。</p><p>在你的<strong>data source</strong>主机上安装Filebeat。安装之后，配置<code>filebeat.yml</code>文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/filebeat/filebeat.yml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filebeat.prospectors:</span><br><span class="line">- type: log</span><br><span class="line">#需要处理的日志的路径，如Nginx</span><br><span class="line">  paths:</span><br><span class="line">  - /var/log/nginx/*.log</span><br><span class="line"></span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [&quot;localhost:5044&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#运行Filebeat</span><br><span class="line">Filebeat -e -c filebeat.yml -d &quot;publish&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Filebeat将会尝试连接到5044端口，在Logstash以一个活动的beats plugin开始前，不会有任何应答。</span><br></pre></td></tr></table></figure><p><br></p><p><strong>为Filebeat Input配置Logstash</strong></p><p>配置一个Logstash pipeline，使用beat input plugin接受来自beats的事件。<br>格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/logstash/conf.d</span><br><span class="line">vim ./first-pipeline.conf</span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#filter部分可选</span><br><span class="line">filter &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#实例</span><br><span class="line">input &#123;</span><br><span class="line">    beats &#123;</span><br><span class="line">    port =&gt; &quot;5044&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">stdout &#123;</span><br><span class="line">    codec =&gt; dubydebug</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#验证配置</span><br><span class="line">logstash -f first-pipe.conf --config.tst_and_exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#消息</span><br><span class="line">2018-04-17T14:15:46.187+0800    ERROR   pipeline/output.go:74   Failed to connect: dial tcp [::1]:5044: getsockopt: connection refused</span><br><span class="line">2018-04-17T14:15:46.607+0800    INFO    log/harvester.go:241    File is inactive: /var/log/nginx/access.log. Closing because close_inactive of 5m0s reached.</span><br><span class="line">2018-04-17T14:15:46.607+0800    INFO    log/harvester.go:241    File is inactive: /var/log/nginx/error.log. Closing because close_inactive of 5m0s reached.</span><br><span class="line">2018-04-17T14:15:46.923+0800    INFO    log/harvester.go:241    File is inactive: /var/log/secure-20180409. Closing because close_inactive of 5m0s reached.</span><br><span class="line">2018-04-17T14:15:51.096+0800    INFO    log/harvester.go:241    File is inactive: /var/log/secure-20180401. Closing because close_inactive of 5m0s reached.</span><br><span class="line">2018-04-17T14:15:52.687+0800    INFO    log/harvester.go:241    File is inactive: /var/log/secure-20180415. Closing because close_inactive of 5m0s reached.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启动Logstash</span><br><span class="line">#修改配置后可动态载入</span><br><span class="line">logstash -f first-pipe.conf --config.reload.automatic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#消息</span><br><span class="line">2018-04-17T14:18:41.542+0800    INFO    [monitoring]    log/log.go:124  Non-zero metrics in the last 30s        &#123;&quot;monitoring&quot;: &#123;&quot;metrics&quot;: &#123;&quot;beat&quot;:&#123;&quot;cpu&quot;:&#123;&quot;system&quot;:&#123;&quot;ticks&quot;:150,&quot;time&quot;:159&#125;,&quot;total&quot;:&#123;&quot;ticks&quot;:450,&quot;time&quot;:468,&quot;value&quot;:450&#125;,&quot;user&quot;:&#123;&quot;ticks&quot;:300,&quot;time&quot;:309&#125;&#125;,&quot;info&quot;:&#123;&quot;ephemeral_id&quot;:&quot;84cbf5cd-dfff-4391-9631-2b8e77329696&quot;,&quot;uptime&quot;:&#123;&quot;ms&quot;:480009&#125;&#125;,&quot;memstats&quot;:&#123;&quot;gc_next&quot;:11030992,&quot;memory_alloc&quot;:6588088,&quot;memory_total&quot;:40882600&#125;&#125;,&quot;filebeat&quot;:&#123;&quot;harvester&quot;:&#123;&quot;open_files&quot;:5,&quot;running&quot;:8&#125;&#125;,&quot;libbeat&quot;:&#123;&quot;config&quot;:&#123;&quot;module&quot;:&#123;&quot;running&quot;:2&#125;&#125;,&quot;pipeline&quot;:&#123;&quot;clients&quot;:8,&quot;events&quot;:&#123;&quot;active&quot;:4118&#125;&#125;&#125;,&quot;registrar&quot;:&#123;&quot;states&quot;:&#123;&quot;current&quot;:10&#125;&#125;,&quot;system&quot;:&#123;&quot;load&quot;:&#123;&quot;1&quot;:4.86,&quot;15&quot;:4.41,&quot;5&quot;:4.53,&quot;norm&quot;:&#123;&quot;1&quot;:2.43,&quot;15&quot;:2.205,&quot;5&quot;:2.265&#125;&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用Grok filter plugin解析Web Logs</strong></p><p>在某些时候，可能输出的日志信息的格式并不理想。你想要解析log以创建特定的命名字段。</p><p><code>grok</code>过滤插件使你能够将非结构化的日志数据解析为结构化和可查询的内容。<br>由于<code>grok</code>过滤器插件在传入的日志数据中查找模式，因此配置插件需要你作出关于如何识别你的用例。</p><p>你可以使用<code>%{COMBINEDAPACHELOG}</code> grok模式，它从如下模式的日志中构建行：</p><table><thead><tr><th>信息</th><th>Field Name</th></tr></thead><tbody><tr><td>IP Add</td><td>clientip</td></tr><tr><td>User ID</td><td>ident</td></tr><tr><td>User Auth</td><td>auth</td></tr><tr><td>timestamp</td><td>timestamp</td></tr><tr><td>HTTP Verb</td><td>verb</td></tr><tr><td>Request body</td><td>request</td></tr><tr><td>HTTP Status code</td><td>respone</td></tr><tr><td>Referer URL</td><td>referer</td></tr><tr><td>User agent</td><td>agent</td></tr></tbody></table><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vim first-pipline.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">beats &#123;</span><br><span class="line">    port =&gt; &quot;5044&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">grok &#123;</span><br><span class="line">    match =&gt; &#123;</span><br><span class="line">        &quot;message&quot; =&gt; &quot;%&#123;COMBINEDAPACHELOG&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">stdout &#123;</span><br><span class="line">    codec =&gt; rubydebug</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启动查看效果</span><br></pre></td></tr></table></figure><p><br></p><p><strong>通过Geoip过滤插件增强数据</strong></p><p>除了解析日志数据以获得更好的搜索外，过滤插件还可从现有的数据中后去补充信息。<br><code>geoip</code>插件查找IP地址，从IP地址获取地理位置信息，并将该位置信息添加到日志中。</p><p>配置Logstash实例来使用geoip过滤插件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vim first-pipeline.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">    beats &#123;</span><br><span class="line">        port =&gt; &quot;5044&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">        match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;COMBINEDAPACHELOG&#125;&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    geoip &#123;</span><br><span class="line">        source =&gt; &quot;clientip&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#重启服务</span><br></pre></td></tr></table></figure><p><br></p><p><strong>索引数据到Elasticsearch</strong></p><p>现在Web log已经被处理为指定的字段，现在Logstash pipeline便可以索引数据到一个Elasticsearch集群中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vim first-pipeline.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">    beats &#123;</span><br><span class="line">        port =&gt; &quot;5044&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">        match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;COMBINEDAPACHELOG&#125;&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    geoip &#123;</span><br><span class="line">        source =&gt; &quot;clientip&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [ &quot;localhost:9200&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#重启服务</span><br></pre></td></tr></table></figure><p><strong>验证：</strong></p><p>这里遇到一个错误：</p><ul><li><code>index_not_found_exception</code></li></ul><p>这里要将<code>logstash-$DATE</code>反映索引的实际名称，也就是在通过下面的命令得到的<code>logstash-2018.04.13</code>。把我坑惨了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;localhost:9200/logstash-$DATE/_search?pretty&amp;q=response=200&apos;</span><br><span class="line"></span><br><span class="line">#索引名称使用的日期基于UTC，而不是Logstash正在运行的timezone</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看可用索引列表</span><br><span class="line">curl &apos;localhost:9200/_cat/indices?v&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">health status index                           uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   logstash-2018.04.13             dRW2veUgS2ObZmP3lepqsQ   5   1        154            0    266.6kb        266.6kb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -XGET &apos;localhost:9200/logstash-2018.04.13/_search?pretty&amp;q=response=200&apos;</span><br></pre></td></tr></table></figure><p><img src="/images/ELK/logstash-20180413.png" alt="访问图"></p><p><br></p><p>Kibana中的可视化效果：</p><p><img src="/images/ELK/kibana-20180413.png" alt=""></p><p><br><br><br></p><h3 id="拼接多个输入和输出插件"><a href="#拼接多个输入和输出插件" class="headerlink" title="拼接多个输入和输出插件"></a>拼接多个输入和输出插件</h3><p>你需要管理的信息通常来自多个不同的source，并且可能需要多个不同的destination来存储数据。Lostash pipeline可以使用多个输入和输出插件来处理这些需求。</p><p><br></p><p>官方文档中使用Twitter and Filebeat这两者作为Logstash input，并将信息输出到Elasticsearch和file。</p><ul><li>配置Logstash实例使用Filebeat input plugin</li><li>配置Logstash实例写入Elasticsearch多节点(cluster)</li><li>配置Logstash pipeline将数据写入file</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#配置Filebeat发送Log Line到Logstash</span><br><span class="line">vim /etc/filebeat/filebeat.yml</span><br><span class="line"></span><br><span class="line">filebeat.prospectors:</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/*.log</span><br><span class="line">  fields:</span><br><span class="line">    type: syslog</span><br><span class="line"></span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [&quot;localhost:5044&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">########################</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cd /etc/logstash/conf.d</span><br><span class="line"></span><br><span class="line">vim 2nd-pipeline.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">twitter &#123;</span><br><span class="line">        consumer_key =&gt; &quot;enter_your_consumer_key_here&quot;</span><br><span class="line">        consumer_secret =&gt; &quot;enter_your_secret_here&quot;</span><br><span class="line">        keywords =&gt; [&quot;cloud&quot;]</span><br><span class="line">        oauth_token =&gt; &quot;enter_your_access_token_here&quot;</span><br><span class="line">        oauth_token_secret =&gt; &quot;enter_your_access_token_secret_here&quot;</span><br><span class="line">    &#125;</span><br><span class="line">beats &#123;</span><br><span class="line">    prot =&gt; &quot;5044&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [&quot;hosts1:port1&quot;, &quot;host2:port2&quot;...]</span><br><span class="line">    &#125;</span><br><span class="line">    file &#123;</span><br><span class="line">    path =&gt; &quot;/path/to/target/file&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#重启服务</span><br><span class="line">#测试，Replace $DATE with the current date, in YYYY.MM.DD format.</span><br><span class="line">curl -XGET &apos;localhost:9200/logstash-$DATE/_search?pretty&amp;q=fields.type:syslog&apos;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入插件可以使特定的事件源由Logstash读取。</p><p>可用的输入插件：<br>我只列出了常见的，具体请参考: <a href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/input-plugins.html</a></p><table><thead><tr><th>插件</th><th>描述</th></tr></thead><tbody><tr><td>beats</td><td>从Elastic框架接收事件</td></tr><tr><td>couchdb_changes</td><td>从CouchDB的<code>_changes</code>URI流式传输事件</td></tr><tr><td>dead_letter_queue</td><td>从Logstash的dead letter queue读取事件</td></tr><tr><td>elasticsearch</td><td>从Elasticsearch集群中读取查询结果</td></tr><tr><td>exec</td><td>抓取shell命令的输出作为事件</td></tr><tr><td>file</td><td>来自文件的流事件</td></tr><tr><td>github</td><td>从GitHub webhook读取事件</td></tr><tr><td>heartbeat</td><td>为测试生成心跳事件</td></tr><tr><td>http</td><td>通过HTTP/HTTPS接收事件</td></tr><tr><td>http_poller</td><td>解码HTTP API输出为事件</td></tr><tr><td>imap</td><td>从IMAP服务器读取邮件</td></tr><tr><td>jmx</td><td>通过JVM从java程序检索标准</td></tr><tr><td>kafka</td><td>从kafka中读取事件</td></tr><tr><td>log4j</td><td>通过TCP socket从Log4j对象读取事件</td></tr><tr><td>pipe</td><td>从长时间运行的命令管道中获取流事件</td></tr><tr><td>rabbitmq</td><td>从Redis实例读取事件</td></tr><tr><td>sqlite</td><td>基于SQLite数据库中的行创建事件</td></tr><tr><td>stdin</td><td>从标准输入中读取事件</td></tr><tr><td>syslog</td><td>读取系统日志作为事件</td></tr><tr><td>tcp</td><td>从TCP socket读取事件</td></tr><tr><td>udp</td><td>从UDP读取事件</td></tr><tr><td>unix</td><td>通过Unix socket读取事件</td></tr><tr><td>websocket</td><td>从一个websocket读取事件</td></tr></tbody></table><p><br></p><p><strong>input filter通用选项: </strong></p><table><thead><tr><th>Setting</th><th>Input type</th><th>Required</th></tr></thead><tbody><tr><td>add_field</td><td>hash</td><td>No</td></tr><tr><td>codec</td><td>codec</td><td>No</td></tr><tr><td>enable_metric</td><td>boolean</td><td>No</td></tr><tr><td>id</td><td>string</td><td>No</td></tr><tr><td>tags</td><td>array</td><td>No</td></tr><tr><td>type</td><td>string</td><td>No</td></tr></tbody></table><ul><li><p><code>add_field</code><br>添加一个字段到一个事件，默认值为<code>{}</code></p></li><li><p><code>codec</code><br>用于输入数据的编解码器。默认值是<code>plain</code></p></li><li><p><code>enable_metric</code><br>为特定插件实例禁用或启用度量标准日志记录，默认值为<code>true</code></p></li><li><p><code>id</code><br>为插件配置添加一个唯一的ID，如果未指定，Logstash会自动生成一个</p></li><li><p><code>tags</code><br>为事件添加任意数量的任意标签</p></li><li><p><code>type</code><br>为所有input处理的事件添加一个<code>type</code></p></li></ul><p><br><br><br></p><h3 id="beats"><a href="#beats" class="headerlink" title="beats"></a>beats</h3><p>此插件使Logstash能够从Elasticsearch框架中接收事件。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; &quot;localhost:9200&quot;</span><br><span class="line">#hosts =&gt; [&quot;hosts1&quot;, &quot;hosts2&quot;, ...]</span><br><span class="line">    manage_template =&gt; false</span><br><span class="line">    index =&gt; &quot;%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    document_type =&gt; &quot;%&#123;[@metadata][type]&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Beats Input配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>cipher_suites</td><td>array</td><td>No</td></tr><tr><td>client_inactivity_timeout</td><td>number</td><td>No</td></tr><tr><td>host</td><td>string</td><td>No</td></tr><tr><td>include_codec_tag</td><td>boolean</td><td>No</td></tr><tr><td>port</td><td>number</td><td>Yes</td></tr><tr><td>ssl</td><td>boolean</td><td>No</td></tr><tr><td>ssl_certificate</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>ssl_certificate_authorities</td><td>array</td><td>No</td></tr><tr><td>ssl_handshake_timeout</td><td>number</td><td>No</td></tr><tr><td>ssl_key</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>ssl_key_passphrase</td><td>password</td><td>No</td></tr><tr><td>ssl_verify_mode</td><td>string, one of [none, peer,force_peer]</td><td>No</td></tr><tr><td>tls_max_version</td><td>number</td><td>No</td></tr><tr><td>tls_min_version</td><td>number</td><td>No</td></tr></tbody></table><p><br><br><br></p><h3 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h3><p><strong>Elasticsearch Input配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>ca_file</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>docinfo</td><td>boolean</td><td>No</td></tr><tr><td>docinfo_fields</td><td>array</td><td>No</td></tr><tr><td>docinfo_target</td><td>string</td><td>No</td></tr><tr><td>hosts</td><td>array</td><td>No</td></tr><tr><td>index</td><td>string</td><td>No</td></tr><tr><td>password</td><td>password</td><td>No</td></tr><tr><td>query</td><td>string</td><td>No</td></tr><tr><td>schedule</td><td>string</td><td>No</td></tr><tr><td>scroll</td><td>string</td><td>No</td></tr><tr><td>size</td><td>number</td><td>No</td></tr><tr><td>ssl</td><td>boolean</td><td>No</td></tr><tr><td>user</td><td>string</td><td>No</td></tr></tbody></table><p><br></p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; &quot;es.production.mysite.org&quot;</span><br><span class="line">    index =&gt; &quot;mydata-2018.09.*&quot;</span><br><span class="line">    query =&gt; &apos;&#123; &quot;query&quot;: &#123; &quot;query_string&quot;: &#123; &quot;query&quot;: &quot;*&quot; &#125; &#125; &#125;&apos;</span><br><span class="line">    size =&gt; 500</span><br><span class="line">    scroll =&gt; &quot;5m&quot;</span><br><span class="line">    docinfo =&gt; true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    index =&gt; &quot;copy-of-production.%&#123;[@metadata][_index]&#125;&quot;</span><br><span class="line">    document_type =&gt; &quot;%&#123;[@metadata][_type]&#125;&quot;</span><br><span class="line">    document_id =&gt; &quot;%&#123;[@metadata][_id]&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>定期运行shell命令，并抓取整个输出为事件。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  exec &#123;</span><br><span class="line">    command =&gt; &quot;ls&quot;</span><br><span class="line">    interval =&gt; 30</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>exec Input配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>command</td><td>string</td><td>Yes</td></tr><tr><td>interval</td><td>number</td><td>No</td></tr><tr><td>schedule</td><td>string</td><td>No</td></tr></tbody></table><p>此调度表示方法如同Linux中定时任务<code>* 5 * 1-3 *</code>。</p><p><br><br><br></p><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>从文件读取流事件。</p><p><strong>file input配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>close_older</td><td>number</td><td>No</td></tr><tr><td>delimiter</td><td>string</td><td>No</td></tr><tr><td>discover_interval</td><td>number</td><td>No</td></tr><tr><td>exclude</td><td>array</td><td>No</td></tr><tr><td>ignore_older</td><td>number</td><td>No</td></tr><tr><td>max_open_files</td><td>number</td><td>No</td></tr><tr><td>path</td><td>array</td><td>Yes</td></tr><tr><td>sincedb_path</td><td>string</td><td>No</td></tr><tr><td>sincedb_write_interval</td><td>number</td><td>No</td></tr><tr><td>start_position</td><td>string, one of [“beginning”, “end”]</td><td>No</td></tr><tr><td>stat_interval</td><td>number</td><td>No</td></tr></tbody></table><p><br><br><br></p><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p><strong>github input配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>drop_invalid</td><td>boolean</td><td>No</td></tr><tr><td>ip</td><td>string</td><td>No</td></tr><tr><td>port</td><td>number</td><td>Yes</td></tr><tr><td>secret_token</td><td>string</td><td>No</td></tr></tbody></table><p><br><br><br></p><h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-kafka.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-kafka.html</a></p><p><br><br><br></p><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>从redis实例读取事件，它支持redis的channel和list类型。</p><p><strong>redis input配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>batch_count</td><td>number</td><td>No</td></tr><tr><td>data_type</td><td>string, one of [list,channel,pattern_channel]</td><td>Yes</td></tr><tr><td>db</td><td>number</td><td>No</td></tr><tr><td>host</td><td>string</td><td>No</td></tr><tr><td>path</td><td>string</td><td>No</td></tr><tr><td>key</td><td>string</td><td>Yes</td></tr><tr><td>password</td><td>password</td><td>No</td></tr><tr><td>port</td><td>number</td><td>No</td></tr><tr><td>ssl</td><td>boolean</td><td>No</td></tr><tr><td>threads</td><td>number</td><td>No</td></tr><tr><td>timeout</td><td>number</td><td>No</td></tr></tbody></table><p><br><br><br></p><h3 id="sqlite"><a href="#sqlite" class="headerlink" title="sqlite"></a>sqlite</h3><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  sqlite &#123;</span><br><span class="line">    path =&gt; &quot;/tmp/example.db&quot;</span><br><span class="line">    type =&gt; weblogs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;</span><br><span class="line">    debug =&gt; true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sqlite input配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>batch</td><td>number</td><td>No</td></tr><tr><td>exclude_tables</td><td>array</td><td>No</td></tr><tr><td>path</td><td>string</td><td>Yes</td></tr></tbody></table><p><br><br><br></p><h3 id="stdin"><a href="#stdin" class="headerlink" title="stdin"></a>stdin</h3><p><br><br><br></p><h3 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h3><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  syslog &#123;</span><br><span class="line">    port =&gt; 12345</span><br><span class="line">    codec =&gt; cef</span><br><span class="line">    syslog_field =&gt; &quot;syslog&quot;</span><br><span class="line">    grok_pattern =&gt; &quot;&lt;%&#123;POSINT:priority&#125;&gt;%&#123;SYSLOGTIMESTAMP:timestamp&#125; CUSTOM GROK HERE&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>syslog input配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>facility_labels</td><td>array</td><td>No</td></tr><tr><td>grok_pattern</td><td>string</td><td>No</td></tr><tr><td>host</td><td>string</td><td>No</td></tr><tr><td>locale</td><td>string</td><td>No</td></tr><tr><td>port</td><td>number</td><td>No</td></tr><tr><td>proxy_protocol</td><td>boolean</td><td>No</td></tr><tr><td>severity_labels</td><td>array</td><td>No</td></tr><tr><td>syslog_field</td><td>string</td><td>No</td></tr><tr><td>timezone</td><td>string</td><td>No</td></tr><tr><td>use_labels</td><td>boolean</td><td>No</td></tr></tbody></table><p><br><br><br></p><h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  tcp &#123;</span><br><span class="line">    port =&gt; 12345</span><br><span class="line">    codec =&gt; json</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>tcp input配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>host</td><td>string</td><td>No</td></tr><tr><td>mode</td><td>string, one of [server, client]</td><td>No</td></tr><tr><td>port</td><td>number</td><td>Yes</td></tr><tr><td>proxy_protocol</td><td>boolean</td><td>No</td></tr><tr><td>ssl_cert</td><td>a valid file system path</td><td>No</td></tr><tr><td>ssl_enable</td><td>boolean</td><td>No</td></tr><tr><td>ssl_extra_chain_certs</td><td>array</td><td>No</td></tr><tr><td>ssl_key</td><td>a valid file system path</td><td>No</td></tr><tr><td>ssl_key_passphrase</td><td>password</td><td>No</td></tr><tr><td>ssl_verify</td><td>boolean</td><td>No</td></tr></tbody></table><p><br><br><br></p><h3 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h3><p><br><br><br></p><h3 id="unix"><a href="#unix" class="headerlink" title="unix"></a>unix</h3><p><br><br><br></p><h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p><br><br><br></p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出将事件数据发送到特定的目标。输出是事件管道的最后阶段。</p><p>输出列表：</p><ul><li>boundary</li><li>circonus</li><li>CSV</li><li>datadog</li><li>Elasticsearch</li><li>email</li><li>exec</li><li>file</li><li>gelf</li><li>ganglia</li><li>http/https</li><li>influxdb</li><li>irc</li><li>kafka</li><li>librato</li><li>loggly</li><li>lumberjack</li><li>metriccatcher</li><li>mongodb</li><li>nagios</li><li>opentsdb</li><li>pipe</li><li>rabbitmq</li><li>redis</li><li>redmine</li><li>stdout</li><li>syslog</li><li>tcp</li><li>udp</li><li>websocket</li><li>zabbix</li></ul><p><br></p><p><strong>output通用配置项： </strong></p><table><thead><tr><th>Setting</th><th>Input type</th><th>Required</th></tr></thead><tbody><tr><td>codec</td><td>codec</td><td>No</td></tr><tr><td>enable_metric</td><td>boolean</td><td>No</td></tr><tr><td>id</td><td>string</td><td>No</td></tr></tbody></table><ul><li><p><code>codec</code><br>用于输出数据的编解码器，默认值是<code>json_lines</code></p></li><li><p><code>enable_metric</code><br>为特定插件实例启用或禁用度量日志记录，默认值是<code>true</code></p></li><li><p><code>id</code><br>为插件配置添加一个唯一的ID，如果未指定ID，Logstash会自动生成。</p></li></ul><p><br><br><br></p><h3 id="csv"><a href="#csv" class="headerlink" title="csv"></a>csv</h3><p><strong>csv output配置选项：</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>create_if_deleted</td><td>boolean</td><td>No</td></tr><tr><td>csv_options</td><td>hash</td><td>No</td></tr><tr><td>dir_mode</td><td>number</td><td>No</td></tr><tr><td>fields</td><td>array</td><td>Yes</td></tr><tr><td>file_mode</td><td>number</td><td>No</td></tr><tr><td>filename_failure</td><td>string</td><td>No</td></tr><tr><td>flush_interval</td><td>number</td><td>No</td></tr><tr><td>gzip</td><td>boolean</td><td>No</td></tr><tr><td>path</td><td>string</td><td>Yes</td></tr><tr><td>spreadsheet_safe</td><td>boolean</td><td>No</td></tr></tbody></table><p><br><br><br></p><h3 id="elasticsearch-1"><a href="#elasticsearch-1" class="headerlink" title="elasticsearch"></a>elasticsearch</h3><p><strong>Elasticsearch output配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input type</th><th>Required</th></tr></thead><tbody><tr><td>action</td><td>string</td><td>No</td></tr><tr><td>bulk_path</td><td>string</td><td>No</td></tr><tr><td>cacert</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>doc_as upsert</td><td>boolean</td><td>No</td></tr><tr><td>document_id</td><td>string</td><td>No</td></tr><tr><td>document_type</td><td>string</td><td>No</td></tr><tr><td>failure_type logging whitelist</td><td>array</td><td>No</td></tr><tr><td>healthcheck_path</td><td>string</td><td>No</td></tr><tr><td>hosts</td><td>uri</td><td>No</td></tr><tr><td>http_compression</td><td>boolean</td><td>No</td></tr><tr><td>index</td><td>string</td><td>No</td></tr><tr><td>keystore</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>keystore_password</td><td>password</td><td>No</td></tr><tr><td>manage_template</td><td>boolean</td><td>No</td></tr><tr><td>parameters</td><td>hash</td><td>No</td></tr><tr><td>parent</td><td>string</td><td>No</td></tr><tr><td>password</td><td>password</td><td>No</td></tr><tr><td>path</td><td>string</td><td>No</td></tr><tr><td>pipeline</td><td>string</td><td>No</td></tr><tr><td>pool_max</td><td>number</td><td>No</td></tr><tr><td>pool_max per route</td><td>number</td><td>No</td></tr><tr><td>proxy</td><td>uri</td><td>No</td></tr><tr><td>resurrect_delay</td><td>number</td><td>No</td></tr><tr><td>retry_initial interval</td><td>number</td><td>No</td></tr><tr><td>retry_max_interval</td><td>number</td><td>No</td></tr><tr><td>retry_on_conflict</td><td>number</td><td>No</td></tr><tr><td>routing</td><td>string</td><td>No</td></tr><tr><td>script</td><td>string</td><td>No</td></tr><tr><td>script_lang</td><td>string</td><td>No</td></tr><tr><td>script_type</td><td>string, one of [inline, indexed, file]</td><td>No</td></tr><tr><td>script_var_name</td><td>string</td><td>No</td></tr><tr><td>scripted_upsert</td><td>boolean</td><td>No</td></tr><tr><td>sniffing</td><td>boolean</td><td>No</td></tr><tr><td>sniffing_delay</td><td>number</td><td>No</td></tr><tr><td>sniffing_path</td><td>string</td><td>No</td></tr><tr><td>ssl</td><td>boolean</td><td>No</td></tr><tr><td>ssl_certificate verification</td><td>boolean</td><td>No</td></tr><tr><td>template</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>template_name</td><td>string</td><td>No</td></tr><tr><td>template_overwrite</td><td>boolean</td><td>No</td></tr><tr><td>timeout</td><td>number</td><td>No</td></tr><tr><td>truststore</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>truststore_password</td><td>password</td><td>No</td></tr><tr><td>upsert</td><td>string</td><td>No</td></tr><tr><td>user</td><td>string</td><td>No</td></tr><tr><td>validate_after inactivity</td><td>number</td><td>No</td></tr><tr><td>version</td><td>string</td><td>No</td></tr><tr><td>version_type</td><td>string, one of [internal, external, external gt, external gte, force]</td><td>No</td></tr></tbody></table><p><br><br><br></p><h3 id="exec-1"><a href="#exec-1" class="headerlink" title="exec"></a>exec</h3><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">  if [type] == &quot;abuse&quot; &#123;</span><br><span class="line">    exec &#123;</span><br><span class="line">      command =&gt; &quot;iptables -A INPUT -s %&#123;clientip&#125; -j DROP&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>exec output配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input type</th><th>Required</th></tr></thead><tbody><tr><td>command</td><td>string</td><td>Yes</td></tr><tr><td>quiet</td><td>boolean</td><td>No</td></tr></tbody></table><p><br><br><br></p><h3 id="file-1"><a href="#file-1" class="headerlink" title="file"></a>file</h3><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line"> file &#123;</span><br><span class="line">   path =&gt; ...</span><br><span class="line">   codec =&gt; line &#123; format =&gt; &quot;custom format: %&#123;message&#125;&quot;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>file output配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input type</th><th>Required</th></tr></thead><tbody><tr><td>create_if_deleted</td><td>boolean</td><td>No</td></tr><tr><td>dir_mode</td><td>number</td><td>No</td></tr><tr><td>file_mode</td><td>number</td><td>No</td></tr><tr><td>filename_failure</td><td>string</td><td>No</td></tr><tr><td>flush_interval</td><td>number</td><td>No</td></tr><tr><td>gzip</td><td>boolean</td><td>No</td></tr><tr><td>path</td><td>string</td><td>Yes</td></tr><tr><td>write_behavior</td><td>string</td><td>No</td></tr></tbody></table><p><br><br><br></p><h3 id="kafka-1"><a href="#kafka-1" class="headerlink" title="kafka"></a>kafka</h3><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">  kafka &#123;</span><br><span class="line">    codec =&gt; json</span><br><span class="line">    topic_id =&gt; &quot;mytopic&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>kafka output配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input type</th><th>Required</th></tr></thead><tbody><tr><td>acks</td><td>string, one of [0, 1, all]</td><td>No</td></tr><tr><td>batch_size</td><td>number</td><td>No</td></tr><tr><td>bootstrap_servers</td><td>string</td><td>No</td></tr><tr><td>buffer_memory</td><td>number</td><td>No</td></tr><tr><td>client_id</td><td>string</td><td>No</td></tr><tr><td>compression_type</td><td>string, one of [none, gzip, snappy, lz4]</td><td>No</td></tr><tr><td>jaas_path</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>kerberos_config</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>key_serializer</td><td>string</td><td>No</td></tr><tr><td>linger_ms</td><td>number</td><td>No</td></tr><tr><td>max_request size</td><td>number</td><td>No</td></tr><tr><td>message_key</td><td>string</td><td>No</td></tr><tr><td>metadata_fetch_timeout_ms</td><td>number</td><td>No</td></tr><tr><td>metadata_max_age_ms</td><td>number</td><td>No</td></tr><tr><td>receive_buffer_bytes</td><td>number</td><td>No</td></tr><tr><td>reconnect_backoff_ms</td><td>number</td><td>No</td></tr><tr><td>request_timeout_ms</td><td>string</td><td>No</td></tr><tr><td>retries</td><td>number</td><td>No</td></tr><tr><td>retry_backoff_ms</td><td>number</td><td>No</td></tr><tr><td>sasl_kerberos_service name</td><td>string</td><td>No</td></tr><tr><td>sasl_mechanism</td><td>string</td><td>No</td></tr><tr><td>security_protocol</td><td>string, one of [PLAINTEXT, SSL, SASL PLAINTEXT, SASL SSL]</td><td>No</td></tr><tr><td>send_buffer_bytes</td><td>number</td><td>No</td></tr><tr><td>ssl_key_password</td><td>password</td><td>No</td></tr><tr><td>ssl_keystore_location</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>ssl_keystore_password</td><td>password</td><td>No</td></tr><tr><td>ssl_keystore_type</td><td>string</td><td>No</td></tr><tr><td>ssl_truststore_location</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>ssl_truststore_password</td><td>password</td><td>No</td></tr><tr><td>ssl_truststore_type</td><td>string</td><td>No</td></tr><tr><td>topic_id</td><td>string</td><td>Yes</td></tr><tr><td>value_serializer</td><td>string</td><td>No</td></tr></tbody></table><p><br><br><br></p><h3 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h3><p><strong>mongodb output配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input type</th><th>Required</th></tr></thead><tbody><tr><td>bulk</td><td>boolean</td><td>No</td></tr><tr><td>bulk_interval</td><td>number</td><td>No</td></tr><tr><td>bulk_size</td><td>number</td><td>No</td></tr><tr><td>collection</td><td>string</td><td>Yes</td></tr><tr><td>database</td><td>string</td><td>Yes</td></tr><tr><td>generateId</td><td>boolean</td><td>No</td></tr><tr><td>isodate</td><td>boolean</td><td>No</td></tr><tr><td>retry_delay</td><td>number</td><td>No</td></tr><tr><td>uri</td><td>string</td><td>Yes</td></tr></tbody></table><p><br><br><br></p><h3 id="redis-1"><a href="#redis-1" class="headerlink" title="redis"></a>redis</h3><p>将Redis作为消息队列缓存能极大降低系统负载，减轻系统压力。</p><p><strong>redis output配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input type</th><th>Required</th></tr></thead><tbody><tr><td>batch</td><td>boolean</td><td>No</td></tr><tr><td>batch_events</td><td>number</td><td>No</td></tr><tr><td>batch_timeout</td><td>number</td><td>No</td></tr><tr><td>congestion_interval</td><td>number</td><td>No</td></tr><tr><td>congestion_threshold</td><td>number</td><td>No</td></tr><tr><td>data_type</td><td>string, one of [list, channel]</td><td>No</td></tr><tr><td>db</td><td>number</td><td>No</td></tr><tr><td>host</td><td>array</td><td>No</td></tr><tr><td>key</td><td>string</td><td>No</td></tr><tr><td>password</td><td>password</td><td>No</td></tr><tr><td>port</td><td>number</td><td>No</td></tr><tr><td>reconnect_interval</td><td>number</td><td>No</td></tr><tr><td>shuffle_hosts</td><td>boolean</td><td>No</td></tr><tr><td>timeout</td><td>number</td><td>No</td></tr></tbody></table><p><br><br><br></p><h3 id="redmine"><a href="#redmine" class="headerlink" title="redmine"></a>redmine</h3><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">  redmine &#123;</span><br><span class="line">    url =&gt; &quot;http://redmineserver.tld&quot;</span><br><span class="line">    token =&gt; &apos;token&apos;</span><br><span class="line">    project_id =&gt; 200</span><br><span class="line">    tracker_id =&gt; 1</span><br><span class="line">    status_id =&gt; 3</span><br><span class="line">    priority_id =&gt; 2</span><br><span class="line">    subject =&gt; &quot;Error ... detected&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>redmine output配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input type</th><th>Required</th></tr></thead><tbody><tr><td>assigned_to_id</td><td>number</td><td>No</td></tr><tr><td>categorie_id</td><td>number</td><td>No</td></tr><tr><td>description</td><td>string</td><td>No</td></tr><tr><td>fixed_version_id</td><td>number</td><td>No</td></tr><tr><td>parent_issue_id</td><td>number</td><td>No</td></tr><tr><td>priority_id</td><td>number</td><td>Yes</td></tr><tr><td>project_id</td><td>number</td><td>Yes</td></tr><tr><td>ssl</td><td>boolean</td><td>No</td></tr><tr><td>status_id</td><td>number</td><td>Yes</td></tr><tr><td>subject</td><td>string</td><td>No</td></tr><tr><td>token</td><td>string</td><td>Yes</td></tr><tr><td>tracker_id</td><td>number</td><td>Yes</td></tr><tr><td>url</td><td>string</td><td>Yes</td></tr></tbody></table><p><br><br><br></p><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">  stdout &#123; codec =&gt; json &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="syslog-1"><a href="#syslog-1" class="headerlink" title="syslog"></a>syslog</h3><p><strong>syslog output配置：</strong></p><table><thead><tr><th>Setting</th><th>Input type</th><th>Required</th></tr></thead><tbody><tr><td>appname</td><td>string</td><td>No</td></tr><tr><td>facility</td><td>string</td><td>No</td></tr><tr><td>host</td><td>string</td><td>Yes</td></tr><tr><td>message</td><td>string</td><td>No</td></tr><tr><td>msgid</td><td>string</td><td>No</td></tr><tr><td>port</td><td>number</td><td>Yes</td></tr><tr><td>priority</td><td>string</td><td>No</td></tr><tr><td>procid</td><td>string</td><td>No</td></tr><tr><td>protocol</td><td>string, one of [tcp, udp, ssl-tcp]</td><td>No</td></tr><tr><td>reconnect interval</td><td>number</td><td>No</td></tr><tr><td>rfc</td><td>string, one of [rfc3164, rfc5424]</td><td>No</td></tr><tr><td>severity</td><td>string</td><td>No</td></tr><tr><td>sourcehost</td><td>string</td><td>No</td></tr><tr><td>ssl_cacert</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>ssl_cert</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>ssl_key</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>ssl_key passphrase</td><td>password</td><td>No</td></tr><tr><td>ssl_verify</td><td>boolean</td><td>No</td></tr><tr><td>use_labels</td><td>boolean</td><td>No</td></tr></tbody></table><p><br><br><br></p><h3 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h3><p><strong>zabbix output配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input type</th><th>Required</th></tr></thead><tbody><tr><td>multi_value</td><td>array</td><td>No</td></tr><tr><td>timeout</td><td>number</td><td>No</td></tr><tr><td>zabbix_host</td><td>string</td><td>Yes</td></tr><tr><td>zabbix_key</td><td>string</td><td>No</td></tr><tr><td>zabbix_server host</td><td>string</td><td>No</td></tr><tr><td>zabbix_server port</td><td>number</td><td>No</td></tr><tr><td>zabbix_value</td><td>string</td><td>No</td></tr></tbody></table><p><br><br><br><br><br></p><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><ul><li><a href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/filter-plugins.html</a></li></ul><p>过滤器插件对事件执行中介(intermediary)处理，过滤器通常根据事件的特征有条件的应用。</p><p>下面是Elastic支持的插件列表:</p><table><thead><tr><th>插件</th><th>描述</th></tr></thead><tbody><tr><td>aggregate</td><td>汇总来自单个任务的多个事件的信息</td></tr><tr><td>alter</td><td>对mutate过滤器无法处理的字段进行常规更改</td></tr><tr><td>cidr</td><td>根据网络块列表检查IP地址</td></tr><tr><td>cipher</td><td>对事件应用或移除cipher(密码)</td></tr><tr><td>clone</td><td>重复事件</td></tr><tr><td>csv</td><td>将csv(comma separated value)解析为单个字段</td></tr><tr><td>date</td><td>解析字段中的日期，以用作事件的Logstash timestamp</td></tr><tr><td>de_dot</td><td>Computationally expensive filter that removes dots from a field name</td></tr><tr><td>dissect</td><td>使用分隔符将非结构化事件数据提取到字段中</td></tr><tr><td>dns</td><td>执行标准或反向DNS查询</td></tr><tr><td>drop</td><td>删除所有事件</td></tr><tr><td>elapsed</td><td>计算一对事件之间的经过时间</td></tr><tr><td>elasticsearch</td><td>将Elasticsearch中以前的日志事件的字段复制到当前事件中</td></tr><tr><td>environment</td><td>将环境变量存储为元数据子字段</td></tr><tr><td>extractnumbers</td><td>从字符串中提取数字</td></tr><tr><td>fingerprint</td><td>由一致的散列值的替换值的指纹字段</td></tr><tr><td>geoip</td><td>添加有关IP地址的地理信息</td></tr><tr><td>grok</td><td>将非结构化事件数据解析到字段中</td></tr><tr><td>i18n</td><td>从字段中删除特定字符</td></tr><tr><td>jdbc_static</td><td>使用从远程数据库预加载的数据来丰富事件</td></tr><tr><td>jdbc_streaming</td><td>用你的数据库数据丰富事件</td></tr><tr><td>json</td><td>解析JSON事件</td></tr><tr><td>json_encode</td><td>将字段序列化为JSON</td></tr><tr><td>kv</td><td>解析键值对</td></tr><tr><td>metricize</td><td>处理包含多个度量标准的复杂事件并将它们分成多个事件，每个事件都包含一个度量标准</td></tr><tr><td>metrics</td><td>汇总指标(Aggregates metrics)</td></tr><tr><td>mutate</td><td>对字段执行突变</td></tr><tr><td>prune</td><td>将基于字段列表的事件数据精简为黑名单或白名单</td></tr><tr><td>range</td><td>检查指定的字段是否在给定的大小或长度限制内</td></tr><tr><td>ruby</td><td>执行任意Ruby代码</td></tr><tr><td>sleep</td><td>休息一段指定的时间</td></tr><tr><td>split</td><td>将多行消息拆分成不同的事件</td></tr><tr><td>syslog_pri</td><td>解析syslog消息的优先字段</td></tr><tr><td>throttle</td><td>限制事件的数量</td></tr><tr><td>tld</td><td>用你在配置中指定的任何内容替换默认消息字段的内容</td></tr><tr><td>translate</td><td>根据散列或YAML文件，替换字段内容</td></tr><tr><td>truncate</td><td>截断长度超过给定长度的字段</td></tr><tr><td>urldecode</td><td>解码URL编码的字段</td></tr><tr><td>useragent</td><td>将用户代理字符串解析到字段中</td></tr><tr><td>uuid</td><td>为事件添加UUID</td></tr><tr><td>xml</td><td>将XML解析到字段</td></tr></tbody></table><p><br></p><p><strong>所有过滤器都支持的配置选项：</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>add_field</td><td>hash</td><td>No</td></tr><tr><td>add_tag</td><td>array</td><td>No</td></tr><tr><td>enable_metric</td><td>boolean</td><td>No</td></tr><tr><td>id</td><td>string</td><td>No</td></tr><tr><td>periodic_flush</td><td>boolean</td><td>No</td></tr><tr><td>remove_field</td><td>array</td><td>No</td></tr><tr><td>remove_tag</td><td>array</td><td>No</td></tr></tbody></table><ul><li><p><code>add_field</code><br>如果此过滤器成功，添加任意字段到此事件。字段名称可以是动态的，并使用<code>%{field}</code>包含事件的部分内容</p></li><li><p><code>add_tag</code><br>如果此过滤器成功，添加任意标签到此事件。标签可以是动态的，并使用<code>%{field}</code>语法包含事件的部分内容</p></li><li><p><code>enable_metric</code><br>为特定插件实例启用/禁用度量标准日志记录</p></li><li><p><code>id</code><br>为插件配置添加一个唯一的ID，如果没有指定ID，Logstash会生成一个。强烈建议在配置中设置此ID<br>当你有多个相同类型的插件时，这特别有用</p></li><li><p><code>periodic_flush</code><br>定期调用过滤器flush方法</p></li><li><p><code>remove_field</code><br>如果此过滤器成功，从事件中移除任意字段</p></li><li><p><code>remove_tag</code><br>如果此过滤器成功，从事件中移除任意标签</p></li></ul><p><br><br><br></p><h3 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h3><p>此过滤器的目的是聚合属于同一任务的多个事件(通常是日志行)中可用的信息，并将最终聚合信息推送到最终任务事件中。</p><p><br></p><p><strong>Aggregate Filter Configuration Options: </strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>aggregate_maps_path</td><td>string, a valid filesystem path</td><td>No</td></tr><tr><td>code</td><td>string</td><td>Yes</td></tr><tr><td>end_of_task</td><td>boolean</td><td>No</td></tr><tr><td>inactivity_timeout</td><td>number</td><td>No</td></tr><tr><td>map_action</td><td>string, one of [“create”, “update”, “create_or_update”]</td><td>No</td></tr><tr><td>push_map_as_event_on_timeout</td><td>boolean</td><td>No</td></tr><tr><td>push_previous_map_as_event</td><td>boolean</td><td>No</td></tr><tr><td>task_id</td><td>string</td><td>Yes</td></tr><tr><td>timeout</td><td>number</td><td>No</td></tr><tr><td>timeout_code</td><td>string</td><td>No</td></tr><tr><td>timeout_tags</td><td>array</td><td>No</td></tr><tr><td>timeout_task_id_field</td><td>string</td><td>No</td></tr><tr><td>timeout_timestamp_field</td><td>string</td><td>No</td></tr></tbody></table><ul><li><p><code>aggregate_maps_path</code><br>Logstash停止时存储聚合地图的文件路径，以及Logstash启动时加载的路径。<br>如果未定义，聚合映射将不会存储在Logstash中，并且会丢失。</p></li><li><p><code>code</code><br>使用当前事件执行更新map的代码；或使用当前的map执行更新事件的代码<br>你将有一个可用的map variable 和 event variable</p></li><li><p><code>end_of_task</code><br>告诉过滤器该任务已结束，因此在代码执行后删除聚合map</p></li><li><p><code>inactivity_timeout</code><br>一个任务被认为已到期的秒数<br>当某个任务超时时，其聚合map将被逐出<br>必须小于timeout</p></li><li><p><code>map_action</code></p><ul><li><code>create</code></li><li><code>update</code></li><li><code>create_or_update</code><br>告诉过滤器如何处理聚合map</li></ul></li><li><p><code>push_map_as_event_on_timeout</code><br>每次检测到任务超时时，它都会将任务集合映射推送为新的Logstash事件</p></li><li><p><code>push_previous_map_as_event</code><br>每次聚合插件检测到新任务ID时，它会将先前的聚合映射推送为新的Logstash事件，然后为下一个任务创建新的空映射</p></li><li><p><code>task_id</code><br>定义了关联日志的任务ID的表达式<br>该值必须唯一标识任务</p></li><li><p><code>timeout</code></p></li><li><p><code>time_code</code></p></li><li><p><code>timeout_tags</code><br>在生成超时事件添加的标记</p></li><li><p><code>timeout_task_id_field</code></p></li><li><p><code>timeout_timestamp_field</code><br>默认情况下，使用系统时间计算超时</p></li></ul><p><br></p><p><strong>栗子：</strong></p><p>给定日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO - 12345 - TASK_START - start</span><br><span class="line">INFO - 12345 - SQL - sqlQuery1 - 12</span><br><span class="line">INFO - 12345 - SQL - sqlQuery2 - 34</span><br><span class="line">INFO - 12345 - TASK_END - end</span><br></pre></td></tr></table></figure><p>过滤器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match =&gt; [ &quot;message&quot;, &quot;%&#123;LOGLEVEL:loglevel&#125; - %&#123;NOTSPACE:taskid&#125; - %&#123;NOTSPACE:logger&#125; - %&#123;WORD:label&#125;( - %&#123;INT:duration:int&#125;)?&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if [logger] == &quot;TASK_START&quot; &#123;</span><br><span class="line">    aggregate &#123;</span><br><span class="line">      task_id =&gt; &quot;%&#123;taskid&#125;&quot;</span><br><span class="line">      code =&gt; &quot;map[&apos;sql_duration&apos;] = 0&quot;</span><br><span class="line">      map_action =&gt; &quot;create&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if [logger] == &quot;SQL&quot; &#123;</span><br><span class="line">    aggregate &#123;</span><br><span class="line">      task_id =&gt; &quot;%&#123;taskid&#125;&quot;</span><br><span class="line">      code =&gt; &quot;map[&apos;sql_duration&apos;] += event.get(&apos;duration&apos;)&quot;</span><br><span class="line">      map_action =&gt; &quot;update&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if [logger] == &quot;TASK_END&quot; &#123;</span><br><span class="line">    aggregate &#123;</span><br><span class="line">      task_id =&gt; &quot;%&#123;taskid&#125;&quot;</span><br><span class="line">      code =&gt; &quot;event.set(&apos;sql_duration&apos;, map[&apos;sql_duration&apos;])&quot;</span><br><span class="line">      map_action =&gt; &quot;update&quot;</span><br><span class="line">      end_of_task =&gt; true</span><br><span class="line">      timeout =&gt; 120</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Alter"><a href="#Alter" class="headerlink" title="Alter"></a>Alter</h3><p>alter filter允许对未包含在正常变异过滤器中的字段进行一般更改。</p><p><br></p><p><strong>安装: </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logstash-plugin install logstash-filter-alter</span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置项: </strong></p><table><thead><tr><th>Setting</th><th>Input type</th><th>Required</th></tr></thead><tbody><tr><td>coalesce</td><td>array</td><td>No</td></tr><tr><td>condrewrite</td><td>array</td><td>No</td></tr><tr><td>condrewriteother</td><td>array</td><td>No</td></tr></tbody></table><ul><li><p><code>coalesce</code><br>将file_name的值设置为其参数的第一个非空表达式</p></li><li><p><code>condrewrite</code><br>如果实际内容等于预期内容，则将字段内容更改为指定值</p></li><li><p><code>condrewriteother</code><br>如果另一个字段内容等于预期内容，则将字段内容更改为指定值</p></li></ul><p><br><br><br></p><h3 id="cidr"><a href="#cidr" class="headerlink" title="cidr"></a>cidr</h3><p>CIDR filter用于检查时间中的IP地址与可能包含它的网络块列表。可以针对多个网络检查多个地址，任何匹配都可以成功。成功后，可将其它标记/字段添加到事件中。</p><p><br></p><p><strong>配置项: </strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>address</td><td>array</td><td>No</td></tr><tr><td>network</td><td>array</td><td>No</td></tr><tr><td>network_path</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>refresh_interval</td><td>number</td><td>No</td></tr><tr><td>separator</td><td>string</td><td>No</td></tr></tbody></table><ul><li><p><code>address</code><br>要检查的IP地址</p></li><li><p><code>network</code><br>要检查的IP网络</p></li><li><p><code>network_path</code><br>包含过滤器应检查的网络的外部文件的完整路径</p></li><li><p><code>refresh_interval</code><br>检查外部文件的更新频率</p></li><li><p><code>seperator</code><br>从network_path指定的外部文件解析网络的分隔符</p></li></ul><p><br><br><br></p><h3 id="csv-1"><a href="#csv-1" class="headerlink" title="csv"></a>csv</h3><p>csv filter处理包含csv数据的事件字段，解析它，并将其存储为单个字段<br>此过滤器还可解析使用任何分隔符的数据，而不仅仅是逗号</p><p><br></p><p><strong>配置项: </strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>autodetect_column_names</td><td>boolean</td><td>No</td></tr><tr><td>autogenerate_column_names</td><td>boolean</td><td>No</td></tr><tr><td>columns</td><td>array</td><td>No</td></tr><tr><td>convert</td><td>hash</td><td>No</td></tr><tr><td>quote_char</td><td>string</td><td>No</td></tr><tr><td>separator</td><td>string</td><td>No</td></tr><tr><td>skip_empty_columns</td><td>boolean</td><td>No</td></tr><tr><td>skip_empty_rows</td><td>boolean</td><td>No</td></tr><tr><td>skip_header</td><td>boolean</td><td>No</td></tr><tr><td>source</td><td>string</td><td>No</td></tr><tr><td>target</td><td>string</td><td>No</td></tr></tbody></table><ul><li><p><code>autodetect_column_names</code><br>是否应该从标题列自动检测列名称，默认false</p></li><li><p><code>autogenerate_column_names</code><br>是否应该自动生成列名，默认true。<br>如果设置为false，那么没有指定header的列将不会被解析</p></li><li><p><code>columns</code><br>列名称的列表</p></li><li><p><code>convert</code><br>应用于列的数据类型转换的集合，可能的转换: integer, float, date, date_time, boolean</p></li><li><p><code>quote_char</code><br>用于引用csv字段的字符，默认<code>&quot;</code></p></li><li><p><code>separator</code><br>列分隔符值。默认值comma<code>,</code></p></li><li><p><code>skip_empty_columns</code><br>是否应该跳过空列，默认false</p></li><li><p><code>skip_empty_rows</code><br>是否应该跳过空行，默认false</p></li><li><p><code>skip_header</code><br>是否应该跳过header，默认false</p></li><li><p><code>source</code><br>源字段值中的csv数据将被扩展为数据结构</p></li><li><p><code>target</code><br>放置数据的目标字段</p></li></ul><p><br><br><br></p><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>date filter从字段中解析日期，然后使用该日期或时间戳作为事件的Logstash时间戳。它对事件排序和回填旧数据尤其重要。<br>在没有此过滤器的情况下，如果timestamp尚未在事件中设置，则Logstash将根据首次查看事件是(input time)选择一个时间戳。</p><p><br></p><p><strong>date filter配置项：</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>locale</td><td>string</td><td>No</td></tr><tr><td>match</td><td>array</td><td>No</td></tr><tr><td>tag_on_failure</td><td>array</td><td>No</td></tr><tr><td>target</td><td>string</td><td>No</td></tr><tr><td>timezone</td><td>string</td><td>No</td></tr></tbody></table><p><strong>locale</strong><br>使用POSIX语言标记指定用于日期解析的环境(locale)，如<code>en</code>,<code>en_US</code><br>如果未指定，则将使用平台默认值</p><p><strong>match</strong><br>有字段名称和格式模式的数组，[ field, formats…]</p><p>如果时间字段有多种格式，你可这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">match =&gt; [ &quot;filed-name&quot;, &quot;MMM dd yyyy HH:mm:ss&quot;,</span><br><span class="line">          &quot;MMM  d yyyy HH:mm:ss&quot;, &quot;ISO8601&quot; ]</span><br><span class="line"></span><br><span class="line">嵌套字段表示</span><br><span class="line">[foo][bar]</span><br></pre></td></tr></table></figure><p>有几个例外:</p><ul><li><code>ISO8601</code>: 解析任何有效的ISO8601时间戳，如<code>2011-04-19T03:44:01.103Z</code></li><li><code>UNIX</code>: 解析float/int Unix原子时间(s)</li><li><code>UNIX_MS</code>: 解析int Unix原子时间</li><li><code>TAI64N</code>: 解析tai64n时间值</li></ul><p>语法细节:<br>用于解析日期和时间文本的语法使用字母来指示时间值的种类，以及重复的字母来指示该值的形式。</p><p>以下是可用于解析日期和时间的内容：</p><ul><li><p>y year</p><ul><li>yyyy<br>完整年号，如<code>2018</code></li><li>yy<br>  两位数年份，如<code>18</code></li></ul></li><li><p>M month of the year</p><ul><li>M<br>最小数字月份,<code>1-12</code></li><li>MM<br>两位数字月份，<code>01-12</code></li><li>MMM<br>缩写的月份文本，<code>Jan, Feb...</code></li><li>MMMM<br>完整的月份文本，<code>January, February...</code></li></ul></li><li><p>d day of the month</p><ul><li>d<br>最小数字日，<code>1, 2...</code></li><li>dd<br>两位数字日，<code>01, 02...</code></li></ul></li><li><p>H hour of the day</p><ul><li>H<br>最小数字小时，<code>0, 1...</code></li><li>HH<br>两位数字小时，<code>00, 01...</code></li></ul></li><li><p>m minutes of the hour</p><ul><li>m<br>最小数字分钟，<code>0, 1...</code></li><li>mm<br>两位数字分钟，<code>00, 01...</code></li></ul></li><li><p>s seconds of the minute</p><ul><li>s<br>最小数字秒数，<code>0, 1...</code></li><li>ss<br>两位数字秒数，<code>00, 01...</code></li></ul></li><li><p>S 秒的最大精度(毫秒)，附加零</p><ul><li>S<br>十分之一秒</li><li>SS<br>百分之一秒</li><li>SSS<br>千分之一秒</li></ul></li><li><p>Z time zone offset or identity</p><ul><li>Z<br>时区偏移量结构为HHmm(如上海)，<code>+0800</code></li><li>ZZ<br>时区偏移量结构为HH:mm，<code>+08:00</code></li><li>ZZZ<br>时区身份(如上海)，<code>Asia/Shanghai</code></li></ul></li><li><p>z time zone names. <strong>Time zone names (z) cannot be parsed</strong></p></li><li><p>w week of the year</p><ul><li>w<br>最小数字周数，<code>1, 2...</code></li><li>ww<br>两位数字周数，<code>01, 02...</code></li></ul></li><li><p>D day of the year</p></li><li><p>e day of the week(number)</p></li><li><p>E day of the week(text)</p><ul><li>E, EE, EEE<br>星期几的缩写，<code>Mon, Tue, Wed, Thu, Fri, Sat, Sun</code></li><li>EEEE<br>星期几的全文，<code>Monday, Tuesday...</code></li></ul></li></ul><p>对于非格式化的语法，你需要在值的周围放置单引号字符。如”yyyy-MM-dd’T’HH:mm:ss”</p><p><br></p><p><strong>tag_on_failure</strong><br>没有成功匹配时，将值附加到tag字段，默认值<code>[&quot;_dateparsefailure&quot;]</code></p><p><strong>target</strong><br>将匹配的timestamp存储到给定目标字段中。如果未提供，则默认更新事件的<code>@timestamp</code>字段</p><p><strong>timezone</strong><br>指定用于日期分析的时区标准ID，如<code>Asia/Shanghai</code></p><p><br><br><br></p><h3 id="dissect"><a href="#dissect" class="headerlink" title="dissect"></a>dissect</h3><p>dissect filter是一种拆分操作。与对整个字符串应用一个分隔符的常规拆分操作不同，此操作将一组分隔符应用于字符串值。dissect不使用正则表达式，所以速度非常快。<br>但是，如果文本结构因行而异，则Grok更适合。有一种混合的情况，dissect可用来结构可靠地重复部分，然后Grok用于余下的字段值，并具有更多的正则表达式可预测性和更少的整体工作。</p><p>一组字段和分隔符被称为dissection，它使用一组<code>%</code>来描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">field: %&#123;a&#125;</span><br><span class="line">delimiter: -</span><br><span class="line">%&#123;a&#125; - %&#123;b&#125; - %&#123;c&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>dissect filter配置项</strong></p><table><thead><tr><th>Setting</th><th>Input type</th><th>Required</th></tr></thead><tbody><tr><td>convert_datatype</td><td>hash</td><td>No</td></tr><tr><td>mapping</td><td>hash</td><td>No</td></tr><tr><td>tag_on_failure</td><td>array</td><td>No</td></tr></tbody></table><ul><li><code>convert_datatype</code><br>可以指定int, float数据类型转换。这些将在mapping发生后完成，如果没有mapping部分，请自由使用此设置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  dissect &#123;</span><br><span class="line">    convert_datatype =&gt; &#123;</span><br><span class="line">      cpu =&gt; &quot;float&quot;</span><br><span class="line">      code =&gt; &quot;int&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>mapping</code><br>A hash of dissections of <code>field =&gt; value</code><br>不要在值中使用具有转移的<code>\n</code>，它会被看做两个字符<code>\+n+</code>而不是实际的换行符。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  dissect &#123;</span><br><span class="line">    mapping =&gt; &#123;</span><br><span class="line">      # using an actual line break</span><br><span class="line">      &quot;message&quot; =&gt; &apos;&quot;%&#123;field1&#125;&quot; &quot;%&#123;field2&#125;&quot;</span><br><span class="line"> &quot;%&#123;description&#125;&quot;&apos;</span><br><span class="line">      &quot;description&quot; =&gt; &quot;%&#123;field3&#125; %&#123;field4&#125; %&#123;field5&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>tag_on_failure</code><br>dissection失败时，将值添加到tag字段。默认值为<code>[&quot;_dissectfailure&quot;]</code></li></ul><p><br><br><br></p><h3 id="geoip"><a href="#geoip" class="headerlink" title="geoip"></a>geoip</h3><p>geoip filter根据Maxmind GeoLite2数据库的数据，添加有关IP地址的地理位置信息。</p><p>此插件与GeoLite City Database数据库捆绑在一起。GeoLite2是免费的IP地址位置数据库，与MaxMind的GeoIP2数据库相比，不如其精确。<br>如果需要使用捆绑的DeoLite之外的数据库，可从MaxMind下载它: <a href="https://dev.maxmind.com/geoip/geoip2/geolite2/" target="_blank" rel="noopener">https://dev.maxmind.com/geoip/geoip2/geolite2/</a></p><p>如果GeoIP返回查找到的经度(latitude)和纬度(longitude)，则会创建<code>[geoip][location]</code>字段。</p><p><br></p><p><strong>Geoip Filter配置项</strong></p><table><thead><tr><th>Setting</th><th>Inpu_type</th><th>Required</th></tr></thead><tbody><tr><td>cache_size</td><td>number</td><td>No</td></tr><tr><td>database</td><td>a valid filesystem path</td><td>No</td></tr><tr><td>default_database_type</td><td>City or ASN</td><td>No</td></tr><tr><td>fields</td><td>array</td><td>No</td></tr><tr><td>source</td><td>string</td><td>Yes</td></tr><tr><td>tag_on_failure</td><td>array</td><td>No</td></tr><tr><td>target</td><td>string</td><td>No</td></tr></tbody></table><ul><li><p><code>cache_size</code><br>默认值为1000。GeoIP查询的成本非常高昂。缓存设置的越高，项目在缓存中的可能性就越大，并且此filter运行的越快。但是，如果设置得太高，则会耗费太多内存。如果缓存已满，则无法添加更多记录。尝试使用此选项的不同值来为数据集找到最佳性能。<br>这个值必须大于0。</p></li><li><p><code>database</code><br>地理数据库的文件路径，如果未指定，则默认为logstash自带的GeoLite2-City数据库。</p></li><li><p><code>default_database_type</code><br>默认值是City。唯一可接受的值是City和ASN。</p></li><li><p><code>fields</code><br>包含在事件中的geoip字段数组。可能的字段取决于数据库类型。</p></li><li><p><code>source</code><br>包含要通过geoip映射的IP地址或主机名的字段。</p></li><li><p><code>tag_on_failure</code><br>默认值为<code>[&quot;_geoip_lookup_failure&quot;]</code>.</p></li><li><p><code>target</code><br>默认值为<code>geoip</code>.指定Logstash应该存储的geoip数据的字段。</p></li></ul><p><br><br><br></p><h3 id="grok"><a href="#grok" class="headerlink" title="grok"></a>grok</h3><p>Parse arbitrary text and structure it.<br>Grok是将非结构化日志数据解析为结构化和可查询的好方法。</p><p>它非常适用于syslog, apache or webserver logs, mysql logs以及通常为人类而不是计算机编写的任何日志格式。</p><p>默认情况下，Logstash ship附带了大约120种模式。它们在这: <a href="https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns" target="_blank" rel="noopener">https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns</a><br>要grok某类日志文件的时候，可以先到上面的地址查看有无对应的模式。然后复制对应内容到<code>patterns_dir</code>下，再在filter中使用。<br>当然，你也可以自定义模式来匹配你的日志。在这测试: <a href="http://grokdebug.herokuapp.com" target="_blank" rel="noopener">http://grokdebug.herokuapp.com</a></p><p><br></p><p><strong>Grok filter配置项</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>break_on_match</td><td>boolean</td><td>No</td></tr><tr><td>keep_empty_captures</td><td>boolean</td><td>No</td></tr><tr><td>match</td><td>hash</td><td>No</td></tr><tr><td>named_captures_only</td><td>boolean</td><td>No</td></tr><tr><td>overwrite</td><td>array</td><td>No</td></tr><tr><td>pattern_definitions</td><td>hash</td><td>No</td></tr><tr><td>patterns_dir</td><td>array</td><td>No</td></tr><tr><td>patterns_files_glob</td><td>string</td><td>No</td></tr><tr><td>tag_on_failure</td><td>array</td><td>No</td></tr><tr><td>tag_on_timeout</td><td>string</td><td>No</td></tr><tr><td>timeout_millis</td><td>number</td><td>No</td></tr></tbody></table><ul><li><p><code>break_on_match</code><br>Break on first match. grok的第一个成功的匹配将导致filter结束。如果你想grok尝试所有的模式，请将其设置为<code>false</code>。默认值为<code>true</code>。</p></li><li><p><code>keep_empty_captures</code><br>默认值为<code>false</code>。如果为<code>true</code>，则将空捕获保留为事件字段。</p></li><li><p><code>match</code><br>field ⇒ value的散列匹配，默认值为<code>{}</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  grok &#123; match =&gt; &#123; &quot;message&quot; =&gt; [ &quot;Duration: %&#123;NUMBER:duration&#125;&quot;, &quot;Speed: %&#123;NUMBER:speed&#125;&quot; ] &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>named_captures_only</code><br>默认值为<code>true</code>。如果为<code>true</code>，只保存来自grok的命名捕获。</p></li><li><p><code>overwrite</code><br>要覆盖的字段，这使你可覆盖已存在的字段中的值。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;SYSLOGBASE&#125; %&#123;DATA:message&#125;&quot; &#125;</span><br><span class="line">    overwrite =&gt; [ &quot;message&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>pattern_definitions</code><br>默认值为<code>{}</code><br>模式名称和模式元组的散列，用于定义当前过滤器要使用的自定义模式。匹配现用名称的模式将覆盖预先存在的定义。</p></li><li><p><code>patterns_dir</code><br>默认值为<code>[]</code><br>logstash默认提供了一堆模式，除非添加额外模式，否则不需要自定义模式。你可以使用此设置指向多个模式目录。grok将读取与<code>patterns_files_glob</code>匹配的目录汇总的所有文件，并假定它为模式文件。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patterns_dir =&gt; [&quot;/opt/logstash/patterns&quot;, &quot;/opt/logstash/extra_patterns&quot;]</span><br></pre></td></tr></table></figure><ul><li><p><code>patterns_files_glob</code><br>默认值为<code>&quot;*&quot;</code><br>Glob模式，用于从patterns_dir目录中选择模式文件。</p></li><li><p><code>tag_on_failure</code><br>默认值为<code>[&quot;_grokparsefailure&quot;]</code><br>匹配没有成功时，将值添加到tags字段。</p></li><li><p><code>tag_on_timeout</code><br>默认值为<code>&quot;_groktimeout&quot;</code><br>如果grok正则表达式超时，则应用此tag.</p></li><li><p><code>timeout_millis</code><br>默认值为<code>30000</code><br>尝试在这段时间后终止正则表达式。设置为0以禁用超时。</p></li></ul><p><br></p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>Grok工作方式，将文本模式组合成与你的日志模式相匹配的内容。</p><p>Grok模式的语法为 <code>%{SYNTAX:SEMANTIC}</code></p><ul><li><code>SYNTAX</code>, 文本匹配的模式的名称</li><li><code>SEMANTIC</code>, 正在匹配的文本的标识符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123;NUMBER:duration&#125; %&#123;IP:client&#125;</span><br></pre></td></tr></table></figure><p>你也可以将数据类型转换添加到Grok模式。默认情况下，所有的语义(semantic)都保存为字符串(strings)。<br>如果你想转换语义的数据类型，如将string转换为int。例如<code>%{NUMBER:num:int}</code>将num语义从string转换为integer。当前情况下，只支持转换为int和float.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">日志格式</span><br><span class="line">55.3.244.1 GET /index.html 15824 0.043</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grok pattern</span><br><span class="line">  grok &#123;</span><br><span class="line">    match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;IP:client&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125;&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grok filter之后的格式</span><br><span class="line">client: 55.3.244.1</span><br><span class="line">method: GET</span><br><span class="line">request: /index.html</span><br><span class="line">bytes: 15824</span><br><span class="line">duration: 0.043</span><br></pre></td></tr></table></figure><p><br></p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>Grok位于正则表达式之上，所以任何正则表达式在grok中都是有效的。<br>Regular Expression Library: <a href="https://github.com/kkos/oniguruma/blob/master/doc/RE" target="_blank" rel="noopener">https://github.com/kkos/oniguruma/blob/master/doc/RE</a></p><p><br></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>grok处理nginx/access.log日志:<br>首先针对nginx.conf中日志格式来决定如何写logstash pattern</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/logstash/patterns</span><br><span class="line"></span><br><span class="line">vim nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NGINX_ACCESS %&#123;IPORHOST:clientip&#125; (?:-|(%&#123;WORD&#125;.%&#123;WORD&#125;)) %&#123;USER:ident&#125; \[%&#123;HTTPDATE:timestamp&#125;\] &quot;(?:%&#123;WORD:verb&#125; %&#123;NOTSPACE:request&#125;(?: HTTP/%&#123;NUMBER:httpversion&#125;)?|%&#123;DATA:rawrequest&#125;)&quot; %&#123;NUMBER:response&#125; (?:%&#123;NUMBER:bytes&#125;|-) %&#123;QS:referrer&#125; %&#123;QS:agent&#125; %&#123;QS:forwarder&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grok &#123;</span><br><span class="line">  patterns_dir =&gt; &quot;/etc/logstash/patterns&quot;</span><br><span class="line">  match =&gt; &#123; &quot;message&quot; =&gt; %&#123;NGINX_ACCESS&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="grok-debugger"><a href="#grok-debugger" class="headerlink" title="grok debugger"></a>grok debugger</h4><p><img src="/images/ELK/grok.png" alt="grok debugger"></p><p><br></p><p><strong>grok-patterns</strong><br>这是grok官方写得patterns，当然，你也可以自己写。就像Nginx日志那样！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">USERNAME [a-zA-Z0-9._-]+</span><br><span class="line">USER %&#123;USERNAME&#125;</span><br><span class="line">EMAILLOCALPART [a-zA-Z][a-zA-Z0-9_.+-=:]+</span><br><span class="line">EMAILADDRESS %&#123;EMAILLOCALPART&#125;@%&#123;HOSTNAME&#125;</span><br><span class="line">INT (?:[+-]?(?:[0-9]+))</span><br><span class="line">BASE10NUM (?&lt;![0-9.+-])(?&gt;[+-]?(?:(?:[0-9]+(?:\.[0-9]+)?)|(?:\.[0-9]+)))</span><br><span class="line">NUMBER (?:%&#123;BASE10NUM&#125;)</span><br><span class="line">BASE16NUM (?&lt;![0-9A-Fa-f])(?:[+-]?(?:0x)?(?:[0-9A-Fa-f]+))</span><br><span class="line">BASE16FLOAT \b(?&lt;![0-9A-Fa-f.])(?:[+-]?(?:0x)?(?:(?:[0-9A-Fa-f]+(?:\.[0-9A-Fa-f]*)?)|(?:\.[0-9A-Fa-f]+)))\b</span><br><span class="line"></span><br><span class="line">POSINT \b(?:[1-9][0-9]*)\b</span><br><span class="line">NONNEGINT \b(?:[0-9]+)\b</span><br><span class="line">WORD \b\w+\b</span><br><span class="line">NOTSPACE \S+</span><br><span class="line">SPACE \s*</span><br><span class="line">DATA .*?</span><br><span class="line">GREEDYDATA .*</span><br><span class="line">QUOTEDSTRING (?&gt;(?&lt;!\\)(?&gt;&quot;(?&gt;\\.|[^\\&quot;]+)+&quot;|&quot;&quot;|(?&gt;&apos;(?&gt;\\.|[^\\&apos;]+)+&apos;)|&apos;&apos;|(?&gt;`(?&gt;\\.|[^\\`]+)+`)|``))</span><br><span class="line">UUID [A-Fa-f0-9]&#123;8&#125;-(?:[A-Fa-f0-9]&#123;4&#125;-)&#123;3&#125;[A-Fa-f0-9]&#123;12&#125;</span><br><span class="line"># URN, allowing use of RFC 2141 section 2.3 reserved characters</span><br><span class="line">URN urn:[0-9A-Za-z][0-9A-Za-z-]&#123;0,31&#125;:(?:%[0-9a-fA-F]&#123;2&#125;|[0-9A-Za-z()+,.:=@;$_!*&apos;/?#-])+</span><br><span class="line"></span><br><span class="line"># Networking</span><br><span class="line">MAC (?:%&#123;CISCOMAC&#125;|%&#123;WINDOWSMAC&#125;|%&#123;COMMONMAC&#125;)</span><br><span class="line">CISCOMAC (?:(?:[A-Fa-f0-9]&#123;4&#125;\.)&#123;2&#125;[A-Fa-f0-9]&#123;4&#125;)</span><br><span class="line">WINDOWSMAC (?:(?:[A-Fa-f0-9]&#123;2&#125;-)&#123;5&#125;[A-Fa-f0-9]&#123;2&#125;)</span><br><span class="line">COMMONMAC (?:(?:[A-Fa-f0-9]&#123;2&#125;:)&#123;5&#125;[A-Fa-f0-9]&#123;2&#125;)</span><br><span class="line">IPV6 ((([0-9A-Fa-f]&#123;1,4&#125;:)&#123;7&#125;([0-9A-Fa-f]&#123;1,4&#125;|:))|(([0-9A-Fa-f]&#123;1,4&#125;:)&#123;6&#125;(:[0-9A-Fa-f]&#123;1,4&#125;|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))&#123;3&#125;)|:))|(([0-9A-Fa-f]&#123;1,4&#125;:)&#123;5&#125;(((:[0-9A-Fa-f]&#123;1,4&#125;)&#123;1,2&#125;)|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))&#123;3&#125;)|:))|(([0-9A-Fa-f]&#123;1,4&#125;:)&#123;4&#125;(((:[0-9A-Fa-f]&#123;1,4&#125;)&#123;1,3&#125;)|((:[0-9A-Fa-f]&#123;1,4&#125;)?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))&#123;3&#125;))|:))|(([0-9A-Fa-f]&#123;1,4&#125;:)&#123;3&#125;(((:[0-9A-Fa-f]&#123;1,4&#125;)&#123;1,4&#125;)|((:[0-9A-Fa-f]&#123;1,4&#125;)&#123;0,2&#125;:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))&#123;3&#125;))|:))|(([0-9A-Fa-f]&#123;1,4&#125;:)&#123;2&#125;(((:[0-9A-Fa-f]&#123;1,4&#125;)&#123;1,5&#125;)|((:[0-9A-Fa-f]&#123;1,4&#125;)&#123;0,3&#125;:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))&#123;3&#125;))|:))|(([0-9A-Fa-f]&#123;1,4&#125;:)&#123;1&#125;(((:[0-9A-Fa-f]&#123;1,4&#125;)&#123;1,6&#125;)|((:[0-9A-Fa-f]&#123;1,4&#125;)&#123;0,4&#125;:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))&#123;3&#125;))|:))|(:(((:[0-9A-Fa-f]&#123;1,4&#125;)&#123;1,7&#125;)|((:[0-9A-Fa-f]&#123;1,4&#125;)&#123;0,5&#125;:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d))&#123;3&#125;))|:)))(%.+)?</span><br><span class="line">IPV4 (?&lt;![0-9])(?:(?:[0-1]?[0-9]&#123;1,2&#125;|2[0-4][0-9]|25[0-5])[.](?:[0-1]?[0-9]&#123;1,2&#125;|2[0-4][0-9]|25[0-5])[.](?:[0-1]?[0-9]&#123;1,2&#125;|2[0-4][0-9]|25[0-5])[.](?:[0-1]?[0-9]&#123;1,2&#125;|2[0-4][0-9]|25[0-5]))(?![0-9])</span><br><span class="line">IP (?:%&#123;IPV6&#125;|%&#123;IPV4&#125;)</span><br><span class="line">HOSTNAME \b(?:[0-9A-Za-z][0-9A-Za-z-]&#123;0,62&#125;)(?:\.(?:[0-9A-Za-z][0-9A-Za-z-]&#123;0,62&#125;))*(\.?|\b)</span><br><span class="line">IPORHOST (?:%&#123;IP&#125;|%&#123;HOSTNAME&#125;)</span><br><span class="line">HOSTPORT %&#123;IPORHOST&#125;:%&#123;POSINT&#125;</span><br><span class="line"></span><br><span class="line"># paths</span><br><span class="line">PATH (?:%&#123;UNIXPATH&#125;|%&#123;WINPATH&#125;)</span><br><span class="line">UNIXPATH (/([\w_%!$@:.,+~-]+|\\.)*)+</span><br><span class="line">TTY (?:/dev/(pts|tty([pq])?)(\w+)?/?(?:[0-9]+))</span><br><span class="line">WINPATH (?&gt;[A-Za-z]+:|\\)(?:\\[^\\?*]*)+</span><br><span class="line">URIPROTO [A-Za-z]([A-Za-z0-9+\-.]+)+</span><br><span class="line">URIHOST %&#123;IPORHOST&#125;(?::%&#123;POSINT:port&#125;)?</span><br><span class="line"># uripath comes loosely from RFC1738, but mostly from what Firefox</span><br><span class="line"># doesn&apos;t turn into %XX</span><br><span class="line">URIPATH (?:/[A-Za-z0-9$.+!*&apos;()&#123;&#125;,~:;=@#%&amp;_\-]*)+</span><br><span class="line">#URIPARAM \?(?:[A-Za-z0-9]+(?:=(?:[^&amp;]*))?(?:&amp;(?:[A-Za-z0-9]+(?:=(?:[^&amp;]*))?)?)*)?</span><br><span class="line">URIPARAM \?[A-Za-z0-9$.+!*&apos;|()&#123;&#125;,~@#%&amp;/=:;_?\-\[\]&lt;&gt;]*</span><br><span class="line">URIPATHPARAM %&#123;URIPATH&#125;(?:%&#123;URIPARAM&#125;)?</span><br><span class="line">URI %&#123;URIPROTO&#125;://(?:%&#123;USER&#125;(?::[^@]*)?@)?(?:%&#123;URIHOST&#125;)?(?:%&#123;URIPATHPARAM&#125;)?</span><br><span class="line"></span><br><span class="line"># Months: January, Feb, 3, 03, 12, December</span><br><span class="line">MONTH \b(?:[Jj]an(?:uary|uar)?|[Ff]eb(?:ruary|ruar)?|[Mm](?:a|ä)?r(?:ch|z)?|[Aa]pr(?:il)?|[Mm]a(?:y|i)?|[Jj]un(?:e|i)?|[Jj]ul(?:y)?|[Aa]ug(?:ust)?|[Ss]ep(?:tember)?|[Oo](?:c|k)?t(?:ober)?|[Nn]ov(?:ember)?|[Dd]e(?:c|z)(?:ember)?)\b</span><br><span class="line">MONTHNUM (?:0?[1-9]|1[0-2])</span><br><span class="line">MONTHNUM2 (?:0[1-9]|1[0-2])</span><br><span class="line">MONTHDAY (?:(?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9])</span><br><span class="line"></span><br><span class="line"># Days: Monday, Tue, Thu, etc...</span><br><span class="line">DAY (?:Mon(?:day)?|Tue(?:sday)?|Wed(?:nesday)?|Thu(?:rsday)?|Fri(?:day)?|Sat(?:urday)?|Sun(?:day)?)</span><br><span class="line"></span><br><span class="line"># Years?</span><br><span class="line">YEAR (?&gt;\d\d)&#123;1,2&#125;</span><br><span class="line">HOUR (?:2[0123]|[01]?[0-9])</span><br><span class="line">MINUTE (?:[0-5][0-9])</span><br><span class="line"># &apos;60&apos; is a leap second in most time standards and thus is valid.</span><br><span class="line">SECOND (?:(?:[0-5]?[0-9]|60)(?:[:.,][0-9]+)?)</span><br><span class="line">TIME (?!&lt;[0-9])%&#123;HOUR&#125;:%&#123;MINUTE&#125;(?::%&#123;SECOND&#125;)(?![0-9])</span><br><span class="line"># datestamp is YYYY/MM/DD-HH:MM:SS.UUUU (or something like it)</span><br><span class="line">DATE_US %&#123;MONTHNUM&#125;[/-]%&#123;MONTHDAY&#125;[/-]%&#123;YEAR&#125;</span><br><span class="line">DATE_EU %&#123;MONTHDAY&#125;[./-]%&#123;MONTHNUM&#125;[./-]%&#123;YEAR&#125;</span><br><span class="line">ISO8601_TIMEZONE (?:Z|[+-]%&#123;HOUR&#125;(?::?%&#123;MINUTE&#125;))</span><br><span class="line">ISO8601_SECOND (?:%&#123;SECOND&#125;|60)</span><br><span class="line">TIMESTAMP_ISO8601 %&#123;YEAR&#125;-%&#123;MONTHNUM&#125;-%&#123;MONTHDAY&#125;[T ]%&#123;HOUR&#125;:?%&#123;MINUTE&#125;(?::?%&#123;SECOND&#125;)?%&#123;ISO8601_TIMEZONE&#125;?</span><br><span class="line">DATE %&#123;DATE_US&#125;|%&#123;DATE_EU&#125;</span><br><span class="line">DATESTAMP %&#123;DATE&#125;[- ]%&#123;TIME&#125;</span><br><span class="line">TZ (?:[APMCE][SD]T|UTC)</span><br><span class="line">DATESTAMP_RFC822 %&#123;DAY&#125; %&#123;MONTH&#125; %&#123;MONTHDAY&#125; %&#123;YEAR&#125; %&#123;TIME&#125; %&#123;TZ&#125;</span><br><span class="line">DATESTAMP_RFC2822 %&#123;DAY&#125;, %&#123;MONTHDAY&#125; %&#123;MONTH&#125; %&#123;YEAR&#125; %&#123;TIME&#125; %&#123;ISO8601_TIMEZONE&#125;</span><br><span class="line">DATESTAMP_OTHER %&#123;DAY&#125; %&#123;MONTH&#125; %&#123;MONTHDAY&#125; %&#123;TIME&#125; %&#123;TZ&#125; %&#123;YEAR&#125;</span><br><span class="line">DATESTAMP_EVENTLOG %&#123;YEAR&#125;%&#123;MONTHNUM2&#125;%&#123;MONTHDAY&#125;%&#123;HOUR&#125;%&#123;MINUTE&#125;%&#123;SECOND&#125;</span><br><span class="line"></span><br><span class="line"># Syslog Dates: Month Day HH:MM:SS</span><br><span class="line">SYSLOGTIMESTAMP %&#123;MONTH&#125; +%&#123;MONTHDAY&#125; %&#123;TIME&#125;</span><br><span class="line">PROG [\x21-\x5a\x5c\x5e-\x7e]+</span><br><span class="line">SYSLOGPROG %&#123;PROG:program&#125;(?:\[%&#123;POSINT:pid&#125;\])?</span><br><span class="line">SYSLOGHOST %&#123;IPORHOST&#125;</span><br><span class="line">SYSLOGFACILITY &lt;%&#123;NONNEGINT:facility&#125;.%&#123;NONNEGINT:priority&#125;&gt;</span><br><span class="line">HTTPDATE %&#123;MONTHDAY&#125;/%&#123;MONTH&#125;/%&#123;YEAR&#125;:%&#123;TIME&#125; %&#123;INT&#125;</span><br><span class="line"></span><br><span class="line"># Shortcuts</span><br><span class="line">QS %&#123;QUOTEDSTRING&#125;</span><br><span class="line"></span><br><span class="line"># Log formats</span><br><span class="line">SYSLOGBASE %&#123;SYSLOGTIMESTAMP:timestamp&#125; (?:%&#123;SYSLOGFACILITY&#125; )?%&#123;SYSLOGHOST:logsource&#125; %&#123;SYSLOGPROG&#125;:</span><br><span class="line"></span><br><span class="line"># Log Levels</span><br><span class="line">LOGLEVEL ([Aa]lert|ALERT|[Tt]race|TRACE|[Dd]ebug|DEBUG|[Nn]otice|NOTICE|[Ii]nfo|INFO|[Ww]arn?(?:ing)?|WARN?(?:ING)?|[Ee]rr?(?:or)?|ERR?(?:OR)?|[Cc]rit?(?:ical)?|CRIT?(?:ICAL)?|[Ff]atal|FATAL|[Ss]evere|SEVERE|EMERG(?:ENCY)?|[Ee]merg(?:ency)?)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>这是一个json解析过滤器。</p><p><br></p><p><strong>Json Filter配置项</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>skip_on_invalid_json</td><td>boolean</td><td>No</td></tr><tr><td>source</td><td>string</td><td>Yes</td></tr><tr><td>tag_on_failure</td><td>array</td><td>No</td></tr><tr><td>target</td><td>string</td><td>No</td></tr></tbody></table><ul><li><p><code>skip_on_invalid_json</code><br>默认值是false.允许跳过无效json上的过滤器。</p></li><li><p><code>source</code><br>json filter的配置<br>如，从message字段中解析json</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  json &#123;</span><br><span class="line">    source =&gt; &quot;message&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>target</code><br>定义放置解析数据的目标字段。如果目标字段已存在，则它会被覆盖。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  json &#123;</span><br><span class="line">    target =&gt; &quot;doc&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="kv"><a href="#kv" class="headerlink" title="kv"></a>kv</h3><p>此过滤器有助于自动解析<code>key=value</code>类型的消息。<br>这对于postfix, iptables和倾向于key=value语法类型的日志非常有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#before</span><br><span class="line">ip=1.2.3.4 error=REFUSED</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  kv &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#after</span><br><span class="line">ip: 1.2.3.4</span><br><span class="line">error: REFUSED</span><br></pre></td></tr></table></figure><p><br></p><p><strong>kv filter配置项</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>allow_duplicate_values</td><td>boolean</td><td>No</td></tr><tr><td>default_keys</td><td>hash</td><td>No</td></tr><tr><td>exclude_keys</td><td>array</td><td>No</td></tr><tr><td>field_split</td><td>string</td><td>No</td></tr><tr><td>include_brackets</td><td>boolean</td><td>No</td></tr><tr><td>include_keys</td><td>array</td><td>No</td></tr><tr><td>prefix</td><td>string</td><td>No</td></tr><tr><td>recursive</td><td>boolean</td><td>No</td></tr><tr><td>remove_char_key</td><td>string</td><td>No</td></tr><tr><td>remove_char_value</td><td>string</td><td>No</td></tr><tr><td>source</td><td>string</td><td>No</td></tr><tr><td>target</td><td>string</td><td>No</td></tr><tr><td>transform_key</td><td>string,</td><td>one of [“lowercase”, “uppercase”, “capitalize”]</td><td>No</td></tr><tr><td>transform_value</td><td>string,</td><td>one of [“lowercase”, “uppercase”, “capitalize”]</td><td>No</td></tr><tr><td>trim_key</td><td>string</td><td>No</td></tr><tr><td>trim_value</td><td>string</td><td>No</td></tr><tr><td>value_split</td><td>string</td><td>No</td></tr></tbody></table><ul><li><p><code>allow_duplicate_values</code><br>默认值为true.用于删除重复 键/值对的布尔选项。</p></li><li><p><code>default_keys</code><br>默认值为{}.一个散列，用于指定在解析源字段中不存在的键时应添加到事件中的默认值及其值。</p></li><li><p><code>exclude_keys</code><br>默认值为[].一个数组，用于指定不应添加到事件中的解析键。默认情况下，没有键被排除。</p></li><li><p><code>field_split</code><br>默认值为<code>&quot; &quot;</code>.用作解析出键值对后的单字符字段分隔符的字符串。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#栗子</span><br><span class="line">name=zhang21&amp;age=25&amp;email=ab123@gamil.com</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  kv &#123;</span><br><span class="line">    field_split =&gt; &quot;&amp;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>field_split_pattern</code><br>一个正则表达式，用作字段分隔符来解析键值对。用于定义多字符字段分隔符。<br>它优先于<code>field_split</code>选项。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#栗子</span><br><span class="line">k1=v1:k2=v2:::k3=v3::k4=v4</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  kv &#123;</span><br><span class="line">    field_split_pattern =&gt; &quot;:+&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>include_brackets</code><br>默认值为true.一个布尔值，指定是否将 方括号[square bracket]，尖括号<angle bracket="">和括号(bracket) 视为的包装器(wrapper)，是否应该从值中删除。</angle></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#栗子</span><br><span class="line">one=(o n e) two=[t w o] three=&lt;t h r e e&gt;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  kv &#123;</span><br><span class="line">    include_brackets =&gt; tree</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#after</span><br><span class="line">one: o n e</span><br><span class="line">two: t w o</span><br><span class="line">three: t h r e e</span><br></pre></td></tr></table></figure><ul><li><p><code>include_keys</code><br>默认值为[].一个数字，用于指定应该添加到解析的键。默认情况下，所有的键都会被添加。</p></li><li><p><code>prefix</code><br>默认值为空。预先添加到所有提取的键的字符串。</p></li><li><p><code>recursive</code><br>默认值为false.一个布尔值，执行是否向下提取值并递归获取更多的键值对。</p></li><li><p><code>remove_char_key</code><br>要从键中移除的字符串。</p></li><li><p><code>remove_char_value</code><br>要从值中移除的字符串。</p></li><li><p><code>source</code><br>默认值为message.要在其上执行key=value搜索的字段。</p></li><li><p><code>target</code><br>将所有键值对放入的容器的名称。</p></li><li><p><code>transform_key</code><br>将键转换为大写，小写。</p></li><li><p><code>transform_value</code><br>将值转换为大写，小写</p></li><li><p><code>trim_key</code><br>从键中修建的字符串。如果键包含在括号中或以空格开头，这很有用。</p></li><li><p><code>trim_value</code><br>从值中修建的字符串。如果你的值包含在括号中或以逗号结尾。这很有用。</p></li><li><p><code>value_split</code><br>默认值为<code>=</code>.一个非空字符串，用作解析出键值对的单字符分隔符。</p></li><li><p><code>value_split_pattern</code><br>用作值分隔符来解析出键值对的正则表达式。优先级高于<code>value_split</code>。</p></li></ul><p><br><br><br></p><h3 id="metrics"><a href="#metrics" class="headerlink" title="metrics"></a>metrics</h3><p>metrics filter用于聚合度量(aggregating metrics).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#计算每种http响应吗</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  metrics &#123;</span><br><span class="line">    meter =&gt; [ &quot;http_%&#123;response&#125;&quot; ]</span><br><span class="line">    add_tag =&gt; &quot;metric&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>metrics filter配置项</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>clear_interval</td><td>number</td><td>No</td></tr><tr><td>flush_interval</td><td>number</td><td>No</td></tr><tr><td>ignore_older_than</td><td>number</td><td>No</td></tr><tr><td>meter</td><td>array</td><td>No</td></tr><tr><td>percentiles</td><td>array</td><td>No</td></tr><tr><td>rates</td><td>array</td><td>No</td></tr><tr><td>timer</td><td>hash</td><td>No</td></tr></tbody></table><ul><li><p><code>clear_interval</code><br>默认值为<code>-1</code>.清理间隔，所有的计数器都被重置。</p></li><li><p><code>flush_interval</code><br>默认值为<code>5</code>.刷新间隔，当metrics事件被创建时。此值必须是5的倍数。</p></li><li><p><code>ignore_older_than</code><br>默认值为<code>0</code>.不要跟着<code>@timestamp</code>超过某个秒数的事件。</p></li><li><p><code>meter</code><br>语法: <code>meter =&gt; [ &quot;name of metric&quot;, &quot;name of metric&quot; ]</code></p></li><li><p><code>percentiles</code><br>默认值为<code>percentiles</code>.计时器值应该测量和发出的百分位数。</p></li><li><p><code>rates</code><br>默认值为<code>[1, 5, 15]</code>.应该按分钟测量的比率。</p></li><li><p><code>timer</code><br>语法: <code>timer =&gt; [ &quot;name of metric&quot;, &quot;%{time_value}&quot; ]</code></p></li></ul><p><br></p><p><strong>meter values</strong><br><code>meter =&gt; &quot;something&quot;</code>, 会收到如下字段:</p><ul><li>“[thing][count]” - the total count of events</li><li>“[thing][rate_1m]” - the per-second event rate in a 1-minute sliding window</li><li>“[thing][rate_5m]” - the per-second event rate in a 5-minute sliding window</li><li>“[thing][rate_15m]” - the per-second event rate in a 15-minute sliding window</li></ul><p><strong>timer values</strong><br><code>timer =&gt; { &quot;thing&quot; =&gt; &quot;%{duration}&quot;}</code>, 会收到如下字段:</p><ul><li>“[thing][count]” - the total count of events</li><li>“[thing][rate_1m]” - the per-second average value in a 1-minute sliding window</li><li>“[thing][rate_5m]” - the per-second average value in a 5-minute sliding window</li><li>“[thing][rate_15m]” - the per-second average value in a 15-minute sliding window</li><li>“[thing][min]” - the minimum value seen for this metric</li><li>“[thing][max]” - the maximum value seen for this metric</li><li>“[thing][stddev]” - the standard deviation for this metric</li><li>“[thing][mean]” - the mean for this metric</li><li>“[thing][pXX]” - the XXth percentile for this metric (see percentiles)</li></ul><p><br><br><br></p><h3 id="mutate"><a href="#mutate" class="headerlink" title="mutate"></a>mutate</h3><p>mutate filter允许你在字段上执行常规突变。你可以重命名，删除，替换和修改事件中的字段。</p><p><br></p><p><strong>mutate filter配置项</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>convert</td><td>hash</td><td>No</td></tr><tr><td>copy</td><td>hash</td><td>No</td></tr><tr><td>gsub</td><td>array</td><td>No</td></tr><tr><td>join</td><td>hash</td><td>No</td></tr><tr><td>lowercase</td><td>array</td><td>No</td></tr><tr><td>merge</td><td>hash</td><td>No</td></tr><tr><td>coerce</td><td>hash</td><td>No</td></tr><tr><td>rename</td><td>hash</td><td>No</td></tr><tr><td>replace</td><td>hash</td><td>No</td></tr><tr><td>split</td><td>hash</td><td>No</td></tr><tr><td>strip</td><td>array</td><td>No</td></tr><tr><td>update</td><td>hash</td><td>No</td></tr><tr><td>uppercase</td><td>array</td><td>No</td></tr><tr><td>capitalize</td><td>array</td><td>No</td></tr></tbody></table><ul><li><p><code>convert</code><br>将字段的值转换为其它类型，如将string转换为int.如果只为数组，则所有成员都将转换；如果是散列，则不处理。</p></li><li><p><code>copy</code><br>将现有字段复制到另一个字段(会覆盖)。</p></li><li><p><code>gsub</code><br>将正则表达式与字段值进行匹配，并用替换字符替换所有匹配项。<br>只支持string或string array.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    gsub =&gt; [</span><br><span class="line">  &quot;field1&quot;, &quot;value&quot;, &quot;replacement string&quot;,</span><br><span class="line">]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>join</code><br>加入一个带分隔符的数组。对非数组字段没有任何作用。</p></li><li><p><code>lowercase</code><br>将字符串转换为小写</p></li><li><p><code>merge</code><br>合并数组或散列的两个字段。字符串字段将被自动转换为数组。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    merge =&gt; &#123; &quot;dest_field&quot; =&gt; &quot;added_field&quot;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>coerce</code><br>为已存在但为空的字段设置默认值。</p></li><li><p><code>rename</code><br>重命名一个或多个字段。</p></li><li><p><code>replace</code><br>用新值替换一个字段。新值可以包含<code>%{foo}</code>字符串，以帮助你从事件的其它部分创建新值。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    replace =&gt; &#123;</span><br><span class="line">  &quot;message&quot; =&gt; &quot;%&#123;source_host&#125;: My new message&quot;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>split</code><br>使用分隔符将字段拆分为数组。只适用于字符串字段。</p></li><li><p><code>strip</code><br>从字段剥离空白符。</p></li><li><p><code>update</code><br>用新值更新现有字段。</p></li></ul><p><br><br><br></p><h3 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h3><p>XML filter.获取包含XML的字段并将其展开为实际的数据结构。</p><p><strong>XML Filter配置项</strong></p><table><thead><tr><th>Setting</th><th>Input_type</th><th>Required</th></tr></thead><tbody><tr><td>force_array</td><td>boolean</td><td>No</td></tr><tr><td>force_content</td><td>boolean</td><td>No</td></tr><tr><td>namespaces</td><td>hash</td><td>No</td></tr><tr><td>remove_namespaces</td><td>boolean</td><td>No</td></tr><tr><td>source</td><td>string</td><td>Yes</td></tr><tr><td>store_xml</td><td>boolean</td><td>No</td></tr><tr><td>suppress_empty</td><td>boolean</td><td>No</td></tr><tr><td>target</td><td>string</td><td>No</td></tr><tr><td>xpath</td><td>hash</td><td>No</td></tr></tbody></table><ul><li><p><code>force_array</code><br>默认值为true.过滤器强制单个元素为数组。将其设置为false防止在数组中存储单个元素。</p></li><li><p><code>force_content</code><br>默认值为false.过滤器将以不同于标签内的内容的方式展开属性。</p></li><li><p><code>namespace</code><br>默认值为<code>{}</code>.这允许配置所有命名空间声明来解析XML文档。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  xml &#123;</span><br><span class="line">    namespaces =&gt; &#123;</span><br><span class="line">      &quot;xsl&quot; =&gt; &quot;http://www.w3.org/1999/XSL/Transform&quot;</span><br><span class="line">      &quot;xhtml&quot; =&gt; &quot;http://www.w3.org/1999/xhtml&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>remove_namespaces</code><br>从文档中的所有节点中删除所有命名空间。</p></li><li><p><code>source</code></p></li><li><p><code>store_xml</code><br>默认为true.过滤器会将整个解析的XML存储在目标字段中。</p></li><li><p><code>suppress_empty</code><br>默认值为true.默认情况下，如果元素为空，这不输出。如果设置为false,则空元素将产生一个空的散列对象。</p></li><li><p><code>target</code><br>定义放置数据的目标。</p></li></ul><p><br><br><br></p><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>使用条件判断决定filter和output处理特定的事件。</p><p>Logstash条件类似于编程语言，条件语句，可以嵌套：</p><ul><li><code>if</code></li><li><code>else if</code></li><li><code>else</code></li></ul><p><br></p><p>比较操作：</p><ul><li><code>==</code></li><li><code>!=</code></li><li><code>&lt;</code></li><li><code>&gt;</code></li><li><code>&lt;=</code></li><li><code>&gt;=</code></li><li><code>=~</code> 匹配正则</li><li><code>!~</code> 不匹配正则</li><li><code>in</code> 包含</li><li><code>not in</code> 不包含</li></ul><p><br></p><p>布尔操作：</p><ul><li><code>and</code></li><li><code>or</code></li><li><code>nand</code></li><li><code>xor</code></li></ul><p><br></p><p>一元运算符：</p><ul><li><code>!</code> 取反</li><li><code>()</code> 复合表达式</li></ul><p><br></p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">  if [path] == &quot;/var/nginx/access.log&quot; &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">  hosts =&gt;</span><br><span class="line">  user =&gt;</span><br><span class="line">  password =&gt;</span><br><span class="line">  index =&gt; &quot;nginx-access-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else if [path] == &quot;/var/nginx/error.log&quot; &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">  hosts =&gt;</span><br><span class="line">  user =&gt;</span><br><span class="line">  password =&gt;</span><br><span class="line">  index =&gt; &quot;nginx-error-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="Filebeat文档"><a href="#Filebeat文档" class="headerlink" title="Filebeat文档"></a>Filebeat文档</h1><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>filebeat是一个beat，它基于libbeat框架。</p><p>Filebeat是一个本地文件的日志数据搬运(shipper)。作为Agent安装，filebeat监视日志目录或指定的日志文件，并将它们转发给Elasticsearch或logstash进行索引。<br>启动filebeat时，它会启动一个或多个<strong>prospectors</strong>，查看为日志指定的本地路径。对于prospectors所在的每个日志文件，filebeat启动harvester。每个harvester为新内容读取单一日志文件，并将新日志发送到filebeat配置的输出。</p><p><br></p><p><img src="/image/ELK/filebeat.png" alt="filebeat流程图"></p><p><br><br><br></p><h2 id="入门-1"><a href="#入门-1" class="headerlink" title="入门"></a>入门</h2><p>开始filebeat前，请确保安装和配置了如下产品：</p><ul><li>Elasticsearch(存储和索引数据)</li><li>Kibana(UI)</li><li>Logstash(可选)</li></ul><p><br></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>filebeat module为常用日志格式提供了入门体验。</p><p><img src="/images/ELK/filebeat002.png" alt=""></p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/filebeat/filebeat.yml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filebeat.prospectors:</span><br><span class="line"> -type: log</span><br><span class="line">   enabled: true</span><br><span class="line">   paths:</span><br><span class="line">     - /var/log/*.log</span><br><span class="line"></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [ &quot;ip:9200&quot; ]</span><br><span class="line">  #username</span><br><span class="line">  #password</span><br><span class="line"></span><br><span class="line">setup.kibana:</span><br><span class="line">  host: &quot;localhost:5601&quot;</span><br><span class="line">  #username</span><br><span class="line">  #password</span><br></pre></td></tr></table></figure><p><br></p><h3 id="配置filebeat使用logstash"><a href="#配置filebeat使用logstash" class="headerlink" title="配置filebeat使用logstash"></a>配置filebeat使用logstash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/filebeat/filebeat.yml</span><br><span class="line"></span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [ &quot;127.0.0.1:5044&quot; ]</span><br><span class="line"></span><br><span class="line">#logstash需要配置监听beats</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="在Elasticsearch中载入索引模板"><a href="#在Elasticsearch中载入索引模板" class="headerlink" title="在Elasticsearch中载入索引模板"></a>在Elasticsearch中载入索引模板</h3><p>在Elasticsearch中，索引模板用于定义设置(setting)和映射(mapping)，以确定如何分析字段(fields)。</p><p>filebeat推荐的索引模板文件有filebeat软件包安装。在成功连接到Elasticsearch后，它会默认自动载入索引模板(<code>fields.yml</code>)。如果模板存在，它不会覆盖除，除非你配置要覆盖。<br>通过修改配置文件，你也可以禁用自动载入模板，或者载入你自己的模板。</p><p><br></p><p><strong>配置模板载入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/filebeat/filebeat.yml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setup.template.name: &quot;template-name&quot;</span><br><span class="line">setup.template.fields: &quot;/path/xxx/xxx.yml&quot;</span><br><span class="line"></span><br><span class="line">#强制覆盖已存在模板</span><br><span class="line">setup.template.overwrite: true</span><br><span class="line"></span><br><span class="line">#关闭自动载入模板</span><br><span class="line">setup.template.enabled: false</span><br></pre></td></tr></table></figure><p><br></p><p><strong>修改索引名</strong></p><ul><li>filebeat的默认索引名为 <code>filebeat-&lt;version&gt;-yyyy.MM.dd</code></li><li>在output.elasticsearch设置选项</li><li>你指定的索引名称应该包含索引的根名、索引版本和日期信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output.elasticsearch.index: &quot;customname-%&#123;[version]&#125;-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">setup.template.name: &quot;customname&quot;</span><br><span class="line">setup.template.pattern: &quot;customname-*&quot;</span><br><span class="line">setup.dashboards.index: &quot;customname-*&quot;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>手动载入模板</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filebeat setup --template</span><br></pre></td></tr></table></figure><p><br></p><p><strong>强制Kibana查看最新文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XDELETE &apos;http://localhost:9200/filebeat-*&apos;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="设置Kibana面板"><a href="#设置Kibana面板" class="headerlink" title="设置Kibana面板"></a>设置Kibana面板</h3><p>Filebeat附带了实例的Kibana dashboards, visualization和可视化搜索。<br>在使用仪表板前，你需要创建索引<code>filebeat-*</code>，并将仪表板加载到Kibana中。你可使用<code>setup</code>命令或配置文件加载它。</p><p><br></p><h3 id="启动Filebeat"><a href="#启动Filebeat" class="headerlink" title="启动Filebeat"></a>启动Filebeat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start filebeat</span><br><span class="line"></span><br><span class="line">#前台启动并查看相关信息</span><br><span class="line">filebeat -e -c filebeat.yml</span><br></pre></td></tr></table></figure><p><br></p><h3 id="查看示例Kibana仪表板"><a href="#查看示例Kibana仪表板" class="headerlink" title="查看示例Kibana仪表板"></a>查看示例Kibana仪表板</h3><p>访问你的kibana web端(<code>localhost:5601</code>)，可用Nginx做反向代理，再加上域名解析。</p><p><br></p><h3 id="快速开始常见日志格式"><a href="#快速开始常见日志格式" class="headerlink" title="快速开始常见日志格式"></a>快速开始常见日志格式</h3><p>filebeat提供了一套预构建模块，可使用它快速实施和部署日志监视方案。</p><p>先决条件：</p><ul><li>安装和配置<code>Elastic Stack</code></li><li>安装<code>filebeat</code></li><li>安装<code>Ingest Node GeoIP</code>和<code>User Agent plugins</code></li><li>验证Elasticsearch和Kibana能从filebeat接收数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch-plugin install ingest-geoip</span><br><span class="line">elasticsearch-plugin install ingest-user-agent</span><br></pre></td></tr></table></figure><p><br></p><p><strong>运行filebeat模块</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#启用模块</span><br><span class="line">filebeat modules enable nginx system</span><br><span class="line"></span><br><span class="line">#配置path</span><br><span class="line">cd /etc/filebeat/modules.d</span><br><span class="line"></span><br><span class="line">vim nginx.yml</span><br><span class="line">vim system.yml</span><br></pre></td></tr></table></figure><p>最后就可以在Kibana中可视化查看日志。</p><p>查看dashboard时，遇到一个错误: <code>Could not locate that index-pattern (id: filebeat-*)</code></p><p>解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#重新载入索引模板</span><br><span class="line">filebeat setup</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h2><p>我们可根据系统的负载情况将Filebeat的output到合适的地方，output只能有一个！<br>如果有时候系统负载过高的话，可以考虑output到Redis或Elasticsearch。</p><p>redis和logstash都还需要logstash的pipeline转交给Elasticsearch，但你可以filter。而直接使用Elasticsearch便不能过滤。</p><ul><li>Logstash</li><li>Elasticsearch</li><li>Redis</li></ul><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/filebeat/filebeat.yml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#找到output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#redis</span><br><span class="line">output.redis:</span><br><span class="line">  hosts: &quot;localhost&quot;</span><br><span class="line">  port: 6379</span><br><span class="line">  key: &quot;filebeat&quot;</span><br><span class="line">  #自定义key-name</span><br><span class="line">  #password:</span><br><span class="line">  #db:</span><br><span class="line">  #data_type: &apos;list&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#logstash</span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [ &quot;localhost:5044&quot; ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Elasticsearch</span><br><span class="line">elasticsearch.output:</span><br><span class="line">  hosts: [ &quot;localhost:9200&quot; ]</span><br><span class="line">  #username:</span><br><span class="line">  #name:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">#redis对应的pipeline</span><br><span class="line">vim /etc/logstash/conf.d/redis-pipeline.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">  redis &#123;</span><br><span class="line">    data_type =&gt; &quot;list&quot;</span><br><span class="line">    key =&gt; &quot;filebeat&quot;</span><br><span class="line">    host =&gt; &quot;localhost&quot;</span><br><span class="line">    port =&gt; 6379</span><br><span class="line">#password =&gt;</span><br><span class="line">#db =&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">#filter&#123; &#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">  hosts =&gt; [ &quot;localhost:9200&quot; ]</span><br><span class="line">#user</span><br><span class="line">#password</span><br><span class="line">index =&gt; &quot;filebeat-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="定义索引"><a href="#定义索引" class="headerlink" title="定义索引"></a>定义索引</h3><p>为filebeat定义index:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/filebeat/filebeat.yml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#定义索引</span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;10.0.1.8:9002&quot;, &quot;10.0.1.7:9002&quot;, &quot;10.0.1.9:9002&quot;]</span><br><span class="line">  username: &quot;elastic&quot;</span><br><span class="line">  password: xxx</span><br><span class="line">  index: &quot;filebeat-publish-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加这几项</span><br><span class="line">setup.template.name: &quot;filebeat&quot;</span><br><span class="line">setup.template.pattern: &quot;filebeat-*&quot;</span><br><span class="line">setup.template.fields: &quot;fields.yml&quot;</span><br><span class="line">setup.template.overwrite: false</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="Kibana文档"><a href="#Kibana文档" class="headerlink" title="Kibana文档"></a>Kibana文档</h1><p>Kibana是一个开源分析和可视化平台，旨在与Elasticsearch合作。你可使用Kibana来检索(search)，查看(view)存储在Elasticsearch索引中的数据并与其进行交互(interact)。你可以很轻松地执行高级数据分析，并在各种图表、表格和地图中可视化你的数据。<br>Kibana可以很容易地理解大量的数据。基于浏览器的接口能够快速创建和分享动态仪表盘，实时显示Elasticsearch查询的变化。</p><p><br><br><br></p><h2 id="入门-2"><a href="#入门-2" class="headerlink" title="入门"></a>入门</h2><p>在开始前，请确保已安装Kibana并与Elasticsearch建立了连接。</p><p><br><br><br></p><h3 id="载入示例数据"><a href="#载入示例数据" class="headerlink" title="载入示例数据"></a>载入示例数据</h3><p>本节依赖如下示例数据：</p><ul><li>shakespeare.json: <a href="https://download.elastic.co/demos/kibana/gettingstarted/shakespeare_6.0.json" target="_blank" rel="noopener">https://download.elastic.co/demos/kibana/gettingstarted/shakespeare_6.0.json</a></li><li>accounts.zip: <a href="https://download.elastic.co/demos/kibana/gettingstarted/accounts.zip" target="_blank" rel="noopener">https://download.elastic.co/demos/kibana/gettingstarted/accounts.zip</a><ul><li><code>uzip accounts.zip</code></li></ul></li><li>logs.jsonl.gz: <a href="https://download.elastic.co/demos/kibana/gettingstarted/logs.jsonl.gz" target="_blank" rel="noopener">https://download.elastic.co/demos/kibana/gettingstarted/logs.jsonl.gz</a><ul><li><code>gunzip logs.jsonl.gz</code></li></ul></li></ul><p><br></p><p>shakespeare按以下模式组织：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"line_id"</span>: INT,</span><br><span class="line">    <span class="attr">"play_name"</span>: <span class="string">"String"</span>,</span><br><span class="line">    <span class="attr">"speech_number"</span>: INT,</span><br><span class="line">    <span class="attr">"line_number"</span>: <span class="string">"String"</span>,</span><br><span class="line">    <span class="attr">"speaker"</span>: <span class="string">"String"</span>,</span><br><span class="line">    <span class="attr">"text_entry"</span>: <span class="string">"String"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>accounts按以下模式组织：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"account_number"</span>: INT,</span><br><span class="line">    <span class="attr">"balance"</span>: INT,</span><br><span class="line">    <span class="attr">"firstname"</span>: <span class="string">"String"</span>,</span><br><span class="line">    <span class="attr">"lastname"</span>: <span class="string">"String"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: INT,</span><br><span class="line">    <span class="attr">"gender"</span>: <span class="string">"M or F"</span>,</span><br><span class="line">    <span class="attr">"address"</span>: <span class="string">"String"</span>,</span><br><span class="line">    <span class="attr">"employer"</span>: <span class="string">"String"</span>,</span><br><span class="line">    <span class="attr">"email"</span>: <span class="string">"String"</span>,</span><br><span class="line">    <span class="attr">"city"</span>: <span class="string">"String"</span>,</span><br><span class="line">    <span class="attr">"state"</span>: <span class="string">"String"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>日志数据的模式有许多不同的字段，此例使用字段如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"memory"</span>: INT,</span><br><span class="line">    <span class="attr">"geo.coordinates"</span>: <span class="string">"geo_point"</span>,</span><br><span class="line">    <span class="attr">"@timestamp"</span>: <span class="string">"date"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>载入数据前，需要为字段设置映射。<br>映射将索引中的文档分成逻辑组，并指定字段特性。如可搜索性、标记化、分解为单独的单词。</p><p>在Kibana界面中的<code>Dev Tools</code>中输入如下命令，为shakespeare数据设置映射。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /shakespeare</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"mappings"</span>: &#123;</span><br><span class="line">  <span class="string">"doc"</span>: &#123;</span><br><span class="line">   <span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"speaker"</span>: &#123;<span class="string">"type"</span>: <span class="string">"keyword"</span>&#125;,</span><br><span class="line">    <span class="string">"play_name"</span>: &#123;<span class="string">"type"</span>: <span class="string">"keyword"</span>&#125;,</span><br><span class="line">    <span class="string">"line_id"</span>: &#123;<span class="string">"type"</span>: <span class="string">"integer"</span>&#125;,</span><br><span class="line">    <span class="string">"speech_number"</span>: &#123;<span class="string">"type"</span>: <span class="string">"integer"</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>日志数据集<code>logs.jsonl</code>需要映射才能将日志中的经纬度标记为地理位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT /logstash-2015.05.18</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;log&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;geo&quot;: &#123;</span><br><span class="line">          &quot;properties&quot;: &#123;</span><br><span class="line">            &quot;coordinates&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;geo_point&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT /logstash-2015.05.19</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;log&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;geo&quot;: &#123;</span><br><span class="line">          &quot;properties&quot;: &#123;</span><br><span class="line">            &quot;coordinates&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;geo_point&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT /logstash-2015.05.20</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;log&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;geo&quot;: &#123;</span><br><span class="line">          &quot;properties&quot;: &#123;</span><br><span class="line">            &quot;coordinates&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;geo_point&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><code>accounts</code>数据集不需要映射，这一点上使用Elasticsearch的<code>bulk</code> API去载入数据集：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这些命令要花一些时间</span></span><br><span class="line"></span><br><span class="line">curl -H <span class="string">'Content-Type: application/x-ndjson'</span> -XPOST <span class="string">'localhost:9200/bank/account/_bulk?pretty'</span> --data-binary @accounts.json</span><br><span class="line">curl -H <span class="string">'Content-Type: application/x-ndjson'</span> -XPOST <span class="string">'localhost:9200/shakespeare/doc/_bulk?pretty'</span> --data-binary @shakespeare_6.0.json</span><br><span class="line">curl -H <span class="string">'Content-Type: application/x-ndjson'</span> -XPOST <span class="string">'localhost:9200/_bulk?pretty'</span> --data-binary @logs.jsonl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#验证</span></span><br><span class="line"><span class="comment">#在Kibana中的DevTools中运行</span></span><br><span class="line">GET /_cat/indices?v</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="定义你的索引模式"><a href="#定义你的索引模式" class="headerlink" title="定义你的索引模式"></a>定义你的索引模式</h3><p>加载到Elasticsearch的每组数据集都有一个索引模式(index pattern)。索引模式是一个带有可匹配多个索引的可使用通配符的字符串。</p><p>在前面，Shakespeare数据集有一个名为: <code>shakespeare</code> 的索引；Account数据集有一个名为：<code>bank</code> 的索引。<br>如，在常见的日志文件中，一个典型的索引包含<code>YYYY.MM.DD</code>日期格式，类似于<code>logstash-2015.05.*</code>。</p><p>进入Kibana界面，点击<strong>Management</strong>， <strong>Index Patterns</strong>， <strong>Create Index Pattern</strong> 来创建一个索引模式。</p><p><code>shakespeare</code>和<code>account</code>数据集不包含 <code>time-series data</code>。确保为此数据集创建索引模式时，不包含基于时间的事件。<code>logs</code>数据集包含了时序数据，因此索引需要包含基于时间的事件。</p><ul><li><code>shakes*</code></li><li><code>ba*</code></li><li><code>logstash-2015*</code></li></ul><p><br></p><p><strong>定义索引模式时，与Elasticsearch匹配的索引必须存在。</strong></p><p>在Kibana的DevTools中输入: <code>GET _cat/indices</code> 来查看索引。</p><p><br><br><br></p><h3 id="数据发现"><a href="#数据发现" class="headerlink" title="数据发现"></a>数据发现</h3><p>点击Kibana界面中的Discover以显示数据发现功能。</p><p><br><br><br></p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>Visualize</p><p>Visualize允许你在Elasticsearch索引中创建数据的可视化。然后可以构建显示相关可视化的仪表盘。</p><p>Kibana的可视化基于Elasticsearch查询。通过使用一系列Elasticsearch聚合来提取和处理你的数据。你可以创建图标来显示你需要了解的趋势。</p><p><br></p><h3 id="创建可视化"><a href="#创建可视化" class="headerlink" title="创建可视化"></a>创建可视化</h3><p><br><br><br></p><hr><p><br></p><h1 id="Elasticsearch文档"><a href="#Elasticsearch文档" class="headerlink" title="Elasticsearch文档"></a>Elasticsearch文档</h1><h2 id="入门-3"><a href="#入门-3" class="headerlink" title="入门"></a>入门</h2><p>Elasticsearch是一个高度可扩展的开源全文搜索和分析引擎。它允许你快速、近乎实时地存储、搜索和分析大量数据。</p><p>Elasticsearch的几个例子：</p><ul><li>使用Elasticsearch来存储产品目录和库存，并为其提供搜索和建议</li><li>收集日志或交易数据，并分析和挖掘数据以便于查找趋势、统计数据、汇总或异常信息</li><li>价格提醒平台，允许顾客制定规则，收到相应规则信息</li><li>分析智能需求，快速调查、分析、可视化并对大量数据提出特别的问题</li></ul><p><br><br><br></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>Near Realtime(NRT)</strong><br>Elasticsearch是一个近乎实时的搜索平台。这意味着从索引文档到可搜索之间存在轻微的延迟(通常为1s)</p><p><br></p><p><strong>Cluster</strong><br>集群是一个或多个节点(服务器)的集合，它们一起保存所有数据，并提供跨节点的联合索引和搜索功能。集群由默认名为<code>elasticsearch</code>的唯一名称标识，它很重要。<br>确保不要在不同的环境中重复使用相同集群名称，否则可能会导致节点加入错误的集群。<br>集群可以只有一个节点！你也可以拥有多个独立的集群，每个集群有自己唯一的集群名称。</p><p><br></p><p><strong>Node</strong><br>节点是属于集群一部分的单个服务器，存储数据并参与集群的索引和索引。<br>与集群一样，一个节点由一个名称来标识，启动时随机分配的UUID。你也可以自定义节点名。<br>配置节点通过集群名称加入特定的集群，默认加入<code>elasticsearch</code>集群。<br>在单集群中，你可以拥有任意数量的节点。</p><p><br></p><p><strong>Index</strong><br>索引是一些具有相似特征的文档集合。例如，客户数据的索引，产品目录的索引，订单数据的索引……<br>索引由名称标识(必须全小写)，文档执行索引、搜索、更新和删除操作时引用索引。<br>在一个单集群中，你可以定义任何你想要的索引。</p><p><br></p><p><strong>Document</strong><br>文档是可被索引的基本信息单位。例如，单个客户的文档，单个产品的文档，单个订单的文档…<br>文档以JSON格式表示。<br>一条记录就是一个文档。</p><p><br></p><p><strong>Shards和Replicas</strong><br>索引可潜在地存储大量数据，这些数据可能会超多单个节点的硬件限制。例如，占用1TB磁盘空间的十亿文档的单个索引可能不适合单个节点的磁盘，或者可能太慢而无法单独向单个节点提供搜索请求。<br>为了解决这个问题，Elasticsearch提供了将索引细分为称为分片的多个碎片上。当你创建索引时，你可以简单定义所需的分片数量。<br>每个分片本身都是一个功能齐全且独立的索引，可以在集群中的任何节点上进行托管。</p><p>分片重要的两个原因：</p><ul><li>允许你水平分割/缩放内容量</li><li>允许分布和并行操作跨分片，从而提高性能和吞吐量(throughput)</li></ul><p>在任何时候都可能出现的网络环境中，强烈建议使用故障切换机制，以防止分片/节点因任何原因而消失。为此，Elasticsearch允许你将索引分片制作为一个或多个称为副本分片的副本集。<br>副本集分片永远不会分配到与原始分片相同的节点上。</p><p>副本集重要的原因：</p><ul><li>在分片/节点失效的情况下提供高可用性</li><li>因为搜索可以在所有副本上并行执行，它允许你扩展搜索量和吞吐量</li></ul><p>总而言之，每个索引都可以分成多个分片，索引也可以被复制。一旦复制，每个索引将具有主分片和副本分片。在创建索引时，可为每个索引定义分片和副本数量。在索引创建之后，你可以动态更改副本的数量，但无法更改分片的数量。</p><p>默认情况下，Elasticsearch中的每个索引都分配了5个主分片和副本。</p><p>每个Elasticsearch分片都是一个Lucene索引。单个Lucene索引有最大文档数量限制。</p><p><br><br><br></p><h2 id="探索你的集群"><a href="#探索你的集群" class="headerlink" title="探索你的集群"></a>探索你的集群</h2><p><strong>The REST API</strong><br>REST(Representational State Transfer)表现层状态转换，是一种万维网软件架构风格，目的是便于不同程序在网络中互相传递信息。REST通常使用HTTP, URI, XML和HTML这些协议和标准。</p><p>启动节点，下一步便是理解如何与它通信。幸运的是，Elasticsearch提供了一个非常全面(comprehensive)和强大的REST API，可以使用它与集群进行交互。</p><p>使用API可以完成如下几件事：</p><ul><li>检查集群、节点和索引的健康、状态和统计信息</li><li>管理集群、节点、索引数据和元数据</li><li>执行CRUD(create, read, update, delete)</li><li>执行高级搜索操作(分页、排序、过滤、脚本、聚合…)</li></ul><p><br><br><br></p><h3 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h3><p>基本健康检查，看看集群正在做什么。<br>使用<code>_cat</code>API检查集群健康。可使用Kibana Console或curl等工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#Kibana</span><br><span class="line">GET /_cat/health?v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#cmd</span><br><span class="line">curl -X GET &quot;localhost:9200/_cat/health?v&quot; -u elastic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">epoch      timestamp cluster    status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class="line">1525330981 15:03:01  docker-elk yellow          1         1     32  32    0    0        6             0                  -                 84.2%</span><br></pre></td></tr></table></figure><p>集群健康：</p><ul><li>green: 万事OK(集群功能齐全)</li><li>yellow: 所有数据可用，但一些副本尚未分配(集群功能齐全)</li><li>red: 一些数据因某种原因不可用(集群部分功能)</li></ul><p>集群名称：</p><ul><li>集群名称被修改为<code>docker-elk</code></li></ul><p><br></p><p>列出集群中的节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_cat/nodes?v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ip        heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name</span><br><span class="line">127.0.0.1           47          74  93    3.18    3.13     2.90 mdi       *      LGrAIE5</span><br></pre></td></tr></table></figure><p>随机节点名： <code>LGrAIE5</code></p><p><br><br><br></p><h3 id="列出所有索引"><a href="#列出所有索引" class="headerlink" title="列出所有索引"></a>列出所有索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /_cat/indicies?v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">health status index                             uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">green  open   .monitoring-kibana-6-2018.04.27   bsKsurh7TKaCsnekwHs3yg   1   0        870            0    328.1kb        328.1kb</span><br><span class="line">green  open   .watcher-history-7-2018.04.28     zuq3rjI8S0OSS7vcZl7kSQ   1   0        954            0      1.4mb          1.4mb</span><br><span class="line">green  open   .kibana                           8t_7lqq4TFSfelA7phgv5g   1   0        142           18    191.8kb        191.8kb</span><br><span class="line">green  open   .monitoring-es-6-2018.04.28       vtUSjqaITT28CMHArpfNoA   1   0      20436            0      9.6mb          9.6mb</span><br><span class="line">yellow open   filebeat-6.2.4-2018.05.03         sK3lIvMXS8GoRbWYCjdgzg   3   1        568            0    348.6kb        348.6kb</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>创建一个名为<code>customer</code>的索引，然后列出索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#pretty漂亮JSON显示</span><br><span class="line">PUT /customer?pretty</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">curl -X PUT &quot;localhost:9200/zhang&quot; -u elastic:elastic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /_cat/indices?v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pri主分片，rep副本</span><br><span class="line">health status index                             uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   customer                          WQ3qEnPQRW6FpVIHYVJ7yA   5   1          0            0      1.1kb          1.1kb</span><br><span class="line">yellow open   zhang                             nkOUPOWERsS1PT_wEui67g   5   1          0            0      1.1kb          1.1kb</span><br></pre></td></tr></table></figure><p>你可能注意到了，索引的健康状态是<code>yellow</code>，表明有一些副本尚未分配。<br>这个索引发生这种情况的原因是Elasticsearch默认为这个索引创建了一个副本。由于此刻我们只有一个节点在运行，因此只有在其它几点加入集群后才能分配一个副本。一旦副本分配到另外的节点，健康状态会变成<code>green</code>。</p><p><br><br><br></p><h3 id="索引和查询文档"><a href="#索引和查询文档" class="headerlink" title="索引和查询文档"></a>索引和查询文档</h3><p>现在让我们把一些东西放入<code>customer</code>索引中。讲一个简单的customer文档放入customer索引中，ID为1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">PUT /customer/_doc/1?pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">curl -X PUT -u elastic:elastic &quot;localhost:9200/customer/_doc/1?pretty&quot; -H &apos;Content-Type: application/json&apos; -d&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;</span><br><span class="line">&#125;&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;customer&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;result&quot; : &quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_seq_no&quot; : 0,</span><br><span class="line">  &quot;_primary_term&quot; : 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /customer/_doc/1?pretty</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;customer&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot;: 1,</span><br><span class="line">  &quot;found&quot;: true,</span><br><span class="line">  &quot;_source&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;John Doe&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#name:John Doe _id:1 _type:_doc _index:customer _score:1</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELETE /customer?pretty</span><br><span class="line"></span><br><span class="line">curl -X DELETE &quot;localhost:9200/customer?pretty&quot; -u elastic:elastic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;acknowledged&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>Elasticsearch几乎提示提供数据操作和搜索功能。从索引、更新、删除数据时可能会有1s延迟。数据在事物完成后立即可用。</p><p><strong>索引/替换 文档</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT /customer/_doc/1?pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#如果我修改此处文档信息，则Elasticsearch会替换之前的文档</span><br><span class="line">PUT /customer/_doc/1?pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Zhang&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#name:Zhang _id:1 _type:_doc _index:customer _score:1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#或者新增一个文档</span><br><span class="line">PUT /customer/_doc/2?pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Zhang&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#name:Zhang _id:2 _type:_doc _index:customer _score:1</span><br></pre></td></tr></table></figure><p><br></p><p><strong>未指定ID：</strong><br>ID是可选的。如果未指定ID，Elasticsearch会生成随机ID。<br>注意，此时使用<code>POST</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /customer/_doc?pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Zhang&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#name:Zhang _id:76xJJWMBddhqcmsO07A_ _type:_doc _index:customer _score:1</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>除了能够索引和替换文档，我们还可以更新文档。<br>Elasticsearch实际上并没有在原地就地更新，它是先删除旧文档，然后一次性更新索引新文档。</p><p>更新同样能够使用简单的脚本。<br>Elasticsearch提供了通过查询条件(类似于<code>SQL-UPDATE-WHERE</code>)更细多个文档的能力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">POST /customer/_doc/1/_update?pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123; &quot;name&quot;: &quot;Jane Doe&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#继续更新</span><br><span class="line">POST /customer/_doc/1/_update?pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123; &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 20&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#简单脚本</span><br><span class="line">#ctx._source指即将更新的当前源文档</span><br><span class="line">POST /customer/_doc/1/_update?pretty</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &quot;ctx._source.age += 5&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>也可通过API匹配查询，删除所匹配的文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /customer/_doc/2?pretty</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h3><p>Elasticsearch同样提供了使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/docs-bulk.html" target="_blank" rel="noopener"><code>_bulk</code>API</a>批量执行上述任何操作的功能。这是一种高效的机制，尽可能快地完成多项操作。</p><p>Bulk API不会因其中一个操作失败而停止，它将继续处理后面的动作。当它完成是，它会返回每个操作的状态，以便你可以检查是否失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /customer/_doc/_bulk?pretty</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: &quot;1&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot;: &quot;John Doe&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: &quot;2&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;name&quot;: &quot;Jane Doe&quot; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">POST /customer/_doc/_bulk?pretty</span><br><span class="line">&#123;&quot;update&quot;: &#123; &quot;_id&quot;: &quot;1&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;doc&quot;: &#123; &quot;name&quot;: &quot;John Doe becomes Jane Doe&quot; &#125; &#125;</span><br><span class="line">&#123; &quot;delete&quot;: &#123; &quot;_id&quot;: &quot;2&quot; &#125; &#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="探索你的数据"><a href="#探索你的数据" class="headerlink" title="探索你的数据"></a>探索你的数据</h2><p><strong>简单数据集</strong><br>准备一个更加真实的数据集。如下生成的JSON文档，每个文档都有如下要点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;account_number&quot;: 0,</span><br><span class="line">    &quot;balance&quot;: 16623,</span><br><span class="line">    &quot;firstname&quot;: &quot;Bradshaw&quot;,</span><br><span class="line">    &quot;lastname&quot;: &quot;Mckenzie&quot;,</span><br><span class="line">    &quot;age&quot;: 29,</span><br><span class="line">    &quot;gender&quot;: &quot;F&quot;,</span><br><span class="line">    &quot;address&quot;: &quot;244 Columbus Place&quot;,</span><br><span class="line">    &quot;employer&quot;: &quot;Euron&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;bradshawmckenzie@euron.com&quot;,</span><br><span class="line">    &quot;city&quot;: &quot;Hobucken&quot;,</span><br><span class="line">    &quot;state&quot;: &quot;CO&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>载入这个数据集</strong><br>下载Elasticsearch提供的<a href="https://raw.githubusercontent.com/elastic/elasticsearch/master/docs/src/test/resources/accounts.json" target="_blank" rel="noopener">accounts.json</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type: application/json&quot; -u elastic:elastic -XPOST &quot;localhost:9200/bank/_doc/_bulk?pretty&amp;refresh&quot; --data-binary &quot;@accounts.json&quot;</span><br><span class="line">curl &quot;localhost:9200/_cat/indices?v&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">health status index                             uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   bank                              PGSvNwQwQIOhMDr1nmXIuw   5   1       1000            0    474.7kb        474.7kb</span><br></pre></td></tr></table></figure><p>这样我们成功批量索引了1000个文档到bank索引。</p><p><br><br><br></p><h3 id="Search-API"><a href="#Search-API" class="headerlink" title="Search API"></a>Search API</h3><p>现在让我们做一些简单的搜索(search)。有两种基本搜索方式：</p><ul><li>REST request URI</li><li>REST request body<ul><li>以可读的JSON格式定义你的搜索，推荐方式</li></ul></li></ul><p><br></p><p>搜索的REST API可从<code>_search</code>端点访问:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#在bank索引下的_search端点搜索</span><br><span class="line">#匹配所有文档，并以账户字段顺序排列</span><br><span class="line">#最后以可读的JSON格式输出结果</span><br><span class="line">GET /bank/_search?q=*&amp;sort=account_number:asc&amp;pretty</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 63,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 5,</span><br><span class="line">    &quot;successful&quot; : 5,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 1000,</span><br><span class="line">    &quot;max_score&quot; : null,</span><br><span class="line">    &quot;hits&quot; : [ &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;bank&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;0&quot;,</span><br><span class="line">      &quot;sort&quot;: [0],</span><br><span class="line">      &quot;_score&quot; : null,</span><br><span class="line">      &quot;_source&quot; : &#123;&quot;account_number&quot;:0,&quot;balance&quot;:16623,&quot;firstname&quot;:&quot;Bradshaw&quot;,&quot;lastname&quot;:&quot;Mckenzie&quot;,&quot;age&quot;:29,&quot;gender&quot;:&quot;F&quot;,&quot;address&quot;:&quot;244 Columbus Place&quot;,&quot;employer&quot;:&quot;Euron&quot;,&quot;email&quot;:&quot;bradshawmckenzie@euron.com&quot;,&quot;city&quot;:&quot;Hobucken&quot;,&quot;state&quot;:&quot;CO&quot;&#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;bank&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">      &quot;sort&quot;: [1],</span><br><span class="line">      &quot;_score&quot; : null,</span><br><span class="line">      &quot;_source&quot; : &#123;&quot;account_number&quot;:1,&quot;balance&quot;:39225,&quot;firstname&quot;:&quot;Amber&quot;,&quot;lastname&quot;:&quot;Duke&quot;,&quot;age&quot;:32,&quot;gender&quot;:&quot;M&quot;,&quot;address&quot;:&quot;880 Holmes Lane&quot;,&quot;employer&quot;:&quot;Pyrami&quot;,&quot;email&quot;:&quot;amberduke@pyrami.com&quot;,&quot;city&quot;:&quot;Brogan&quot;,&quot;state&quot;:&quot;IL&quot;&#125;</span><br><span class="line">    &#125;, ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>took</code>: Elasticsearch执行搜索花费的事件(ms)</li><li><code>timed_out</code>: 查询超时与否</li><li><code>_shards</code>: 搜索了多少分片，包含成功和失败的次数</li><li><code>hits</code>: 搜索结果</li><li><code>hits.total</code>: 匹配搜索的文档数</li><li><code>hits.hits</code>: 搜索结果数组(默认前十个文档)</li><li><code>hits.sort</code>: 结果的排序键</li><li><code>hits._score</code>, <code>max_score</code>: 忽略的字段</li></ul><p><br></p><p>REST request body方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123; &quot;account_number&quot;: &quot;asc&quot; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h3><p>Elasticsearch提供了可用于执行查询的JSON格式语言，这被称为 <strong>Query DSL</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#上一个查询栗子</span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理<code>query</code>参数，我们还可以传递其它参数来搜索结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#size参数，返回从from开始多少个文档</span><br><span class="line">#from未指定，就默认为0</span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;size&quot;: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#from参数，指定从哪个文档索引开始</span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;from&quot;: 10,</span><br><span class="line">  &quot;size&quot;: 10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#sort参数</span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;sort&quot;: &#123; &quot;balance&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="执行搜索"><a href="#执行搜索" class="headerlink" title="执行搜索"></a>执行搜索</h3><p>搜索某些字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;_source&quot;: [&quot;account_number&quot;, &quot;balance&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;account_number&quot;: 20 &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill&quot; &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;address&quot;: &quot;mill lane&quot; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>布尔查询：</p><ul><li><code>must</code></li><li><code>should</code></li><li><code>must_not</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#must</span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;lane&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#should</span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;lane&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#must_not</span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;lane&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#组合使用must,must_not,should</span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;age&quot;: &quot;40&quot; &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;state&quot;: &quot;ID&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>前面我们跳过了称为文档分数的<code>_score</code>字段。它是文档与搜索查询匹配度相度量的一个数值。数值越大，与文档越相关。</p><p>但查询并不总是需要产生分数，特别是当它们仅用于过滤时。Elasticsearch检测这些情况并自动优化查询执行，以便不计算无用的分数。</p><ul><li><code>range query</code>: 通过一系列值来过滤文档</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;balance&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: 20000,</span><br><span class="line">            &quot;lte&quot;: 30000</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了前面这些查询类型，还有很多其它类型。由于只是入门章节，所以并不会涉及太多太难。</p><p><br><br><br></p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合(Aggregation)提供了从数据中分组和提取统计的功能。<br>考虑聚合最简单方法是将其大致等同于SQL <code>GROUP BY</code>和SQL聚合函数。</p><p>在Elasticsearch中，你可以执行返回匹配的搜索，同时还可以在一个响应中返回与匹配不同的聚合结果。你可以运行查询和多个聚合，并一次性获得多个操作的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;group_by_state&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;state.keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#类似的SQL</span><br><span class="line">SELECT state, COUNT(*) FROM bank GROUP BY state ORDER BY COUNT(*) DESC</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#group, average</span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;group_by_state&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;state.keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;average_balance&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;group_by_age&quot;: &#123;</span><br><span class="line">      &quot;range&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;age&quot;,</span><br><span class="line">        &quot;ranges&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;from&quot;: 20,</span><br><span class="line">            &quot;to&quot;: 30</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;from&quot;: 30,</span><br><span class="line">            &quot;to&quot;: 40</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;from&quot;: 40,</span><br><span class="line">            &quot;to&quot;: 50</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;group_by_gender&quot;: &#123;</span><br><span class="line">          &quot;terms&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;gender.keyword&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;aggs&quot;: &#123;</span><br><span class="line">            &quot;average_balance&quot;: &#123;</span><br><span class="line">              &quot;avg&quot;: &#123;</span><br><span class="line">                &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有很多其它聚合方法，请参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/search-aggregations.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.2/search-aggregations.html</a>。</p><p><br><br><br></p><hr><p><br></p><h1 id="Lucene查询"><a href="#Lucene查询" class="headerlink" title="Lucene查询"></a>Lucene查询</h1><p>ElasticSearch提供的一些查询方式(query types)能够被Lucene的查询解析器(query parser)语法所支持。可直接在Kibana的发现面板上直接使用。</p><p><br></p><h2 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h2><ul><li>string</li><li>“string1 string2”</li></ul><p>Kibana会匹配和展示对应的string。</p><p><br></p><h2 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h2><ul><li><code>key:value</code>: 全文搜索</li><li><code>&quot;key:value&quot;</code>： 精确搜索</li><li><code>_exists_:key</code>: 返回结果中需要有key字段</li><li><code>_missing__:key</code>: 不能含有key字段</li></ul><p>如:<code>http.code:502</code>，<code>log-levle:warn</code></p><p><br></p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><ul><li><code>?</code></li><li><code>*</code></li></ul><p>这两者都不能用作第一个字符，如<code>?.txt, *.txt</code></p><p><br></p><h2 id="正则表达式-1"><a href="#正则表达式-1" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>它也支持性能较差的正则表达式。</p><p><br></p><h2 id="模糊搜索"><a href="#模糊搜索" class="headerlink" title="模糊搜索"></a>模糊搜索</h2><ul><li><code>~</code>: 在一个单词后面加上<code>~</code>启用模糊搜索</li><li><code>~n</code>： 设置编辑距离(整数)，指定需要多少相似度，越大越接近原始值</li><li>在短语后面加<code>~</code>，可以搜索到被隔开或顺序不同的单词</li></ul><p><code>first~</code>也可以匹配到frist<br><code>&quot;hello world&quot;~5</code>表示两者之间可以隔着5个单词</p><p><br></p><h2 id="范围搜索"><a href="#范围搜索" class="headerlink" title="范围搜索"></a>范围搜索</h2><p>数值/时间/IP/字符串 类型的字段可以对某一范围进行查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">length:[100 TO 200]</span><br><span class="line">sip:[&quot;172.24.20.110&quot; TO &quot;172.24.20.140&quot;]</span><br><span class="line">date:&#123;&quot;now-6h&quot; TO &quot;now&quot;&#125;</span><br><span class="line">tag:&#123;b TO e&#125; 搜索b到e中间的字符</span><br><span class="line">count:[10 TO *] * 表示一端不限制范围</span><br><span class="line">count:[1 TO 5&#125; [ ] 表示端点数值包含在范围内，&#123; &#125; 表示端点数值不包含在范围内，可以混合使用，此语句为1到5，包括1，不包括5</span><br><span class="line"></span><br><span class="line">可以简化成以下写法：</span><br><span class="line">age:&gt;10</span><br><span class="line">age:&lt;=10</span><br><span class="line">age:(&gt;=10 AND &lt;20)</span><br></pre></td></tr></table></figure><p><br></p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>使用<code>^</code>使一个词语比另一个搜索优先级更高，默认为1。可以为0~1之间的浮点数，来降低优先级</p><p><br></p><h2 id="逻辑操作"><a href="#逻辑操作" class="headerlink" title="逻辑操作"></a>逻辑操作</h2><ul><li><code>AND</code></li><li><code>OR</code></li><li><code>NOT</code></li><li><code>+</code>: 搜索结果中必须包含此项</li><li><code>-</code>: 不能包含此项</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a OR b) AND c</span><br><span class="line"></span><br><span class="line">host:(baidu OR qq OR google) AND host:(com OR cn)</span><br></pre></td></tr></table></figure><p><br></p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><ul><li><code>\</code>：使用转义字符来转移特殊字符</li></ul><p><br></p><hr><p><br></p><h1 id="Metricbeat"><a href="#Metricbeat" class="headerlink" title="Metricbeat"></a>Metricbeat</h1><p>Metricbeat是一个轻量级的托运器(lightweight shipper), 你可从安装该软件的操作系统和服务器上定期收集指标信息。它可将收集到的指标信息或统计信息发送到指定的输出(如elasticsearch/Logstash)。</p><p>具体使用方法也和Filebeat差不多！</p><p>Metricbeat通过从服务器上运行的系统和服务收集指标来帮助你监控服务器。如：</p><ul><li>Apache</li><li>Docker</li><li>Kafka</li><li>Kubernets</li><li>HAProxy</li><li>MongoDB</li><li>MySQL</li><li>Nginx</li><li>PHP-FPM</li><li>PostgreSQL</li><li>Redis</li><li>RabbitMQ</li><li>System</li><li>Zookeeper</li><li>…</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="Packetbeat"><a href="#Packetbeat" class="headerlink" title="Packetbeat"></a>Packetbeat</h1><p>Packetbeat是一个实时网络数据包分析器，可与Elasticsearch一起提供应用程序监控和性能分析。</p><p>Packetbeat通过捕获应用服务器之间的网络流量，解码应用层协议(HTTP, MySQL, Redis…)，将请求与响应关联起来，并记录每个事务感兴趣的字段。<br>Packetbeat可以帮助你轻松地注意到后端应用程序的问题，例如错误或性能问题，并且可以更快地排除故障并进行修复。<br>Packetbeat捕获服务器之间的流量，即时分析应用层协议，并将这些消息关联到事务中。并将这些事务插入到Elasticsearch或使用Redis和Logstash的队列中。</p><p>Packetbeat支持的协议如下:</p><ul><li>ICMP</li><li>DNS</li><li>HTTP</li><li>AMQP</li><li>Cassandra</li><li>MySQL</li><li>PostgreSQL</li><li>Redis</li><li>MongoDB</li><li>Thrift-RPC</li><li>TLS</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="Heartbeat"><a href="#Heartbeat" class="headerlink" title="Heartbeat"></a>Heartbeat</h1><p>Heartbeat是一个轻量级守护进程，用以定期检查服务的状态并确定它们是否可用。与Metricbeat不同，Metricbeat只会告诉你服务器是down/up，而Heartbeat会告诉你服务是否可以访问(reached)。</p><p>当你需要验证是否满足服务级别协议的服务正常运行时间时，Heartbeat非常有用。当需要验证外部没有人能访问企私有服务器上的服务时，这也很有用。<br>你可以配置Heartbeat来ping指定主机名的所有DNS可解析的IP地址。这样，你可以检查所有负载均衡的服务，看他们是否可用。<br>配置Heartbeat时，你可以指定用于表示要检查的主机名的监视器(monitor)。每台监视器都根据你指定的时间表运行。</p><p>Heartbeat目前支持通过通过如下方式监控主机：</p><ul><li><p>ICMP<br>当你指向检查服务是否可用时，请使用icmp监视器。此功能需要root权限</p></li><li><p>TCP<br>支持SSL/TLS/proxy<br>你可以选择配置此监视器，通过发送 and/or 接收自定义有效内容来验证端点</p></li><li><p>HTTP<br>支持SSL/TLS/proxy<br>你可以选择配置此监视器，来验证该服务是否会返回预期的响应。如特定状态码，响应header或内容</p></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="Auditbeat"><a href="#Auditbeat" class="headerlink" title="Auditbeat"></a>Auditbeat</h1><p>Auditbeat是一个轻量化的托运器(shipper)，在系统上安装它，以审核(audit)系统上用户和进程的活动。</p><p>例如，你可以使用Auditbeat从Linux Audit Framework收集和集中审计事件。你还可以使用它来检查关键文件的改动，并识别潜在的安全策略违规。</p><p><br><br><br></p><hr><p><br></p><h1 id="Topbeat"><a href="#Topbeat" class="headerlink" title="Topbeat"></a>Topbeat</h1><p>在v5.0, Topbeat被Metricbeat取代！</p><p>Topbeat的版本与其它Elastic Stack组件不同步，ES是v6.2.4， 而Topbeat是v1.3。所以需要额外安装repo.</p><p>Topbeat是一个轻量化的托运器(shipper)，来定期读取系统和每个进程的CPU和内存统计信息，然后为Elasticsearch中的统计信息编制索引。</p><p><br></p><p>Topbeat通过收集如下指标来帮助你监控你的服务器:</p><p><strong>ystem-wide statistics</strong></p><ul><li>system load<ul><li>1, 5, 15</li></ul></li><li>system wide CPU usage<ul><li>user, system, idle, IOWait</li></ul></li><li>system wide memory uusage<ul><li>total, used, free</li></ul></li><li>system wide swap usage<ul><li>total, used, free</li></ul></li></ul><p><strong>Per-process statistics</strong></p><ul><li>process name</li><li>process parent pid</li><li>process state</li><li>process pid</li><li>process CPU usage</li><li>process Memory usage</li></ul><p><strong>File system statistics</strong></p><ul><li>avaliable disks</li><li>name, type, mounted</li><li>total, used, free, available</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="APM"><a href="#APM" class="headerlink" title="APM"></a>APM</h1><p>APM(Application Performance Monitoring)应用程序性能监控，自动收集应用程序内部的深入性能指标和错误。</p><p>它由三个组件组成:</p><ul><li>Agents<ul><li>Node.js</li><li>Django</li><li>Flask</li><li>Ruby on Rails</li><li>Rack</li><li>JS</li></ul></li><li>Server</li><li>UI</li></ul><p><br><br><br></p><hr><p>May 30, 2018 5:57 PM</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Elastic指南: &lt;a href=&quot;https://www.elastic.co/guide/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.elastic.co/guide/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Elasticsearch文档: &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Logstash文档: &lt;a href=&quot;https://www.elastic.co/guide/en/logstash/current/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.elastic.co/guide/en/logstash/current/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kibana文档: &lt;a href=&quot;https://www.elastic.co/guide/en/kibana/current/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.elastic.co/guide/en/kibana/current/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Filebeat文档: &lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.elastic.co/guide/en/beats/filebeat/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Metricbeat文档: &lt;a href=&quot;https://www.elastic.co/guide/en/beats/metricbeat/current/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.elastic.co/guide/en/beats/metricbeat/current/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Lucence查询语法: &lt;a href=&quot;https://wizardforcel.gitbooks.io/mastering-elasticsearch/content/chapter-1/114_README.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://wizardforcel.gitbooks.io/mastering-elasticsearch/content/chapter-1/114_README.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7.x86_64&lt;/li&gt;
&lt;li&gt;Elastcisearch v6.2.3&lt;/li&gt;
&lt;li&gt;Kibana v6.2.3&lt;/li&gt;
&lt;li&gt;Logstash v6.2.3&lt;/li&gt;
&lt;li&gt;Beats v6.2.3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Elasticsearch" scheme="https://zhang21.github.io/tags/Elasticsearch/"/>
    
      <category term="Logstash" scheme="https://zhang21.github.io/tags/Logstash/"/>
    
      <category term="Kibana" scheme="https://zhang21.github.io/tags/Kibana/"/>
    
      <category term="Filebeat" scheme="https://zhang21.github.io/tags/Filebeat/"/>
    
      <category term="Metricbeat" scheme="https://zhang21.github.io/tags/Metricbeat/"/>
    
      <category term="Heartbeat" scheme="https://zhang21.github.io/tags/Heartbeat/"/>
    
      <category term="Packetbeat" scheme="https://zhang21.github.io/tags/Packetbeat/"/>
    
      <category term="Auditbeat" scheme="https://zhang21.github.io/tags/Auditbeat/"/>
    
  </entry>
  
  <entry>
    <title>Beanstalkd</title>
    <link href="https://zhang21.github.io/2018/04/10/Beanstalkd/"/>
    <id>https://zhang21.github.io/2018/04/10/Beanstalkd/</id>
    <published>2018-04-10T08:08:11.000Z</published>
    <updated>2018-04-15T07:20:21.907Z</updated>
    
    <content type="html"><![CDATA[<p>环境：</p><ul><li>CentOS7.x86_64</li><li>Beanstalkd v1.10</li></ul><p><br><br><br></p><a id="more"></a><p><br></p><h1 id="Beanstalkd介绍"><a href="#Beanstalkd介绍" class="headerlink" title="Beanstalkd介绍"></a>Beanstalkd介绍</h1><p>Beanstalk，一个高性能、轻量级的分布式内存队列系统。<br>高性能离不开异步，异步离不开队列，而其内部都是Producer-Comsumer模式的原理。</p><p><br><br><br></p><h2 id="Beanstalkd核心概念："><a href="#Beanstalkd核心概念：" class="headerlink" title="Beanstalkd核心概念："></a>Beanstalkd核心概念：</h2><ul><li><p>job(任务)<br>一个需要异步处理的任务，是beanstalkd中的基本单元，需要放在一个tube中。</p></li><li><p>tube(管道)<br>一个有名的任务队列，用来存储同一类型的job。是producer和consumer操作的对象。</p></li><li><p>producer(生产者)<br>job的生产者，通过<code>put</code>命令将一个job放到一个tube中。</p></li><li><p>consumer(消费者)<br>job的消费者，通过<code>reserve</code>/<code>release</code>/<code>bury</code>/<code>delete</code>命令来获取或改变job的状态。</p></li></ul><p><br></p><p>beanstalkd官方状态图：</p><p><img src="/images/beanstalkd.png" alt=""></p><p><br><br><br></p><h2 id="Beanstalkd特性"><a href="#Beanstalkd特性" class="headerlink" title="Beanstalkd特性"></a>Beanstalkd特性</h2><ul><li><p>优先级<br>支持0-2^32的优先级。值越小，优先级越高，默认是1024。</p></li><li><p>持久化<br>可通过<strong>binlog</strong>将job及其状态记录到文件里面。在Beanstalkd下次启动时，可通过读取binlog来恢复之前的job及状态。</p></li><li><p>分布式容错<br>分布式设计和Memcached类似，beanstalkd个server之间并不知道彼此的存在，都是通过client来实现分布式以及根据tube名称到特定server获取job。</p></li><li><p>超时控制<br>为了防止某个consumer长时间占用任务但不能处理的情况，beanstalkd为<code>reserve</code>操作设置了timeout。如果该consumer不能在指定时间内完成job，job将被迁移会READY状态，供其它consumer执行。</p></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="安装Beanstalkd"><a href="#安装Beanstalkd" class="headerlink" title="安装Beanstalkd"></a>安装Beanstalkd</h1><p>由于epel源可直接安装beanstalkd，So:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum install -y beanstalkd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置文件</span></span><br><span class="line">/etc/sysconfig/beanstalkd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">systemctl start beanstalkd</span><br><span class="line"></span><br><span class="line"><span class="comment">#等同于</span></span><br><span class="line"><span class="comment">#/usr/bin/beanstalkd -l 0.0.0.0 -p 11300 -u beanstalkd</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Beanstalk的客户端和管理端"><a href="#Beanstalk的客户端和管理端" class="headerlink" title="Beanstalk的客户端和管理端"></a>Beanstalk的客户端和管理端</h2><p>官方没有推出客户端和管理端，GitHub上有一些第三方插件，请自己选择使用。</p><p><br></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li>pheanstalkd:  <a href="https://github.com/pda/pheanstalk/" target="_blank" rel="noopener">https://github.com/pda/pheanstalk/</a></li></ul><p>pheanstalk是一个在PHP中操作beanstalkd的客户端。<br>具体使用方法参考README。</p><p><br></p><h3 id="管理端"><a href="#管理端" class="headerlink" title="管理端"></a>管理端</h3><ul><li><p>beanstalk_console： <a href="https://github.com/ptrofimov/beanstalk_console" target="_blank" rel="noopener">https://github.com/ptrofimov/beanstalk_console</a></p></li><li><p>aurora: <a href="https://github.com/xuri/aurora" target="_blank" rel="noopener">https://github.com/xuri/aurora</a><br>aurora 是一个基于 Web 的 Beanstalk 消息队列服务器管理工具，单文件无需依赖其他组件，支持管理本地和远程多个队列服务器。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7.x86_64&lt;/li&gt;
&lt;li&gt;Beanstalkd v1.10&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Beanstalkd" scheme="https://zhang21.github.io/tags/Beanstalkd/"/>
    
  </entry>
  
  <entry>
    <title>Supervisor</title>
    <link href="https://zhang21.github.io/2018/04/08/Supervisor/"/>
    <id>https://zhang21.github.io/2018/04/08/Supervisor/</id>
    <published>2018-04-08T02:38:33.000Z</published>
    <updated>2018-05-23T09:26:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="http://www.supervisord.org" target="_blank" rel="noopener">http://www.supervisord.org</a></li></ul><p>环境：</p><ul><li>Supervisor 3.3.4</li><li>CentOS7.x86_64</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><br></p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Supervisor是一个C/S系统，允许用户在Unix-Like操作系统上控制许多进程。它受如下启发：</p><ul><li>Convenience</li><li>Accuracy</li><li>Delegation</li><li>Process Group</li></ul><p><br><br><br></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>Simple</li><li>Centralized(统一)</li><li>Efficient</li><li>Extensible</li><li>Compatible</li><li>Proven(久经考验)</li></ul><p><br><br><br></p><h2 id="Supervisor组件"><a href="#Supervisor组件" class="headerlink" title="Supervisor组件"></a>Supervisor组件</h2><ul><li>supervisord<ul><li>Supervisor的服务器部分被命名为<code>supervisord</code>。负责启动子进程，响应客户端的子进程，重启奔溃或退出的子进程，记录其<code>stderr</code>和<code>stdout</code>，以及生成对应的事件</li><li>默认使用的配置文件为<code>/etc/supervisord.conf</code>——Windows-INI格式的文件，由于它包含了未加密的username和password，请保证它安全</li></ul></li><li>supervisorctl<ul><li>Supervisor的客户端部分被命名为<code>supervisorctl</code>。用户可连接到不同的supervisord，status/stop/start子进程，获取supervisord中正在运行的进程列表</li><li>通过Unix domain socket或TCP socket与server通信，客户端在执行命令前应该先提供认证。客户端和服务端使用同一个配置文件</li></ul></li><li>Web server<ul><li>Web界面，可通过它查看或控制进程状态</li></ul></li><li>XML-RPC接口<ul><li>用于询问和控制管理程序及其运行的程序</li></ul></li></ul><p><br><br><br></p><h2 id="平台要求"><a href="#平台要求" class="headerlink" title="平台要求"></a>平台要求</h2><ul><li>在Unix-Like系统上运行良好</li><li>不支持Windows系统</li><li>Supervisor运行在Python2.4或之后的版本，不支持Python3</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装方法取决于你的操作系统。</p><p><br></p><h2 id="通过网络安装"><a href="#通过网络安装" class="headerlink" title="通过网络安装"></a>通过网络安装</h2><ul><li>推荐使用setuptools的<code>easy_install</code></li><li>下载Supervisor包并调用一个命令</li></ul><p><br></p><h3 id="使用Setuptools的网络安装"><a href="#使用Setuptools的网络安装" class="headerlink" title="使用Setuptools的网络安装"></a>使用Setuptools的网络安装</h3><p>如果Python解释器安装了Setuptools:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install supervisor</span><br></pre></td></tr></table></figure><p><br></p><h2 id="不使用Setuptools的网络安装"><a href="#不使用Setuptools的网络安装" class="headerlink" title="不使用Setuptools的网络安装"></a>不使用Setuptools的网络安装</h2><p>如果系统上未安装Setuptools，那么你需要手动去下载Supervisor发行套件和安装它。</p><p>PYPI： <a href="https://pypi.python.org/pypi/supervisor" target="_blank" rel="noopener">https://pypi.python.org/pypi/supervisor</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://pypi.python.org/pypi/supervisor/xxx.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xzf xxx.tar.gz</span><br><span class="line"></span><br><span class="line">python setup.py install</span><br><span class="line">#它会自动通过网络下载依赖</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="安装一个分发包"><a href="#安装一个分发包" class="headerlink" title="安装一个分发包"></a>安装一个分发包</h2><p>一些Linux发行版提供了可通过系统包管理工具安装Supervisor。这些包由第三方制作，包含了对特定发行版的一些修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum info supervisor</span><br><span class="line">yum search supervisor</span><br><span class="line"></span><br><span class="line">yum install -y supervisor</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="通过pip安装"><a href="#通过pip安装" class="headerlink" title="通过pip安装"></a>通过pip安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="创建一个配置文件"><a href="#创建一个配置文件" class="headerlink" title="创建一个配置文件"></a>创建一个配置文件</h2><p>由于我是通过<code>yum</code>安装，所以<code>supervisor</code>配置文件自动在<code>/etc</code>下自动生成：</p><ul><li><p>默认配置文件： <code>/etc/supervisord.conf</code><br>建议在此配置文件中加入<code>[include]</code>，默认已包含此配置</p></li><li><p>目录： <code>/etc/supervisord.d</code><br>建议将每个配置单独写在此目录下</p></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="运行Supervisor"><a href="#运行Supervisor" class="headerlink" title="运行Supervisor"></a>运行Supervisor</h1><p><br></p><h2 id="添加一个程序"><a href="#添加一个程序" class="headerlink" title="添加一个程序"></a>添加一个程序</h2><p>在<code>supervisord</code>为你做任何有用的事情之前，你至少需要在配置文件中添加一个程序部分。<strong>program</strong>部分将定义在调用supervisord命令时如何运行和管理一个程序。</p><p>一个最简单的栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[program:foo]</span><br><span class="line">command=/bin/cat</span><br></pre></td></tr></table></figure><p>上面的栗子只命名了一个命令，还有很多其它关于程序部分的设置。</p><p><br><br><br></p><h2 id="运行supervisord"><a href="#运行supervisord" class="headerlink" title="运行supervisord"></a>运行supervisord</h2><p>使用<code>supervisord</code>命令启动supervisord，进程将自我守护，并从终端分离。并将操作日志默认放于<code>$CWD/supervisor.log</code>。<br>你可传递<code>-n/--nodaemon</code>标志来将进程放置于前台，这样对于debug很有帮助。</p><p>要更改supervisord控制的程序集，请编辑配置文件并<code>kill- HUP</code>，或以其它方式重新启动supervisord进程。</p><p><code>supervisord</code>命令接受许多命令行选项。这些命令行选项中的每一个都会覆盖配置文件中的任何等效值。</p><p>详细选项： <a href="http://www.supervisord.org/running.html#supervisord-command-line-options" target="_blank" rel="noopener">http://www.supervisord.org/running.html#supervisord-command-line-options</a></p><p><br><br><br></p><h2 id="运行supervisorctl"><a href="#运行supervisorctl" class="headerlink" title="运行supervisorctl"></a>运行supervisorctl</h2><p>使用<code>supervisorclt</code>命令启动supervisorctl客户端。如果需要验证supervisord调用，则系统会要求您提供验证凭据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl status all</span><br><span class="line"></span><br><span class="line">supervisorctl stop all</span><br></pre></td></tr></table></figure><p><br></p><h3 id="supervisorctl-Actions"><a href="#supervisorctl-Actions" class="headerlink" title="supervisorctl Actions"></a>supervisorctl Actions</h3><p>如果在命令行中指定了<code>-i</code>或未指定任何操作(action)，则将启动交互式输入的shell解释操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl help</span><br><span class="line">#查看可操作的action</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">default commands (type help &lt;topic&gt;):</span><br><span class="line">=====================================</span><br><span class="line">add    clear  fg        open  quit    remove  restart   start   stop  update</span><br><span class="line">avail  exit   maintail  pid   reload  reread  shutdown  status  tail  version</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h2><p>supervisord程序可能会发送某些actions，让它在运行时执行某些操作。你可将这些信号发送到一个单一的supervisord的PID。</p><p><br></p><h3 id="信号处理程序"><a href="#信号处理程序" class="headerlink" title="信号处理程序"></a>信号处理程序</h3><ul><li><code>SIGTERM</code><ul><li>supervisord及其所有子进程都将关闭</li></ul></li><li><code>SIGINT</code><ul><li>supervisord及其所有子进程都将关闭</li></ul></li><li><code>SIGQUIT</code><ul><li>supervisord及其所有子进程都将关闭</li></ul></li><li><code>SIGHUP</code><ul><li>supervisord将关闭所有进程，重新载入配置文件并启动所有进程</li></ul></li><li><code>SIGUSR2</code><ul><li>supervisord将关闭并重新打开主要活动日志和所有子日志文件</li></ul></li></ul><p><br><br><br></p><h2 id="运行安全"><a href="#运行安全" class="headerlink" title="运行安全"></a>运行安全</h2><p>开发人员尽力确保以root身份运行的supervisord进程不会导致意外的权限升级。但supervisord允许在其配置文件中的任意路径规范写入数据，允许任意路径选择可能会造成符号链接工具的漏洞。<br>确保supervisord配置文件的权限安全，除此之外，确保Python PATH和标准库都有足够的文件权限保护。</p><p><br><br><br></p><h2 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h2><p>由于我是<code>yum</code>安装，所以能够直接使用系统服务管理来设置开机自启。</p><p><br><br><br></p><hr><p><br></p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>Supervisor的配置文件通常命名为<code>supervisord.conf</code>。如果没有指定<code>-c</code>配置文件，应用程序会从以下位置去寻找配置文件：</p><ul><li>$CWD/supervisord.conf</li><li>$CWD/etc/supervisord.conf</li><li>/etc/supervisord.conf</li><li>/etc/supervisor/supervisord.conf (since Supervisor 3.3.0)</li><li>../etc/supervisord.conf (Relative to the executable)</li><li>../supervisord.conf (Relative to the executable)</li></ul><p><br><br><br></p><h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p><code>supervisord.conf</code> is a Windows-INI-style (Python ConfigParser) file.<br>它包含section（[header]）和section中的key/value对。</p><p><br></p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>使用Python字符串表达式语法<code>%(ENV_X)%</code>，可以在配置文件中使用环境中存在的环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[program:example]</span><br><span class="line">command=/usr/bin/example --loglevel=%(ENV_LOGLEVEL)s</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="unix-http-server"><a href="#unix-http-server" class="headerlink" title="[unix_http_server]"></a>[unix_http_server]</h2><p>在此section中应该插入在Unix domain socket上监听的HTTP server的配置参数。<br>如果没有配置此section，则Unix domain socket HTTP server将不会启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#supervisor监听HTTP/XML-RPC请求的Unix domain socket的路径</span><br><span class="line">file</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#socket文件的权限模式</span><br><span class="line">chmod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#socket的用户和组</span><br><span class="line">chown</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#访问HTTP server需要的认证</span><br><span class="line">username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#密码可以是明文，或使用SHA加密的字符串</span><br><span class="line">password</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="inet-http-server"><a href="#inet-http-server" class="headerlink" title="[inet_http_server]"></a>[inet_http_server]</h2><p>监听TCP(internet) socket 的HTTP server的配置参数。<br>如果此section未配置，inet HTTP server将不会启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#tcp host:port，supervisor监听HTTP/XML-RPC请求的地址</span><br><span class="line">port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#HTTP server认证</span><br><span class="line">username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#密码可以是明文，或SHA加密</span><br><span class="line">passwd</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="supervisord"><a href="#supervisord" class="headerlink" title="[supervisord]"></a>[supervisord]</h2><p>与supervisord进程有关的全局设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">logfile</span><br><span class="line"></span><br><span class="line">logfile_maxbytes</span><br><span class="line"></span><br><span class="line">logfile_backps</span><br><span class="line"></span><br><span class="line">#critical, error, warn, info, debug, trace</span><br><span class="line">logevel</span><br><span class="line"></span><br><span class="line">pidfile</span><br><span class="line"></span><br><span class="line">umask</span><br><span class="line"></span><br><span class="line">nodaemon</span><br><span class="line"></span><br><span class="line">minfds</span><br><span class="line"></span><br><span class="line">minprocs</span><br><span class="line"></span><br><span class="line">#防止supervisord在启动时清除任何现有子日志文件</span><br><span class="line">nocleanup</span><br><span class="line"></span><br><span class="line">childlogdir</span><br><span class="line"></span><br><span class="line">user</span><br><span class="line"></span><br><span class="line">directory</span><br><span class="line"></span><br><span class="line">strip_ansi</span><br><span class="line"></span><br><span class="line">enviroment</span><br><span class="line"></span><br><span class="line">identifier</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="supervisorctl"><a href="#supervisorctl" class="headerlink" title="[supervisorctl]"></a>[supervisorctl]</h2><p><code>supervisorctl</code>交互式shell程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">serverurl</span><br><span class="line"></span><br><span class="line">#与前面设置的验证账户一致</span><br><span class="line">username</span><br><span class="line">password</span><br><span class="line"></span><br><span class="line">prompt</span><br><span class="line"></span><br><span class="line">history_file</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="program-x"><a href="#program-x" class="headerlink" title="[program:x]"></a>[program:x]</h2><p>supervisord知道的应该启动和控制的程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> #该程序启动时将运行的命令</span><br><span class="line">command</span><br><span class="line"></span><br><span class="line"> #进程名称</span><br><span class="line">process_name</span><br><span class="line"></span><br><span class="line"> #多个实例</span><br><span class="line">numproc</span><br><span class="line"></span><br><span class="line"> #用于计算numprocs开始的数量</span><br><span class="line">numprocs_start</span><br><span class="line"></span><br><span class="line"> #程序在启动和关闭顺序中的相对优先级</span><br><span class="line">priority</span><br><span class="line"></span><br><span class="line"> #当supervisord启动时，改程序将自动启动</span><br><span class="line">autostart</span><br><span class="line"></span><br><span class="line"> #程序在启动后需要保持运行以考虑启动成功的总秒数，设置为0表示不需要再任何特定的事件内保持运行</span><br><span class="line">startsecs</span><br><span class="line"></span><br><span class="line"> #允许失败的尝试次数，然后放弃并将进程置入fatal状态</span><br><span class="line">startretries</span><br><span class="line"></span><br><span class="line"> #自动重启进程</span><br><span class="line">autorestart</span><br><span class="line"></span><br><span class="line"> #异常退出码</span><br><span class="line">exitcodes</span><br><span class="line"></span><br><span class="line"> #请求停止时用于杀死程序的信号</span><br><span class="line">stopsignal</span><br><span class="line"></span><br><span class="line"> #发送停止信号后，等待系统将信号返回给supervisord的秒数</span><br><span class="line">stopwaitsecs</span><br><span class="line"></span><br><span class="line"> #将停止信号发送给整个进程组</span><br><span class="line">stopagroup</span><br><span class="line"></span><br><span class="line"> #</span><br><span class="line">killasgroup</span><br><span class="line"></span><br><span class="line"> #以哪个用户运行该程序</span><br><span class="line">user</span><br><span class="line"></span><br><span class="line">redirect_stderr</span><br><span class="line"></span><br><span class="line">stdout_logfile</span><br><span class="line">stdout_logfile_maxbytes</span><br><span class="line">stdout_logfile_backups</span><br><span class="line">stdout_capture_maxbytes</span><br><span class="line">stdout_events_enabled</span><br><span class="line"></span><br><span class="line">stderr_logfile</span><br><span class="line">stderr_logfile_maxbytes</span><br><span class="line">stderr_logfile_backups</span><br><span class="line">stderr_capture_maxbytes</span><br><span class="line">stderr_events_enabled</span><br><span class="line"></span><br><span class="line">environment</span><br><span class="line"></span><br><span class="line">directory</span><br><span class="line"></span><br><span class="line">umask</span><br><span class="line"></span><br><span class="line">serverurl</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="include"><a href="#include" class="headerlink" title="[include]"></a>[include]</h2><p>如果配置文件包含<code>[include]</code>部分，则它必须包含一个名为<code>files</code>的key。该key中的值包含了其它配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#文件空间的空格分隔序列，路径可以是相对或绝对。</span><br><span class="line">files</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="group-x"><a href="#group-x" class="headerlink" title="[group:x]"></a>[group:x]</h2><p>将同质进程组组合成一个异质进程组通常很有用，所以它们可以作为supervisor各种控制器接口的一个单元进行控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#程序的逗号分隔列表</span><br><span class="line">programs</span><br><span class="line"></span><br><span class="line">#优先级</span><br><span class="line">priority</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="fcgi-program-x"><a href="#fcgi-program-x" class="headerlink" title="[fcgi-program:x]"></a>[fcgi-program:x]</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#程序的fastCGI socket或TCP或Unix domain socket</span><br><span class="line">socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#为socket指定特定user或group</span><br><span class="line">socket_owner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定permission模式</span><br><span class="line">socket_mode</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="eventlistener-x"><a href="#eventlistener-x" class="headerlink" title="[eventlistener:x]"></a>[eventlistener:x]</h2><p>supervisor允许在配置文件中定义专门的同质进程组(event listener pools)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer_size</span><br><span class="line"></span><br><span class="line">events</span><br><span class="line"></span><br><span class="line">result_handler</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="rpcinterface-x"><a href="#rpcinterface-x" class="headerlink" title="[rpcinterface:x]"></a>[rpcinterface:x]</h2><p><code>[rpcinterface:x]</code>适用于希望通过自定义行为扩展supervisor的人们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.supervisord.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.supervisord.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Supervisor 3.3.4&lt;/li&gt;
&lt;li&gt;CentOS7.x86_64&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Supervisor" scheme="https://zhang21.github.io/tags/Supervisor/"/>
    
  </entry>
  
  <entry>
    <title>Consul</title>
    <link href="https://zhang21.github.io/2018/04/05/Consul/"/>
    <id>https://zhang21.github.io/2018/04/05/Consul/</id>
    <published>2018-04-05T14:08:11.000Z</published>
    <updated>2018-07-06T01:45:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://www.consul.io/intro/index.html" target="_blank" rel="noopener">https://www.consul.io/intro/index.html</a></li><li><a href="https://www.consul.io/docs/" target="_blank" rel="noopener">https://www.consul.io/docs/</a></li><li>Consul Template: <a href="https://www.hashicorp.com/blog/introducing-consul-template" target="_blank" rel="noopener">https://www.hashicorp.com/blog/introducing-consul-template</a></li></ul><p>环境：</p><ul><li>CentOS7x86_64</li><li>Consul v1.2.0</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>介绍consul是什么，它可以解决哪些问题，以及如何开始使用它。</p><p><br></p><h2 id="Consul是什么"><a href="#Consul是什么" class="headerlink" title="Consul是什么"></a>Consul是什么</h2><p>Consule有多个组件，但总体而言，它是发现(discovery)和配置(config)基础架构(infrastructure)服务的工具。它提供几个关键特点：</p><ul><li>服务发现(service discovery)<ul><li>Consul客户端可提供一个服务，如API或mysql，其它客户端能够使用Consul来发现给定服务的提供者。使用DNS或HTTP，应用程序可以轻松找到他们所依赖的服务</li></ul></li><li>健康检查(health checking)<ul><li>Consul可以提供任何数量的健康检查，既可以与给定服务相关联(webserver return 200)，也可与本地节点(内存使用率小于90%)相关联。操作人员可用此信息来监视集群运行状况，服务发现组件使用此信息将流量(traffic)从不健康的主机中引导出去</li></ul></li><li>KV store<ul><li>应用程序可将Consul的分层Key/Value用于存储任何目的，包括动态配置(dynamic configuration)、功能标记(feature flagging)、协调(coordination)、领导选举(leader election)…简单的HTTP API使其易于使用</li></ul></li><li>多数据中心(Multi Datacenter)<ul><li>Consul支持多数据中心，这意味着Consul的用户不必担心构建额外的抽象层以扩展到多个区域</li></ul></li></ul><p>Consul旨在与DevOps和应用程序开发者保持友好，使其成为现代化 ，弹性基础架构的完美选择。</p><p><br><br><br></p><h2 id="Consul用例"><a href="#Consul用例" class="headerlink" title="Consul用例"></a>Consul用例</h2><ul><li><p>服务发现(service )<br>服务注册，集成健康检查，使用DNS或HTTP接口使得任何服务都能被其它服务发现。</p></li><li><p>服务分割(service segmentation)<br>通过自动TLS加密和基于身份的授权实现安全的服务到服务通信。</p></li><li><p>服务配置(service configuration)<br>功能丰富的 key/value 可轻易配置服务。</p></li></ul><p><br><br><br></p><h2 id="Consul基础架构"><a href="#Consul基础架构" class="headerlink" title="Consul基础架构"></a>Consul基础架构</h2><p>Consul是一个分布式、高可用的系统。</p><p>每一个向Consul提供服务的节点都运行一个Consul agent。运行agent对于服务发现或get/set Key/Value不是必需的。agent负责健康检查节点上的服务和节点自身。</p><p>agent可与一个或多个Consul server交流。Consul server是数据存储和复制集所在之地。server之间选出一个leader。虽然Consul可以使用一台服务器，但推荐使用3-5台以避免数据丢失的故障情况。对每一个数据中心都推荐使用Consul server cluster。</p><p>需要发现其它服务或节点的基础架构组件 可以查询任何Consul server或Consul agent。agent自动将查询发送到server。</p><p>每个数据中心运行一组consul server cluster。当发生cross-datacenter服务发现或配置请求时，本地consul server将请求转发给远程数据中心并返回结果。</p><p><br><br><br></p><hr><p><br></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="安装Consul"><a href="#安装Consul" class="headerlink" title="安装Consul"></a>安装Consul</h2><ul><li>二进制包: <a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">https://www.consul.io/downloads.html</a><ul><li>解压缩，得到一个consul二进制可执行文件，可将其放入系统路径</li></ul></li><li>验证安装: <code>consul</code></li></ul><p><br><br><br></p><h2 id="运行consul-agent"><a href="#运行consul-agent" class="headerlink" title="运行consul-agent"></a>运行consul-agent</h2><p>安装consul后请务必运行agent，agent可运行在server或client模式。每个datacenter必须至少有一台server，推荐3-5台做一个集群。单一server部署非常不安全，在故障情况下数据丢失就不可避免了。</p><p>所有其它agents都以client模式运行。client是一个非常轻量化的进程——它注册服务、运行健康检查、转发查询给server。agent必须运行在集群的每个节点上。</p><p><br></p><h3 id="启动agent"><a href="#启动agent" class="headerlink" title="启动agent"></a>启动agent</h3><p>测试consul development模式，不建议在生产环境使用此方法，此处做测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">consul agent -dev</span><br><span class="line"></span><br><span class="line">netstat -nltp</span><br><span class="line"></span><br><span class="line">#可根据日志看出agent已成为server，并成为集群leader</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Consul成员"><a href="#Consul成员" class="headerlink" title="Consul成员"></a>Consul成员</h3><p><code>members</code>命令基于<code>gossip protocol</code>并最终保持一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">consul members</span><br><span class="line"></span><br><span class="line">#节点名称、监听地址、健康状态、集群角色、版本信息</span><br><span class="line">Node     Address         Status  Type    Build  Protocol  DC   Segment</span><br><span class="line">zhang22  127.0.0.1:8301  alive   server  1.0.6  2         dc1  &lt;all&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#使用HTTP API将请求转发给server以获取一致的view of world</span><br><span class="line">culr localhost:8500/v1/catalog/nodes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#DNS interface也可以查询节点，默认端口8600</span><br><span class="line">dig @127.0.0.1 -p 8600 zhang22.node.consul</span><br></pre></td></tr></table></figure><p><br></p><h3 id="停止agent"><a href="#停止agent" class="headerlink" title="停止agent"></a>停止agent</h3><p>可使用<code>Ctrl + C</code>优雅地终止agent，你可以看到它离开集群并关闭。</p><p>优雅关闭，Consul会通知集群其它节点此节点的离开。如果你强制kill agent，则集群的其它节点将检测该节点失败。<br>当成员离开时，其服务和健康检查将从catalog中移除。当成员失败时，其健康状态被标记为critical，但不会从catalog中移除。<br>Consul会自动尝试重连失败的节点，允许它从当前网络条件中修复，知道离开的节点不在联系。</p><p>此外，如果agent正作为server在运行，那么优雅地离开对避免造成严重的影响有帮助。</p><p><br><br><br></p><h2 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h2><p>注册(register)服务并查询(query)服务。</p><p><br></p><h3 id="定义一个服务"><a href="#定义一个服务" class="headerlink" title="定义一个服务"></a>定义一个服务</h3><p>服务可以通过以下两种方法注册：</p><ul><li>服务定义(service definition)</li><li>调用HTTP API</li></ul><p>服务定义是注册服务最常见的方式，我们将构建前面agent的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#创建一个consul配置目录</span><br><span class="line">mkdir /etc/consul.d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#编写服务定义配置文件</span><br><span class="line">#假设有一个web服务运行在80端口，添加一个便于query的tag</span><br><span class="line">echo &apos;&#123;&quot;service&quot;: &#123;&quot;name: &quot;web&quot;, &quot;tag&quot;: [&quot;rails&quot;], &quot;port&quot;: 80 &#125;&#125;&apos; | tee /etc/consul.d/web.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#重启agent，指定配置目录</span><br><span class="line">consul agent -dev -config-dir=/etc/consul.d</span><br></pre></td></tr></table></figure><p>如果你想注册多个服务，你可以在配置目录下创建多个服务定义文件。</p><p><br></p><h3 id="查询服务"><a href="#查询服务" class="headerlink" title="查询服务"></a>查询服务</h3><p>一旦agent启动并且服务已同步，我们可通过HTTP API或DNS查询(query)服务。</p><p><br></p><p><strong>DNS API</strong><br>使用DNS API(默认8600)查询服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#DNS name(默认) -- NAME.service.consul</span><br><span class="line"></span><br><span class="line">#只有IP</span><br><span class="line">dig @127.0.0.1 -p 8600 web.service.consul</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#返回IP/Port</span><br><span class="line">dig @127.0.0.1 -p 8600 web.service.consul SRV</span><br></pre></td></tr></table></figure><p>我们还可以用DNS API按tag来过滤service。基于标签的查询格式为<code>tag.name.service.consul</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig @127.0.0.1 -p 8600 rails.web.service.consul</span><br></pre></td></tr></table></figure><p><br></p><p><strong>HTTP API</strong><br>除了DNS API，HTTP API(默认8500)同样可用于查询服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#前面定义了web这个service</span><br><span class="line">curl http://localhost:8500/v1/catalog/service/web</span><br></pre></td></tr></table></figure><p>catalog API提供了给定服务的所有节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#仅仅健康实例的查询</span><br><span class="line"> curl &apos;http://localhost:8500/v1/health/service/web?passing&apos;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="更新服务"><a href="#更新服务" class="headerlink" title="更新服务"></a>更新服务</h3><p>服务定义可以通过更改配置文件并向agent发送SIGHUP来更新。这使得更新服务不会出现任何停机或查询服务不可达的情况。</p><p>另外，HTTP API能够用来动态地添加、移除、修改服务。</p><p><br><br><br></p><h2 id="Consul集群"><a href="#Consul集群" class="headerlink" title="Consul集群"></a>Consul集群</h2><p>具有多个成员的consul集群。</p><p>当consul节点启动时，它不知道任何其它节点，它是一个孤立的集群。为了了解到集群中的其它成员，agent必须要加入一个存在的集群。要加入一个现有的集群，只需知道一个现有成员。当加入集群后，agent将于其此成员闲聊，并迅速发现集群中的其它成员。一个agent可以加入任何其它agent，而不仅仅是server模式的agent。</p><p><br></p><h3 id="启动agents"><a href="#启动agents" class="headerlink" title="启动agents"></a>启动agents</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#node1</span><br><span class="line">consul agent -server -bootstrap-expect=1 \</span><br><span class="line">    -data-dir=/tmp/consul -node=agent-one -bind=ip1 \</span><br><span class="line">    -enable-script-checks=true -config-dir=/etc/consul.d</span><br><span class="line"></span><br><span class="line">#node2</span><br><span class="line">consul agent -data-dir=/tmp/consul -node=agent-two \</span><br><span class="line">    -bind=ip2 -enable-script-checks=true -config-dir=/etc/consul.d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#两个独立的node</span><br><span class="line"></span><br><span class="line">#现在，我们有两个agent在运行中：一个server，一个client。但是他们两者并不知道对方，并仍然是一个单一节点的集群。</span><br><span class="line">#查看节点</span><br><span class="line">consul member</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="加入集群"><a href="#加入集群" class="headerlink" title="加入集群"></a>加入集群</h2><p>由于我们在启动agent的时候便已指定server，所以从哪个节点加入都一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">consul join ip</span><br><span class="line">#Successfully joined cluster by contacting 1 nodes.</span><br><span class="line"></span><br><span class="line">consul members</span><br><span class="line"></span><br><span class="line">Node       Address              Status  Type    Build  Protocol  DC   Segment</span><br><span class="line">agent-one  172.16.129.141:8301  alive   server  1.0.6  2         dc1  &lt;all&gt;</span><br><span class="line">agent-two  172.16.129.150:8301  alive   client  1.0.6  2         dc1  &lt;default&gt;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="在启动时自动加入集群"><a href="#在启动时自动加入集群" class="headerlink" title="在启动时自动加入集群"></a>在启动时自动加入集群</h3><p>理想情况下，每当一个新节点出现在数据中心时，它应该自动加入集群而不需要人工干预。</p><p><br><br><br></p><h3 id="查询节点"><a href="#查询节点" class="headerlink" title="查询节点"></a>查询节点</h3><p>就像查询服务，consul有一个API用于查询节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#NAME.node.consul或NAME.node.DATACENTER.conosul</span><br><span class="line">dig @localhost -p 8600 agent-one.node.consul</span><br><span class="line">dig @127.0.0.1 -p 8600 agent-two.node.consul</span><br></pre></td></tr></table></figure><p><br></p><h3 id="离开集群"><a href="#离开集群" class="headerlink" title="离开集群"></a>离开集群</h3><ul><li>优雅的退出: <code>Ctrl+C</code></li><li>强制<code>kill</code></li></ul><p><br><br><br></p><h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>对节点和服务添加健康检查(health check)。<br>健康检查是服务发现的关键组件，可以防止使用不健康的服务。</p><p><br></p><h3 id="定义检查"><a href="#定义检查" class="headerlink" title="定义检查"></a>定义检查</h3><p>与服务类似，一个检查能够通过定义检查或适当调用HTTP API来两种方式来注册。</p><p>定义<strong>检查</strong>是一个最基本和推荐的方法。</p><p>在consul配置目录中创建检查定义文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#在基于脚本的健康检查上，它与consul进程使用同样的用户</span><br><span class="line">#如果命令以非0状态码退出，则该节点会被标记为unhealthy</span><br><span class="line"></span><br><span class="line">echo &apos;&#123;&quot;check&quot;: &#123;&quot;name&quot;: &quot;ping&quot;, &quot;args&quot;: [&quot;ping&quot;, &quot;-c1&quot;, &quot;baidu.com&quot;], &quot;interval&quot;: &quot;30s&quot;&#125;&#125;&apos; &gt;/etc/consul.d/ping.json</span><br><span class="line"></span><br><span class="line">echo &apos;&#123;&quot;service&quot;: &#123;&quot;name&quot;: &quot;web&quot;, &quot;tags&quot;: [&quot;rails&quot;], &quot;port&quot;: 80, &quot;check&quot;: &#123;&quot;args&quot;: [&quot;curl&quot;, &quot;localhost&quot;], &quot;interval&quot;: &quot;10s&quot;&#125;&#125;&#125;&apos; &gt;/etc/consul.d/web.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consul reload</span><br></pre></td></tr></table></figure><p><br></p><h2 id="检查健康状态"><a href="#检查健康状态" class="headerlink" title="检查健康状态"></a>检查健康状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8500/v1/health/state/critical</span><br><span class="line"></span><br><span class="line">dig @127.0.0.1 -p 8600 web.service.consul</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="KV数据"><a href="#KV数据" class="headerlink" title="KV数据"></a>KV数据</h2><p>Consul提供了一个易于使用的KV存储。这可以用来保存动态配置，协助服务协调，构建leader选举，并启用开发人员可以考虑构建的任何其它内容。</p><p><br></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>有两种方法与Consul K/V交互的方式：</p><ul><li>HTTP API</li><li>Consul KV CLI</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#CLI</span><br><span class="line">consul kv --help</span><br><span class="line"></span><br><span class="line">consul kv put name zhang</span><br><span class="line">consul kv get name</span><br><span class="line">#zhang</span><br><span class="line"></span><br><span class="line">consul kv get -detailed name</span><br><span class="line"></span><br><span class="line">consul kv puut -flags=42 who zhang21</span><br><span class="line">#所有key都支持设置一个64位的整数标志值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#列出所有kv</span><br><span class="line">consul kv get -recurse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">consul kv delete name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#使用 Check-And-Set 进行原子更新</span><br><span class="line">consul kv put -cas -modify-index=112 NAME zhang</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#导出与导入</span><br><span class="line">consul kv export &gt; xxx.json</span><br><span class="line"></span><br><span class="line">consul kv import $xxx.json</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Web界面"><a href="#Web界面" class="headerlink" title="Web界面"></a>Web界面</h2><p>Consul支持美观的Web界面。用户界面可以查看所有的服务和节点，查看所有健康检查和当前状态，读取和设置kv数据，并自动支持多数据中心。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">consul agent -ui</span><br><span class="line"></span><br><span class="line">#localhost:8500/ui</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="内部详情"><a href="#内部详情" class="headerlink" title="内部详情"></a>内部详情</h1><p>Consul Internals</p><p>介绍Consul内部详情。</p><p><br></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Architecture</p><p><br></p><h3 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h3><p>Glossary</p><ul><li>Agent</li><li>Client</li><li>Server</li><li>Datacenter</li><li>Consensus</li><li>Gossip<ul><li>LAN Geossip</li><li>WAN Geossip</li></ul></li><li>RPC</li></ul><p><br></p><p><img src="/images/consul-arch-420ce04a.png" alt="Consul"></p><p><br><br><br></p><h2 id="Consensus协议"><a href="#Consensus协议" class="headerlink" title="Consensus协议"></a>Consensus协议</h2><p>Consul使用consensus(共识) protocol来提供一致性(consistency)，它基于<strong>Raft</strong>(In search of an Understandable Consensus Algorithm)</p><p><br></p><h3 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h3><p>Raft是基于Paxos的共识算法。</p><p>Raft的一些关键术语：</p><ul><li><p>Log<br>The primary unit of work in a Raft system is a log entry.</p></li><li><p>FSM(Finite State Machine)<br>An FSM(有限状态机) is a collection of finite states with transitions between them.</p></li><li><p>Peer set<br>The peer set(对等集) is the set of all members participating in log replication.</p></li><li><p>Quorum<br>A quorum(仲裁) is a majority of members from a peer set: for a set of size n, quorum requires at least (n/2)+1 members. </p></li><li><p>Committed Entry<br>An entry is considered committed when it is durably stored on a quorum of nodes.</p></li><li><p>Leader<br>At any given time, the peer set elects a single node to be the leader.</p></li></ul><p><br></p><p>Raft节点总是处于如下三种状态之一：</p><ul><li>follower(追随者)</li><li>candidate(候选者)</li><li>leader(领导者)</li></ul><p>所有节点最初都是作为follower开始的。在这种状态下，节点可接受leader的日志条目并投票。如果一段时间内没有收到任何条目，则节点会自我提升到candidate。<br>在candidate状态下，节点请求来自对等节点的投票。如果候选人获得仲裁(quorum)的票数，那么它将被提升为leader。<br>leader必须接受新的日志条目并复制给其它所有follower。另外，如果陈旧读取不可接受，则所有查询也必须在leader上执行。</p><p>一旦集群具有leader，它就能够接受新的日志条目。Client可以请求leader添加新的日志条目。然后，leader将条目持久化，并尝试复制到仲裁的follower。一旦日志条目被认为提交(committed)，它就可以应用于有限状态机(FSM)。<br>显然，允许复制日志以无限制的方式增长是不可取的。Raft提供了一种机制，可通过快照(snapshot)当前状态并压缩日志。<br>达成共识是容错的，直到法定人数可用。<br>建议为每个数据中心配置3-5台Consul Server。3个节点的Raft集群可以容忍单个节点故障，5个节点的Raft集群可以容忍2个节点故障。这可最大限制提高可用性。</p><p><br></p><h3 id="Raft-in-Consul"><a href="#Raft-in-Consul" class="headerlink" title="Raft in Consul"></a>Raft in Consul</h3><p>只有Consul Server节点参与Raft，并且是对等集的一部分。所有的Client节点都将请求转发给Server。</p><p>当启动的时候，单个Consul Server进入<strong>bootstrap</strong>模式，此模式允许它进行自我选举为leader。leader选出后，可以以一致性和安全性的方式将其它Server添加到对等集，之后，就可以禁用bootstrap模式。<br>由于所有的Server作为对等集的一部分参与，因此他们都知道当前的leader。当一个RPC请求到达了non-leader Server时，请求被转发给leader。</p><ul><li>如果RPC是查询(query)类型，意味着它是只读的，则leader根据FSM的当前状态生成结果</li><li>如果RPC是事务(transaction)类型，意味着它是可修改的，则leader生成新的日志条目并使用Raft应用它</li></ul><p>提交日志条目并将其应用于FSM后，事务就完成了。</p><p>由于Raft副本的性质，性能对网络延迟很敏感。因此，每个数据中心选择一个独立的leader并维护一个不相交的对等集。数据由数据中心分区，每个leader仅负责其数据中心中的数据。</p><p><br></p><h3 id="一致性模式"><a href="#一致性模式" class="headerlink" title="一致性模式"></a>一致性模式</h3><p>Consistency Modes</p><p>虽然对副本日志的所有写入都通过Raft，但读取却更加灵活。<br>Consul支持3种不同的读取一致性模式：</p><ul><li>default</li><li>consistent</li><li>stale</li></ul><p><br></p><h3 id="部署表"><a href="#部署表" class="headerlink" title="部署表"></a>部署表</h3><table><thead><tr><th>Servers</th><th>Quorum Size</th><th>Failere Tolerance</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>2</td><td>2</td><td>0</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>4</td><td>3</td><td>1</td></tr><tr><td>5</td><td>3</td><td>2</td></tr><tr><td>6</td><td>4</td><td>2</td></tr><tr><td>7</td><td>4</td><td>3</td></tr></tbody></table><p><br><br><br></p><h2 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h2><p>Consul 使用gossip协议来管理成员并向集群发送广播信息。所有这些都通过Serf Library提供。</p><p><br></p><h3 id="Goossip-in-Consul"><a href="#Goossip-in-Consul" class="headerlink" title="Goossip in Consul"></a>Goossip in Consul</h3><p>Consul使用两个不同的gossip pools:</p><ul><li>LAN pool</li><li>WAN pool</li></ul><p><br><br><br></p><h2 id="网络坐标"><a href="#网络坐标" class="headerlink" title="网络坐标"></a>网络坐标</h2><p>Network Coordinates</p><p>Consul使用网络层层析系统来计算集群中节点的网络坐标。这些坐标允许使用非常简单的计算在任意两个节点之间估计网络往返时间。所有这些都通过使用Serf Library。</p><p><br></p><h3 id="Consul中的网络坐标"><a href="#Consul中的网络坐标" class="headerlink" title="Consul中的网络坐标"></a>Consul中的网络坐标</h3><p>Network Coordinates in Consul</p><p>网络坐标在Consul中有多种表现方式：</p><ul><li><code>consul rtt</code></li><li>Catalog/Health endpoints</li><li>Prepared query</li><li>Coordinate endpoint</li></ul><p><br></p><h3 id="使用坐标"><a href="#使用坐标" class="headerlink" title="使用坐标"></a>使用坐标</h3><p>一旦你有了两个节点的坐标，则计算它们间的往返时间是很简单的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;Coord&quot;: &#123;</span><br><span class="line">    &quot;Adjustment&quot;: 0.1,</span><br><span class="line">    &quot;Error&quot;: 1.5,</span><br><span class="line">    &quot;Height&quot;: 0.02,</span><br><span class="line">    &quot;Vec&quot;: [0.34,0.68,0.003,0.01,0.05,0.1,0.34,0.06]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>Sessions</p><p>consul提供了一个用于构建分布式锁的会话机制。会话充当节点、健康检查和K/V数据之间的监听层。</p><p><br></p><h3 id="会话设计"><a href="#会话设计" class="headerlink" title="会话设计"></a>会话设计</h3><p><br><br><br></p><hr><p><br></p><h1 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h1><h2 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h2><p>Consul Agent是Consul的核心进程。它维护成员关系信息，注册服务，运行检查，响应查询…<br>Consul Agent必须运行在在Consul集群的每个节点上。</p><p>Agent有两种运行模式：</p><ul><li>server</li><li>client</li></ul><p>Server节点承担了作为<strong>consensus quorum(共识法人)</strong>的额外责任，这些节点参与Raft，并在出现故障时提供强大的一致性和可用性。<br>Client节点构成了集群的大部分，它们非常轻便。因为它们与Server进行大部分操作，保持自己的状态则很少。</p><p><br></p><p><strong>运行Agent</strong><br>以下是一些重要信息：</p><ul><li>Node name</li><li>Datacenter</li><li>Server</li><li>Client addr</li><li>Cluster addr</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接指定配置项运行</span></span><br><span class="line">consul agent -options</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将配置项写入文件，指定配置目录运行</span></span><br><span class="line">mkdir /etc/consul.d</span><br><span class="line">vim /etc/consul.d/consul.json</span><br><span class="line"></span><br><span class="line">consul agent -config-dir=/etc/consul.d</span><br></pre></td></tr></table></figure><p><br></p><p><strong>停止Agent</strong><br>有两种停止方式：</p><ul><li><p>gracefully<br>发送中断信号<code>ctrl+c</code>或运行<code>kill -INT</code>。优雅地退出，Agent首先通知集群它要离开集群。这样，集群便会通知其它成员该节点已离开。</p></li><li><p>forcefully<br>通过<code>kill signal</code>来强制杀掉Consul。集群的其余部分最终会检测到该节点已死亡并通知集群节点已失效。</p></li></ul><p>特别重要的是允许Server节点优雅地离开，以便对可用性产生最小的影响。<br>对于Client Agent来说，节点失效和节点离开的区别对用例并不是那么重要。</p><p><br></p><p><strong>生命周期</strong><br>Consul集群中的每个Agent都会经历一个生命周期(lifecycle)。<br>当Agent首次启动时，他并不知道集群中的其它任何节点。要发现它的同伴，它必须加入集群。这使用<code>join</code>命令或在配置文件中配置。一旦一个节点加入，这个信息就会传递给整个集群，这意味着所有节点最终都会意识到对方。<br>如果Agent是一个Server，则已经存在的Server就会开始复制(replicating)到新节点。</p><p>在网络故障的情况下，某些节点可能无法被其它节点访问。在这种情况下，无法访问的节点被标记为失败(failed)。无法区分网络故障和Agent崩溃，因此两种情况的处理方式都是相同的。该信息将在service catalog中被更新。</p><p>当一个节点离开时，它指定了它的意图，并且集群将该节点标记为已离开。与失败(failed)不同，节点提供的所有服务都立即注销(deregistered)。如果Agent是Server，则对其的复制(replication)将停止。</p><p>为了防止死亡(failed/left)节点的堆积，Consul会自动将死亡节点从目录中移除。这个过程被称为<strong>收割(reaping)</strong>。</p><p><br><br><br></p><h2 id="DNS接口"><a href="#DNS接口" class="headerlink" title="DNS接口"></a>DNS接口</h2><p>DNS接口允许应用程序利用服务发现，而无需与Consul进行高度整合。</p><p>有几个重要的配置项：</p><ul><li><code>client_addr</code></li><li><code>ports.dns</code></li><li><code>recursors</code></li><li><code>domain</code></li><li><code>dns_config</code></li></ul><p><strong>数据中心部分是可选的，如果没有提供，则默认为Agent自身的数据中心。</strong></p><p><br></p><p><strong>节点查找</strong><br>为了解析名称(name)，Consul依赖于特定的查询格式。基本上有两种类型的查询：</p><ul><li>node lookup</li><li>service lookup</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#node lookup</span><br><span class="line">&lt;node&gt;.node[.datacenter].&lt;domain&gt;</span><br><span class="line"></span><br><span class="line">node1.node.dc1.consul</span><br><span class="line">node1.node.consul</span><br><span class="line"></span><br><span class="line">dig @127.0.0.1 -p 8600 node1.node.consul</span><br></pre></td></tr></table></figure><p><br></p><p><strong>服务查找</strong><br>服务查找用于查询你服务提供者。</p><p>有两种查询方式：</p><ul><li>标准查询<br>DNS查询系统利用健康检查信息来防止路由到不健康的节点。为了实现简单的负载均衡，每次返回的节点集都是随机的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[tag.]&lt;service&gt;.service[.datacenter].&lt;domain&gt;</span><br><span class="line"></span><br><span class="line">redis.service.consul</span><br><span class="line">postgresql.service.dc2.consul</span><br><span class="line"></span><br><span class="line">dig @127.0.0.1 -p 8600 redis.service.consul SRV</span><br></pre></td></tr></table></figure><ul><li>RFC 2782查询<br>RFC 2782使用<code>_</code>下划线作为查询中服务和协议值的前缀，以防止DNS冲突。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_&lt;service&gt;._&lt;protocol&gt;[.service][.datacenter][.domain]</span><br><span class="line"></span><br><span class="line">dig @127.0.0.1 -p 8600 _rabbitmq._amqp.service.consul SRV</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Prepared Query Lookups</strong><br>The query or name is the ID or given name of an existing Prepared Query.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;query or name&gt;.query[.datacenter].&lt;domain&gt;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>可连接的服务查找</strong><br>Connect-Capable Service Lookups.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;service&gt;.connect.&lt;domain&gt;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Caching</strong><br>默认情况下，Consul服务的所有DNS结果都会设置一个为0的TTL。这会禁用DNS结果的缓存。但，很多情况下，缓存对性能和伸缩性都是可取的。</p><p><br></p><p><strong>WAN地址转换</strong><br>默认情况下，Consul DNS查询将会返回一个节点的本地地址。如果你需要外部地址，则可使用<code>advertise-wan</code>和<code>translate_wan_addrs</code>选项来配置此行为。</p><p><br><br><br></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Agent有许多通过命令行或配置文件配置的配置项。配置优先级如下：</p><ol><li>命令行参数</li><li>环境变量</li><li>配置文件</li></ol><p>配置文件可以是<strong>HCL</strong>或<strong>JSON</strong>格式。<br>Consul可通过<code>reload</code>命令重新载入配置文件。</p><p><br><br><br></p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>Consul默认使用的端口：</p><ul><li><p>8300(tcp)<br>Server RPC. Server用于处理来自其它Agent的传入请求。</p></li><li><p>8301(tcp/udp)<br>Serf LAN. 用于处理LAN中的gossip，所有Agent都需要。</p></li><li><p>8302(tcp/udp)<br>Serf WAN. Server用于处理WAN上gossip到其它Server。</p></li><li><p>8500(tcp)<br>HTTP API.</p></li><li><p>8600(tcp/udp)<br>DNS Interface.</p></li></ul><p><br><br><br></p><h3 id="可重新加载的配置"><a href="#可重新加载的配置" class="headerlink" title="可重新加载的配置"></a>可重新加载的配置</h3><p>Reloadable Configuration</p><p>重新加载配置文件不会加载所有配置项，如下这些配置项是可重新载入的：</p><ul><li>log level</li><li>checks</li><li>services</li><li>watches</li><li>http client address</li><li>node metadata</li><li>metric prefix filter</li><li>discard check output</li><li>rpc rate limiting</li></ul><p><br><br><br></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件不仅用于设置代理，还用于提供检查和服务定义。</p><p>配置文件选项和命令行参数稍微有点不一样。<br>使用<code>consul agent -h</code>查看具体配置项。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#开始栗子</span><br><span class="line">vim /etc/consul.d/single.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;bind_addr&quot;: &quot;192.168.1.11&quot;,</span><br><span class="line">&quot;bootstrap&quot;: true,</span><br><span class="line">&quot;client_addr&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">&quot;datacenter&quot;: &quot;zhang&quot;,</span><br><span class="line">&quot;data_dir&quot;: &quot;/var/lib/consul&quot;,</span><br><span class="line">&quot;log_level&quot;: &quot;WARN&quot;,</span><br><span class="line">&quot;node_name&quot;: &quot;zhang21&quot;,</span><br><span class="line">&quot;server&quot;: true,</span><br><span class="line">&quot;enable_syslog&quot;: true,</span><br><span class="line">&quot;ui&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#集群配置</span><br><span class="line">vim /etc/consul.d/cluster.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;bind_addr&quot;: &quot;xxx&quot;,</span><br><span class="line">&quot;bootstrap_expect&quot;: 2,</span><br><span class="line">&quot;client_addr&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">&quot;datacenter&quot;: &quot;zhang&quot;,</span><br><span class="line">&quot;data_dir&quot;: &quot;/var/lib/consul&quot;,</span><br><span class="line">&quot;encrypt&quot;: &quot;a1b8vAA2==@xyz&quot;,</span><br><span class="line">&quot;log_level&quot;: &quot;WARN&quot;,</span><br><span class="line">&quot;node_name&quot;: &quot;zhang21&quot;,</span><br><span class="line">&quot;node_id&quot;: &quot;zhang21&quot;,</span><br><span class="line">&quot;server&quot;: true,</span><br><span class="line">&quot;enable_syslog&quot;: true,</span><br><span class="line">&quot;ui&quot;: true,</span><br><span class="line">&quot;retry_interval&quot;: 20s,</span><br><span class="line">&quot;retry_join&quot;: [</span><br><span class="line">&quot;consul.domain.internal&quot;,</span><br><span class="line">&quot;10.0.1.2:8301&quot;,</span><br><span class="line">&quot;[::1]:8301&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h2><p>服务发现的主要目标之一是提供可用服务的目录(catalog)。为此，Agent提供了一种简单的服务定义格式来声明服务的可用性，并可能将其与健康检查相关联。如果健康检查与服务关联，则认为它是应用程序级别。</p><p><br></p><h3 id="服务定义-1"><a href="#服务定义-1" class="headerlink" title="服务定义"></a>服务定义</h3><p>服务定义方式：</p><ul><li>配置文件(推荐)</li><li>HTTP API</li></ul><p>一个服务定义包含的字段：</p><ul><li>name(必须)</li><li>id(可选)</li><li>tags(可选)</li><li>address(可选)</li><li>port(可选)</li><li>check(可选)</li><li>meta(可选)</li><li><code>enable_tag_override</code>(可选)</li><li>token(可选)</li></ul><p>id必须唯一，如果未设置id，默认使用name。</p><p><br></p><p>服务可以关联健康检查，这是一个强大的功能。<br>检查必须是脚本、HTTP、TCP或TTL类型。</p><ul><li>脚本类型，必须提供参数和间隔</li><li>HTTP类型，必须提供http和interval</li><li>TCP类型，必须提供tcp和interval</li><li>TTL类型，只能提供ttl</li></ul><p>检查名称自动生成为: <code>service:&lt;service-id&gt;</code>，如果有多个服务检查注册，生成的id为： <code>service:&lt;service:-id&gt;:&lt;num&gt;</code>，num是从1开始递增的数字。</p><p><br></p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/consul.d/redis.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;service&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;redis&quot;,</span><br><span class="line">        &quot;id&quot;: &quot;redis01&quot;,</span><br><span class="line">        &quot;tags&quot;: [</span><br><span class="line">            &quot;master&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;port&quot;: 6379,</span><br><span class="line">        &quot;meta&quot;: &#123;</span><br><span class="line">            &quot;meta&quot;: &quot;service definition for redis&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;enable_tag_override&quot;: false,</span><br><span class="line"></span><br><span class="line">        &quot;check&quot;: &#123;</span><br><span class="line">            &quot;id&quot;: &quot;redisTCP&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;redis service check&quot;,</span><br><span class="line">            &quot;tcp&quot;: &quot;localhost:6379&quot;,</span><br><span class="line">            &quot;interval&quot;: &quot;10s&quot;,</span><br><span class="line">            &quot;timeout&quot;: &quot;1s&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="多个服务定义"><a href="#多个服务定义" class="headerlink" title="多个服务定义"></a>多个服务定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;services&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;red0&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;redis&quot;,</span><br><span class="line">      &quot;tags&quot;: [</span><br><span class="line">        &quot;primary&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;address&quot;: &quot;&quot;,</span><br><span class="line">      &quot;port&quot;: 6000,</span><br><span class="line">      &quot;checks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;args&quot;: [&quot;/bin/check_redis&quot;, &quot;-p&quot;, &quot;6000&quot;],</span><br><span class="line">          &quot;interval&quot;: &quot;5s&quot;,</span><br><span class="line">          &quot;ttl&quot;: &quot;20s&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;red1&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;redis&quot;,</span><br><span class="line">      &quot;tags&quot;: [</span><br><span class="line">        &quot;delayed&quot;,</span><br><span class="line">        &quot;secondary&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;address&quot;: &quot;&quot;,</span><br><span class="line">      &quot;port&quot;: 7000,</span><br><span class="line">      &quot;checks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;args&quot;: [&quot;/bin/check_redis&quot;, &quot;-p&quot;, &quot;7000&quot;],</span><br><span class="line">          &quot;interval&quot;: &quot;30s&quot;,</span><br><span class="line">          &quot;ttl&quot;: &quot;60s&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="检查定义"><a href="#检查定义" class="headerlink" title="检查定义"></a>检查定义</h2><p>Agent的主要角色便是管理系统级和应用级的健康检查。<br>一个检查的定义有两种方式：</p><ul><li>配置文件</li><li>HTTP API</li></ul><p><br></p><p>检查方式：</p><ul><li>Script + Interval</li><li>HTTP + Interval</li><li>TCP + Interval</li><li>TTL</li><li>Docker + Interval</li><li>gRPC + Interval</li></ul><p><br></p><h3 id="定义检查-1"><a href="#定义检查-1" class="headerlink" title="定义检查"></a>定义检查</h3><p>A script check:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;check&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: &quot;mem-util&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;Memory utilization&quot;,</span><br><span class="line">    &quot;args&quot;: [&quot;/usr/local/bin/check_mem.py&quot;, &quot;-limit&quot;, &quot;256MB&quot;],</span><br><span class="line">    &quot;interval&quot;: &quot;10s&quot;,</span><br><span class="line">    &quot;timeout&quot;: &quot;1s&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>A HTTP check:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;check&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: &quot;api&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;HTTP API on port 5000&quot;,</span><br><span class="line">    &quot;http&quot;: &quot;https://localhost:5000/health&quot;,</span><br><span class="line">    &quot;tls_skip_verify&quot;: false,</span><br><span class="line">    &quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">    &quot;header&quot;: &#123;&quot;x-foo&quot;:[&quot;bar&quot;, &quot;baz&quot;]&#125;,</span><br><span class="line">    &quot;interval&quot;: &quot;10s&quot;,</span><br><span class="line">    &quot;timeout&quot;: &quot;1s&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>A TCP check:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;check&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: &quot;ssh&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;SSH TCP on port 22&quot;,</span><br><span class="line">    &quot;tcp&quot;: &quot;localhost:22&quot;,</span><br><span class="line">    &quot;interval&quot;: &quot;10s&quot;,</span><br><span class="line">    &quot;timeout&quot;: &quot;1s&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>A TTL check:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;check&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: &quot;web-app&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;Web App Status&quot;,</span><br><span class="line">    &quot;notes&quot;: &quot;Web app does a curl internally every 10 seconds&quot;,</span><br><span class="line">    &quot;ttl&quot;: &quot;30s&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>A Docker check:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;check&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: &quot;mem-util&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;Memory utilization&quot;,</span><br><span class="line">    &quot;docker_container_id&quot;: &quot;f972c95ebf0e&quot;,</span><br><span class="line">    &quot;shell&quot;: &quot;/bin/bash&quot;,</span><br><span class="line">    &quot;args&quot;: [&quot;/usr/local/bin/check_mem.py&quot;],</span><br><span class="line">    &quot;interval&quot;: &quot;10s&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>A gRPC check:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;check&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: &quot;mem-util&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;Service health status&quot;,</span><br><span class="line">    &quot;grpc&quot;: &quot;127.0.0.1:12345&quot;,</span><br><span class="line">    &quot;grpc_use_tls&quot;: true,</span><br><span class="line">    &quot;interval&quot;: &quot;10s&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="检查脚本"><a href="#检查脚本" class="headerlink" title="检查脚本"></a>检查脚本</h3><p>使用<code>enable_script_checks</code>选项来启用脚本检查。</p><p>检查脚本的退出码(exit code)必须遵循如下约定：</p><ul><li><p>exit code o<br>检查通过</p></li><li><p>exit code 1<br>检查警告</p></li><li><p>any exit code<br>检查失败</p></li></ul><p><br></p><h3 id="初始化健康检查状态"><a href="#初始化健康检查状态" class="headerlink" title="初始化健康检查状态"></a>初始化健康检查状态</h3><p>在某些情况下，可能需要指定健康检查的初始状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;check&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: &quot;mem&quot;,</span><br><span class="line">    &quot;args&quot;: [&quot;/bin/check_mem&quot;, &quot;-limit&quot;, &quot;256MB&quot;],</span><br><span class="line">    &quot;interval&quot;: &quot;10s&quot;,</span><br><span class="line">    &quot;status&quot;: &quot;passing&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="绑定服务检查"><a href="#绑定服务检查" class="headerlink" title="绑定服务检查"></a>绑定服务检查</h3><p>健康检查可以选择性地绑定到特定服务。这可以确保健康检查的状态只会影响给定服务的健康状态，而不会影响整个节点。<br>服务绑定检查需要添加一个<code>service_id</code>字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;check&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: &quot;web-app&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;Web App Status&quot;,</span><br><span class="line">    &quot;service_id&quot;: &quot;web-app&quot;,</span><br><span class="line">    &quot;ttl&quot;: &quot;30s&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="定义多个检查"><a href="#定义多个检查" class="headerlink" title="定义多个检查"></a>定义多个检查</h3><p>使用<code>checks</code>来定义多个服务检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;checks&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;chk1&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;mem&quot;,</span><br><span class="line">      &quot;args&quot;: [&quot;/bin/check_mem&quot;, &quot;-limit&quot;, &quot;256MB&quot;],</span><br><span class="line">      &quot;interval&quot;: &quot;5s&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;chk2&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;/health&quot;,</span><br><span class="line">      &quot;http&quot;: &quot;http://localhost:5000/health&quot;,</span><br><span class="line">      &quot;interval&quot;: &quot;15s&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;chk3&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;cpu&quot;,</span><br><span class="line">      &quot;script&quot;: &quot;/bin/check_cpu&quot;,</span><br><span class="line">      &quot;interval&quot;: &quot;10s&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>Encryption</p><p>Consul Agent支持加密所有流量。有两个独立的加密系统：</p><ul><li>gossip流量</li><li>RPC</li></ul><p><br></p><h3 id="gossip加密"><a href="#gossip加密" class="headerlink" title="gossip加密"></a>gossip加密</h3><p>启用geossip加密只需要你在启动Consul Agent时设置加密密钥(encryption key)。密钥是16Bytes的Base64编码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">consul keygen</span><br><span class="line">FDGDpW55oCYJlh555Es1gA==</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim /etc/consul.d/cluster.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;encrypt&quot;: &quot;FDGDpW55oCYJlh555Es1gA==&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>consul集群的所有节点必须共享相同的加密密钥！</p><p><br></p><h3 id="RPC加密"><a href="#RPC加密" class="headerlink" title="RPC加密"></a>RPC加密</h3><p>Consul支持使用TLS来验证Server和Client之间的真实性。它们之间使用由证书机构颁发的密钥对，你可以自己生成CA。</p><p><br><br><br></p><h2 id="Telemetry"><a href="#Telemetry" class="headerlink" title="Telemetry"></a>Telemetry</h2><p>Consul Agent收集有关不同库和子系统的各种运行时指标。这些指标以10s为间隔进行汇总，并保留1min。<br>查看这些数据，你需要向Consul进程发送信号：</p><ul><li>Unix: USR1</li><li>Windows: BREAK</li></ul><p>Consul收到信号后，它将当前的遥测(telemetry)信息转储到Agent’s STDERR。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#USR1 10</span><br><span class="line">kill -10 $&#123;consul-pid&#125;</span><br></pre></td></tr></table></figure><p>详情: <a href="https://www.consul.io/docs/agent/telemetry.html" target="_blank" rel="noopener">https://www.consul.io/docs/agent/telemetry.html</a></p><p><br><br><br></p><h2 id="Watches"><a href="#Watches" class="headerlink" title="Watches"></a>Watches</h2><p>watches是一种指定检测更新的数据视图的方式。检测到更新，将调用外部处理程序。<br>watch使用HTTP API中的blocking query，Agent自动进行适当的API调用已检测更新，并在数据视图更新时通知处理程序。<br>watch可以配置为Agent configuration的一部分，watch也可以在Agent之外启动。</p><p><br></p><h3 id="处理程序"><a href="#处理程序" class="headerlink" title="处理程序"></a>处理程序</h3><p>监测配置指定要监测的数据视图，更新视图后，将调用指定的处理程序(Handler)。外部程序可为可执行程序(executable)或HTTP endpoint。</p><ul><li><strong>可执行程序</strong><br>可执行处理程序从stdin读取json信息，此外<code>CONSUL_INDEX</code>环境变量将被设置为Consul Index写入stdout。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;key&quot;,</span><br><span class="line">  &quot;key&quot;: &quot;foo/bar/baz&quot;,</span><br><span class="line">  &quot;handler_type&quot;: &quot;script&quot;,</span><br><span class="line">  &quot;args&quot;: [&quot;/usr/bin/my-service-handler.sh&quot;, &quot;-redis&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#在consul v1.0以后，args数组被添加，以便可在没有shell的情况下运行处理程序</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>HTTP endpoint</strong><br>当watch被调用时发送HTTP请求给HTTP处理程序。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;key&quot;,</span><br><span class="line">  &quot;key&quot;: &quot;foo/bar/baz&quot;,</span><br><span class="line">  &quot;handler_type&quot;: &quot;http&quot;,</span><br><span class="line">  &quot;http_handler_config&quot;: &#123;</span><br><span class="line">    &quot;path&quot;:&quot;https://localhost:8000/watch&quot;,</span><br><span class="line">    &quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">    &quot;header&quot;: &#123;&quot;x-foo&quot;:[&quot;bar&quot;, &quot;baz&quot;]&#125;,</span><br><span class="line">    &quot;timeout&quot;: &quot;10s&quot;,</span><br><span class="line">    &quot;tls_skip_verify&quot;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h3><p>Global Parameters</p><ul><li>datacenter</li><li>token</li><li>args</li><li>handler</li></ul><p><br></p><h3 id="Watch类型"><a href="#Watch类型" class="headerlink" title="Watch类型"></a>Watch类型</h3><ul><li>key</li><li>keyprefix</li><li>services</li><li>nodes</li><li>service</li><li>checks</li><li>event</li></ul><p><br></p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">consul watch -type service -service redis</span><br><span class="line"></span><br><span class="line">consul watch -type checks -service redis</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#key</span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;key&quot;,</span><br><span class="line">  &quot;key&quot;: &quot;foo/bar/baz&quot;,</span><br><span class="line">  &quot;args&quot;: [&quot;/usr/bin/my-service-handler.sh&quot;, &quot;-redis&quot;]</span><br><span class="line">&#125;</span><br><span class="line">#or</span><br><span class="line">consul watch -type=key -key=foo/bar/baz /usr/bin/my-key-handler.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#keyprefix</span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;keyprefix&quot;,</span><br><span class="line">  &quot;prefix&quot;: &quot;foo/&quot;,</span><br><span class="line">  &quot;args&quot;: [&quot;/usr/bin/my-service-handler.sh&quot;, &quot;-redis&quot;]</span><br><span class="line">&#125;</span><br><span class="line">#or</span><br><span class="line">consul watch -type=keyprefix -prefix=foo/ /usr/bin/my-prefix-handler.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#services</span><br><span class="line">&#123;</span><br><span class="line">  &quot;redis&quot;: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#nodes</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;Node&quot;: &quot;node1&quot;,</span><br><span class="line">&quot;Address&quot;: &quot;192.168.1.11&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;Node&quot;: &quot;node2&quot;,</span><br><span class="line">&quot;Address&quot;: &quot;xxx&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#service</span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;service&quot;,</span><br><span class="line">  &quot;service&quot;: &quot;redis&quot;,</span><br><span class="line">  &quot;args&quot;: [&quot;/usr/bin/my-service-handler.sh&quot;, &quot;-redis&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#check</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;Node&quot;: &quot;foobar&quot;,</span><br><span class="line">    &quot;CheckID&quot;: &quot;service:redis&quot;,</span><br><span class="line">    &quot;Name&quot;: &quot;Service &apos;redis&apos; check&quot;,</span><br><span class="line">    &quot;Status&quot;: &quot;passing&quot;,</span><br><span class="line">    &quot;Notes&quot;: &quot;&quot;,</span><br><span class="line">    &quot;Output&quot;: &quot;&quot;,</span><br><span class="line">    &quot;ServiceID&quot;: &quot;redis&quot;,</span><br><span class="line">    &quot;ServiceName&quot;: &quot;redis&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#event</span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;event&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;web-deploy&quot;,</span><br><span class="line">  &quot;args&quot;: [&quot;/usr/bin/my-service-handler.sh&quot;, &quot;-web-deploy&quot;]</span><br><span class="line">&#125;</span><br><span class="line">#or</span><br><span class="line">consul watch -type=event -name=web-deploy /usr/bin/my-deploy-handler.sh -web-deploy</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="指南"><a href="#指南" class="headerlink" title="指南"></a>指南</h1><p>Consul Guide</p><p>本节提供了Consul各种常见的操作指南。</p><p>如下：</p><ul><li><p><strong>ACLs</strong><br>Consul访问控制列表，该功能用于控制对资源的访问。</p></li><li><p><strong>Adding/Removing Servers</strong><br>从集群中安全地添加和删除Consul Server，这应该小心操作。</p></li><li><p><strong>Autopilot</strong><br>为Consul Server提供自动友好操作的管理。</p></li><li><p><strong>Bootstrapping</strong><br>引导新的数据中心，包括安全地添加初始化Consul Server。</p></li><li><p><strong>Consul with Container</strong><br>在容器内运行Consul Cluster。</p></li><li><p><strong>DNS Caching</strong><br>为DNS查询缓存启用TTLS</p></li><li><p><strong>DNS Forwarding</strong><br>从BIND转发DNS查询到Consul</p></li><li><p><strong>External Services</strong><br>注册外部服务。允许在Consul框架内使用第三方服务。</p></li><li><p><strong>Federation</strong><br>配置Consul以支持多个数据中心。</p></li><li><p><strong>Geo Failover</strong><br>用准备好的查询来实现服务的地理故障转移。</p></li><li><p><strong>Leader Election</strong><br>使用Consul构建Client端的领导选举。</p></li><li><p><strong>Network Segments</strong><br>配置Consul使用网段-支持部分LAN连接。</p></li><li><p><strong>Outage Recovery</strong><br>恢复因Server故障而无法使用的集群。</p></li><li><p><strong>Semaphore</strong><br>使用KV存储实现一个信号量</p></li><li><p><strong>Sentinel</strong><br>使用哨兵模式在Consul中执行策略。</p></li><li><p><strong>Server Performance</strong><br>Consul Server的最低要求以及生产环境中运行Consul Server的指南。</p></li></ul><p><br><br><br></p><h2 id="ACLs"><a href="#ACLs" class="headerlink" title="ACLs"></a>ACLs</h2><p>Consul提供可选的访问控制列表系统，用于控制对数据和API的访问。它依赖于规则的token.</p><p>访问控制列表旨在提供易于使用，快速执行和灵活的新策略。</p><p><br></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>ACL Tokens</strong><br>访问控制列表系统基于token(令牌)，由Consul操作者通过 Consul ACL API进行管理。<br>如果没有提供token，则会自动关联与特殊的可配置匿名令牌(anonymous token)的规则。</p><p>每个token具有：</p><ul><li>ID</li><li>name</li><li>type<ul><li>client</li><li>management</li></ul></li><li>rule set(规则集)</li></ul><p><br></p><p><strong>ACL Rules and Scope</strong><br>token绑定到一组规则，用于控制令牌可以访问的Consul资源。可在白名单(whitelist)/黑名单(blacklist)下定义策略，这取决于默认策略<code>acl_default_policy</code>的值。</p><p>构建规则的ACL策略：</p><ul><li><p>agent<br>用于Agent API</p></li><li><p>event<br>用于Event API</p></li><li><p>key<br>用于KV Store API</p></li><li><p>keyring<br>用于Keyring API</p></li><li><p>node<br>用于Catalog API, Health API, Prepare Query API, Network Coordinate API， Agent API</p></li><li><p>operator<br>用于Operator API</p></li><li><p>query<br>用于Prepared Query API</p></li><li><p>service<br>Catalog API, Health API, Prepared Query API, Agent API</p></li><li><p>session<br>用于Session API</p></li></ul><p>由于Consul snapshots实际上包含ACL token，因此Snapshot API需要一个管理token进行快照操作。</p><p>ACL策略不包括如下资源：</p><ul><li>Status API</li><li>Catalog API</li></ul><p><br></p><p><strong>ACL Datacenter</strong><br>必须使用<code>acl_datacenter</code>配置所有节点(client/server)来启用ACL强制实施，但同时也是权威数据中心。Consul依靠RPC转发来支持多数据中心(multi-datacenter)。但是，由于可以跨数据中心边界发出请求，因此ACL令牌必须在全局范围内有效。为避免一致性问题，单个数据中心被视为具有权威性，并存储规范的令牌集。</p><p><br><br><br></p><h3 id="配置ACLs"><a href="#配置ACLs" class="headerlink" title="配置ACLs"></a>配置ACLs</h3><p>使用多个配置项配置ACL：</p><table><thead><tr><th>配置项</th><th>Server</th><th>Client</th><th>目的</th></tr></thead><tbody><tr><td><code>acl_datacenter</code></td><td>required</td><td>required</td><td>为ACL定义权威Consul数据中心来启用ACL的主控制</td></tr><tr><td><code>acl_default_policy</code></td><td>可选</td><td>n/a</td><td>定义白名单或黑名单模式</td></tr><tr><td><code>acl_down_policy</code></td><td>可选</td><td>可选</td><td>定义ACL数据中心脱机时执行的操作</td></tr><tr><td><code>acl_ttl</code></td><td>可选</td><td>可选</td><td>定义缓存ACL的生存时间</td></tr></tbody></table><p><br></p><p>配置特殊令牌，允许引导ACL系统或在特殊情况下访问Consul：</p><table><thead><tr><th>特殊令牌</th><th>Server</th><th>Client</th><th>目的</th></tr></thead><tbody><tr><td><code>acl_agent_master_token</code></td><td>可选</td><td>可选</td><td>当ACL数据中心不可用或Server脱机时，可用于访问Agent API</td></tr><tr><td><code>acl_agent_token</code></td><td>可选</td><td>可选</td><td>用于Agent内部操作</td></tr><tr><td><code>acl_master_token</code></td><td>required</td><td>n/a</td><td>用于引导ACL系统</td></tr><tr><td><code>acl_token</code></td><td>可选</td><td>可选</td><td>用于未提供token的客户端请求的默认令牌。这通常配置为对服务的只读访问权限，以便在Agent上启用DNS发现</td></tr></tbody></table><p><br></p><p><strong>ACL Agent Master Token</strong><br>由于<code>acl_agent_master_token</code>旨在Consul Server不可用时使用，因此其策略在Agent本地管理，并且不需要通过ACL API在Consul Server上定义token。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">agent &quot;&lt;node name of agent&gt;&quot; &#123;</span><br><span class="line">  policy = &quot;write&quot;</span><br><span class="line">&#125;</span><br><span class="line">node &quot;&quot; &#123;</span><br><span class="line">  policy = &quot;read&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>ACL Agent Token</strong><br><code>acl_agent_token</code>是一个特殊令牌，用于Agent的内部操作。用于Agent的如下操作：</p><ul><li>使用Catalog API更新Agent的节点条目</li><li>执行反熵同步</li><li>执行<code>consul_exec</code>命令时，读写KV存储库的特殊<code>_rexec部分</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node &quot;node1&quot; &#123;</span><br><span class="line">  policy = &quot;write&quot;</span><br><span class="line">&#125;</span><br><span class="line">service &quot;&quot; &#123;</span><br><span class="line">  policy = &quot;read&quot;</span><br><span class="line">&#125;</span><br><span class="line">key &quot;_rexec&quot; &#123;</span><br><span class="line">  policy = &quot;write&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何一个可在Agent上注册的服务，service策略需要读访问权限。</p><p><br><br><br></p><h3 id="引导ACLs"><a href="#引导ACLs" class="headerlink" title="引导ACLs"></a>引导ACLs</h3><p>Bootstrapping ACLs</p><p>在新集群上引导ACLs需要几个步骤：</p><p><strong>Enable ACLs on the Consul Servers</strong><br>引导ACLs的第一步便是在ACL数据中心的Consul Server上启用ACLs，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;acl_datacenter&quot;: &quot;dc1&quot;,</span><br><span class="line">  &quot;acl_master_token&quot;: &quot;123abc!@#,</span><br><span class="line">  &quot;acl_default_policy&quot;: &quot;deny&quot;,</span><br><span class="line">  &quot;acl_down_policy&quot;: &quot;deny&quot;,</span><br><span class="line">  &quot;acl_down_policy&quot;: &quot;extend-cache&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Create an Agent Token</strong><br>使用ACL API和上一步中设置的ACL Master Token创建令牌：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl --request PUT --header &quot;X-Consul-Token: 123abc!@#&quot; --data \</span><br><span class="line">&apos;&#123;</span><br><span class="line">   &quot;Name&quot;: &quot;Agent Token&quot;,</span><br><span class="line">   &quot;Type&quot;: &quot;client&quot;,</span><br><span class="line">   &quot;Rules&quot;: &quot;node \&quot;\&quot; &#123; policy = \&quot;write\&quot;&#125; service \&quot;\&quot; &#123; policy = \&quot;read\&quot; &#125;&quot;</span><br><span class="line">&#125;&apos; http://127.0.0.1:8500/v1/acl/create</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">返回的值便是新创建的token</span><br><span class="line">&#123;&quot;ID&quot;: &quot;xxxxxxxxxxxxxx&quot;&#125;</span><br></pre></td></tr></table></figure><p>返回的值便是新创建的token。将这个值添加到Consul Server配置中，并重启Server：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;acl_datacenter&quot;: &quot;dc1&quot;,</span><br><span class="line">  &quot;acl_master_token&quot;: &quot;123abc!@#,</span><br><span class="line">  &quot;acl_default_policy&quot;: &quot;deny&quot;,</span><br><span class="line">  &quot;acl_down_policy&quot;: &quot;deny&quot;,</span><br><span class="line">  &quot;acl_down_policy&quot;: &quot;extend-cache&quot;,</span><br><span class="line">  &quot;acl_agent_token&quot;: &quot;xxxxxxxxxxxxxxxx&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或使用API导入token：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl --request PUT --header &quot;X-Consul-Token: 123abc!@#&quot; --data \</span><br><span class="line">&apos;&#123;</span><br><span class="line">   &quot;Token&quot;: &quot;xxxxxxxxxxxxx&quot;</span><br><span class="line">&#125;&apos; http://127.0.0.1:8500/v1/agent/token/acl_agent_token</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Enable ACLs on the Consul Clients</strong><br>还需再Agent上配置ACL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;acl_datacenter&quot;: &quot;dc1&quot;,</span><br><span class="line">  &quot;acl_down_policy&quot;: &quot;extend-cache&quot;,</span><br><span class="line">  &quot;acl_agent_token&quot;: &quot;前面的acl_agent_token&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#或使用API</span><br><span class="line">curl \</span><br><span class="line">    --request PUT \</span><br><span class="line">    --header &quot;X-Consul-Token: abc123!@#&quot; \</span><br><span class="line">    --data \</span><br><span class="line">&apos;&#123;</span><br><span class="line">  &quot;Token&quot;: &quot;xxxxxxxxxxxx&quot;</span><br><span class="line">&#125;&apos; http://127.0.0.1:8500/v1/agent/token/acl_agent_token</span><br></pre></td></tr></table></figure><p>使用由Server创建的相同ACL Agent token，因为它不是特定于任何节点或前缀集。建议每个Client获取一个ACL agent token，该令牌具有对自己的节点名称前缀的节点有写入权限，以及针对预期在该Client上注册的服务前缀的读权限。</p><p><br></p><p><strong>Set an Anonymous Policy (Optional)</strong><br>此时，ACL已通过配置的ACL agent token进行引导，但还没有配置其它策略。<br>甚至像<code>consul members</code>这样的基本操作也会受到ACL默认策略<code>deny</code>的限制。</p><p>如果我们提供上面的Token，则能够看到具体信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONSUL_HTTP_TOKEN=xxxxxxxx consul members</span><br></pre></td></tr></table></figure><p>匿名令牌：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl \</span><br><span class="line">    --request PUT \</span><br><span class="line">    --header &quot;X-Consul-Token: 123abc!@#&quot; \</span><br><span class="line">    --data \</span><br><span class="line">&apos;&#123;</span><br><span class="line">  &quot;ID&quot;: &quot;anonymous&quot;,</span><br><span class="line">  &quot;Type&quot;: &quot;client&quot;,</span><br><span class="line">  &quot;Rules&quot;: &quot;node \&quot;\&quot; &#123; policy = \&quot;read\&quot; &#125;&quot;</span><br><span class="line">&#125;&apos; http://127.0.0.1:8500/v1/acl/update</span><br></pre></td></tr></table></figure><p>某个服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl \</span><br><span class="line">    --request PUT \</span><br><span class="line">    --header &quot;X-Consul-Token: 123abc!@#&quot; \</span><br><span class="line">    --data \</span><br><span class="line">&apos;&#123;</span><br><span class="line">  &quot;ID&quot;: &quot;anonymous&quot;,</span><br><span class="line">  &quot;Type&quot;: &quot;client&quot;,</span><br><span class="line">  &quot;Rules&quot;: &quot;node \&quot;\&quot; &#123; policy = \&quot;read\&quot; &#125; service \&quot;consul\&quot; &#123; policy = \&quot;read\&quot; &#125;&quot;</span><br><span class="line">&#125;&apos; http://127.0.0.1:8500/v1/acl/update</span><br></pre></td></tr></table></figure></p><p><br></p><p><strong>Set Agent-Specific Default Tokens (Optional)</strong><br>匿名令牌的替代方法是<code>acl_token</code>配置项。</p><p><br></p><p><strong>Create Tokens for UI Use (Optional)</strong><br>如果你使用具有限制性ACL策略的Consul UI，UI将无法使用匿名ACL令牌完整运行。<br>建议使用特定于UI的ACL令牌，可以在Web浏览器绘画期间在UI中设置该令牌对进口进行认证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl \</span><br><span class="line">    --request PUT \</span><br><span class="line">    --header &quot;X-Consul-Token: 123abc!@#&quot; \</span><br><span class="line">    --data \</span><br><span class="line">&apos;&#123;</span><br><span class="line">  &quot;Name&quot;: &quot;UI Token&quot;,</span><br><span class="line">  &quot;Type&quot;: &quot;client&quot;,</span><br><span class="line">  &quot;Rules&quot;: &quot;key \&quot;\&quot; &#123; policy = \&quot;write\&quot; &#125; node \&quot;\&quot; &#123; policy = \&quot;read\&quot; &#125; service \&quot;\&quot; &#123; policy = \&quot;read\&quot; &#125;&quot;</span><br><span class="line">&#125;&apos; http://127.0.0.1:8500/v1/acl/create</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>Rule Specification</p><p>ACL系统的和核心部分是规则语言，用于描述必须强制执行的策略。<br>使用基于前缀的规则，最具体的前缀匹配决定了操作。<br>使用HCL配置语言来指定规则，规则可定义多个策略。<br>ACL API运行使用HCL或JSON来定义规则部分的内容。</p><p>策略有以下集中处理方式：</p><ul><li>read</li><li>write(读写)</li><li>deny</li></ul><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># These control access to the key/value store.</span><br><span class="line">key &quot;&quot; &#123;</span><br><span class="line">  policy = &quot;read&quot;</span><br><span class="line">&#125;</span><br><span class="line">key &quot;foo/&quot; &#123;</span><br><span class="line">  policy = &quot;write&quot;</span><br><span class="line">&#125;</span><br><span class="line">key &quot;foo/private/&quot; &#123;</span><br><span class="line">  policy = &quot;deny&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># This controls access to cluster-wide Consul operator information.</span><br><span class="line">operator = &quot;read&quot;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Agent Rules</strong><br>Agent策略控制对Agent API中实用程序操作的访问。<br>Agent规则通过节点名称，使用欧冠最长前缀匹配规则。</p><p>Agent rules栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">agent &quot;&quot; &#123;</span><br><span class="line">  policy = &quot;read&quot;</span><br><span class="line">&#125;</span><br><span class="line">agent &quot;foo&quot; &#123;</span><br><span class="line">  policy = &quot;write&quot;</span><br><span class="line">&#125;</span><br><span class="line">agent &quot;bar&quot; &#123;</span><br><span class="line">  policy = &quot;deny&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，对具有空前缀的任何节点可读，对以foo开头的节点名进行读写，拒绝以bar开头的节点名。</p><p><br></p><p><strong>Event Rules</strong><br>事件策略控制对事件API中事件操作的访问。<br>事件规则由它们事件名称的前缀，使用最长匹配规则。</p><p>Event rules栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">event &quot;&quot; &#123;</span><br><span class="line">  policy = &quot;read&quot;</span><br><span class="line">&#125;</span><br><span class="line">event &quot;deploy&quot; &#123;</span><br><span class="line">  policy = &quot;write&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Key/Value Rules</strong><br>键值策略控制对KV API中的键值存储操作的访问。</p><p>Key规则栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">key &quot;&quot; &#123;</span><br><span class="line">  policy = &quot;read&quot;</span><br><span class="line">&#125;</span><br><span class="line">key &quot;foo&quot; &#123;</span><br><span class="line">  policy = &quot;write&quot;</span><br><span class="line">&#125;</span><br><span class="line">key &quot;bar&quot; &#123;</span><br><span class="line">  policy = &quot;deny&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>List Policy for Keys</strong><br>一个新的键列表策略，只有在通过布尔配置参数<code>acl_enable_key_list_policy</code>选择时才会强制执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">key &quot;&quot; &#123;</span><br><span class="line"> policy = &quot;deny&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key &quot;bar&quot; &#123;</span><br><span class="line"> policy = &quot;list&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key &quot;baz&quot; &#123;</span><br><span class="line"> policy = &quot;read&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Kerring Rules</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyring = &quot;write&quot;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Node Rules</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node &quot;&quot; &#123;</span><br><span class="line">  policy = &quot;read&quot;</span><br><span class="line">&#125;</span><br><span class="line">node &quot;app&quot; &#123;</span><br><span class="line">  policy = &quot;write&quot;</span><br><span class="line">&#125;</span><br><span class="line">node &quot;admin&quot; &#123;</span><br><span class="line">  policy = &quot;deny&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Operator Rules</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator = &quot;read&quot;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Prepared Query Rules</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query &quot;&quot; &#123;</span><br><span class="line">  policy = &quot;read&quot;</span><br><span class="line">&#125;</span><br><span class="line">query &quot;foo&quot; &#123;</span><br><span class="line">  policy = &quot;write&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="引导数据中心"><a href="#引导数据中心" class="headerlink" title="引导数据中心"></a>引导数据中心</h2><p>Bootstrapping a Datacenter</p><p>在Consul集群可以开始为请求提供服务之前，必须选在Server节点作为leader。Bootstrapping是将这些初始Server节点加入集群的过程。</p><p>建议的引导方式是使用<code>-bootstrap-expect</code>配置项。此配置项告知Consul预期的Server节点数，并在有许多Server可用时自动引导。为了防止不一致和脑裂情况(多个Server认为自己是leader)，所有Server应该指定相同的<code>-bootstrap-expect</code>，或根本不指定任何值。只有指定值的Server才会尝试引导集群。为了防止脑裂情况，Server不会选举自己作为leader。</p><p>推荐每个数据中心使用3或5台Server。不建议使用单个服务器部署数据中心。</p><p>加入一个集群:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#On NodeB</span><br><span class="line">consul join NodeA</span><br></pre></td></tr></table></figure><p><br></p><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>要触发选举leader，必须将这些机器连接在一起并创建一个集群。</p><ul><li>使用<code>-join</code>和<code>start_join</code>选项手动指定机器列表</li><li>使用<code>-retry-join</code>选项手动指定机器列表</li></ul><p><br><br><br></p><h2 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h2><p>使用Consul构建客户端的领导选举。</p><p>有多种方式建立领导选举，我们将专注于Consul sessions。会话允许我们构建一个可以优雅地处理故障的系统。</p><p><br></p><p><strong>协调节点</strong><br>Contending Nodes</p><p>假设一组节点试图称为给定服务的领导者，参与的所有节点应该就给定的键进行协调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">servece/&lt;service name&gt;/leader</span><br></pre></td></tr></table></figure><p><br></p><p>首先创建会话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT &apos;&#123; &quot;Name&quot;: &quot;dbservice&quot; &#125;&apos; http://localhost:8500/v1/session/create</span><br><span class="line"></span><br><span class="line">这回返回一个JSON对象的session ID</span><br></pre></td></tr></table></figure><p>下一步是使用<code>?acquirre=&lt;session&gt;</code>查询参数的KV条目上的PUT方法从此节点获取给定键的会话。<code>PUT</code>的<code>&lt;body&gt;</code>应该是表示本地节点的JSON对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT -d &lt;body&gt; http://localhost:8500/v1/kv/&lt;key&gt;?acquire=&lt;session&gt;</span><br><span class="line"></span><br><span class="line">如果返回true，则已获得锁定，并且本地节点时领导者</span><br><span class="line">如果返回false，则某个其它节点已获取锁定</span><br></pre></td></tr></table></figure><p>通过对<code>&lt;key&gt;</code>的阻塞查询来监视更改，如果注意到<code>&lt;key&gt;</code>的session是空白的，那么就没有领导者，我们应该重新锁定获取。<br>如果领导是自愿下台，这应该通过简单地释放锁来完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT http://localhost:8500/v1/kv/&lt;key&gt;?release=&lt;session&gt;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>发现一个领导者</strong><br>Discovering a Leader</p><p>关于领导者选举的另一种常见做法是节点希望识别给定服务的领导者。<br>与领导者选举一样，所有参与的节点都应该同意用于协调的密钥(key)。</p><p>Client有一个非常简单的角色，它们只需阅读<code>&lt;key&gt;</code>来发现当前的领导者是谁:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl  http://localhost:8500/v1/kv/&lt;key&gt;</span><br></pre></td></tr></table></figure><p>如果密钥没有关联的话，就没有领导者。<br>你可查询<code>/v1/session/info</code>获取session详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8500/v1/session/info/xxxxxxxxxxx</span><br></pre></td></tr></table></figure><p>Client还应使用阻塞查询来查看密钥的更改，如果领导者退出或失败将清除与密钥相关联的会话。当选出新的领导者时，密钥值也将更新。</p><p><br><br><br></p><hr><p><br></p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>文档链接: <a href="https://www.consul.io/api/index.html" target="_blank" rel="noopener">https://www.consul.io/api/index.html</a></p><p>Consul的主要接口是RESTful HTTP API。API可对node，service，check，configuration…执行基本的CRUD操作。</p><p><strong>版本前缀</strong><br>Version Prefix</p><p>所有API路由都以<code>/v1/</code>为前缀，这适用于v1 API。</p><p><br><br><br></p><hr><p><br></p><h1 id="consul-template"><a href="#consul-template" class="headerlink" title="consul-template"></a>consul-template</h1><p>Consul Template 查询consul instance，并更新文件系统上任意数量的指定模板。作为额外的奖励，Consul Template可以在模板更新完成时执行任意命令。</p><p>Consul Tempalte可以查询Consul中的服务条目，keys, key values。强大的抽象和模板查询语言是Consul Template非常适合创建动态配置。</p><p>如：</p><ul><li>Apache</li><li>Nginx</li><li>HAproxy</li></ul><p><br><br><br></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>下载地址: <a href="https://releases.hashicorp.com/consul-template/" target="_blank" rel="noopener">https://releases.hashicorp.com/consul-template/</a></li></ul><p>步骤：</p><ol><li>下载</li><li>解压</li><li>添加PATH</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wget https://releases.hashicorp.com/consul-template/0.19.5/consul-template_0.19.5_linux_amd64.tgz</span><br><span class="line"></span><br><span class="line">tar -xzvf ./consul-template_0.19.5_linux_amd64.tgz</span><br><span class="line">mv ./consul-template /bin/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">mv consul-template /usr/local/bin</span><br><span class="line">vim /etc/profile</span><br><span class="line">export PATH=$PATH:/usr/local/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consul-template --version</span><br><span class="line">consul-template v0.19.5 (57b6c71)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><p>官方栗子： <a href="https://github.com/hashicorp/consul-template/tree/master/examples" target="_blank" rel="noopener">https://github.com/hashicorp/consul-template/tree/master/examples</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul-template -h</span><br></pre></td></tr></table></figure><p><br></p><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>查询<code>demo.consul.io</code>这个consul实例。</p><p>渲染模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">consul-template \</span><br><span class="line">    -template &quot;/tmp/nginx.ctmpl:/var/nginx/nginx.conf:nginx -s reload&quot; \</span><br><span class="line">    -template &quot;/tmp/redis.ctmpl:/var/redis/redis.conf:service redis restart&quot; \</span><br><span class="line">    -template &quot;/tmp/haproxy.ctmpl:/var/haproxy/haproxy.conf&quot;</span><br></pre></td></tr></table></figure><p>监听Consul：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul-template -consul-addr=&quot;consul1:8500&quot; -consul-addr=&quot;consul2:8500&quot;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件使用 <a href="https://github.com/hashicorp/hcl" target="_blank" rel="noopener">HashiCorp Configuration Language</a>编写的。这意味着，配置也是JSON兼容的。</p><p>命令行指定的选项优先于配置文件！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/consul-template</span><br><span class="line"></span><br><span class="line">vim consul-template.hcl</span><br><span class="line"></span><br><span class="line">consul-template -config=&apos;/etc/consul-template/consul-template.hcl&apos;</span><br></pre></td></tr></table></figure><p>配置文件详情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br></pre></td><td class="code"><pre><span class="line"># This denotes the start of the configuration section for Consul. All values</span><br><span class="line"># contained in this section pertain to Consul.</span><br><span class="line">consul &#123;</span><br><span class="line">  # This block specifies the basic authentication information to pass with the</span><br><span class="line">  # request. For more information on authentication, please see the Consul</span><br><span class="line">  # documentation.</span><br><span class="line">  auth &#123;</span><br><span class="line">    enabled  = true</span><br><span class="line">    username = &quot;test&quot;</span><br><span class="line">    password = &quot;test&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # This is the address of the Consul agent. By default, this is</span><br><span class="line">  # 127.0.0.1:8500, which is the default bind and port for a local Consul</span><br><span class="line">  # agent. It is not recommended that you communicate directly with a Consul</span><br><span class="line">  # server, and instead communicate with the local Consul agent. There are many</span><br><span class="line">  # reasons for this, most importantly the Consul agent is able to multiplex</span><br><span class="line">  # connections to the Consul server and reduce the number of open HTTP</span><br><span class="line">  # connections. Additionally, it provides a &quot;well-known&quot; IP address for which</span><br><span class="line">  # clients can connect.</span><br><span class="line">  address = &quot;127.0.0.1:8500&quot;</span><br><span class="line"></span><br><span class="line">  # This is the ACL token to use when connecting to Consul. If you did not</span><br><span class="line">  # enable ACLs on your Consul cluster, you do not need to set this option.</span><br><span class="line">  #</span><br><span class="line">  # This option is also available via the environment variable CONSUL_TOKEN.</span><br><span class="line">  token = &quot;abcd1234&quot;</span><br><span class="line"></span><br><span class="line">  # This controls the retry behavior when an error is returned from Consul.</span><br><span class="line">  # Consul Template is highly fault tolerant, meaning it does not exit in the</span><br><span class="line">  # face of failure. Instead, it uses exponential back-off and retry functions</span><br><span class="line">  # to wait for the cluster to become available, as is customary in distributed</span><br><span class="line">  # systems.</span><br><span class="line">  retry &#123;</span><br><span class="line">    # This enabled retries. Retries are enabled by default, so this is</span><br><span class="line">    # redundant.</span><br><span class="line">    enabled = true</span><br><span class="line"></span><br><span class="line">    # This specifies the number of attempts to make before giving up. Each</span><br><span class="line">    # attempt adds the exponential backoff sleep time. Setting this to</span><br><span class="line">    # zero will implement an unlimited number of retries.</span><br><span class="line">    attempts = 12</span><br><span class="line"></span><br><span class="line">    # This is the base amount of time to sleep between retry attempts. Each</span><br><span class="line">    # retry sleeps for an exponent of 2 longer than this base. For 5 retries,</span><br><span class="line">    # the sleep times would be: 250ms, 500ms, 1s, 2s, then 4s.</span><br><span class="line">    backoff = &quot;250ms&quot;</span><br><span class="line"></span><br><span class="line">    # This is the maximum amount of time to sleep between retry attempts.</span><br><span class="line">    # When max_backoff is set to zero, there is no upper limit to the</span><br><span class="line">    # exponential sleep between retry attempts.</span><br><span class="line">    # If max_backoff is set to 10s and backoff is set to 1s, sleep times</span><br><span class="line">    # would be: 1s, 2s, 4s, 8s, 10s, 10s, ...</span><br><span class="line">    max_backoff = &quot;1m&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # This block configures the SSL options for connecting to the Consul server.</span><br><span class="line">  ssl &#123;</span><br><span class="line">    # This enables SSL. Specifying any option for SSL will also enable it.</span><br><span class="line">    enabled = true</span><br><span class="line"></span><br><span class="line">    # This enables SSL peer verification. The default value is &quot;true&quot;, which</span><br><span class="line">    # will check the global CA chain to make sure the given certificates are</span><br><span class="line">    # valid. If you are using a self-signed certificate that you have not added</span><br><span class="line">    # to the CA chain, you may want to disable SSL verification. However, please</span><br><span class="line">    # understand this is a potential security vulnerability.</span><br><span class="line">    verify = false</span><br><span class="line"></span><br><span class="line">    # This is the path to the certificate to use to authenticate. If just a</span><br><span class="line">    # certificate is provided, it is assumed to contain both the certificate and</span><br><span class="line">    # the key to convert to an X509 certificate. If both the certificate and</span><br><span class="line">    # key are specified, Consul Template will automatically combine them into an</span><br><span class="line">    # X509 certificate for you.</span><br><span class="line">    cert = &quot;/path/to/client/cert&quot;</span><br><span class="line">    key  = &quot;/path/to/client/key&quot;</span><br><span class="line"></span><br><span class="line">    # This is the path to the certificate authority to use as a CA. This is</span><br><span class="line">    # useful for self-signed certificates or for organizations using their own</span><br><span class="line">    # internal certificate authority.</span><br><span class="line">    ca_cert = &quot;/path/to/ca&quot;</span><br><span class="line"></span><br><span class="line">    # This is the path to a directory of PEM-encoded CA cert files. If both</span><br><span class="line">    # `ca_cert` and `ca_path` is specified, `ca_cert` is preferred.</span><br><span class="line">    ca_path = &quot;path/to/certs/&quot;</span><br><span class="line"></span><br><span class="line">    # This sets the SNI server name to use for validation.</span><br><span class="line">    server_name = &quot;my-server.com&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># This is the signal to listen for to trigger a reload event. The default</span><br><span class="line"># value is shown below. Setting this value to the empty string will cause CT</span><br><span class="line"># to not listen for any reload signals.</span><br><span class="line">reload_signal = &quot;SIGHUP&quot;</span><br><span class="line"></span><br><span class="line"># This is the signal to listen for to trigger a graceful stop. The default</span><br><span class="line"># value is shown below. Setting this value to the empty string will cause CT</span><br><span class="line"># to not listen for any graceful stop signals.</span><br><span class="line">kill_signal = &quot;SIGINT&quot;</span><br><span class="line"></span><br><span class="line"># This is the maximum interval to allow &quot;stale&quot; data. By default, only the</span><br><span class="line"># Consul leader will respond to queries; any requests to a follower will</span><br><span class="line"># forward to the leader. In large clusters with many requests, this is not as</span><br><span class="line"># scalable, so this option allows any follower to respond to a query, so long</span><br><span class="line"># as the last-replicated data is within these bounds. Higher values result in</span><br><span class="line"># less cluster load, but are more likely to have outdated data.</span><br><span class="line">max_stale = &quot;10m&quot;</span><br><span class="line"></span><br><span class="line"># This is the log level. If you find a bug in Consul Template, please enable</span><br><span class="line"># debug logs so we can help identify the issue. This is also available as a</span><br><span class="line"># command line flag.</span><br><span class="line">log_level = &quot;warn&quot;</span><br><span class="line"></span><br><span class="line"># This is the path to store a PID file which will contain the process ID of the</span><br><span class="line"># Consul Template process. This is useful if you plan to send custom signals</span><br><span class="line"># to the process.</span><br><span class="line">pid_file = &quot;/path/to/pid&quot;</span><br><span class="line"></span><br><span class="line"># This is the quiescence timers; it defines the minimum and maximum amount of</span><br><span class="line"># time to wait for the cluster to reach a consistent state before rendering a</span><br><span class="line"># template. This is useful to enable in systems that have a lot of flapping,</span><br><span class="line"># because it will reduce the the number of times a template is rendered.</span><br><span class="line">wait &#123;</span><br><span class="line">  min = &quot;5s&quot;</span><br><span class="line">  max = &quot;10s&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># This denotes the start of the configuration section for Vault. All values</span><br><span class="line"># contained in this section pertain to Vault.</span><br><span class="line">vault &#123;</span><br><span class="line">  # This is the address of the Vault leader. The protocol (http(s)) portion</span><br><span class="line">  # of the address is required.</span><br><span class="line">  address = &quot;https://vault.service.consul:8200&quot;</span><br><span class="line"></span><br><span class="line">  # This is the grace period between lease renewal of periodic secrets and secret</span><br><span class="line">  # re-acquisition. When renewing a secret, if the remaining lease is less than or</span><br><span class="line">  # equal to the configured grace, Consul Template will request a new credential.</span><br><span class="line">  # This prevents Vault from revoking the credential at expiration and Consul</span><br><span class="line">  # Template having a stale credential.</span><br><span class="line">  #</span><br><span class="line">  # Note: If you set this to a value that is higher than your default TTL or</span><br><span class="line">  # max TTL, Consul Template will always read a new secret!</span><br><span class="line">  #</span><br><span class="line">  # This should also be less than or around 1/3 of your TTL for a predictable</span><br><span class="line">  # behaviour. See https://github.com/hashicorp/vault/issues/3414</span><br><span class="line">  grace = &quot;5m&quot;</span><br><span class="line"></span><br><span class="line">  # This is the token to use when communicating with the Vault server.</span><br><span class="line">  # Like other tools that integrate with Vault, Consul Template makes the</span><br><span class="line">  # assumption that you provide it with a Vault token; it does not have the</span><br><span class="line">  # incorporated logic to generate tokens via Vault&apos;s auth methods.</span><br><span class="line">  #</span><br><span class="line">  # This value can also be specified via the environment variable VAULT_TOKEN.</span><br><span class="line">  token = &quot;abcd1234&quot;</span><br><span class="line"></span><br><span class="line">  # This tells Consul Template that the provided token is actually a wrapped</span><br><span class="line">  # token that should be unwrapped using Vault&apos;s cubbyhole response wrapping</span><br><span class="line">  # before being used. Please see Vault&apos;s cubbyhole response wrapping</span><br><span class="line">  # documentation for more information.</span><br><span class="line">  unwrap_token = true</span><br><span class="line"></span><br><span class="line">  # This option tells Consul Template to automatically renew the Vault token</span><br><span class="line">  # given. If you are unfamiliar with Vault&apos;s architecture, Vault requires</span><br><span class="line">  # tokens be renewed at some regular interval or they will be revoked. Consul</span><br><span class="line">  # Template will automatically renew the token at half the lease duration of</span><br><span class="line">  # the token. The default value is true, but this option can be disabled if</span><br><span class="line">  # you want to renew the Vault token using an out-of-band process.</span><br><span class="line">  #</span><br><span class="line">  # Note that secrets specified in a template (using &#123;&#123;secret&#125;&#125; for example)</span><br><span class="line">  # are always renewed, even if this option is set to false. This option only</span><br><span class="line">  # applies to the top-level Vault token itself.</span><br><span class="line">  renew_token = true</span><br><span class="line"></span><br><span class="line">  # This section details the retry options for connecting to Vault. Please see</span><br><span class="line">  # the retry options in the Consul section for more information (they are the</span><br><span class="line">  # same).</span><br><span class="line">  retry &#123;</span><br><span class="line">    # ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # This section details the SSL options for connecting to the Vault server.</span><br><span class="line">  # Please see the SSL options in the Consul section for more information (they</span><br><span class="line">  # are the same).</span><br><span class="line">  ssl &#123;</span><br><span class="line">    # ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># This block defines the configuration for connecting to a syslog server for</span><br><span class="line"># logging.</span><br><span class="line">syslog &#123;</span><br><span class="line">  # This enables syslog logging. Specifying any other option also enables</span><br><span class="line">  # syslog logging.</span><br><span class="line">  enabled = true</span><br><span class="line"></span><br><span class="line">  # This is the name of the syslog facility to log to.</span><br><span class="line">  facility = &quot;LOCAL5&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># This block defines the configuration for de-duplication mode. Please see the</span><br><span class="line"># de-duplication mode documentation later in the README for more information</span><br><span class="line"># on how de-duplication mode operates.</span><br><span class="line">deduplicate &#123;</span><br><span class="line">  # This enables de-duplication mode. Specifying any other options also enables</span><br><span class="line">  # de-duplication mode.</span><br><span class="line">  enabled = true</span><br><span class="line"></span><br><span class="line">  # This is the prefix to the path in Consul&apos;s KV store where de-duplication</span><br><span class="line">  # templates will be pre-rendered and stored.</span><br><span class="line">  prefix = &quot;consul-template/dedup/&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># This block defines the configuration for exec mode. Please see the exec mode</span><br><span class="line"># documentation at the bottom of this README for more information on how exec</span><br><span class="line"># mode operates and the caveats of this mode.</span><br><span class="line">exec &#123;</span><br><span class="line">  # This is the command to exec as a child process. There can be only one</span><br><span class="line">  # command per Consul Template process.</span><br><span class="line">  command = &quot;/usr/bin/app&quot;</span><br><span class="line"></span><br><span class="line">  # This is a random splay to wait before killing the command. The default</span><br><span class="line">  # value is 0 (no wait), but large clusters should consider setting a splay</span><br><span class="line">  # value to prevent all child processes from reloading at the same time when</span><br><span class="line">  # data changes occur. When this value is set to non-zero, Consul Template</span><br><span class="line">  # will wait a random period of time up to the splay value before reloading</span><br><span class="line">  # or killing the child process. This can be used to prevent the thundering</span><br><span class="line">  # herd problem on applications that do not gracefully reload.</span><br><span class="line">  splay = &quot;5s&quot;</span><br><span class="line"></span><br><span class="line">  env &#123;</span><br><span class="line">    # This specifies if the child process should not inherit the parent</span><br><span class="line">    # process&apos;s environment. By default, the child will have full access to the</span><br><span class="line">    # environment variables of the parent. Setting this to true will send only</span><br><span class="line">    # the values specified in `custom_env` to the child process.</span><br><span class="line">    pristine = false</span><br><span class="line"></span><br><span class="line">    # This specifies additional custom environment variables in the form shown</span><br><span class="line">    # below to inject into the child&apos;s runtime environment. If a custom</span><br><span class="line">    # environment variable shares its name with a system environment variable,</span><br><span class="line">    # the custom environment variable takes precedence. Even if pristine,</span><br><span class="line">    # whitelist, or blacklist is specified, all values in this option</span><br><span class="line">    # are given to the child process.</span><br><span class="line">    custom = [&quot;PATH=$PATH:/etc/myapp/bin&quot;]</span><br><span class="line"></span><br><span class="line">    # This specifies a list of environment variables to exclusively include in</span><br><span class="line">    # the list of environment variables exposed to the child process. If</span><br><span class="line">    # specified, only those environment variables matching the given patterns</span><br><span class="line">    # are exposed to the child process. These strings are matched using Go&apos;s</span><br><span class="line">    # glob function, so wildcards are permitted.</span><br><span class="line">    whitelist = [&quot;CONSUL_*&quot;]</span><br><span class="line"></span><br><span class="line">    # This specifies a list of environment variables to exclusively prohibit in</span><br><span class="line">    # the list of environment variables exposed to the child process. If</span><br><span class="line">    # specified, any environment variables matching the given patterns will not</span><br><span class="line">    # be exposed to the child process, even if they are whitelisted. The values</span><br><span class="line">    # in this option take precedence over the values in the whitelist.</span><br><span class="line">    # These strings are matched using Go&apos;s glob function, so wildcards are</span><br><span class="line">    # permitted.</span><br><span class="line">    blacklist = [&quot;VAULT_*&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # This defines the signal that will be sent to the child process when a</span><br><span class="line">  # change occurs in a watched template. The signal will only be sent after the</span><br><span class="line">  # process is started, and the process will only be started after all</span><br><span class="line">  # dependent templates have been rendered at least once. The default value is</span><br><span class="line">  # nil, which tells Consul Template to stop the child process and spawn a new</span><br><span class="line">  # one instead of sending it a signal. This is useful for legacy applications</span><br><span class="line">  # or applications that cannot properly reload their configuration without a</span><br><span class="line">  # full reload.</span><br><span class="line">  reload_signal = &quot;&quot;</span><br><span class="line"></span><br><span class="line">  # This defines the signal sent to the child process when Consul Template is</span><br><span class="line">  # gracefully shutting down. The application should begin a graceful cleanup.</span><br><span class="line">  # If the application does not terminate before the `kill_timeout`, it will</span><br><span class="line">  # be terminated (effectively &quot;kill -9&quot;). The default value is &quot;SIGTERM&quot;.</span><br><span class="line">  kill_signal = &quot;SIGINT&quot;</span><br><span class="line"></span><br><span class="line">  # This defines the amount of time to wait for the child process to gracefully</span><br><span class="line">  # terminate when Consul Template exits. After this specified time, the child</span><br><span class="line">  # process will be force-killed (effectively &quot;kill -9&quot;). The default value is</span><br><span class="line">  # &quot;30s&quot;.</span><br><span class="line">  kill_timeout = &quot;2s&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># This block defines the configuration for a template. Unlike other blocks,</span><br><span class="line"># this block may be specified multiple times to configure multiple templates.</span><br><span class="line"># It is also possible to configure templates via the CLI directly.</span><br><span class="line">template &#123;</span><br><span class="line">  # This is the source file on disk to use as the input template. This is often</span><br><span class="line">  # called the &quot;Consul Template template&quot;. This option is required if not using</span><br><span class="line">  # the `contents` option.</span><br><span class="line">  source = &quot;/path/on/disk/to/template.ctmpl&quot;</span><br><span class="line"></span><br><span class="line">  # This is the destination path on disk where the source template will render.</span><br><span class="line">  # If the parent directories do not exist, Consul Template will attempt to</span><br><span class="line">  # create them, unless create_dest_dirs is false.</span><br><span class="line">  destination = &quot;/path/on/disk/where/template/will/render.txt&quot;</span><br><span class="line"></span><br><span class="line">  # This options tells Consul Template to create the parent directories of the</span><br><span class="line">  # destination path if they do not exist. The default value is true.</span><br><span class="line">  create_dest_dirs = true</span><br><span class="line"></span><br><span class="line">  # This option allows embedding the contents of a template in the configuration</span><br><span class="line">  # file rather then supplying the `source` path to the template file. This is</span><br><span class="line">  # useful for short templates. This option is mutually exclusive with the</span><br><span class="line">  # `source` option.</span><br><span class="line">  contents = &quot;&#123;&#123; keyOrDefault \&quot;service/redis/maxconns@east-aws\&quot; \&quot;5\&quot; &#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line">  # This is the optional command to run when the template is rendered. The</span><br><span class="line">  # command will only run if the resulting template changes. The command must</span><br><span class="line">  # return within 30s (configurable), and it must have a successful exit code.</span><br><span class="line">  # Consul Template is not a replacement for a process monitor or init system.</span><br><span class="line">  command = &quot;restart service foo&quot;</span><br><span class="line"></span><br><span class="line">  # This is the maximum amount of time to wait for the optional command to</span><br><span class="line">  # return. Default is 30s.</span><br><span class="line">  command_timeout = &quot;60s&quot;</span><br><span class="line"></span><br><span class="line">  # Exit with an error when accessing a struct or map field/key that does not</span><br><span class="line">  # exist. The default behavior will print &quot;&lt;no value&gt;&quot; when accessing a field</span><br><span class="line">  # that does not exist. It is highly recommended you set this to &quot;true&quot; when</span><br><span class="line">  # retrieving secrets from Vault.</span><br><span class="line">  error_on_missing_key = false</span><br><span class="line"></span><br><span class="line">  # This is the permission to render the file. If this option is left</span><br><span class="line">  # unspecified, Consul Template will attempt to match the permissions of the</span><br><span class="line">  # file that already exists at the destination path. If no file exists at that</span><br><span class="line">  # path, the permissions are 0644.</span><br><span class="line">  perms = 0600</span><br><span class="line"></span><br><span class="line">  # This option backs up the previously rendered template at the destination</span><br><span class="line">  # path before writing a new one. It keeps exactly one backup. This option is</span><br><span class="line">  # useful for preventing accidental changes to the data without having a</span><br><span class="line">  # rollback strategy.</span><br><span class="line">  backup = true</span><br><span class="line"></span><br><span class="line">  # These are the delimiters to use in the template. The default is &quot;&#123;&#123;&quot; and</span><br><span class="line">  # &quot;&#125;&#125;&quot;, but for some templates, it may be easier to use a different delimiter</span><br><span class="line">  # that does not conflict with the output file itself.</span><br><span class="line">  left_delimiter  = &quot;&#123;&#123;&quot;</span><br><span class="line">  right_delimiter = &quot;&#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line">  # This is the `minimum(:maximum)` to wait before rendering a new template to</span><br><span class="line">  # disk and triggering a command, separated by a colon (`:`). If the optional</span><br><span class="line">  # maximum value is omitted, it is assumed to be 4x the required minimum value.</span><br><span class="line">  # This is a numeric time with a unit suffix (&quot;5s&quot;). There is no default value.</span><br><span class="line">  # The wait value for a template takes precedence over any globally-configured</span><br><span class="line">  # wait.</span><br><span class="line">  wait &#123;</span><br><span class="line">    min = &quot;2s&quot;</span><br><span class="line">    max = &quot;10s&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/consul-template/consul.hcl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">max_stale = &apos;10m&apos;</span><br><span class="line">wait = &#123;</span><br><span class="line">  min = &apos;1s&apos;</span><br><span class="line">  max = &apos;3s&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &#123;</span><br><span class="line">  source = &apos;/etc/consul-template/ctmpl/a.ctmpl&apos;</span><br><span class="line">  destination = &apos;/etc/nginx/conf.d/upstream-a.conf&apos;</span><br><span class="line">  command = &apos;systemctl reload nginx&apos;</span><br><span class="line">  perms = 0644</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">vim /etc/consul-template/ctmpl/a.ctmpl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">upstream upstream-a &#123;</span><br><span class="line">  &#123;&#123;range service &apos;a&apos;&#125;&#125;</span><br><span class="line">  server &#123;&#123;.Address&#125;&#125;:&#123;&#123;.Port&#125;&#125;;</span><br><span class="line">  &#123;&#123;else&#125;&#125;</span><br><span class="line">  server 127.0.0.1:12345;</span><br><span class="line">  &#123;&#123;end&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#nginx</span><br><span class="line">vim /etc/nginx/conf.d/upstream-a.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">upstream upstream-a &#123;</span><br><span class="line"></span><br><span class="line">  server 192.168.1.11:12345;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><p>Consul Template解析文件以 <a href="https://golang.org/pkg/text/template/" target="_blank" rel="noopener">Go Template</a>创作。<br>Consul Template提供了如下函数：</p><h4 id="API函数"><a href="#API函数" class="headerlink" title="API函数"></a>API函数</h4><p>API函数与远程API进行交互，与Consul等外部服务进行通信。</p><ul><li>datacenters<br>查询Consul目录中的所有数据中心。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; datacenters &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子</span><br><span class="line">&#123;&#123; range datacenters &#125;&#125;</span><br><span class="line">&#123;&#123; . &#125;&#125;&#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">#效果</span><br><span class="line">dc1</span><br><span class="line">dc2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.consul.io/intro/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.consul.io/intro/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.consul.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.consul.io/docs/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Consul Template: &lt;a href=&quot;https://www.hashicorp.com/blog/introducing-consul-template&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.hashicorp.com/blog/introducing-consul-template&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7x86_64&lt;/li&gt;
&lt;li&gt;Consul v1.2.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Consul" scheme="https://zhang21.github.io/tags/Consul/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://zhang21.github.io/2018/03/27/Docker/"/>
    <id>https://zhang21.github.io/2018/03/27/Docker/</id>
    <published>2018-03-27T00:38:33.000Z</published>
    <updated>2018-07-08T04:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>Docker文档:  <a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></li><li><a href="https://blog.csdn.net/sD7O95O/article/details/78623697" target="_blank" rel="noopener">https://blog.csdn.net/sD7O95O/article/details/78623697</a></li><li><a href="https://www.zhihu.com/question/22969309/answer/34030581" target="_blank" rel="noopener">https://www.zhihu.com/question/22969309/answer/34030581</a></li></ul><p>环境：</p><ul><li>CentOS7x86_64</li><li>Docker v18.03</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Docker是一个开发、shipping、运行应用程序的开放平台。Docker使你能够将应用程序与基础架构(infrastructure)分离开，从而可以快速交付软件。借助Docker，你可以像管理应用程序一样管理基础架构。利用Docker的方法快速进行运输、测试和部署代码，可以显著缩短编写代码和在生存环境中运行代码之间的延迟。</p><p><br></p><h2 id="Docker平台"><a href="#Docker平台" class="headerlink" title="Docker平台"></a>Docker平台</h2><p>Docker提供了在称为容器的松散隔离(isolated)环境中 打包和运行应用程序的能力。隔离性和安全性允许你在给定的主机上同时运行多个容器。容器是轻量级(lightweight)的，因为它们不需要hypervisor的额外负载，而是直接使用主机的内核运行。这意味着，与使用虚拟机相比，你可以在给定的硬件组合上运行更多的容器。你甚至可以在虚拟主机中运行Docker容器。</p><p>Docker提供了工具和平台来管理容器的生命周期(lifecycle)：</p><ul><li>使用容器开发应用程序及其支持组件</li><li>容器成为分发和测试你应用程序的单元</li><li>准备好后，将你的应用程序部署到生产环境中，作为容器协调服</li></ul><p><br></p><h2 id="Docker引擎"><a href="#Docker引擎" class="headerlink" title="Docker引擎"></a>Docker引擎</h2><p>Docker引擎是一个包含如下部件的client-server应用程序：</p><ul><li>Server是称为守护进程的dockerd</li><li>REST API是指定程序可用于与守护进程进行通信并指示其执行操作的接口</li><li>Client是command line interface(CLI)</li></ul><p><img src="/images/Docker/engine-components-flow.png" alt=""></p><p>Docker的开源许可协议是Apache2.0</p><p><br></p><h2 id="能用Docker做什么"><a href="#能用Docker做什么" class="headerlink" title="能用Docker做什么"></a>能用Docker做什么</h2><p><strong>快速、一致的交付应用程序</strong></p><p>通过允许开发人员在 提供应用程序和服务的本地容器 的标准化环境 下工作，Docker简化了开发生命周期。容器非常适合<strong>持续集成(continuous intergration,CI)和持续交付(continuous deliver,CD)</strong>工作流程。</p><p>考虑如下示例场景：</p><ul><li>开发者在本地编写代码，并使用Docker容器分享工作给他们的同事</li><li>使用Docker将应用程序push到测试环境，并自动执行和手动测试</li><li>当开发人员发现bug，他们能在开发环境中修复bug，并重新部署应用程序到测试环境进行测试和验证</li><li>测试完成后，向客户提供修补的应用程序 与将更新的image push到生产环境一样简单</li></ul><p><br></p><p><strong>响应式部署和伸缩</strong></p><ul><li>Docker的基于容器的平台支持高度可移植的工作负载。Docker container可以运行在笔记本、物理机、虚拟机、云平台…</li><li>Docker的可移植性和轻量化特性也使得动态管理工作负载非常容易，可以近乎实时地按业务需求扩展或拆分应用程序和服务</li></ul><p><br></p><p><strong>在同一硬件上运行更多的工作负载</strong></p><p>Docker轻量且快速。它为基于hypersior的虚拟机提供了一种可行、经济高效的替代方案，因此你可以使用更多计算容量来实现业务目标。Docker是高密度环境和中小型部署的理想选择，你需要用更小的资源做更多的事情。</p><p><br></p><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><p>Docker使用了client-server的体系架构。客户端向守护进程发送消息，守护进程负责构建、运行和分发 Docker容器。客户端和守护进程可以在同一系统上运行，也可将客户端连接到远程的Docker守护进程。客户端和守护进程使用REST API，通过Unix socket或network interface进程通信。</p><p><img src="/images/Docker/architecture.png" alt="Docker架构图"></p><p><br></p><h3 id="Docker-daemon"><a href="#Docker-daemon" class="headerlink" title="Docker daemon"></a>Docker daemon</h3><p>Docker daemon(<code>dockerd</code>)，监听Docker API请求并管理Docker对象——image、container、network、volume。<br>docker daemon还可与其它docker daemon通信来管理docker service。</p><p><br></p><h3 id="Docker-client"><a href="#Docker-client" class="headerlink" title="Docker client"></a>Docker client</h3><p>Docker client(<code>docker</code>)是许多Docker用户与Docker进行交互的主要方式。客户端将命令发送给守护进程，守护进程执行命令。<br>Docker命令使用Docker API，Docker客户端可与多个守护进程进行通信。</p><p><br></p><h3 id="Docker-registry"><a href="#Docker-registry" class="headerlink" title="Docker registry"></a>Docker registry</h3><p>Docker registry存储Docker image。Docker Hub和Docker Cloud是任何人都可使用的public registry，你可以创建private registry。</p><p><code>docker pull</code>或<code>docker run</code>需要的image便是从配置的registry中提取。<code>docker push</code>推送image到你配置的registry。</p><p><br></p><h2 id="Docker对象"><a href="#Docker对象" class="headerlink" title="Docker对象"></a>Docker对象</h2><p>当你使用Docker时，你会创建和使用 image、container、network、volume、plugin和其它对象。</p><p><br></p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>镜像是一个只读模板，带有创建Docker容器的说明。通常，镜像基于其它镜像，并具有一些额外的自定义功能。<br>例如，你可构建基于Ubuntu镜像的镜像，但会按照ApacheWeb服务器和应用程序，以及应用程序所需的配置。</p><p>你可能创建自己的镜像，或使用由别人创建并推送到registry上的镜像。构建自己的镜像，需要使用简单的语法创建一个Dockerfile，以定义创建镜像并运行它所需的步骤。</p><p><br></p><h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><p>容器是镜像的可运行实例。可将容器连接到一个或多个网络，将存储器连接到它，还可根据当前状态创建新镜像。</p><p>默认情况下，容器与其它容器以及主机是相对隔离的。你可以控制容器的网络、存储、其它底层子系统与其它容器或主机的隔离程度。</p><p>容器由镜像定义，以及你在创建或启动时提供给它的任何配置选项。当一个容器被移除时，其未被存储在永久存储器中的状态会消失。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#运行一个Ubuntu镜像，交互地连接到本地命令会话</span><br><span class="line"></span><br><span class="line">docker run -i -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>以上命令会发生如下步骤:</p><ol><li>如果本地没有Ubuntu镜像，docker会从registry拉取，就好像你手动运行 <code>docker pull ubuntu</code></li><li>Docker创建一个新容器，就好像你手动执行<code>docker container create</code></li><li>Docker分配一个读写文件系统给容器，作为它的最后一层</li><li>如果你没有指定任何网络选项，Docker会创建一个网络接口将容器连接到默认网络。</li><li>Docker开启容器并执行/bin/bash</li><li>发送<code>exit</code>到<code>/bin/bash</code>，容器停止但并未被移除</li></ol><p><br></p><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>服务允许你伸缩多个Docker守护进程的容器，这些守护进程可以作为一个swarm与多个manager和worker一起工作。默认情况下，该服务在所有node之间进行负载均衡。</p><p><br></p><h3 id="底层技术"><a href="#底层技术" class="headerlink" title="底层技术"></a>底层技术</h3><p>Docker使用GO编写，利用Linux内核的几个特性来提供其功能。</p><p><br></p><p><strong>namespace</strong></p><p>Docker使用一个称为<code>namespace</code>的技术来提供称为容器的独立工作空间。当你运行一个容器时，Docker会为该容器创建一组命名空间。<br>命名空间提供了一个隔离层。容器的每个方面都在单独<code>namespace</code>中运行，并且其访问权限仅限于该单独的<code>namespace</code>。</p><p>Docker引擎在Linux上使用如下<code>namespace</code>：</p><ul><li><code>pid</code> namespace： 进程隔离</li><li><code>net</code> namespace： 管理网络接口</li><li><code>ipc</code> namespace： 管理对IPC(InterProcess Communication)资源的访问</li><li><code>mnt</code> namespace： 管理文件系统挂载点</li><li><code>ust</code> namespace： 隔离内核和版本标识符(Unix Timesharing System)</li></ul><p><br></p><p><strong>control groups</strong></p><p>Linux上的Docker Engine也依赖与另一种称为控制组(cgroups)的技术。cgroup将应用程序限制为一组特定的资源。控制组允许Docker引擎将可用的硬件资源共享给容器，并可选地强制实施限制和约束。<br>例如，你可限制特定容器的内存是CPU使用率等。</p><p><br></p><p><strong>union file systems</strong></p><p>union file systems(UnionFS)，是通过创建layer进行操作的文件系统，使得它们非常轻量和快速。Docker引擎使用UnioFS为容器提供构建block。Docker引擎可以使用多种UnionFS变体，包括AUFS, brrfs, vfs, DeviceMapper…</p><p><br></p><p><strong>container format</strong></p><p>Docker引擎将namespace、cgroup、UnionFS组合成一个名为容器格式的包装器。默认的容器格式为<code>libcontainer</code>。</p><p><br><br><br></p><hr><p><br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Docker有两个可获取的版本：</p><ul><li>Community Edition(CE)<ul><li>适合开始使用Docker并尝试基于容器的应用程序的开发人员和小型团队</li></ul></li><li>Enterprise Edition(EE)<ul><li>专为企业开发和IT团队而设计，可以在生产规模上构建，发布和运行关键业务应用程序</li></ul></li></ul><p><br><br><br></p><h2 id="CentOS7安装Docker-CE"><a href="#CentOS7安装Docker-CE" class="headerlink" title="CentOS7安装Docker CE"></a>CentOS7安装Docker CE</h2><h3 id="OS要求"><a href="#OS要求" class="headerlink" title="OS要求"></a>OS要求</h3><ul><li>CentOS7.x</li><li><code>centos-extras</code> repository</li><li>推荐使用<code>overlay2</code>存储驱动</li><li>安装新版本Docker需卸载老版本Docker</li><li>Docker CE包被称为<code>docker-ce</code></li></ul><p><br></p><h3 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h3><ul><li><a href="https://download.docker.com/" target="_blank" rel="noopener">https://download.docker.com/</a></li></ul><p>多种安装方法：</p><ul><li>Docker’s repository</li><li>RPM package</li><li>scripts</li></ul><p><br></p><p><strong>使用repository安装：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#安装依赖</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#设置repository</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#安装Docker CE</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"></span><br><span class="line"> <span class="comment">#Docker安装但未启动，docker group会被创建，但没有用户添加到组中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#在生产环境中，你可能需要安装特定版本的Docker CE，而不是最新版</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line">yum search docker-ce --showduplicates</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#开启docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#测试docker</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"> <span class="comment">#此命令下载一个测试image并将其运行到container中</span></span><br><span class="line"> <span class="comment">#Hello from Docker!</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用package安装：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#下载rpm包</span></span><br><span class="line">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#安装</span></span><br><span class="line">yum install -y /path/docker-cexxx.rpm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用scripts安装：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line"></span><br><span class="line">sh get-docker.sh</span><br><span class="line"></span><br><span class="line"> <span class="comment">#手动添加group合user</span></span><br><span class="line">usermod -aG docker your-user</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="卸载Docker-CE"><a href="#卸载Docker-CE" class="headerlink" title="卸载Docker CE"></a>卸载Docker CE</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker-ce</span><br><span class="line"></span><br><span class="line"> <span class="comment">#默认文件</span></span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line"> <span class="comment">#你还需要手动删除其它配置文件</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p><br><br><br></p><h2 id="关于Docker"><a href="#关于Docker" class="headerlink" title="关于Docker"></a>关于Docker</h2><p>Docker文档会有如下讲解：</p><ul><li>设置你的Docker环境</li><li>在一个容器(container)中构建并运行一个镜像</li><li>延伸你的APP以便在多个容器中运行</li><li>在整个集群中分配你的APP</li><li>通过添加后端数据库来堆栈服务</li><li>将应用部署到生产</li></ul><p><br></p><h3 id="Docker的概念"><a href="#Docker的概念" class="headerlink" title="Docker的概念"></a>Docker的概念</h3><p>Docker是开发人员，系统管理员使用容器来开发、部署和运行APP的平台。使用Linux容器来部署APP被称为<strong>集装箱化(containerzation)</strong></p><p><img src="/images/Docker/laurel-docker-containers.png" alt=""></p><p>集装箱受欢迎的几点原因：</p><ul><li>灵活(flexible)</li><li>轻量(lightweight)</li><li>通用(Interchangeable)</li><li>可移植(portable)</li><li>延伸(scalable)</li><li>堆栈(stackable)</li></ul><p><br></p><h3 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h3><p>通过运行镜像(image)启动容器(container)。镜像是一个可执行包，包含运行APP所需的所有内容：代码，库，环境变量，配置文件…</p><p>容器是镜像的运行时(runtime)实例。在Linux上使用<code>docker ps</code>命令查看运行的容器列表。</p><p><br></p><h3 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h3><p>容器在Linux本地上运行，并与其它容器共享主机Kernel。它是一个独立的进程，不占其它可执行文件内存，使其轻量化。</p><p>虚拟机(VM)运行一个完整的访客操作系统，通过虚拟机管理程序访问主机资源。一般来说，虚拟机比大多数应用程序需要的资源更多。</p><p><img src="/images/Docker/docker002.png" alt=""></p><p><br><br><br></p><h3 id="准备Docker环境"><a href="#准备Docker环境" class="headerlink" title="准备Docker环境"></a>准备Docker环境</h3><p>Docker版本：</p><ul><li>CE: Docker Community Edition</li><li>EE: Docker Enterprise Edition</li></ul><p><a href="#安装Docker">Install Docker</a></p><p><br></p><h2 id="测试Docker"><a href="#测试Docker" class="headerlink" title="测试Docker"></a>测试Docker</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看详细信息</span></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试安装工作是否正常</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看镜像</span></span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出容器</span></span><br><span class="line">docker container ls -all</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker命令</span></span><br><span class="line">docker</span><br><span class="line">docker container --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>集装箱化使得<strong>CI/CD</strong>无缝：</p><ul><li>持续集成(Continuous integration, CI)</li><li>持续部署(continuous deployment, CD)</li><li>APP无系统依赖</li><li>更新能够推送到分布式APP的任何部分</li><li>资源密度可以被优化</li></ul><p>使用Docker，扩展APP的过程就是启动新的可执行文件，而不是运行繁重的VM主机。</p><p><br><br><br></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Container</p><p><br></p><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><br></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>是时候使用Docker方式来构建一个APP了。</p><ul><li>从应用程序的层次结构底部开始，这是一个容器(container)</li><li>在此级别之上，是一个服务(service)，它定义了容器在生产中的表现</li><li>最后，顶层是堆栈(stack)，定义所有服务的交互(interaction)</li></ul><p>Like this:</p><ul><li>Stack</li><li>Service</li><li>Container</li></ul><p><br></p><h3 id="新开发环境"><a href="#新开发环境" class="headerlink" title="新开发环境"></a>新开发环境</h3><p>在过去，如果你要开始编写一个Python APP，你的第一要务是在你的机器运行时安装Python。但是，这会造成你的计算机上的环境，需要如预期般完美适合你的APP，并且还需要与你的生产环境相匹配。</p><p>使用Docker，你可以将一个可移植的Python运行时作为一个image，无需安装。接着，你的构建可以将基础Python image与APP代码一起包含在内，确保你的APP，依赖项…都构建一起。</p><p><br></p><h3 id="使用Dockerfile定义一个容器"><a href="#使用Dockerfile定义一个容器" class="headerlink" title="使用Dockerfile定义一个容器"></a>使用<code>Dockerfile</code>定义一个容器</h3><p><code>Dockerfile</code>定义了容器内环境中发生的事情。访问的网络接口(network interface)和磁盘驱动(disk driver)等资源是在此环境中虚拟化的(virtualized)，与系统其余部分隔离。因此你需要将端口映射(map port)到外部世界，并明确指定要将哪些文件<strong>复制</strong>到此环境中。但是，在完成这些后，你完全可以将它们看做一致 —— 在<code>Dockerfile</code>中定义的构建的APP的行为与它运行时的行为完全相同。</p><p><strong>Dockerfile</strong></p><p>创建一个空目录，并创建一个名叫<code>Dockerfile</code>的文件，复制以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to /app</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at /app</span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><p>注意代理服务器会阻断你与APP的连接！</p><p>这个<code>Dockerfile</code>引用了一些我们还没有创建的文件，分别是<code>app.py</code>和<code>requirements.txt</code>。接下来创建它们。</p><p><br></p><h3 id="APP自身"><a href="#APP自身" class="headerlink" title="APP自身"></a>APP自身</h3><p>创建另外的文件，如上面的<code>app.py</code>和<code>requirements.txt</code>，并将它们与<code>Dockerfile</code>放置于同一目录下。这就完成了我们的APP，这看起来非常简单。当这个<code>Dockerfile</code>被构建成一个image时，由于<code>Dockerfile</code>的<code>ADD</code>命令，<code>app.py</code>和<code>requirements.txt</code>仍然存在，而且由于使用了EXPOSE命令，<code>app.py</code>的输出仍可以通过HTTP访问。</p><p><strong>requirements.txt: </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><p><strong>app.py: </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br></pre></td></tr></table></figure><blockquote><p>在容器内访问主机的名称将检索容器ID，这进程ID类似。</p></blockquote><p>仅此而已，在你的系统中，你不需要任何Python或requirements.txt文件，也不需要在你的系统上安装 构建或运行的image。看起来你并没有真正用Python和Flask建立一个环境，但是你确实已经拥有了。</p><p><br></p><h3 id="构建APP"><a href="#构建APP" class="headerlink" title="构建APP"></a>构建APP</h3><p>我们准备去构建(build)APP。确保你仍在目录的顶层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#查看是否还在顶层</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">Dockerfileapp.pyrequirements.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在此目录运行build命令，这将创建一个Docker image，用 -t 命名</span><br><span class="line">docker build -t friendlyhello .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看你build的image</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">friendlyhello       latest              b24e21d7645f        13 minutes ago      150MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#运行APP</span><br><span class="line">docker run -p 4000:80 friendlyhello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#测试</span><br><span class="line">curl http://localhost:4000</span><br><span class="line">links http://localhost:4000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在后台运行</span><br><span class="line">docker run -d -p 4000:80 friendlyhello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看容器</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">146662dca737        friendlyhello       &quot;python app.py&quot;     16 seconds ago      Up 16 seconds       0.0.0.0:4000-&gt;80/tcp   goofy_chaplygin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#停止</span><br><span class="line">Ctrl + C</span><br><span class="line">docker container stop docker-ID</span><br><span class="line">docker container stop 146662dca737</span><br></pre></td></tr></table></figure><p><img src="/images/Docker/docker003.png" alt="效果图"></p><p><br></p><p>端口重映射<code>4000:80</code>是为了证明Dockerfile中的EXPOSE与使用<code>docker run -p</code>发布的内容之间的区别。<br>在后续步骤中，我们只需将主机的80端口映射到容器的80端口就好。</p><p><br></p><h3 id="分享你的image"><a href="#分享你的image" class="headerlink" title="分享你的image"></a>分享你的image</h3><p>为了演示刚才创建的image的可移植性(portability)，让我们上传build的image并在其它地方run它。毕竟，当你需要将container部署到生产环境时，你需要知道如何push注册。</p><p>注册表(registry)是一个repository的集合，而repository是image的集合——有点类似于GitHub repository，但代码是已经构建了的。<br>注册表上的账户可以创建许多repository。docker CLI 默认使用Docker’s public registry。你也可以选择其它注册表，或创建自己的注册表。</p><p><br></p><p><strong>使用Docker ID登录：</strong></p><p>如果没有Docker账户，请先注册 <cloud.docker.com>。</cloud.docker.com></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br><span class="line"></span><br><span class="line">docker login -u zhang21</span><br></pre></td></tr></table></figure><p><br></p><p><strong>标记image：</strong></p><p>使用<code>username/repository:tag</code>将本地image与registry中的repository相关联。tag是可选的，但推荐使用tag。因为它是注册管理机构用于为Docker image提供版本的机制。为该内容提供一个有意义的repository和tag，例如<code>get-started:part2</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker tag image username/repository:tag</span><br><span class="line"></span><br><span class="line">#例子</span><br><span class="line">docker tag friendlyhello zhang/test:tag-test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看tag</span><br><span class="line">docker images ls</span><br></pre></td></tr></table></figure><p><br></p><p><strong>发布image：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#上传你标记了的image到repository</span><br><span class="line">docker push username/repository:tag</span><br><span class="line"></span><br><span class="line">docker push zhang21/test:tag-test</span><br><span class="line"></span><br><span class="line">#完成后，此image便可以公开获取</span><br></pre></td></tr></table></figure><p><br></p><p><strong>从远处repository拉取并运行image：</strong></p><p>无论在哪里执行<code>docker run</code>，它都会将你的image以及Python和所有依赖关系一起拉取下来，并运行你的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 username/repository:tag</span><br><span class="line"></span><br><span class="line">docker run -p 80:80 zhang21/test:tag-test</span><br></pre></td></tr></table></figure><p><br></p><h3 id="本节基础命令"><a href="#本节基础命令" class="headerlink" title="本节基础命令"></a>本节基础命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从Dockerfile创建image</span></span><br><span class="line">docker build -t image-name .</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行image</span></span><br><span class="line">docker run -p 4000:80 image-name</span><br><span class="line"></span><br><span class="line"><span class="comment">#后台运行</span></span><br><span class="line">docker run -d -p 4000:80 image-name</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出运行的容器</span></span><br><span class="line">docker container ls</span><br><span class="line"><span class="comment">#列出所有容器，包括未运行</span></span><br><span class="line">docker container ls -a</span><br><span class="line"></span><br><span class="line"><span class="comment">#优雅停止容器</span></span><br><span class="line">docker container stop 容器ID</span><br><span class="line"><span class="comment">#强制停止</span></span><br><span class="line">docker container <span class="built_in">kill</span> 容器ID</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除容器</span></span><br><span class="line">docker container rm 容器ID</span><br><span class="line"><span class="comment">#删除所有容器</span></span><br><span class="line">docker container rm $(docker container ls -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出镜像</span></span><br><span class="line">docker image ls</span><br><span class="line"><span class="comment">#列出所有镜像</span></span><br><span class="line">docker image ls -a</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除镜像</span></span><br><span class="line">docker image rm 镜像ID</span><br><span class="line"><span class="comment">#删除所有镜像</span></span><br><span class="line">docker image rm $(docker image ls -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment">#登录</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment">#标记</span></span><br><span class="line">docker tag 镜像 username/repository:tag</span><br><span class="line"></span><br><span class="line"><span class="comment">#上传到注册表</span></span><br><span class="line">docker push username/repository:tag</span><br><span class="line"></span><br><span class="line"><span class="comment">#从注册表拉取</span></span><br><span class="line">docker run username/repository:tag</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>service</p><p><br></p><h3 id="先决条件-1"><a href="#先决条件-1" class="headerlink" title="先决条件"></a>先决条件</h3><ul><li>安装Docker</li><li>获取Docker Compose</li><li>阅读Orientation</li><li>阅读Container</li><li>确保已发布friendlyhello image到你的registry</li><li>确保你的image工作为一个部署的container。<code>docker run -p 80:80 username/repo:tag</code></li></ul><p><br></p><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>在此，我们<strong>扩展(scale)</strong>APP并启用<strong>负载均衡(load balancing)</strong>。要做到这样，我们必须在分布式(distributed)应用程序的层次结构中升一级: 服务</p><ul><li>Stack</li><li>Service</li><li>Container</li></ul><p><br></p><h3 id="关于服务"><a href="#关于服务" class="headerlink" title="关于服务"></a>关于服务</h3><p>在分布式应用程序中，应用程序的不同部分称为服务(service)。</p><p>例如，一个视频共享站点。那么它可能包含：</p><ul><li>用于将应用程序数据 存储到数据库中的服务</li><li>用户上传后的视频转码服务</li><li>前端服务</li><li>…</li></ul><p>服务是真正的生产环境中的容器。一个service只运行一个image，但它可修改image的运行方式 —— 哪个端口、容器应该运行多少个副本以便于服务所需的容量等.<br>伸缩服务会更改运行该软件的容器实例数量，从而为进程中的服务分配更多的计算资源。</p><p>在Docker平台上定义、运行和伸缩服务都是很简单的 —— 只需修改<code>docker-compose.yml</code>文件。</p><p><br></p><h3 id="你的第一个docker-compose-yml文件"><a href="#你的第一个docker-compose-yml文件" class="headerlink" title="你的第一个docker-compose.yml文件"></a>你的第一个<code>docker-compose.yml</code>文件</h3><p><code>docker-compose.yml</code>是一个YAML文件，它定义了Docker container在生产中的行为方式。</p><p><strong>docker-compose.yml：</strong></p><p>将如下信息保存为<code>docker-compose.yml</code>，确保你已经<code>pushed the image</code>到registry，并通过修改<code>.yml</code>文件的image detail来替换<code>username/repo:tag</code>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line">    <span class="comment"># replace username/repo:tag with your name and image details</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">username/repo:tag</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">      resources:</span></span><br><span class="line"><span class="attr">        limits:</span></span><br><span class="line"><span class="attr">          cpus:</span> <span class="string">"0.1"</span></span><br><span class="line"><span class="attr">          memory:</span> <span class="number">50</span><span class="string">M</span></span><br><span class="line"><span class="attr">      restart_policy:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:80"</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">webnet</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  webnet:</span></span><br></pre></td></tr></table></figure><p><br></p><p><code>docker-compose.yml</code>文件告诉Docker之下如下操作：</p><ul><li>pull the image</li><li>Run 5 instances of that image as a service called <code>web</code></li><li>限制每个实例最多使用10%的CPU和50MB的RAM</li><li>如果一个失败，马上重启container</li><li>映射主机的80端口到web的80端口</li><li>指示web container通过称为<code>webnet</code>的负载均衡网络共享80端口</li><li>使用默认设置定义<code>webnet</code>网络</li></ul><p><br></p><h3 id="运行你的负载均衡APP"><a href="#运行你的负载均衡APP" class="headerlink" title="运行你的负载均衡APP"></a>运行你的负载均衡APP</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行并设置APP名字</span></span><br><span class="line">docker stack -c docker-compose.yml app-name</span><br><span class="line"></span><br><span class="line">docker stack -c docker-compose.yml LoadBalance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在一个主机上，单个服务栈通过部署的image运行5个container instance</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取service ID</span></span><br><span class="line">docker service ls</span><br><span class="line"></span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                   PORTS</span><br><span class="line">3d1a48yse0t4        LoabBalance_web     replicated          5/5                 zhang21/<span class="built_in">test</span>:tag-test   *:80-&gt;80/tcp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看服务中的任务</span></span><br><span class="line">docker service ps app-name_web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker container ls -q</span><br><span class="line"></span><br><span class="line"><span class="comment">#5个容器ID</span></span><br><span class="line">c7ce0075890e</span><br><span class="line">52ba026bf28c</span><br><span class="line">6d4381be438f</span><br><span class="line">bd297a42e89d</span><br><span class="line">357b05cc38eb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#访问的时候容器ID会在此5个负载中变化</span></span><br></pre></td></tr></table></figure><p>在服务中运行的单个container称为任务(task)。任务是具有数字增量的唯一ID，最大数量是在<code>docker-compose.yml</code>中定义的副本数量。</p><p><br></p><h3 id="伸缩APP"><a href="#伸缩APP" class="headerlink" title="伸缩APP"></a>伸缩APP</h3><p>通过修改<code>docker-compose.yml</code>中<code>replicas</code>的值，并重新运行<code>docker stack deploy -c xxx app-name</code>来伸缩APP。</p><p>Docker执行就地更新，不需要stack down或kill any containers.</p><p><strong>卸下APP和swarm：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app</span></span><br><span class="line">docker stack rm app-name</span><br><span class="line"></span><br><span class="line">docker stack rm LoadBalance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#swarm</span></span><br><span class="line">docker swarm leave --force</span><br></pre></td></tr></table></figure><p>使用Docker扩展APP非常简单。</p><p><br></p><h3 id="本节命令"><a href="#本节命令" class="headerlink" title="本节命令"></a>本节命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出栈或APP</span></span><br><span class="line">docker stack ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行指定配置文件</span></span><br><span class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出与APP相关联的服务</span></span><br><span class="line">docker service ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出与APP相关联的任务</span></span><br><span class="line">docker service ps &lt;service&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查任务</span></span><br><span class="line">docker inspect &lt;task or container&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出容器ID</span></span><br><span class="line">docker container ls -q</span><br><span class="line"></span><br><span class="line"><span class="comment">#除掉APP</span></span><br><span class="line">docker stack rm &lt;appname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#从管理中除掉一个单一节点swarm</span></span><br><span class="line">docker swarm leave --force</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="swarm"><a href="#swarm" class="headerlink" title="swarm"></a>swarm</h2><p><br></p><h3 id="先决条件-2"><a href="#先决条件-2" class="headerlink" title="先决条件"></a>先决条件</h3><ul><li>前面几个小节的内容</li></ul><p><br></p><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>前面你将一个服务运行在生产环境，并扩展为5个副本进程。</p><p>在此，你将APP部署到到集群上，并在多台机器上运行它。通过将多台主机连接到成为<strong>swarm</strong>的<strong>Dockerized</strong>集群，使得多容器、多主机应用成为可能。</p><p><br></p><h3 id="理解swarm集群"><a href="#理解swarm集群" class="headerlink" title="理解swarm集群"></a>理解swarm集群</h3><p>swarm是一组运行Docker并加入到集群中的机器。这样以后，你可以在集群的swarm manager上执行Docker命令。swarm中的机器可以是物理的或虚拟的，当他们加入swarm后，他们便被成为node。</p><p>swarm manager可以使用多种策略来运行容器，你可在compose file中指定相应的策略。</p><p>swarm manager是swarm中唯一可以执行命令、授权其他机器作为工作者加入swarm的机器。工作者(worker)只能在那提供能力(capacity)，并没有权力告诉任何机器能够做什么。</p><p>但目前为止，你已经在本机机器上以单主机(single host)模式使用Docker。但Docker也可以切换为swarm(集群)模式，这就是使用swarm的原因。立即启用swarm模式使得当前机器成为swarm manager。从此，Docker将运行在你管理的swarm上执行命令，而不仅仅是在当前机器上执行。</p><p><br></p><h3 id="建立swarm"><a href="#建立swarm" class="headerlink" title="建立swarm"></a>建立swarm</h3><p>一个swarm由多个节点组成，不管它是虚拟机还是物理机。</p><ul><li>基本概念很简单，运行<code>docker swarm init</code>来开启swarm模式并使得当前机器成为swarm manager</li><li>在其它机器上运行<code>docker swarm join</code>使他们作为worker加入swarm</li></ul><p><br></p><p><strong>栗子：</strong><br>使用VM快速创建两台机器的集群，并将其变为swarm。</p><p>使用<code>docker-machine</code>创建一对VM:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#CentOS7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装VirtualBox</span></span><br><span class="line">wget https://download.virtualbox.org/virtualbox/5.2.8/VirtualBox-5.2-5.2.8_121009_el7-1.x86_64.rpm &amp;&amp; yum install -y Virtual.xx.rpm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装docker-machine</span></span><br><span class="line"> curl -L https://github.com/docker/machine/releases/download/v0.14.0/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp; install /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在BIOS中开启虚拟化支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在VMware中开启虚拟化支持(如果是VM)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker-machine create --driver virtual myvm1</span><br><span class="line">docker-machine create --driver virtual myvm2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出虚拟机</span></span><br><span class="line">docker-machine ls</span><br></pre></td></tr></table></figure><p><br></p><p><strong>初始化swarm并添加node</strong></p><p>第一台机器作为swarm manager，执行命令和join认证，后面的机器作为worker。</p><p>你可以使用<code>docker-machine ssh</code>发送命令到VM。在<code>swarm mananger</code>上执行<code>docker swarm init</code>初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh &lt;swarm manager&gt; &quot;docker swarm init --advertise-assr &lt;mananger-IP&gt;&quot;</span><br><span class="line"></span><br><span class="line">#add worker</span><br><span class="line">docker swarm jion --toker &lt;token&gt; &lt;wroker-ip&gt;:&lt;port&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加manager</span><br><span class="line">docker swarm join-token manaer</span><br></pre></td></tr></table></figure><p><strong>由于我的虚拟的无法使用VT，因此我用的两台机器两个Docker来做swarm。</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化这台机器默认为manager</span></span><br><span class="line">docker swarm init</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#作为worker加入，ip是manager的</span></span><br><span class="line"><span class="comment">#以下信息会在manager初始化时生成</span></span><br><span class="line"><span class="comment">#注意防火墙，可能会阻碍加入</span></span><br><span class="line"></span><br><span class="line">docker swarm join --toker &lt;toker&gt; &lt;ip:port&gt;</span><br><span class="line">docker swarm join --token SWMTKN-1-3vrbnuneu0hyu41evxlhbn5fp04ad5jvg9v5rzvdaedg2bghkt-e24mjnni3hu7782t3gkz0ny39 172.16.129.150:2377</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看swarm</span></span><br><span class="line">docker node ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#离开swarm</span></span><br><span class="line">docker swarm leave</span><br></pre></td></tr></table></figure><p><br></p><h3 id="在swarm集群上部署APP"><a href="#在swarm集群上部署APP" class="headerlink" title="在swarm集群上部署APP"></a>在swarm集群上部署APP</h3><p>主需要记住，只有swarm manager才能执行docker命令，worker仅仅是容量(capacity)。</p><p>在swarm manager上使用<code>docker-composr.yml</code>和<code>docker stack deploy</code>命令来部署APP。使用<code>docker  service ps &lt;service name&gt;</code>来验证部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#在manager部署</span><br><span class="line">docker stack deploy -c ./docker-compose.yml LoadBalance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker service ls</span><br><span class="line"></span><br><span class="line">docker stack ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#注意node名</span><br><span class="line">docker stack ps LoadBalance</span><br><span class="line"></span><br><span class="line">ID                  NAME                IMAGE                   NODE                DESIRED STATE       CURRENT STATE             ERROR               PORTS</span><br><span class="line">6nrn4mwc6pvt        LoadBalance_web.1   zhang21/test:tag-test   zhang22             Running             Preparing 2 minutes ago</span><br><span class="line">bpssrnzesl7n        LoadBalance_web.2   zhang21/test:tag-test   zhang22             Running             Preparing 2 minutes ago</span><br><span class="line">kmhd8p5wkc12        LoadBalance_web.3   zhang21/test:tag-test   zhang21             Running             Running 2 minutes ago</span><br><span class="line">i0pkf4foms87        LoadBalance_web.4   zhang21/test:tag-test   zhang22             Running             Preparing 2 minutes ago</span><br><span class="line">rvtpjk781frn        LoadBalance_web.5   zhang21/test:tag-test   zhang21             Running             Running 2 minutes ago</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#分别访问个主机的IP</span><br><span class="line">#创建的网络在它们之间共享并负载均衡</span><br><span class="line">links ip1</span><br><span class="line">links ip2</span><br></pre></td></tr></table></figure><p>两个IP地址工作的原因是集群中的节点参与入口(ingress)路由网络(routing mesh)。这可以确保部署在swarm中某个端口的服务始终将该端口保留给自己，而不管实际运行容器的节点是什么。</p><p><img src="/images/Docker/ingress-routing-mesh.png" alt="入口路由"></p><p><br></p><h3 id="清理并重启"><a href="#清理并重启" class="headerlink" title="清理并重启"></a>清理并重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack rm LoadBalance</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>先决条件，已完成前面的步骤。</p><p><br></p><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>你已到达分布式应用程序层次结构的顶端——stack。堆栈是一组相互关联的服务，它们可以共享依赖关系，并可以进行协调和缩放。单个堆栈能够定义和协调整个应用程序的功能(尽管非常复杂的应用程序可能需要使用多个堆栈)。</p><p>在前面使用的<code>docker deploy</code>——是运行在单主机上的单个服务堆栈，这通常不会发生在生产环境中。在这里，你会使用学到的东西使多个服务相互关联，并在多台机器上运行它们。</p><p><br></p><h3 id="添加一个新服务并部署"><a href="#添加一个新服务并部署" class="headerlink" title="添加一个新服务并部署"></a>添加一个新服务并部署</h3><p>docker-compose2.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username/repo:tag with your name and image details</span><br><span class="line">    image: username/repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  #可视化</span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure><p>新增的东西使web对等服务，称为visualizer。注意两个事：</p><ul><li>volumes: 给予visualizer访问主机Docker的socket文件</li><li>placement： 确保服务运行在manager而不是worker上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c ./docker-compose2.yml stack-test</span><br><span class="line"></span><br><span class="line">Creating network stack-test_webnet</span><br><span class="line">Creating service stack-test_visualizer</span><br><span class="line">Creating service stack-test_web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看visualizer，要等一会才能正常访问，别着急</span><br><span class="line">访问 IP:8080</span><br></pre></td></tr></table></figure><p><img src="/images/Docker/visualizer.png" alt=""></p><p><br></p><h3 id="持久化数据"><a href="#持久化数据" class="headerlink" title="持久化数据"></a>持久化数据</h3><p>让我们再次通过相同的工作流程来添加用于存储应用程序数据的Redis数据库。</p><p>docker-compose3.yml，添加一个Redis服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username/repo:tag with your name and image details</span><br><span class="line">    image: username/repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/home/docker/data:/data&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    command: redis-server --appendonly yes</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#部署</span><br><span class="line">docker stack deploy -c docker-compose3.yml redis-test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#测试</span><br><span class="line">访问 IP:port</span><br></pre></td></tr></table></figure><p>Redis是一个Docker library中的官方image，并被授予redis镜像名称。</p><p>redis规范中有几件事使数据在这个堆栈的部署之间持续存在：</p><ul><li>redis运行在manager，所以它总是使用相同的文件系统</li><li>redis将数据存储在上面的目录</li><li>确保redis服务始终使用相同的主机</li><li>确保存储的数据的连续性</li></ul><p>如果没有创建，redis会将数据存储在容器文件系统的/data中，如果该容器被重新部署，则数据将被清除。</p><p><br><br><br></p><h2 id="部署APP"><a href="#部署APP" class="headerlink" title="部署APP"></a>部署APP</h2><p>先决条件为前面的操作步骤。</p><p><br></p><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>compose file在生产环境中的效果与在您的计算机上的效果相同。</p><p><br></p><h3 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a>选择版本</h3><p>我安装的是社区版(ce)。如果你在生产环境中使用docker-ce，则可以使用Docker Cloud帮助管理你的应用程序，如AWS、Aliyun、腾讯云。<br>docker cloud： <cloud.docker.com>, 可注册后建立、上传、管理自己的repo。</cloud.docker.com></p><p>设置和部署：</p><ul><li>连接Docker Cloud并授权它自动为你配置Dockerize VM</li><li>使用Docker Cloud创建你的计算资源和swarm</li><li>部署应用程序</li></ul><p><br></p><h3 id="连接DockerCloud"><a href="#连接DockerCloud" class="headerlink" title="连接DockerCloud"></a>连接DockerCloud</h3><p>你可以标准模式或swarm模式运行Docker Cloud。</p><ul><li>AWS配置指南</li><li>Aliyun配置指南</li><li>腾讯云配置指南</li></ul><p><br></p><h3 id="创建swarm"><a href="#创建swarm" class="headerlink" title="创建swarm"></a>创建swarm</h3><p>你可在Docker Cloud UI创建你的node，或<code>docker swarm init|join</code>命令。</p><p><br></p><h3 id="在云提供商上部署应用程序"><a href="#在云提供商上部署应用程序" class="headerlink" title="在云提供商上部署应用程序"></a>在云提供商上部署应用程序</h3><p><img src="/images/Docker/dockercloud.png" alt="栗子"></p><p>我觉得阿里云和腾讯云也有对应的平台。</p><p>运行部署命令: <code>docker stack deploy -c xxx.yml &lt;cus_appname&gt;</code>，现在你的APP就运行在云提供商上。</p><p><strong>运行swarm命令来验证部署</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br><span class="line"></span><br><span class="line">docker service ls</span><br><span class="line"></span><br><span class="line">docker service ps &lt;service&gt;</span><br></pre></td></tr></table></figure><p><strong>在云提供商开放端口</strong></p><table><thead><tr><th>service</th><th>type</th><th>protocol</th><th>port</th></tr></thead><tbody><tr><td>web</td><td>http</td><td>tcp</td><td>80</td></tr><tr><td>visualizer</td><td>http</td><td>tcp</td><td>8080</td></tr><tr><td>redis</td><td>tcp</td><td>tcp</td><td>6379</td></tr></tbody></table><p>具体操作参见各云提供商。</p><p><br></p><h3 id="迭代和清理"><a href="#迭代和清理" class="headerlink" title="迭代和清理"></a>迭代和清理</h3><ul><li>改变<code>*.yml</code>文件伸缩应用程序</li><li>使用<code>docker stack deploy</code>部署应用程序</li><li>push和pull image</li><li>使用<code>docker stack rm &lt;name&gt;</code>清除stack</li></ul><p><br><br><br></p><h2 id="修改Docker默认路径"><a href="#修改Docker默认路径" class="headerlink" title="修改Docker默认路径"></a>修改Docker默认路径</h2><p>docker默认的目录为<code>/var/lib/docker</code>，但很多时候<code>/var</code>目录并没有单独挂载，可能导致空间不够。<br>前提是你已经把源配置目录对应的文件拷贝到替换的目录。</p><ul><li>方法1：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">cd /etc/docker</span><br><span class="line"></span><br><span class="line">vim daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;graph&quot;: &quot;/opt/docker&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line">#systemctl reload docker</span><br><span class="line"></span><br><span class="line">#查看变更</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><p><br></p><ul><li>方法2:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">cd /etc/sysconfig/</span><br><span class="line"></span><br><span class="line">vim docker-storage</span><br><span class="line"></span><br><span class="line">DOCKER_STORAGE_OPTIONS=--graph=/opt/docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">#查看变更</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="容器服务自启动"><a href="#容器服务自启动" class="headerlink" title="容器服务自启动"></a>容器服务自启动</h2><p>在运行docker容器时可以加如下参数来保证每次docker服务重启后容器也自动重启:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart=always -d -p 80:80 &lt;container-id&gt;</span><br><span class="line"></span><br><span class="line">#对于已启动的容器服务，更新它</span><br><span class="line">docker update --restart=always &lt;container-id&gt;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="交互式容器"><a href="#交互式容器" class="headerlink" title="交互式容器"></a>交互式容器</h2><p>进入Docker容器以获得交互式体验。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;container-id&gt; /bin/bash</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Docker日志"><a href="#Docker日志" class="headerlink" title="Docker日志"></a>Docker日志</h2><ul><li>docker服务日志：<ul><li><code>journalctl -u docker.service</code></li></ul></li><li>docker容器日志：<ul><li><code>&lt;docker-graph&gt;/containers/&lt;container-id&gt;/&lt;container-id&gt;-json.log</code></li><li>由于容器ID会变化，请注意提取容器ID</li><li>可使用ELK在此收集容器日志</li></ul></li></ul><p><br><br><br></p><h2 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h2><p>使用<code>docker commit</code>从改变的容器中生成一个新镜像。</p><p>更新镜像步骤：</p><ol><li>备份镜像: <code>docker tag</code></li><li>运行镜像</li><li>修改容器</li><li>生成新镜像: <code>docker commit</code></li><li>推送镜像: <code>docker push</code></li></ol><p><br><br><br></p><h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><p><br></p><h3 id="备份容器"><a href="#备份容器" class="headerlink" title="备份容器"></a>备份容器</h3><ul><li><code>docker commit</code>: 生成新镜像</li><li><code>docker save</code>： 生成本地tar包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Usage:  docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">docker commit -m &quot;Just a test&quot; -p $&#123;container-id&#125; Zhang21/test:01</span><br><span class="line">docker image ls</span><br><span class="line">docker login</span><br><span class="line">docker push</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Usage:  docker save [OPTIONS] IMAGE [IMAGE...] [flags]</span><br><span class="line"></span><br><span class="line">docker save -o /path/$&#123;image&#125;.tar $&#123;image&#125;</span><br><span class="line">ls /path</span><br></pre></td></tr></table></figure><p><br></p><h3 id="恢复容器"><a href="#恢复容器" class="headerlink" title="恢复容器"></a>恢复容器</h3><ul><li><code>docker run ${image}</code></li><li><code>docker load</code>: 载入本地.tar镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage:  docker load [OPTIONS]</span><br><span class="line"></span><br><span class="line">docker load -i /path/$&#123;image&#125;.tar</span><br><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="应用场景与注意事项"><a href="#应用场景与注意事项" class="headerlink" title="应用场景与注意事项"></a>应用场景与注意事项</h2><p><br></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>本地依赖</li><li>搭建环境</li><li>微服务</li><li>自动测试</li><li>部署过程</li><li>CI/CD</li><li>多租户环境</li><li>一台机器的多个APP</li><li>弹性伸缩</li><li>资源隔离</li></ul><p><br></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>一个进程，一个容器<br>不推荐在Docker容器中运行多个进程！</p></li><li><p>不要将数据存放到容器内<br>所以请使用挂在卷的方式映射到本地磁盘目录</p></li></ul><ul><li><p>使用磁盘进行数据存储</p></li><li><p>容器通信<br>每当一个Docker容器需要与另一个容器通信时，传递信息最好使用名称或环境变量。</p></li><li><p>以non-root用户运行Docker<br>默认情况下，Docker容器以root用户身份运行，众所周知，以root用户运行的容器完全可以控制主机系统。</p></li><li><p>注意容器的体积<br>选择一个容器的主要原因之一是它的体积小。但是，如果你把它做得更大，它的主要优势就没了。</p></li><li><p>制定控策略<br>开发和部署Docker容器不是你的工作的结束。您需要持续监控已部署的容器以及整个系统的运行状况。选择合适的工具并制定一个策略来有效地监控您的Docker容器，以确保最短的停机时间，从而使客户满意。</p></li><li><p>安全问题<br>安全补丁、防火墙…</p></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>参考:</p><ul><li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a></li></ul><p><br></p><p>将镜像每一层的修改、安装、配置、操作的命令写入Dockerfile，并用它来构建、定制镜像，那么镜像构建透明性问题便会得到解决。</p><p>Dockerfile是一个文本文件，包含了一条条指令(instrction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p><br><br><br></p><h2 id="使用Dockerfile定制镜像"><a href="#使用Dockerfile定制镜像" class="headerlink" title="使用Dockerfile定制镜像"></a>使用Dockerfile定制镜像</h2><p><br></p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>所谓指定镜像，就是以一个镜像为基础，在其上进行定制。基础镜像必须指定，而<code>FROM</code>就是指定<strong>基础镜像</strong>，因此一个<code>Dockerfile</code>中<code>FROM</code>是必备的指令，并且必须是第一条指令。</p><p>只有有可能，请使用当前官方repo作为你的基础镜像。我们推荐使用<strong>Alpine</strong>镜像，因为它严格控制，体积小(只有5MB)，同时也是完整的Linux发行版。</p><p>Docker Hub中有很多常用的官方镜像——常用软件、常用语言和常用系统镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#特殊镜像，scratch，空白镜像</span><br><span class="line">FROM scratch</span><br></pre></td></tr></table></figure><p><br></p><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>在多行中使用反斜杠<code>\</code>或复杂的<code>RUN</code>语句，使Dockerfile更具可读性、易理解性和可维护性。</p><p><code>RUN</code>指令是用来执行命令行命令的。有两种格式：</p><ul><li><code>shell</code>格式<ul><li><code>RUN &lt;CMD&gt;</code>，就像直接在命令行中输入命令一样</li></ul></li><li><code>exec</code>格式<ul><li><code>RUN [&quot;可执行文件&quot;, &quot;参数&quot;]</code>，这更像函数调用中的格式</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure><p>Dockerfile中的每一个指令都会建立一层，<code>RUN</code>也不例外。每一个<code>RUN</code>的行为，就和手工建立镜像的过程一样 —— 新建立一层，在其上执行这些命令，执行结束后，<code>commit</code>这一层的修改，构成新的镜像。</p><p>上面这种写法，创建了7层镜像，这是完全没有意义的，而且很多运行时不需要的东西都被装进了镜像里，比如编译环境和更新的软件包等。结果就会产生非常臃肿、非常多层的镜像，不仅增加了构建部署的时间，也容易出错。这是很多初学Docker的人常犯的一个错误。</p><p>UnionFS是Linux、FreeBSD的文件系统服务，UnionFS是有最大层数限制的。</p><p>修改后的Dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line">RUN buildDeps=&apos;gcc libc6-dev make&apos; \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure><p>仅仅使用一个<code>RUN</code>指令，并使用<code>&amp;&amp;</code>将各指令串联起来。将之前的7层简化为1层。在编写<code>Dockerfile</code>时，要经常提醒自己，这并不是在写shell脚本，而是在定义每一层该如何构建。</p><p><code>Dockerfile</code>支持shell类的换行<code>\</code>、注释<code>#</code>等格式，良好的格式，如换行、缩进、注释等，会让维护、排障更为容易，这也是一个好习惯。</p><p>此外，还可看到命令最后添加了清理工作的命令，删除了为编译构建所需要的软件，清理了所有下载文件。这很重要，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随镜像。<br>因此，构建镜像时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。<br>很多人初学docker制作出了很臃肿的镜像，原因之一就是顽疾了每一层构建的最后一定要清理无关文件。</p><p><br></p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在<code>Dockerfile</code>目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#docker build [OPTIONS] PATH | URL | - [flags]</span><br><span class="line">#Build an image from a Dockerfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#-t指定镜像名称</span><br><span class="line">#.指的是上下文目录</span><br><span class="line">docker build -t nginx:test .</span><br></pre></td></tr></table></figure><p><br></p><p><strong>构建上下文(content)</strong></p><p>上面的<code>.</code>是在指定<strong>上下文路径</strong>。</p><p>当我们在进行镜像构建的时候，并非所有的定制都会通过<code>RUN</code>指令完成，经常会需要一些本地文件复制进镜像，比如通过<code>COPY</code>, <code>ADD</code>指令。而<code>docker build</code>命令并非是在本地构建镜像，而是在服务端，也就是Docker引擎<code>dockerd</code>中构建的。那么在这种C/S架构中，如何才能让服务端获得本地文件呢？</p><p>这就引进了上下文的概念。当构建的时候，用户会指定构建镜像的上下文的路径，<code>docker build</code>命令得知这个路径后，会将路径下的所有内容打包，然后上传给Docker引擎。这样Docker引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#复制上下文目录下的package.json</span><br><span class="line">COPY ./package.json /app/</span><br></pre></td></tr></table></figure><p>因此<code>COPY</code>这类指令中的源文件的路径都是相对路径，因为绝对路径已经超出了上下文的范围，Docker引擎无法获取这些位置的文件。如果真需要这些文件，请将它们复制到上下文目录中去。</p><p>理解构建上下文对于镜像构建很重要，避免犯一些不应该的错误。</p><p>一般来说，应将<code>Dockerfile</code>置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，则应该把所需文件复制一份过来。如果目录下有些东西不希望构建时传给Docker引擎，可以写一个<code>.dockerignore</code>文件，用于剔除不需要作为上下文传递给Docker引擎的。</p><p>实际上，<code>Dockerfile</code>的文件名并不要求必须为<code>Dockerfile</code>，也并不要求必须位于上下文目录中。可使用<code>-f</code>指定某个文件为<code>Dockerfile</code>。</p><p><br></p><p><strong>其它<code>docker build</code>的用法</strong></p><ol><li>直接使用Git repo进行构建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#docker build URL</span><br><span class="line"></span><br><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14</span><br><span class="line">#docker会自己去clone、切换分支、并进入指定目录开始构建</span><br></pre></td></tr></table></figure><p><br></p><ol><li>使用给定tar压缩包构建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build http://server/context.tar.gz</span><br><span class="line"></span><br><span class="line">#自动下载/解压缩 压缩包，以其作为上下文，开始构建</span><br></pre></td></tr></table></figure><p><br></p><ol><li>从标准输入中读取Dockerfile进行构建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat Dockerfile | docker build -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><p><code>Dockerfile</code>提供了十多个指令供我们操作。</p><p><br></p><h3 id="LABLE"><a href="#LABLE" class="headerlink" title="LABLE"></a>LABLE</h3><p>你可以为你的镜像添加标签，以助于通过项目来组织镜像，记录相关信息。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set multiple labels at once, using line-continuation characters to break long lines</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> vendor=ACME\ Incorporated \</span></span><br><span class="line"><span class="bash">      com.example.is-beta= \</span></span><br><span class="line"><span class="bash">      com.example.is-production=<span class="string">""</span> \</span></span><br><span class="line"><span class="bash">      com.example.version=<span class="string">"0.0.1-beta"</span> \</span></span><br><span class="line"><span class="bash">      com.example.release-date=<span class="string">"2015-02-12"</span></span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>尽管<code>ADD</code>和<code>COPY</code>在功能上相似，但一般来说，<code>COPY</code>是首选，因为它比<code>COPY</code>更透明。<br><code>COPY</code>只支持将本地文件复制到容器中，而<code>ADD</code>具有一些功能(如提取tar文件和远程URL支持)</p><p><br></p><p><code>COPY</code>,复制文件。<br>从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置。</p><blockquote><p>源路径可以是多个，或通配符(需满足Go的规则)<br>目标路径可是容器内的绝对路径，也可是相对于工作目录(<code>WORKDIR</code>)的相对路径。目标路径不需要事先创建。<br>使用COPY指令，源文件的各种元数据都会保留 —— 如读、写、执行权限、文件变更时间…</p></blockquote><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">COPY  &lt;sourch&gt;  &lt;destination&gt;</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">COPY  [&quot;&lt;source1&gt;&quot;, ... &quot;&lt;destination&gt;&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子</span><br><span class="line">COPY package.json /usr/src/app/</span><br><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure><p><br></p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p><code>ADD</code>,更高级的复制文件。<br><code>ADD</code>和<code>COPY</code>的格式和性质基本一致，但增加了一些功能。<br>尽可能的使用<code>COPY</code>，因为<code>COPY</code>的语义很明确，就是复制文件而已，而<code>ADD</code>则包含了更复杂的功能，其行为也不一定很清晰。<br>最适合<code>ADD</code>的场合，就是所提及的需要自动解压缩的场合。</p><p>因此在<code>COPY</code>和<code>ADD</code>指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用<code>COPY</code>指令，仅在需要自动解压缩的场合使用<code>ADD</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line"></span><br><span class="line">ADD abc.tar.gz / &amp;&amp; \</span><br><span class="line">    http://example.com/big.tar.xz /usr/src/things/ &amp;&amp; \</span><br><span class="line">RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span><br><span class="line">RUN make -C /usr/src/things all</span><br></pre></td></tr></table></figure><p><br></p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>CMD</code>，容器启动命令。用于运行镜像中包含的软件以及任何参数。</p><p>也有两个格式：</p><ul><li><code>shell</code>格式： <code>CMD &lt;command&gt;</code></li></ul><p><code>shell</code>格式，在实际中会被包装成<code>sh -c</code>的参数形式进行执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CMD echo $HOME</span><br><span class="line"></span><br><span class="line">#转变为</span><br><span class="line">CMD[&quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot;]</span><br><span class="line"></span><br><span class="line">#-c string If  the  -c option is present, then commands are read from string.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理</span><br></pre></td></tr></table></figure><p><br></p><ul><li><code>exec</code>格式： <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot; ...]</code><br>CMD几乎总是以此格式使用。</li></ul><p>Docker不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code>指令就是用于指定默认的容器主进程的启动命令的。<br>``</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p><p><br></p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p><code>ENTRYPOINT</code>，入口点。指令格式同样分为<code>shell</code>格式和<code>exec</code>两种。</p><p><code>ENTRYPOINT</code>和<code>CMD</code>一样，都是在指定容器启动程序及参数。<br>当指定了<code>ENTRYPOINT</code>后，<code>CMD</code>的含义就发生了改变，不再是直接的运行其命令，而是将<code>CMD</code>的内容作为参数传给<code>ENTRYPOINT</code>指令。即变为如下模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure><p><br></p><p>有几大好处：</p><ul><li><strong>让镜像变成像命令一样使用</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#可以从腾讯上拉取，快一些</span><br><span class="line">#ccr.ccs.tencentyun.com/qcloud/ubuntu</span><br><span class="line"></span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker build -t myip</span><br><span class="line">docker run myip</span><br><span class="line">#当前 IP：182.150.x.xx 来自：四川省成都市 电信</span><br></pre></td></tr></table></figure><p>不过命令总有参数，例如我想查看HTTP header，使用<code>-i</code>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run myip -i</span><br><span class="line">#这样会报错，-i替换了CMD命令，而不是-s参数，然而-i并不是命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#重新完整输入命令</span><br><span class="line">docker run myip curl -s http://ip.cn -i</span><br><span class="line">#这样又太麻烦</span><br></pre></td></tr></table></figure><p>这时便可以使用<code>ENTRYPOINT</code>解决这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker build it myip</span><br><span class="line">docker run myip</span><br><span class="line">#当前 IP：182.150.x.xx 来自：四川省成都市 电信</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run myip -i</span><br><span class="line">#成功</span><br></pre></td></tr></table></figure><p>当存在<code>ENTRYPOINT</code>后，<code>CMD</code>的内容将作为参数传递给<code>ENTRYPOINT</code>，而<code>-i</code>就是新的<code>CMD</code>，因此会作为参数传递给<code>curl</code>，从而达到预期效果。</p><p><br></p><ul><li><strong>应用运行前的准备工作</strong></li></ul><p>有时，在启动前需要做一些准备工作。</p><ul><li>如MySQL，需要一些配置文件、初始化工作，这些工作需要在MySQL server运行前解决</li><li>避免使用root用户去启动服务，从而提高安全性</li><li>这些准备工作和<code>CMD</code>无关</li></ul><p><br></p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p><code>ENV</code>，设置环境变量。<br>为了使新软件更容易运行，使用此命令为你的容器内安装的软件更新环境变量。</p><p>两种格式：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV PATH $PATH:/root/bin \</span><br><span class="line">EMAIL abc@zhang21.cn \</span><br><span class="line">NAME=&quot;Zhang21&quot;</span><br></pre></td></tr></table></figure><p>下列指令可以支持环境变量展开： <code>ADD</code>, <code>COPY</code>, <code>ENV</code>, <code>EXPOSE</code>, <code>LABEL</code>, <code>USER</code>, <code>WORKDIR</code>, <code>VOLUME</code>, <code>STOPGIGNAL</code>, <code>ONBUILD</code>。</p><p>通过环境变量，我们可以让一份<code>Dockerfile</code>制作更多的镜像，只需使用不同的环境变量即可。</p><p><br></p><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p><code>ARG</code>，构建参数</p><p>格式：</p><ul><li><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></li></ul><p><br></p><p>构建参数和<code>ENV</code>的效果一样，都是设置环境变量。所不同的是，<code>ARG</code>所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。</p><p><br></p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><code>VOLUME</code>，定义匿名卷。用于显示有docker容器创建的任何数据库存储区域，配置存储或文件/文件夹。<br>强烈建议将VOLUME用于镜像的任何可变部分和用户可用部分。</p><p>格式：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p><br></p><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。<br>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在<code>Dockerfile</code>中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会像容器存储层写入大量数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#在运行时自动挂载为匿名卷</span><br><span class="line">VOLUME /data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#覆盖挂载</span><br><span class="line">docker run -d -v mydata:/data xxx</span><br></pre></td></tr></table></figure><p><br></p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><code>EXPOSE</code>，声明容器监听连接的端口。</p><p>格式：</p><ul><li><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></li></ul><p><code>EXPOSE</code>指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。<br>在<code>Dockerfile</code>中写入这个声明有两个好处：</p><ul><li>一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便映射</li><li>另一个用处则是在运行时使用随机端口映射(未定义时)</li></ul><p>要将<code>EXPOSE</code>和在运行时使用<code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code>区分开。<code>EXPOSE</code>仅仅声明容器打算使用哪些端口，并未包含端口映射。</p><p><br></p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p><code>WORKDIR</code>，指定工作目录。为了清晰可靠，请使用绝对路径。</p><p>使用<code>WORKDIR</code>指令可以来指定工作目录，以后各层的当前目录就被改为指定的目录，如目录不存在，<code>WORKDIR</code>会帮你建立目录。<br>如果需要改变<code>Dockerfile</code>各层的工作目录的位置，那么应该使用<code>WORKDIR</code>指令。</p><p>格式：</p><ul><li><code>WORKDIR &lt;工作目录&gt;</code></li></ul><p><br></p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p><code>USER</code>，指定当前用户。<br>如果服务可以在非特权模式下运行，请使用USER将其改为non-root用户。首先在Dockerfile中创建相应的用户和组:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r group &amp;&amp; \</span><br><span class="line">useradd -r -g group group</span><br></pre></td></tr></table></figure><p><code>USER</code>和<code>WORKDIR</code>相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code>是改变工作目录，<code>USER</code>则是改变之后的层执行<code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>这类命令的身份。这个用户必须存在。</p><p>格式：</p><ul><li><code>USER &lt;用户名&gt;</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USER redis</span><br><span class="line">RUN [&quot;redis-server&quot;]</span><br></pre></td></tr></table></figure><p><br></p><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p><code>HEALTHCHECK</code>，健康检查<br><code>HEALTHCHECK</code>指令告诉docker应该如何进行判断容器的状态是否正常。</p><p>格式：</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>， 设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>， 如果基础镜像有健康检查，使用这行可以屏蔽其健康检查指令</li></ul><p>当在一个镜像指定了<code>HEALTHCHECK</code>指令后，用其启动容器，初始状态会为<code>starting</code>，在<code>HEALTHCHECK</code>指令检查成功后变为<code>healthy</code>，如果连续一定次数失败，则会变为<code>unhealthy</code>。<br>和<code>CMD</code>, <code>ENTRYPOINT</code>一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p><p><br></p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p><code>ONBUILD</code>，为他人做嫁衣。</p><p><code>ONBUILD</code>是一个特殊的指令，它后面跟的是其它指令。而这些指令，在当前镜像构建时不会被执行。只有当以当前镜像为基础镜像(父镜像)，去构建下一级镜像(子镜像)的时候才会被执行。<code>ONBUILD</code>命令在子镜像的Dockerfile中任何命令之前执行。<br><code>Dockerfile</code>中的其它指令都是为了定制当前镜像而准备的，唯有<code>ONBUILD</code>是为了帮助别人定制自己而准备的。</p><p>格式：</p><ul><li><code>ONBUILD &lt;其它指令&gt;</code></li></ul><p><br><br><br></p><h2 id="Dockerfile多阶段构建"><a href="#Dockerfile多阶段构建" class="headerlink" title="Dockerfile多阶段构建"></a>Dockerfile多阶段构建</h2><p><strong>全部放入一个Dockerfile</strong></p><p>将所有的构建过程包含在一个<code>Dockerfile</code>中，包括项目及其依赖库的编译、测试、打包等流程。<br>这可能会带来一些问题：</p><ul><li><code>Dockerfile</code>特别长，可维护性降低</li><li>镜像层次多，镜像体积较大，部署时间变长</li><li>源代码存在泄漏的风险</li></ul><p><br></p><p><strong>分散到多个Dockerfile</strong></p><p>事先在一个<code>Dockerfile</code>将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中。这种方式需要编写两个<code>Dockerfile</code>和一些编译脚本才能将两个阶段自动整合起来。这种方式虽然可以很好避免全部写入一个Dockerfile的风险，但明显部署过程较复杂。</p><p><br></p><p><strong>多阶段构建</strong></p><p>使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个<code>Dockerfile</code>。</p><p><br><br><br></p><h2 id="Dockerfile最佳实践"><a href="#Dockerfile最佳实践" class="headerlink" title="Dockerfile最佳实践"></a>Dockerfile最佳实践</h2><ul><li>一般性建议<ul><li>容器应该是短暂的</li><li>使用<code>.dockerignore</code>文件</li><li>使用多阶段构建减少镜像大小</li><li>避免安装不必要的包</li><li>一个镜像只运行一个进程</li><li>镜像层数尽可能少</li><li>将多行参数排序</li><li>构建缓存</li></ul></li><li>Dockerfile指令<ul><li><code>FROM</code></li><li><code>LABEL</code></li><li><code>RUN</code></li><li><code>CMD</code></li><li><code>EXPOSE</code></li><li><code>ENV</code></li><li><code>ADD</code></li><li><code>COPY</code></li><li><code>ENTRYPOINT</code></li><li><code>VOLUME</code></li><li><code>USER</code></li><li><code>WORKDIR</code></li></ul></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="Compose-file"><a href="#Compose-file" class="headerlink" title="Compose file"></a>Compose file</h1><p>参考:</p><ul><li><a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="使用Docker进行开发"><a href="#使用Docker进行开发" class="headerlink" title="使用Docker进行开发"></a>使用Docker进行开发</h1><p>Develop with Docker</p><p><br><br><br></p><h2 id="在Docker上开发应用程序"><a href="#在Docker上开发应用程序" class="headerlink" title="在Docker上开发应用程序"></a>在Docker上开发应用程序</h2><p>Develop new apps on Docker</p><ul><li>Learn to build an image from a Dockerfile</li><li>Use multistage builds to keep your images lean</li><li>Manage application data using volumes and bind mounts</li><li>Scale your app as a swarm service</li><li>Define your app stack using a compose file</li><li>General application development best practices</li></ul><p><br></p><p>了解有关Docker上特定语言的开发：</p><ul><li>Java</li><li>node.js</li><li>Ruby on Rails</li><li>.Net</li><li>ASP.Net</li></ul><p><br><br><br></p><h3 id="Docker开发最佳实践"><a href="#Docker开发最佳实践" class="headerlink" title="Docker开发最佳实践"></a>Docker开发最佳实践</h3><p>Docker development best practices</p><p>如下开发模式已被证明有助于人么使用Docker构建应用程序。</p><p><br></p><h4 id="如何保持较小的镜像"><a href="#如何保持较小的镜像" class="headerlink" title="如何保持较小的镜像"></a>如何保持较小的镜像</h4><p>How to keep your images small</p><p>在启动容器或服务时，小图像可以更快速通过网络pull镜像并加载到内存中。有几条经验法则可保持较小的镜像：</p><ul><li><p>从适当的基础镜像开始<br>例如，如果需要JDK，请考虑官方镜像，而不是从一个通用的Ubuntu/Centos镜像并将Openjdk作为Dockerfile的一部分安装开始。</p></li><li><p>使用多阶段构建<br>例如，你可以使用maven镜像构建java程序，然后重置到tomcat镜像，并将java构件复制到正确位置以部署应用程序，所有这些都位于相同的Dockerfile。这意味着你的最终镜像不包含构建时所引入的所有库和依赖项，仅包含运行它们所需的构件和环境。</p></li><li><p>如果你有多个共同的镜像，请考虑使用共享组件创建你的基本镜像，并在其上创建独特的镜像<br>Docker只要家在一次通用层，然后便会缓存。</p></li><li><p>保持生产环境镜像精简但允许调试(degub)，请考虑使用生产环境镜像作为调试镜像的基本镜像</p></li><li><p>在构建镜像时，应该始终使用有用的标签对其进行标记，如(test, prod)。不要依赖自动创建的<code>latest</code>标签</p></li></ul><p><br></p><h4 id="何处以及如何持久化应用程序数据"><a href="#何处以及如何持久化应用程序数据" class="headerlink" title="何处以及如何持久化应用程序数据"></a>何处以及如何持久化应用程序数据</h4><p>Where and how to persist application data</p><ul><li><p>避免使用存储驱动(storge drivers)将应用程序的数据存储在容器的可写层(writeable layer)中<br>与使用卷(volume)或绑定挂载(bound mounts)相比，这增加了容器的大小，并且从I/O角度来看效率较低</p></li><li><p>使用卷存储数据</p></li><li>适合使用绑定挂载的一种情况是在开发过程中，对于生产环境，请改用卷</li><li>对于生产环境，使用secerts来存储服务使用的敏感的应用程序数据，使用config来存储不敏感的数据(如配置文件)</li></ul><p><br></p><h4 id="尽可能使用swarm服务"><a href="#尽可能使用swarm服务" class="headerlink" title="尽可能使用swarm服务"></a>尽可能使用swarm服务</h4><p>Use swarm services when possible</p><ul><li>在可能的情况下，使用swarm服务进行伸缩的能力来设计你的应用程序</li><li>即使你只需运行单个实例，swarm服务也比standalone容器提供更多的优势</li><li>网络和卷可使用swarm服务连接和断开，并且docker可以以不中断的方式重新部署各个服务容器。standalone容器需要手动停止/移除/重新创建</li><li>一些功能仅适用于服务而不适用于standalone容器</li><li>让<code>docker stack deploy</code>处理任意镜像，而不是使用<code>docker pull</code>。通过这种方式，你的部署不会尝试从down的节点进行pull。此外，当新节点添加到集群时，镜像会自动pull</li></ul><p><br></p><h4 id="使用CI-CD进行测试和部署"><a href="#使用CI-CD进行测试和部署" class="headerlink" title="使用CI/CD进行测试和部署"></a>使用CI/CD进行测试和部署</h4><p>Use CI/CD for testing and deployment</p><ul><li>CI(Continuous integration)</li><li>CD(continuous deployment)</li><li>当更新源码库或创建拉取请求时，请使用CI/CD pipeline 自动构建并标记Docker镜像，并对其进行测试。也可将测试过的应用程序直接部署到生产环境中</li></ul><p><br><br><br></p><h3 id="Develop-images"><a href="#Develop-images" class="headerlink" title="Develop images"></a>Develop images</h3><h4 id="编写Dockerfile的最佳实践"><a href="#编写Dockerfile的最佳实践" class="headerlink" title="编写Dockerfile的最佳实践"></a>编写Dockerfile的最佳实践</h4><p>Best practices for writing Dockerfiles</p><p>Docker通过读取Dockerfile(一个包含命令的文本文件)中的命令来自动构建镜像。<br>Dockerfile reference: <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p><p><br></p><p>Dockerfile由read-only layer组成，每层代表一个Dockerfile指令。如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:15.04</span><br><span class="line">COPY . /app</span><br><span class="line">RUN make /app</span><br><span class="line">CMD python /app/app.py</span><br></pre></td></tr></table></figure><p>每个命令创建一个层:</p><ul><li><p><code>FROM</code><br>从<code>ubuntu:15.04</code> Docker image创建一个层</p></li><li><p><code>COPY</code><br>从Docker client的当前目录添加文件</p></li><li><p><code>RUN</code><br>使用<code>make</code>构建你的应用程序</p></li><li><p><code>CMD</code><br>指定在容器内运行的命令</p></li></ul><p>当你运行镜像并生成容器时，会在基础层的顶部添加一个可写层(writable layer)，也称容器层(container layer)。对正在运行的容器所做的所有更改(增删改文件)都会写入此可写容器层。</p><p><br></p><h4 id="一般准则和建议"><a href="#一般准则和建议" class="headerlink" title="一般准则和建议"></a>一般准则和建议</h4><p>General guidelines and recommendations</p><p><strong>创建临时(ephemeral)容器</strong></p><p>Create ephemeral containers<br>由Dockerfile定义的镜像应该生成尽可能临时的容器。临时的意思为容器可以被停止(stop)和销毁(destroy)，然后重建(rebuild)并使用绝对最小化的设置和配置来替代。</p><p><br></p><p><strong>理解构建上下文</strong></p><p>Understand build context<br>当你发出<code>docker build</code>命令时，当前的工作目录被称为构建上下文(build context)。默认情况下，假设Dockerfile位于此，但你也可以使用文件标志(-f)指定位置。无论Dockerfile位于何处，当前目录内的所有内容(除了.dockerignore中忽略的内容)都将作为构建上下文发送给Docker守护进程。</p><p><br></p><p><strong>从stdin读取Dockerfile</strong></p><p>Pipe Dockerfile through stdin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#local build-context</span><br><span class="line">docker build -t . -f-&lt;&lt;EOF</span><br><span class="line">FROM busybox</span><br><span class="line">RUN echo &quot;hello world&quot;</span><br><span class="line">COPY . /my-copied-files</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#remote</span><br><span class="line">docker build -t foo https://github.com/thajeztah/pgadmin4-docker.git -f-&lt;&lt;EOF</span><br><span class="line">FROM busybox</span><br><span class="line">COPY LICENSE config_local.py /usr/local/lib/python2.7/site-packages/pgadmin4/</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用<code>.dockerignore</code>排除文件</strong></p><p>Exclude with .dockerignore<br>要排除与构建无关的文件，请使用<code>.dockerignore</code>文件，这与<code>.gitignore类似</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ./dockerignore</span><br><span class="line"></span><br><span class="line">file1</span><br><span class="line">dir2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用多阶段构建</strong></p><p>Use multi-stage builds<br>多阶段构建允许你大幅缩减镜像大小，而不需要减少中间层和文件数。<br>由于镜像是在构建过程的最后阶段构建的，因此可以通过利用构建缓存(build cache)来最小化镜像层</p><p>例如，如果你的版本博涵包含多个层，你可以从 不经常改动的版本到频繁改动的版本进行排序:</p><ul><li>安装构建应用程序需要的工具</li><li>安装或更新依赖库</li><li>生成应用程序</li></ul><p>A Dockerfile for Go application:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.9.2-alpine3.6 AS build</span><br><span class="line"></span><br><span class="line"># Install tools required for project</span><br><span class="line"># Run `docker build --no-cache .` to update dependencies</span><br><span class="line">RUN apk add --no-cache git</span><br><span class="line">RUN go get github.com/golang/dep/cmd/dep</span><br><span class="line"></span><br><span class="line"># List project dependencies with Gopkg.toml and Gopkg.lock</span><br><span class="line"># These layers are only re-built when Gopkg files are updated</span><br><span class="line">COPY Gopkg.lock Gopkg.toml /go/src/project/</span><br><span class="line">WORKDIR /go/src/project/</span><br><span class="line"># Install library dependencies</span><br><span class="line">RUN dep ensure -vendor-only</span><br><span class="line"></span><br><span class="line"># Copy the entire project and build it</span><br><span class="line"># This layer is rebuilt when a file changes in the project directory</span><br><span class="line">COPY . /go/src/project/</span><br><span class="line">RUN go build -o /bin/project</span><br><span class="line"></span><br><span class="line"># This results in a single layer image</span><br><span class="line">FROM scratch</span><br><span class="line">COPY --from=build /bin/project /bin/project</span><br><span class="line">ENTRYPOINT [&quot;/bin/project&quot;]</span><br><span class="line">CMD [&quot;--help&quot;]</span><br></pre></td></tr></table></figure><p><br></p><p><strong>不要安装不必要的包</strong></p><p>Don’t install unnecessary packages<br>为了减少复杂性、依赖性，文件大小和构建时间，避免安装额外的或不不必要的软件包。</p><p><br></p><p><strong>分离应用程序</strong></p><p>Decouple applications<br>每个容器应该只有一个问题。将应用程序分离到多个容器中可以更轻松地水平伸缩和重新使用容器。<br>例如，Web应用程序堆栈可能有三个独立的容器组成，每个容器都有其独特的镜像，以分离的方式管理Web应用程序、数据库和内存缓存。</p><p>将每个容器限制为一个进程是一个很好的经验法则，但不是硬性规定。(想想高可用和负载均衡)。</p><p>尽你最大的努力使容器干净和模块化。如果容器相互依赖，则可以使用Docker container network来确保容器间可进行通信。</p><p><br></p><p><strong>最小化层数</strong></p><p>Minimize the number of layers<br>在老版本的docker中，重要的是减少镜像的层数，以确保它们的性能。</p><p><br></p><p><strong>对多行参数排序</strong></p><p>Sort multi-line arguments<br>只要有可能，通过按字母数字排序多行参数来简化修改。这有助于避免软件包重复，并使列表更容易更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">  bzr \</span><br><span class="line">  cvs \</span><br><span class="line">  git \</span><br><span class="line">  mercurial \</span><br><span class="line">  subversion</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Leverage build cache</strong></p><p>在构建镜像时，Docker安装Dockerfile中的指令逐步执行，并按指定的顺序执行每个镜像。在检查每条指令时，docker会在其缓存中查找可重用的现有镜像，而不是创建新的(重复)镜像。</p><p>如果你不想使用缓存，可在<code>docker build</code>命令中使用<code>--no-cache=true</code>选项。如果让Docker使用了缓存，那么了解何时可以 找到/找不到 匹配的图像就很重要了。</p><p>Docker遵循的基本规则如下:</p><ul><li>从已经在缓存中的父镜像开始，将下一条指令与该基本镜像派生的所有子镜像进行比较，以查看是否使用完全相同的指令构建了其中的一条。否则，缓存失效。</li><li>大多数情况下，只需将Dockerfile中的指令与其中一个子镜像进行比较久够了。但是，某些说明需要更多的检查和解释。</li><li>对于<code>ADD</code>和<code>COPY</code>指令，将检查镜像文件中的内容，并为每个文件计算校验和。在缓存查找过程中，将检验和与现有镜像中的校验和进行比较，如果文件中由任何内容已更改，如内容和元数据，则缓存将失效。</li><li>除了<code>ADD</code>和<code>COPY</code>指令，缓存检查将不会查看容器中的文件已确定缓存。</li></ul><p>一旦缓存失效，所有后续的Dockerfile命令将生产新的镜像，并且不会使用缓存。</p><p><br></p><p><strong>Dockerfile instruction</strong></p><p>请参考: <a href="# Dockerfile">Dockerfile</a></p><p><br></p><h4 id="创建一个基镜像"><a href="#创建一个基镜像" class="headerlink" title="创建一个基镜像"></a>创建一个基镜像</h4><p>Create a base image</p><p>大多数Dockerfile从父镜像开始，如果需要完全控制镜像的内容，则可能需要创建基镜像(base image)。区别:</p><ul><li>父镜像是镜像的所基于的镜像</li><li>基镜像的Dockerfile中没有<code>FROM</code>行</li></ul><p><br></p><h4 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h4><p>Use multi-stage builds</p><p>多阶段构建需要Docker v17.05及以上版本。多阶段构建对于优化Dockerfile来说非常有用，同时让它易读和维护。</p><p><br></p><p><strong>构建之前</strong><br>构建镜像最具挑战的事情是保持镜像的大小。Dockerfile中的每条指令都会为镜像添加一层，在移动到下一层前清理不需要的任何构件。为了编写一个高效的Dockerfile，需要尽可能减小图层，并确保每个层都具有上一层需要的构件，而不是其它东西。</p><p><strong>使用多阶段构建</strong><br>使用多阶段构建，你可以在Dockerfile中使用多个<code>FROM</code>语句。每条<code>FROM</code>命令可以使用不同的基镜像，并且每个指令都可是构建的新阶段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go .</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=0 /go/src/github.com/alexellis/href-counter/app .</span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure><p><code>COPY --from=0</code>将前面构建的工作复制到这个新阶段。Go SDK和任何中间工作件都被留下，并未保存在最终镜像中</p><p><br></p><p><strong>命名你的构建阶段</strong><br>默认情况下，构建阶段没有命名。你可以通过它们的整数来引用它们，第一个指令<code>FROM</code>从0开始。但你可以命名它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3 as builder</span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go    .</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=builder /go/src/github.com/alexellis/href-counter/app .</span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure><p><br></p><p><strong>停止一个特定的构建阶段</strong><br>构建镜像时，不一定需要构建包含每个阶段的整个Dockerfile。<br>如下的栗子停在名为<code>builder</code>的阶段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --target builder -t alexellis2/href-counter:latest .</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用外部镜像用作一个阶段</strong><br>多阶段构架可使用<code>COPY --from</code>指令从单独的镜像中进行复制，可以使用本机镜像、远程Registry的镜像和标记的ID。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="使用Docker-Engine-SDKs和API进行开发"><a href="#使用Docker-Engine-SDKs和API进行开发" class="headerlink" title="使用Docker Engine SDKs和API进行开发"></a>使用Docker Engine SDKs和API进行开发</h2><p>Develop with Docker Engine SDKs and API</p><p><br></p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Docker提供了一个用于与Docker daemon(称为Docker Engine API)交互的API，以及用于Go和Python的SDK。</p><p>SDK允许你款速轻松地构建和扩展Docker APP。<br>如果Go或Python不适合你，你可以直接使用Docker Engine API——它是由HTTP客户端(curl, wget)访问的RESTful API，或者是大多数现代编程语言的一部分HTTP库。</p><p><br></p><h3 id="安装SDKs"><a href="#安装SDKs" class="headerlink" title="安装SDKs"></a>安装SDKs</h3><h4 id="Go-SDK"><a href="#Go-SDK" class="headerlink" title="Go SDK"></a>Go SDK</h4><ul><li>Go SDK参考：<a href="https://godoc.org/github.com/docker/docker/client" target="_blank" rel="noopener">https://godoc.org/github.com/docker/docker/client</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/docker/docker/client</span><br></pre></td></tr></table></figure><p><br></p><h4 id="Python-SDK"><a href="#Python-SDK" class="headerlink" title="Python SDK"></a>Python SDK</h4><ul><li>Python SDK参考: <a href="https://docker-py.readthedocs.io/en/stable/" target="_blank" rel="noopener">https://docker-py.readthedocs.io/en/stable/</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install docker</span><br></pre></td></tr></table></figure><p><br></p><h3 id="快速开始SDK和API"><a href="#快速开始SDK和API" class="headerlink" title="快速开始SDK和API"></a>快速开始SDK和API</h3><p>Python: 运行一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import docker</span><br><span class="line">client = docker.from_env()</span><br><span class="line">print (client.containers.run(&quot;alpine&quot;, [&quot;echo&quot;, &quot;hello&quot;, &quot;world&quot;]))</span><br></pre></td></tr></table></figure><p>HTTP:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ curl --unix-socket /var/run/docker.sock -H &quot;Content-Type: application/json&quot; \</span><br><span class="line">  -d &apos;&#123;&quot;Image&quot;: &quot;alpine&quot;, &quot;Cmd&quot;: [&quot;echo&quot;, &quot;hello world&quot;]&#125;&apos; \</span><br><span class="line">  -X POST http:/v1.24/containers/create</span><br><span class="line">&#123;&quot;Id&quot;:&quot;1c6594faf5&quot;,&quot;Warnings&quot;:null&#125;</span><br><span class="line"></span><br><span class="line">$ curl --unix-socket /var/run/docker.sock -X POST http:/v1.24/containers/1c6594faf5/start</span><br><span class="line"></span><br><span class="line">$ curl --unix-socket /var/run/docker.sock -X POST http:/v1.24/containers/1c6594faf5/wait</span><br><span class="line">&#123;&quot;StatusCode&quot;:0&#125;</span><br><span class="line"></span><br><span class="line">$ curl --unix-socket /var/run/docker.sock &quot;http:/v1.24/containers/1c6594faf5/logs?stdout=1&quot;</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="SDK和API栗子"><a href="#SDK和API栗子" class="headerlink" title="SDK和API栗子"></a>SDK和API栗子</h3><p>链接: <a href="https://docs.docker.com/develop/sdk/examples/" target="_blank" rel="noopener">https://docs.docker.com/develop/sdk/examples/</a></p><p><br></p><hr><p><br></p><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><p>Configure networking</p><h2 id="综述-1"><a href="#综述-1" class="headerlink" title="综述"></a>综述</h2><p>Docker容器和服务如此强大的原因之一是——你可以将它们连接在一起，或将它们连接到non-docker工作负载。Docker容器和服务甚至不需要知道它们是否部署在Docker上，或它们的对等端是否也是Docker工作负载。都可以使用Docker方式管理它们。</p><p><br></p><h3 id="网络驱动"><a href="#网络驱动" class="headerlink" title="网络驱动"></a>网络驱动</h3><p>Network drivers</p><p>使用驱动程序，Docker的网络子系统是可插拔的(pluggable)。</p><p>集中驱动程序:</p><ul><li><p>brige<br>默认网络驱动。桥接网络通常用于你的应用程序运行在需要通信的独立容器中。</p></li><li><p>host<br>对于独立容器，删除容器和Docker主机之间的网络隔离，并直接使用主机的网络。</p></li><li><p>overlay<br>overlay网络将多个docker daemon连接在一起，并使集群服务能够无相互通信。</p></li><li><p>macvlan<br>macvlan网络允许你为容器分配MAC地址，使其成为你网络上的物理设备。docker daemon通过其MAC地址将流量路由到容器。</p></li><li><p>none<br>对于此容器，禁用所有网络。</p></li><li><p>network plugins<br>你可在Docker上安装和使用第三方网络插件，从Docker Store获取: <a href="https://store.docker.com" target="_blank" rel="noopener">https://store.docker.com</a></p></li></ul><p><br></p><p><strong>网络驱动总结</strong></p><ul><li><p><strong>User-defined bridge networks</strong><br>当你需要多个容器在同一个Docker主机上进行通信时</p></li><li><p><strong>Host networks</strong><br>当网络堆栈不应与Docker主机隔离时，但希望容器的其它方面被隔离</p></li><li><p><strong>Overlay networks</strong><br>当你需要运行在不同Docker主机上的容器进行通信时，或多个应用程序使用集群服务进行工作时</p></li><li><p><strong>Macvlan networks</strong><br>当你从虚拟机迁移或需要你的容器看起来像物理主机时，每个都具有唯一的MAC地址</p></li><li><p><strong>Third-party network plugins</strong><br>允许你将Docker与专用网络堆栈集成</p></li></ul><p><br><br><br></p><h2 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h2><p>就网络而言，桥接网络是一种链路层设备，用于转发网段之间的流量。桥接可以是硬件设备，或在主机内核中运行的软件设备。<br>就Docker而言，桥接网络允许连接到统一桥接网络的容器进行通信，同时提供与未连接到桥接网络的容器的隔离。Docker桥接驱动程序自动在主机上安装桥接规则，以便于不同桥接网络上的容器不能直接相互通信。</p><p>桥接网络适用于在同一个Docker daemon上运行的容器之间的通信。</p><p>当你启动Docker时，除非另有定义，否则将自动创建默认桥接网络，并且新启动的容器将连接到它。<br>你也可以创建用户自定义的桥接网络。</p><p><br><br><br></p><h3 id="bridge与user-defined-bridges"><a href="#bridge与user-defined-bridges" class="headerlink" title="bridge与user-defined bridges"></a>bridge与user-defined bridges</h3><p>Differences between user-defined bridges and the default bridge</p><p>两者的差别：</p><ul><li><p>用户自定义的桥接在集装箱化的应用程序之间提供了更好的隔离和互操作性</p></li><li><p>用户自定义的桥接提供了容器之间的自动DNS解析</p></li><li><p>容器可以在运行中与用户定义的网络进行连接(attach)和分离(detach)</p></li><li><p>每个用户定义的网络会创建一个可配置的桥接网络</p></li><li><p>在默认桥接网络上链接的容器共享环境变量</p></li></ul><p><br><br><br></p><h3 id="管理user-defined-bridge"><a href="#管理user-defined-bridge" class="headerlink" title="管理user-defined bridge"></a>管理user-defined bridge</h3><p>Manage a user-defined bridge</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker network create --help</span><br><span class="line"></span><br><span class="line">#创建一个用户自定义桥接网络</span><br><span class="line">#你还可以指定子网，范围，网关...</span><br><span class="line">docker network creat $&#123;name&#125;</span><br><span class="line"></span><br><span class="line">docker network creat my-net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">docker network rm $&#123;name&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="连接到自定义桥接网络"><a href="#连接到自定义桥接网络" class="headerlink" title="连接到自定义桥接网络"></a>连接到自定义桥接网络</h3><p>Connect a container to a user-defined bridge</p><p>当你创建一个新的容器时，你可以指定一个或多个<code>--network</code>标志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#创建时</span><br><span class="line">docker create --name my-nginx \</span><br><span class="line">  --network my-net \</span><br><span class="line">  --publish 8080:80 \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#运行中的容器</span><br><span class="line">docker network connect my-net my-nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#断开连接</span><br><span class="line">docker network disconnect my-net my-nginx</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用IPv6"><a href="#使用IPv6" class="headerlink" title="使用IPv6"></a>使用IPv6</h3><p>需要修改docker daemon的配置项以支持使用IPv6，在创建自定义网络是指定<code>--ipv6</code>标志。<br>你不能有选择地禁用默认桥接网络上的IPv6支持。</p><p><br><br><br></p><h3 id="启用容器转发"><a href="#启用容器转发" class="headerlink" title="启用容器转发"></a>启用容器转发</h3><p>Enable forwarding from Docker containers to the outside world</p><p>默认情况下，使用默认桥接网络的连接的容器的流量不会转发到外部世界。启用操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#配置Linux内核</span><br><span class="line">sysctl net.ipv4.conf.all.forwarding=1</span><br><span class="line"></span><br><span class="line">#修改iptables FORWARD默认策略</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line"></span><br><span class="line">#重启后无效，请写入配置文件</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="默认桥接网络"><a href="#默认桥接网络" class="headerlink" title="默认桥接网络"></a>默认桥接网络</h3><p>Use the default bridge network</p><p>默认桥接网络被视为Docker的遗留细节，不建议用于生产环境。</p><p><br></p><p><strong>连接容器到默认桥接网络</strong><br>如果未指定网络，则默认使用默认桥接网络。</p><p><strong>配置默认桥接网络</strong><br>指定并配置<code>daemon.json</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bip&quot;: &quot;192.168.1.5/24&quot;,</span><br><span class="line">  &quot;fixed-cidr&quot;: &quot;192.168.1.5/25&quot;,</span><br><span class="line">  &quot;fixed-cidr-v6&quot;: &quot;2001:db8::/64&quot;,</span><br><span class="line">  &quot;mtu&quot;: 1500,</span><br><span class="line">  &quot;default-gateway&quot;: &quot;10.20.1.1&quot;,</span><br><span class="line">  &quot;default-gateway-v6&quot;: &quot;2001:db8:abcd::89&quot;,</span><br><span class="line">  &quot;dns&quot;: [&quot;10.20.1.2&quot;,&quot;10.20.1.3&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用IPv6</strong><br>修改配置文件以支持IPv6，则默认桥接网络自动支持IPv6。</p><p><br><br><br></p><h2 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h2><p>overlay网络驱动在多个docker daemon主机之间创建分布式网络。该网络位于特定主机网络之上，允许容器连接到此并安全地进行通信。</p><p>当初始化集群或将docker主机加入现有集群时，将在docker主机上创建两个新网络：</p><ul><li><p>称为<code>ingress</code>的overlay网络<br>处理与集群服务相关的控制和数据流量。<br>当你创建集群服务并且不将其连接到用户自定义的网络时，它默认连接到<code>ingress</code>网络。</p></li><li><p>称为<code>docker_gwbridge</code>的桥接网络<br>将单独的docker daemon连接到集群的其它docker daemon。</p></li></ul><p>与创建自定义桥接网络类似，你也可以使用<code>docker network create</code>来创建自动以的overlay网络。服务或容器一次可连接到多个网络，但只能通过连接的网络进行通信。</p><p>尽管可以将集群服务和独立容器连接到overlay网络，但默认行为和配置是不同的。</p><p><br><br><br></p><h3 id="所有overlay网络的操作"><a href="#所有overlay网络的操作" class="headerlink" title="所有overlay网络的操作"></a>所有overlay网络的操作</h3><p>Operations for all overlay networks</p><p><br></p><h4 id="创建overlay网络"><a href="#创建overlay网络" class="headerlink" title="创建overlay网络"></a>创建overlay网络</h4><p>Create an overlay network</p><p><strong>先决条件</strong></p><ul><li><p>使用overlay网络的docker daemon的防火墙规则</p><ul><li>2377(tcp): 集群通信管理</li><li>7946(tcp/udp)： 节点通信</li><li>4789(udp)： overlay网络流量</li></ul></li><li><p>创建overlay网络前，需要初始化docker daemon集群</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d overlay my-overlay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建可供集群服务或独立容器与其它docker daemon上的独立容器进行通信</span><br><span class="line">docker network create -d overlay --attachable my-attachable-overlay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#你可以指定IP地址范围，子网，网关...</span><br></pre></td></tr></table></figure><p><br></p><h4 id="加密overlay网络上的流量"><a href="#加密overlay网络上的流量" class="headerlink" title="加密overlay网络上的流量"></a>加密overlay网络上的流量</h4><p>Encrypt traffic on an overlay network</p><p><strong>Overlay network encryption is not supported on Windows！</strong></p><p>所有集群服务管理流量默认都是加密的，在GCM模式下使用AES算法。<br>要加密应用程序数据，在创建overlay网络时添加<code>--opt encrypted</code>。这种加密带来了不可忽视的性能问题，所以应该在生产环境使用前对其进行测试。<br>当启用overlay加密时，docker会在节点间创建IPsec tunnel，在这些节点上调度连接到overlay网络的服务的任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#SWARM MODE OVERLAY NETWORKS AND STANDALONE CONTAINERS</span><br><span class="line"> docker network create --opt encrypted --driver overlay --attachable my-attachable-multi-host-network</span><br></pre></td></tr></table></figure><p><br></p><h4 id="自定义默认ingress网络"><a href="#自定义默认ingress网络" class="headerlink" title="自定义默认ingress网络"></a>自定义默认ingress网络</h4><p>如果自动选择的子网与已存在的网络冲突，或需要自定义其它低级网络设置(如MTU)，这次功能非常有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#显示详细信息</span><br><span class="line">docker network inspect ingress</span><br><span class="line"></span><br><span class="line">#移除现有网络</span><br><span class="line">docker network rm ingress</span><br><span class="line"></span><br><span class="line">#创建新网络 --ingress</span><br><span class="line">docker network create \</span><br><span class="line">  --driver overlay \</span><br><span class="line">  --ingress \</span><br><span class="line">  --subnet=10.11.0.0/16 \</span><br><span class="line">  --gateway=10.11.0.2 \</span><br><span class="line">  --opt com.docker.network.driver.mtu=1200 \</span><br><span class="line">  my-ingress</span><br></pre></td></tr></table></figure><p><br></p><h4 id="自定义docker-gwbridge"><a href="#自定义docker-gwbridge" class="headerlink" title="自定义docker_gwbridge"></a>自定义docker_gwbridge</h4><p><code>docker_gwbridge</code>是一个虚拟桥接网络，它将overlay网路连接到单独的docker daemon的物理网络。当初始化集群或将主机加入集群时，docker会自动创建它，但它不是docker设备。啊存在于docker主机的内核之中。如果你需要自定义其设置，则必须在主机加入集群之前或将主机临时从集群中删除之后才执行此操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 停止docker</span><br><span class="line"></span><br><span class="line">2. 删除已存在的docker_gwbridge</span><br><span class="line">ip link set docker_gwbridge doen</span><br><span class="line">ip link del dev docker_gwbridge</span><br><span class="line"></span><br><span class="line">3. 启动docker，但不加入或初始化集群</span><br><span class="line"></span><br><span class="line">4. 创建docker_gwbridge</span><br><span class="line">docker network create \</span><br><span class="line">--subnet 10.11.0.0/16 \</span><br><span class="line">--opt com.docker.network.bridge.name=docker_gwbridge \</span><br><span class="line">--opt com.docker.network.bridge.enable_icc=false \</span><br><span class="line">--opt com.docker.network.bridge.enable_ip_masquerade=true \</span><br><span class="line">docker_gwbridge</span><br><span class="line"></span><br><span class="line">5. 集群初始化或加入集群</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="swarm服务的操作"><a href="#swarm服务的操作" class="headerlink" title="swarm服务的操作"></a>swarm服务的操作</h3><p>Operations for swarm services</p><h4 id="在overlay网络上发布端口"><a href="#在overlay网络上发布端口" class="headerlink" title="在overlay网络上发布端口"></a>在overlay网络上发布端口</h4><p>Publish ports on an overlay network</p><p>连接到同一overlay网络的集群服务可有效地将所有端口暴露给对方。要是端口可在服务外可访问，必须使用<code>-p</code>或<code>--publish</code>标志暴露此端口。</p><p>两种方法：</p><ul><li>传统的冒号<code>:</code>分隔语法</li><li>较新的逗号<code>,</code>分隔语法</li></ul><table><thead><tr><th>Flag value</th><th>Description</th></tr></thead><tbody><tr><td>-p 8080:80 or <br> -p published=8080,target=80</td><td>Map TCP port 80 on the service to port 8080 on the routing mesh</td></tr><tr><td>-p 8080:80/udp or <br> -p published=8080,target=80,protocol=udp</td><td>Map UDP port 80 on the service to port 8080 on the routing mesh</td></tr><tr><td>-p 8080:80/tcp -p 8080:80/udp or <br> -p published=8080,target=80,protocol=tcp -p published=8080,target=80,protocol=udp</td><td>Map TCP port 80 on the service to TCP port 8080 on the routing mesh, and map UDP port 80 on the service to UDP port 8080 on the routine mesh</td></tr></tbody></table><p><br></p><h4 id="绕过swarm的路由网格"><a href="#绕过swarm的路由网格" class="headerlink" title="绕过swarm的路由网格"></a>绕过swarm的路由网格</h4><p>Bypass the routing mesh for a swarm service</p><p>默认情况下，发布端口的集群服务使用路由网格来发布。当你连接到任何swarm节点上已发布的端口时，都会透明地将你重定向到正在运行服务的工作。实际上，docker充当集群服务的负载均衡器(Load-Balancer)。使用路由网格的服务以虚拟IP(vip)模式运行。即使在每个节点上运行服务也使用路由网格。使用路由网格时，不能保证那个docker node处理客户端请求。</p><p>要绕过路由网格，可使用DNS Round Robin(DNSRR)模式启动——<code>--endpoint-mode dnsrr</code>。你必须在服务前运行负载均衡器。docker主机上DNS查询服务名称会返回运行该服务的节点的IP地址列表。配置你的负载均衡器使用此列表并平衡各节点间的流量。</p><p><br></p><h4 id="分离控制流量和数据流量"><a href="#分离控制流量和数据流量" class="headerlink" title="分离控制流量和数据流量"></a>分离控制流量和数据流量</h4><p>默认情况下，尽管集群控制流量是加密的，但集群管理和应用程序之间的控制流量运行在同一个网络上。你可以配置docker来使用单独的网络接口来处理来种不同类型的流量。</p><p><br><br><br></p><h3 id="overlay网络上独立容器的操作"><a href="#overlay网络上独立容器的操作" class="headerlink" title="overlay网络上独立容器的操作"></a>overlay网络上独立容器的操作</h3><p>Operations for standalone containers on overlay networks</p><h4 id="将独立容器连接到overlay网络"><a href="#将独立容器连接到overlay网络" class="headerlink" title="将独立容器连接到overlay网络"></a>将独立容器连接到overlay网络</h4><p>Attach a standalone container to an overlay network</p><p>独立容器连接到<code>ingress</code>网络需添加<code>--attachable</code>标志。这使得运行在不同docker daemon上的独立容器能够进行通信，而无需在各个docker daemon主机上设置路由。</p><p><br></p><h4 id="发布端口"><a href="#发布端口" class="headerlink" title="发布端口"></a>发布端口</h4><p>Publish ports</p><table><thead><tr><th>Flag value</th><th>Desciption</th></tr></thead><tbody><tr><td>-p 8080:80</td><td>Map TCP port 80 in the container to port 8080 on the overlay network</td></tr><tr><td>-p 8080:80/udp</td><td>Map UDP port 80 in the container to port 8080 on the overlay network</td></tr><tr><td>-p 8080:80/sctp</td><td>Map SCTP port 80 in the container to port 8080 on the overlay network</td></tr><tr><td>-p 8080:80/tcp -p 8080:80/udp</td><td>Map TCP port 80 in the container to TCP port 8080 on the overlay network, and map UDP port 80 in the container to UDP port 8080 on the overlay network</td></tr></tbody></table><p><br></p><h4 id="容器发现"><a href="#容器发现" class="headerlink" title="容器发现"></a>容器发现</h4><p>Container discovery</p><p>对于大多数情况，应该连接到服务名称——它是负载均衡的，并支持服务的所有容器处理。要获取支持该服务的所有任务的列表，请执行DNS查找服务——<code>tasks.&lt;service-name&gt;</code>。</p><p><br><br><br></p><h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><p>如果你对容器使用host网络驱动，则该容器的网络堆栈将不与docker主机隔离。例如，如果运行一个绑定在80端口并使用host网络的容器，则该容器的应用程序将在主机IP地址的80端口上可用。</p><p>host网络驱动只能运行在Linux主机上。</p><p><br><br><br></p><h2 id="Macvlan"><a href="#Macvlan" class="headerlink" title="Macvlan"></a>Macvlan</h2><p>一些应用程序，尤其是需要监视网络流量的应用程序，希望连接到物理网络上。在这种情况下，你可以使用<code>macvlan</code>驱动为容器的虚拟网络接口分配MAC地址，使其看起来像是直接连接到物理网络的物理网络接口。在这种情况下，你需要指定Docker主机上的物理接口用于macvlan，以及macvlan的子网和网关。</p><p><br></p><h3 id="创建一个macvaln网络"><a href="#创建一个macvaln网络" class="headerlink" title="创建一个macvaln网络"></a>创建一个macvaln网络</h3><p>macvlan网络可处于 <strong>bridge mode</strong> 或 <strong>802.1q trunk mode</strong>:</p><ul><li><p>在桥接模式下，macvlan流量通过主机上的物理设备</p></li><li><p>在802.1q主干桥接模式下，流量通过Docker在运行中创建的802.1q子接口。<br>这使你可以更细粒度地控制路由和过滤。</p></li></ul><p><br></p><p><strong>bridge mode</strong></p><p>创建bridge macvlan:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker networkcreate --driver macvlan \</span><br><span class="line">  --subnet=172.16.86.0/24 \</span><br><span class="line">  --gateway=172.16.86.1  \</span><br><span class="line">  -o parent=eth0 pub_net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--aux-addresses排除IP地址</span><br><span class="line">docker networkcreate --driver macvlan \</span><br><span class="line">  --subnet=172.16.86.0/24 \</span><br><span class="line">  --gateway=172.16.86.1  \</span><br><span class="line">  --aux-address=&quot;my-router=192.168.32.129&quot; \</span><br><span class="line">  -o parent=eth0 pub_net</span><br></pre></td></tr></table></figure><p><br></p><p><strong>802.1q truk bridge mode</strong></p><p>如果你指定了包含点<code>.</code>的接口名——如<strong>eth0.50</strong>，则Docker将其解释为eth0的子接口，并自动创建子接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker network  create  --driver macvlan \</span><br><span class="line">  --subnet=192.168.50.0/24 \</span><br><span class="line">  --gateway=192.168.50.1 \</span><br><span class="line">  -o parent=eth0.50 macvlan50</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用ipvlan替换macvlan</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d ipvlan \</span><br><span class="line">  --subnet=192.168.210.0/24 \</span><br><span class="line">  --subnet=192.168.212.0/24 \</span><br><span class="line">  --gateway=192.168.210.254  \</span><br><span class="line">  --gateway=192.168.212.254  \</span><br><span class="line">  -o ipvlan_mode=l2 ipvlan210</span><br></pre></td></tr></table></figure><p><br></p><p><strong>IPv6</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker network  create  -d macvlan \</span><br><span class="line">  --subnet=192.168.216.0/24 --subnet=192.168.218.0/24 \</span><br><span class="line">  --gateway=192.168.216.1  --gateway=192.168.218.1 \</span><br><span class="line">  --subnet=2001:db8:abc8::/64 --gateway=2001:db8:abc8::10 \</span><br><span class="line">  -o parent=eth0.218 \</span><br><span class="line">  -o macvlan_mode=bridge macvlan216</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="禁用容器网络"><a href="#禁用容器网络" class="headerlink" title="禁用容器网络"></a>禁用容器网络</h2><p>在启动容器时加上`–network none来禁用容器的网络堆栈，这样在容器内便仅仅创建loopback设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -dit \</span><br><span class="line">  --network none \</span><br><span class="line">  --name no-net-alpine \</span><br><span class="line">  alpine:latest \</span><br><span class="line">  ash</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="网络教程"><a href="#网络教程" class="headerlink" title="网络教程"></a>网络教程</h2><p>Networking tutorials</p><p><br></p><h3 id="bridge-network"><a href="#bridge-network" class="headerlink" title="bridge network"></a>bridge network</h3><ul><li>default bridge network</li><li>user-defined bridge network</li></ul><p><br></p><h4 id="default-bridge-network"><a href="#default-bridge-network" class="headerlink" title="default bridge network"></a>default bridge network</h4><ol><li>基本docker网络</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">8d3b84bfe5a0        bridge              bridge              local</span><br><span class="line">3579d63da633        host                host                local</span><br><span class="line">f766b990db47        none                null                local</span><br></pre></td></tr></table></figure><p>以上列出了默认的桥接网络，主机网络(启动直接连接到docker daemon的主机的网络堆栈的容器)，none(启动一个没有网络设备的容器)。</p><p><br></p><ol><li>启动一个容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name alpine1 alpine ash</span><br></pre></td></tr></table></figure><p>由于启动时没有指定网络，所以默认为桥接网络。</p><p><br></p><ol><li>Inspect the bridge network，以查看哪个容器连接到它</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;8d3b84bfe5a034c65d043af80976a1e6127011fc1ab312446252f562e221d351&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-05-24T18:38:35.538308064+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;893903129d869f384bd78d63a382f1c9527d6979be0a6cf3c13ea4f45a1554d6&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;hardcore_rosalind&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;515d1435470c9f72d3b07680515d9c503457b8eb5bcaaaa915bb53901eac9424&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><ol><li>连接到容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker attach alpine1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ # ip addr show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">506: eth0@if507: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP </span><br><span class="line">    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ # ping -c 2 www.baidu.com</span><br><span class="line">PING www.baidu.com (119.75.216.20): 56 data bytes</span><br><span class="line">64 bytes from 119.75.216.20: seq=0 ttl=55 time=46.521 ms</span><br><span class="line">64 bytes from 119.75.216.20: seq=1 ttl=55 time=45.189 ms</span><br></pre></td></tr></table></figure><p><br></p><ol><li>ping其它容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ # ping -c 2 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.125 ms</span><br><span class="line">64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.075 ms</span><br></pre></td></tr></table></figure><p><br></p><h4 id="user-defined-bridge-networks"><a href="#user-defined-bridge-networks" class="headerlink" title="user-defined bridge networks"></a>user-defined bridge networks</h4><ol><li>创建名为<code>apline-net</code>用户自定义网络<br>当然，你可以手动指定子网，网关这些。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge alpine-net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docket network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">810fb1e02000        alpine-net          bridge              local</span><br><span class="line">8d3b84bfe5a0        bridge              bridge              local</span><br><span class="line">3579d63da633        host                host                local</span><br><span class="line">f766b990db47        none                null                local</span><br></pre></td></tr></table></figure><p><br></p><ol><li>查看alpine-net网络详情<br>注意网关和子网发生了变化。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect alpine-net</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;alpine-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;810fb1e020008c7c6598f3b830ca25896dde638b1190d383ee6a5214d284e77d&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-06-14T15:45:19.43941906+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><ol><li>创建两种网络的容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#alpine-net</span><br><span class="line">docker run -dit --name alpine1 --network alpine-net alpine ash</span><br><span class="line"></span><br><span class="line">#default bridge</span><br><span class="line">docker run -dit --name alpine2 alpine ash</span><br></pre></td></tr></table></figure><p><br></p><ol><li>显示两种网络情况</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;8d3b84bfe5a034c65d043af80976a1e6127011fc1ab312446252f562e221d351&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-05-24T18:38:35.538308064+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;893903129d869f384bd78d63a382f1c9527d6979be0a6cf3c13ea4f45a1554d6&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;hardcore_rosalind&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;515d1435470c9f72d3b07680515d9c503457b8eb5bcaaaa915bb53901eac9424&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;e7472c3ddda5043bc03868f4bf7ed59562220f05772f02f57ff589d086630562&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;alpine2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;ba565a247e347feb59713c188eb38e184d781da0489ae80e26ecad6d24e165c2&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker network inspect alpine-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;alpine-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;810fb1e020008c7c6598f3b830ca25896dde638b1190d383ee6a5214d284e77d&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-06-14T15:45:19.43941906+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;264ccde8b1d5198551d689f0dd49ffbfb612255e0bf76c9543325d7c2e588acb&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;alpine1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;563c48cc6b936bcd9d3f57e9bb5e162a8cb52a23c8980346f288d42cc9b0a8fc&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><ol><li>连接到容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker container attach alpine1</span><br><span class="line"></span><br><span class="line">#网段内通</span><br><span class="line">/ # ping -c 2 172.18.0.3</span><br><span class="line">PING 172.18.0.1 (172.18.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.097 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.070 ms</span><br><span class="line"></span><br><span class="line">--- 172.18.0.1 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 0.070/0.083/0.097 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#网段外不通</span><br><span class="line">/ # ping -c 2 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.16.0.1): 56 data bytes</span><br><span class="line"></span><br><span class="line">--- 172.17.0.2 ping statistics ---</span><br><span class="line">2 packets transmitted, 0 packets received, 100% packet loss</span><br></pre></td></tr></table></figure><p><br></p><ol><li>使容器连接到default bridge<br>这样，此容器便连接到了两个网络中。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network connect bridge apline1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ # ping -c 2 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.102 ms</span><br><span class="line">64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.071 ms</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="host-network"><a href="#host-network" class="headerlink" title="host network"></a>host network</h3><p>host网络不存在隔离问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#默认主机上的80端口</span><br><span class="line">docker run -rm -dit --network host --name my_nginx nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#访问</span><br><span class="line">http://localhost:80</span><br><span class="line">Welcome to nginx!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker network inspect host</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;host&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;3579d63da633adcc497417d39b8b1d270cf329a68b9222f6a75fae72086509d6&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-04-27T11:31:17.900886126+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;host&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;f02a3b11fce7228ad6ee196771bd9cf0b64966bfc2aa7c27719bc120dbdc7189&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;my_nginx&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;4ee67fb4d0a0c1a357b5fdd141f856a70c205fad5c49b1cb6a4f5245df0318a8&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="overlay-network"><a href="#overlay-network" class="headerlink" title="overlay network"></a>overlay network</h3><ul><li>default overlay network</li><li>user-defined overlay network</li><li>overlay network for standalone containers</li><li>Communicate between a container and a swarm service</li></ul><p><br></p><h4 id="default-overlay"><a href="#default-overlay" class="headerlink" title="default overlay"></a>default overlay</h4><p><strong>依赖：</strong></p><ul><li>swarm集群</li><li>集群节点<ul><li>worker-1</li><li>worker-2</li><li>mananger</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">495c570066be        bridge              bridge              local</span><br><span class="line">961c6cae9945        docker_gwbridge     bridge              local</span><br><span class="line">ff35ceda3643        host                host                local</span><br><span class="line">trtnl4tqnc3n        ingress             overlay             swarm</span><br><span class="line">c8357deec9cb        none                null                local</span><br></pre></td></tr></table></figure><p><br></p><p>创建nginx-net的overlay的网络:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d overlay nginx-net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ docker service create \</span><br><span class="line">  --name my-nginx \</span><br><span class="line">  --publish target=80,published=80 \</span><br><span class="line">  --replicas=5 \</span><br><span class="line">  --network nginx-net \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><p><br></p><h4 id="user-defined-overlay"><a href="#user-defined-overlay" class="headerlink" title="user-defined overlay"></a>user-defined overlay</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d overlay my-overlay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ docker service create \</span><br><span class="line">  --name my-nginx \</span><br><span class="line">  --network my-overlay \</span><br><span class="line">  --replicas 1 \</span><br><span class="line">  --publish published=8080,target=80 \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p><br></p><h4 id="overlay-network-for-standalone-containers"><a href="#overlay-network-for-standalone-containers" class="headerlink" title="overlay network for standalone containers"></a>overlay network for standalone containers</h4><p><br></p><h4 id="Communicate-between-a-container-and-a-swarm-service"><a href="#Communicate-between-a-container-and-a-swarm-service" class="headerlink" title="Communicate between a container and a swarm service"></a>Communicate between a container and a swarm service</h4><p><br><br><br></p><h3 id="macvalan-network"><a href="#macvalan-network" class="headerlink" title="macvalan network"></a>macvalan network</h3><p>假设主机网络接口为<code>eth0</code>。</p><p><br></p><h4 id="bridge-1"><a href="#bridge-1" class="headerlink" title="bridge"></a>bridge</h4><p>此模式下，流量通过eth0流动，docker使用其MAC地址就流量路由到容器。</p><ol><li>创建名为<code>my-macvlan-net</code>的macvlan网络</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d macvlan \</span><br><span class="line">  --subnet=172.16.86.0/24 \</span><br><span class="line">  --gateway=172.16.86.1 \</span><br><span class="line">  -o parent=eth0 \</span><br><span class="line">  my-macvlan-net</span><br></pre></td></tr></table></figure><p><br></p><ol><li>查看网络</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">810fb1e02000        alpine-net          bridge              local</span><br><span class="line">8d3b84bfe5a0        bridge              bridge              local</span><br><span class="line">3579d63da633        host                host                local</span><br><span class="line">6be80655739d        my-macvlan-net      macvlan             local</span><br><span class="line">f766b990db47        none                null                local</span><br></pre></td></tr></table></figure><p><br></p><ol><li>以此网络运行容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -itd \</span><br><span class="line">  --network my-macvlan-net \</span><br><span class="line">  --name my-macvlan-alpine \</span><br><span class="line">  alpine:latest \</span><br><span class="line">  ash</span><br></pre></td></tr></table></figure><p><br></p><ol><li>查看my-macvlan-net</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect my-macvlan-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;my-macvlan-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;6be80655739deffe204e087d098f97fc75072d95f9818e129cfd7d5667ed01f3&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-06-14T16:52:30.507647877+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;macvlan&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.16.86.0/24&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.16.86.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;8301b669b4b63afb20911b46243f11b70e5a9d0880beaafa922b52bcb8ab0477&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;my-macvlan-alpine&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;4f2971ba4bd92c34e2a299d301f739867d2b1b65d35566aef07d7a26b079662c&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:10:56:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.16.86.2/24&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;parent&quot;: &quot;ens160&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><ol><li>查看容器网卡和路由</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker exec my-macvlan-alpine ip addr show eth0</span><br><span class="line">517: eth0@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UNKNOWN</span><br><span class="line">    link/ether 02:42:ac:10:56:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.16.86.2/24 brd 172.16.86.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">docker exec my-macvlan-alpine ip route</span><br><span class="line">default via 172.16.86.1 dev eth0</span><br><span class="line">172.16.86.0/24 dev eth0 scope link  src 172.16.86.2</span><br></pre></td></tr></table></figure><p><br></p><h4 id="802-1q-trunked-bridge-network"><a href="#802-1q-trunked-bridge-network" class="headerlink" title="802.1q trunked bridge network"></a>802.1q trunked bridge network</h4><p>此模式下，流量流经eth0的子接口(eth0.10)，docker使用其MAC地址将流量路由到容器。</p><ol><li>创建名为<code>my-8021q-macvlan-net</code>的macvlan网络</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d macvlan \</span><br><span class="line">  --subnet=172.16.87.0/24 \</span><br><span class="line">  --gateway=172.16.87.1 \</span><br><span class="line">  -o parent=eth0.10 \</span><br><span class="line">  my-8021q-macvlan-net</span><br></pre></td></tr></table></figure><p><br></p><ol><li>查看此网络</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line">NETWORK ID          NAME                   DRIVER              SCOPE</span><br><span class="line">2aeafd44fd67        my-8021q-macvlan-net   macvlan             local</span><br><span class="line">6be80655739d        my-macvlan-net         macvlan             local</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ifconfig</span><br><span class="line">eth0.10: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::20c:29ff:feaa:7e75  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:aa:7e:75  txqueuelen 0  (Ethernet)</span><br></pre></td></tr></table></figure><p><br></p><ol><li>用此网络启动一个容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -itd \</span><br><span class="line">  --network my-8021q-macvlan-net \</span><br><span class="line">  --name my-second-macvlan-alpine \</span><br><span class="line">  alpine:latest \</span><br><span class="line">  ash</span><br></pre></td></tr></table></figure><p><br></p><ol><li>查看my-8021q-macvlan-net</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect my-8021q-macvlan-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;my-8021q-macvlan-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;2aeafd44fd67e6ee937c82788745b1d45fb291efd61f545537528eafdff94e3d&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-06-14T17:06:33.426800076+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;macvlan&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.16.87.0/24&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.16.87.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;90103673d94915c3c7fb572eec8bd97b2aee1c3dab877c598d0a62e6d797b06d&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;my-second-macvlan-alpine&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;5c93f2ea1d29150ee57f099d42fc8e04a571efd0d1273a4f6bed755dc34f2e54&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:10:57:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.16.87.2/24&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;parent&quot;: &quot;ens160.10&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><ol><li>查看容器网络接口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker exec my-second-macvlan-alpine ip addr show eth0</span><br><span class="line">519: eth0@if518: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UNKNOWN </span><br><span class="line">    link/ether 02:42:ac:10:57:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.16.87.2/24 brd 172.16.87.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker exec my-second-macvlan-alpine ip route</span><br><span class="line">default via 172.16.87.1 dev eth0</span><br><span class="line">172.16.87.0/24 dev eth0 scope link  src 172.16.87.2</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="配置守护进程和容器"><a href="#配置守护进程和容器" class="headerlink" title="配置守护进程和容器"></a>配置守护进程和容器</h2><h3 id="启用IPv6"><a href="#启用IPv6" class="headerlink" title="启用IPv6"></a>启用IPv6</h3><p>启用IPv6前，请确保支持IPv6.</p><p>给docker daemon启用IPv6:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;ipv6&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>所有Docker的<code>iptables</code>规则都被添加到<code>DOKCER chain</code>。不要手动操作此表。<br>如果你需要添加Docker规则，请将其添加到<code>DOCKER-USER chain</code></p><p>栗子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I DOCKER-USER -m iprange -i ext_if ! --src-range 192.168.1.1-192.168.1.3 -j DROP</span><br></pre></td></tr></table></figure><p><br></p><h3 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h3><p>容器使用的网络类型(无论是bridge，overlay，macvlan还是自定义网络)，在容器内都是透明的。从容器的角度来看，它有一个带有IP地址，网关，路由表，DNS服务和其它网络细节的网络接口。</p><p><strong>publish port</strong><br>默认情况下，创建容器时，它不会将任何端口发布的外部世界。要是端口可用于docker之外的服务，请使用<code>--publish</code>或<code>-p</code>标志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-p 8080:80</span><br><span class="line">-p 192.168.1.100:8080:80</span><br><span class="line">-p 8080:80/udp</span><br><span class="line">-p 8080:80/tcp -p 8080:80/udp</span><br></pre></td></tr></table></figure><p><br></p><p><strong>ip add and hostname</strong><br>默认情况下，容器会为其连接的每个docker网络分配一个IP地址。IP地址是从分配给网络的地址池中分配的，因此docker daemon有效地充当了每个容器的DHCP服务器。每个网络也有一个默认的子网掩码和网关。<br>同样，一个容器的主机名也有docker daemon指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#指定运行网络</span><br><span class="line">docker run xxx --network</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#运行的容器连接到其它网络</span><br><span class="line">docker network connect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--ip，指定IP地址</span><br><span class="line">docker network connect my-bridge --ip 172.18.0.111</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--hostname，指定主机名</span><br><span class="line">docker run xxx --network xxx --hostname container-01</span><br><span class="line"></span><br><span class="line">docker network connect my-bridge --hostname container-02</span><br></pre></td></tr></table></figure><p><br></p><p><strong>DNS</strong><br>默认情况下，容器会继承docker daemon的DNS设置，包括<code>/etc/hosts</code>和<code>/etc/resolv.conf</code>。你也可以基于每个容器覆盖这些默认设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#DNS server</span><br><span class="line">--dns</span><br><span class="line"></span><br><span class="line">#DNS搜索域</span><br><span class="line">--dns-search</span><br><span class="line"></span><br><span class="line">#表示DNS选项值的键值对</span><br><span class="line">--dns-opt</span><br><span class="line"></span><br><span class="line">--hostname</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Docker使用代理服务器"><a href="#Docker使用代理服务器" class="headerlink" title="Docker使用代理服务器"></a>Docker使用代理服务器</h3><p>在启动docker容器的用户主目录下创建此文件： <code>~/.docker/config.json</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;proxies&quot;:</span><br><span class="line"> &#123;</span><br><span class="line">   &quot;default&quot;:</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;httpProxy&quot;: &quot;http://127.0.0.1:3001&quot;,</span><br><span class="line">     &quot;noProxy&quot;: &quot;*.test.example.com,.example2.com&quot;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="应用程序数据"><a href="#应用程序数据" class="headerlink" title="应用程序数据"></a>应用程序数据</h1><p>Manage application data</p><p><br></p><h2 id="存储综述"><a href="#存储综述" class="headerlink" title="存储综述"></a>存储综述</h2><p>Manage data in Docker</p><p>默认情况下，容器内创建的所有文件都被存储容器的可写层上：</p><ul><li><p>当容器不在运行时，数据不是持续存在的。容器外的进程很难从容器中获取数据</p></li><li><p>容器的可写层与主机紧密耦合，你很难将数据移动到其他地方</p></li><li><p>向容器的可写入层写入数据，需要存储驱动(storage driver)管理文件系统才<br>存储驱动使用Linux kernel来提供一个union filesystem。与直接写入主机文件系统的数据卷相比，这种额外的抽象会降低性能。</p></li></ul><p><br></p><p>Docker容器有两种选项将文件存储到主机上，这样即使容器停止之后这些文件也会被保留:</p><ul><li>volumes</li><li>bind mounts</li><li>tmpfs mount(Docker on Linux)</li></ul><p><br></p><h3 id="选择正确的挂载方式"><a href="#选择正确的挂载方式" class="headerlink" title="选择正确的挂载方式"></a>选择正确的挂载方式</h3><p>Choose the right type of mount</p><p>无论你选用哪种挂载方式，数据在容器内看起来都是相同的。它被公开为容器文件系统中的目录或单个文件。</p><p>一个简单的方法——考虑数据在docker主机上的位置，可以看出<strong>volumes, bind mounts, temfs</strong>之间的差异：</p><ul><li><p>Volumes<br>volumes存储在由docker管理的主机文件系统的一部分中(如Linux上: <code>/var/lib/docker/volumes/</code>)。<br>non-docker进程不应该修改这部分文件系统。Volume是Docker中保存数据的最佳方式。</p></li><li><p>Bind mounts<br>bind mounts可存储在主机系统上的任何地方。它们可能是最要的系统文件或目录。<br>docker主机或docker容器上的non-docker进程可以随时修改它们。</p></li><li><p>tmpfs<br>仅存储在主机系统的内存中，不会写入主机系统的文件系统。</p></li></ul><p><img src="/images/Docker/types-of-mounts.png" alt=""></p><p><br></p><h4 id="volumes的好栗子"><a href="#volumes的好栗子" class="headerlink" title="volumes的好栗子"></a>volumes的好栗子</h4><p>Good use cases for volumes</p><p>Volemes是在docker容器和服务中持久化数据的首选方式:</p><ul><li><p>在多个运行容器之间共享数据。如果你没有明确创建它，会在第一次挂载到容器时创建volume。当容器停止或删除时，volume仍然存在。多个容器可以挂载相同的volume，无论是read-write还是read-only。只有在你手动删除volume时它才会被删除。</p></li><li><p>当docker主机不能保证具有给定的目录或文件结构时，volume帮助你将docker主机的配置与运行时的容器进行分离。</p></li><li><p>当你想要将容器的数据存储在远程主机而不是本地的时候。</p></li><li><p>当你需要备份、还原或将数据从一台docker主机迁移到另一台时，volume时更好的选择。</p></li></ul><p><br></p><h4 id="bind-mounts的好栗子"><a href="#bind-mounts的好栗子" class="headerlink" title="bind mounts的好栗子"></a>bind mounts的好栗子</h4><p>一般来说，你应该尽量使用volumes。bind mounts适合以下案例：</p><ul><li><p>从主机共享配置文件到容器<br>这就是默认情况下，通过将主机的/<code>etc/resolv.conf</code>挂载到每个容器中，Docker为每个容器提供DNS解析。</p></li><li><p>在docker主机/容器的开发环境上共享源码或构建工件</p></li><li><p>当docker主机的文件或目录结构保证与容器所需的bind mounts一致时</p></li></ul><p><br></p><h4 id="tmpfs-mounts的好栗子"><a href="#tmpfs-mounts的好栗子" class="headerlink" title="tmpfs mounts的好栗子"></a>tmpfs mounts的好栗子</h4><p>当你不希望数据在主机上或容器内持久存储时，tmpfs mounts最合适。<br>这可能处于安全原因，或在应用于程序需要编写大量非持久性状态数据时保护容器的性能。</p><p><br></p><h4 id="使用bind或volumes的提示"><a href="#使用bind或volumes的提示" class="headerlink" title="使用bind或volumes的提示"></a>使用bind或volumes的提示</h4><p>如果你要使用bind mounts 或 volumes，牢记以下事项：</p><ul><li><p>如果你挂载一个空卷(empty volume)到存在文件或目录的容器中的目录上，则会将这些文件或目录赋值到卷中。同样，如果你启动容器并制定了一个尚不存在的卷，则会为你创建一个空卷。</p></li><li><p>如果你挂载一个bind mount或non-empty volume到存在文件或目录的容器中的目录上，则这些文件或目录会被挂载所遮蔽。就像在Linux上挂载卷一样。</p></li></ul><p><br><br><br></p><h2 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h2><p>volumes是持久化Docker数据的首选机制，卷由docker完全管理。另外，由于卷不会增加使用它的容器的大小，并且该卷的内容存在于给定容器的周期之外，因此卷通产是比将容器的可写入层中的数据持久化更好的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-v/--volume</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#此选项更详细和简单</span><br><span class="line">#如果你需要指定volume driver，请使用此flag</span><br><span class="line">--mount</span><br><span class="line"></span><br><span class="line">docker service create \</span><br><span class="line">  --mount &apos;type=volume,src=&lt;VOLUME-NAME&gt;,dst=&lt;CONTAINER-PATH&gt;,volume-driver=local,volume-opt=type=nfs,volume-opt=device=&lt;nfs-server&gt;:&lt;nfs-path&gt;,&quot;volume-opt=o=addr=&lt;nfs-address&gt;,vers=4,soft,timeo=180,bg,tcp,rw&quot;&apos;</span><br><span class="line">  --name myservice \</span><br><span class="line">  &lt;IMAGE&gt;</span><br></pre></td></tr></table></figure><ul><li><code>--volume</code></li></ul><p>由三个由冒号<code>:</code>分割的字段组成。这些字段必须按照正确的顺序排列，每个字段的含义并不明显。<br>第一个字段是卷的名称，并且在给定主机上是唯一的。对于匿名卷，第一个字段被省略。<br>第二个字段是文件或目录在容器中的挂载路径。<br>第三个字段是可选的，是由一个逗号`,分隔的选项列表。</p><ul><li><code>--mount</code></li></ul><p>由多个键值对组成，以逗号<code>,</code>分隔。<code>--mount</code>的语法比<code>--volume</code>更冗长，但键的顺序并不重要，并且标志的值更易于理解。<br>挂载的类型(type)有<code>bind, volume, tmpfs</code>。<br>挂载的来源(source, src)为卷的名称，对于匿名卷该字段可被省略。<br>目的地(destination, dst, target)的值是安装在容器中的文件或目录的路径。<br>只读(readonly)选项将导致bind mount以只读方式挂载到容器中。<br><code>volume-opt</code>选项可以多次指定，它是由选项名称和值组成的键值对组成。</p><p><br></p><h3 id="创建和管理卷"><a href="#创建和管理卷" class="headerlink" title="创建和管理卷"></a>创建和管理卷</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my-vol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               my-vol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2018-06-15T17:19:02+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/opt/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker volume rm my-vol</span><br></pre></td></tr></table></figure><p><br></p><h3 id="启动用卷的容器"><a href="#启动用卷的容器" class="headerlink" title="启动用卷的容器"></a>启动用卷的容器</h3><p>Start a container with a volume</p><p>包括两种卷：</p><ul><li><p>已存在的卷</p></li><li><p>未存在的卷<br>会自动创建</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount source=myvol2,target=/app \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --volume myvol2:/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               my-vol</span><br><span class="line">local               myvol2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker inspect devtest</span><br><span class="line">#找到挂载</span><br><span class="line">        &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;myvol2&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/opt/docker/volumes/myvol2/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/app&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><p><br></p><h3 id="启动用卷的服务"><a href="#启动用卷的服务" class="headerlink" title="启动用卷的服务"></a>启动用卷的服务</h3><p>Start a service with volumes</p><p>docker服务不支持使用<code>--volume</code>标志，请使用<code>--mount</code>标志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service create -d \</span><br><span class="line">  --replicas=4 \</span><br><span class="line">  --name devtest-service \</span><br><span class="line">  --mount source=myvol2,target=/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p><br></p><h3 id="在机器间共享数据"><a href="#在机器间共享数据" class="headerlink" title="在机器间共享数据"></a>在机器间共享数据</h3><p>Share data among machines</p><p>在构建容错应用程序时，可能需要配置同一服务的多个副本能访问相同的文件，而这些副本可能分布于不同的节点上。</p><p><img src="/images/Docker/share_data_amon_machine.png" alt=""></p><p>卷驱动程序(volume driver)允许你从应用程序逻辑中抽象出底层存储系统。</p><p><br></p><h3 id="使用卷驱动"><a href="#使用卷驱动" class="headerlink" title="使用卷驱动"></a>使用卷驱动</h3><p>Use a volume driver</p><p>在创建卷或启动带卷的容器时，你可以指定卷驱动。如<code>vieux/sshfs</code>卷驱动程序。</p><ul><li>初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker plugin install --grant-all-permissions vieux/sshfs</span><br></pre></td></tr></table></figure><ul><li>使用卷驱动创建卷</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#操作node2</span><br><span class="line">docker volume create --driver vieux/sshfs \</span><br><span class="line">  -o sshcmd=test@node2:/home/test \</span><br><span class="line">  -o password=testpassword \</span><br><span class="line">  sshvolume</span><br></pre></td></tr></table></figure><ul><li>启动一个带用卷驱动程序创建的卷的容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name sshfs-container \</span><br><span class="line">  --volume-driver vieux/sshfs \</span><br><span class="line">  --mount src=sshvolume,target=/app,volume-opt=sshcmd=test@node2:/home/test,volume-opt=password=testpassword \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><ul><li>备份，还原或迁移数据卷</li></ul><p>使用<code>--volumes-from</code>标志创建一个挂载该卷的新容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#备份</span><br><span class="line">docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#从备份还原</span><br><span class="line">docker run -v /dbdata --name dbstore2 ubuntu /bin/bash</span><br><span class="line">docker run --rm --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c &quot;cd /dbdata &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="bind-mounts"><a href="#bind-mounts" class="headerlink" title="bind mounts"></a>bind mounts</h2><p>与volumes相比，bind mounts功能有限。当你使用bind mounts时，主机上的文件或目录(绝对路径或相对路径)被挂载到容器内。相比之下，当你使用volumes时，会在主机上的Docker存储目录中创建一个新目录，并且Docker会管理该目录的内容。<br>该文件或目录不需要已经存在于Docker主机上。如果它尚未存在，它会根据需求创建。bind mounts非常高效，但是它们依赖于具有特定目录结构的主机文件系统。如果你正在开发新的Docker Application，请考虑使用volumes。你不能使用Docker CLI直接管理bind mounts。</p><p>你可以使用<code>--volume</code>或<code>--mount</code>(语法更详细)flag。具体区别参考volumes的介绍。</p><p><br></p><h3 id="启动用bind-mount的容器"><a href="#启动用bind-mount的容器" class="headerlink" title="启动用bind mount的容器"></a>启动用bind mount的容器</h3><p>Start a container with a bind mount</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p><br></p><p><strong>挂载到容器内非空目录</strong><br>如果挂载在容器内非空目录上，则该目录的已有内容将被隐藏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name broken-container \</span><br><span class="line">  --mount type=bind,source=/tmp,target=/usr \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name broken-container \</span><br><span class="line">  -v /tmp:/usr \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p><br></p><h3 id="只读bind-mount"><a href="#只读bind-mount" class="headerlink" title="只读bind mount"></a>只读bind mount</h3><p>Use a read-only bind mount</p><p>某些时候，容器可能只需要只读权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app,readonly \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app:ro \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p><br></p><h3 id="bind-propagation"><a href="#bind-propagation" class="headerlink" title="bind propagation"></a>bind propagation</h3><p>对于bind mounts和volumes，bind propagation(传播)默认为<code>rprivate</code>。它只能对Linux主机上的bind mounts进行配置。它是一个高级话题，许多用户并不需要配置它。</p><p>bind propagation(传播)是指在给定的bind-mounts或named volume中创建的挂载是否可以传播(propagation)到该挂载(mount)的副本(replicas)。<br>考虑一个挂载点<code>/mnt</code>，挂载在<code>/tmp</code>上。传播设置控制<code>/tmp/a</code>上的挂载点是否也可用于<code>/mnt/a</code>。每个传播设置都有一个递归对应点。在递归的情况下，考虑<code>/tmp/a</code>也被挂载到<code>/foo</code>。传播设置控制是否存在<code>/mnt/a</code>和<code>/tmp/a</code>。</p><table><thead><tr><th>传播设置</th><th>描述</th></tr></thead><tbody><tr><td>shared</td><td>原始mount的sub-mount会暴露给replica mounts，并且replica mounts的sub-mount同样传播给原始mount。也就是双向</td></tr><tr><td>slave</td><td>类似于shared，但仅限于单方向。</td></tr><tr><td>private</td><td>私有挂载</td></tr><tr><td>rshared</td><td>与shared相同，但传播也扩展到嵌套在任何原始或副本挂载点内的挂载点</td></tr><tr><td>rslave</td><td>与slave相同，但传播也扩展到嵌套在任何原始或副本挂载点内的挂载点</td></tr><tr><td>rprivate</td><td>默认值。与private相同，这意味着原始或副本挂载点内的任何位置的挂载点都不会沿任一方向传播</td></tr></tbody></table><p>在设置bind propagation之前，主机文件系统需要已经支持bind propagatin: <a href="https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app \</span><br><span class="line">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app2,readonly,bind-propagation=rslave \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app2:ro,rslave \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p><br></p><h3 id="selinux-label"><a href="#selinux-label" class="headerlink" title="selinux label"></a>selinux label</h3><p>如果你使用selinux，你可以添加<code>z</code>或<code>Z</code>选项来修改挂载到容器内的主机文件或目录的selinux标签。这户影响主机本身的文件或目录，并可能导致Docker范围之外的后果。</p><ul><li><p><code>z</code><br>bind mount的内容在多个容器之间共享。</p></li><li><p><code>Z</code><br>bind mount的内容是私有和非共享的。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#不支持--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app:z \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="tmpfs-mounts"><a href="#tmpfs-mounts" class="headerlink" title="tmpfs mounts"></a>tmpfs mounts</h2><p>tmpfs: <a href="https://docs.docker.com/storage/tmpfs/#limitations-of-tmpfs-mounts" target="_blank" rel="noopener">https://docs.docker.com/storage/tmpfs/#limitations-of-tmpfs-mounts</a><br>tmpfs mounts只支持运行在Linux上的Docker。</p><p><br><br><br></p><h2 id="Troubleshoot"><a href="#Troubleshoot" class="headerlink" title="Troubleshoot"></a>Troubleshoot</h2><p>troubleshoot: <a href="https://docs.docker.com/storage/troubleshooting_volume_errors/" target="_blank" rel="noopener">https://docs.docker.com/storage/troubleshooting_volume_errors/</a></p><p><br><br><br></p><h2 id="将数据存储到容器内"><a href="#将数据存储到容器内" class="headerlink" title="将数据存储到容器内"></a>将数据存储到容器内</h2><p>Store data within containers</p><h3 id="关于存储驱动"><a href="#关于存储驱动" class="headerlink" title="关于存储驱动"></a>关于存储驱动</h3><p>为了有效地使用存储驱动(storage driver)，了解Docker如何构建和存储镜像，以及容器如何使用镜像是很重要的。你可以使用这些信息作出明智的选择，以便找到应用程序数据持久化的最佳方式，并避免出现性能问题。</p><p>存储驱动允许你在容器的可写入层创建数据。在容器停止后，这些文件将不会被保留，并且读写速度都很低。</p><p><br></p><h4 id="镜像和层"><a href="#镜像和层" class="headerlink" title="镜像和层"></a>镜像和层</h4><p>Images and layers</p><p>Docker镜像由一系列层(layer)构建而成。每个层代表镜像的Dockerfile中的指令，除最后一层外的每个层都是只读的。</p><p>考虑如下Dockerfile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:15.04</span><br><span class="line">COPY . /app</span><br><span class="line">RUN make /app</span><br><span class="line">CMD python /app/app.py</span><br></pre></td></tr></table></figure><p>此Dockerfile包含4个命令，每个命令创建一个层。<br>当你创建一个新容器时，你在底层之上添加了一个新的可写入层——它通常被称为<strong>容器层(container layer)</strong>。<br>对运行中的容器所做的所有更改(增删改文件)都会写入此可写容器层。</p><p><img src="/images/Docker/container-layers.jpg" alt="容器层"></p><p>存储驱动处理有关这些层相互交互的详细信息。有几个不同的驱动程序，在不同的情况下具有相应的优点和缺点。</p><p><br></p><h4 id="容器和层"><a href="#容器和层" class="headerlink" title="容器和层"></a>容器和层</h4><p>Container and layers</p><p>容器和镜像之间的主要区别是最高的可写入层。当容器删除时，可写入层也被删除。但底层镜像保持不变。</p><p>由于每个容器都有自己的可写入容器层，并且所有的更改都存储在此容器中，因此多个容器可以共享相同的基础镜像的访问权限，并拥有自己的数据状态。</p><p><img src="/images/Docker/sharing-layers.jpg" alt="容器和层"></p><p>Docker使用存储驱动来管理镜像层和可写入容器层的内容。每个存储驱动程序都已不同方式实现，但所有驱动程序都是用可堆叠(stackable)的镜像层和写入时复制(copy-on-write)策略。</p><p><br></p><h4 id="容器大小"><a href="#容器大小" class="headerlink" title="容器大小"></a>容器大小</h4><p>Container size on disk</p><p>使用<code>docker ps -s(--size)</code>命令查看正在运行的容器的大小。有两个大小:</p><ul><li><p><code>size</code><br>每个容器的可写入层的数据量(在磁盘上的)</p></li><li><p><code>virtual size</code><br>容器使用的只读镜像的数据量加上容器可写入层大小</p></li></ul><p><br><br><br></p><h4 id="写入时复制"><a href="#写入时复制" class="headerlink" title="写入时复制"></a>写入时复制</h4><p>The copy-on-write (CoW) strategy</p><p>写入时复制是一种共享和复制文件以实现最高效率的策略。如果文件或目录存在于镜像的较低层中，而另外的层(包括可写入层)需要对其进行读取访问，则它只是用已有文件。第一次需要修改文件时，该文件将被复制到该层并进行修改。这最大限度减少了每个后续层的I/O和大小。</p><p><strong>共享促进了较小的容器</strong><br>Sharing promotes smaller images</p><p>当你创建和拉取镜像时，它们通常存储于本机的<code>/var/lib/docker</code>下。每层都存储在主机存储区内的特定目录下<code>/var/lib/docker/&lt;storage-driver&gt;/layers</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls /var/lib/docker/aufs/layers</span><br><span class="line"></span><br><span class="line">1d6674ff835b10f76e354806e16b950f91a191d3b471236609ab13a930275e24</span><br><span class="line">5dbb0cbe0148cf447b9464a358c1587be586058d9a4c9ce079320265e2bb94e7</span><br><span class="line">bef7199f2ed8e86fa4ada1309cfad3089e0542fec8894690529e4c04a7ca2d73</span><br><span class="line">ebf814eccfe98f2704660ca1d844e4348db3b5ccc637eb905d4818fbfb00a06a</span><br></pre></td></tr></table></figure><p><br></p><p><strong>复制使容器高效</strong><br>Copying makes containers efficient</p><p>容器不会更改的任何文件都不会被复制到此可写入层中。这意味着可写入层尽可能小。</p><p>当容器中存在的文件被修改时，存储驱动之赐你个写入时复制操作(CoW)。涉及的具体步骤取决于具体的存储驱动。</p><p>aufs, overlay, overlay2存储驱动 遵循的基本顺序:</p><ul><li>通过镜像层搜索要更新的文件</li><li>对找到的文件的第一个副本执行<code>copy_up</code>操作，将文件复制到容器的可写入层</li><li>任何修改应用于此复制的文件，并且该容器不能看到存在于较低层中的文件的只读副本</li></ul><p><br><br><br></p><h3 id="选择存储驱动"><a href="#选择存储驱动" class="headerlink" title="选择存储驱动"></a>选择存储驱动</h3><p>Select a storage driver</p><p>理想情况下，将很少的数据写入容器的可写入层，并且使用Docker volume写入数据。但某些工作负载要求你能够写入容器的可写入层，这就是存储驱动进来的地方。</p><p>存储驱动控制镜像和容器在Docker主机上的存储和管理方式。</p><p>考虑三个高层次因素：</p><ul><li><p>如果你的Kernel支持多个存储驱动，在没有指定存储驱动的情况下，Docker会列出要使用拿个存储驱动程序的优先级列表</p><ul><li>如果可能，将使用配置最少的存储驱动。如<code>brrfs</code>, <code>zfs</code></li><li>否则，请尝试在最常见的情况下使用具有最佳整体性能和稳定性的存储驱动程序<ul><li><code>overlay2</code>是首选(Docker CE的默认选择)，其次是<code>overlay</code>。这些都不需要额外的配置。</li><li><code>devicemapper</code>居次，但需要<code>direc-lvm</code>用于生产环境，因为<code>loopback-lvm</code>的性能很差。</li></ul></li></ul></li><li><p>你的选择会受限于Docker版本、操作系统和发行版</p></li><li><p>某些存储驱动要求你为文件系统使用特定格式</p></li><li><p>你的选择还取决于工作负载和所需的稳定级别</p></li></ul><p><br></p><h4 id="Linux发行版支持的存储驱动"><a href="#Linux发行版支持的存储驱动" class="headerlink" title="Linux发行版支持的存储驱动"></a>Linux发行版支持的存储驱动</h4><p><strong>Docker CE</strong></p><table><thead><tr><th>Linux distribution</th><th>Recommended storage drivers</th></tr></thead><tbody><tr><td>Docker CE on Ubuntu</td><td>aufs, devicemapper, overlay2 (Ubuntu 14.04.4 or later, 16.04 or later), overlay, zfs, vfs</td></tr><tr><td>Docker CE on Debian</td><td>aufs, devicemapper, overlay2 (Debian Stretch), overlay, vfs</td></tr><tr><td>Docker CE on CentOS</td><td>devicemapper, vfs</td></tr><tr><td>Docker CE on Fedora</td><td>devicemapper, overlay2 (Fedora 26 or later, experimental), overlay (experimental), vfs</td></tr></tbody></table><p><br></p><h4 id="存储驱动支持的文件系统"><a href="#存储驱动支持的文件系统" class="headerlink" title="存储驱动支持的文件系统"></a>存储驱动支持的文件系统</h4><table><thead><tr><th>Storage driver</th><th>Supported backing filesystems</th></tr></thead><tbody><tr><td>overlay, overlay2</td><td>ext4, xfs</td></tr><tr><td>aufs</td><td>ext4, xfs</td></tr><tr><td>devicemapper</td><td>direct-lvm</td></tr><tr><td>btrfs</td><td>btrfs</td></tr><tr><td>zfs</td><td>zfs</td></tr></tbody></table><p><br></p><h4 id="查看存储驱动"><a href="#查看存储驱动" class="headerlink" title="查看存储驱动"></a>查看存储驱动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Version: 18.03.1-ce</span><br><span class="line">Storage Driver: overlay2</span><br></pre></td></tr></table></figure><p><br></p><h3 id="AUFS存储驱动"><a href="#AUFS存储驱动" class="headerlink" title="AUFS存储驱动"></a>AUFS存储驱动</h3><p>AUFS is a union filesystem.</p><p>aufs存储驱动用于管理Ubuntu上Docker的镜像和层。</p><p>我的发行版是Centos，此驱动针对Ubuntu。注意</p><p><br></p><h4 id="使用aufs存储驱动配置Docker"><a href="#使用aufs存储驱动配置Docker" class="headerlink" title="使用aufs存储驱动配置Docker"></a>使用aufs存储驱动配置Docker</h4><ul><li>判断kernel是否支持aufs</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep aufs /proc/filesystems</span><br></pre></td></tr></table></figure><ul><li>查看Docker存储驱动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><ul><li>配置存储驱动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">--storage-driver</span><br></pre></td></tr></table></figure><p><br></p><h4 id="aufs存储驱动如何工作"><a href="#aufs存储驱动如何工作" class="headerlink" title="aufs存储驱动如何工作"></a>aufs存储驱动如何工作</h4><p>AUFS是一个联合文件系统，这意味着它在单个Linux主机上对多个目录进行分层并将它们呈现为单个目录。这些目录在AUFS术语中称为分支，在Docker术语中称为层。统一过程被称为联合安装。</p><p><img src="/images/Docker/aufs_layers.jpg" alt=""></p><p><br></p><h4 id="容器如何使用aufs进行读写"><a href="#容器如何使用aufs进行读写" class="headerlink" title="容器如何使用aufs进行读写"></a>容器如何使用aufs进行读写</h4><p><strong>读取文件</strong></p><p><br></p><h3 id="Btrfs存储驱动"><a href="#Btrfs存储驱动" class="headerlink" title="Btrfs存储驱动"></a>Btrfs存储驱动</h3><p>Use the BTRFS storage driver</p><p><br></p><h3 id="Device-Mapper存储驱动"><a href="#Device-Mapper存储驱动" class="headerlink" title="Device Mapper存储驱动"></a>Device Mapper存储驱动</h3><p>Use the Device Mapper storage driver</p><p>Device Mapper是基于kernel的框架，支持Linux上的许多高级卷管理技术。Docker的<code>devicemapper</code>存储驱动利用此框架的精简配置和快照功能进行镜像和容器管理。</p><p>对于支持它的系统，<code>devicemapper</code>支持包含在Linux内核中。但是，需要特定配置才能将其用于Docker。<code>devicemapper</code>驱动使用专用于Docker的块设备，并在块级(block level)而不是文件级(file level)运行。这些设备可通过在Docker主机添加物理设备来扩展，并且它们比咋子操作系统级别使用文件系统更好。</p><p><br></p><p><strong>依赖</strong></p><ul><li>Docker EE</li><li>Docker CE</li><li>更改存储驱动会使已创建的容器在本地系统上都无法访问</li></ul><p><br></p><p><strong>配置devicemapper存储驱动</strong></p><ul><li>loop-lvm</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#loop-lvm模式</span><br><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;storage-driver&quot;: &quot;devicemapper&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><ul><li>direct-lvm<br>生产环境的devicemapper存储驱动必须使用direct-lvm模式。此模式使用块设备创建精简池。这比使用loopback设备更快，更高效地使用系统资源，并且块设备可以根据需求进行扩展。</li></ul><p><br></p><table><thead><tr><th>Option</th><th>Description</th><th>Required</th><th>Default</th><th>Example</th></tr></thead><tbody><tr><td>dm.directlvm_device</td><td>The path to the block device to configure for direct-lvm.</td><td>Yes</td><td>-</td><td>dm.directlvm_device=”/dev/xvdf”</td></tr><tr><td>dm.thinp_percent</td><td>The percentage of space to use for storage from the passed in block device.</td><td>No</td><td>95</td><td>dm.thinp_percent=95</td></tr><tr><td>dm.thinp_metapercent</td><td>The percentage of space to for metadata storage from the passed-in block device.</td><td>No</td><td>1</td><td>dm.thinp_metapercent=1</td></tr><tr><td>dm.thinp_autoextend_threshold</td><td>The threshold for when lvm should automatically extend the thin pool as a percentage of the total storage space.</td><td>No</td><td>80</td><td>dm.thinp_autoextend_threshold=80</td></tr><tr><td>dm.thinp_autoextend_percent</td><td>The percentage to increase the thin pool by when an autoextend is triggered.</td><td>No</td><td>20</td><td>dm.thinp_autoextend_percent=20</td></tr><tr><td>dm.directlvm_device_force</td><td>Whether to format the block device even if a filesystem already exists on it. If set to false and a filesystem is present, an error is logged and the filesystem is left intact.</td><td>No</td><td>false</td><td>dm.directlvm_device_force=true</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#安装依赖</span><br><span class="line">RHEL / CentOS: device-mapper-persistent-data, lvm2, and all dependencies</span><br><span class="line">Ubuntu / Debian: thin-provisioning-tools, lvm2, and all dependencies</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建物理卷(physical volume)</span><br><span class="line">pvcreate /dev/cvdf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建卷组(volume group)</span><br><span class="line">vgcreat docker /dev/xvdf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建逻辑卷(logical volume)</span><br><span class="line">lvcreate --wipesignatures y -n thinpool docker -l 95%VG</span><br><span class="line">lvcreate --wipesignatures y -n thinpoolmeta docker -l 1%VG</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#转换卷为精简池</span><br><span class="line">lvconvert -y \</span><br><span class="line">--zero n \</span><br><span class="line">-c 512K \</span><br><span class="line">--thinpool docker/thinpool \</span><br><span class="line">--poolmetadata docker/thinpoolmeta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#配置lvm配置文件精简池自动扩展</span><br><span class="line">/etc/lvm/profile/docker-thinpool.profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定thin_pool_autoextend_threshold 和 thin_pool_autoextend_percent的值</span><br><span class="line">activation &#123;</span><br><span class="line">  thin_pool_autoextend_threshold=80</span><br><span class="line">  thin_pool_autoextend_percent=20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#应用LVM profile</span><br><span class="line">lvchange --metadataprofile docker-thinpool docker/thinpool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启用监控LV</span><br><span class="line">lvs -o+seg_monitor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#配置devicemapper存储驱动</span><br><span class="line">/etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;storage-driver&quot;: &quot;devicemapper&quot;,</span><br><span class="line">    &quot;storage-opts&quot;: [</span><br><span class="line">    &quot;dm.thinpooldev=/dev/mapper/docker-thinpool&quot;,</span><br><span class="line">    &quot;dm.use_deferred_removal=true&quot;,</span><br><span class="line">    &quot;dm.use_deferred_deletion=true&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><p><br></p><h4 id="管理devicemapper"><a href="#管理devicemapper" class="headerlink" title="管理devicemapper"></a>管理devicemapper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查看LVM logs</span><br><span class="line">journalctl -fu dm-event.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pvdisplay</span><br><span class="line">vgdisplay/vgextend</span><br><span class="line">lvdisplay/lvextend/lvchange</span><br></pre></td></tr></table></figure><p><br></p><h3 id="OverlayFS存储驱动"><a href="#OverlayFS存储驱动" class="headerlink" title="OverlayFS存储驱动"></a>OverlayFS存储驱动</h3><p>Use the OverlayFS storage driver</p><p><br></p><h3 id="ZFS存储驱动"><a href="#ZFS存储驱动" class="headerlink" title="ZFS存储驱动"></a>ZFS存储驱动</h3><p>Use the ZFS storage driver</p><p><br></p><h3 id="VFS存储驱动"><a href="#VFS存储驱动" class="headerlink" title="VFS存储驱动"></a>VFS存储驱动</h3><p>Use the VFS storage driver</p><p>VFS存储驱动不是联合文件系统，相反，每层都是磁盘上的一个目录，它不支持CoW。要创建一个新层，先前的层会进行<strong>深层复制(deep copy)</strong>。与其它驱动相比，这导致磁盘性能下降和占用更多磁盘空间。但是，它强大，稳定，适用于各种环境。</p><p><strong>配置VFS存储驱动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;storage-driver&quot;: &quot;vfs&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#控制大小</span><br><span class="line">&#123;</span><br><span class="line">  &quot;storage-opts&quot;: [&quot;size=256M&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="在生产环境运行应用程序"><a href="#在生产环境运行应用程序" class="headerlink" title="在生产环境运行应用程序"></a>在生产环境运行应用程序</h1><p>Run your app in production</p><p><br></p><h2 id="配置对象"><a href="#配置对象" class="headerlink" title="配置对象"></a>配置对象</h2><p>Configure all objects</p><p><br></p><h3 id="自定义原数据"><a href="#自定义原数据" class="headerlink" title="自定义原数据"></a>自定义原数据</h3><p>Apply custom metadata to objects</p><p><strong>Docker object label</strong><br>标签(label)是一种将原数据(metadata)应用于docker object的机制，包含:</p><ul><li>image</li><li>container</li><li>local daemon</li><li>volume</li><li>network</li><li>node</li><li>service</li></ul><p><br></p><h4 id="label-key-and-value"><a href="#label-key-and-value" class="headerlink" title="label key and value"></a>label key and value</h4><p>标签是一组键值对，以字符串形式存储。可以为对象指定多个标签，但每个键值对必须唯一。如果一个键有多个值，则最新写入的值会覆盖以前的值。</p><p><strong>key格式建议</strong><br>label key是可能包含字母，数字，<code>.</code>，<code>-</code>组成的字符串。</p><ul><li>第三方工具的作者给每个label key加上前缀域，如<code>com.example.some-label</code></li><li>未经允许，不得使用他人域</li><li><code>com.docker.*</code>, <code>io.docker.*</code>, <code>org.dockerproject.*</code>命名空间保留给Docker内部使用</li><li>以小写字母开头和结尾</li><li>用<code>.</code>分割命令空间字段</li></ul><p><br></p><p><strong>value 指南</strong><br>label value可以包含任何可表示为字符串的数据类型，包括JSON, XML, CSV, YAML…唯一的要求是，首先使用特定于结构类型的机制将该值序列化为字符串。</p><p><br><br><br></p><h3 id="清理未使用的对象"><a href="#清理未使用的对象" class="headerlink" title="清理未使用的对象"></a>清理未使用的对象</h3><p>Prune unused Docker objects</p><p>Docker采取保守的方法来清理未使用的对象(通常称为垃圾回收)，通常它不会删除这些对象，除非你明确要求Docker这样做。对于每个类型的对象，docker提供了<code>prune</code>命令。你也可以使用<code>docker system prune</code>命令一次清理多种类型的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#prune image</span><br><span class="line">docker image prune</span><br><span class="line"> docker image prune -a --filter &quot;until=24h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#prune container</span><br><span class="line">docker container prune</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#prune volume</span><br><span class="line">docker volume prune</span><br><span class="line">docker volume prune --filter &quot;label!=keep&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#prune everything</span><br><span class="line">docker system prune</span><br><span class="line">docker system prune --volumes</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>Format command and log output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#join</span><br><span class="line">docker inspect --format &apos;&#123;&#123;join .Args &quot; , &quot;&#125;&#125;&apos; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#json</span><br><span class="line">docker inspect --format &apos;&#123;&#123;json .Mounts&#125;&#125;&apos; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#lower</span><br><span class="line">docker inspect --format &quot;&#123;&#123;lower .Name&#125;&#125;&quot; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#split</span><br><span class="line">docker inspect --format &apos;&#123;&#123;split .Image &quot;:&quot;&#125;&#125;&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#title</span><br><span class="line">docker inspect --format &quot;&#123;&#123;title .Name&#125;&#125;&quot; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#upper</span><br><span class="line">docker inspect --format &quot;&#123;&#123;upper .Name&#125;&#125;&quot; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#printIn</span><br><span class="line">docker inspect --format=&apos;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;println .IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&apos; container</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="配置daemon"><a href="#配置daemon" class="headerlink" title="配置daemon"></a>配置daemon</h2><p>Configure the daemon</p><p><br></p><h3 id="配置和运行Docker"><a href="#配置和运行Docker" class="headerlink" title="配置和运行Docker"></a>配置和运行Docker</h3><p><strong>配置docker daemon</strong></p><ul><li>使用json配置文件</li><li>使用<code>dockerd --flag</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;debug&quot;: true,</span><br><span class="line">  &quot;tls&quot;: true,</span><br><span class="line">  &quot;tlscert&quot;: &quot;/var/docker/server.pem&quot;,</span><br><span class="line">  &quot;tlskey&quot;: &quot;/var/docker/serverkey.pem&quot;,</span><br><span class="line">  &quot;hosts&quot;: [&quot;tcp://192.168.59.3:2376&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">dockerd --debug \</span><br><span class="line">  --tls=true \</span><br><span class="line">  --tlscert=/var/docker/server.pem \</span><br><span class="line">  --tlskey=/var/docker/serverkey.pem \</span><br><span class="line">  --host tcp://192.168.59.3:2376</span><br></pre></td></tr></table></figure><p><br></p><p><strong>docker daemon目录</strong><br>docker daemon将所有数据保存在一个目录中。你可以手动修改它。</p><p>默认目录:</p><ul><li>Linux： <code>/var/lib/docker</code></li><li>Windows: <code>C:\ProgramData\docker</code></li></ul><p><br><br><br></p><h3 id="使用systemd控制docker"><a href="#使用systemd控制docker" class="headerlink" title="使用systemd控制docker"></a>使用systemd控制docker</h3><p>Control Docker with systemd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/lib/systemd/system/docker.service</span><br><span class="line">#or</span><br><span class="line">cat /etc/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl enable/start/stop/status docker</span><br></pre></td></tr></table></figure><p><br></p><p><strong>自定义docker daemon选项</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;data-root&quot;: &quot;/mnt/docker-data&quot;,</span><br><span class="line">    &quot;storage-driver&quot;: &quot;overlay&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>http/https proxy</strong><br>Docker daemon使用<code>HTTP_PROXY</code>，<code>HTTPS_PROXY</code>和<code>NO_PROXY</code>环境变量来配置代理行为。无法使用<code>daemon.json</code>文件来配置环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#/etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot;</span><br><span class="line"></span><br><span class="line">#/etc/systemd/system/docker.service.d/https-proxy.conf</span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTPS_PROXY=https://proxy.example.com:443/&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl show --property=Environment docker</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="收集Docker指标"><a href="#收集Docker指标" class="headerlink" title="收集Docker指标"></a>收集Docker指标</h3><p>Collect Docker metrics with Prometheus</p><p>Promethus: <a href="https://prometheus.io/" target="_blank" rel="noopener">https://prometheus.io/</a><br>Prometheus是一个开源的系统监控和报警工具包。你可以将Docker配置为Prometheus target。设置Prometheus作为Docker容器运行，并使用Prometheus监控Docker实例。</p><p><strong>配置Docker</strong><br>配置docker daemon作为Prometheus target，你需要指定<code>metrics-address</code>。最佳方式是通过<code>daemon.json</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;metrics-addr&quot; : &quot;127.0.0.1:9323&quot;,</span><br><span class="line">  &quot;experimental&quot; : true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置和运行Prometheus</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/tmp/prometheus.yml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># my global config</span><br><span class="line">global:</span><br><span class="line">  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br><span class="line">  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.</span><br><span class="line">  # scrape_timeout is set to the global default (10s).</span><br><span class="line"></span><br><span class="line">  # Attach these labels to any time series or alerts when communicating with</span><br><span class="line">  # external systems (federation, remote storage, Alertmanager).</span><br><span class="line">  external_labels:</span><br><span class="line">      monitor: &apos;codelab-monitor&apos;</span><br><span class="line"></span><br><span class="line"># Load rules once and periodically evaluate them according to the global &apos;evaluation_interval&apos;.</span><br><span class="line">rule_files:</span><br><span class="line">  # - &quot;first.rules&quot;</span><br><span class="line">  # - &quot;second.rules&quot;</span><br><span class="line"></span><br><span class="line"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class="line"># Here it&apos;s Prometheus itself.</span><br><span class="line">scrape_configs:</span><br><span class="line">  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br><span class="line">  - job_name: &apos;prometheus&apos;</span><br><span class="line"></span><br><span class="line">    # metrics_path defaults to &apos;/metrics&apos;</span><br><span class="line">    # scheme defaults to &apos;http&apos;.</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&apos;localhost:9090&apos;]</span><br><span class="line"></span><br><span class="line">  - job_name: &apos;docker&apos;</span><br><span class="line">         # metrics_path defaults to &apos;/metrics&apos;</span><br><span class="line">         # scheme defaults to &apos;http&apos;.</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&apos;localhost:9323&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service create --replicas 1 --name my-prometheus \</span><br><span class="line">    --mount type=bind,source=/tmp/prometheus.yml,destination=/etc/prometheus/prometheus.yml \</span><br><span class="line">    --publish published=9090,target=9090,protocol=tcp \</span><br><span class="line">    prom/prometheus</span><br></pre></td></tr></table></figure><p>访问: <a href="http://localhost:9090/targets/" target="_blank" rel="noopener">http://localhost:9090/targets/</a></p><p><br><br><br></p><h2 id="配置容器"><a href="#配置容器" class="headerlink" title="配置容器"></a>配置容器</h2><p>Configure containers</p><h3 id="自动启动容器"><a href="#自动启动容器" class="headerlink" title="自动启动容器"></a>自动启动容器</h3><p>Start containers automatically</p><p>Docker提供了重启策略，以控制容器在退出或重启时自动启动。重启策略可确保链接的容器以正确的书序启动。Docker建议你使用重启策略，并避免使用进程管理器(如supervisor)来启动容器。<br>重启策略与<code>docker xxx --live-restart</code>标志不同，后者可以让你在Docker upgrage期间保持容器运行。</p><p><br></p><p><strong>重启策略</strong><br>使用<code>docker run xxx --restart</code>标志来配置重启策略，<code>--restart</code>的值如下：</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>no</td><td>不要自动重启容器(默认值)</td></tr><tr><td>on-failure</td><td>如果容器由于错误(非零退出码)退出，则重启容器</td></tr><tr><td>unless-stopped</td><td>除非明确停止或docker本身停止或重启，则重启容器</td></tr><tr><td>always</td><td>如果停止，则始终重启容器</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#栗子</span><br><span class="line">docker run -dit --restart unless-stopped redis</span><br></pre></td></tr></table></figure><p><br></p><p><strong>重启策略注意事项</strong></p><ul><li><p>重启策略尽在容器成功启动后才生效——这意味着容器已启动至少10s，并且Docker已开始监视它。<br>这可以防止根本不启动的容器进入重启循环。</p></li><li><p>如果你手动停止容器(状态码为0)，则在重启Docker daemon或手动启动容器之前，其重启策略将会被忽略。<br>这是另一个防止重启循环的尝试。</p></li><li><p>重启策略仅适用于容器。集群服务的重启策略与此不同。</p></li></ul><p><br><br><br></p><h3 id="在daemon停机期间保持容器活着"><a href="#在daemon停机期间保持容器活着" class="headerlink" title="在daemon停机期间保持容器活着"></a>在daemon停机期间保持容器活着</h3><p>Keep containers alive during daemon downtime</p><p>默认情况下，当Docker daemon终止时，它会关闭正在运行的容器。从Docker Engine 1.12开始，你可配置守护进程，以便在守护进程不可用时容器保持运行。这个功能被称为<strong>实时恢复(live restore)</strong>。<br>它不支持Windows container。</p><p><br></p><p><strong>实时恢复</strong><br>有两种方式来启用live restore，只启用其中一个就好。<br>实时恢复仅适用于独立容器，不适用于集群服务。</p><ul><li>修改配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>--live-restore</code>标志<br>不推荐</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockerd xxx --live-restore</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="在一个容器中运行多个服务"><a href="#在一个容器中运行多个服务" class="headerlink" title="在一个容器中运行多个服务"></a>在一个容器中运行多个服务</h3><p>Run multiple services in a container</p><p>容器的主要运行进程是Dockerfile末尾的<code>ENTRYPOINT</code>或<code>CMD</code>指令。通常建议你通过每个容器运行一项服务来分割关注区域。这些服务可能会分成多个进程(如Nginx的worker processe)。你可以使用用户定义的network和shared volumes来连接多个容器。</p><p>容器的主进程负责管理它启动的所有进程。在某些情况下，主进程设计不好，在容器退出时无法正常处理<strong>停止</strong>子进程。如果你的进程属于这个类别，你可在容器运行时使用<code>--init</code>选型。<code>--init</code>标志将一个微小的<code>inti-process</code>作为主进程插入到容器中，并在容器退出时处理所有进程的停止。以这种方式处理这些进程优于使用完整的初始化进程。</p><p><br></p><p>如果你需要在一个容器中运行多个服务，则可通过几种不同方式来完成此操作。</p><ul><li>将所有命令封装进一个脚本中，并附带测试和调试信息。以封装脚本作为你的CMD</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vim my_wrapper.sh</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">xxxxx</span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim Dockerfile</span><br><span class="line"></span><br><span class="line">FROM ubuntu:latest</span><br><span class="line">COPY my_first_process my_first_process</span><br><span class="line">COPY my_second_process my_second_process</span><br><span class="line">COPY my_wrapper_script.sh my_wrapper_script.sh</span><br><span class="line">CMD ./my_wrapper_script.sh</span><br></pre></td></tr></table></figure><ul><li>使用如<code>supervisord</code>这样的进程管理器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y supervisor</span><br><span class="line">RUN mkdir -p /var/log/supervisor</span><br><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br><span class="line">COPY my_first_process my_first_process</span><br><span class="line">COPY my_second_process my_second_process</span><br><span class="line">CMD [&quot;/usr/bin/supervisord&quot;]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="容器运行指标"><a href="#容器运行指标" class="headerlink" title="容器运行指标"></a>容器运行指标</h3><p>Container runtime metrics</p><p><strong>docker stats</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker stats redis1 redis2</span><br><span class="line"></span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O</span><br><span class="line">redis1              0.07%               796 KB / 64 MB        1.21%               788 B / 648 B       3.568 MB / 512 KB</span><br><span class="line">redis2              0.07%               2.746 MB / 64 MB      4.29%               1.266 KB / 648 B    12.4 MB / 0 B</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Control groups</strong></p><p>Linux Container依赖于<code>control group</code>，这些组不仅跟踪进程组，还公开有关CPU，mem，block I/O的使用情况和度量标准。你可以访问这些指标并判断容器运行状况。<br>control group通过为文件系统(pseudo-fs)公开，你应该可在<code>/proc/fs/cgroup</code>中找到它。</p><p>查看cgroup子系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">grep cgroup /proc/mounts</span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">mount -l | grep cgroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#进程</span><br><span class="line">/proc/&lt;pid&gt;/cgroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#/表示进程尚未分配给group</span><br><span class="line">cat /proc/1/cgroup</span><br><span class="line">11:devices:/</span><br><span class="line">10:cpuset:/</span><br><span class="line">9:hugetlb:/</span><br><span class="line">8:memory:/</span><br><span class="line">7:blkio:/</span><br><span class="line">6:net_prio,net_cls:/</span><br><span class="line">5:pids:/</span><br><span class="line">4:perf_event:/</span><br><span class="line">3:cpuacct,cpu:/</span><br><span class="line">2:freezer:/</span><br><span class="line">1:name=systemd:/</span><br></pre></td></tr></table></figure><p><br></p><p><strong>查找给定容器的cgroup</strong><br>对于每个容器，每个层次结构中创建一个cgroup。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/sys/fs/cgroup/memory/docker/&lt;docker-longid&gt;/</span><br><span class="line"></span><br><span class="line">cd /sys/fs/cgroup/memory/docker/893903129d869f384bd78d63a382f1c9527d6979be0a6cf3c13ea4f45a1554d6</span><br><span class="line">cat memory.stat</span><br><span class="line"></span><br><span class="line">cache 36282368</span><br><span class="line">rss 196608</span><br><span class="line">rss_huge 0</span><br><span class="line">mapped_file 1077248</span><br><span class="line">swap 0</span><br><span class="line">pgpgin 212904</span><br><span class="line">pgpgout 205531</span><br><span class="line">pgfault 314692</span><br><span class="line">pgmajfault 204</span><br><span class="line">inactive_anon 131072</span><br><span class="line">active_anon 65536</span><br><span class="line">inactive_file 18223104</span><br><span class="line">active_file 18059264</span><br><span class="line">unevictable 0</span><br><span class="line">hierarchical_memory_limit 9223372036854771712</span><br><span class="line">hierarchical_memsw_limit 9223372036854771712</span><br><span class="line">total_cache 36282368</span><br><span class="line">total_rss 196608</span><br><span class="line">total_rss_huge 0</span><br><span class="line">total_mapped_file 1077248</span><br><span class="line">total_swap 0</span><br><span class="line">total_pgpgin 212904</span><br><span class="line">total_pgpgout 205531</span><br><span class="line">total_pgfault 314692</span><br><span class="line">total_pgmajfault 204</span><br><span class="line">total_inactive_anon 131072</span><br><span class="line">total_active_anon 65536</span><br><span class="line">total_inactive_file 18223104</span><br><span class="line">total_active_file 18059264</span><br><span class="line">total_unevictable 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#其它信息类似</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="限制容器的资源"><a href="#限制容器的资源" class="headerlink" title="限制容器的资源"></a>限制容器的资源</h3><p>Limit a container’s resources</p><p>默认情况下，容器没有资源限制，可以使用主机内核调度程序允许给定的资源。Docker提供了一些方法来控制容器可以使用的CPU、memory、block I/O。</p><p>许多这些功能需要内核的支持。使用<code>docker info</code>命令检查是否支持。如果内核禁用了某功能，则可能会有如下警告: <strong>WARNING: No swap limit support</strong></p><p><br></p><h4 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h4><p><strong>你需要了解内存耗尽(out of memory)的风险</strong><br>不要让正在运行的容器消耗太多的主机内存，这很重要。在Linux主机上，如果内核检测到没有足够的内存来执行重要的系统功能，它会抛出一个<strong>OOME(out of memory exception)</strong>，并开始killing process以释放进程。任何进程都会是killing objects，包括Docker和其它重要应用程序。</p><p>docker尝试通过调整docker daemon的OOM优先级来降低这些风险，从而使其比系统上的其它进程更小(less)可能的被killing。容器的OOM优先级不进行调整，这使得单个容器被killing的可能性要大于docker或其它进程。你不应该给docker daemon的<code>--oom-score-adj</code>或container的<code>--oom-kill-disable</code>标志来绕过这些安全措施。</p><p>你可以通过以下方式减轻由OOM引起的系统不稳定的风险:</p><ul><li>在上线之前，进行测试以了解应用程序的内存需求</li><li>确保应用程序仅在拥有足够资源的主机上运行</li><li>限制容器可使用的内存量</li><li>在主机上配置swap时请注意。swap比内存更慢，性能更低，但可以提供缓冲区以防系统内存耗尽</li><li>考虑将容器转换为服务，并使用服务级别约束和节点标签来确保应用程序仅在具有足够内存的主机上运行</li></ul><p><br></p><p><strong>限制容器对内存的</strong><br>Limit a container’s access to memory</p><p>Docker可以强制<code>hard limit</code>，允许容器使用不超过给定数量的用户/系统内存，或<code>soft limit</code>。这允许容器使用尽可能多的内存。</p><p>如下这些选项具有这样一些效果，注意内存单位<code>b, k, m, g</code>：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-m/--memory=</code></td><td>容器可使用的最大内存量。如果你设置此选项，则允许的最小值为4m</td></tr><tr><td><code>--memory-swap</code></td><td>容器允许使用的swap量。只有在<code>--momery</code>设置时才有意义</td></tr><tr><td><code>--memory-swappiness</code></td><td>默认情况下，容器可使用的主机内核可交换的匿名页面的百分比<0-100></0-100></td></tr><tr><td><code>--memory-reservation</code></td><td>允许你指定一个小于<code>--memory</code>的soft limit。当docker检测到内存不足时，此会被激活</td></tr><tr><td><code>--kernel-memory</code></td><td>容器可以使用的最大kernel memory。内核内存不能够被swap out，因此内核内存不足的容器可能会阻塞主机资源，这会对主机和其它容器产生副作用</td></tr><tr><td><code>--oom-kill-disable</code></td><td>默认情况下，如果发生内存溢出(OOM)，内核会杀死容器中的进程。使用此选项改变此行为</td></tr></tbody></table><p><br></p><h4 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h4><p>默认情况下，每个容器对主机CPU周期的访问是无限制的。你可以设置各种约束来限制给定容器访问主机的CPU周期。</p><p><strong>CFS scheduler</strong><br>CFS是用于普通Linux进程的Linux kernel CPU调度器，一些运行时标志用于配置容器的CPU资源访问量。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>--cpu=&lt;value&gt;</code></td><td>指定容器可以使用的CPU资源，如<code>--cpu=&quot;1.6&quot;</code></td></tr><tr><td><code>--cpu-period=&lt;value&gt;</code></td><td>指定CFS调度器周期，它与<code>--cpu-quota</code>一起使用。默认100ms。Docker1.13以后，使用<code>--cpus</code>替代</td></tr><tr><td><code>--cpu-quota=&lt;value&gt;</code></td><td>在容器上条件CFS配额。在Docker1.13以后，使用<code>--cpus</code>替代</td></tr><tr><td><code>--cpuset-cpus</code></td><td>限制容器可以使用的特定CPU或CORE。如果有多个CPU，请使用逗号<code>,</code>分割。如<code>0,2</code></td></tr><tr><td><code>--cpu-shares</code></td><td>将此标志设置为大于/小于1024(默认值)的值，以增加或减少容器的重量，并使其能够访问更大或更小比例的主机CPU周期。这仅在CPU周期受到限制时才会执行。</td></tr></tbody></table><p>如果你只有1 CPU，如下命令可保证容器每秒最多有50%的CPU——<code>docker run -it --cpus=&quot;.5&quot; xxx</code></p><p><br></p><p><strong>realtime scheduler</strong></p><p>在Docker1.13及更高版本，对于无法使用CFS的任务，你可以使用realtime scheduler。<br>在你配置docker daemon和container之前，请正确地配置主机内核。</p><p><strong>注意： CPU调度和优先级是高级内核功能。大多数用户不需要修改它。错误地设置将导致主机系统不稳定或不可用。</strong></p><ul><li><p>配置主机内核<br>通过运行<code>zcat /proc/config.gz | grep CONFIG_RT_GROUP_SCHED</code>或检查<code>/sys/fs/cgroup/cpu.rt_runtime_us</code>来验证内核是否启用了<code>CONFIG_RT_GROUP_SCHED</code>。有关配置内核实时调度器的指导，请参考相关文档。</p></li><li><p>配置docker daemon<br>运行docker daemon时使用<code>--cpu-rt-runtime</code>标志设置每个运行时间段的实时任务保留的最大微秒数。可使用systemd的docker.service进行配置。</p></li><li><p>配置独立容器<br>当使用<code>docker run</code>启动容器时，可以传递多个标志来控制容器CPU的优先级。</p></li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>--cap-add=sys_nice</code></td><td>授予容器<code>CAP_SYS_NICE</code>功能，允许容器提升进程的nice值，设置实时调度策略，设置CPU关联和其它操作</td></tr><tr><td><code>--cpu-rt-runtime=&lt;value&gt;</code></td><td>Docker实时调度器期间，容器可以以实时优先级运行的最大微秒数。需要<code>--cap-add=sys_nice</code>标志</td></tr><tr><td><code>--ulimit rtprio=&lt;value&gt;</code></td><td>容器允许的最大实时优先级，需要<code>--cap-add=sys_nice</code>标志</td></tr></tbody></table><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --it --cpu-rt-runtime=950000 \</span><br><span class="line">                  --ulimit rtprio=99 \</span><br><span class="line">                  --cap-add=sys_nice \</span><br><span class="line">                  debian:jessie</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><h4 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h4><p>记录的信息和日志格式取决于容器的端点命令。<br><code>docker logs</code>命令显示正在运行的容器记录的信息。<br><code>docker service logs</code>命令显示参与服务的所有容器记录的信息。在swarm模式下。</p><p>在某些情况下，<code>docker logs</code>可能不会显示有用的信息，除非你采取其它措施。</p><ul><li>如果将日志发送到文件、主机、数据库或其它日志驱动程序，则<code>docker logs</code>可能不会显示有用的信息</li><li>如果你的镜像运行non-interactive进程(如数据库)，则该应用程序可能会将output发送到日志文件而不是stdout/stderr</li></ul><p><br></p><h4 id="配置日志驱动"><a href="#配置日志驱动" class="headerlink" title="配置日志驱动"></a>配置日志驱动</h4><p>Configure logging drivers</p><p>docker提供了多种日志记录机制(logging mechanisms)来帮助你从运行的容器和服务中获取信息。这些机制被称为日志驱动(logging driver)。<br>每个docker daemon都有一个默认日志驱动，每个容器也默认使用该驱动。除非你给容器配置了其它日志驱动。<br>除了使用docker附带日志驱动，在Docker v17.05之后，你还可以使用日志驱动插件(logging driver plugin)。</p><p><br></p><p><strong>配置默认日志驱动</strong><br>默认的日志驱动是<code>json-flie</code>。<br>可在<code>daemon.json</code>文件里通过<code>log-driver</code>选项匹配置日志驱动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">#设置为syslog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;syslog&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果日志驱动存在可配置选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;labels&quot;: &quot;production_status&quot;,</span><br><span class="line">    &quot;env&quot;: &quot;os,customer&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">docker info | grep &apos;Loggin Driver&apos;</span><br><span class="line">Logging Driver: json-file</span><br></pre></td></tr></table></figure><p><br></p><p><strong>为容器配置日志驱动</strong><br>启动容器时，可使用<code>--log-driver</code>标志为其配置不同于docker daemon的日志驱动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --log-driver none alpine ash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看容器日志驱动</span><br><span class="line">docker inspect -f &apos;&#123;&#123;.HostConfig.LogConfig.Type&#125;&#125;&apos; &lt;CONTAINER&gt;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置从容器到日志驱动的log message的交付模式</strong><br>Docker为从容器到日志驱动的日志消息提供了两种交付(delivery）模式：</p><ul><li><p>直接阻塞(blocking)从容器到驱动的交付(默认)</p></li><li><p>非阻塞交付(non-blocking)，将日志消息存储在中间每个容器的环形缓冲区中供驱动使用<br>非阻塞消息交付模式可防止应用程序因日志反压而被阻塞。当STDERR或STDOUT流阻塞时，应用程序可能会以意想不到的方式失败。</p></li></ul><p><strong>注意：当缓冲区已满且新消息排入队列时，内存中最早的消息将被丢弃。丢弃消息通常首选阻止应用程序的日志写入过程。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --log-opt mode=non-blocking --log-opt max-buffer-size=4m alpine ping 127.0.0.1</span><br></pre></td></tr></table></figure><p><br></p><p><strong>日志驱动使用环境变量或label</strong><br>一些日志驱动将容器的<code>--env/-e</code>或<code>--label</code>标签的值添加到容器的日志中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --label production_status=testing -e os=ubuntu alpine sh</span><br></pre></td></tr></table></figure><p><br></p><p><strong>支持的日志驱动</strong><br>如下是受支持的日志驱动。</p><table><thead><tr><th>驱动</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>No logs are available for the container and docker logs does not return any output.</td></tr><tr><td>json-file</td><td>The logs are formatted as JSON. The default logging driver for Docker.</td></tr><tr><td>syslog</td><td>Writes logging messages to the syslog facility. The syslog daemon must be running on the host machine.</td></tr><tr><td>journald</td><td>Writes log messages to journald. The journald daemon must be running on the host machine.</td></tr><tr><td>gelf</td><td>Writes log messages to a Graylog Extended Log Format (GELF) endpoint such as Graylog or Logstash.</td></tr><tr><td>fluentd</td><td>Writes log messages to fluentd (forward input). The fluentd daemon must be running on the host machine.</td></tr><tr><td>splunk</td><td>Writes log messages to splunk using the HTTP Event Collector.</td></tr><tr><td>logentries</td><td>Writes log messages to Rapid7 Logentries.</td></tr><tr><td>云日志系统</td><td>各类云服务商提供的云日志系统</td></tr></tbody></table><p><code>docker logs</code>命令不适用于除<code>json-file</code>和<code>journald</code>之外的其它日志驱动。</p><p><br></p><h4 id="日志驱动插件"><a href="#日志驱动插件" class="headerlink" title="日志驱动插件"></a>日志驱动插件</h4><p>日志驱动插件允许你扩展和定制docker的日志记录功能，超越了内置的日志驱动的功能。</p><ul><li>安装日志驱动插件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker plugin install &lt;org/image&gt;</span><br><span class="line"></span><br><span class="line">docker plugin ls</span><br></pre></td></tr></table></figure><ul><li>将插件配置为docker daemon默认日志驱动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.josn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">--loggin-driver</span><br></pre></td></tr></table></figure><ul><li>将插件配置为容器日志驱动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run xxx --log-driver</span><br></pre></td></tr></table></figure><p><br></p><h4 id="定制日志驱动输出"><a href="#定制日志驱动输出" class="headerlink" title="定制日志驱动输出"></a>定制日志驱动输出</h4><p>Customize log driver output</p><p>日志选项<code>tag</code>指定如何格式化表示容器日志消息。默认情况下，系统使用容器ID的前12个字符。你可以指定<code>tag</code>选项来覆盖此行为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">log</span>-driver=fluentd \</span><br><span class="line">  --<span class="built_in">log</span>-opt fluentd-address=myhost.local:24224 \</span><br><span class="line">  --<span class="built_in">log</span>-opt tag=<span class="string">"mailer"</span></span><br></pre></td></tr></table></figure><p>在指定<code>tag</code>时，Docker支持的一些特殊模板标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;.ID&#125;&#125;</span><br><span class="line">The first 12 characters of the container ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.FullID&#125;&#125;</span><br><span class="line">The full container ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.Name&#125;&#125;</span><br><span class="line">The container name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.ImageID&#125;&#125;</span><br><span class="line">The first 12 characters of the container’s image ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.ImageFullID&#125;&#125;</span><br><span class="line">The container’s full image ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.ImageName&#125;&#125;</span><br><span class="line">The name of the image used by the container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.DaemonName&#125;&#125;</span><br><span class="line">The name of the docker program (docker)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--log-opt tag=&quot;&#123;&#123;.ImageName&#125;&#125;/&#123;&#123;.Name&#125;&#125;/&#123;&#123;.ID&#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line">Aug  7 18:33:19 HOSTNAME hello-world/foobar/5790672ab6a0[9103]: Hello from Docker.</span><br></pre></td></tr></table></figure><p><br></p><h4 id="日志驱动"><a href="#日志驱动" class="headerlink" title="日志驱动"></a>日志驱动</h4><p>介绍如下日志驱动！</p><h5 id="Logentries"><a href="#Logentries" class="headerlink" title="Logentries"></a>Logentries</h5><p>Logentries日志驱动将容器日志发送到Logentries server。</p><p><code>--log-opt</code>:</p><ul><li><code>logentries-token</code>: 指定Logentries log设置的token</li><li><code>line-only</code>: 仅发送原始有效载荷</li></ul><p>docker daemon:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dockerd --log-driver=logentries</span><br><span class="line"></span><br><span class="line">#可在docker.service中设置</span><br></pre></td></tr></table></figure><p>docker container:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --log-driver=logentries ...</span><br></pre></td></tr></table></figure><p>在使用此日志驱动之前，你需要在Logentries web界面中创建一个新的日志集，并将该日志集的令牌传递给docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --log-driver=logentries --log-opt logentries-token=abcd1234-12ab-34cd-5678-0123456789ab</span><br></pre></td></tr></table></figure><p><br></p><h5 id="json-file"><a href="#json-file" class="headerlink" title="json file"></a>json file</h5><p>默认情况下，docker捕获所有容器的STDOUT和STDERR，并使用json格式将它们写入文件。每个文件包含仅包含一个容器的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;10m&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">docker run \</span><br><span class="line">      --log-driver json-file --log-opt max-size=10m \</span><br><span class="line">      alpine echo hello world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子</span><br><span class="line">docker run -it --log-opt max-size=10m --log-opt max-file=3 alpine ash</span><br></pre></td></tr></table></figure><p>json-file支持的日志选项：</p><table><thead><tr><th>选项</th><th>描述</th><th>栗子</th></tr></thead><tbody><tr><td>max-size</td><td>The maximum size of the log before it is rolled. A positive integer plus a modifier representing the unit of measure (k, m, or g). Defaults to -1 (unlimited).</td><td>–log-opt max-size=10m</td></tr><tr><td>max-file</td><td>The maximum number of log files that can be present. If rolling the logs creates excess files, the oldest file is removed. Only effective when max-size is also set. A positive integer. Defaults to 1.</td><td>–log-opt max-file=3</td></tr><tr><td>labels</td><td>Applies when starting the Docker daemon. A comma-separated list of logging-related labels this daemon accepts. Used for advanced log tag options.</td><td>–log-opt labels=production_status,geo</td></tr><tr><td>env</td><td>Applies when starting the Docker daemon. A comma-separated list of logging-related environment variables this daemon accepts. Used for advanced log tag options.</td><td>–log-opt env=os,customer</td></tr><tr><td>env-regex</td><td>Similar to and compatible with env. A regular expression to match logging-related environment variables. Used for advanced log tag options.</td><td>–log-opt env-regex=^(os或customer).</td></tr></tbody></table><p><br></p><h5 id="Graylog-Extended-Format-gelf"><a href="#Graylog-Extended-Format-gelf" class="headerlink" title="Graylog Extended Format(gelf)"></a>Graylog Extended Format(gelf)</h5><p><code>gelf</code>日志驱动是一种方便的格式，可被Graylog, Logstash, Fluentd等工具所理解。许多工具使用这种格式。</p><p>在GELF中，每条日志消息都是带有一下字段的字典：</p><ul><li>version</li><li>host</li><li>timestamp</li><li>short and long version of the message</li><li>自定义的字段</li></ul><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;gelf&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;gelf-address&quot;: &quot;udp://1.2.3.4:12201&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">dockerd --log-driver gelf –-log-opt gelf-address=udp://1.2.3.4:12201</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#容器</span><br><span class="line">docker run \</span><br><span class="line">      --log-driver gelf –-log-opt gelf-address=udp://1.2.3.4:12201 \</span><br><span class="line">      alpine echo hello world</span><br></pre></td></tr></table></figure><p><br></p><p>GELF选项：</p><table><thead><tr><th>Option</th><th>Required</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td><code>gelf-address</code></td><td>required</td><td>GELF服务器地址(tcp/udp)</td><td><code>--log-opt gelf-address=udp://192.168.0.42:12201</code></td></tr><tr><td><code>gelf-compression-type</code></td><td>optional</td><td>仅限于UDP。类型有gzip(default),zlib,none</td><td><code>--log-opt gelf-compression-type=gzip</code></td></tr><tr><td><code>gelf-compression-level</code></td><td>optional</td><td><code>-1/0 - 9</code>,<code>-1/0</code>(禁用压缩)，1(BestSpeed)，9(BestCompress)</td><td><code>--log-opt gelf-compression-level=2</code></td></tr><tr><td><code>gelf-tcp-max-reconnect</code></td><td>optional</td><td>仅TCP，连接断开尝试的最大重连次数，默认3</td><td><code>--log-opt gelf-tcp-max-reconnect=3</code></td></tr><tr><td><code>gelf-tcp-reconnect-delay</code></td><td>optinal</td><td>仅TCP，重连等待的秒数，默认1s</td><td><code>--log-opt gelf-tcp-reconnect-delay=1</code></td></tr><tr><td><code>tag</code></td><td>optional</td><td>默认使用Docker容器ID的前12位</td><td><code>--log-opt tag=mailer</code></td></tr><tr><td><code>labels</code></td><td>optional</td><td>以逗号分隔的日志相关标签</td><td><code>--log-opt labels=production_status,geo</code></td></tr><tr><td><code>env</code></td><td>optional</td><td>以逗号分隔的日志相关的环境变量</td><td><code>--log-opt env=os,customer</code></td></tr><tr><td><code>evn-regex</code></td><td>optional</td><td>匹配日志相关环境变量的正则表达式</td><td><code>--log-opt env-regex=^(os l customer)</code></td></tr></tbody></table><p><br></p><h5 id="Syslog"><a href="#Syslog" class="headerlink" title="Syslog"></a>Syslog</h5><p>syslog日志驱动将日志路由到系统日志服务器。系统日志必须以特定方式格式化才能生效。从有效的消息中，接收者可以提取以下消息：</p><ul><li><p>priority<br>日志级别，debug, info, warning, error…</p></li><li><p>timestamp</p></li><li>hostname</li><li><p>facility<br>记录消息的子系统</p></li><li><p>process name</p></li><li>pid</li></ul><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;syslog&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;syslog-address&quot;: &quot;udp://1.2.3.4:1111&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">#syslog-address支持tcp和udp</span><br><span class="line">docker run \</span><br><span class="line">      -–log-driver syslog –-log-opt syslog-address=udp://1.2.3.4:1111 \</span><br><span class="line">      alpine echo hello world</span><br></pre></td></tr></table></figure><p><br></p><p>syslog日志驱动选项：</p><table><thead><tr><th>选项</th><th>描述</th><th>栗子</th></tr></thead><tbody><tr><td><code>syslog-address</code></td><td><code>[tcp l udp l tcp+tls]:host:port</code>, <code>unixgram://path</code>, <code>unix://path</code></td><td><code>--log-opt syslog-address=tcp+tls://192.168.1.3:514</code>, <code>--log-opt syslog-address=unix:///tmp/syslog.sock</code></td></tr><tr><td><code>syslog-facility</code></td><td>子系统</td><td><code>--log-opt syslog-facility=daemon</code></td></tr><tr><td><code>syslog-tls-ca-cert</code></td><td>CA</td><td><code>--log-opt syslog-tls-ca-cert=/etc/ca-certificates/custom/ca.pem</code></td></tr><tr><td><code>syslog-tls-cert</code></td><td>TLS certificate</td><td><code>--log-opt syslog-tls-key=/etc/ca-certificates/custom/key.pem</code></td></tr><tr><td><code>syslog-tls-skip-verify</code></td><td>跳过tls验证</td><td><code>--log-opt syslog-tls-skip-verify=true</code></td></tr><tr><td><code>tag</code></td><td>如前</td><td>如前</td></tr><tr><td><code>syslog-format</code></td><td>日志格式</td><td><code>--log-opt syslog-format=rfc5424micro</code></td></tr><tr><td><code>lables</code></td><td>如前</td><td>如前</td></tr><tr><td><code>env</code></td><td>如前</td><td>如前</td></tr><tr><td><code>env-regex</code></td><td>如前</td><td>如前</td></tr></tbody></table><p><br></p><h5 id="ETW"><a href="#ETW" class="headerlink" title="ETW"></a>ETW</h5><p>ETW日志驱动将容器日志转发为ETW事件。每个ETW时间都包含一条日志及其上下文信息的消息，然后客户端可以创建一个ETW监听器来监听这些事件。</p><p><br></p><h5 id="Fluentd"><a href="#Fluentd" class="headerlink" title="Fluentd"></a>Fluentd</h5><p>fluentd日志驱动将容器日志作为结构化日志数据发送到fluentd收集器。接着，用户便可以使用任意一种Fluentd output plugin将这些日志写入不同的目的地。</p><p>fluentd发送一下这些元数据：</p><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td><code>container_id</code></td><td>完整的64位容器ID</td></tr><tr><td><code>container_ame</code></td><td>启动时的容器名</td></tr><tr><td>source</td><td>stdout or stderr</td></tr><tr><td>log</td><td>容器日志</td></tr></tbody></table><p><code>docker logs</code>命令不可用于此日志驱动。</p><p><br></p><ul><li><p><code>fluentd-address</code><br>指定fluentd daemon地址</p></li><li><p>tag</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   &quot;log-driver&quot;: &quot;fluentd&quot;,</span><br><span class="line">   &quot;log-opts&quot;: &#123;</span><br><span class="line">     &quot;fluentd-address&quot;: &quot;fluentdhost:24224&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">docker run --log-driver=fluentd --log-opt fluentd-address=fluentdhost:24224</span><br><span class="line">docker run --log-driver=fluentd --log-opt fluentd-address=tcp://fluentdhost:24224</span><br><span class="line">docker run --log-driver=fluentd --log-opt fluentd-address=unix:///path/to/fluentd.sock</span><br></pre></td></tr></table></figure><p><br></p><h5 id="Journald"><a href="#Journald" class="headerlink" title="Journald"></a>Journald</h5><p>journald 日志驱动将容器日志发送给 systemd journal。可以通过<code>journalctl</code>命令，<code>journal</code> API，<code>docker logs</code>来检索日志条目。</p><p>journald日志驱动还提供如下元数据：</p><ul><li><code>CONTAINER_ID</code></li><li><code>CONTAINER_ID_FULL</code></li><li><code>CONTAINER_NAME</code></li><li><code>CONTAINER_TAG</code></li><li><code>CONTAINER_PARTIAL_MESSAGE</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;journald&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">docker run --log-driver=journald ...</span><br></pre></td></tr></table></figure><p><br></p><p>几个选项：</p><ul><li>tag</li><li>label</li><li>env</li><li>env-regex</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --log-driver=journald \</span><br><span class="line">    --log-opt labels=location \</span><br><span class="line">    --log-opt env=TEST \</span><br><span class="line">    --env &quot;TEST=false&quot; \</span><br><span class="line">    --label location=west \</span><br><span class="line">    your/application</span><br></pre></td></tr></table></figure><p><br></p><p>使用<code>journalctl</code>命令查看日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">journalctl CONTAINER_NAME=webserver</span><br><span class="line">journalctl -o json CONTAINER_NAME=webserver</span><br></pre></td></tr></table></figure><p>使用journal API：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> systemd.journal</span><br><span class="line"></span><br><span class="line">reader = systemd.journal.Reader()</span><br><span class="line">reader.add_match(<span class="string">'CONTAINER_NAME=web'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> reader:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'&#123;CONTAINER_ID_FULL&#125;: &#123;MESSAGE&#125;'</span>.format(**msg)</span><br></pre></td></tr></table></figure><p><br></p><h5 id="Splunk"><a href="#Splunk" class="headerlink" title="Splunk"></a>Splunk</h5><p>splunk日志驱动将容器日志发送到Splunk Enterprise和Splunk Clound的HTTP Event Collector。</p><p><br><br><br></p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker文档:  &lt;a href=&quot;https://docs.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/sD7O95O/article/details/78623697&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/sD7O95O/article/details/78623697&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/22969309/answer/34030581&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/22969309/answer/34030581&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7x86_64&lt;/li&gt;
&lt;li&gt;Docker v18.03&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Docker" scheme="https://zhang21.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>《网站运维》读书笔记</title>
    <link href="https://zhang21.github.io/2018/03/05/%E7%BD%91%E7%AB%99%E8%BF%90%E7%BB%B4/"/>
    <id>https://zhang21.github.io/2018/03/05/网站运维/</id>
    <published>2018-03-05T14:34:49.000Z</published>
    <updated>2018-03-25T03:53:52.761Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>《网站运维：保持数据实时的秘籍》(Web Operations: Keeping the Data on Time)</li></ul><p><br><br><br></p><a id="more"></a><p><br></p><h1 id="作为职业的运维"><a href="#作为职业的运维" class="headerlink" title="作为职业的运维"></a>作为职业的运维</h1><p>互联网变化如此之快，以至于几乎没有时间认真思考一下我们在做什么，以及为什么做。我们奋力拼搏，才避免被淘汰出局，哪里还敢谈论什么引领潮流呢！这种高压、过度刺激的环境使得所有努力都只是为了一份工作，而没有职业的概念了。</p><p>职业是指占去你人生大部分时光的事业，并能够逐步晋升。工作只是拿钱干活儿，换句话说，工作就只是工作而已。</p><p><br></p><h2 id="为什么运维如此艰难"><a href="#为什么运维如此艰难" class="headerlink" title="为什么运维如此艰难"></a>为什么运维如此艰难</h2><p>运维对如下领域都有深入的理解：<strong>网络、路由、交换、防火墙、负载均衡、高可用性、灾难恢复、TCP与UDP服务、网络运维中心管理、硬件规范、各种Unix、各种Web服务器技术、高速缓存技术、数据库技术、存储基础架构、密码学、算法、趋势分析、容量规划…</strong></p><p>运维要求广博，可以说几乎是不可接受的。</p><p>运维领域成为一个合格的人选，需要具备三点素质：<strong>扎实的计算背景、娴熟的决断力、沉稳的性格</strong>。</p><p><br></p><h3 id="扎实的计算背景"><a href="#扎实的计算背景" class="headerlink" title="扎实的计算背景"></a>扎实的计算背景</h3><p>运维要求理解架构中的各个组成部分，在理解计算系统的来龙去脉时，扎实的计算背景对你会有莫大的帮助。具有扎实的基础，对于理解为什么及如何架构解决方案，以及识别出问题所在，是非常重要的。毕竟，计算是架构我们的智能系统的基础。此外，工程师的思维方式和对物理定律的基本理解，也是一个很大的优势。</p><p>运维会经常遇到随意的、不切实际的期望。<br>运维，就是理解理论和实践在哪里发生冲突，并发明适当的方法，以便在发生事故时减少损失。</p><p><br></p><h3 id="娴熟的决断力"><a href="#娴熟的决断力" class="headerlink" title="娴熟的决断力"></a>娴熟的决断力</h3><p>虽然优柔寡断在任何领域都不算是一个优点，但在运维中却几乎不能容忍。</p><p><br></p><h3 id="沉稳的性格"><a href="#沉稳的性格" class="headerlink" title="沉稳的性格"></a>沉稳的性格</h3><p>一个沉稳与可控的思维过程是非常关键的，需要保持自己是清醒的一方。</p><p>在运维领域，目标很简单，使所有事情在所有时间正常运转。一个简单的定义，但却是一个不可能的期望。或许在这个领域成为一名工程师的更大挑战是组织内的同事对你的不切实际的期望。</p><p><br><br><br></p><h2 id="从学徒到师傅"><a href="#从学徒到师傅" class="headerlink" title="从学徒到师傅"></a>从学徒到师傅</h2><p>掌握任何知识领域都需要四项基本要求：<strong>知识、工具、经验和纪律</strong>。</p><p><br></p><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p>互联网行业的一个独特之处就是几乎所有的东西都是公开的，事实上，有专有权的东西也是极少的，而更为独特的是，几乎所有规范文档都是免费的。</p><p>在你走在从从学徒到师傅的路途中，尽可能多滴占有信息是你的职责，这样你的大脑才能将那些细微之处进行排序、过滤、关联，使其成为一幅简明、精确的图画，从而有助于你的决策——不管是长期的架构设计的关键决策，还是临时的排除故障的决策。</p><p><br></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>虽然工具各有优缺点，然而人们使用这些工具都取得了成功。制造和使用工具使我们人类的本性。<br>所有的工具归根结底都只是人类肢体和感觉器官的延长。</p><p>师傅不适用工具炼成的。在互联网应用的环境中，你会看得更清楚，五花八门的语言、平台、技术都能够成功地结合在一起，将这些成功地构建为一个架构的，不是Java或PHP，而是设计与实现它的工程师——那些师傅们。</p><p>工具上的一个真理是，不管在用的工具是什么，要了解你的工具，这是在这个行业登堂入室的前提。灵巧地运用工具的能力，比工具本身的质量要重要的多。话虽如此，有经验的工程师还是应该手边备一件合适的高质量的工具。</p><p><br></p><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><p>从最本质的意义上来说，经验意味着良好的判断力，而良好的判断力却是从很多失败中取得的。</p><p>经验与知识是紧密相关的，知识可以认为是他人经验的总结。<br>经验既是一个名词，也是一个动词。获得经验与应用经验，同样容易也同样困难。</p><p>一名资深工程师最大的特点是其一致与可靠的良好判断力。很显然，这要在需要做出判断的场合经受锻炼。</p><p>对进入运维这个领域而没有什么经验的工程师，我的忠告是：<strong>耐心</strong>。</p><p><br></p><h3 id="纪律"><a href="#纪律" class="headerlink" title="纪律"></a>纪律</h3><p>通过尽可能正确而高效地做事，从而为解决同样问题，而尽可能地少做工作。</p><p><br><br><br></p><hr><p><br></p><h1 id="如何应用云计算-Elastic-Compute"><a href="#如何应用云计算-Elastic-Compute" class="headerlink" title="如何应用云计算(Elastic Compute)"></a>如何应用云计算(Elastic Compute)</h1><p>云服务器(ECS, Elastic Compute Service)</p><p><br></p><h2 id="什么地方适合云计算"><a href="#什么地方适合云计算" class="headerlink" title="什么地方适合云计算"></a>什么地方适合云计算</h2><p>灵活性和一定程度上的自由是云服务器的特点，当然，本地服务器同样有这个特点。</p><p><br></p><h3 id="混合计算"><a href="#混合计算" class="headerlink" title="混合计算"></a>混合计算</h3><p>混合计算=云计算+本地计算</p><p><br></p><h2 id="什么地方不适合云计算"><a href="#什么地方不适合云计算" class="headerlink" title="什么地方不适合云计算"></a>什么地方不适合云计算</h2><p>当然，最先考虑的肯定是经济层面。</p><p>服务层与数据库是紧密耦合的，所以使它们之间的网络延迟最小化是很重要的。这意味着它们要么全在云里，要么全在云外。</p><p><br></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>尽管有大量广告吹嘘完整托管在云里，但从运维角度来说，混合应用架构模式或许是最有趣的。有些事情在云里做的不一定好。脚踏两只船，你才会游刃有余。</p><p>混合应用还强调一点，就是传统运维中的最佳时间仍然是成功的公司的云应用所必须的。</p><p><br><br><br></p><hr><p><br></p><h1 id="基础架构与应用程序测量"><a href="#基础架构与应用程序测量" class="headerlink" title="基础架构与应用程序测量"></a>基础架构与应用程序测量</h1><p>任何规模的运维，采集测量数据就像将服务器连接到网络上一样重要，对于一个规模不断增长的基础架构来说，或许更加重要。</p><p>我们不光讨论你要采集并监视的测量数据的种类，还要讨论为了应对各种情况，你能利用这些数据做些什么。</p><p>测量数据的采集和带有报警(alerting)功能的监控有明显的区别。</p><p><br><br><br></p><h2 id="时间刷新率和存留时间的考虑"><a href="#时间刷新率和存留时间的考虑" class="headerlink" title="时间刷新率和存留时间的考虑"></a>时间刷新率和存留时间的考虑</h2><p>随着采集的数据不断增长，确保这些数据能够一直可查询和移动，这是很明智的。</p><p>如Zabbix中——获取数据的时间刷新率和数据保存时间。历史数据保留时长和趋势数据存储时间。<br>比如有的数据要30s获取一次，而有的信息只需要1h获取一次。</p><p>测量数据真正出彩的地方：</p><ul><li>对于某个特定的资源，每天的峰值是哪些？每周的峰值日是哪些？每年的峰值月是哪些？</li><li>有季节性模式吗？<ul><li>如夏时日和节假日会高一些</li></ul></li><li>最大(波峰)值与最小(波谷)值比较起来怎么样？</li><li>在用户分布广泛的情况下，波峰与波谷是否发生变化？</li></ul><p><br><br><br></p><h2 id="测量数据采集与存储的地点"><a href="#测量数据采集与存储的地点" class="headerlink" title="测量数据采集与存储的地点"></a>测量数据采集与存储的地点</h2><p>无论使用什么采集工具，易于采集和便于得出结果都是必须要考虑的。</p><p><br><br><br></p><h2 id="测量数据的层次"><a href="#测量数据的层次" class="headerlink" title="测量数据的层次"></a>测量数据的层次</h2><p>不同层次的数据存储在不同的数据库中。</p><p><br></p><h3 id="高层业务或功能特定的测量数据"><a href="#高层业务或功能特定的测量数据" class="headerlink" title="高层业务或功能特定的测量数据"></a>高层业务或功能特定的测量数据</h3><p>有了这些高层数据之后，面向产品的那些人对这些数据也抱有极大的兴趣，你一点都不用感到惊讶。</p><p>对于应用层面的数据，最有用的是能够跟踪用户的交互情况。</p><p><br></p><h3 id="系统及服务层面的测量数据"><a href="#系统及服务层面的测量数据" class="headerlink" title="系统及服务层面的测量数据"></a>系统及服务层面的测量数据</h3><p>这些是在运维工程师电脑上以图形方式显示的数据。</p><p><br></p><p>测量数据的层次：</p><table><thead><tr><th>-</th><th>例子</th><th>测量项目</th></tr></thead><tbody><tr><td>应用层</td><td>网页或API</td><td>故障：类型、延迟、发生率…</td></tr><tr><td>服务层</td><td>Nginx, MySQL, MongoDB…</td><td>Nginx: 请求频率、响应时间、忙碌的工作进程… <br> MySQL/MongoDB：导致故障的查询类型、慢查询、连接数…</td></tr><tr><td>物理层</td><td>CPU、内存、网络、硬盘</td><td>内存：繁忙程度 <br> 内存：空闲内存 <br> 硬盘：可用空间，I/O速率 <br> 网络：网络I/O带宽情况</td></tr></tbody></table><p>有了这些数据，就能够回答如下问题：</p><ul><li>平均的Web请求时间</li><li>CPU时间</li><li>调用最多的数据库查询</li><li>数据库慢查询</li><li>文件系统缓存</li><li>最大的页面响应</li><li>…</li></ul><p><br><br><br></p><h2 id="为异常检测和报警提供环境"><a href="#为异常检测和报警提供环境" class="headerlink" title="为异常检测和报警提供环境"></a>为异常检测和报警提供环境</h2><p>在本地采集的测量数据的主要理由，就像油表一样，有了这些数据，就可以明白基础架构正在发生什么，以及正在驶向何方。<br>知道哪里的资源在增长或缩减，能够进行预测。使用预测对基础架构的容量需求进行预报，称为容量规划。<br>观察网站运行是否有异常时，测量数据就派上用场了。</p><p>发生异常是，测量数据回味报警提供相关信息。报警的信息要尽量简明，告知检测到了什么，以及何时检测到。而测量数据会告诉你报警都发生了什么。</p><p><br><br><br></p><h2 id="日志记录也是测量数据"><a href="#日志记录也是测量数据" class="headerlink" title="日志记录也是测量数据"></a>日志记录也是测量数据</h2><p>应用程序的日志文件也提供了测量数据和使用情况的信息。这些信息用于追踪过去发生的事件。</p><p><br><br><br></p><h2 id="将变化管理和事件的时间线建立关联"><a href="#将变化管理和事件的时间线建立关联" class="headerlink" title="将变化管理和事件的时间线建立关联"></a>将变化管理和事件的时间线建立关联</h2><p>更新生产系统会带来风险。<br>记录更新发生的时间，从而保留更新的踪迹，这在发生问题需要进行追踪时是非常有价值的。</p><p><br><br><br></p><h2 id="给测量数据加入报警机制"><a href="#给测量数据加入报警机制" class="headerlink" title="给测量数据加入报警机制"></a>给测量数据加入报警机制</h2><p>Zabbix、Nagios等就是一个测量数据采集系统配合使用的监控/报警工具。</p><p><br><br><br></p><h2 id="使用测量数据建立加载-反馈机制"><a href="#使用测量数据建立加载-反馈机制" class="headerlink" title="使用测量数据建立加载-反馈机制"></a>使用测量数据建立加载-反馈机制</h2><p>采集时序数据的另一个好处，就是能够通过编程使你的应用生成测量数据，从而可以建立安全、精密的反馈循环。</p><p><br><br><br></p><h2 id="结语-1"><a href="#结语-1" class="headerlink" title="结语"></a>结语</h2><p>测量数据的采集、存储、显示，可以认为是web基础架构的关键部分。不论是及时排查错误，预测容量、规划产品的发布，还是建立应用的反馈机制，如果没有正确的测量数据为你提供一个基础架构运行的全景图的话，你会损失惨重。</p><p>设计数据如何经过系统时，要考虑安全问题，而且数据要易于导出到其它应用。一旦运维部门采集了测量数据，你会发现，追踪数据是一件多么有趣的事情，同时也能使工作更加轻松。</p><p><br><br><br></p><hr><p><br></p><h1 id="连续部署"><a href="#连续部署" class="headerlink" title="连续部署"></a>连续部署</h1><p>软件应该以小批量的方式进行设计、编写和部署。</p><p>批量大小是产品在开发过程的各个阶段转移的单位。对于软件而言，最容易看到的批量是代码。每次工程师检入代码，都是在提交一定量的工作。有很多技术用来控制这些批量，从连续部署所需的最小批量到更为传统的分支开发，在分支开发中，多个开发者工作数周或数月产生的所有代码将被成批处理，并集中到一起。</p><p>结果证明，以远小于传统做法的建议的批量工作，有极大的好处。</p><p><br><br><br></p><h2 id="小批量意味着更快的反馈"><a href="#小批量意味着更快的反馈" class="headerlink" title="小批量意味着更快的反馈"></a>小批量意味着更快的反馈</h2><p>工作转移到下一阶段越快，则也就能越快地发现下一个阶段是如何接纳你的工作的。</p><p><br><br><br></p><h2 id="小批量意味着问题即刻被本地化"><a href="#小批量意味着问题即刻被本地化" class="headerlink" title="小批量意味着问题即刻被本地化"></a>小批量意味着问题即刻被本地化</h2><p>问题发现得越快，则解决的也越快。</p><p>每次部署，都只有少量代码有变化，所以导致回归或料想不到的性能问题的任何变化，都能够快速识别出来，并进行改正。当然，由于需要改正或回滚的变化数量不仅是确定的，也是很小的，所以解决问题的平均时间也就很低了。</p><p><br><br><br></p><h2 id="小批量能够减少风险"><a href="#小批量能够减少风险" class="headerlink" title="小批量能够减少风险"></a>小批量能够减少风险</h2><p><br><br><br></p><h2 id="小批量可以降低总开销"><a href="#小批量可以降低总开销" class="headerlink" title="小批量可以降低总开销"></a>小批量可以降低总开销</h2><p>大多数机构都会降低自己的批量大小，以降低总的开销。<br>大批量导致的瓶颈经常是隐含的，是这些隐含的瓶颈显现出来，是需要开销的，甚至要投入更多的工作才能修正这些瓶颈。</p><p>连续部署的目标，是在减小批量的同时，帮助开发团队清除开发过程中的垃圾，加快工作步伐。这样就能使各个团队处于持续的流动状态，这种状态使得团队的创新、试验变得非常容易，从而形成可持续发展的良性循环。</p><p><br><br><br></p><h2 id="质量卫士的挽歌"><a href="#质量卫士的挽歌" class="headerlink" title="质量卫士的挽歌"></a>质量卫士的挽歌</h2><p>产生开发过程中的垃圾的一个很大原因是重复检查。</p><p>连续集成，有助于加快缺陷反馈流程；故事卡和看板，用于降低批量大小；日站，有助于加快步伐；连续部署也是这样的技术，有能力是开发团队更有活力。</p><p><br></p><h3 id="为什么连续部署能行"><a href="#为什么连续部署能行" class="headerlink" title="为什么连续部署能行"></a>为什么连续部署能行</h3><p>连续部署区分了发布的两种不同的定义：</p><ul><li>一个是工程师使用的，指的是将代码完全集成到生产环境中的过程；</li><li>另一个是市场部门使用的，指的是客户看到的东西</li></ul><p>使用连续部署，代码一旦写完，就在去往生产环境的路上了。<br>连续部署也起着速度调节器的作用。</p><p>这种速度调节，对于习惯于通过个体效率来度量其进步的团队来说，是一种技巧性的调整。在这种团队中，每个工程师的头等大事就是保持忙碌。不幸的是，这种观点忽略了团队的整体生产能力。对于有些情形，大家坐下来讨论，找出协调方法，从而不需要做重复工作，这时候才是有效率的。</p><p><br><br><br></p><h2 id="让我们开始吧"><a href="#让我们开始吧" class="headerlink" title="让我们开始吧"></a>让我们开始吧</h2><h3 id="步骤1：连续集成服务器"><a href="#步骤1：连续集成服务器" class="headerlink" title="步骤1：连续集成服务器"></a>步骤1：连续集成服务器</h3><p>这是连续部署的脊梁。我们需要一个中心服务器，运行所有的自动化测试，并监控每一次的提交。</p><p><br></p><h3 id="步骤2：源代码控制提交检查"><a href="#步骤2：源代码控制提交检查" class="headerlink" title="步骤2：源代码控制提交检查"></a>步骤2：源代码控制提交检查</h3><p>下一个需要的基础框架是源代码控制服务器，并带有能进行提交检查的甲苯。如CVS、SVN、Git等。</p><p>作为一个团队，我们的目标是在能够可靠地生产高质量代码的前提下，尽可能快地工作，但不要过快。</p><p><br></p><h3 id="步骤3：简单的部署脚本"><a href="#步骤3：简单的部署脚本" class="headerlink" title="步骤3：简单的部署脚本"></a>步骤3：简单的部署脚本</h3><p>建立一个关键的部署脚本，用于逐台机器进行增量备份，与此同时，监控集群和业务的运行情况。这样一旦出现异常，就可以快速恢复。</p><p><br></p><h3 id="步骤4：实时报警"><a href="#步骤4：实时报警" class="headerlink" title="步骤4：实时报警"></a>步骤4：实时报警</h3><p>无论部署过程多么完美，缺陷仍然会通过部署而进入生产环境。需要一个监控平台，以便事情一旦偏离正常，能够进行提醒，并找到人来调试。</p><p><br></p><h3 id="步骤5：根本原因分析"><a href="#步骤5：根本原因分析" class="headerlink" title="步骤5：根本原因分析"></a>步骤5：根本原因分析</h3><p>无论问题多小，都要做些投资，而且各个级别都要做。<br>小的改进，经过经年累月，非常像复利。</p><p><br><br><br></p><h2 id="连续部署用于关键应用"><a href="#连续部署用于关键应用" class="headerlink" title="连续部署用于关键应用"></a>连续部署用于关键应用</h2><p>连续部署要求的第一个心态转移是：如果一个更新假设是无副作用的，马上发布。不要再等着与其它相关的更新捆绑在一起，否则，一旦发生副作用，就很难确定到底是哪个更新产生的。</p><p>第二个是心态转移是把市场发布的概念和工程发布的概念区分开。</p><p><br></p><ul><li>更快更好的反馈</li><li>更多的自动化</li><li>对真实环境测量数据的监控</li><li>更好地处理间歇性错误</li><li>更小的批量</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="作为代码的基础架构"><a href="#作为代码的基础架构" class="headerlink" title="作为代码的基础架构"></a>作为代码的基础架构</h1><p><strong>只需要源代码库、应用程序数据备份、硬件裸机就能够把整个业务重建起来。</strong></p><p>理想情况下，重组业务的最大制约是还原应用程序数据所需要的时间，应用程序数据是真正的业务价值所在。</p><p><br><br><br></p><h2 id="面向服务体系结构"><a href="#面向服务体系结构" class="headerlink" title="面向服务体系结构"></a>面向服务体系结构</h2><p>将系统的每个组件都分解为可通过网络访问的服务，这些服务集成在一起就构成了一个功能性应用程序。</p><p>通过将每个基本组件都呈现为服务、应用开发者可自由组装的新的应用，结果就是重用更为容易、封装更为清洁、错误排查更为简单。</p><ul><li><p>应该是模块化的</p><ul><li>做一件事，并且做好<br>在SOA中，每个服务都很小——只做一件事，并允许其它服务调用。每个服务都很简单，但应用程序员要做很多集成工作。每个服务都专注于自己的狭小领域，则管理、开发、测试都会很容易。<br>基础架构服务也是一样的，缩小每个服务的操作范围，就可以降低复杂性，从而他人也就易于理解其行为。</li></ul></li><li><p>应该是协作的</p><ul><li>让我们团结起来<br>在构建通过网络API呈现的基本服务时，要鼓励别人和你协作，而不是重复实现相同的功能。每个服务都要设计成与其它服务协作的，尽量少假设服务的使用方式。<br>服务的协作本性决定了用的人越多，则服务本身就越有用。对于基础架构服务而言，这种本性是至关重要的——随着基础架构的每个部分都成为可集成的服务，服务之间相互协作的方式会呈指数增长。</li></ul></li><li><p>应该是可组合的</p><ul><li>应该一切准备就绪<br>理想情况下，每个服务都应该通过易于访问的网络API呈现自己的配置和功能，实际情况是：大部分都没有。</li></ul></li></ul><p><br></p><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>配置管理是一种管理活动，从技术和管理两个方面作用于产品和生命周期、配置项，以及相关的产品配置信息。</p><p>配置管理是指对所有那些事情的跟踪，那些事情是把一个系统从<strong>裸机(baremetal)</strong>转变成<strong>做自己的事</strong>时必须要做的。系统管理员手工配置系统，并将笔记贴到wiki上时，他就是在实践着最基本的配置管理。软件开发者写了一个脚本来自动部署自己的应用程序，她就是在实践着自动化的配置管理。</p><p><br></p><h3 id="配置管理是策略驱动的"><a href="#配置管理是策略驱动的" class="headerlink" title="配置管理是策略驱动的"></a>配置管理是策略驱动的</h3><ol><li>把问题和解决方案的最终结果记入文档(设立策略)；</li><li>写出在策略中要执行的代码(执行策略)；</li><li>确认最终结果是正确的(审计策略)；</li><li>重复这个过程，确保以后呢能够可靠的执行(测试策略)</li></ol><p><br></p><h3 id="系统自动化就是用代码实现配置管理策略"><a href="#系统自动化就是用代码实现配置管理策略" class="headerlink" title="系统自动化就是用代码实现配置管理策略"></a>系统自动化就是用代码实现配置管理策略</h3><p>自动化几乎总是使用高级语言，自动化方式展现了三个原则：</p><ul><li>应该是灵活的<ul><li>无论需要什么，都应该有能力做</li></ul></li><li>应该是可扩展的<ul><li>遇到新情况时，要易于扩展</li></ul></li><li>应该是可重复的<ul><li>不管重复做了多少次，结果都一样</li></ul></li></ul><p><br></p><h3 id="系统管理中的配置管理"><a href="#系统管理中的配置管理" class="headerlink" title="系统管理中的配置管理"></a>系统管理中的配置管理</h3><p>配置管理工具应该有如下思想：</p><ul><li>描述的<ul><li>说明做什么，而不是怎么做</li></ul></li><li>抽象的<ul><li>让工具为你操心细节</li></ul></li><li>幂等的<ul><li>旨在需要时才采取行动</li></ul></li><li>聚合的<ul><li>只关心自己，并信赖其他服务亦然</li></ul></li></ul><p><br></p><h3 id="系统集成"><a href="#系统集成" class="headerlink" title="系统集成"></a>系统集成</h3><p>系统集成是指将各个组件整合为一个功能正常的、完全自动化的系统。系统集成侧重于广度，能否成功则依赖于对两个方面的理解：</p><ul><li>系统中的每个组件是如何工作的</li><li>这些组件是如何相关的</li></ul><p>应该遵循这两个步骤将基础架构构建为代码，这两个恰好也是系统集成阶段使用的步骤。系统集成就是将所有的东西整合在一起。</p><p><br></p><p><strong>将基础架构分解为可重用的，可通过网络访问的服务</strong></p><p>良好基础架构的十大核心原则：</p><ul><li>应该是模块化的<ul><li>启动过程将只处理这样的任务：使资源成为网络可访问</li></ul></li><li>应该是协作的<ul><li>启动服务应该能够将启动后的工作传给其他服务</li></ul></li><li>应该是可组合的<ul><li>能够从不同的服务中调用启动服务</li></ul></li><li>应该是灵活的<ul><li>足够灵活以应付不同类型的物理系统</li></ul></li><li>应该是可扩展的<ul><li>易于扩展，义启动新的资源类型</li></ul></li><li>应该是可重复的<ul><li>每次启动，都要生产相同的系统</li></ul></li><li>应该是描述的<ul><li>应该描述需要的系统类型，而不是如何安装和构建这些系统的细节</li></ul></li><li>应该是抽象的<ul><li>应该隐藏底层机制</li></ul></li><li>应该是幂等的</li><li>应该是聚合的<ul><li>应该尽快将每个系统都启动起来，并为随后的操作系统做好准备，而不用担心其他系统的状态</li></ul></li></ul><p><br></p><p><strong>将服务集成在一起</strong></p><p>现在，你已经创建了一个如何引导和配置系统的策略，你知道接收标准是什么、能够列出实现步骤、能够对策略进行测试。这种做系统集成的方式类似于做一个多层蛋糕：每一层都建立在前一层的美味基础上，使得整个蛋糕更为诱人。</p><p><br><br><br></p><hr><p><br></p><h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><p>我以前假定服务器资源是无限的，实际情况却是服务器正在为获得必要的内存而努力挣扎着。操作系统开始进行交换，CPU开始过载，从而响应时间开始变糟。</p><p>技术人员的观点和最终用户/业务的观点并不一致。</p><p>监控并不是设置一个系统，它是用来支持业务运转的，是用来保证系统中各个部分都在各司其职地工作着。能够正常工作也可以表述为保持网站的可用性。</p><p>可用性(A)可表述为：<br>A = Uptime/(Uptime + Downtime)</p><p>网站可用性受如下4个参数的影响：</p><ul><li><strong>MTTD(平均故障诊断时间)</strong><ul><li>诊断该问题所花费的平均时间</li></ul></li><li><strong>MTTR(平均修复时间)</strong><ul><li>用于修复问题所花费的平均时间</li></ul></li><li><strong>MTTF(平均无故障时间)</strong><ul><li>正常运行的平均时间</li></ul></li><li><strong>MTBF(平均故障间隔时间)</strong><ul><li>两次故障间隔的平均时间</li></ul></li></ul><p>A = MTTF/MTBF = MTTF/(MTTF+MTTD+MTTR)</p><p>并不是说你的业务需要接近90%或更高的可用性，业务要求的可能性只是一种期望值，如果宕机发生在周末，即使发生在工作日，只要还能工作，用户也不会说什么。你的目标是应该通过降低MTTD和MTTR，以及增加MTTF来增加可用性。</p><p><br><br><br></p><h2 id="理解你在监控什么"><a href="#理解你在监控什么" class="headerlink" title="理解你在监控什么"></a>理解你在监控什么</h2><p><strong>技术组件的依赖项：</strong></p><table><thead><tr><th>组件</th><th>依赖关系</th></tr></thead><tbody><tr><td>应用程序</td><td>应用程序服务器、Web服务器、邮件服务器、缓存服务器、队列服务器</td></tr><tr><td>Mail服务器</td><td>Mail服务进程、网络、主机、存储</td></tr><tr><td>DNS服务器</td><td>DNS服务进程、网络、主机、存储</td></tr><tr><td>应用程序服务</td><td>应用程序服务进程、网络、主机、存储</td></tr><tr><td>Web服务器</td><td>Web服务器进程、网络、主机、存储</td></tr><tr><td>数据库</td><td>数据库服务进程、网络、主机、存储</td></tr><tr><td>主机</td><td>设备、OS设备进程</td></tr><tr><td>网络</td><td>设备、网络设备进程</td></tr><tr><td>存储</td><td>设备、磁盘、RAID控制器、接口</td></tr><tr><td>通用设备</td><td>磁盘、内存、CPU、接口、房屋</td></tr><tr><td>房屋</td><td>UPS、电源、温度</td></tr></tbody></table><p>依赖项常常不受你控制，相反，它是由公司内不同的组管理的。从你自己的筒子里走出来，到其他部门获取相关信息，并不是很容易。正是因为你依赖于他们，所以更好地理解他们的就很关键了。这样你就不用在讯早问题的原因上浪费时间，在用户访问服务所依赖的那些组件上也就不会存在盲点。</p><p><br></p><p><strong>不同部门之间的边界：</strong></p><table><thead><tr><th>企业部门</th><th>依赖项</th></tr></thead><tbody><tr><td>支援部门</td><td>能影响浏览器、桌面设置、防病毒/间谍软件</td></tr><tr><td>开发组</td><td>专注于应用程序更新</td></tr><tr><td>中间件组</td><td>经常运行数据库、Web服务器、应用程序服务器、邮件服务器、缓存服务器队列服务器</td></tr><tr><td>系统组</td><td>操作系统、DNS、DHCP、虚拟化、集群</td></tr><tr><td>网络组</td><td>交换机、路由器、VPN、代理服务器</td></tr><tr><td>存储组</td><td>SAN、NAS、备份、恢复</td></tr><tr><td>数据中心组</td><td>电缆、电力、UPS</td></tr><tr><td>安全小组</td><td>防火墙、安全策略</td></tr></tbody></table><p>这样划分责任，在不清楚问题的真正原因时，会显著增加修复问题的时间。大量精力会花在努力证明自己部门的清白上面，从而延长了解决问题的时间。这份额外时间称为平均清白时间(Mean Time to Innocence)。<br>为了减少这种相互推诿的时间，良好的合作与协调很重要。持续的知识共享有助于增加这种共同应对问题的责任感。</p><p>组织边界到防火墙哪里就停止了，但Internet服务比内部控制的服务有更多的依赖项，这些外部依赖项有ISP、广告商、RSS信息、Internet邮件、DNS服务器、ISP连接等，内部依赖项和外部依赖项的主要区别在于，对于外部依赖项，你不知道这些服务是如何提供的。即使如此，也不能在监控这些服务上止步不前，毕竟它们仍然是你的服务的依赖项。</p><p>在无冗余的系统中，一个组件失效，整个服务就会失效。当一个组件的失效会影响整个服务时，这种失效就称为单点故障。这种影响既指服务完全中断，也指对服务质量的影响。<br>为了避免单点故障，通常是在架构中的多个位置增加冗余，这些冗余是你的环境的安全卫士，而不是对问题的某种补偿方式。通常，增加冗余会增加复杂性，所以不要掉进过度设计的陷阱。</p><p><strong>一些冗余机制：</strong></p><table><thead><tr><th>服务/组件</th><th>冗余机制</th></tr></thead><tbody><tr><td>应用程序</td><td>负载均衡器、状态复制</td></tr><tr><td>Mail服务器</td><td>一个域名多条MX记录</td></tr><tr><td>DNS服务器</td><td>一个域名多条NS记录</td></tr><tr><td>应用程序服务器</td><td>会话复制、多实例安装</td></tr><tr><td>Web服务器</td><td>Web服务器服务进程</td></tr><tr><td>数据库</td><td>集群服务、水平区分</td></tr><tr><td>主机</td><td>虚拟化、集群</td></tr><tr><td>网络</td><td>多网关、BGP、VRRP、多ISP</td></tr><tr><td>存储</td><td>RAID、镜像、多重路径技术</td></tr><tr><td>通用设备</td><td>多网卡、CPU、内存</td></tr><tr><td>数据中心</td><td>BGP任播、GSLB</td></tr></tbody></table><p><br></p><p>不要忘了检查监控服务的依赖项，如果监控都挂了，那还监控什么呢。</p><p><strong>各种检查：</strong></p><table><thead><tr><th>检查种类</th><th>例子</th></tr></thead><tbody><tr><td>可用性</td><td>能访问80端口吗？HTTP进程在运行吗？数据库能访问吗？</td></tr><tr><td>功能/既时</td><td>应用程序在请求数据库，OS在进行DNS查询，控制器在进行磁盘写入，负载均衡器在请求Web服务器</td></tr><tr><td>功能/模拟</td><td>模拟HTTP请求、DNS请求、发送邮件</td></tr><tr><td>质量/利用</td><td>CPU、内存、磁盘等硬件信息使用情况，可以知道机器是否有足够的处理能力</td></tr><tr><td>质量/效率</td><td>Squid缓存命中率</td></tr><tr><td>质量/吞吐</td><td>订阅数、登录数、请求数、进/出请求数，用户数，数据库连接数，活动连接数，实例数</td></tr><tr><td>环境</td><td>配置监控，安全监控，备份监控</td></tr><tr><td>可信性</td><td>邮件域的垃圾邮件防范级别，SSL证书</td></tr></tbody></table><p><br></p><p><strong>不同层级的检查：</strong></p><table><thead><tr><th>层级</th><th>例子</th></tr></thead><tbody><tr><td>业务</td><td>内部网管理站点</td></tr><tr><td>交易</td><td>登录、增加文档、分享链接、注销</td></tr><tr><td>服务</td><td>Mail、DNS、Web服务器、数据库、路由、防火墙</td></tr><tr><td>机器</td><td>服务器、CPU、内存、交换机</td></tr></tbody></table><p><br><br><br></p><h2 id="理解正常行为"><a href="#理解正常行为" class="headerlink" title="理解正常行为"></a>理解正常行为</h2><p><strong>即使你了解所有依赖项，但设计一个好的监控解决方案仍是要花时间的。需要根据业务实际需求和变化对监控实施改变。</strong></p><blockquote><p><strong>一些监控中的主要问题：</strong><br>如果多次报警基于同一个原因，应该只发送一次报警；<br>夜间，备份可能会在生产网络上产生很高的负载，这样由于响应时间的变慢而导致多个ping失败和其它可能的误报，从而产生起起伏伏的报警；<br>如果我们想要随时待命的支持人员，必须尽可能降低报警和误报的次数。</p></blockquote><p><br></p><p>加入的检查越多，消耗的生产系统的资源也就越多，这些资源可以是传送数据的带宽、计算结果的CPU…<br>你需要找到正确的平衡：监控太多只会浪费资源，从而降低对整个状况的了解；监控不足将导致不能及时报警。越靠近业务层的检查越有机会检测出问题，而越底层的检查越能够对发生的问题进行定位。</p><p>监控被认为是运维环境的一部分，通常是由系统或网络管理员来管理的。开始时是一个很小的系统，在后台运行。随着监控环境的扩大，需要执行更多的配置和定制。虽然运维人员常常是第一个对要部署的新软件进行仔细检查的人，他们的标准却往往并不应用到自己的监控系统上。监控系统是你的关键应用之一，请一视同仁。</p><p><br></p><p><strong>监控的最佳实践：</strong></p><table><thead><tr><th>实践</th><th>说明</th></tr></thead><tbody><tr><td>版本</td><td>对你的检查进行版本华，并把他们放入版本控制库中</td></tr><tr><td>不同环境</td><td>使用不同环境开发、测试新的检查</td></tr><tr><td>测试</td><td>将检查作为通常代码对待，在代码功能中加入测试</td></tr><tr><td>可使用性</td><td>创建一个所有组件及其关系的可视化总览图，指出失效和组件的关系对工程师很有帮助，只需要看一下仪表板就能明白问题出在哪里</td></tr><tr><td>信息架构</td><td>使用不同的数据表示法，将数据组织为层次结构以便于导航，同时还要避免信息过载</td></tr><tr><td>代码重用</td><td>如果能够重用所监控的应用程序中的业务逻辑，就不要自己写</td></tr><tr><td>无硬编码</td><td>避免将参数编码在脚本中，使用配置文件，这也易于脚本在不同环境中的迁移</td></tr><tr><td>部署</td><td>要易于部署和分发新的检查</td></tr><tr><td>备份/还原</td><td>备份监控数据，并了解在什么情况下需要还原</td></tr><tr><td>监控</td><td>监控你的监控系统</td></tr><tr><td>冗余</td><td>在监控上，使用高可用性的功能做维护工作</td></tr><tr><td>应用的安全规则</td><td>监控账号与其它事务账号分开 <br> 是用最小特权级 <br> 不要将密码保存为明文 <br> 限制对系统的访问，不要将其用于其它的测试 <br> 将监控系统用防火墙或代理系统保护起来，避免来自易受攻击的主机的访问</td></tr></tbody></table><p>所有信息一旦采集和存储，接下来做的就是分析检查结果。服务或系统的状态有<strong>可用(Up)</strong>和<strong>不可用(Down)</strong>，某些监控系统还增加了两个状态，一个用于<strong>系统不可达(Unreachable)</strong>，一个用于<strong>系统/服务尚未检查(Pending)</strong>。</p><p>有的时候，在位新服务建立环境时，预先定义的阈值很困难——实际使用可能会超过预期，或者相反。所以，对阈值进行不断的调优就有意义了。先根据理论上的假设定义一组阈值，然后在测试环境中模拟预期的行为，并翻译为技术化的组件使用情况。因为系统及使用情况的复杂性，对系统、应用程序、用户行为建立精确的模型是很困难的。所以，对阈值只能持续不断地研究与改进。趋势分析确实有助于定义阈值，大部分监控软件都可以让你对监控的值做趋势分析，而不产生报警，根据历史数据得出阈值之后，再启动报警设置。</p><p>管理报警并不仅仅是状态变化时发出报警信息。所有报警如果一直打开着的话，工程师将无法安心做系统支持，因为报警信息太多了，可能要被报警轰炸。同样，如果有太多假设报警，也会导致同样的问题，这可以看成是你的监控系统存在技术缺陷。<br>警报应该产生行动。如果一条警报可以忽略或不需要人工干预，这条报警就是一种浪费。然而，消除噪音却是真正的挑战。警报太多会导致<strong>狼来了</strong>效应，由于警报过载而忽略了正在重要的警报。</p><p>为了使网站可以忍受而限制报警是好的，但假如与业务需求不一致的话，就不行了。反之也是对的，如果业务不需要的话，为了显示网站运行正常而发送很多报警信息，也是毫无意义的。使监控保持正确的平衡，这很重要。</p><p><br><br><br></p><h2 id="有备而学"><a href="#有备而学" class="headerlink" title="有备而学"></a>有备而学</h2><p>一个人不可能在每个方面都是专家，有一个清晰定义的升级路径，从而把问题提交给更为专业的人员去处理是明智的。<br>对紧急报警进行跟踪和趋势分析，有助于提出架构和过程的改进建议。</p><p>故障时间本身并不仅仅有功能失效引起的，也可能是由于维护活动产生的。维护活动产生的故障时间被描述为维护窗口。在这种情况下，业务部门是认可默写故障时间的。为了避免不必要的报警，监控系统可能会在这段时间关闭报警。这会导致丢失一些与此次维护无关的系统/服务故障。所以，应该只关掉与维护相关的报警，而不是整个报警系统。然后，一旦服务运行稳定了，就要打开报警。</p><p><br><br><br></p><h2 id="结语-2"><a href="#结语-2" class="headerlink" title="结语"></a>结语</h2><p>监控并不是要保持服务器运行正常，也要保持业务运行正常。理解了技术组件和业务行为，你就会有相当的把握减少和修复问题上的时间。错误总是会发生的，但要为此做好准备。万一系统失效，一定要将反馈信息发送给每一个希望听到的人，并对事情做出改进，避免再发生新的错误。愿监控的力量与你同在。</p><p><br><br><br></p><hr><p><br></p><h1 id="复杂系统是如何失败的"><a href="#复杂系统是如何失败的" class="headerlink" title="复杂系统是如何失败的"></a>复杂系统是如何失败的</h1><p>所有复杂系统失败时，都有共同点。Web运维就是这样一个领域。</p><p><br><br><br></p><h2 id="复杂系统是如何失效的"><a href="#复杂系统是如何失效的" class="headerlink" title="复杂系统是如何失效的"></a>复杂系统是如何失效的</h2><ul><li>复杂系统本质上都是灾难系统</li><li>复杂系统都被重重地然而也是成功地防护着</li><li>灾难要求多点失效——单点失效是不够的</li><li>复杂系统包含潜藏在其中的缺陷的变化混合物</li><li>复杂系统以降级模式运行</li><li>灾难随时会发生</li><li>事后归结为”根本原因“是错误的</li><li>幕后认识对人类行为的时候评估存在偏见</li><li>人类操作员有双重角色：作为生产者，以及作为失效防护者</li><li>所有操作者的行为都是赌博</li><li>最为困难的行动解决了所有的模糊性</li><li>人类操作者是复杂系统的可调整因素</li><li>复杂系统中人类专门处理知识处于不断变化中</li><li>变化会引入新的失效</li><li>“原因”观点限制了对未来事件的有效防护</li><li>安全是系统的特性，而不是系统的组件</li><li>持续创造安全的是人</li><li>无事故的运维需要经历事故的历练</li></ul><p><br></p><p><strong>针对Web运维而言：</strong></p><ul><li>了解系统失效很困难</li><li>了解哪部分失效很困难</li><li>有意义的响应会被延迟</li><li>沟通会产生紧张，而脾气会冒火</li><li>维护会成为新的失效的主要源头</li><li>从备份中恢复本身就很困难，而且还有潜在的危险</li><li>创建测试过程，一线人员用来验证系统状态</li><li>对运维进行例行的每日管理</li><li>控制维护</li><li>定期对性能进行评估</li><li>要成为(独一无二)的用户</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="社区管理与Web运维"><a href="#社区管理与Web运维" class="headerlink" title="社区管理与Web运维"></a>社区管理与Web运维</h1><p>运行一个大型且广为人知的网站，意味着会有大批人依赖于网站快速而稳定的服务。这些人会形成一个社区，以各种有趣新颖的方式进行交流，并彼此关照。</p><p>社区起着一个交流、沟通、反馈的渠道作用。</p><p><br><br><br></p><hr><p><br></p><h1 id="处理非预期的访问量激增"><a href="#处理非预期的访问量激增" class="headerlink" title="处理非预期的访问量激增"></a>处理非预期的访问量激增</h1><p>有些时候，因为某种原因，Web的访问量会急剧增加(是正常用户访问而不是遭受攻击)，我们的服务器就会遭受严重的考验。</p><p><br><br><br></p><h2 id="一切是如何开始的"><a href="#一切是如何开始的" class="headerlink" title="一切是如何开始的"></a>一切是如何开始的</h2><p>开能由于某个原因，导致Web流量激增，而我们服务器却无法应付这么高的并发和流量，所以导致Web瘫痪。</p><p><br><br><br></p><h2 id="警报连连"><a href="#警报连连" class="headerlink" title="警报连连"></a>警报连连</h2><p>监控软件(如nagios, zabbix)警报连连。Web请求太多导致响应很慢或奔溃。</p><p><br><br><br></p><h2 id="扑灭烈火"><a href="#扑灭烈火" class="headerlink" title="扑灭烈火"></a>扑灭烈火</h2><p>查找是哪些环节导致Web响应很慢或奔溃，对之做相应的优化。</p><p><br><br><br></p><h2 id="未雨绸缪"><a href="#未雨绸缪" class="headerlink" title="未雨绸缪"></a>未雨绸缪</h2><p>当我们经历了非预期的流量激增，并处理优化之后，下一步就需要对整个基础架构进行加固，或转向新的架构。</p><p><br><br><br></p><h2 id="救命稻草CDN"><a href="#救命稻草CDN" class="headerlink" title="救命稻草CDN"></a>救命稻草CDN</h2><p>解决带宽问题要靠内容分发网络(CDN)——在多个地点存储文件，为客户提供最近最快的响应。<br>大部分静态资源适合移动到CDN上，以减轻原始服务器的负担。</p><p>但CDN也有一些不足。对于移动到CDN上的数据，你就失去了控制。对于短时间的静态内容，CDN的效果并不好。</p><p><br><br><br></p><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>代理服务器处于我们系统的最前沿，尽可能让代理服务器转发请求，而不使用任何其它资源。</p><p><br><br><br></p><h2 id="围剿踩踏"><a href="#围剿踩踏" class="headerlink" title="围剿踩踏"></a>围剿踩踏</h2><p>如何避免缓存踩踏？</p><ul><li>一个是对数据库进行优化</li><li>一个是搭建数据库集群</li></ul><p><br><br><br></p><h2 id="将代码基流水化"><a href="#将代码基流水化" class="headerlink" title="将代码基流水化"></a>将代码基流水化</h2><p><br><br><br></p><h2 id="怎么知道它能否工作"><a href="#怎么知道它能否工作" class="headerlink" title="怎么知道它能否工作"></a>怎么知道它能否工作</h2><p>确保系统能够处理负载的唯一途径是在流量汹涌而来时，对其进行现场测试。</p><p><br><br><br></p><h2 id="真实测试"><a href="#真实测试" class="headerlink" title="真实测试"></a>真实测试</h2><p>必须要在真实的生产环境中查看其负载效果，才能确保其能正常工作。</p><p><br><br><br></p><h2 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h2><p>总要为未来几年做一个规划——问问你自己：“当前的架构方案能够用于未来几年吗？”</p><p>要测试生产环境，经过适当的测试规划，很多问题是可以避免的。</p><p>当一个架构方案已经明显不能工作的时候，必须要有重新考虑整个方案的勇气。<br>重新思考代码、硬件、网络、数据库模式，为可见的未来创建一个伸缩性更好的系统。</p><p><br><br><br></p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>针对遭受的问题，之后对系统的改进。</p><p><br><br><br></p><hr><p><br></p><h1 id="开发者与运维者的协调与合作"><a href="#开发者与运维者的协调与合作" class="headerlink" title="开发者与运维者的协调与合作"></a>开发者与运维者的协调与合作</h1><p>很多网站都将其开发和运维分为两个独立的团队，开发负责开发新功能和对现有功能进行改进，运维负责网站的正常运行。<br>两个团队有不同的目标，工作方式的要求也是迥然有别。</p><p>这种设置很常见，但也是保证网站稳定性或及时推出新功能的最糟糕的设置。</p><p>这在种情形下，开发人员没有动力将网站做得更易于运维支持，开发团队交付的代码通常是一个黑盒子，一旦发生意外，运维团队没有办法及时去修复问题。这种结构也抑制了新的功能的开发、构建和部署网站的新版本，不仅耗时，成本高，还涉及很多不同团队之间的协调。对运维来说，部署是存在风险的，而且也是造成很多宕机事故的原因。</p><p>传统的运维和开发，两者之间存在着很多对彼此很有用的信息。对很多网站来说，性能瓶颈都出在应用程序代码上：开发团队最适合修正这些问题，但运维团队有测量数据，要想找出问题出在哪，是需要这些数据的。关于什么地方可能会出问题，以及如何修复，开发团队有很多很好的想法，但这些却很少会记录在文档里面。</p><p>所以，重新评估运维跟开发之间的关系！</p><p><br><br><br></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>以合适的方式进行移交，则不同团队之间就能更好地共同工作，而改变过程这是困难的，需要协助以及每个人的认可。</p><p>一项服务之所以受人欢迎，频繁部署也是重要原因之一。小批量代码更新。</p><p>用户报告问题后，极短时间内就得到修复，这一做法会彻底征服用户。有了这种响应凡是，则将来有了问题，用户也会很乐意报告给你，这样产品就会越做越好，特别是你能够一直这样快速反应的话。对关键的数据损失或安全缺陷能够在短时间内而不是几周响应的话，用户的数据就会安全得多。</p><p>然而最重要的是，频繁部署并不比周部署或月部署风险更大。很多小的更新，每个都单独测试和检查过，比起一次大的更新来说，导致严重宕机的事故的可能性要小很多。</p><p>这是因为小更新的影响能够提前单独进行复审和测试，从而错误造成的影响也易于量化及应对。定位代码中的缺陷，复审10行的更新比起10000行来，会容易得多，而且只测试那些受更新影响的功能，比起测试整个系统，也要快得多。而且能够确保每次部署都只是更新一个区域，从而避免同时更新的两个组件之间发生预料不到的交互作用。小部署意味着更容易预言更新对基础架构的影响，而这也就意味着未雨绸缪更加有的放矢。</p><p>如果只是部署30行代码，缺陷通常是自明的。如果缺陷不自明，其影响也会非常小，即使回滚也非常容易。</p><p><br></p><p>只有在遵循以下三条规则的情形下，频繁的小更新才起作用：</p><ul><li>构建与部署系统必须能够完全重复且自动地工作</li><li>具有几近完美的预演环境</li><li>部署必须尽可能快，理想情况是小于5min</li></ul><p>大多数构建和部署系统在某种程度上都是自动化的，少数团队走得更远，把构建和部署做成了一键操作。</p><p><br><br><br></p><h2 id="共享、开放的基础架构"><a href="#共享、开放的基础架构" class="headerlink" title="共享、开放的基础架构"></a>共享、开放的基础架构</h2><p>很多情形下，运维和工程都分为不同的小组，你会发现支持的基础架构也会一分为二。</p><p>共享基础架构是在团队之间进行协作的最容易的方式。</p><p>为了有效地工作，你需要了解系统的其它方面目前是如何运转的。为了建立信任，你需要使你的工作变得透明。</p><p><br><br><br></p><h2 id="信任"><a href="#信任" class="headerlink" title="信任"></a>信任</h2><p>信任是开发和运维之间最常见的紧张关系之一。多数运维团队对开发团队多少都有点怀疑，开发人员通常也好不到哪去。团队之间的不信任是不健康的，也是不合适的。</p><p>信任最终是建立在一种尊敬的感觉之上的。如果你尊敬某人，就很容易信任此人能够做好他的事情。反之，如此人交往便会带有偏见、不满等情绪。</p><p>运维和开发之间的许多问题都是由于对两个团队不同角色的重要性认识不同而造成的。</p><p>充分尊重你的同事，而不是事后指责他们。</p><p><br><br><br></p><h2 id="随叫随到的开发人员"><a href="#随叫随到的开发人员" class="headerlink" title="随叫随到的开发人员"></a>随叫随到的开发人员</h2><p>只有在开发人员对修正生产系统代码中的问题肩负起责任的情况下，才是有意义的，而这就意味着开发人员随叫随到。</p><p><br></p><h3 id="现场调试工具"><a href="#现场调试工具" class="headerlink" title="现场调试工具"></a>现场调试工具</h3><p>很多代码对于运维团队来说都是黑盒子。</p><p>要想办法在运行时调用额外的调试信息，技术团队的每个人在用管理账号登录系统之后，都可以开启额外的调试信息。</p><p><br></p><h3 id="功能标识"><a href="#功能标识" class="headerlink" title="功能标识"></a>功能标识</h3><p>禁掉某些依赖于问题架构的功能，而保持网站的其他部分正常运行，功能标识能够实现这一点。</p><ul><li>单个标识，用来禁掉每个非核心的基础架构</li><li>只要这些服务出现问题，我们都可以暂时并优雅地禁止掉这些功能</li><li>如果生产系统出现新的错误场景，也可增加新的标识</li></ul><p><br><br><br></p><h2 id="避免职责"><a href="#避免职责" class="headerlink" title="避免职责"></a>避免职责</h2><p>在很多团队中，没有人愿意成为搞坏所有事情的傻瓜。发生问题时，人们都会将责任推卸给别人。</p><p>每个人都有貌似合理的理由将指责转嫁给别人，却没有挺身而出，实实在在地修复问题，组织良好的团队深切地了解，在将问题修复之前，争论到底是谁的责任是没有意义的，为保护自己而浪费的每一分钟，由于问题没有修复，都会成为给用户带来损失的一分钟。用户会尝试各种可能性，知道他们发现系统出问题了。</p><p>多数生产环境都有足够的冗余，也足够复杂，任何问题都不太可能存在单一的根本问题。很多问题都是由两个或多个系统发生意料之外的交互作用而引起的。</p><p><br><br><br></p><h2 id="结语-3"><a href="#结语-3" class="headerlink" title="结语"></a>结语</h2><p>网站的稳定性是每一个人的责任，而不仅仅是某种应该交给运维团队去处理的东西。</p><p>让人人都拥有对网站的主人翁感觉，确实意味着能够减轻运维团队的工作负担。他们不用再花费大量时间呼吁采取防护性措施，一旦发生问题，也能够花更小的时间修复。这非常了不起，因为这意味着网站的宕机时间会减少很多。这也释放了运维团队，让他们能够把精力放在更为重要的任务上，即对基础架构的长期增长进行管理。</p><p><br><br><br></p><hr><p><br></p><h1 id="你的访问者感觉怎么样：面向用户的测量"><a href="#你的访问者感觉怎么样：面向用户的测量" class="headerlink" title="你的访问者感觉怎么样：面向用户的测量"></a>你的访问者感觉怎么样：面向用户的测量</h1><p>对于网站的成功而言，终端用户的测量也就变得和后台测量一样至关重要。</p><p><br><br><br></p><h2 id="为何要采集面向用户的测量数据"><a href="#为何要采集面向用户的测量数据" class="headerlink" title="为何要采集面向用户的测量数据"></a>为何要采集面向用户的测量数据</h2><p>采集数据，从而就可以对业务的健康状况进行分析。</p><p>如：</p><ul><li>每秒请求数/发布数</li><li>带宽</li><li>响应时间</li><li>HTTP错误率</li><li>记入日志的异常数</li><li>进程重启次数</li><li>队列大小</li><li>服务器的平均负载和进程数</li><li>数据库负载</li><li>内存</li></ul><p><br></p><h3 id="成功的创业公司所学到的以及必须适应的"><a href="#成功的创业公司所学到的以及必须适应的" class="headerlink" title="成功的创业公司所学到的以及必须适应的"></a>成功的创业公司所学到的以及必须适应的</h3><p>创业公司的一大优势就是敏捷，即快速反应的能力。要真正做到敏捷，创业公司需要了解终端用户真正体验到的是什么。</p><p>任何网站想要成功，就必须向用户学习，而且必须适应用户的需求。很多Internet巨头，它们现在的业务，都与其当初设定的相比有很大的不同。</p><p><br></p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>响应越快的应用程序越好！</p><p>响应级别：</p><ul><li>加入事情的响应时间在10ms内，我们的大脑就会认为这是真实的<ul><li>如点击桌面系统上的按钮</li></ul></li><li>如果谈话有100ms左右的延迟，我们不会感觉到这种延迟<ul><li>如国际长途电话</li></ul></li><li>如果应用程序的响应时间在1s之内，我们的感觉就是仍然在与应用程序互动，仍然在工作</li><li>应用程序的响应时间要是明显长于1s的话，我们就会抓狂</li></ul><p><br></p><h3 id="研究量化了这种关系"><a href="#研究量化了这种关系" class="headerlink" title="研究量化了这种关系"></a>研究量化了这种关系</h3><p>Web应用的速度越快，其Web业务员的优势就越明显！</p><p>如果你的网站很慢，你将得到：</p><ul><li>更少的用户搜索</li><li>更少的精度搜索</li><li>更少的每访客收入</li><li>更少的点击，更低的满意度</li><li>更少的每日搜索</li><li>等待访客点击的时间更长</li><li>更低的搜索引擎排名</li><li>更差的用户体验</li></ul><p><br><br><br></p><h2 id="是什么使网站变得很慢"><a href="#是什么使网站变得很慢" class="headerlink" title="是什么使网站变得很慢"></a>是什么使网站变得很慢</h2><p>简单来说，由以下三点原因造成：</p><ul><li>服务器花在处理用户请求上的时间</li><li>网络花在传输请求和响应上的时间</li><li>用户花在组装并显示结果内容上的时间</li></ul><p><br></p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>开始访问网站，用户都需要先找到服务器。</p><p>对于带有很多组件的网站——这是一个日渐普遍的模式——都会迫使用户去解析很多网站，并且页面加载的时间也延长了。</p><p><br></p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>网络再快，用户与服务器之间的往返也是需要时间的。</p><p>请求包含的内容越多，则网络用来传输的时间就越长。加入是一个安全页面的话，还会有另外的延迟，用来在客户与服务器之间进行加密协商。</p><p><br></p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>请求到达服务器之后，另一个导致延迟的罪魁祸首就登场了——主机。不论是从内存中检索静态对象，还是利用后台的第三方服务来完成一个复杂的请求，主机延迟都会对性能造成影响。</p><p><br></p><h3 id="发送响应"><a href="#发送响应" class="headerlink" title="发送响应"></a>发送响应</h3><p>响应内容一旦准备就绪，服务器就可以通过HTTP协议发送这些请求对象——大多数页面包含多个对象(如html,css,js,gif,png,jpg…)，正是这些对象的发送造成了访客体验到的延迟。</p><p><br></p><h3 id="异步通信与刷新"><a href="#异步通信与刷新" class="headerlink" title="异步通信与刷新"></a>异步通信与刷新</h3><p>某些应用包括一些客户与服务器之间的通信，这些通信是独立于页面进行的。<br>包含某种异步更新或刷新的应用，有不同的延迟测量指标。</p><p><br></p><h3 id="渲染时间"><a href="#渲染时间" class="headerlink" title="渲染时间"></a>渲染时间</h3><p>随着客户端越来越复杂，浏览器做的也就越来越多。有可能是启动富互联网应用(RIA)，这些RIAs都是构建在Flash、Flex、HTML5、Java、JS…之上的，也可能是运行QuickTime或Windows媒体播放器等这样的插件，甚至决定如何对复杂页面进行布局也是需要花费时间的。<br>所以，对于大量依赖客户端进行渲染的网站，就必须考虑这种延迟。</p><p><br><br><br></p><h2 id="测量延迟"><a href="#测量延迟" class="headerlink" title="测量延迟"></a>测量延迟</h2><p>有两种测量方法：</p><ul><li>综合监控</li><li>实际用户监控(RUM)</li></ul><p><br></p><h3 id="综合监控"><a href="#综合监控" class="headerlink" title="综合监控"></a>综合监控</h3><p>综合监控是通过从多个地点对网站进行一系列正规的校本化测试，对网站的性能进行监控。</p><p><strong>要记住，综合测试也是要消耗服务器资源的。</strong></p><p><br></p><h3 id="真实用户监控"><a href="#真实用户监控" class="headerlink" title="真实用户监控"></a>真实用户监控</h3><p>RUM的工作名副其实：它观察的是网站的真实访客，记录访客打开页面的速度，然后生成报表。</p><p>从这点来看，RUM会告诉你系统是否出问题了，因为你可以通过RUM发现问题以及速度变慢的情况，这些情况你没有进行测试，从而也就不知道是否存在。</p><p><br><br><br></p><h2 id="编写SLA"><a href="#编写SLA" class="headerlink" title="编写SLA"></a>编写SLA</h2><p>Web运维收集终端用户的数据的一个主要理由就是用来编写SLA，哪怕与客户之间没有正式的SLA，但对于正常工作时间及页面延迟，也应该有内部的目标，因为网站速度对用户体验有直接的影响。</p><p><br><br><br></p><h2 id="访客结果：分析"><a href="#访客结果：分析" class="headerlink" title="访客结果：分析"></a>访客结果：分析</h2><p>对于成功的Web运维来说，监控就是了解存在哪些不利因素。而当进入Web业务时，这些测量就要让位于Web分析了。</p><p><br></p><h3 id="市场营销如何定义成功"><a href="#市场营销如何定义成功" class="headerlink" title="市场营销如何定义成功"></a>市场营销如何定义成功</h3><p>对市场营销的最好描述——“更经常、更有效地卖出更多的东西给更多的人，从而得到更多的钱。”<br>或许应该将成功的在线营销更精确地定义为“让人们有效地去做你要他们做的事情。”</p><p><br></p><h3 id="网站的四种类型"><a href="#网站的四种类型" class="headerlink" title="网站的四种类型"></a>网站的四种类型</h3><ul><li>交易性网站</li><li>协作型网站</li><li>作为服务(saas)网站</li><li>媒体网站</li></ul><p>很多流行网站都是上述模式的混合。</p><p>网站分析就是对每种类型网站的成功因素进行追踪，从中识别出使这些因素得以增长的背后动因——不管是广告活动、性能的提升、社会网络上的关注、特殊的定价模式还是某个引人注目的内容。</p><p><br></p><h3 id="分析一个简单的模型"><a href="#分析一个简单的模型" class="headerlink" title="分析一个简单的模型"></a>分析一个简单的模型</h3><p>有一个简单方式来考虑网站分析，就是做一次访问。</p><p>网站分析的目标，就是通过优化网站，将访客的转变最大化，通常是对网站进行试验，并针对各种内部和外部区段，对这些试验结果进行分析。</p><p><br><br><br></p><h2 id="市场营销关心的其他测量数据"><a href="#市场营销关心的其他测量数据" class="headerlink" title="市场营销关心的其他测量数据"></a>市场营销关心的其他测量数据</h2><h3 id="Web交互分析"><a href="#Web交互分析" class="headerlink" title="Web交互分析"></a>Web交互分析</h3><p>分析查看的是用户对多个页面的整体访问情况，Web交互分析集中在单个页面的可用性交互上。</p><p><br></p><h3 id="用户之声"><a href="#用户之声" class="headerlink" title="用户之声"></a>用户之声</h3><p>用户之声工具用来询问客户在想什么。这些工具从网站的访问性中征求反馈，通过请求客户参与调查，或者在页面上提供一个反馈按钮。</p><p><br><br><br></p><h2 id="用户体验如何影响Web运维"><a href="#用户体验如何影响Web运维" class="headerlink" title="用户体验如何影响Web运维"></a>用户体验如何影响Web运维</h2><p>随着新建公司对终端用户体验的关注，Web运维的角色正在发生变化。对线上事务的兴趣越来越浓，而且通过追踪分析，网站的所有事情都能够和业绩联系起来。</p><p><br></p><h3 id="将监控作为生命周期的一部分"><a href="#将监控作为生命周期的一部分" class="headerlink" title="将监控作为生命周期的一部分"></a>将监控作为生命周期的一部分</h3><p>网站现在已经有了很大的变化，随着敏捷和精简产品开发的流行，监控也需要跟上。所以来的综合监控脚本以及RUM配置也需如此。</p><p><br></p><h2 id="Web监控的未来"><a href="#Web监控的未来" class="headerlink" title="Web监控的未来"></a>Web监控的未来</h2><p>终端用户体验的监控正在兴起，变化很快。这是业务中最能进行分析、量化的部分，每周都能涌现出新的技术。</p><ul><li>从系统转向用户</li><li>以服务为中心的架构</li><li>云与监控</li><li>APIs与RSS消息</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="将关系数据库用于Web的战略战术"><a href="#将关系数据库用于Web的战略战术" class="headerlink" title="将关系数据库用于Web的战略战术"></a>将关系数据库用于Web的战略战术</h1><p>如何为产品或应用程序设计一个良好的关系数据库架构，如何构建良好的互联网数据库架构？</p><p><br><br><br></p><h2 id="Web数据库需求"><a href="#Web数据库需求" class="headerlink" title="Web数据库需求"></a>Web数据库需求</h2><p>其实，大多数网站，相对而言，都只是小型数据库。<br>一些大型公司，可能才是一个大型数据库。</p><p><br></p><h3 id="一直在线"><a href="#一直在线" class="headerlink" title="一直在线"></a>一直在线</h3><p>数据库通常要7x24小时运行。<br>一直在线意味着维护和运维任务是很难做的，你不能简单地等到人们回家了然后将服务器卸下来，给硬件升级或备份。必须在不停机的情况下做这些事，而且很多情况下还不能给应用程序增加额外的负载。</p><p>话虽这么说，还是极少看到没有峰值时间的数据库。所以，还是有很好的机会，在数据库活动的间歇期来做备份或对数据库产生干扰工作。</p><p><br></p><h3 id="事务最多的工作负载"><a href="#事务最多的工作负载" class="headerlink" title="事务最多的工作负载"></a>事务最多的工作负载</h3><p>很多互联网应用都匹配以下模式：</p><ul><li>应用程序读远大于写</li><li>一次读一行和一次读多行是混合出现的</li><li>一般，写每次只影响一行</li></ul><p>这就是称之为的<strong>事务型负荷</strong>。</p><p><br></p><h3 id="简单数据，简单查询"><a href="#简单数据，简单查询" class="headerlink" title="简单数据，简单查询"></a>简单数据，简单查询</h3><p>网站的流量很大程度上决定了数据库的流量。</p><p>查询通常会满足下面的模式：</p><ul><li>读写用户表，一次一行</li><li>以区域或集合方式读取用户自己的数据</li><li>以区域或集合方式读取其他用户的数据</li><li>从该用户到其他用户的关联表中读取区域行</li><li>对该用户和其他用户的数据进行汇总与计数</li></ul><p>特别低，很多数据可以分区存储的事实说明了为什么<strong>分片(sharded)</strong>架构是可能的。</p><p><br></p><h3 id="可用性胜过一致性"><a href="#可用性胜过一致性" class="headerlink" title="可用性胜过一致性"></a>可用性胜过一致性</h3><p>从业务的角度看，最重要的事情是应用程序对用户的可用性。</p><p><br></p><h3 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h3><p>传统应用极少以天或周为周期构建和部署，但对于大量Web应用来说却是常态，这些Web应用是永远的Beta版。</p><p><br></p><h3 id="在线部署"><a href="#在线部署" class="headerlink" title="在线部署"></a>在线部署</h3><p>模式和数据的更新都做成代码形式，而且也有这样的框架，部署这些代码或将其回滚都很容易。</p><p><br></p><h3 id="由开发人员构建"><a href="#由开发人员构建" class="headerlink" title="由开发人员构建"></a>由开发人员构建</h3><p>大量的应用程序都是由开发人员做的，都没有一个高水平的DBA。</p><p><br><br><br></p><h2 id="典型的Web数据库是如何增长的"><a href="#典型的Web数据库是如何增长的" class="headerlink" title="典型的Web数据库是如何增长的"></a>典型的Web数据库是如何增长的</h2><p>大多数Web数据库的增长，都经历了一些列的架构变动。这些架构变动，在应用程序的整个生命周期中，相对而言都是可预知的。</p><p><br></p><h3 id="单台服务器"><a href="#单台服务器" class="headerlink" title="单台服务器"></a>单台服务器</h3><p>一般应用程序都是从单台服务器开始起步的。使用单台服务器有很多好处：</p><ul><li>数据只有一份拷贝，不存在你的数据是否正确或不同的问题</li><li>易于配置</li><li>便宜</li></ul><p>当然，缺点就是只有一台服务器！假如发生问题，没有冗余机器做故障转移。性能也会受影响。</p><p><br></p><h3 id="主服务器与单复制从服务器"><a href="#主服务器与单复制从服务器" class="headerlink" title="主服务器与单复制从服务器"></a>主服务器与单复制从服务器</h3><p>各数据库的复制技术都不一样，但一般而言，发生在主服务器上的数据修改，都要在从服务器上重复一遍，所以从服务器是主服务器数据的只读拷贝。依赖于数据库、系统负载以及执行的查询类型，从服务器不一定时刻与主服务器的数据完全一致(异步复制)。</p><p>增加一个复制从服务器有很多好处。数据库读请求可以在主、从指间分担，这称为读写分离。可以在从服务器上执行那些效率不高的查询、备份以及其它有可能对网站造成破坏的任务。</p><p><br></p><h3 id="主服务器与多复制从服务器"><a href="#主服务器与多复制从服务器" class="headerlink" title="主服务器与多复制从服务器"></a>主服务器与多复制从服务器</h3><p>大多数复制技术对两台或多台从服务器都没问题。<br>这样确实不错，而且随着从服务器越来越多，系统的数据库读取能力也越来越强。但这种增长不是无限制的，在很多层面上都会遇到收益递减的拐点。</p><ul><li>第一个层面就是应用程序中读对写的比例</li><li>第二个方式表示主服务器的写操作有多忙，其中你会看到收益递减的情况</li><li>第三个限制是操作成本和复杂性<ul><li>管理一群服务器，比管理单台服务器，要难得多也昂贵得多</li></ul></li><li>最后一个不足是应用的复杂性<ul><li>从单一数据源走向两个数据源，对于大多数应用程序而言，都是一个重大转移。应用程序不得不连接多个位置来进行查询。连接池、负载均衡器以及类似技术会在一定程度上保护你不受这种复杂性的困扰，但最终应用程序仍然要面对某种程度的复杂性</li></ul></li></ul><p>复杂性的一个最大来源是异步复制。异步意味着写操作先在主服务器上完成，随后送往从服务器执行。结果就是，从服务器总是拖后于主服务器某段时间，即时这段时间很短，但由此而造成的问题却很大。这可能会导致用户体验的不一致到数据完整性等一系列问题。</p><p>一般而言，不存在修复这个问题的神奇方法，应用程序必须自己处理这种延迟复制。<br>一种不错的简单技术是基于会话的分裂。用户做了更新之后，一段时间之内，该用户的所有查询都导向到主服务器。认为能够安全地查询从服务器所需的时间戳通常都存储在会话里。</p><p><br></p><h3 id="功能分区"><a href="#功能分区" class="headerlink" title="功能分区"></a>功能分区</h3><p>复制只对读有伸缩，对写没有。随着应用的规模越来越大，写操作的负载最终会大到系统无法处理。</p><p>功能分区(functional partitioning)，假如将某些部分与其余部分分开，则这些部分可以独立增长。<br>如，对于博客服务，可将评论功能分离到它自己的服务器中。</p><p>从运维角度来看，不同部分处在不同位置，则应用程序的功能也就能够单独对待。比起网站宕机，将评论改为只读模式，用户的反感可能要小得多。</p><p>这种做法的不利之处是增加了复杂性。应用程序需要从多个位置获取数据，而运维团队必须保持这些服务器正常运行。</p><p><br></p><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>分片(sharding)，是将单一逻辑数据划分为多个片段并发布在多台服务器上的一种方式。所有的片段在逻辑上和功能上都是相同的，虽然这些片段分别包含数据的不同子集。</p><p>分片架构的主要设计目标和优势都是双重的。第一是允许写伸缩，因为负值无法实现写伸缩，假如应用程序的写操作草果了任何单台服务器能承受的程度，就必须要分片以减少写操作的负载，写操作的负载必须分担到完全隔离的服务器上，对一个分片的服务器的写操作不能复制到另一个分片服务器上。第二个目标和优势是，随着数据集的增长，能够增加更多容量的能力。</p><p>在分片架构中，许多查询也变得困难或不可能了。例如，需要访问所有客户数据的查询，通常都要在每个分片上分别执行，然后在应用程序代码中在聚合在一起。</p><p>分片架构还存在很多其他的不足和复杂性。</p><p><br></p><h3 id="缓存层"><a href="#缓存层" class="headerlink" title="缓存层"></a>缓存层</h3><p>缓存层的目的是阻止查询到达数据库。<br>标准的例子是：memcached，redis</p><p>缓存层的主要优势是极为容易，并且简单。</p><p>从运维的立场来看，需要考虑缓存服务器的冗余和可用性，就像为其他服务器所做的一样。</p><p><br><br><br></p><h2 id="对集群的渴望"><a href="#对集群的渴望" class="headerlink" title="对集群的渴望"></a>对集群的渴望</h2><p>在应用程序出现某种问题，或关于可用性或伸缩性的困难问题来的时候，人们的思想就会转向集群(cluster)，就像年轻人的思想转向春天和爱情一样。</p><p><br></p><h3 id="CAP定理以及ACID和BASE"><a href="#CAP定理以及ACID和BASE" class="headerlink" title="CAP定理以及ACID和BASE"></a>CAP定理以及ACID和BASE</h3><p>CAP原理： 一致性(Consistency)、可用性(Availability)、分区容错性(Partition Tolerance)。你可以具有两者，但不能三者皆具备。</p><p>ACID： 原子性(Atomicity)、一致性(Consisitency)、分离性(Isolation)、持续性(Durability)。</p><p>BASE: 根本可用性(basically available)、软状态(soft state)、最终一致性(eventual consistency)。</p><p><br></p><h3 id="MySQL集群的状态"><a href="#MySQL集群的状态" class="headerlink" title="MySQL集群的状态"></a>MySQL集群的状态</h3><p>MySQL Cluster是将MySQL服务器作为一个完全不相干的、称为NDB的软件的前端。NDB的意思是网络数据库，这是一个极快、分布式、无共享、高可用的数据库。</p><p><br></p><h4 id="DRDB和Heartbeat"><a href="#DRDB和Heartbeat" class="headerlink" title="DRDB和Heartbeat"></a>DRDB和Heartbeat</h4><p>DRDB在服务器之间对块设备进行复制，将修改的块通过网络复制给备机。如果主服务器失效了，则Heartbear激活备机。</p><p>从运维的角度来说，DRDB非常棒，装上就能工作，但却不能满足在线用户的需求。它不是为满足典型Web应用的高可用性而设计的。相反，它非常适合用户保证你不丢失数据的情况，也就是说，它关注的焦点是一致性而不是可用性。</p><p>另一个问题就是基于DRDB的集群不能改进性能。Web应用需要的是正常工作时间和性能，而基于DRDB的集群是以性能为代价来提供一致性，而一旦失效，宕机时间就会很长。</p><p><br></p><h4 id="主服务器到主服务器的复制管理器-MMM"><a href="#主服务器到主服务器的复制管理器-MMM" class="headerlink" title="主服务器到主服务器的复制管理器(MMM)"></a>主服务器到主服务器的复制管理器(MMM)</h4><p>MMM是一系列的Perl脚本，管理复制和虚拟IP地址，从而为MySQL提供一个伪集群(pseudocluster)。</p><p>应用程序连接到虚拟IP而不是服务器的真实IP。服务器发生问题时，MMM将该服务器的虚拟IP移动到另外的可用服务器上。它也可以将复制从服务器从失效的主服务器移动到正常的主服务器上。MMM允许手工将服务器离线执行维护任务。</p><p><br></p><h4 id="带复制的Heartbeat"><a href="#带复制的Heartbeat" class="headerlink" title="带复制的Heartbeat"></a>带复制的Heartbeat</h4><p>如果MMM无法完美地管理复制和虚拟IP地址，heartbeat考虑以下？</p><p>不管怎么说，复制延迟仍然是一个复杂的问题。必须在应用程序层解决这一部分问题。</p><p><br></p><h4 id="基于代理的解决方案"><a href="#基于代理的解决方案" class="headerlink" title="基于代理的解决方案"></a>基于代理的解决方案</h4><p>有一种可供选择的方案，基于代理(proxy)，需要人工介入，MySQL Proxy位于前端。HAProxy是另一个流行的方案。</p><ul><li>MySQL Proxy，事实上能够理解MySQL的协议，并且拦截、解释以及传递消息</li><li>HAProxy，只是传递TCP流，并不对内部进行窥探</li></ul><p>基于代理的解决方案仍然没有入人们所愿的那样解决复制延迟问题，而且还引入了单点故障，并且影响性能。</p><p><br></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>前面讨论这么多，简而言之，就是没有一个完美的、万能的答案。</p><p>最好的数据库架构是为了应用而建的，期待集群所承担的指责分布在数据库、网络以及应用程序上，有运维的适度介入，以及起粘合作用的软件，就能把各部分整合在一起。</p><p><br><br><br></p><h2 id="数据库战略"><a href="#数据库战略" class="headerlink" title="数据库战略"></a>数据库战略</h2><p>如何选择一个对于大量的互联网架构来说都能够运转良好的架构。</p><p><br></p><h3 id="架构需求"><a href="#架构需求" class="headerlink" title="架构需求"></a>架构需求</h3><p>最好定义你的需求，特别是，把那些超出你的范围从而成为别人的问题的内容写成文档。</p><p><br></p><h3 id="有把握的架构"><a href="#有把握的架构" class="headerlink" title="有把握的架构"></a>有把握的架构</h3><p>以下数据库架构，是比较有把握的。</p><p><br></p><ul><li><p><strong>单主服务器，多从服务器</strong><br>这种主-从架构很难自动实现主服务器的故障转移，因为主服务器和从服务器的配置是不一样的，所以，一旦主服务器失效，则必须手动进行失效转移。</p></li><li><p><strong>主服务器-主服务器复制，外加从服务器</strong><br>这种方式实际上与一台主服务器加多台从服务器的架构一样，但有时候主服务器本身也成为从服务器。这种架构的优点是，在协同的主服务器之间更容易实现失效转移和失效转回。缺点是，向两台主服务器进行写入存在风险，会导致数据库存在某种不一致性，也很难解决。</p></li><li><p><strong>功能分区</strong><br>随着应用的增长，将应用中某些部分转移到特定的服务器或特定集群上。</p></li><li><p><strong>失效转移和负载均衡</strong><br>使用负载均衡器，或者浮动的虚拟IP地址。</p></li><li><p><strong>ACID仍然是有意义的</strong><br>高可用性要求快速而可靠的灾难恢复。</p></li><li><p><strong>使用正确的工具</strong><br>不要使数据库处于关键路径上，不要讲应用程序的静态信息放入数据库中。数据库应该存储数据，而非应用程序本身。将数据库简单化，因为这是最难于伸缩，也是最昂贵的资源。但是，对于Web应用，还是应该分离应用程序和数据库，将数据库仅用来存储和检索数据。</p></li></ul><p><br></p><h3 id="有风险的架构"><a href="#有风险的架构" class="headerlink" title="有风险的架构"></a>有风险的架构</h3><p>建议不要使用这些架构</p><p><br></p><ul><li><p><strong>分片</strong><br>除非不得已，不要分片。<br>对于一个中等规模的应用，将其构建在数百台低档机器的分片架构上，试图提供无线伸缩能力，是非常愚蠢的。其实，只需购买几台足够好的机器，在工程上多做一些考虑就足够了。<br>分片架构比你预想要昂贵的多，甚至在短期内也是如此，长期则一定如此<br>分片问题设计过度设计的风险</p></li><li><p><strong>写入多台主服务器</strong><br>不要将多台服务器配置为可写，这会造成数据一致性问题。非常麻烦。</p></li><li><p><strong>多级复制</strong><br>尽量不要使用多级复制。<br>使用一主多从而不是从的从的从服务器，要简单的多。孙子辈的从服务器和重孙辈的从服务器很难管理。</p></li><li><p><strong>环形复制</strong><br>避免使用环形复制，其失效情形，不管是数量还是复杂度，都打得超乎想象。</p></li><li><p><strong>依赖于DNS</strong><br>DNS很脆弱，依赖DNS最终会自食苦果。</p></li></ul><p><br><br><br></p><h2 id="数据库战术"><a href="#数据库战术" class="headerlink" title="数据库战术"></a>数据库战术</h2><p>数据库战术，即为保持数据库基础架构的可靠性而做的日常运维任务。</p><p><br></p><h3 id="在从服务器上做备份"><a href="#在从服务器上做备份" class="headerlink" title="在从服务器上做备份"></a>在从服务器上做备份</h3><p>一些小提示：</p><ul><li>在备份上不要拖延，做备份其实并不难</li><li>做事不要追求完美，而要追求可恢复</li><li>至少对于可接受的数据损失、可接受的宕机时间、数据持续策略以及安全需求要形成文档</li><li>对恢复过程要进行练习并形成文档，恢复比备份要重要的多</li><li>对于备份成功与否，要进行外部验证，不要依赖于作业自身对你的提示</li></ul><p>可以专门配置一台复制(备份)从服务器，将复制延迟一段时间——如30min，以避免主服务器上的某些误操作——如<code>DROP table</code>。</p><p><br></p><h3 id="在线模式修改"><a href="#在线模式修改" class="headerlink" title="在线模式修改"></a>在线模式修改</h3><p>将表做的小一点是很有好处的。</p><p>一般的想法是设置主-主复制对，但只有一台服务器可写。在只读上执行更新，但不要复制到可写服务器上。更新一旦完成，则用正常方式使应用程序实现失效转移。这样，读和写便实现了角色转换。然后在另一台服务器上重复执行风险。这就实现了对应用程序隐含宕机时间的目的。</p><p><br></p><h3 id="监控和图示"><a href="#监控和图示" class="headerlink" title="监控和图示"></a>监控和图示</h3><p>构建用于测量和监控的系统是很值得做的事情，这些系统是基础架构非常重要的核心内容。</p><p><br></p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>一般步骤是，在产生麻烦的时间内手机详细的诊断数据，消除掉可能的原因，集中在问题的现象上。<br>问题往往是服务器产生大量负载，而这通常是由于糟糕的查询产生的。</p><p>MySQL所谓的慢查询日志(slow query log)可以回答这个问题，不仅是因为日志收集了慢查询的信息，而且对于每个查询还有时间信息。</p><p>加入性能问题不是查询引起的，则需要对MySQL本身进行性能测试。</p><p><br></p><h3 id="归档和删除数据"><a href="#归档和删除数据" class="headerlink" title="归档和删除数据"></a>归档和删除数据</h3><p>从一开始就要规划归档和删除不活动或不需要的数据，这样有助于减小“工作集”的大小。</p><ul><li>将极不活跃的用户数据移动到慢速服务器，或仅仅将用户设置为过期。当用户登录或重新激活时，在倒回到正常表中</li><li>另外一类可归档或删除的数据是陈旧的历史数据，或将历史数据移到另外的服务器上</li></ul><p><br><br><br></p><h2 id="结语-4"><a href="#结语-4" class="headerlink" title="结语"></a>结语</h2><p>尽最大可能将数据库架构建立在逻辑的基础上，而不是做一些看起来很酷的事情。</p><p>努力使系统保持小巧，不要大——而当不得不变大时，也要保持在能够掌控的范围内。要确定应用程序的真正需求，尽可能满足这些需求。要尽早及经常做缓存，但不要尽早及经常做分片。</p><p>最重要的，请记住：<strong>做备份</strong>。</p><p><br><br><br></p><hr><p><br></p><h1 id="如何优雅地失败：事后处理的艺术与科学"><a href="#如何优雅地失败：事后处理的艺术与科学" class="headerlink" title="如何优雅地失败：事后处理的艺术与科学"></a>如何优雅地失败：事后处理的艺术与科学</h1><p>宕机意味着实际的金钱损失。<br>客户才不会管这些故障，他们要的就是可靠性。互联网已经变得非常重要，宕机成本也越来越高。</p><p>但正如一个刚毕业的年轻人一样，只是知道你需要成长，但并没有告诉你如何去成长。我们需要将失败转化为学习经验。</p><p>保证网站稳定的首要事情，就是建立一个系统化的事后分析过程。通过阻止事故的重现以及改进处理事故的方法，使得系统稳定之后，事后分析能够让你全面地理解事故的本性。</p><p>例行的时候分析，是对运维的复杂问题进行科学分析的最贴近的方法。通过收集实际证据，可将有限的资源集中于解决产生问题的实际原因上。</p><p><br><br><br></p><h2 id="什么是事后分析"><a href="#什么是事后分析" class="headerlink" title="什么是事后分析"></a>什么是事后分析</h2><p>事后分析至少要包含这些内容：</p><ul><li>事故描述</li><li>根本原因描述</li><li>事件是如何修复的</li><li>用于解决事故的行动的时间表</li><li>事故是如何影响用户的</li><li>纠正或改正动作</li></ul><p>事后分析时，与事故明显有关的人员都要同时到场，对事故的真实情况作出共同的描述，从而正确地采取行动。</p><p>减少事故的修复时间，就跟消除事故本身一样重要。</p><p>对问题赋予严重级别，将帮助你按照轻重缓急来处理纠正项，而且对于活跃事件的评估也是有用的。</p><p>事故严重级别：</p><ul><li>严重影响大批用户</li><li>网站降级运行、性能问题或很难应对的功能故障</li><li>对客户影响不大或易于应对</li></ul><p><br><br><br></p><h2 id="什么时候引入事后分析"><a href="#什么时候引入事后分析" class="headerlink" title="什么时候引入事后分析"></a>什么时候引入事后分析</h2><p>在事故处理完成之后，就应该进行事故分析。事后分析过程应该最终使用户获益，而不应该在恢复服务的过程中进行。</p><p><br><br><br></p><h2 id="进行事后分析"><a href="#进行事后分析" class="headerlink" title="进行事后分析"></a>进行事后分析</h2><p>开始事后分析时，要明确基本规则，要明确告知参与事后分析的相关各方，事后分析不是指责谁(人们害怕这样的会议变成政治迫害)，主要目的是为了使类似事件不在重复发生。问题不可避免，重要的是我们能够从错误中学到教训。<br>事情一旦清楚之后，就可以开始讨论为了使类似事情不在发生，需要做些什么。确保相关各方对各自领域都能得出补救的办法。但切记不可矫枉过正！</p><p>一旦有了一套纠正措施，要将其记录在案，包括执行人员和完成日期。</p><p><br><br><br></p><h2 id="事后分析的后续工作"><a href="#事后分析的后续工作" class="headerlink" title="事后分析的后续工作"></a>事后分析的后续工作</h2><p>对纠正措施必须进行追踪，直到执行完成。</p><p>一些网站可操作性：</p><ul><li>消除单点故障</li><li>容量规划</li><li>监控</li><li>发布管理</li><li>运维架构复审</li><li>配置管理</li><li>随时待命和提升过程</li><li>不稳定的组件</li></ul><p><br><br><br></p><h2 id="结语-5"><a href="#结语-5" class="headerlink" title="结语"></a>结语</h2><p>最后，对于避免事故的发生，事后分析是最有用的方法。在一个快速变化的环境中，发生问题时可以理解的，但问题重复发生却是不能原谅的。花些时间高清楚问题的实质，从而确定、记录以及实施高强度的纠正措施，就可以避免事故的重复发生。</p><p><br><br><br></p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>数据是一项最重要、不可替代的商业资产。</p><p><br></p><h2 id="数据资产的库存"><a href="#数据资产的库存" class="headerlink" title="数据资产的库存"></a>数据资产的库存</h2><p>在开始一项新的存储工作时，首要的事情是要知道数据存在哪里。<br>对于不了解的数据，你是无法进行保护的。</p><p><br><br><br></p><h2 id="数据的保护"><a href="#数据的保护" class="headerlink" title="数据的保护"></a>数据的保护</h2><p>数据保护对所有系统都是很重要的。<br>良好的数据保护实践有助于处理范围广泛的情形，从还原被用户偶然删除的文件，到从灾难事件中恢复。</p><p>为了对数据中心问题提供完全的防护，重要的是将关键数据复制到不同的地点。</p><p>如今大多数的存储系统都有某种类型的复制技术。复制通常有两种形式：同步和异步。</p><p><br><br><br></p><h2 id="容量规划"><a href="#容量规划" class="headerlink" title="容量规划"></a>容量规划</h2><p>在确保有效的的数据保护之后，作为一名存储专业人员，容量规划就是第二项最重要的职责。<br>规划在前，确保应用和服务有足够的资源来运行和成长，不至于碰到天花板，这是必须的。</p><p>总是确保有足够的空间以应对突然的爆炸性增长，以及软件开发方面出现的延迟。</p><p><br><br><br></p><h2 id="存储大小的变化"><a href="#存储大小的变化" class="headerlink" title="存储大小的变化"></a>存储大小的变化</h2><p>存储是很昂贵的，这是现代基础框架中成本最高的组件。正是由于这个原因，对于存储上的开支进行明智地规划是很重要的。</p><p>存储需求要点：</p><ul><li>应用是什么</li><li>应用位于哪里</li><li>存储的是什么类型的数据</li><li>需要共享存储吗</li><li>是否需要特殊的访问协议</li><li>典型的文件大小是多少</li><li>数据是压缩的吗</li><li>如果描述工作负载</li><li>需要批处理操作吗</li><li>工作负荷是大部分用于读、写、读写</li><li>工作负荷是大部分顺序、还是大部分随机、还是两者</li><li>快照是怎么安排的</li><li>快照的一致性问题</li><li>存储容量在6个月、12个月、18个月的计划是什么</li><li>工作负荷在6个月、12个月、18个月的计划是什么</li><li>复制策略是什么</li><li>业务连续性规划是什么</li><li>可用性需求是什么</li><li>备份的频度是什么</li><li>备份保持的计划是什么样的</li><li>归档策略是什么</li><li>综合性需求是什么</li><li>加密需求是什么</li><li>…</li></ul><p><br><br><br></p><h2 id="结语-6"><a href="#结语-6" class="headerlink" title="结语"></a>结语</h2><p>数据是最宝贵的业务资产，且是不可替换的。</p><p><br><br><br></p><hr><p><br></p><h1 id="非关系数据库"><a href="#非关系数据库" class="headerlink" title="非关系数据库"></a>非关系数据库</h1><p>应用的数据存储层的伸缩是很难的。不管用的是什么数据库技术，随着数据量和事务数量的增长，就需要做出改变以适应新的负荷。</p><p>SQL数据库的可伸缩性通常归结为四件事：<strong>缓存、查询优化、购买新硬件、数据库分片。</strong></p><p><br><br><br></p><h2 id="NoSQL数据库概览"><a href="#NoSQL数据库概览" class="headerlink" title="NoSQL数据库概览"></a>NoSQL数据库概览</h2><p>NoSQL共生系统，可将数据库划分为5大类：</p><ul><li>纯粹的键值</li><li>数据结构</li><li>图</li><li>面向文档</li><li>高度分布</li></ul><p>每种类别的数据库都面向不同的应用情况，每个类别也都做了不同的这种。</p><p><br><br><br></p><h3 id="纯粹的键值"><a href="#纯粹的键值" class="headerlink" title="纯粹的键值"></a>纯粹的键值</h3><p>如： Tokyo Cabinet、 Kyoto Cabinet、MemcacheDB</p><p>正是它们的简单性定义了这组数据库。向数据库存入一个键和一个值，然后用同一个键查询数据库，则会得到相同的值。没有结构或类型系统——通常所处理的只是字节或字符串。因为这种简单性，这些数据库的开销极小，所以非常块。事实上，这些数据库通常都是实现为磁盘上的B树或哈希表。</p><p><br><br><br></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构数据库对键值数据库做了些修改，数据结构数据库将其存储为特定的数据结构，如<strong>列表、集合、哈希表等。</strong>有了这些附加的结构，就可以对值执行一些原子操作。可以对数据库执行在应用程序中对数据结构进行的各种操作。</p><p>Redis默认是在内存中(in memory)存储其全部内容，只是周期性地将内容的快照存储到磁盘。这使得Redis出奇的快，但假如数据库奔溃了，就会对数据造成一些损失，同时也意味着必须有足够的RAM存储这个数据库。</p><p><br><br><br></p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图数据库几乎就是数据结构数据库的一个特定实现，因为图本就是一种数据库。区别是图数据库不再是基于键值，数据是作为图的节点和边存储的。图数据库不是用键来查询值，而是给出根节点的句柄，然后就可以遍历整个图以找到需要的节点或边。</p><p>图数据库的优势：存储图或树形的数据。如一个社交图(social graph)。</p><p>常见图数据库包含：<strong>Neo4j、HyperGraphDB、InfoGrid、VertexDB。</strong></p><p><br><br><br></p><h2 id="面向文档"><a href="#面向文档" class="headerlink" title="面向文档"></a>面向文档</h2><p>面向文档的数据库又类似于键值数据库，但值不再是字节、字符串、列表、集合，而是<strong>文档</strong>。<br>文档作为JSON(BSON)对象存储，本质上是一种哈希表或字典。这些值都想相同的结构，意味着可以用查询来探测这种结构，并只返回所需要的文档。这种查询能力是建立在通过键来查找文档的能力之上的。</p><p>常见面向文档数据库： <strong>MongoDB、CouchDB</strong>。</p><p><br><br><br></p><h3 id="高度分布"><a href="#高度分布" class="headerlink" title="高度分布"></a>高度分布</h3><p>高度分布的数据库多少有些不同——有些本质上更接近于键值存储，其它则像大型的多维哈希图。</p><p><strong>HBase、Cassandra</strong>是高度分布式数据库。</p><p><br><br><br></p><h2 id="某些细节"><a href="#某些细节" class="headerlink" title="某些细节"></a>某些细节</h2><p>注意这些数据库之间的一些相似性，以及所做决策是如何影响系统可操作性的。</p><p><br><br><br></p><h3 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h3><p>Cassandra是一个高度分布数据库。</p><p>它有一些关键概念：</p><ul><li>认为写比读更难于伸缩，所以它专门为写操作做了大量优化</li><li>认为不应该存在单一故障点<br>任何数据可以写入到集群内的任何一个节点，而且读也一样。任何接收到请求的节点都可以，并且将会吧请求转发到合适的节点。</li></ul><p><br><br><br></p><h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><p>HBase选择一致性和可用性作为自己的核心价值。这样的结果，导致了在某些网段、集群无法实现优雅的恢复。作为这种牺牲的补偿，HBase有很强的一致性，保证写入一结束，写入的值就立即可以读取。</p><p><br><br><br></p><h3 id="Riak"><a href="#Riak" class="headerlink" title="Riak"></a>Riak</h3><p>Riak实现了向量时钟(vector clocks)，一些高度分布的数据库都没有实现——这些数据库选择了依赖于更为简单的基于时间戳的技术。</p><p>向量时钟是一种分布式系统中的机制，用于生成偏序事件。使用向量时钟，解决发生在两个独立的不同节点中的相同值的冲突就变得非常简单。从Riak客户端的角度来看，每个客户实例在Riak集群中执行一个动作时，都应该有一个唯一的标识(token)(连同其接收到的向量时钟一起)。然后，客户读取数据时，就可以看到向量时钟和数据值，使用包含的信息连接两个结果，从而将正确的版本写会数据库。</p><p>Riak也不存在单一故障点。</p><p><br><br><br></p><h3 id="CouchDB"><a href="#CouchDB" class="headerlink" title="CouchDB"></a>CouchDB</h3><p>CouchDB对世界的看法是一致的：所有东西都是文档，而且都通过RESTful HTTP来访问。<br>CouchDB可以在数据库中直接存储静态媒体，它实际上是允许将整个应用程序都存储在数据库中的。<br>CouchDB的数据模型很新颖，即数据以一种只附加的B树进行存储。</p><p><br><br><br></p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>MongoDB是一个面向文档的数据库，文档格式使用BSON——一种类似于JSON对象的二进制规范。MongoDB是用C++写的，因而有很高的性能。</p><p>所有能用SQL做的事情也能用MongoDB查询表达式来做。<br>MongoDB与以SQL数据库相同的方式支持索引，同时这些索引也强制了唯一性。</p><p>MongoDB有一个<code>mongostat</code>命令来查看数据库状态。</p><p>有好几种MongoDB备份方式：</p><ul><li>停掉数据库，复制数据文件</li><li>锁定数据库写入，复制数据文件，解除锁定</li><li>使用<code>mongodump</code>，将数据库转存到一个二进制文件中</li><li>可以设置一个从服务器，在从服务器上进行备份，而不是主服务器上</li></ul><p><br><br><br></p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis(remote dictionary server)，远程字典服务器。通过<code>INFO</code>可查看相关信息。</p><p>不管你将Redis运行在快照模式(rdb)还是只附加模式(aof)上，都可以简单地调用<code>rsync</code>实现备份。</p><p><br><br><br></p><hr><p><br></p><h1 id="如何高枕无忧"><a href="#如何高枕无忧" class="headerlink" title="如何高枕无忧"></a>如何高枕无忧</h1><p>企业持续规划(Business Continuity Planning)BCP。<br>BCP简单最简单来说，就是<strong>什么都是两份</strong>。当然，两套设备间的失效转移必须完全自动化。</p><p><br><br><br></p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>集中于BCP计划的高可用部分：保证站点正常工作。即使在高可用性领域，也有各种各样的技术，从<strong>热/热(Hot/Hot)、热/暖(Hot/Warm)、热/冷(Hot/Cold)到灾难恢复</strong>。</p><ul><li>热/热是高可用性的最高级别。用户可以从任意的数据中心使用全部的应用程序。读和写可以发生在任何地方。折让自动的故障转移变得非常简单，但它不是万能的。你想必须思考如何处理数据一致性的问题。</li><li>热/暖是一种很好的方式，如果你不能容忍数据的不一致性的话。很多应用有大量的读操作，仅偶尔写一下(但很重要)。在这种情况下，区别处理这两种操作是有意义的。</li><li>热/冷让我害怕。这种架构将读写流量送到单一地点，而让另一个相同的部署在遥远的地平线上闲置。它容易建立，但价值很低。</li><li>灾难恢复是最差的技术，本质上是雾件(vaporware)。它的本意不是在平常的时候保护你，而是在大的灾难发生时给你提供重建的选项。</li></ul><p><br><br><br></p><h2 id="影响持续时间对事件持续时间"><a href="#影响持续时间对事件持续时间" class="headerlink" title="影响持续时间对事件持续时间"></a>影响持续时间对事件持续时间</h2><p>当灾难来袭时，所有你需要考虑的是将用户流量以最快速度转移，离开问题区域。你需要立即降低影响。不要过于担心根源问题的修复，一旦将影响制止住，会有很多时间来解决这次事故。</p><p>怎样才能将流量从问题站点转出呢？通常方案是使用<strong>全局负载均衡(Global Server Load Balancing)GSLB</strong>。这实际是一个动态的授权DNS服务器，他能够根据相关因素对同一域名给出不同的IP地址。</p><p><br><br><br></p><h2 id="数据中心数量"><a href="#数据中心数量" class="headerlink" title="数据中心数量"></a>数据中心数量</h2><p>我们知道数据中心会失效，所以你至少需要两个。这就够了吗？三个或更多是不是会好一些？这取决于三个因素，<strong>成本、复杂性和性能</strong>。</p><p><br><br><br></p><h2 id="逐渐失效"><a href="#逐渐失效" class="headerlink" title="逐渐失效"></a>逐渐失效</h2><p>当数据中心出现局部问题(partial problem)时，不要等它解决从而希望你不需要撤离，立即导出复制数据！</p><p><br><br><br></p><h2 id="不信赖任何人"><a href="#不信赖任何人" class="headerlink" title="不信赖任何人"></a>不信赖任何人</h2><p>正如最可靠的数据中心也会时不时宕机，你可以预期即使最好的第三方供应商，偶尔也会有问题。就是你不能完全信赖一个服务提供商。</p><p><br><br><br></p><h2 id="故障测试转移"><a href="#故障测试转移" class="headerlink" title="故障测试转移"></a>故障测试转移</h2><p>通过早期和经常的测试，获取经验，以便当灾难袭来时，不会手忙脚乱，而是立即做出正确的事情。</p><p><br><br><br></p><h2 id="监控和历史模式"><a href="#监控和历史模式" class="headerlink" title="监控和历史模式"></a>监控和历史模式</h2><p>你要知道日、周、月的流量模式。如果清楚正常流量中的不寻常处，你就不会在切换、迁移或升级时感到惊讶。确保监控包括周对周的图形和趋势。</p><p><br><br><br></p><h2 id="高枕无忧"><a href="#高枕无忧" class="headerlink" title="高枕无忧"></a>高枕无忧</h2><p>如果你能够事先有计划，能够解决大的问题，并且在日常工作中操练故障转移，则平台任何部分的失效将会变成容易处理的事件，而不是危机。</p><p><br><br><br></p><hr><p><br></p><p>March 25, 2018 11:32 AM</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《网站运维：保持数据实时的秘籍》(Web Operations: Keeping the Data on Time)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Database" scheme="https://zhang21.github.io/tags/Database/"/>
    
      <category term="Operations" scheme="https://zhang21.github.io/tags/Operations/"/>
    
  </entry>
  
  <entry>
    <title>《经济学原理》读书笔记</title>
    <link href="https://zhang21.github.io/2018/02/23/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://zhang21.github.io/2018/02/23/经济学原理读书笔记/</id>
    <published>2018-02-23T08:13:58.000Z</published>
    <updated>2018-02-25T11:24:49.684Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>《经济学原理-微观/宏观》，曼昆： <a href="https://book.douban.com/subject/26435630/" target="_blank" rel="noopener">https://book.douban.com/subject/26435630/</a></li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><h1 id="微观经济学"><a href="#微观经济学" class="headerlink" title="微观经济学"></a>微观经济学</h1><p>阿尔弗雷德·马歇尔在《经济学原理》中写道<strong>经济学是一门研究人类一般生活事务的学问</strong>。</p><p>应当学习经济学的原因如下：</p><ul><li>有助于你理解你所生活在其中的世界</li><li>使你更加精明的参与经济</li><li>使你更好地理解经济政策的潜力与局限性</li><li>经济学原理可以运用到生活中的方方面面</li></ul><p><br></p><p>经济学领域的伟大洞见，如亚当·斯密的<strong>看不见的手</strong>的概念、大卫·李嘉图的<strong>比较优势原理</strong>，以及约翰·梅纳德·凯恩斯的<strong>总需求理论</strong></p><p><br><br><br></p><hr><p><br></p><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p><br></p><h3 id="经济学十大原理"><a href="#经济学十大原理" class="headerlink" title="经济学十大原理"></a>经济学十大原理</h3><p><strong>经济(economy)</strong>这个词来源于希腊语oikonomos，意思是“管理一个家庭的人”。</p><p>一个家庭面临着许多决策，同样，一个社会也面临着许多决策。</p><p><br></p><p>由于资源是稀缺的，社会资源的管理就尤为重要。</p><ul><li><strong>稀缺性(scarcity):</strong><ul><li>社会资源的有限性</li></ul></li><li><strong>经济学(economics):</strong><ul><li>研究社会如何管理自己的稀缺资源</li></ul></li></ul><p><br></p><h4 id="人们如何做出决策"><a href="#人们如何做出决策" class="headerlink" title="人们如何做出决策"></a>人们如何做出决策</h4><p>由于一个经济的行为反映了组成这个经济的个人的行为，所以个人就需要做出决策。</p><p><br></p><h5 id="人们面临权衡取舍"><a href="#人们面临权衡取舍" class="headerlink" title="人们面临权衡取舍"></a>人们面临权衡取舍</h5><ul><li><strong>效率(efficiency):</strong><ul><li>社会能从其稀缺资源中得到最大利益的特性</li></ul></li><li><strong>平等(equlity):</strong><ul><li>经济成果在社会成员中平均分配的特性</li></ul></li></ul><p><br></p><p>作出决策就是要求我们在一个目标与另一个目标之间进行权衡取舍。</p><p>当人们组成社会时，他们会面临不同的权衡取舍。经典的权衡取舍是在<strong>大炮与黄油</strong>之间。</p><p>社会面临的另一种权衡取舍是在效率与平等之间。</p><p>然而，认识到人们面临权衡取舍本身并没有告诉我们人们将会或应该做出什么决策。</p><p><br></p><h5 id="某种东西的成本是为了得到这种东西所放弃的东西"><a href="#某种东西的成本是为了得到这种东西所放弃的东西" class="headerlink" title="某种东西的成本是为了得到这种东西所放弃的东西"></a>某种东西的成本是为了得到这种东西所放弃的东西</h5><ul><li><strong>机会成本(opportunity cost):</strong><ul><li>为了得到某种东西所必须放弃的东西</li></ul></li></ul><p><br></p><p>由于人们面临着权衡取舍，所以做决策就需要比较可供选择的行动方案的成本与收益。</p><p><br></p><h5 id="理性人考虑边际量"><a href="#理性人考虑边际量" class="headerlink" title="理性人考虑边际量"></a>理性人考虑边际量</h5><ul><li><strong>理性人(rational people):</strong><ul><li>系统而有目的地尽最大努力实现其目标的人</li></ul></li><li><strong>边际变动(marginal change):</strong><ul><li>对行动计划的微小增量调整</li></ul></li><li><strong>边际成本(marginal cose):</strong><ul><li>对行动计划调整所带来的成本</li></ul></li><li><strong>边际收益(marginal benefit):</strong><ul><li>对行动计划调整所带来的的收益</li></ul></li><li><strong>边际决策(marginal decision):</strong><ul><li>选择哪种决策</li></ul></li></ul><p><br></p><h5 id="人们会对激励做出反应"><a href="#人们会对激励做出反应" class="headerlink" title="人们会对激励做出反应"></a>人们会对激励做出反应</h5><ul><li><strong>激励(incentive):</strong><ul><li>引起一个人做出某种行为的某种东西</li></ul></li></ul><p><br></p><p>在经济学研究中，激励起着中心作用。</p><p>市场上的高价格提供了买者少消费而卖者多生产的激励。<br>价格对消费者和生产者行为的影响对于市场经济如何配置稀缺资源是至关重要的。</p><p>政府决策者决不能忘记激励，因为许多政策改变了人们面临的成本或收益，从而也改变了人们的行为。</p><p>在分析任何一种政策时，我们不仅应该考虑它的直接影响，而且还应该考虑它通过激励产生的不太明显的间接影响。如果政策改变了激励，那就会使人们改变自己的行为。</p><p><br></p><h4 id="人们如何互相影响"><a href="#人们如何互相影响" class="headerlink" title="人们如何互相影响"></a>人们如何互相影响</h4><p>我们的许多决策不仅影响了我们自己，还会影响其他人。</p><p><br></p><h5 id="贸易可以使每个人的状况都变得更好"><a href="#贸易可以使每个人的状况都变得更好" class="headerlink" title="贸易可以使每个人的状况都变得更好"></a>贸易可以使每个人的状况都变得更好</h5><p>思考国家之间的竞争的想法很容易产生误导。美国与中国之间的贸易并不像体育比赛一样，一方赢而另一方输。实际上，事实正好相反：两国之间的贸易可以使两个国家的状况都变得更好。</p><p>贸易使每个人都可以专门从事自己最擅长的活动，无论它是耕种、做衣服还是盖房子。通过与其他人的贸易，人们可以以较低的成本获得各种各样的物品和服务。</p><p>国家和家庭一样，也能从相互贸易中获益。贸易可以使各国可以专门从事自己最擅长的活动，并享有种类更多的物品与服务。美国人和英国人、法国人一样，在世界经济中既是我们的竞争对手，又是我们的伙伴。</p><p><br></p><h5 id="市场通常是组织经济活动的一种好方法"><a href="#市场通常是组织经济活动的一种好方法" class="headerlink" title="市场通常是组织经济活动的一种好方法"></a>市场通常是组织经济活动的一种好方法</h5><ul><li><strong>市场经济(market economy):</strong><ul><li>当许多企业和家庭在物品与服务市场上相互交易时，通过他们的分散决策配置资源的经济</li></ul></li><li><p><strong>看不见的手(invisible hand):</strong></p></li><li><p><strong>利己心(self-interest):</strong></p></li></ul><p><br></p><p>中央计划经济国家运行的前提假设是，政府官员能够最佳地配置经济中稀缺资源。这些中央计划者决定，生产什么物品与服务、生产多少，以及谁生产和消费这些物品与服务。支撑中央计划经济的理论是，只有政府才能以促进整个社会经济福利的方式组织经济活动。</p><p>大部分曾经是中央计划经济的国家已经放弃了这个制度，代之以发展市场经济。在市场经济中，中央计划者的决策被数千百万企业和家庭的决策所取代。</p><p><br></p><p>在市场经济中，没有一个人追求整个社会的经济福利。自由市场包括大量物品与服务的许多买者与卖者，而所有的人都主要关心自己的福利。</p><p>经济学家亚当·斯密在《国富论》中提出了全部经济学中最著名的观察结果：“家庭和企业在市场上相互交易，他们仿佛被一只<strong>看不见的手</strong>所指引，并导致了合意的市场结果。”</p><p>价格就是看不见的手用来指引经济活动的工具。作为买者与卖者决策的结果，市场价格既反映了一种物品的社会价值，也反映了生产该物品的社会成本。斯密的重要洞察是，价格会自发调整，指引这些单个买者和卖者达到某种结果，该结果在大多数情况下会实现整个社会福利的最大化。</p><p>斯密的观点有一个重要的推论：当政府阻止价格根据供求状况自发调整时，它就限制了看不见的手对组成经济的千百万家庭和企业的决策进行协调的能力。这个推论解释了为什么税收对资源配置有不利的影响：由于税收扭曲了价格，从而也扭曲了家庭和企业的决策。这个推论还解释了像租金控制这类直接控制价格的政策所引起的巨大危害。而且，这个推论解释了中央计划经济的失败。在中央计划经济国家，价格并不是在市场上决定的，而是由中央计划者规定的。这些计划者缺乏关于消费者爱好和生产者成本的必要信息，而在市场经济中这些信息都反映在价格上。中央计划者之所以失败，是因为他们在管理经济时把市场这只看不见的手绑起来了。</p><p>亚当·斯密描述了市场经济中人们如何相互影响：</p><blockquote><p>人类几乎随时随地都需要同胞的协助，要想仅仅依赖他人的恩惠，那是绝对不行的。他如果能够刺激他人的利己心，使其有利于他，并告诉其他人，给他做事是对他们自己有利的，那么他要达到目的就容易得多了。··· ···请给我们我所要的东西吧，同时，你也可以获得你所要的东西：这句话是交易的通义。我们所需要的相互帮助，大部分是依照这个方法取得的。<br>我们每天所需的食物和饮料，不是出自屠户、酿酒师或面包师的恩惠，而是出自他们利己的打算。我们不说唤起他们利他心的话，而说唤起他们利己心得话。我们不说自己有需要，而说对他们有利。社会上，除乞丐外，没有一个人愿意全然靠别人的恩惠过活… …<br>每一个人··· ···既不打算促进公共的利益，也不知道自己是在何种程度上促进那种利益··· ···他所盘算的也只是他自己的利益。在这种场合下，像在其他许多场合一样，他受着一只看不见的手的引导，去尽力达到一个并非他本意想要达到的目的。也并不因为不是出于本意，就对社会有害。他追求自己的利益，往往使他能比在真正处于本意的情况下更有效地促进社会的利益。</p></blockquote><p>斯密是说，经济参与者受利己心所驱动，而市场上这只看不见的手指引这种利己心去促进总体的经济福利。</p><p><br></p><h5 id="政府有时可以改善市场结果"><a href="#政府有时可以改善市场结果" class="headerlink" title="政府有时可以改善市场结果"></a>政府有时可以改善市场结果</h5><ul><li><strong>产权(property rights):</strong><ul><li>个人拥有并控制稀缺资源的能力</li></ul></li><li><strong>市场失灵(market failure):</strong><ul><li>市场本身不能有效的配置资源的情况</li></ul></li><li><strong>外部性(externality):</strong><ul><li>一个人的行为对旁观者福利的影响</li><li>外部性的经典例子是污染</li></ul></li><li><strong>市场势力(market power):</strong><ul><li>单个经济活动者(或某个经济活动小群体)对市场价格有显著影响的能力</li></ul></li></ul><p><br></p><p>我们需要政府的原因之一是：只有在政府实施规则并维持对市场经济至关重要的制度时，看不见的手才能施展其魔力。最重要的是，市场经济需要实施产权制度，以便个人可以拥有和控制稀缺资源。<br>我们都依靠政府提供的警察和法律来实施我们对自己生产出来的东西的权利——而看不见的手依靠我们实施自己权利的能力。</p><p>然而，我们需要政府的另一个原因是：看不见的手是强有力的，但并不是无所不能的。政府干预经济并改变人们自己选择的资源配置的原因有两类：<strong>促进效率</strong>和<strong>促进公平</strong>。这就是说，大多数政策的目标要么是把经济蛋糕做大，要么是改变这个蛋糕的分割方式。</p><p>在存在外部性或市场势力的情况下，设计良好的公共政策可以提高经济效率。</p><p>即使看不见的手带来了有效率的产出，他也不能消除经济福利上巨大的不对称。根据某种政治哲学，这种不平等要求政府进行干预。实际上，许多公共政策，例如所得税和福利制度的目标就是要实现更平等的经济福利分配。</p><p>我们说政府有时可以改善市场结果并不意味着它总会这样。公共政策并不是天使制定的，而是由不完善的政治程序制定的。有时所设计的政策只是为了有利于政治上有权势的人；有时政策是由动机良好但信息不充分的领导人制定的。</p><p><br></p><h4 id="整体经济如何运行"><a href="#整体经济如何运行" class="headerlink" title="整体经济如何运行"></a>整体经济如何运行</h4><p>决策和相互影响共同组成了<strong>经济</strong>。</p><p><br></p><h5 id="一国的生活水平取决于它生产物品与服务的能力"><a href="#一国的生活水平取决于它生产物品与服务的能力" class="headerlink" title="一国的生活水平取决于它生产物品与服务的能力"></a>一国的生活水平取决于它生产物品与服务的能力</h5><ul><li><strong>生产率(productivity):</strong><ul><li>每单位劳动投入所生产的物品与服务数量</li></ul></li></ul><p><br></p><p>世界各国生活水平的差别是惊人的。<br>随着时间的推移，生活水平的变化也是巨大的。</p><p><strong>几乎所有的生活水平的差别都可以归因于各国生产率的差别。</strong></p><p>生产率和生活水平之间的基本关系是简单的，但它的意义却是深远的。如果生产率是生活水平的首要决定因素，那么，其他因素就应该是次要的。</p><p><br></p><h5 id="当政府发行了过多货币时，物价上升"><a href="#当政府发行了过多货币时，物价上升" class="headerlink" title="当政府发行了过多货币时，物价上升"></a>当政府发行了过多货币时，物价上升</h5><ul><li><strong>通货膨胀(inflation):</strong><ul><li>经济中物价总水平的上升</li></ul></li></ul><p><strong>在大多数严重或持续通货膨胀的情况下，罪魁祸首是货币量的增长。</strong></p><p>当一国政府发行了大量本国货币时，货币的价值就下降了。</p><p>由于高通货膨胀会让社会付出各种成本，所以世界各国的经济政策制定者都把保持低通货膨胀作为目标之一。</p><p><br></p><h5 id="社会面临通货膨胀与失业之间的短期权衡取舍"><a href="#社会面临通货膨胀与失业之间的短期权衡取舍" class="headerlink" title="社会面临通货膨胀与失业之间的短期权衡取舍"></a>社会面临通货膨胀与失业之间的短期权衡取舍</h5><ul><li><strong>经济周期(business cycle):</strong><ul><li>就业和经济生产的波动</li></ul></li></ul><p><br></p><p>虽然在长期中，物价水平上升主要是货币增加的结果，但短期中，问题就变得更为复杂更具争议性。</p><p>大多数经济学家这样描述货币注入的短期效应：</p><ul><li>经济中货币量增加刺激了社会的整体支出水平，从而增加了对物品与服务的需求</li><li>需求的增量随着时间的推移，会引起企业提高物价，但同时，它也鼓励企业雇佣更多的工人，并生产更多的产品与服务</li><li>服用更多的工人意味着更少的失业</li></ul><p>你知道，支出链将以乘数扩大，并带来更高的收入和就业。人们看到了发生了的活动，但他们没有看到本来会发生的活动。</p><p><br></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><strong>经济学十大原理：</strong></p><ul><li>人们如何做出决策<ul><li>人们面临权衡取舍</li><li>某种东西的成本是为了得到它所放弃的东西</li><li>理性人考虑边际量</li><li>人们会对激励做出反应</li></ul></li><li>人们如何相互影响<ul><li>贸易可以使每个人的状况都变得更好</li><li>市场通常是组织经济活动的一种好方法</li><li>政府有时可以改善市场结果</li></ul></li><li>整体经济如何运行<ul><li>一国的生活水平取决于它生产物品与服务的能力</li><li>当政府发行了过多的货币时，物价上升</li><li>社会面临通货膨胀与失业之间的短期权衡取舍</li></ul></li></ul><p><br><br><br></p><hr><p><br></p><h3 id="像经济学家一样思考"><a href="#像经济学家一样思考" class="headerlink" title="像经济学家一样思考"></a>像经济学家一样思考</h3><p>每个研究领域都有自己的语言和思考方式。经济学家也一样。<br>供给、需求、弹性、比较优势、消费者剩余和无谓损失——这些术语也是经济学家语言的一部分。</p><p><br></p><h4 id="作为科学家的经济学家"><a href="#作为科学家的经济学家" class="headerlink" title="作为科学家的经济学家"></a>作为科学家的经济学家</h4><p>先提出理论，再收集数据，然后分析数据，以努力证明或否定他们的理论。</p><p><br></p><h5 id="科学方法：观察、理论和进一步观察"><a href="#科学方法：观察、理论和进一步观察" class="headerlink" title="科学方法：观察、理论和进一步观察"></a>科学方法：观察、理论和进一步观察</h5><p>在经济学研究中，进行实验往往是不可能的。通常不得不使用这个世界向他们提供的数据。</p><p>为了寻找实验室实验的替代品，经济学家十分关注历史所提供的自然实验。</p><p><br></p><h5 id="假设的作用"><a href="#假设的作用" class="headerlink" title="假设的作用"></a>假设的作用</h5><p>当我们在研究政策变动在长短不同时间中的影响时，就会做出不同的假设。</p><p><br></p><h5 id="经济模型"><a href="#经济模型" class="headerlink" title="经济模型"></a>经济模型</h5><p>经济学家也用模型来了解世界，但不是塑料模型，而通常是由图形和方程组成的模型。</p><p><br></p><h5 id="第一个模型：循环流量图"><a href="#第一个模型：循环流量图" class="headerlink" title="第一个模型：循环流量图"></a>第一个模型：循环流量图</h5><ul><li><strong>循环流量图(circular-flow diagram):</strong><ul><li>一个说明货币如何通过市场在家庭与企业之间流动的直观经济模型</li></ul></li><li><strong>生产要素(production factors):</strong><ul><li>劳动、土地、资本等投入品被称为生产要素</li></ul></li></ul><p><br></p><p>企业用生产要素来生产产品和服务，家庭则拥有生产要素并消费企业生产的物品与服务。家庭与企业之间相互交易。</p><p><br></p><h5 id="第二个模型：生产可能性边界"><a href="#第二个模型：生产可能性边界" class="headerlink" title="第二个模型：生产可能性边界"></a>第二个模型：生产可能性边界</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《经济学原理-微观/宏观》，曼昆： &lt;a href=&quot;https://book.douban.com/subject/26435630/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://book.douban.com/subject/26435630/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Economics" scheme="https://zhang21.github.io/categories/Economics/"/>
    
    
      <category term="Economics" scheme="https://zhang21.github.io/tags/Economics/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://zhang21.github.io/2018/02/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://zhang21.github.io/2018/02/08/正则表达式/</id>
    <published>2018-02-08T03:33:16.000Z</published>
    <updated>2018-02-24T10:43:37.352Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>《鸟哥的Linux私房菜》</li><li><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">正则表达式维基百科</a></li></ul><p><br><br><br></p><a id="more"></a><p><br></p><h1 id="正则表达式介绍"><a href="#正则表达式介绍" class="headerlink" title="正则表达式介绍"></a>正则表达式介绍</h1><p>正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法(Regular Expression, 在代码中常简写为regex、regexp或RE）。<br>是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p><p><br></p><p>正则表达式的POSIX规范，分为两大流派：</p><ul><li>基本型正则表达式（Basic Regular Expression，BRE）<ul><li><code>grep</code>、<code>vi</code>、<code>sed</code>都属于BRE，是历史最早的正则表达式，因此元字符必须转译之后才具有特殊含义</li></ul></li><li>扩展型正则表达式（Extended Regular Express，ERE）<ul><li><code>egrep</code>、<code>awk</code>则属于ERE，元字符不用转译</li></ul></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="正则表达式基本语法"><a href="#正则表达式基本语法" class="headerlink" title="正则表达式基本语法"></a>正则表达式基本语法</h1><p>一个正则表达式通常被称为一个模式（pattern），用来描述或者匹配一系列匹配某个句法规则的字符串。</p><p><br></p><p>大部分正则表达式有如下结构：</p><ul><li><strong>选择</strong><ul><li><code>|</code>竖线符代表选择(或)，具有最低优先级</li></ul></li><li><strong>数量限定</strong><ul><li>字符后的数量限定符用来限定前面这个字符允许出现的个数</li><li>不加数量限定则代表仅出现一次</li><li>常见的数量限定符包括 <strong>+</strong>、<strong>?</strong>、<strong>*</strong><ul><li><code>+</code>加号代表前面的字符必须至少出现一次 ( $$$&gt;=1$$$ )</li><li><code>?</code>问号代表前面的字符最多只可出现一次 ( $$$1&gt;=?&gt;=0$$$ )</li><li><code>*</code>星号代表前面的字符可不出现，也可出现一次或多次 ($$$&gt;=0$$$)</li></ul></li></ul></li><li><strong>匹配</strong><ul><li><code>()</code>圆括号可以定义操作符的范围和优先度</li></ul></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="PCRE表达式全集"><a href="#PCRE表达式全集" class="headerlink" title="PCRE表达式全集"></a>PCRE表达式全集</h1><p>正则表达式有多种不同的风格。<br>PCRE（Perl兼容正则表达式，Perl Compatible Regular Expression）。适用于Perl或者Python编程语言（grep或者egrep的正则表达式文法是PCRE的子集）</p><p><br></p><p><strong>基础正则表达式</strong></p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>转义字符</td></tr><tr><td>zhang</td><td>匹配文本字符串值<code>zhang</code></td></tr><tr><td>.</td><td>匹配除<code>\r</code>,<code>\n</code>之外的任何单个字符</td></tr><tr><td>竖线l</td><td>匹配竖线两边某一个</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次</td></tr><tr><td>{n}</td><td>n是一个非负整数。匹配n次</td></tr><tr><td>{n,}</td><td>n是一个非负整数。至少匹配n次</td></tr><tr><td>{n,m}</td><td>m和n均为非负整数，匹配n-m次</td></tr><tr><td>[xyz]</td><td>字符集合（character class）。匹配所包含的任意一个字符</td></tr><tr><td>[^xyz]</td><td>排除型字符集合（negated character classes）。匹配未列出的任意字符</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符</td></tr><tr><td>[^a-z]</td><td>排除型的字符范围。匹配任何不在指定范围内的任意字符</td></tr><tr><td>[:name:]</td><td>增加命名字符类（named character class）</td></tr><tr><td>[=elt=]</td><td>增加当前locale下排序（collate）等价于字符“elt”的元素</td></tr><tr><td>[.elt.]</td><td>增加排序元素（collation element）elt到表达式中。这是因为某些排序元素由多个字符组成</td></tr></tbody></table><p><br></p><p><strong>元字符</strong><br>元字符(meta character)，是一种Perl风格的正则表达式，只有一部分文本处理工具支持它。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置</td></tr><tr><td>\B</td><td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”</td></tr><tr><td>\cx</td><td>匹配由x指明的控制字符</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于[0-9]。注意Unicode正则表达式会匹配全角数字字符</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于[^0-9]</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于\x0c和\cL</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于\x0a和\cJ</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于\x0d和\cM</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于[^ \f\n\r\t\v]</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于\x09和\cI</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于\x0b和\cK</td></tr><tr><td>\w</td><td>匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。注意Unicode正则表达式会匹配中文字符</td></tr><tr><td>\W</td><td>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”</td></tr><tr><td>\ck</td><td>匹配控制转义字符。k代表一个字符。等价于“Ctrl-k”。用于ECMA语法</td></tr><tr><td>\xnn</td><td>十六进制转义字符序列。匹配两个十六进制数字nn表示的字符</td></tr><tr><td>\num</td><td>向后引用（back-reference）一个子字符串（substring），该子字符串与正则表达式的第num个用括号围起来的捕捉群（capture group）子表达式（subexpression）匹配。其中num是从1开始的十进制正整数，其上限可能是9[注 2]、31、[注 3]99甚至无限。[注 4]例如：“(.)\1”匹配两个连续的相同字符</td></tr><tr><td>\n</td><td>标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值</td></tr><tr><td>\nm</td><td>3位八进制数字，标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm</td></tr><tr><td>\nml</td><td>如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml</td></tr><tr><td>\un</td><td>Unicode转义字符序列。其中n是一个用四个十六进制数字表示的Unicode字符</td></tr></tbody></table><p><br></p><p><strong>扩展正则表达式</strong></p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>?</td><td>非贪心量化（Non-greedy quantifiers）：当该字符紧跟在任何一个其他重复修饰符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串</td></tr><tr><td>(pattern)</td><td>匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”</td></tr><tr><td>(?:pattern)</td><td>匹配pattern但不获取匹配的子字符串（shy groups)，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用</td></tr><tr><td>(?=pattern)</td><td>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用</td></tr><tr><td>(?!pattern)</td><td>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用</td></tr><tr><td>(?&lt;=pattern)</td><td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反</td></tr><tr><td>(?&lt;!pattern)</td><td>反向否定预查，与正向否定预查类似，只是方向相反</td></tr></tbody></table><p><br><br><br></p><hr><p><br></p><h1 id="POSIX字符组"><a href="#POSIX字符组" class="headerlink" title="POSIX字符组"></a>POSIX字符组</h1><p>POSIX字符类(POSIX character class),是一个形如[:…:]的特殊元序列，它用于匹配特定的字符范围。</p><table><thead><tr><th>POSIX字符组</th><th>说明</th><th>ASCII环境</th><th>Unicode环境</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>字母字符和数字字符</td><td>[a-zA-Z0-9]</td><td>[\p{L&amp;}\p{Nd}]</td></tr><tr><td>[:alpha:]</td><td>字母</td><td>[a-zA-Z]</td><td>\p{L&amp;}</td></tr><tr><td>[:ascii:]</td><td>ASCII字符</td><td>[\x00-\x7F]</td><td>\p{InBasicLatin}</td></tr><tr><td>[:blank:]</td><td>空格字符和制表符</td><td>[ \t]</td><td>[\p{Zs}\t]</td></tr><tr><td>[:cntrl:]</td><td>控制字符</td><td>[\x00-\x1F\x7F]</td><td>\p{Cc}</td></tr><tr><td>[:digit:]</td><td>数字字符</td><td>[0-9]</td><td>\p{Nd}</td></tr><tr><td>[:graph:]</td><td>空白字符之外的字符</td><td>[\x21-\x7E]</td><td>[^\p{Z}\p{C}]</td></tr><tr><td>[:lower:]</td><td>小写字母字符</td><td>[a-z]</td><td>\p{Ll}</td></tr><tr><td>[:print:]</td><td>类似[:graph:]，但包括空白字符</td><td>[\x20-\x7E]</td><td>\P{C}</td></tr><tr><td>[:punct:]</td><td>标点符号</td><td>}~-]</td><td>[\p{P}\p{S}]</td></tr><tr><td>[:space:]</td><td>空白字符</td><td>[ \t\r\n\v\f]</td><td>[\p{Z}\t\r\n\v\f]</td></tr><tr><td>[:upper:]</td><td>大写字母字符</td><td>[A-Z]</td><td>\p{Lu}</td></tr><tr><td>[:word:]</td><td>字母字符</td><td>[A-Za-z0-9_]</td><td>[\p{L}\p{N}\p{Pc}]</td></tr><tr><td>[:xdigit:]</td><td>十六进制字符</td><td>[A-Fa-f0-9]</td><td>[A-Fa-f0-9]</td></tr></tbody></table><p><br><br><br></p><hr><p><br></p><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><table><thead><tr><th>优先权</th><th>符号</th></tr></thead><tbody><tr><td>最高</td><td>\</td></tr><tr><td>高</td><td>( )、(?: )、(?= )、[ ]</td></tr><tr><td>中</td><td>*、+、?、{n}、{n,}、{m,n}</td></tr><tr><td>低</td><td>^、$、中介字符</td></tr><tr><td>次最低</td><td>串接，即相邻字符连接在一起</td></tr><tr><td>最低</td><td>l</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《鸟哥的Linux私房菜》&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;正则表达式维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="RegularExpression" scheme="https://zhang21.github.io/tags/RegularExpression/"/>
    
      <category term="正则表达式" scheme="https://zhang21.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://zhang21.github.io/2018/02/05/Redis/"/>
    <id>https://zhang21.github.io/2018/02/05/Redis/</id>
    <published>2018-02-05T09:20:28.000Z</published>
    <updated>2018-05-28T11:13:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>《Redis官方文档》: <a href="http://www.redis.cn/documentation.html" target="_blank" rel="noopener">http://www.redis.cn/documentation.html</a></li><li>《Redis命令大全》: <a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">http://www.redis.cn/commands.html</a></li></ul><p><br></p><p>环境:</p><ul><li>CentOS7x86_64</li><li>Redis 3.2</li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p><br></p><h2 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h2><p>Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的、非关系型,键值对存储数据库。<br>Redis是一个开源(BSD许可)的,内存中的数据结构存储系统,它可以用作数据库、缓存和消息中间件。</p><p>毫无疑问,Redis开创了一种新的数据存储思路,使用Redis,我们不用在面对功能单调的数据库时,把精力放在如何把大象放进冰箱这样的问题上,而是利用Redis灵活多变的数据结构和数据操作,为不同的大象构建不同的冰箱。希望你喜欢这个比喻。</p><p>Remote Dictionary Server(Redis)是由一个Salvatore Sanfilippo写的key-value储存系统。Redis提供了一些丰富的数据结构,包括lists,sets,ordered sets,hashes,当然还有和Memcached一样的string结构,所以常被称为是一款数据结构服务器(data structure server)。Redis当然还包括了对这些数据结构的丰富操作。</p><p>你可以在这些类型上面运行原子操作,例如,追加字符串,增加哈希中的值,加入一个元素到列表,计算集合的交集、并集和差集,或者是从有序集合中获取最高排名的元素。</p><p><br><br><br></p><h2 id="Redis的优点"><a href="#Redis的优点" class="headerlink" title="Redis的优点"></a>Redis的优点</h2><p>为了满足性能,Redis采用内存(in-memory)数据集(dataset)。根据你的使用场景,你可以通过每隔一段时间转储数据集到磁盘,或者追加每条命令到日志来持久化。持久化也可以被禁用,如果你只是需要一个功能丰富,网络化的内存缓存。</p><ul><li>性能极高,Redis能支持超过100K+每秒的读写频率</li><li>丰富的数据类型,Redis支持二进制案例的Strings,Lists,Hashes,Sets及Ordered Sets数据类型操作</li><li>原子,Redis的所有操作都是原子性的,同时Redis还支持对几个操作全并后的原子性执行</li><li>丰富的特性,Redis还支持publish/sucscribe,通知,key过期等特性</li><li>Redis还支持主从异步复制,非常快的非阻塞初次同步、网络断开时自动重连局部重同步</li></ul><p><br></p><hr><p><br></p><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><p>直接通过<code>yum</code>安装:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y redis</span><br></pre></td></tr></table></figure><p><br></p><p>启动redis-server的两种方式:</p><ul><li>redis-server: standalone模式</li><li>systemctl redis start: daemon模式<ul><li>需要在配置文件中开启daemonize</li></ul></li></ul><p>启动redis-cli:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">redis-cli -a passwd</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h1><p>redis配置文件(/etc/redis.conf)常用参数:</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>daemonize</td><td>以守护进程启动,放置于后台</td></tr><tr><td>bind</td><td>监听地址,建议只对本地127.0.0.1开放</td></tr><tr><td>protect-mode</td><td>redis的保护模式</td></tr><tr><td>requirepass</td><td>设置密码</td></tr><tr><td>timeout</td><td>超时</td></tr><tr><td>tcp-keepalive</td><td>在Linux上,指定值(秒)用于发送ACKs的时间,关闭连接需要双倍的时间,默认为0</td></tr><tr><td>loglevle</td><td>指定日志记录的级别。有四个级别:debug(记录很多信息,用于开发测试)、notice(常用于生产环境)、warning(严重的信息)、verbose(有用的信息)</td></tr><tr><td>logfile</td><td>日志文件,默认为stdout</td></tr><tr><td>databases</td><td>可用数据库,范围在0-(database-1)</td></tr><tr><td>save</td><td>保存数据到磁盘(.rdb)</td></tr><tr><td>stop-writes-on-bgsave-error</td><td>后台储存错误停止写</td></tr><tr><td>rdbcompression</td><td>储存到本地数据库时(持久化到rdb文件)是否压缩</td></tr><tr><td>dbfilename</td><td>本地持久化数据库文件名,默认dump.rdb</td></tr><tr><td>dir</td><td>数据库文件路径,是目录</td></tr><tr><td>salveof</td><td>设置从库</td></tr><tr><td>masterauth</td><td>设置主库认证的密码</td></tr><tr><td>slave-read-only</td><td>设置slave是否只读</td></tr><tr><td>slave-serve-stale-data</td><td>从库同主库失去连接或复制正在进行时,从库是否继续响应客户端请求</td></tr><tr><td>repl-disable-tcp-nodelay</td><td>tcp-nodelay</td></tr><tr><td>slave-priority</td><td>slave优先级,master不能工作后,从众多slave中选出优先值最小的slave提升为master,优先值为0表示不能为master</td></tr><tr><td>appendonly</td><td>是否开启AOF数据备份,redis会把所接收到的每一次写操作请求都追加到appendonly.aof文件,当此文件很大</td></tr><tr><td>appendsync</td><td>AOF文件同步策略,后台会进行大量I/O</td></tr><tr><td>no-appendfsync-on-rewrite</td><td>-</td></tr><tr><td>auto-aof-rewrite-percentage</td><td>aof自动重写</td></tr><tr><td>auto-aof-rewrite-min-size</td><td>指定最小大小用于aof重写</td></tr><tr><td>slowlog-log-slower-than</td><td>慢日志,记录超过特定执行时间的命令,不包括I/o</td></tr><tr><td>slowlog-max-len</td><td>慢日志记录的长度,超过大小,最先进入队列的记录会被踢出</td></tr><tr><td>hash-max-zipmap-entries</td><td>hash将以一种特殊的编码方式(大大减少内存使用)来储存,这是其中一个临界值</td></tr><tr><td>hash-max-zipmap-value</td><td>另一个临界值</td></tr><tr><td>list-max-ziplist-entries</td><td>多个list以特定的方式编码来节省空间</td></tr><tr><td>activerehashing</td><td>Redis将在每100ms时使用1ms的CPU时间来对redis的hash表进行重新hash,可降低内存的使用</td></tr><tr><td>hz</td><td>不是所有任务都以相同的频率执行,但redis按照指定的“hz”值执行检查任务</td></tr><tr><td>aof-rewrite-incremental-fsync</td><td>当一个子节点重写AOF文件时,则文件每生产32m数据进行同步</td></tr></tbody></table><p><br></p><p>官方文档对VM的使用建议:</p><ul><li>当KEY很小而VALUE很大时,使用VM的效果会比较好,因为这样节约内存比较大</li><li>当key不小时,可以考虑使用一些非常方法将很大的key变成value,比如将key,value组合成一个新的value</li></ul><p><br></p><hr><p><br></p><h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><p>Redis不仅仅是简单的key-value存储器,同时也是一种data structure server。传统的key-value是指支持使用一个key字符串来索引value字符串的储存。而Redis中,value不仅仅支持字符串,还支持更多的复杂结构,包括列表、集合、哈希表等。Redis采用二进制安全,这就意味着你可以使用任何二进制序列作为重点。</p><p><br></p><h2 id="字符串-strings"><a href="#字符串-strings" class="headerlink" title="字符串(strings)"></a>字符串(strings)</h2><p>字符串 是一种最基本的Redis值类型。Redis字符串是二进制安全的,这意味着一个Redis字符串能包含任意类型的数据。</p><p>只关心二进制化的字符串,不关心具体格式。只会严格的按照二进制的数据存取。不会妄图已某种特殊格式解析数据。</p><p><br></p><h2 id="列表-lists"><a href="#列表-lists" class="headerlink" title="列表(lists)"></a>列表(lists)</h2><p>Redis列表是简单的字符串列表,按照插入顺序序列,你可以添加一个或多个元素到列表的头部或者尾部。</p><p><br></p><h2 id="散列-hash"><a href="#散列-hash" class="headerlink" title="散列(hash)"></a>散列(hash)</h2><p>Redis Hashes是字符串字段和字符串值之间的映射,因此他们是展现对象的完美数据类型。如一个有姓、名、年龄等属性的用户。一个带有一些字段的hash仅仅需要一块很小的空间储存,因此你可以储存数以百万计的对象在一个小的Redis实例中。</p><p>哈希主要用来表现对象,他们有能力储存很多对象,因此你可以将哈希用于许多其他的任务。</p><p><br></p><h2 id="无序集合-unorder-set"><a href="#无序集合-unorder-set" class="headerlink" title="无序集合(unorder set)"></a>无序集合(unorder set)</h2><p>Redis集合(Set)是一个无序的字符串集合。可以用O(1)的时间复杂度(无论集合中有多少元素时间复杂度都是常量)完成添加、删除、测试元素是否存在。</p><p>Redis集合拥有令人满意的不允许包含相同成员的属性。多次添加相同的元素,最终在集合里只会有一个元素。实际上就是添加元素时无序检测元素是否存在。</p><p>一个Redis集合有趣的事情是它支持一些服务端的命令从现有的集合出发去进行集合运算,因此你可以在非常短的时间内进行合并(unions)、交集(intersections)、找出不同的元素(difference of sets)。</p><p><br></p><h2 id="有序集合-order-set"><a href="#有序集合-order-set" class="headerlink" title="有序集合(order set)"></a>有序集合(order set)</h2><p>Redis有序集合与普通集合非常相似,也是一个没有重复项的字符串集合。不同之处是有序集合的每一个成员都关联了一个评分,这个评分被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的,但是评分可以是重复了。</p><p>使用有序集合可以以非常快的速度(O(log(N)))添加,删除和更新元素。可以很快根据评分(score)或者次序(position)来获取一个范围的元素。访问有序集合的中间元素也是很快的,因此能够使用有序集合作为一个没有重复成员的智能列表。在有序集合中,你可以很快捷的访问一切你需要的东西。</p><p>简而言之,使用有序的集合你可以做完许多对性能有极端要求的任务,而那些任务使用其他类型的数据库真的是很难完成。</p><p><br></p><hr><p><br></p><h1 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h1><p><br></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">exists key    <span class="comment">#判断一个key是否存在</span></span><br><span class="line"></span><br><span class="line">del key    <span class="comment">#删除某个或一系列key</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> key    <span class="comment">#返回某个key元素的数据类型,key不存在返回空</span></span><br><span class="line"></span><br><span class="line">keys key-pattern    <span class="comment">#返回匹配的key列表</span></span><br><span class="line"></span><br><span class="line">randomkey    <span class="comment">#随机获取一个已经存在的key</span></span><br><span class="line"></span><br><span class="line">rename oldname newname<span class="comment">#改key的名字,如果存在将会覆盖</span></span><br><span class="line"></span><br><span class="line">dbsize    <span class="comment">#返回当前数据库的key的总和</span></span><br><span class="line"></span><br><span class="line">expire key time   <span class="comment">#设置某个key的过期时间(秒),到期后自动删除</span></span><br><span class="line"></span><br><span class="line">ttl    <span class="comment">#查询key剩余存活时间</span></span><br><span class="line"></span><br><span class="line">flushdb    <span class="comment">#清空当前数据库中的所有键</span></span><br><span class="line"></span><br><span class="line">flushall    <span class="comment">#清空所有数据库中的键</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="设置相关"><a href="#设置相关" class="headerlink" title="设置相关"></a>设置相关</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config get    <span class="comment">#用来读取Redis服务器的配置参数</span></span><br><span class="line"></span><br><span class="line">config <span class="built_in">set</span>    <span class="comment">#用于更改运行Redis服务器的配置参数</span></span><br><span class="line"></span><br><span class="line">config resetstat    <span class="comment">#重置数据统计报告,通常返回OK</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">quit<span class="comment">#关闭连接</span></span><br><span class="line"></span><br><span class="line">auth<span class="comment">#密码认证</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">help</span> <span class="built_in">command</span><span class="comment">#帮助</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">save<span class="comment">#将数据同步保存到磁盘</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bgsave<span class="comment">#将数据异步保存到磁盘</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lastsave<span class="comment">#返回上次成功将数据保存到磁盘的Unix时戳</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="远程服务"><a href="#远程服务" class="headerlink" title="远程服务"></a>远程服务</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">info<span class="comment">#服务器信息统计,基本所有信息</span></span><br><span class="line"></span><br><span class="line">monitor<span class="comment">#实时转储收到的请求</span></span><br><span class="line"></span><br><span class="line">slaveof<span class="comment">#改变复制策略</span></span><br><span class="line"></span><br><span class="line">shutdown<span class="comment">#将数据同步保存到磁盘,然后关闭服务</span></span><br><span class="line"></span><br><span class="line">server<span class="comment">#Redis server的常规信息</span></span><br><span class="line"></span><br><span class="line">clients<span class="comment">#Client的连接选项</span></span><br><span class="line"></span><br><span class="line">memory<span class="comment">#存储占用相关信息</span></span><br><span class="line"></span><br><span class="line">persistence<span class="comment">#RDB and AOF 相关信息</span></span><br><span class="line"></span><br><span class="line">stats<span class="comment">#常规统计</span></span><br><span class="line"></span><br><span class="line">replication<span class="comment">#Master/slave请求信息</span></span><br><span class="line"></span><br><span class="line">cpu<span class="comment">#CPU占用信息统计</span></span><br><span class="line"></span><br><span class="line">cluster<span class="comment">#Redis 集群信息</span></span><br><span class="line"></span><br><span class="line">keyspace<span class="comment">#数据库信息统计</span></span><br><span class="line"></span><br><span class="line">all<span class="comment">#返回所有信息</span></span><br><span class="line"></span><br><span class="line">default<span class="comment">#返回常规设置信息</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="值-value-操作"><a href="#值-value-操作" class="headerlink" title="值(value)操作"></a>值(value)操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">exists key<span class="comment">#判断一个key是否存在</span></span><br><span class="line"></span><br><span class="line">del key<span class="comment">#删除一个key</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> key<span class="comment">#返回值的类型</span></span><br><span class="line"></span><br><span class="line">keys pattern<span class="comment">#返回满足给定模式的所有key</span></span><br><span class="line"></span><br><span class="line">randomkey<span class="comment">#随机返回key空间的一个</span></span><br><span class="line"></span><br><span class="line">rename oldname newname<span class="comment">#改key的名字,如果存在将会覆盖</span></span><br><span class="line"></span><br><span class="line">dbsize<span class="comment">#返回当前数据库中key的数目</span></span><br><span class="line"></span><br><span class="line">expire<span class="comment">#设定一个key的活动时间(s)</span></span><br><span class="line"></span><br><span class="line">ttl<span class="comment">#获得一个key的活动时间</span></span><br><span class="line"></span><br><span class="line">select index<span class="comment">#按索引查询</span></span><br><span class="line"></span><br><span class="line">move key dbindex<span class="comment">#移动当前数据库中的key到dbindex数据库</span></span><br><span class="line"></span><br><span class="line">flushdb<span class="comment">#删除当前选择的数据库中的所有key</span></span><br><span class="line"></span><br><span class="line">flushall<span class="comment">#删除所有数据库中的所有key</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="字符串-string-操作"><a href="#字符串-string-操作" class="headerlink" title="字符串(string)操作"></a>字符串(string)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">set key value           #给数据库中名称为key的string赋值value</span><br><span class="line"></span><br><span class="line">get key                         #返回数据库中名为key的string的value</span><br><span class="line"></span><br><span class="line">getset key value                #给名称为key的string赋予上一次的value</span><br><span class="line"></span><br><span class="line">mget key1 key2 ... key N                #返回库中多个string的value</span><br><span class="line"></span><br><span class="line">setnx key value         #添加string 名称为key 值为value</span><br><span class="line"></span><br><span class="line">setex key time value            #向库中添加string 设定过期时间time</span><br><span class="line"></span><br><span class="line">mset key 1 value 1 ... key N value N            #批量设置多个string的值</span><br><span class="line"></span><br><span class="line">msetnx key 1 value 1 ... key N value N          #如果所有名称为 key N的string都不存在 则向库中添加string 名称为 key N赋值value N</span><br><span class="line"></span><br><span class="line">incr key                #名称为key的string加 1 操作</span><br><span class="line"></span><br><span class="line">incrby key integer              #名称为key的string增减integer</span><br><span class="line"></span><br><span class="line">decr key                #名称为key的string减1操作</span><br><span class="line"></span><br><span class="line">decrby key integer              #名称为key的string的值附加value</span><br><span class="line"></span><br><span class="line">append key value                #名称为key的值附加value</span><br><span class="line"></span><br><span class="line">substr key start end            #返回名称为key的string的value的子串</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="列表-list-操作"><a href="#列表-list-操作" class="headerlink" title="列表(list)操作"></a>列表(list)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">rpush key value                 #在名称为key的list尾部添加一个值为value的元素</span><br><span class="line"></span><br><span class="line">lpush key value                 #在名称为key的list首部添加一个值为value的元素</span><br><span class="line"></span><br><span class="line">llen key                #返回名称为key的list的长度</span><br><span class="line"></span><br><span class="line">lrange key start end            #返回名称为key的list中start至end之间的元素 下表从0开始</span><br><span class="line"></span><br><span class="line">ltrim key start end             #截取名称为key的list 保留start至end之间的元素</span><br><span class="line"></span><br><span class="line">lindex key index                #返回名称为key的list中index位置的元素</span><br><span class="line"></span><br><span class="line">lset key index value            #给名称为key的list中index位置的元素赋值value</span><br><span class="line"></span><br><span class="line">lrem key count value            #删除count个名称为key的list中值为value的元素</span><br><span class="line"></span><br><span class="line">brpop key1 key2 ... keyN               #rpop的block版本</span><br><span class="line"></span><br><span class="line">rpoplpush srckey dstkey                 #返回并删除名为srckey的list尾元素 并将该元素添加到名为dstkey的list的头部</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="集合-set-操作"><a href="#集合-set-操作" class="headerlink" title="集合(set)操作"></a>集合(set)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">sadd key member                 #向名为key的set中添加元素member</span><br><span class="line"></span><br><span class="line">srem key member                 #删除名为key的set中元素的member</span><br><span class="line"></span><br><span class="line">spop key                #随机返回并删除名为key的set中的一个元素</span><br><span class="line"></span><br><span class="line">smove srckey dstkey member              #将member元素从名为srckey的集合移动到名为dstkey的集合</span><br><span class="line"></span><br><span class="line">scard key               #返回名为key的set的基数</span><br><span class="line"></span><br><span class="line">sismember key member            #测试member是否是名称为key的set的集合</span><br><span class="line"></span><br><span class="line">sinter key1 key2 ... key N              #求交集</span><br><span class="line"></span><br><span class="line">sinterstore dstkey key1 ... key N               #求交集并将交集保存到dstkey的集合</span><br><span class="line"></span><br><span class="line">sunion key1 ... key N           #求并集</span><br><span class="line"></span><br><span class="line">sunionstore dstkey key 1 ... key N              #求并集并将并集保存到dstkey的集合</span><br><span class="line"></span><br><span class="line">sdiff key1 ... key N            #求差集</span><br><span class="line"></span><br><span class="line">sdiffstore dstkey key 1 ... key N               #求差集并将差集保存到dstkey的集合</span><br><span class="line"></span><br><span class="line">smembers key            #返回名为key的set的所有元素</span><br><span class="line"></span><br><span class="line">srandmember key                 #随机返回名为key的set的一个元素</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="有序集合-sorted-set-操作"><a href="#有序集合-sorted-set-操作" class="headerlink" title="有序集合(sorted set)操作"></a>有序集合(sorted set)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zadd key score member           #向名为key的zset中添加元素member score用于排序 如果该元素已经存在 则根据</span><br><span class="line">score更新该元素的顺序</span><br><span class="line"></span><br><span class="line">zrem key member                 #删除名为key的zset中的元素member</span><br><span class="line"></span><br><span class="line">zincrby key increment member            #如果在名为key的zset中已经存在元素member 则该元素的score增加increment 否则向集合中添加该元素 其score的值为increment</span><br><span class="line"></span><br><span class="line">zrank key member                #返回名为key的zset 顺序</span><br><span class="line"></span><br><span class="line">zrevrank key member             #返回名为key的zset 倒序</span><br><span class="line"></span><br><span class="line">zrange key start end            #返回名为key的zset score顺序按index从start到end返回所有元素</span><br><span class="line"></span><br><span class="line">zrevrange key start end                 #返回名为key的zset score倒序按index从start到end返回所有元素</span><br><span class="line"></span><br><span class="line">zrangebyscore key min max               #返回名为key的zset中score大于等于min 小于等于max的所有元</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="hash操作"><a href="#hash操作" class="headerlink" title="hash操作"></a>hash操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">hset key field value            #向名为key的hash中添加元素filed----value</span><br><span class="line"></span><br><span class="line">hget key field          #返回名为key的hash中field对应的value</span><br><span class="line"></span><br><span class="line">hmset key field1 value1 ... field N value N             #向名为key的hash中添加元素field----value</span><br><span class="line"></span><br><span class="line">hmget key field1 ... field N            #返回名为key的hash中filed对应的value</span><br><span class="line"></span><br><span class="line">hincrby key field integer               #将名为key的hash中field的value增加integer</span><br><span class="line"></span><br><span class="line">hexists key field               #名为key的hash中是否存在键为field的域</span><br><span class="line"></span><br><span class="line">hdel key field          #删除名为key的hash中键为field的域</span><br><span class="line"></span><br><span class="line">hlen key                #返回名为key的hash中元素个数</span><br><span class="line"></span><br><span class="line">hkeys key               #返回名为key的hash中所有键</span><br><span class="line"></span><br><span class="line">hvals key               #返回名为key的hash中所有键对应的value</span><br><span class="line"></span><br><span class="line">hgetall key     #返回名为key的hash中所有的键 field 及其对应的value</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="Redis高级应用"><a href="#Redis高级应用" class="headerlink" title="Redis高级应用"></a>Redis高级应用</h1><p>Redis高级应用包括<strong>安全性设置、主从复制、事务处理、持久化机制和虚拟内存的使用</strong>。</p><p><br><br><br></p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>由于redis速度相当快，一秒钟可以150K次密码尝试，所以需要设置一个密码强度很强大的密码。</p><p>设置密码的两种方法：</p><ul><li><code>config set requirepass &quot;passwd&quot;</code>，通过命令设置密码</li><li>直接在配置文件中<code>requirepass</code>属性后加上密码</li></ul><p>认证登录的两种方式：</p><ul><li><code>redis-cli -a passwd</code></li><li><code>redi-cli</code> –&gt; <code>auth passwd</code></li></ul><p><br><br><br></p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>Redis的主从复制的配置和使用都比较简单。</p><ul><li>master server</li><li>slave server</li></ul><p>Redis主从复制特点：</p><ul><li>一主多从</li><li>当master宕机后，优先级值小的那台slave server自动转变为master</li><li>主从复制不同阻塞master，在同步数据时master可以继续处理client的请求</li><li>提高了系统的可伸缩性</li></ul><p>Redis主从复制过程：</p><ul><li>slave与master建立连接，发送sync同步命令</li><li>master会启动一个后台进程，将数据库快照保存到文件中，同时master主进程会开始收集新的写命令并缓存</li><li>后台完成保存后，就将此文件发送给slave</li><li>slave将文件保存在磁盘上</li></ul><p><br></p><h3 id="主从复制栗子"><a href="#主从复制栗子" class="headerlink" title="主从复制栗子"></a>主从复制栗子</h3><p>Redis主从配置，一主多从。<br>注意：由于redis吃内存，可能会由于内存过小而无法正常启动redis，可查看<code>/var/log/message</code>。</p><p><br></p><p><strong>配置master</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/redis_master.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">daemon yes</span><br><span class="line">bind 127.0.0.1 ip1</span><br><span class="line">port 6379</span><br><span class="line">requirepass fuza_mima</span><br><span class="line">protect-mode yes</span><br><span class="line">datebases 100</span><br><span class="line">logfile /var/log/redis/redis_master.log</span><br><span class="line">dir /var/lib/redis_master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir /var/lib/redis_master</span><br><span class="line">chown redis:redis /var/lib/redis_master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start redis</span><br></pre></td></tr></table></figure><p><strong>配置slave</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/redis_slave.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">daemon yes</span><br><span class="line">bind 127.0.0.1</span><br><span class="line">port 6379</span><br><span class="line">protect-mode yes</span><br><span class="line">logfile /var/log/redis/redis_slave.log</span><br><span class="line">dir /var/lib/redis_slave</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">slaveof &lt;master-ip&gt; &lt;master-port&gt;</span><br><span class="line">masterauth &lt;master-passwd&gt;</span><br><span class="line">slave-read-only yes</span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line">#master挂掉后，从slave中选出优先级最小的作为master</span><br><span class="line"></span><br><span class="line">······</span><br><span class="line">#其他具体主从参数自己配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir /var/lib/redis_slave</span><br><span class="line">chown redis:redis /var/lib/redis_slave</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start redis</span><br></pre></td></tr></table></figure><p><br></p><p><strong>测试master</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a xxx</span><br><span class="line"></span><br><span class="line">set name zhang</span><br><span class="line">get zhang</span><br></pre></td></tr></table></figure><p><strong>测试slave</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">auth(&apos;passwd&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key *</span><br><span class="line">get zhang</span><br></pre></td></tr></table></figure><p><br></p><p><strong>注意</strong>：</p><p>由于Redis只是主从，并不像MongoDB的集群功能。当Redis master挂掉以后，虽然优先级较小的slave成为了master，但从库是无法更新数据的。这点也可以从Redis从的配置文件中看出，连接到Redis主的IP：PORT，并通过主的密码来认证。</p><p><br><br><br></p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>Redis的主从模式，并不支持高可用。<br>不过，Redis引进了哨兵模式(sentinel)，提供Redis实时监控和故障检测恢复的功能。<br>Redis Sentinel 是 Redis 的官方高可用解决方案，是设计用来帮助管理 Redis 实例的系统。</p><p>运行 Sentinel 强制使用配置文件，这个文件被系统用来保存当前状态，在重启时能重新加载。如果没有指定配置文件，或者配置文件的路径不可写，Sentinel 将拒绝启动。<br>Sentinel 运行时默认监听 TCP 端口 26379，所以为了让 Sentinel 正常运行，你的服务器必须开放 26379 端口，以接受从其他 Sentinel 实例 IP 地址的连接。否则，Sentinel 间就没法通信，没法协调，也不会执行故障转移。</p><p>Redis Sentinel 是一个分布式系统，这意味着，你通常想要在你的基础设施中运行多个 Sentinel 进程，这些进程使用 gossip 协议来判断一台主服务器是否下线(down)，使用 agreement 协议来获得授权以执行故障转移，并更新相关配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The redis-sentinel command is a symbolic link to the redis-server command which imply the --sentionel option.</span><br><span class="line"></span><br><span class="line">redis-server [ configuration_file ] [ options ] --sentinel</span><br><span class="line">redis-sentinel [ configuration_file ] [ options ]</span><br></pre></td></tr></table></figure><p><br></p><p>Redis Sentinel用于完成如下4个任务：</p><ul><li><p>监控(Monitoring)<br>Sentinel 不断检查你的主从实例是否运转正常。</p></li><li><p>通知(Notification)<br>Sentinel 可以通过 API 来通知系统管理员，或者其他计算机程序，被监控的Redis实例出了问题。</p></li><li><p>自动故障转移(Automatic failover)<br>如果一台主服务器运行不正常，Sentinel 会开始一个故障转移过程，将从服务器提升为主服务器，配置其他的从服务器使用新的主服务器，使用 Redis 服务器的应用程序在连接时会收到新的服务器地址通知。</p></li><li><p>配置提供者(Configuration provider)<br>Sentinel 充当客户端服务发现的权威来源：客户端连接到 Sentinel 来询问某个服务的当前 Redis 主服务器的地址。当故障转移发生时，Sentinel 会报告新地址。</p></li></ul><p><br></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Redis Sentinel示例配置文件：</p><p>只需要指定需要监控的主服务器，并给主服务器去一个名字；<br>没有必要指定从服务器，因为它们会被自动发现；<br>每一次故障转移时，将一台从服务器提升为主服务器都会重写配置文件；<br>无论你指定多少个同意来检测实例是否正常工作，Sentinel 需要系统中已知的大多数 Sentinel 的投票才能开始故障转移，并且在故障转移之后获取一个新的配置纪元(configuration Epoch) 赋予新的配置；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#默认26379端口</span><br><span class="line">#sentinel  &lt;option_name&gt;  &lt;master_name&gt;  &lt;option_value&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#仲裁数为2</span><br><span class="line">sentinel  monitor  mymaster  127.0.0.1  6379  2</span><br><span class="line"></span><br><span class="line">#哨兵认为实例不可达的毫秒数</span><br><span class="line">sentinel  down-after-milliseconds  mymaster  60000</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">sentinel  failover-timeout  mymaster  180000</span><br><span class="line"></span><br><span class="line">#在一次故障转移之后，被配置为同时使用新主服务器的从服务器数量</span><br><span class="line">sentinel  parallel-syncs  mymaster  1</span><br><span class="line"></span><br><span class="line"># master 有密码就要使用,</span><br><span class="line">#sentinel auth-pass mymaster ****</span><br><span class="line"></span><br><span class="line">sentinel  monitor  resque  192.168.1.3  6380  4</span><br><span class="line">sentinel  down-after-milliseconds  resque  10000</span><br><span class="line">sentinel  failover-timeout  resque  180000</span><br><span class="line">sentinel  parallel-syncs  resque  5</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>Redis的事务处理比较简单。只能保证client发起的事务中的命令可以连续的执行，而且不会插入其他的client命令。</p><p>当一个client在连接中发出multi命令时，这个连接就进入一个事务的上下文，该连接后续的命令不会执行，而是存放在一个队列中，当执行exec命令时，redis会顺序的执行队列中的所有命令。如果其中执行出现错误，执行正确的不会回滚，不同于关系型数据库的事务。</p><p><br><br><br></p><h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>持久化就是把数据从内存保存到硬盘。</p><p>Redis是一个支持持久化的内存数据库，Redis需要经常将内存中的数据同步到磁盘来保证持久化。</p><p>Redis支持两种持久化方式：</p><ol><li>snapshotting(快照)<ul><li>将数据存放到文件里，默认方式。默认写入dump.rdb二进制文件中</li><li>可配置redis在n秒内超过m个key被修改就自动做快照</li><li>save 500 10 –&gt; 500s内超过10个key被修改，则保存快照</li></ul></li></ol><p>由于快照方式在一定间隔时间做一次保存， 如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。<br>AOF比快照方式有更好的持久化性，是由于使用aof时，redis会将每一个收到的写命令都通过write函数写入到文件中当redis启动时会通过重新执行文件中保存的写命令在内存中重新建立整个数据库的内容。</p><ol><li>appendonly file(AOF)<ul><li>aof方式redis会将每一次的函数都追加到文件中，当redis重启时会重新执行文件中保存的命令</li></ul></li></ol><p><br></p><p>配置文件参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启用aof持久化方式</span></span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"><span class="comment">#每秒写入磁盘一次，在性能和持久化方面做了很好的折中</span></span><br><span class="line">appendonly everysc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将数据写入磁盘</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>Redis的虚拟内存是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出内存空间用于其它的访问数据。<br>对于redis这样的内存数据库，内存总是不够用的。</p><p>在配置文件(/etc/redis.conf)中配置VM:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启vm功能</span></span><br><span class="line">vm-enableyes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#交换出来的value保存的文件路径</span></span><br><span class="line">vm-swap-file    /tmp/redis.swap</span><br><span class="line"></span><br><span class="line"><span class="comment">#redis使用的最大内存上线</span></span><br><span class="line">vm-max-memory 10000000</span><br><span class="line"></span><br><span class="line"><span class="comment">#每个页面的大小32字节</span></span><br><span class="line">vm-page-size 32</span><br><span class="line"></span><br><span class="line"><span class="comment">#最多使用多少个页面</span></span><br><span class="line">vm-pages 123217729</span><br><span class="line"></span><br><span class="line"><span class="comment">#用于执行value对象换入的工作线程数量</span></span><br><span class="line">vm-max-threads 4</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>Redis监听地址<code>bind： x.x.x.x</code>，强烈建议只对本地<code>127.0.0.1</code>开放。不建议对外网开放，有安全隐患</li><li>防火墙，最简单就是关闭防火墙，另一个就是开放redis的监听端口</li><li>开启守护进程，让redis可以在后台运行而不必通过<code>redis-server</code>的方式来启动，将配置文件里的<code>deamonize no</code>改为<code>yes</code></li><li>关闭redis的保护模式(protect-mode)，这里的保护模式是指是否允许其他IP的设备访问redis。如果开启的话就只能允许本机访问。如果是生产开发的实际运行环境，请一定开启保护模式</li><li>设置redis数据库密码！不仅仅是redis，任何数据库都应该设置密码，否则对外网开放的数据库就成了活靶子。</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h1><ul><li>Redis支持多个数据库</li><li>类似于其它数据库，不同的数据存储在不同的数据库中</li><li>Redis下，数据库是由一个整数索引标识，而不是数据库名称。默认情况下，客户端连接到<code>数据库0</code></li><li>Redis不支持自定义数据库名称，所以需要开发者记录那些数据库存储了哪些数据</li><li>Redis不支持为每个数据库设置不同的访问密码，因为密码是在配置文件中设置的。所以一个用户可对所有数据库进行访问</li><li>Redis默认支持16个数据库，但可在配置文件中修改</li><li>使用<code>SELECT</code>命令切换数据库</li><li><code>FLUSHALL</code>命令或清除所有数据库，请注意</li></ul><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redis.conf</span><br><span class="line"></span><br><span class="line"># Set the number of databases. The default database is DB 0, you can select</span><br><span class="line"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="line"># dbid is a number between 0 and &apos;databases&apos;-1</span><br><span class="line">databases 16</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Redis官方文档》: &lt;a href=&quot;http://www.redis.cn/documentation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.redis.cn/documentation.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Redis命令大全》: &lt;a href=&quot;http://www.redis.cn/commands.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.redis.cn/commands.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7x86_64&lt;/li&gt;
&lt;li&gt;Redis 3.2&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="https://zhang21.github.io/categories/Database/"/>
    
    
      <category term="Redis" scheme="https://zhang21.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>计算机集群</title>
    <link href="https://zhang21.github.io/2018/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4/"/>
    <id>https://zhang21.github.io/2018/02/03/计算机集群/</id>
    <published>2018-02-03T05:56:45.000Z</published>
    <updated>2018-02-24T10:47:08.777Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>《老男孩Linux运维》</li><li>《服务器集群系统各概念》: <a href="https://segmentfault.com/a/1190000009923581" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009923581</a></li><li>《WEB的负载均衡、集群、高可用解决方案》： <a href="https://zhuanlan.zhihu.com/p/23826048" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23826048</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4" target="_blank" rel="noopener">计算机集群维基百科</a></li></ul><p><br></p><a id="more"></a><hr><p><br></p><h1 id="计算机集群"><a href="#计算机集群" class="headerlink" title="计算机集群"></a>计算机集群</h1><p>计算机集群简称<strong>集群</strong>(Clusters)，是一种计算机系统。它通过一组散列集成的软件或硬件 连接起来高度紧密地协作完成计算工作。在某种意义上，他们可以被看做是一台计算机。</p><p>集群就是指一组（若干）相互独立的计算机，利用高速通信网络组成的一个较大的计算机服务系统，每个集群结点都是运行各自服务的独立服务器。这些服务器之间可以彼此通信，协同向用户提供应用程序、系统资源和数据，并以单一系统的模式加以管理。</p><p>当客户机请求集群系统时，集群给用户的感觉就是一个单一独立的服务器，而实际上用户请求的是一组集群服务器。</p><p>集群系统中的单个计算机通常称为节点，通常通过内网连接，但也有其它的可能连接方式。集群计算机通常用来改进单个计算机的计算速度和可靠性。</p><p><br><br><br></p><h2 id="服务器集群概念"><a href="#服务器集群概念" class="headerlink" title="服务器集群概念"></a>服务器集群概念</h2><p>集群、冗余、负载均衡、主从复制、读写分离、分布式、分布式计算、分布式计算平台、并行计算……</p><p>实际生产环境中常有的问题：</p><ul><li>当数据库性能遇到问题时，是否能够横向扩展，通过添加服务器的方式达到更高的吞吐量，从而充分利用现有的硬件实现更好的投资回报率;</li><li>是否拥有实时同步的副本，当数据库面临灾难时，可以短时间内通过故障转移的方式保证数据库的可用性。此外，当数据丢失或损坏时，能否通过所谓的实时副本（热备）实现数据的零损失;</li><li>数据库的横向扩展是都对应用程序透明，如果数据库的横向扩展需要应用程序端进行大量修改，则所带来的后果不仅仅是高昂的开发成本，同时也会带来很多潜在和非潜在的风险.</li></ul><p><br></p><h3 id="集群和冗余"><a href="#集群和冗余" class="headerlink" title="集群和冗余"></a>集群和冗余</h3><p>集群和冗余并不对立，多台服务器做集群（不是主从），本身就有冗余和负载均衡的效果。<br>狭义上来说，集群就是把多台服务器虚拟成一台服务器，而冗余的每台服务器都是独立的。</p><ul><li>集群的侧重点在于协同，多台服务器系统分担工作，提升效率；</li><li>冗余的侧重点在于防止单点故障，一主多备的架构，也就是主从复制；</li></ul><blockquote><p>数据冗余==高可用性==主从</p></blockquote><ul><li>主从一定程度上起到了负载均衡的作用，但主要目的还是为了保证数据冗余和高可用性</li><li>主从只提供一种成本较低的数据备份方案加上不完美的灾难和负载均衡，由于复制存在时间差，不能同步读，所以只是不完善的负载均衡和有损灾备</li><li>主从显然达不到集群的严格度，不论是 HA 还是 AA（多活并行集群），主从都达不到数据一致性的集群要求</li></ul><p><br><br><br></p><h2 id="为什么要使用集群"><a href="#为什么要使用集群" class="headerlink" title="为什么要使用集群"></a>为什么要使用集群</h2><ul><li>高性能（Performance）<br>  大型网站谷歌、淘宝、百度等，都不是几台大型机可以构建的，都是上万台服务器组成的高性能集群，分布于不同的地点。<br>  只有当并发或总请求数量超过单台服务器的承受能力时，服务器集群的优势才会体现出来。</li><li>价格有效性（Cost-effectiveness）<br>  在达到同样性能的需求下，采用计算机集群架构比采用同等运算能力的大型计算机具有更高的性价比。</li><li>可伸缩性（Scalability）<br>  当服务负载、压力增长时，针对集群系统进行较简单的扩展即可满足需求，且不会降低服务质量。</li><li>高可用（Availability）<br>  单一计算机发生故障时，就无法正常提供服务；而集群架构技术可以是得系统在若干硬件设备发生故障时仍可以继续工作。<br>  集群系统在提高系统可靠性的同时，也大大减小了系统故障带来的业务损失，目前几乎100%的网站都要求7x24h提供服务。</li><li>透明性（Transparency）<br>  多个独立计算机组成的耦合集群系统构成一个虚拟服务器。用户访问集群系统时，就像访问一台高性能、高可用的服务器一样，集群中一部分服务器的上线、下线不会中断整个系统服务，这对用户也是透明的。</li><li>可管理性（Manageability）<br>  这个系统可能在物理上很大，但其实很容易管理，就像管理一个单一映像系统一样。</li><li>可编程性（Programmability）<br>  在集群系统上，容易开发及修改各类应用程序。</li></ul><p><br></p><hr><p><br></p><h1 id="集群分类"><a href="#集群分类" class="headerlink" title="集群分类"></a>集群分类</h1><p>集群分为同构和异构，他们区别在于 “组成集群系统的计算机之间的体系结构是否相同”。</p><p>集群计算机按功能和结构可以分为以下几类：</p><ul><li>均衡集群（Load balancing clusters）</li><li>用性集群（High-availability clusters）</li><li>能计算集群（High-performance cluster）</li><li>计算集群（Grid computing）</li></ul><blockquote><p>负载均衡集群（LB）和高可用性集群（HA）是互联网行业常用的集群架构模式</p></blockquote><p><br><br><br></p><h2 id="负载均衡集群"><a href="#负载均衡集群" class="headerlink" title="负载均衡集群"></a>负载均衡集群</h2><p><strong>负载均衡集群用于抗并发。</strong></p><blockquote><p>负载均衡集群典型的开源软件包括：LVS、Nginx、Haproxy 等。</p></blockquote><p><br></p><p>负载均衡集群可以把很多客户集中的访问请求负载压力尽可能平均分摊在计算机集群中处理。<br>集群中每个节点都可以一定的访问请求负载压力，并且可以实现访问请求在各节点之间动态分配，以实现负载均衡。<br>负载均衡集群运行时，一般是通过一个或多个前端负载均衡器（Director）将客户访问请求分发到后端的一组服务器上，从而达到整个系统的高性能和高可用性。<br>一般高可用性集群和负载均衡集群会使用类似的技术，或同时具有高可用性与负载均衡的特点。</p><p>Linux虚拟服务器（LVS）项目 在Linux操作系统上提供最常用的负载均衡软件。</p><p><br></p><p>负载均衡的作用：</p><ul><li>用户访问请求及数据流量（负载均衡）</li><li>业务连续性，即7x24h服务（高可用）</li><li>于Web业务及数据库从库等服务器的业务</li></ul><p><br><br><br></p><h2 id="高可用性集群"><a href="#高可用性集群" class="headerlink" title="高可用性集群"></a>高可用性集群</h2><p><strong>高可用性集群用于避免单点故障。</strong></p><blockquote><p>高可用性集群常用开源软件包括：Keepalived、Heartbeat 等。</p></blockquote><p><br></p><p>一般是指集群中任意一个节点失效的情况下，该节点上的所有任务会自动转移到其他正常的节点上。此过程不会影响整个集群的运行。</p><p>当集群中的一个节点系统发生故障时，运行着的集群服务器会迅速做出反应，将该系统的服务分配到集群中其他正在工作的系统上运行。考虑到计算机硬件和软件的容错性，高可用性集群的主要目的是使局群的整体服务尽可能可用。<br>如果高可用集群中的主节点发生了故障，那么这段时间内将由备节点代替它。备节点通常是主节点的镜像。当它代替主节点时，它可以完全接管主节点（包括Ip和其他资源）提供服务，因此，使集群系统环境对系统环境来说是一致的，既不会影响用户的访问。</p><p>高可用性集群使服务器系统的运行速度和响应速度会尽可能的快。它们经常利用在多台机器上运行的冗余节点和服务来相互跟踪。<br>如果某个节点失败，它的替补者将在几秒钟或更多时间内接管它的职责。因此，对于用户来说，集群里的任意一台机器宕机，业务都不会受影响。</p><p>高可用性集群的作用：</p><ul><li>当一台机器宕机后，另外一台机器接管宕机的机器的Ip资源和服务资源，提供服务；</li><li>常用于不易实现负载均衡的应用，如负载均衡器、主数据库、主存储对之间；</li></ul><p><br><br><br></p><h2 id="高性能计算集群"><a href="#高性能计算集群" class="headerlink" title="高性能计算集群"></a>高性能计算集群</h2><p>高性能计算集群也称并行计算。通常，高性能计算集群涉及为集群开发的并行应用程序，以解决复杂的科学问题。</p><p>高性能计算集群对外就好像一个超级计算机，这种超级计算机内部由数万个独立服务器组成，并且在公共消息传递层上进行通信以运行并行应用程序。</p><p><br><br><br></p><h2 id="高可用与负载均衡有什么区别"><a href="#高可用与负载均衡有什么区别" class="headerlink" title="高可用与负载均衡有什么区别"></a>高可用与负载均衡有什么区别</h2><ul><li>HA偏重于备用资源，切机时会有业务的断开的，保证了数据的安全，但造成资源的浪费；</li><li>LB侧重于资源的充分应用，没有主备的概念，只有资源的最大限度的加权平均应用，基本不会业务的中断；</li><li>HA的目的是不中断服务，LB的目的是为了提高接入能力。虽然经常放一起用，但确实是两个不同的领域；</li><li>HA在一条路不通的时候提供另一条路可走，而 LB 就类似于是春运时的多个窗口；</li></ul><p><br></p><hr><p><br></p><h1 id="集群软硬件"><a href="#集群软硬件" class="headerlink" title="集群软硬件"></a>集群软硬件</h1><p><br></p><p>企业运维中常见集群产品：</p><ul><li>开源集群软件：<pre><code>+ Nginx, LVS, Haproxy, Keepalived, Heartbear...</code></pre></li><li>商业集群硬件：<pre><code>+ F5， Netscaler,Radware, A10...</code></pre></li></ul><p>如何选择开源集群软件：</p><ul><li>网站在并发访问和总访问量不是很大的情况下，建议首选Nginx负载均衡，Nginx配置简单使用方便安全稳定。 另一个实现负载均衡的产品为Haproxy</li><li>如果要考虑Nginx负载均衡的高可用功能，建议首选Keepalived软件，因为安装配置简单方便稳定。类似高可用软件还有Heartbeat，但比较复杂</li><li>如果是大型企业，负载均衡可以使用 LVS+Keepalived 在前端做四层转发，后端使用Nginx或Haproxy做七层转发，再后面是应用服务器。如果是数据库与存储的负载均衡和高可用，可选用<code>LVS+Heartbeat</code></li></ul><p><img src="/images/Zabbix/cluster.png" alt=""></p><p><br></p><hr><p><br></p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>所谓负载均衡，就是把大访问量分发给不同的服务器，也就是分流请求。</p><p><br></p><h2 id="HTTP重定向协议实现负载均衡"><a href="#HTTP重定向协议实现负载均衡" class="headerlink" title="HTTP重定向协议实现负载均衡"></a>HTTP重定向协议实现负载均衡</h2><p>HTTP 重定向就是应用层的请求转发，用户的请求其实已经到了HTTP重定向负载均衡服务器，服务器根据算法要求用户重定向，用户收到重定向请求后，再次请求真正的集群.</p><ul><li>优点：简单</li><li>缺点：性能较差</li></ul><p><br><br><br></p><h2 id="DNS域名解析负载均衡"><a href="#DNS域名解析负载均衡" class="headerlink" title="DNS域名解析负载均衡"></a>DNS域名解析负载均衡</h2><p>DNS域名解析负载均衡就是在用户请求DNS服务器，获取域名对应的IP地址时，DNS服务器直接给出负载均衡后的服务器IP。</p><ul><li>优点：交给DNS，不用我们去维护负载均衡服务器</li><li>缺点：当一个应用服务器挂了，不能及时通知DNS，而且DNS负载均衡的控制权在域名服务商那里，网站无法做更多的改善和更强大的管理</li></ul><p><br><br><br></p><h2 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h2><p>在用户的请求到达方向代理服务器时（已到达网站机房），由于反向代理服务器根据算法转发到具体的服务器，常用的Apache，Nginx都可以充当反向代理服务器。</p><ul><li>优点：部署简单</li><li>缺点：代理服务器可能成为性能的瓶颈，特别是一次上传大文件</li></ul><p><br><br><br></p><h2 id="IP负载均衡-LVS-NAT"><a href="#IP负载均衡-LVS-NAT" class="headerlink" title="IP负载均衡(LVS-NAT)"></a>IP负载均衡(LVS-NAT)</h2><p>LVS集群中实现的三种IP负载均衡技术。</p><p><br></p><p>在请求到达负载均衡器后，负载均衡器通过修改请求的目的IP地址，从而实现请求的转发，做到负载均衡。</p><ul><li>优点：性能更好</li><li>缺点：负载均衡器的带宽称为瓶颈</li></ul><p><br><br><br></p><h2 id="直接路由负载均衡-LVS-DR"><a href="#直接路由负载均衡-LVS-DR" class="headerlink" title="直接路由负载均衡(LVS-DR)"></a>直接路由负载均衡(LVS-DR)</h2><p>数据链路层负载均衡，在请求到达负载均衡器后，负载均衡器通过修改请求的Mac地址，从而做到负载均衡，与IP负载均衡不一样的是，当请求访问完服务器之后，直接返回客户，而无需在经过负载均衡器。</p><p><br><br><br></p><h3 id="IP隧道负载均衡-LVS-TUN"><a href="#IP隧道负载均衡-LVS-TUN" class="headerlink" title="IP隧道负载均衡(LVS-TUN)"></a>IP隧道负载均衡(LVS-TUN)</h3><p><br></p><hr><p><br></p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主从是一种用于数据容错和灾备的高可用解决方案，而不是一种处理高并发压力的解决方案（负载均衡是用来抗并发的）。</p><blockquote><p>如MySQL主从复制，MongoDB主从复制(副本集)</p></blockquote><ul><li>主机负责查询，从机负责增删改</li><li>可以在从机上执行备份，以避免备份期间影响主机的服务</li><li>主从复制后，也可以在从机上查询，以降低主机的访问压力。但是，只有更新不频繁的数据或者对实时性要求不高的数据可以通过从服务器查询，实时性要求高的数据仍需在主服务器查询（因为主从复制有同步延迟，所以不能保证强数据一致性）</li></ul><p><br><br><br></p><h2 id="主从复制和读写分离"><a href="#主从复制和读写分离" class="headerlink" title="主从复制和读写分离"></a>主从复制和读写分离</h2><ul><li>主从复制是实现读写分离的技术之一，也是实现读写分离的前提条件</li><li>做读写分离时最重要的就是确保 读库 和 写库 的数据统一，而主从复制是实现数据统一最简单的方法（并不能够保证强数据的一致性）</li><li>读写分离，顾名思义，就是一个表只负责向前台页面展示数据，而后台管理人员对表的增删改在另一个表中，把两个表分开，就是读写分离</li><li>主从复制则是一个表数据 增删改 之后会及时更新到另一个表中，保证两个表的数据一致</li></ul><p><br><br><br></p><h2 id="主从类型"><a href="#主从类型" class="headerlink" title="主从类型"></a>主从类型</h2><ul><li>双机热备=主机+备机</li><li>主要应用运行在主机，备机即备用机器。备机不工作，主机出现故障时备机接管主机的所有工作</li><li>双机互备=主机（备机） + 备机（主机）</li><li>互为主备，部分应用运行于主机，部分应用运行于备机，主机备机同时工作</li><li>双机双工=主机+主机</li><li>两台主机同时运行应用，主机备机同时工作</li></ul><p><br></p><hr><p><br></p><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><ul><li>广义上的分布式是指，将不同的服务分布在不同的服务器上</li><li>集群是指，将几台服务器集中在一起，实现同一业务</li><li>分布式中的每一个节点都可以做集群，而集群并不一定是分布式的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《老男孩Linux运维》&lt;/li&gt;
&lt;li&gt;《服务器集群系统各概念》: &lt;a href=&quot;https://segmentfault.com/a/1190000009923581&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000009923581&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《WEB的负载均衡、集群、高可用解决方案》： &lt;a href=&quot;https://zhuanlan.zhihu.com/p/23826048&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/23826048&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计算机集群维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://zhang21.github.io/tags/Nginx/"/>
    
      <category term="Cluster" scheme="https://zhang21.github.io/tags/Cluster/"/>
    
  </entry>
  
  <entry>
    <title>不成熟的小想法</title>
    <link href="https://zhang21.github.io/2018/01/21/%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E5%B0%8F%E6%83%B3%E6%B3%95/"/>
    <id>https://zhang21.github.io/2018/01/21/不成熟的小想法/</id>
    <published>2018-01-21T14:11:16.000Z</published>
    <updated>2018-03-18T12:19:12.500Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ynwa.png" alt="YNWA"></p><a id="more"></a><p><br><br><br></p><blockquote><p>你在大学奋斗四年和你进入工作岗位后奋斗四年，这两者的质量是完全不同的。前者是一个人一生的黄金时代，他有绝对的选择权来决定自己要成为什么样子；而后者则不同，吃饱饭才是这些已经步入社会的人需要考虑的第一要务。</p></blockquote><p><br></p><blockquote><p>我想不明白，为什么非要把成都建设成为2/3个四川？(或许西部省份都是这样，省会便是这个省)2017年成都市GDP约为13800亿人民币，而第二名的绵阳，却连2000亿都不到。<br>后来别人对我讲，资本都是逐利的。也许将壹万亿拆分成小蛋糕到各个地级市能使得各个地级市经济都得到一定的发展，但肯定没有将全部蛋糕投在成都的利润更好。这让我想起了滚雪球效应，相比滚出许多小雪球，所带来的的直观效应也没有大雪球突出，雪球越滚越大，给人的映像也就越来越明显。还有就是为政者都是需要政绩来突出自己，这是升迁的重要依据。GDP才是衡量你当政的重要依据，其它因素虽然也重要，但也比不过它。</p></blockquote><p><br></p><blockquote><p>我喜欢苹果，你却给了我一车梨，然后告诉全世界你花光了所有的钱给我买了一车梨。可是我却没有一点点感动，你说我是一个铁石心肠的人，可是我只是喜欢苹果而已。</p></blockquote><p><br></p><blockquote><p>任何人不是要你来教他如何做人的！</p></blockquote><p><br></p><blockquote><p>难道真如马尔克斯所说——“上了年纪的人不是按照已经活了多少岁来衡量年龄的，而是通过距离死亡还有多远来衡量！”</p></blockquote><p><br></p><blockquote><p>我刚开上本田的时候，也是宋总这心情，把骑自行车的人贬个贼死，而且心里就会骂出口，大屁股晃什么晃，开个玛萨拉蒂得瑟呀，我那时就像我买得起玛萨拉蒂一样。哈哈，就是个工具，先上手再说。<br>原来人都有这种心态，哈哈哈。</p></blockquote><p><br></p><blockquote><p>看着老一辈的逐渐老去，小一辈的逐渐长大，感叹时光过得真快呀！</p><p>过年回家，任何人都会谈及一个字——“钱”。</p><p>全家人都想出去挣钱，关于老人赡养问题，儿子和女儿又该如何担责？</p><p>儿媳妇也是一个严重的问题！我在想一个问题，儿媳妇在对待男方父母的时候，有没有想过如果以后她的儿媳也这样对待她，她作何感想？</p><p>现在的亲戚关系如果隔代的话，基本上过年就只有上一辈的人才走动了，下一辈子女基本都不会去。想想我们这些娃儿，上辈是亲兄弟姐妹、堂兄弟姐妹或表兄弟姐妹，我们这些小辈娃儿从小一起玩耍长大，小时候的关系好的不得了，用俗话说就是“穿一条裤子”。可是长大以后、结婚成家以后关系就淡泊了，哎！<br>可能我们这一辈情况以后会好一点，因为由于国家的计划生育政策，我们这一辈基本上都是独生子女。以后亲戚就这些，可能关系会好点，逢年过节走动会更频繁一点。其实计划生育使得我们这一辈人挺孤单的，长得后没什么亲戚、兄弟姊妹。以后我们的孩子也没有了舅舅、姨、叔伯、嬢嬢。所以可能以后非直系亲戚间的关系也会更紧密一些。现在国家放开了二胎其实挺好的，孩子们能有个哥哥姐姐弟弟妹妹真的挺好的。</p><p>过年回家经典问答：毕业了没有呀？毕业了，微笑；多少岁了呀？xxx岁了，微笑；在哪上班呀？在外上班，微笑；在成都哪个地方呀？南边，微笑；在哪个公司呀？小公司，微笑；是做啥子的呀？计算机，微笑；工资多少呀？不多不少，微笑；有没有女朋友呀？没有，微笑……<br>我知道这些长辈本没有恶意，只是出于不知道说什么而问点问题。但是，你们就不能动动脑子吗，我的长辈些。</p></blockquote><p><br></p><blockquote><p>我只是一个农村里出来的怯弱书生，一定要找准自己的定位。上辈给不了我什么东西，这点和城里的孩子已经差了一步，所以只有靠自己好好努力奋斗。争取给小一辈创造一个好一点的环境。</p><p>人人都是有利己心，人人都是自私的，表面和内心就如同硬币的正反两面。底层人民毫不讲理的一套，做事情完全不看原则和对错，完全是斗谁的声音高谁的脾气大才是理。看见斗不过有立马哭闹装楞。农村人民并不是那么淳良朴实，一点点鸡毛蒜皮的事情都要争。</p></blockquote><p><br></p><blockquote><p>任何人际关系都需要维持的！</p></blockquote><p><br></p><blockquote><p>我发觉我有一个问题。<br>人对一个人、一件物、一件事产生一个误解(或称之为成见的东西)，是很难改变的，以后会一直存在于我们的潜意识里面。我们的潜意识会主动隔阂某人某事某物，几遍某人某物某事是对的，这样一个长期效应便是对于我们潜意识里面的思维，我们会主动用我们的成见来隔阂。不知道能不能用“一朝被蛇咬十年怕井绳”来表述。<br>其实人与人、人与事是需要相互了解的，有了成见以后人就不愿意了解对方，而用自己潜意识的成见来判断人事物。这样隔阂也就难以消除而会一直延续小区。<br>所以，对人对事，不能带着老旧的成见去看到。——“士别三日当刮目相待，已非吴下阿蒙”。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/ynwa.png&quot; alt=&quot;YNWA&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Zhang" scheme="https://zhang21.github.io/categories/Zhang/"/>
    
    
      <category term="Zhang" scheme="https://zhang21.github.io/tags/Zhang/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://zhang21.github.io/2018/01/16/MySQL/"/>
    <id>https://zhang21.github.io/2018/01/16/MySQL/</id>
    <published>2018-01-16T02:47:12.000Z</published>
    <updated>2018-07-06T10:07:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>MySQL5.7参考文档： <a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/</a></li></ul><p><br></p><p>环境：</p><ul><li>CentOS7.x86_64</li><li>MySQL5.7</li></ul><a id="more"></a><p><br><br><br></p><hr><p><br></p><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>MySQL官网： <a href="https://www.mysql.com/" target="_blank" rel="noopener">https://www.mysql.com/</a></p><p>由于MySQL5.7和以前版本之间的许多功能和其他差异，因此此手册不太适用于之前的老版本。之前的版本请参考MySQL相关版本的手册。</p><p><br></p><p><img src="/images/Mysql/MySQL.png" alt="MySQL"></p><p><br><br><br></p><hr><p><br></p><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>General information</p><p>MySQL™ software提供了一个快速、多线程、多任务和健壮的SQL(结构化查询语言)的数据库服务器。MySQL server是为关键服务(mission-critical)、重负荷(heavy-load)生产系统以及嵌入式(embedding)大规模部署的软件而设计。<br>MySQL是Oracle Corporation的商标(trademark)。</p><p>MySQL software是双重许可的(dual license)：</p><ol><li>Open Source product of the GNU General Public License</li><li>A Standard commercial License from Oracle</li></ol><p><br><br><br></p><h2 id="关于此手册"><a href="#关于此手册" class="headerlink" title="关于此手册"></a>关于此手册</h2><ul><li>该手册作为一个参考，它不提供关于SQL或关系型数据库概念的一般指令；</li><li>MySQL Database Software正在不断发展，所以参考手册也经常更新。可在此 &lt; <a href="http://dev.mysql.com/doc/&gt;" target="_blank" rel="noopener">http://dev.mysql.com/doc/&gt;</a> 获取最新版的手册；</li><li>参考手册(Reference Manual)的源文件使用DocBook XML格式书写的，其他版本(如HTML)等是自动生成的；</li><li>如果在使用过程中有任何问题或建议，请发邮件给我们；</li><li>手册由MySQL Documentation Team维护。</li></ul><p><br><br><br></p><h2 id="MySQL数据库管理系统"><a href="#MySQL数据库管理系统" class="headerlink" title="MySQL数据库管理系统"></a>MySQL数据库管理系统</h2><p>MySQL Database Management System</p><p><br></p><h3 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a>MySQL介绍</h3><p>MySQL是最流行的开源的SQL数据库管理系统，由Oracle Corporation开发、分发和支持。</p><p><br></p><ul><li><p>MySQL is a database management system<br>数据库是一个结构化的数据集合。它可能是从简单的购物清单到图片库，或是公司网络中的大量信息。若要添加、访问和处理存储在计算机数据库中的数据，你需要一个像MySQL Server这样的数据库管理系统。由于计算机非常擅长处理大量的数据，数据库管理系统在计算机中扮演这一个重要的角色。</p></li><li><p>MySQL databases are relational<br>关系型数据库将数据存储在单独的表(table)中，而不是将所有数据放入一个大的库房中。数据库结构被组织成针对速度优化的物理文件。具有数据库(database)，表(table)，视图(view)，行(row)，列(column)等物理对象的逻辑模型提供了灵活的编程环境。你设置了管理不同数据字段之间关系的规则，如一对一，一对多，唯一，必须和可选关系，以及不同表之间的指针(pointer)。数据库强制执行这些规则，这样在设计良好的数据库中，应用程序就不会看到不一致、重复、孤立、过时或丢失的数据。</p></li></ul><p>MySQL也是代表SQL(Structure Query Language)的一部分。SQL是访问数据库最常用的标准化语言。你可以直接使用SQL语句，或者将SQL语法隐藏到语言特定的API中。</p><p>-MySQL software is Open Source<br>MySQL software使用GPL(GNU General Public License)，开源意味着任何人都可以下载、转发、使用和修改软件，而不需要支付任何费用。</p><ul><li><p>MySQL database server is very fast,reliable,scalabe and easy to use</p></li><li><p>MySQL server works in Client/Server or embedded system<br>MySQL Database Server是一个由多线程(multi-threaded)SQL Server组成的客户/服务器系统。它支持不同的后端，多个不同的客户程序和库、管理工具和广泛的APIs。<br>还提供MySQL Server作为一个嵌入式多线程库以便链接到你的产品，以获得一个更小，更快，更容易管理的独立产品。</p></li><li><p>A large amount of contributed MySQL software is available</p></li></ul><p><br><br><br></p><h3 id="MySQL主要特点"><a href="#MySQL主要特点" class="headerlink" title="MySQL主要特点"></a>MySQL主要特点</h3><h4 id="Internals-and-Portability"><a href="#Internals-and-Portability" class="headerlink" title="Internals and Portability"></a>Internals and Portability</h4><ul><li>由C和C++写成</li><li>适用于许多不同的平台</li><li>为了可移植性，使用<code>CMake</code></li><li>采用独立(independent)模块的多层(layer)服务器设计</li><li>设计为使用内核线程的完全多线程，如果有多核CPU，能够轻松使用它们</li><li>提供了事务性(transactional)和非事务性(notransactional)存储引擎</li><li>使用非常快速的带有索引压缩的B-tree磁盘表</li><li>添加其他存储引擎相对容易</li><li>使用非常快速的基于线程的内存分配系统</li><li>使用优化的嵌套循环(nested-loop)连接执行非常快的联结</li><li>实现内存中的hash table，这些表用作临时表</li><li>使用高度优化的类库实现SQL函数</li></ul><p><br></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>1,2,3,4和8byte的有无符号(signed/unsigned)的整数(integers)</li><li>FLOAT</li><li>DOUBLE</li><li>CHAR, VARCHAR</li><li>BINARY, VARBINARY</li><li>TEXT</li><li>BLOB</li><li>DATE, TIME, DATETIME</li><li>TIMESTAMP</li><li>YEAR</li><li>SET</li><li>ENUM</li><li>OpenGIS</li></ul><p><br></p><h4 id="状态和功能"><a href="#状态和功能" class="headerlink" title="状态和功能"></a>状态和功能</h4><p>statement and function</p><ul><li><code>SELECT</code>和<code>WHERT</code>中包含了所有支持的操作符和函数</li><li>SQL中的<code>GROUP BY</code>和<code>ORDER BY</code>也全部支持</li><li>GROUP functions(<code>COUNT()</code>, <code>AVG()</code>, <code>STD()</code>, <code>SUM()</code>, <code>MAX()</code>, <code>MIN()</code>, <code>GROUP_CONCAT()</code>)</li><li>支持<code>LEFT OUTER JOIN</code>和<code>ROGHT OUTER JOIN</code></li><li>按照SQL标准支持table和columns的别名</li><li>支持<code>DELETE</code>,<code>INSERT</code>,<code>REPLACE</code>,<code>UPDATE</code>，以返回受影响的行数</li><li>支持MySQL特定的<code>SHOW</code>显示语句</li><li>一个<code>EXPLAIN</code>语句显示优化器如何解析查询</li></ul><p><br></p><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>security</p><ul><li>权限(privilege)和密码系统，非常灵活和安全，并且支持基于主机的验证</li><li>当连接到Server时，通过加密(encryption)所有密码通信量来确保密码安全</li></ul><p><br></p><h4 id="扩展性和限制"><a href="#扩展性和限制" class="headerlink" title="扩展性和限制"></a>扩展性和限制</h4><p>Scalability and Limits</p><ul><li>支持大型数据库。包含五千万条记录，二十万个表，五十亿行</li><li>每个表最多支持64个索引，每个索引可以由1到16个列组成</li></ul><p><br></p><p>####　连通性</p><p>Conectivity</p><ul><li>客户端使用如下几种协议连接到MySQL Server<ul><li>TCP/IP sockets</li><li>–enable-named-pipe on Windows</li><li>Unix domain socket files on UNIX</li></ul></li><li>MySQL客户端可用多种语言编写</li><li>APIs对于多数语言是可用的</li></ul><p><br></p><h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>Localization</p><ul><li>Server可以向多种语言的客户端提供错误信息</li><li>完全支持几个不同的字符集(character sets)</li><li>所有数据都被保存在选取的字符集(chracter set)</li><li>排序和比较是根据默认的字符集和排序规则完成</li><li>服务器时区(time zone)可动态更改，个客户端也可修改自己的时区</li></ul><p><br></p><h4 id="客户端和工具"><a href="#客户端和工具" class="headerlink" title="客户端和工具"></a>客户端和工具</h4><p>Clients and Tools</p><ul><li>MySQL包含几个客户机和使用程序<ul><li>command-line： <code>mysqldump</code>, <code>mysqladmin</code></li><li>graphical: MySQL Workbench</li></ul></li><li>MySQL Server内置了对SQL语句的支持来检查、优化和修复表</li><li>MySQL程序可使用<code>--help</code>或<code>-?</code>来获取帮助</li></ul><p><br><br><br></p><h3 id="MySQL历史"><a href="#MySQL历史" class="headerlink" title="MySQL历史"></a>MySQL历史</h3><p>History of MySQL</p><ul><li>MySQL is named after co-founder Monty Widenius’s daughter, My.</li><li>The name of the MySQL Dolphin (our logo) is “Sakila,” which was chosen from a huge list of names suggested by users in our “Name the Dolphin” contest.</li></ul><p><br><br><br></p><h2 id="MySQL5-7新特色"><a href="#MySQL5-7新特色" class="headerlink" title="MySQL5.7新特色"></a>MySQL5.7新特色</h2><p>What Is New in MySQL 5.7</p><p><br></p><h3 id="MySQL5-7新功能"><a href="#MySQL5-7新功能" class="headerlink" title="MySQL5.7新功能"></a>MySQL5.7新功能</h3><p>Features Added in MySQL 5.7</p><p><br><br><br></p><h3 id="MySQL5-7中过期的功能"><a href="#MySQL5-7中过期的功能" class="headerlink" title="MySQL5.7中过期的功能"></a>MySQL5.7中过期的功能</h3><p>Features Deprecated in MySQL 5.7</p><p><br><br><br></p><h3 id="MySQL5-7中移除的功能"><a href="#MySQL5-7中移除的功能" class="headerlink" title="MySQL5.7中移除的功能"></a>MySQL5.7中移除的功能</h3><p>Features Removed in MySQL 5.7</p><p><br><br><br></p><h2 id="Server-and-Status-Variables-and-Options-Added-Deprecated-or-Removed-in-MySQL-5-7"><a href="#Server-and-Status-Variables-and-Options-Added-Deprecated-or-Removed-in-MySQL-5-7" class="headerlink" title="Server and Status Variables and Options Added, Deprecated, or Removed in MySQL 5.7"></a>Server and Status Variables and Options Added, Deprecated, or Removed in MySQL 5.7</h2><p><br><br><br></p><h2 id="MySQL信息源"><a href="#MySQL信息源" class="headerlink" title="MySQL信息源"></a>MySQL信息源</h2><p>MySQL Information Sources</p><p>本章节将列出有关MySQL的帮助信息。</p><p><br></p><h3 id="MySQL站点"><a href="#MySQL站点" class="headerlink" title="MySQL站点"></a>MySQL站点</h3><p>MySQL Websites</p><p>MySQL Documentation is <a href="https://dev.mysql.com/doc" target="_blank" rel="noopener">https://dev.mysql.com/doc</a></p><p><br><br><br></p><hr><p><br></p><h1 id="安装和升级"><a href="#安装和升级" class="headerlink" title="安装和升级"></a>安装和升级</h1><ul><li>mysql-repo: <a href="http://repo.mysql.com/" target="_blank" rel="noopener">http://repo.mysql.com/</a></li><li>yum-repo: <a href="http://repo.mysql.com/yum/" target="_blank" rel="noopener">http://repo.mysql.com/yum/</a></li></ul><p><br></p><p>安装MySQL一般遵循以下步骤：</p><ul><li>确定MySQL是否支持你的平台(platform)<ul><li>Unix、Linux、FreeBSD</li><li>Windows</li><li>OS X</li></ul></li><li>选择要安装的发行版(distribution)</li><li>下载你想要安装的发行版</li><li>安装发行版</li><li>执行任何必要的安装后设置</li></ul><p><br><br><br></p><h2 id="通用安装指南"><a href="#通用安装指南" class="headerlink" title="通用安装指南"></a>通用安装指南</h2><p>General Installation Guidance</p><p><br><br><br></p><h3 id="安装哪个发行版和MySQL版本"><a href="#安装哪个发行版和MySQL版本" class="headerlink" title="安装哪个发行版和MySQL版本"></a>安装哪个发行版和MySQL版本</h3><p>Which MySQL Version and Distribution to Install</p><p><br></p><p>在准备安装MySQL时，请决定使用哪种版本(version)和发行(distribution)格式(binary or source)</p><p>首先，决定安装开发版还是稳定版。</p><ul><li>Development release<ul><li>具有新功能，但不推荐用于生产环境</li></ul></li><li>General Availability(GA) release<ul><li>也称为稳定版(stable release)，推荐为生产环境使用</li></ul></li></ul><p>MySQL命名方案(naming scheme)， 例如MySQL5.7.1：</p><ul><li>5为主版本号(major)</li><li>7为次版本号(minor)</li><li>1为发行(release)系列版本号<ul><li>系列号描述了稳定的功能集。对于每个新的修补程序，这都会增加。</li></ul></li></ul><p>在选择要安装的MySQL版本之后，决定要为操作系统安装哪个发行版格式。</p><ul><li>二进制(binary)<ul><li>RPM, DMG</li></ul></li><li>源码(source)<ul><li>tar, zip</li></ul></li></ul><p>在某些情况下，最好使用源码安装MySQL：</p><ul><li>想在某个明确的位置安装MySQL</li><li>希望使用二进制发行版中未包含的特性配置mysqld</li><li>希望配置mysqld，而不需要二进制发行版中包含的一些功能</li><li>你希望读取或修改组成MySQL的C、C++源代码</li><li>源码发行版比二进制发行版包含更多的测试和示例</li></ul><p><br><br><br></p><h3 id="如何获取MySQL"><a href="#如何获取MySQL" class="headerlink" title="如何获取MySQL"></a>如何获取MySQL</h3><p>How to Get MySQL</p><p><br></p><ul><li>MySQL当前版本下载页： <a href="https://dev.mysql.com/downloads/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/</a></li><li>完整的MySQL镜像： <a href="https://dev.mysql.com/downloads/mirrors/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mirrors/</a></li><li>基于RPM的Linux平台，MySQL Yum Repository： <a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a></li><li>基于Debian的Linux平台，MySQL APT Repository： <a href="https://dev.mysql.com/downloads/repo/apt/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/apt/</a></li><li>SUSE Linux平台，MySQL SUSE Repository： <a href="https://dev.mysql.com/downloads/repo/suse/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/suse/</a></li></ul><p><br><br><br></p><h3 id="使用MD5校验和或GnuPG验证程序完整性"><a href="#使用MD5校验和或GnuPG验证程序完整性" class="headerlink" title="使用MD5校验和或GnuPG验证程序完整性"></a>使用MD5校验和或GnuPG验证程序完整性</h3><p>Verifying Package Integrity Using MD5 Checksums or GnuPG</p><p><br></p><p>下载好MySQL包并在安装它之前，请确保它是完整的并未被篡改。有如下三种方法：</p><ul><li>MD5 checksums</li><li>Cryptographic signatures using GnuPG, the GNU Privacy Guard</li><li>For RPM packages, the built-in RPM integrity verification mechanism</li></ul><p><br><br><br></p><h4 id="验证MD5校验和"><a href="#验证MD5校验和" class="headerlink" title="验证MD5校验和"></a>验证MD5校验和</h4><p>Verifying the MD5 Checksum</p><p><br></p><p>应确保下载的MySQL包的MD5校验和与MySQL官方提供的校验和相匹配。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">md5sum mysql-standard-5.7.22-linux-i686.tar.gz</span><br><span class="line"><span class="comment">#aaab65abbec64d5e907dcd41b8699945  mysql-standard-5.7.22-linux-i686.tar.gz</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="使用GnuPG进行签名检查"><a href="#使用GnuPG进行签名检查" class="headerlink" title="使用GnuPG进行签名检查"></a>使用GnuPG进行签名检查</h4><p>Signature Checking Using GnuPG</p><p><br></p><p>要验证软件包的签名，首先需要我们的公共GPG密钥的副本。可从<a href="http://pgp.mit.edu/" target="_blank" rel="noopener">http://pgp.mit.edu/</a>下载。<br>你想要获得的密钥名为<strong>mysql-build@oss.oracle.com</strong>，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PGP PUBLIC KEY BLOCK-----</span><br><span class="line">Version: GnuPG v1.4.5 (GNU/Linux)</span><br><span class="line"></span><br><span class="line">mQGiBD4+owwRBAC14GIfUfCyEDSIePvEW3SAFUdJBtoQHH/nJKZyQT7h9bPlUWC3</span><br><span class="line">RODjQReyCITRrdwyrKUGku2FmeVGwn2u2WmDMNABLnpprWPkBdCk96+OmSLN9brZ</span><br><span class="line">fw2vOUgCmYv2hW0hyDHuvYlQA/BThQoADgj8AW6/0Lo7V1W9/8VuHP0gQwCgvzV3</span><br><span class="line">BqOx后面还有很多，省略</span><br><span class="line">-----END PGP PUBLIC KEY BLOCK-----</span><br></pre></td></tr></table></figure><p>使用<code>gpg --import</code>将密钥导入到个人公共GPG密钥环中。如公共密钥为<code>mysql_pubkey.asc</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gpg --import ./mysql_pubkey.asc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#或使用public key id下载公共密钥</span><br><span class="line">gpg --recv-keys $pub-key-id</span><br></pre></td></tr></table></figure><p>在rpm包中验证:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import ./mysql_pubkey.asc</span><br></pre></td></tr></table></figure><p>确保两个文件都放置于同一目录下，然后运行命令验证签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gpg --verify package_name.asc</span><br><span class="line"></span><br><span class="line">gpg --verify mysql-standard-5.7.22-linux-i686.tar.gz.asc</span><br><span class="line">gpg: Signature made Tue 01 Feb 2011 02:38:30 AM CST using DSA key ID 5072E1F5</span><br><span class="line">gpg: Good signature from &quot;MySQL Release Engineering &lt;mysql-build@oss.oracle.com&gt;&quot;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="使用RPM进行签名检查"><a href="#使用RPM进行签名检查" class="headerlink" title="使用RPM进行签名检查"></a>使用RPM进行签名检查</h4><p>Signature Checking Using RPM</p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm --checksig package_name.rpm</span><br><span class="line"></span><br><span class="line">[zhang@zabbix ~]$ rpm --checksig mysql-community-server-5.7.20-1.el7.x86_64.rpm</span><br><span class="line">mysql-community-server-5.7.20-1.el7.x86_64.rpm: (sha1) dsa sha1 md5 gpg OK</span><br></pre></td></tr></table></figure><p>rpm还支持从URL加载密钥:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import http://dev.mysql.com/doc/refman/5.7/en/checking-gpg-signature.html</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="安装布局"><a href="#安装布局" class="headerlink" title="安装布局"></a>安装布局</h3><p>Installation Layouts</p><p><br></p><p>不同的安装类型(native packages, binary tarballs, and source tarballs)有不同的安装布局，这样可能会导致混淆。</p><p><br><br><br></p><h2 id="在Unix-Linux上使用通用二进制文件安装MySQL"><a href="#在Unix-Linux上使用通用二进制文件安装MySQL" class="headerlink" title="在Unix/Linux上使用通用二进制文件安装MySQL"></a>在Unix/Linux上使用通用二进制文件安装MySQL</h2><p>Installing MySQL on Unix/Linux Using Generic Binaries</p><p><br></p><p>包括以压缩的tar文件形式的通用二进制发行版，以及针对特定平台封装格式的二进制文件。</p><p>MySQL压缩tar文件二进制发行版具有<strong> mysql-VERSION-OS.tar.gz</strong>的文件格式。</p><p>MySQL依赖于<code>libaio</code> Library：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y libaio</span><br></pre></td></tr></table></figure><p><br></p><p>默认地，tar文件二进制发行版，解压后安装于<code>/usr/local/mysql</code>目录。会在目录下生产 通用Unix/Linux二进制包的MySQL安装布局目录</p><table><thead><tr><th>目录</th><th>内容</th></tr></thead><tbody><tr><td>bin</td><td>mysqld server, client and utility programs</td></tr><tr><td>docs</td><td>MySQL manual in Info format</td></tr><tr><td>man</td><td>Unix manual pages</td></tr><tr><td>include</td><td>Include (header) files</td></tr><tr><td>lib</td><td>Libraries</td></tr><tr><td>share</td><td>Error messages, dictionary, and SQL for database installation</td></tr><tr><td>support-files</td><td>Miscellaneous support files</td></tr></tbody></table><p>大致命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; groupadd mysql</span><br><span class="line">shell&gt; useradd -r -g mysql -s /bin/false mysql</span><br><span class="line">shell&gt; cd /usr/local</span><br><span class="line">shell&gt; tar zxvf /path/to/mysql-VERSION-OS.tar.gz</span><br><span class="line">shell&gt; ln -s full-path-to-mysql-VERSION-OS mysql</span><br><span class="line">shell&gt; cd mysql</span><br><span class="line">shell&gt; mkdir mysql-files</span><br><span class="line">shell&gt; chown mysql:mysql mysql-files</span><br><span class="line">shell&gt; chmod 750 mysql-files</span><br><span class="line">shell&gt; bin/mysqld --initialize --user=mysql</span><br><span class="line">shell&gt; bin/mysql_ssl_rsa_setup</span><br><span class="line">shell&gt; bin/mysqld_safe --user=mysql &amp;</span><br><span class="line"># Next command is optional</span><br><span class="line">shell&gt; cp support-files/mysql.server /etc/init.d/mysql.server</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加环境变量</span><br><span class="line">export PATH=$PATH:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="在Linux上安装MySQL"><a href="#在Linux上安装MySQL" class="headerlink" title="在Linux上安装MySQL"></a>在Linux上安装MySQL</h2><p>Installing MySQL on Linux</p><p><br></p><p>Linux支持多种方法来安装MySQL。建议使用Oracle提供的一个发行版：</p><ul><li>Apt</li><li>Yum</li><li>Zypper</li><li>RPM</li><li>DEB</li><li>Generic</li><li>Source</li><li>Docker</li><li>Oracle Unbreakable Linux Network</li></ul><p>作为一个选择，你可以使用系统中的包管理工具自动下载和安装MySQL。</p><p><br><br><br></p><h3 id="在Linux上使用Yum-Repository安装MySQL"><a href="#在Linux上使用Yum-Repository安装MySQL" class="headerlink" title="在Linux上使用Yum Repository安装MySQL"></a>在Linux上使用Yum Repository安装MySQL</h3><p>Installing MySQL on Linux Using the MySQL Yum Repository</p><p><br></p><p><strong>安装一个全新的MySQL的步骤：</strong></p><ul><li>添加MySQL Yum Repository<ul><li>首先，添加MySQL Yum repository到你的系统仓库列表</li><li>选择和下载对应平台的release 或者 手动添加repository文件</li><li>安装release package</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#yum localinstall platform-and-version-specific-package-name.rpm</span></span><br><span class="line">yun install http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum repolist enabled | grep <span class="string">"mysql.*-community.*"</span></span><br></pre></td></tr></table></figure><ul><li>选择一个release series</li></ul><p>默认是最新的GA series，当前最新是MySQL5.7。</p><p>查看所有的MySQL Yum repository: <code>yum repolist all | grep mysql</code></p><p>安装最新MySQL不需要配置，而安装先前的版本则需要指定GA series。disable最新的GA series并且enable需要的GA series。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --disable mysql57-community</span><br><span class="line"></span><br><span class="line">yum-config-manager --enable mysql56-community</span><br></pre></td></tr></table></figure><p><strong>或者手动创建repo，可直接定义版本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysql57-community]</span><br><span class="line">name=MySQL 5.7 Community Server</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/7/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br></pre></td></tr></table></figure><ul><li>安装MySQL</li></ul><p>在安装MySQL过程中出现错误，请务必查看日志文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mysql-community-server mysql-community-client</span><br><span class="line"></span><br><span class="line">#也可不安装客户端</span><br></pre></td></tr></table></figure><ul><li>开启MySQL Server</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service mysqld start</span><br><span class="line">#Starting mysqld:[ OK ]</span><br><span class="line"></span><br><span class="line">service mysqld status</span><br></pre></td></tr></table></figure><p><strong>在服务器初始启动时，如果服务器的数据目录为空，则会发生一下情况：</strong></p><ul><li>服务器已初始化</li><li>SSL certificate and key files 在数据目录中生成</li><li>validate_password已安装并启用</li><li>超级用户账户’root’@’localhost’被创建，超级用户密码被设置并被存储在error log files<ul><li>这一点和以前版本有很大区别，我被坑惨了</li></ul></li></ul><p><strong>注意：</strong></p><blockquote><p>ValidPassword的默认密码策略要求包含大写字母、小写字母、数字和特殊字符，并且密码长度至少为8个字符</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#查看初始密码</span><br><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#无法使用mysqladmin修改密码，需要登录mysql后修改</span><br><span class="line"></span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#重置密码</span><br><span class="line">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;NewPass4!;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#如果找不到初始密码</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line"></span><br><span class="line">#在[mysqld]最后行加上skip-grant-tables实现无认证登录</span><br><span class="line">#重启MySQL</span><br><span class="line">UPDATE  mysql.user  SET  authentication_string =PASSWORD(&apos;新密码&apos;)  WHERE  USER=&apos;xxx&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改默认密码策略</span><br><span class="line">#更改密码强度</span><br><span class="line">set global validate_password_policy=0;</span><br><span class="line"></span><br><span class="line">#设置密码最小长度</span><br><span class="line">set global validate_password_length=4;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用Yum安装额外的MySQL产品和组件</strong></p><p>你可使用Yum安装和管理MySQL的个别组件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum --disablerepo=\* --enablerepo=<span class="string">'mysql*-community*'</span> list available</span><br><span class="line"></span><br><span class="line">yum install package-name</span><br><span class="line"></span><br><span class="line"><span class="comment">#栗子</span></span><br><span class="line">yum install mysql-community-libs</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="在Linux上使用Oracle提供的RPM包安装MySQL"><a href="#在Linux上使用Oracle提供的RPM包安装MySQL" class="headerlink" title="在Linux上使用Oracle提供的RPM包安装MySQL"></a>在Linux上使用Oracle提供的RPM包安装MySQL</h3><p>Installing MySQL on Linux Using RPM Packages from Oracle</p><p><br></p><p>MySQL Community Edition的rpm包如下：</p><table><thead><tr><th>包名</th><th>描述</th></tr></thead><tbody><tr><td>mysql-community-server</td><td>Database server and related tools</td></tr><tr><td>mysql-community-client</td><td>MySQL client applications and tools</td></tr><tr><td>mysql-community-common</td><td>Common files for server and client libraries</td></tr><tr><td>mysql-community-server-minimal</td><td>Minimal installation of the database server and related tools</td></tr><tr><td>mysql-community-devel</td><td>Development header files and libraries for MySQL database client applications</td></tr><tr><td>mysql-community-libs</td><td>Shared libraries for MySQL database client applications</td></tr><tr><td>mysql-community-libs-compat</td><td>Shared compatibility libraries for previous MySQL installations</td></tr><tr><td>mysql-community-embedded</td><td>MySQL embedded library</td></tr><tr><td>mysql-community-embedded-devel</td><td>Development header files and libraries for MySQL as an embeddable library</td></tr><tr><td>mysql-community-test</td><td>Test suite for the MySQL server</td></tr></tbody></table><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#rpm -qpl mysql-community-server-version-distribution-arch.rpm</span><br><span class="line"></span><br><span class="line">#yum install mysql-community-&#123;server,client,common,libs&#125;-*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wget http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql-community-server-5.7.20-1.el7.x86_64.rpm</span><br><span class="line">wget http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql-community-client-5.7.20-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install -y mysql-community-server-5.7.20-1.el7.x86_64.rpm mysql-community-client-5.7.20-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Linux RPM包MySQL开发区的安装布局：</strong></p><table><thead><tr><th>文件或资源</th><th>位置</th></tr></thead><tbody><tr><td>Client programs and scripts</td><td>/usr/bin</td></tr><tr><td>mysqld server</td><td>/usr/sbin</td></tr><tr><td>configuration file</td><td>/etc/my.cnf</td></tr><tr><td>data directory</td><td>/var/lib/mysql</td></tr><tr><td>error log file</td><td>/var/log/mysqld.log</td></tr><tr><td>Value of secure_file_priv</td><td>/var/lib/mysql-files</td></tr><tr><td>System V init script</td><td>/etc/init.d/mysqld</td></tr><tr><td>Systemd service</td><td>mysqld</td></tr><tr><td>pid file</td><td>/var/run/mysql/mysqld.pid</td></tr><tr><td>socket</td><td>/var/lib/mysql/mysql.sock</td></tr><tr><td>Keyring directory</td><td>/var/lib/mysql-keyring</td></tr><tr><td>Unix manual pages</td><td>/usr/share/man</td></tr><tr><td>include (header) files</td><td>/usr/include/mysql</td></tr><tr><td>Libraries</td><td>/usr/lib/mysql</td></tr><tr><td>Miscellaneous support files (for example, error messages, and character set files)</td><td>/usr/share/mysql</td></tr></tbody></table><p><br></p><p>The installation also creates a user named mysql and a group named mysql on the system.</p><blockquote><p><strong>注意</strong><br>安装MySQL会在系统上生成一个名为mysql的用户和群组<br>安装以前的MySQL版本可能会创建<code>my.cnf</code>配置文件。强烈建议先将<code>my.cnf</code>进行迁移，然后删除它。之后才安装MySQL</p></blockquote><p><br><br><br></p><h3 id="用systemd管理MySQL-Server"><a href="#用systemd管理MySQL-Server" class="headerlink" title="用systemd管理MySQL Server"></a>用systemd管理MySQL Server</h3><p>Managing MySQL Server with systemd</p><p><br></p><h4 id="systemd综述"><a href="#systemd综述" class="headerlink" title="systemd综述"></a>systemd综述</h4><p>Overview of systemd</p><p><br></p><p><code>systemd</code>提供了MySQL Server的自动开启和关闭，使用<code>systemctl</code>命令进行管理。</p><p>或者，使用<code>system V</code>系统兼容的<code>service</code>命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl &#123;start|stop|restart|status&#125; mysqld</span><br><span class="line"></span><br><span class="line">service mysqld &#123;start|stop|restart|status&#125;</span><br></pre></td></tr></table></figure><p>对systemd的支持包括这些文佳：</p><ul><li>mysqld.service<ul><li>systemd服务单元配置文件，以及有关MySQL服务的详细信息</li></ul></li><li>mysqld@.service<ul><li>用于管理多个MySQL实例</li></ul></li><li>mysqld.tmpfiles.d<ul><li>包含支持临时文件功能的信息</li></ul></li><li>mysqld_pre_systemd<ul><li>支持单元文件的脚本</li></ul></li></ul><p><br></p><h4 id="为MySQL配置systemd"><a href="#为MySQL配置systemd" class="headerlink" title="为MySQL配置systemd"></a>为MySQL配置systemd</h4><p>Configuring systemd for MySQL</p><p><br></p><p>为MySQL添加或修改systemd选项，参考如下方法：</p><ul><li>使用一个本地化的systemd配置文件</li><li>安排systemd为MySQL Server进程设置环境变量</li><li>设置MYSQLD_OPTS systemd变量</li></ul><p>创建<code>/etc/systemd/system/mysqld.service</code>本地化systemd配置文件，这里讨论的是将此文件名作为<code>override.conf</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">LimitNOFILE=max_open_files</span><br><span class="line">PIDFile=/path/to/pid/file</span><br><span class="line">Nice=nice_level</span><br><span class="line">LimitCore=core_file_limit</span><br><span class="line">Environment=<span class="string">"LD_PRELOAD=/path/to/malloc/library"</span></span><br><span class="line">Environment=<span class="string">"TZ=time_zone_setting"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#LimitNOFILE: 文件描述符数量</span></span><br><span class="line"><span class="comment">#LimitCore: 最大核心文件大小</span></span><br><span class="line"><span class="comment">#Nice: 优先级</span></span><br><span class="line"><span class="comment">#LD_PRELOAD: 特定内存分配库</span></span><br><span class="line"><span class="comment">#TZ: 指定时区</span></span><br></pre></td></tr></table></figure><p>修改mysqld:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl edit mysqld</span><br></pre></td></tr></table></figure><p>重新加载systemd配置，然后重启MySQL service：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>可在<code>override.conf</code>中设置如下参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">PIDFile=/var/run/mysqld/mysqld-custom.pid</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld-custom.pid <span class="variable">$MYSQLD_OPTS</span></span><br></pre></td></tr></table></figure><p>在<code>/etc/sysconfig/mysql</code>下指定值：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD=/path/to/malloc/library</span><br><span class="line">TZ=time_zone_setting</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p><br></p><h4 id="使用systemd配置多个MySQL实例"><a href="#使用systemd配置多个MySQL实例" class="headerlink" title="使用systemd配置多个MySQL实例"></a>使用systemd配置多个MySQL实例</h4><p>Configuring Multiple MySQL Instances Using systemd</p><p><br></p><p>由于systemd具有在平台上管理多个MySQL实例的能力，而不必须需要<code>mysqld_multi</code>和<code>mysqld_multi.server</code>。</p><p>若要使用多实例(multiple-instance)功能，请修改<code>/etc/my.cnf</code>文件以包含每个实例的关键选项配置。<br>例如，管理replication01和replication02两个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysqld@replica01]</span><br><span class="line">datadir=/var/lib/mysql-replica01</span><br><span class="line">socket=/var/lib/mysql-replica01/mysql.sock</span><br><span class="line">port=3307</span><br><span class="line">log-error=/var/log/mysqld-replica01.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysqld@replica02]</span><br><span class="line">datadir=/var/lib/mysql-replica02</span><br><span class="line">socket=/var/lib/mysql-replica02/mysql.sock</span><br><span class="line">port=3308</span><br><span class="line">log-error=/var/log/mysqld-replica02.log</span><br></pre></td></tr></table></figure><p><strong>这里的名称使用<code>@</code>作为分隔符(delimiter)，因为这个是<code>systemd</code>支持的唯一分隔符。</strong></p><p>管理两个实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld@replica01</span><br><span class="line">systemctl start mysqld@replica02</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl enable mysqld@replica01</span><br><span class="line">systemctl enable mysqld@replica02</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#使用通配符</span><br><span class="line">systemctl status &apos;mysqld@replica*&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl stop mysqld@replica0&#123;1,2&#125;</span><br></pre></td></tr></table></figure><p>对于同一个机器上的不同MySQL实例，systemd自动使用不同的单元文件。<br>在unit file中，<code>%I</code>和<code>%i</code>用于<code>@</code>标记后传入参数，用于管理特定实例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#像这样</span></span><br><span class="line">mysqld --defaults-group-suffix=@%I ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl status mysqld@replica01</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysqld@replica01.service - MySQL Server</span></span><br><span class="line"><span class="comment">#  Loaded: loaded (/usr/lib/systemd/system/mysqld@.service; disabled; vendor preset: disabled)</span></span><br><span class="line"><span class="comment">#  Active: active (running) since Tue 2018-02-27 12:18:34 CST; 1min 6s ago</span></span><br><span class="line"><span class="comment">#    Docs: man:mysqld(8)</span></span><br><span class="line"><span class="comment">#          http://dev.mysql.com/doc/refman/en/using-systemd.html</span></span><br><span class="line"><span class="comment"># Process: 3927 ExecStart=/usr/sbin/mysqld --defaults-group-suffix=@%I --daemonize --pid-file=/var/run/mysqld/mysqld-%i.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS)</span></span><br><span class="line"><span class="comment"># Process: 3845 ExecStartPre=/usr/bin/mysqld_pre_systemd %I (code=exited, status=0/SUCCESS)</span></span><br><span class="line"><span class="comment">#Main PID: 3930 (mysqld)</span></span><br><span class="line"><span class="comment">#  CGroup: /system.slice/system-mysqld.slice/mysqld@replica01.service</span></span><br><span class="line"><span class="comment">#          `-3930 /usr/sbin/mysqld --defaults-group-suffix=@replica01 --daemonize --pid-file=/var/run/mysqld/mysqld-replica01.pid</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#eb 27 12:18:27 zabbix.me systemd[1]: Starting MySQL Server...</span></span><br><span class="line"><span class="comment">#eb 27 12:18:34 zabbix.me systemd[1]: Started MySQL Server.</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="从mysqld-safe迁移到systemd"><a href="#从mysqld-safe迁移到systemd" class="headerlink" title="从mysqld_safe迁移到systemd"></a>从mysqld_safe迁移到systemd</h4><p>Migrating from mysqld_safe to systemd</p><p><br></p><p>因为<code>mysqld_safe</code>没有安装在使用<code>systemd</code>管理MySQL的平台上，所以以前需要为该程序指定选项：<code>[mysqld_safe]</code></p><ul><li>一些<code>[mysqld_safe]</code>的选项也能被<code>[mysqld]</code>支持</li><li>一些<code>[mysqld_safe]</code>的选项类似于<code>[mysqld]</code>选项</li></ul><p><br><br><br></p><h2 id="从源码安装MySQL"><a href="#从源码安装MySQL" class="headerlink" title="从源码安装MySQL"></a>从源码安装MySQL</h2><p>Installing MySQL from Source</p><p><br></p><p>从源代码构建MySQL使我们能够自定义构建参数(parameter)、编译器优化(compiler optimization)和安装位置(installation location)。</p><p>在使用源码安装前，请检查Oracle是否为你的平台生成预编译的二进制发行版，以及是否适合你。Oracle付出了很多努力确保提供的二进制文件具有最佳的性能选择。</p><p><strong>源码安装系统需求：</strong><br>使用源码安装MySQL需要多种开发工具。</p><p>使用源码安装MySQL，必须满足一下系统需求：</p><ul><li>CMake, which is used as the build framework on all platforms</li><li>A good make program</li><li>A working ANSI C++ compiler</li><li>The Boost C++ libraries are required to build MySQL</li><li>The ncurses library</li><li>Sufficient free memory</li><li>Perl is needed if you intend to run test scripts</li></ul><p>使用standard source distribution安装MySQL，需要以下工具来unpack分发文件：</p><ul><li>For a .tar.gz compressed tar file: <code>tar</code></li><li>For a .zip Zip archive: <code>zip</code></li><li>For an .rpm RPM package: <code>rpmbuild</code></li></ul><p><br><br><br></p><h3 id="用于源码安装的MySQL布局"><a href="#用于源码安装的MySQL布局" class="headerlink" title="用于源码安装的MySQL布局"></a>用于源码安装的MySQL布局</h3><p>MySQL Layout for Source Installation</p><p><br></p><p>默认地，再从源码编译后安装MySQL时，安装步骤会将文件安装在<code>/usr/local/mysql</code>下。</p><p><br><br><br></p><h3 id="使用标准源码发行版安装MySQL"><a href="#使用标准源码发行版安装MySQL" class="headerlink" title="使用标准源码发行版安装MySQL"></a>使用标准源码发行版安装MySQL</h3><p>Installing MySQL Using a Standard Source Distribution</p><p><br></p><p>从一个标准源码发行版安装MySQL：</p><ol><li>确保系统满足工具需求</li><li>获取发行文件</li><li>配置、构建和安装</li><li>执行安装后程序</li></ol><p><br></p><p>如果是source RPM:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpmbuild --rebuild --clean MySQL-VERSION.src.rpm</span><br></pre></td></tr></table></figure><p><br></p><p>如果是compressed tar file 或 zip archive source:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Preconfiguration setup</span></span><br><span class="line">shell&gt; groupadd mysql</span><br><span class="line">shell&gt; useradd -r -g mysql -s /bin/<span class="literal">false</span> mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Beginning of source-build specific instructions</span></span><br><span class="line">shell&gt; tar zxvf mysql-VERSION.tar.gz</span><br><span class="line">shell&gt; <span class="built_in">cd</span> mysql-VERSION</span><br><span class="line">shell&gt; mkdir bld</span><br><span class="line">shell&gt; <span class="built_in">cd</span> bld</span><br><span class="line">shell&gt; cmake ..</span><br><span class="line">shell&gt; make</span><br><span class="line">shell&gt; make install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># End of source-build specific instructions</span></span><br><span class="line"><span class="comment"># Postinstallation setup</span></span><br><span class="line">shell&gt; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</span><br><span class="line">shell&gt; mkdir mysql-files</span><br><span class="line">shell&gt; chown mysql:mysql mysql-files</span><br><span class="line">shell&gt; chmod 750 mysql-files</span><br><span class="line">shell&gt; bin/mysqld --initialize --user=mysql</span><br><span class="line">shell&gt; bin/mysql_ssl_rsa_setup</span><br><span class="line">shell&gt; bin/mysqld_safe --user=mysql &amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Next command is optional</span></span><br><span class="line">shell&gt; cp support-files/mysql.server /etc/init.d/mysql.server</span><br></pre></td></tr></table></figure><p><strong>/sbin/nologin和/bin/false的区别</strong></p><ul><li>/bin/false是最严格的禁止login选项，一切服务都不能用<ul><li><code>mongod:x:996:994:mongod:/var/lib/mongo:/bin/false</code></li></ul></li><li>/sbin/nologin只是不允许系统login，可以使用其他服务<ul><li><code>ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</code></li></ul></li></ul><p><br></p><p><strong>执行预配置(preconfiguration)设置</strong></p><p>在Unix上，设置MySQL用户和组，用于运行和执行MySQL服务器和数据库目录。</p><p><br></p><p><strong>获得和解包distribution</strong></p><p>选择要解压分发的目录，并将位置更改到其中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf mysql-VERSION.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#gunzip &lt; mysql-VERSION.tar.gz | tar xvf -</span></span><br><span class="line"><span class="comment">#cmake -E tar zxvf mysql-VERSION.tar.gz</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用开发源码树安装MySQL"><a href="#使用开发源码树安装MySQL" class="headerlink" title="使用开发源码树安装MySQL"></a>使用开发源码树安装MySQL</h3><p>Installing MySQL Using a Development Source Tree</p><p><br></p><p>install MySQL from the latest development source codew hich is hosted on GitHub: <a href="https://github.com/mysql/mysql-server" target="_blank" rel="noopener">https://github.com/mysql/mysql-server</a></p><p><strong>设置一个MySQL git repository</strong></p><ol><li>克隆MySQL git repository到本机</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/mysql/mysql-server.git</span><br></pre></td></tr></table></figure><ol><li>查看</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> mysql-server</span><br></pre></td></tr></table></figure><ol><li>使用<code>git branch -r</code>查看远程MySQL分支</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> mysql-server</span><br><span class="line"></span><br><span class="line">git branch -r</span><br></pre></td></tr></table></figure><ol><li>查看分支</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> mysql-server</span><br><span class="line"></span><br><span class="line">git branch</span><br></pre></td></tr></table></figure><ol><li>切换分支</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> mysql-server</span><br><span class="line"></span><br><span class="line">git checkout 5.7</span><br></pre></td></tr></table></figure><ol><li>获取远程MySQL git repository更新</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> mysql-server</span><br><span class="line"></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><ol><li>检查提交历史</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> mysql-server</span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#也可在MySQL GitHub上查看commit history</span></span><br></pre></td></tr></table></figure><ol><li>在克隆MySQL git repository并切换到需要的分支后，便可以从源代码构建MySQL Server。</li></ol><p>在生产机器上从分发源码树安装构件时要小心，安装命令可能会覆盖您的实时发行版安装。</p><p><br><br><br></p><h3 id="MySQL源码配置选项"><a href="#MySQL源码配置选项" class="headerlink" title="MySQL源码配置选项"></a>MySQL源码配置选项</h3><p>MySQL Source-Configuration Options</p><p><br></p><p>CMake程序提供了一个强大的如何配置MySQL源码发行版的控制。</p><p>具体链接参考: <a href="https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html</a></p><p><br><br><br></p><h3 id="处理MySQL编译问题"><a href="#处理MySQL编译问题" class="headerlink" title="处理MySQL编译问题"></a>处理MySQL编译问题</h3><p>Dealing with Problems Compiling MySQL</p><p><br></p><ul><li>如果CMake先前已经运行过，那么现在运行的CMake可能使用先前的调用过程中收集到的信息。这些信息存储在 CMakeCache.txt。在CMake启动时，它会寻找和读取此文件。</li><li>每次运行<code>CMake</code>，必须再次运行<code>make</code>才能重新编译。</li></ul><p>防止使用old object file或配置文件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">rm CMakeCache.txt</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="安装之后的设置和测试"><a href="#安装之后的设置和测试" class="headerlink" title="安装之后的设置和测试"></a>安装之后的设置和测试</h2><p>Postinstallation Setup and Testing</p><p><br></p><p>在安装MySQL后你应该做的事：</p><ul><li>如有必要，初始化数据目录并创建MySQL授权表</li><li>开启Server并确保它可以正常访问</li><li>将密码分配给授权表中的root用户</li><li>可选地，设置Server自启动</li><li>可选地，填写时区表，以便识别时区</li></ul><p><br></p><h3 id="初始化数据目录"><a href="#初始化数据目录" class="headerlink" title="初始化数据目录"></a>初始化数据目录</h3><p>Initializing the Data Directory</p><p><br></p><p>安装MySQL之后，必须初始化数据目录，包括mysql系统数据库中的表。有些安装方法会自动初始化，有些则需要手动初始化。<br>当然，如果修改了默认数据目录位置，那么也是需要手动初始化的。</p><p>初始化数据库目录，主要是包含了初始MySQL授权表(grant table)的MySQL服务器，这些表确定了如何允许用户连接到服务器。<br>但是，初始化数据目录是不会覆盖(overwrite)任何现有权限表，因此在任何情况下运行都是安全的。</p><p>数据目录初始化会在MySQL数据库汇总创建time zone，但不会填充它，所以它是空的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</span><br><span class="line"></span><br><span class="line">mkdir mysql-files</span><br><span class="line"></span><br><span class="line">chown mysql:mysql ./mysql-files</span><br><span class="line">chmod 750 ./mysql-files</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#--user</span></span><br><span class="line"><span class="comment">#使数据库目录文件属于mysql用户，以确保Server有读取权限</span></span><br><span class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqld --initialize --user=mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#开启安全连接</span></span><br><span class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysql_ssl_rsa_setup</span><br></pre></td></tr></table></figure><p><br></p><h4 id="使用mysqld手动初始化数据目录"><a href="#使用mysqld手动初始化数据目录" class="headerlink" title="使用mysqld手动初始化数据目录"></a>使用mysqld手动初始化数据目录</h4><p>Initializing the Data Directory Manually Using mysqld</p><p><br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使数据库目录文件属于mysql用户，以确保Server有读取权限</span></span><br><span class="line"><span class="comment">#默认是secure，会生成root初始密码</span></span><br><span class="line">./mysqld --initialize --user=mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#不生成root初始密码</span></span><br><span class="line">./bin/mysqld --initialize-insecure --user=mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定目录</span></span><br><span class="line">--basedir=/usr/<span class="built_in">local</span>/mysql</span><br><span class="line">--datadir=/var/lib/mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者将其写入配置文件</span></span><br><span class="line">vim /etc/my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/usr/<span class="built_in">local</span>/mysql</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定配置文件初始化</span></span><br><span class="line">./mysqld --defaults-file=/etc/mysql.cnf --initialize --user=mysql</span><br></pre></td></tr></table></figure><p><br></p><h4 id="使用mysql-install-db初始化数据目录"><a href="#使用mysql-install-db初始化数据目录" class="headerlink" title="使用mysql_install_db初始化数据目录"></a>使用mysql_install_db初始化数据目录</h4><p>Initializing the Data Directory Manually Using mysql_install_db</p><p><br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql_install_db命令会创建数据目录，并在数据目录下创建mysql数据库和授权表</span></span><br><span class="line">./mysql_install_db --user=mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定目录是必须的</span></span><br><span class="line">--basedir=/usr/<span class="built_in">local</span>/mysql</span><br><span class="line">--datadir=/var/lib/mysql</span><br><span class="line"></span><br><span class="line">./mysqld_safe --user=mysql &amp;</span><br><span class="line"><span class="comment">#systemctl start mysqld</span></span><br><span class="line"></span><br><span class="line">mysql -u root -p xxx</span><br><span class="line"></span><br><span class="line">mysql&gt;SET PASSWORD FOR <span class="string">'root'</span>@<span class="string">'localhost'</span> = PASSWORD(<span class="string">'new_password'</span>);</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Starting-the-Server"><a href="#Starting-the-Server" class="headerlink" title="Starting the Server"></a>Starting the Server</h3><ul><li>Start the MySQL server like this if your installation includes mysqld_safe<ul><li><code>/usr/local/mysql/binmysqld_safe --user=mysql &amp;</code></li></ul></li><li>Start the server like this if your installation includes systemd support<ul><li><code>systemctl start mysqld</code></li></ul></li><li>使用non-root用户运行MySQL服务很重要</li><li>如有错误请查看日志</li></ul><p><br><br><br></p><h3 id="Testing-the-Server"><a href="#Testing-the-Server" class="headerlink" title="Testing the Server"></a>Testing the Server</h3><p>执行一些简单测试以保证Server正常工作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用mysqladmin验证Server正在运行</span></span><br><span class="line">mysqladmin --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">mysqladmin -uuser -ppasswd version</span><br><span class="line"></span><br><span class="line">mysqladmin -uuser -ppasswd variables</span><br><span class="line"></span><br><span class="line">mysqladmin -user -ppasswd shutdown</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用mysqlshow查看数据库</span></span><br><span class="line">mysqlshow -uuser -ppasswd</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看指定数据库信息</span></span><br><span class="line">mysqlshow -uuser -ppasswd mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取信息</span></span><br><span class="line"><span class="comment">#-e,Execute command and quit</span></span><br><span class="line">mysql -uuser -ppasswd -e <span class="string">"SELECT user, host from mysql.user"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="保护初始化MySQL账户"><a href="#保护初始化MySQL账户" class="headerlink" title="保护初始化MySQL账户"></a>保护初始化MySQL账户</h3><p>Securing the Initial MySQL Accounts</p><p><br></p><p>在安装MySQL后，root账户密码可能已经被分配。</p><p><code>mysql.user</code>授权表定义了初始化MySQL用户账户和它们的访问权限。<br>MySQL5.7只创建了一个<code>&#39;root&#39;@&#39;localhost&#39;</code>账户，但早期的版本可能有多个用户。</p><p>请务必为每一个MySQL账户创建密码。</p><p>查看用户：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#存储在authentication_string列中的密码可能包含无法正常显示的二进制数据</span></span><br><span class="line"><span class="comment">#所以将其转换为十六进制</span></span><br><span class="line">mysql&gt; SELECT user, host, hex(authentication_string) FROM mysql.user;</span><br><span class="line">mysql&gt; SELECT user, host, authentication_string FROM mysql.user;</span><br><span class="line"></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">mysql -uuser -ppasswd -e <span class="string">"SELECT user, host, hex(authentication_string) FROM mysql.user;"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.7以前的版本</span></span><br><span class="line">mysql&gt; mysql&gt; SELECT user, host, password FROM mysql.user;</span><br><span class="line"></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">mysql -uuser -ppasswd -e <span class="string">"SELECT user, host, password FROM mysql.user;"</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>为root账户分配密码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#5.7.6</span><br><span class="line">mysql&gt; ALTER USER user IDENTIFIED BY &apos;new_passwd&apos;;</span><br><span class="line"></span><br><span class="line">mysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;new_passwd&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5.7.6前</span><br><span class="line">mysql&gt; SET PASSWORD FOR username = PASSWORD(&apos;new_passwd&apos;);</span><br><span class="line"></span><br><span class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;new_passwd&apos;);</span><br></pre></td></tr></table></figure><p><br></p><p><strong>给anonymous账户分配密码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD FOR &apos;&apos;@&apos;localhost&apos; = PASSWORD(&apos;new_passwd&apos;);</span><br></pre></td></tr></table></figure><p><br></p><p><strong>移除匿名账户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP USER &apos;&apos;@&apos;localhost&apos;;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="升级或降级MySQL"><a href="#升级或降级MySQL" class="headerlink" title="升级或降级MySQL"></a>升级或降级MySQL</h2><p>Upgrading or Downgrading MySQL</p><p><br></p><ul><li>升级是一个常见的过程。请在测试系统上确保运行正常后再实施到生产环境</li><li>降级不太常见。一般是由于新版本在生产环境上发生某些兼容性或性能问题，并且是在测试环境中没有发现的情况下，从而需要降级。请现在测试系统上运行正常后再实施到生产环境。</li></ul><p><br><br><br></p><h3 id="升级MySQL"><a href="#升级MySQL" class="headerlink" title="升级MySQL"></a>升级MySQL</h3><p>请使用有管理权限的MySQL账户执行升级相关命令。(如root账户)</p><p><br></p><h4 id="MySQL升级策略"><a href="#MySQL升级策略" class="headerlink" title="MySQL升级策略"></a>MySQL升级策略</h4><p>MySQL Upgrade Strategies</p><p><br></p><p><strong>升级方法</strong></p><ul><li>直接升级(In-Place Upgrade)<ul><li>包含关闭旧版MySQL，替换为新的MySQL版本，在现有数据目录上重启MySQL，运行<code>mysql_upgrade</code></li></ul></li><li>逻辑升级(Logical Upgrade)<ul><li>包含使用<code>mysqldump</code>导出现有数据文件，安装新版MySQL，导入数据文件到新版MySQL，运行<code>mysql_upgrade</code></li></ul></li></ul><p><br></p><p><strong>升级路径</strong></p><ul><li>只支持GA release之间</li><li>这是一个发行系列的升级<ul><li>如5.6.x到5.6.y</li></ul></li><li>升级到下一个版本之前，建议先升级到最新版本<ul><li>如先升级到5.6最新版，再升级到5.7</li></ul></li><li>不支持跳版本升级<ul><li>如5.5到5.7</li></ul></li></ul><p><br></p><p><strong>升级之前</strong></p><ul><li>升级之前，请一定备份数据</li><li>查看新版本的Release Note<ul><li>删除和增加了什么功能</li></ul></li><li>新版本依赖什么</li><li>如果在InnoDB中使用XA事务，则在升级之前运行XA恢复以检查未提交的XA事务</li><li>如果MySQL数据量很大，就地升级以后可能需要很长的时间才能进行转换<ul><li>你可能会发现创建一个”dummy”数据库实例是很有用的，以及评估可能需要哪些转换以及执行这些转换所涉及的工作</li></ul></li><li>无论在你安装或升级到一个MySQL新版本，建议重建和重装MySQL language interface<ul><li>如PHP MySQL扩展</li></ul></li></ul><p><br></p><p><strong>直接升级</strong></p><ul><li>配置MySQL执行slow shutdown</li></ul><p>innoDB在关闭前执行一个完整的清除和更改缓冲区合并，这确保数据文件在不同的版本的文件格式做好充分准备。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p --execute=<span class="string">"SET GLOBAL innodb_fast_shutdown=0"</span></span><br></pre></td></tr></table></figure><ul><li>关闭MySQL Server</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p shutdown</span><br></pre></td></tr></table></figure><ul><li><p>升级MySQL</p></li><li><p>开启新版MySQL</p></li><li><p>运行mysql_upgrade</p></li></ul><p><code>mysql_upgrade</code>检查所有数据库中的所有表与当前版本MySQL的不兼容性。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql_upgrade -uroot -p</span><br><span class="line"></span><br><span class="line"><span class="comment">#Upgrade process completed successfully.</span></span><br><span class="line"><span class="comment">#Checking if update is needed.</span></span><br></pre></td></tr></table></figure><ul><li>关闭和重启MySQL Server来确保改变生效</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p shutdown</span><br><span class="line"></span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure><p><br></p><p><strong>逻辑升级</strong></p><ul><li>导出所有数据</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p  --all-databases --force &gt; mysqldb_backup.sql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#-f, --force         Continue even if we get an SQL error</span></span><br><span class="line"><span class="comment">#Use the --routines and --events options if your databases include stored programs</span></span><br><span class="line"><span class="comment">#--add-drop-database Add a DROP DATABASE before each create.</span></span><br><span class="line">mysqldump -uroot -p --add-drop-table --routines --events --all-databases --force &gt; mysqldb_backup.sql</span><br></pre></td></tr></table></figure><ul><li>关闭MySQL Server</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p shutdown</span><br></pre></td></tr></table></figure><ul><li><p>安装新版MySQL</p></li><li><p>初始化MySQL并启动</p></li><li><p>载入数据文件</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p --force &lt; ./mysqldb_backup.sql</span><br></pre></td></tr></table></figure><ul><li>运行mysql_upgrade</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql_upgrade -uroot -p</span><br><span class="line"></span><br><span class="line"><span class="comment">#Upgrade process completed successfully.</span></span><br><span class="line"><span class="comment">#Checking if update is needed.</span></span><br></pre></td></tr></table></figure><ul><li>关闭并重启MySQL Server以确保更改生效</li></ul><p><br></p><h4 id="通过MySQL-Yum-Repository进行升级"><a href="#通过MySQL-Yum-Repository进行升级" class="headerlink" title="通过MySQL Yum Repository进行升级"></a>通过MySQL Yum Repository进行升级</h4><p>Upgrading MySQL with the MySQL Yum Repository</p><p><br></p><p><strong>选择一个target series</strong></p><p>默认情况下，MySQL Yum Repository会将MySQL升级到该release系列的最新版本。如5.7.1升级到5.7.10。</p><p>如果要升级到其他release(如5.6到5.7)，就必须要先禁用此subrepository，并选择和启用新的subrepository。</p><p>As a general rule, to upgrade from one release series to another, go to the next series rather than skipping a series.</p><p><br></p><p><strong>升级MySQL</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update mysql-server mysql-client</span><br></pre></td></tr></table></figure><p><br></p><p><strong>重启MySQL</strong></p><p>MySQL Server总是在Yum更新之后重启，一旦重启，请运行<code>mysql_upgrade</code>来检查旧数据与升级软件之间的任何不兼容问题。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql_upgrade -uroot -p</span><br><span class="line"></span><br><span class="line"><span class="comment">#Upgrade process completed successfully.</span></span><br><span class="line"><span class="comment">#Checking if update is needed.</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>升级Shared Client Libraries</strong></p><p>所以说，用yum repository安装软件是很方便的。不管是在管理还是升级等方面…</p><p><br></p><h4 id="通过直接下载RPM包升级MySQL"><a href="#通过直接下载RPM包升级MySQL" class="headerlink" title="通过直接下载RPM包升级MySQL"></a>通过直接下载RPM包升级MySQL</h4><p>直接下载mysql相应组件的rpm进行升级。<br>建议备份好配置文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql-community-server-5.7.20-1.el7.x86_64.rpm</span><br><span class="line">wget http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql-community-client-5.7.20-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum install mysql-community-server-5.7.20-1.el7.x86_64.rpm mysql-community-client-5.7.20-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="mysql降级"><a href="#mysql降级" class="headerlink" title="mysql降级"></a>mysql降级</h3><p>MySQL降级类似于MySQL升级。也包含有直接降级和逻辑降级。</p><p><br><br><br></p><h3 id="重建或修复表或索引"><a href="#重建或修复表或索引" class="headerlink" title="重建或修复表或索引"></a>重建或修复表或索引</h3><p>Rebuilding or Repairing Tables or Indexes</p><p><br></p><ul><li>MySQL处理数据类型和字符集的方式的更改</li><li>表维修或升级(mysqlcheck, mysql_upgrade)</li></ul><p>重建表的方法：</p><ul><li>Dump and Reload</li><li>ALTER TABLE</li><li>REPAIR TABLE</li></ul><p><br></p><p><strong>Dump and Reload Method</strong></p><p>由于MySQL升级/降级之后，不同版本的MySQL无法处理这些表，则需要转储和重载的方法来重建表。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p --all-databases --force &gt; mysql_backdb.sql</span><br><span class="line">mysql -uroot -p --force &lt; mysql_backdb.sql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#某个库或表</span></span><br><span class="line">mysqldump -uroot -p --databases <span class="built_in">test</span> --force &gt; db_test.sql</span><br><span class="line">mysql -uroot -p <span class="built_in">test</span> &lt; db_test.sql</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p --databases <span class="built_in">test</span> --tables table222 &gt; table222.sql</span><br><span class="line">mysql -uroot -p <span class="built_in">test</span>  &lt; table222.sql</span><br></pre></td></tr></table></figure><p><br></p><p><strong>ALTER TABLE Method</strong></p><p>更改表以使用它已经拥有的存储引擎。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE test ENGINE = InnoDB;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>REPAIR TABLE Method</strong></p><p><code>REPAIR TABLE</code>仅适用于MyISAM， ARCHIVE和 csv 表。</p><p><code>mysqlcheck --repair</code>提供了对<code>REPAIR TABLE</code>的命令行访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPAIR TABLE t1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysqlcheck --repair --databases db_name ...</span><br><span class="line">mysqlcheck --repair --all-databases</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="复制MySQL数据库到其他机器"><a href="#复制MySQL数据库到其他机器" class="headerlink" title="复制MySQL数据库到其他机器"></a>复制MySQL数据库到其他机器</h3><p>Copying MySQL Databases to Another Machine</p><p><br></p><p>在需要为不同体系架构之间传输MySQL数据库时，可使用<code>mysqldump</code>创建包含SQL语句的<code>.sql</code>文件，然后复制到另外的计算机上，将其作为输入提供给MySQL客户端。</p><p>不要忘记复制mysql数据库，因为这个存储授权表的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --host &apos;remote-host&apos; -uxxx -p --compress --all-databases | mysql -uxxx -p</span><br><span class="line"></span><br><span class="line">mysqldump --host &apos;remote-host&apos; -uxxx -p --compress db_name | mysql -uxxx -p db_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysqladmin -uxxx -p flush-privileges</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h1><p>如何使用MySQL client程序来创建和使用数据库。</p><p><br></p><h2 id="连接和断开服务器"><a href="#连接和断开服务器" class="headerlink" title="连接和断开服务器"></a>连接和断开服务器</h2><p>Connecting to and Disconnecting from the Server</p><p><br></p><p>Like this:</p><ul><li>不建议把密码直接写在命令行上</li><li>host表示了MySQL Server运行在的机器</li><li>某些MySQL允许匿名用户连接</li><li><code>-ppassword, not as -p password</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql --host host --user username -p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#maybe not default port</span></span><br><span class="line">mysql --host host --user username -p  --port port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#匿名用户连接</span></span><br><span class="line">mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#退出</span></span><br><span class="line">mysql&gt; QUIT</span><br><span class="line"><span class="comment">#Unix</span></span><br><span class="line">mysql&gt; Ctrl+D</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="输入查询"><a href="#输入查询" class="headerlink" title="输入查询"></a>输入查询</h2><p>Entering Queries</p><p><br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#简单查询</span><br><span class="line">mysql&gt; SELECT VERSION(), CURRENT_DATE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#简单计算</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SIN</span>(<span class="keyword">PI</span>()/<span class="number">2</span>), (<span class="number">4</span>+<span class="number">1</span>)*<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#一行中输入多个语句</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>(); <span class="keyword">SELECT</span> <span class="keyword">NOW</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#多行输入一个命令</span><br><span class="line">mysql&gt; SELECT</span><br><span class="line">    -&gt; USER()</span><br><span class="line">    -&gt; ,</span><br><span class="line">    -&gt; CURRENT_DATE;</span><br></pre></td></tr></table></figure><p><img src="/images/MySQL/20180301101009.jpg" alt="MySQL简单查询"></p><p><br></p><p>这QUERY说明了有关MySQL的几件事：</p><ul><li>MySQL查询通常由一个<code>SQL statement</code>和<code>;</code>组成</li><li>MySQL将查询发送给服务器并返回结果，然后打印下一个<code>mysql&gt;</code>提示</li><li>MySQL以表格形式(rows and columns)显示查询输出</li><li>MySQL显示返回多少行，以及执行查询花费了多长时间</li><li>MySQL查询不区分大小写，但建议使用大写</li><li>MySQL支持在一行中输入多个语句</li><li>MySQL支持一个命令多行输入</li></ul><p><br></p><p><strong>MySQL提示符：</strong></p><table><thead><tr><th>Prompt</th><th>Meaning</th></tr></thead><tbody><tr><td><code>mysql&gt;</code></td><td>准备新查询</td></tr><tr><td><code>-&gt;</code></td><td>等待多行查询的下一行</td></tr><tr><td><code>&#39;&gt;</code></td><td>等待下一行，等待单引号开头的字符串的完成</td></tr><tr><td><code>&quot;&gt;</code></td><td>等待下一行，等待双引号字开头的字符串的完成</td></tr><tr><td><code>\</code>&gt;`</td><td>等待下一行，等待以反引号开始的标识符的完成</td></tr><tr><td><code>/*&gt;</code></td><td>等待下一行，等待以<code>/*</code>开头的注释的完成–&gt;<code>/*comments*/</code></td></tr></tbody></table><p><br><br><br></p><h2 id="创建和使用数据库"><a href="#创建和使用数据库" class="headerlink" title="创建和使用数据库"></a>创建和使用数据库</h2><p>Creating and Using a Database</p><p><br></p><p>大致操作：</p><ul><li>Create a database</li><li>Create a table</li><li>Load data into the table</li><li>Retrieve data from the table in various ways</li><li>Use multiple tables</li></ul><p><br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#显示数据库</span><br><span class="line">#不能显示你没有权限的数据库</span><br><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line"></span><br><span class="line">#mysql数据库描述用户访问权限</span><br><span class="line">#test数据库通常作为用户尝试使用工作区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#访问数据库</span><br><span class="line">mysql&gt; USE test;</span><br><span class="line"></span><br><span class="line">#USE和QUIT一样可以不使用分号，使用也无妨</span><br><span class="line">#USE只能是一个单行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#授权</span><br><span class="line">#GRANT ALL ON da_name.table TO 'username'@'host';</span><br><span class="line">mysql&gt; GRANT ALL ON test.* TO 'test'@'127.0.0.1';</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="创建和选择数据库"><a href="#创建和选择数据库" class="headerlink" title="创建和选择数据库"></a>创建和选择数据库</h3><p>Creating and Selecting a Database</p><p><br></p><p><strong>Unix是区分大小写的(case-sensitive)，这与SQL keyword不一致。请注意。</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE db01;</span><br><span class="line"></span><br><span class="line">mysql&gt; USE db01;</span><br><span class="line"></span><br><span class="line">#也可在mysql连接时直接指定数据库</span><br><span class="line">mysql -u username -p db01</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看当前选择的数据库</span><br><span class="line">mysql&gt; SELECT DATABASE();</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>Creating a Table</p><p><br></p><p><strong>困难的部分是决定数据库的结构应该是什么： 你需要哪些表以及每个表中应该包含哪些列。</strong></p><p><code>VARCHAR</code>对于name，owner，species来说是一个不错的选择，因为column值的长度有所不同。<br><code>DATE</code>对于出生和死亡column来说很不错。<br>如果以后你发现你需要更长的字段，MySQL提供了一个<code>ALTER TABLE</code>语句来修改。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#创建一个宠物表</span><br><span class="line">mysql&gt; CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),</span><br><span class="line">    -&gt; species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#验证表格</span><br><span class="line">#如果你忘记了表中列的名称或类型，使用DESCRIBE</span><br><span class="line">mysql&gt; DECRIBE pet;</span><br><span class="line">+<span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line">| name    | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| owner   | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| species | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| sex     | char(1)     | YES  |     | NULL    |       |</span><br><span class="line">| birth   | date        | YES  |     | NULL    |       |</span><br><span class="line">| death   | date        | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">---------+-------------+------+-----+---------+-------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="将数据载入表格"><a href="#将数据载入表格" class="headerlink" title="将数据载入表格"></a>将数据载入表格</h3><p>Loading Data into a Table</p><p><br></p><p>假设pet表信息如下：</p><table><thead><tr><th>name</th><th>owner</th><th>species</th><th>sex</th><th>birth</th><th>death</th></tr></thead><tbody><tr><td>PetA</td><td>Aa</td><td>cat</td><td>f</td><td>1993-02-04</td><td></td></tr><tr><td>PetB</td><td>Bb</td><td>cat</td><td>m</td><td>1994-03-17</td><td></td></tr><tr><td>PetC</td><td>Cc</td><td>dog</td><td>f</td><td>1989-05-13</td><td></td></tr><tr><td>PetD</td><td>Aa</td><td>dog</td><td>m</td><td>1979-08-25</td><td>1995-02-21</td></tr><tr><td>PetE</td><td>Cc</td><td>bird</td><td></td><td>1991-02-17</td><td></td></tr></tbody></table><p><br></p><p>你可以创建一个<code>pet.txt</code>文本文件，每行包含一个记录，值由制表符分割，并按照<code>CREATE TABLE</code>语句中列出的顺序给出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim pet.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PetA    Aa     cat    f      1993-02-04    \N</span><br><span class="line">PetB    Bb     cat    m      1994-03-17    \N</span><br><span class="line">PetC    Cc     dog    f      1989-05-13    \N</span><br><span class="line">PetD    Aa     dog    m      1979-08-25    1995-02-21</span><br><span class="line">PetE    Cc     bird  \N      1991-02-17    \N</span><br></pre></td></tr></table></figure><p>将<code>pet.txt</code>载入<code>pet</code>表中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; LOAD DATA LOCAL INFILE '/path/file.txt' INTO TABLE table_name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; LOAD DATA LOCAL INFILE '/home/zhang/pet.txt' INTO TABLE pet;</span><br><span class="line">Query OK, 5 rows affected, 0 warnings (0.00 sec)</span><br><span class="line">Records: 5  Deleted: 0  Skipped: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM pet;</span><br><span class="line">+<span class="comment">-------+-------+---------+------+------------+------------+</span></span><br><span class="line">| name  | owner | species | sex  | birth      | death      |</span><br><span class="line">+<span class="comment">-------+-------+---------+------+------------+------------+</span></span><br><span class="line">| PetA  |  Aa   |  cat    | f    | 1993-02-04 | NULL       |</span><br><span class="line">| PetB  |  Bb   |  cat    | m    | 1994-03-17 | NULL       |</span><br><span class="line">| PetC  |  Cc   |  dog    | f    | 1989-05-13 | NULL       |</span><br><span class="line">| PetD  |  Aa   |  dog    | m    | 1979-08-25 | 1995-02-21 |</span><br><span class="line">| PetE  |  Cc   |  bird   | NULL | 1991-02-17 | NULL       |</span><br><span class="line">+<span class="comment">-------+-------+---------+------+------------+------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#通过命令行载入</span><br><span class="line">mysql&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> pet</span><br><span class="line">    -&gt; <span class="keyword">VALUES</span> (<span class="string">'PetF'</span>, <span class="string">'Ff'</span>, <span class="string">'hamster'</span>, <span class="string">'f'</span>, <span class="string">'1999-03-21'</span>, <span class="literal">NULL</span>)</span><br><span class="line">    -&gt; ;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="从表中检索信息"><a href="#从表中检索信息" class="headerlink" title="从表中检索信息"></a>从表中检索信息</h3><p>Retrieving Information from a Table</p><p><br></p><p><code>SELECT</code>语句用于从表中提取信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> what_to_select</span><br><span class="line"><span class="keyword">FROM</span> which_table</span><br><span class="line"><span class="keyword">WHERE</span> condition;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="查询所有数据"><a href="#查询所有数据" class="headerlink" title="查询所有数据"></a>查询所有数据</h4><p>Selecting All Data</p><p><br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM pet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; DELETE FROM pet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE pet SET birth = '1989-06-17' WHERE name = 'PetC';</span><br></pre></td></tr></table></figure><p><br></p><h4 id="查询特定行"><a href="#查询特定行" class="headerlink" title="查询特定行"></a>查询特定行</h4><p>Selecting Particular Rows</p><p><br></p><p>当一个表很大时，你通常不想看到整个表。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#条件查询</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE name = 'PetA';</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE owner = 'Cc';</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE birth &gt;= '1990-01-01';</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#AND</span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE species = 'dog' AND sex = 'f';</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#OR</span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE species = 'dog' OR species = 'bird';</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#AND和OR也可以混合使用</span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE (species = 'cat' AND sex = 'm') OR (species = 'dog' AND sex='f');</span><br></pre></td></tr></table></figure><p><br></p><h4 id="查询特定列"><a href="#查询特定列" class="headerlink" title="查询特定列"></a>查询特定列</h4><p>Selecting Particular Columns</p><p><br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM pet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT name, species FROM pet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#获取唯一结果</span><br><span class="line">mysql&gt; SELECT DISTINCT species FROM pet;</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| species |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">| cat     |</span><br><span class="line">| dog     |</span><br><span class="line">| bird    |</span><br><span class="line">+<span class="comment">---------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, species, birth <span class="keyword">FROM</span> pet <span class="keyword">WHERE</span> species = <span class="string">'dog'</span> <span class="keyword">OR</span> species = <span class="string">'cat'</span>;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="行排序"><a href="#行排序" class="headerlink" title="行排序"></a>行排序</h4><p>Sorting Rows</p><p><br></p><p>使用<code>ORDER BY</code>语句对结果进行排序。默认排序顺序是升序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name, birth FROM pet ORDER BY birth;</span><br><span class="line">+<span class="comment">------+------------+</span></span><br><span class="line">| name | birth      |</span><br><span class="line">+<span class="comment">------+------------+</span></span><br><span class="line">| PetD | 1979-08-25 |</span><br><span class="line">| PetC | 1989-06-17 |</span><br><span class="line">| PetE | 1991-02-17 |</span><br><span class="line">| PetA | 1993-02-04 |</span><br><span class="line">| PetB | 1994-03-17 |</span><br><span class="line">+<span class="comment">------+------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#倒序</span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, birth <span class="keyword">FROM</span> pet <span class="keyword">ORDER</span> <span class="keyword">BY</span> birth <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>可对多列进行排序，也可按不同的方向对不同的列进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name, species, birth FROM pet</span><br><span class="line">    -&gt; ORDER BY species, birth DESC;</span><br><span class="line">+<span class="comment">------+---------+------------+</span></span><br><span class="line">| name | species | birth      |</span><br><span class="line">+<span class="comment">------+---------+------------+</span></span><br><span class="line">| PetE | bird    | 1991-02-17 |</span><br><span class="line">| PetB | cat     | 1994-03-17 |</span><br><span class="line">| PetA | cat     | 1993-02-04 |</span><br><span class="line">| PetC | dog     | 1989-06-17 |</span><br><span class="line">| PetD | dog     | 1979-08-25 |</span><br><span class="line">+<span class="comment">------+---------+------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, species, birth <span class="keyword">FROM</span> pet</span><br><span class="line">    -&gt; <span class="keyword">ORDER</span> <span class="keyword">BY</span> species <span class="keyword">DESC</span>, birth <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h4><p>Date Calculations</p><p><br></p><p>MySQL提供了几个函数用于日期计算。如计算年龄或提取日期一部分等。</p><p><br></p><ul><li><code>TIMESTAMPDIFF()</code><ul><li>使用<code>TIMESTAMPDIFF()</code>函数计算pet的年龄。它的两个参数为两个相隔的日期</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name, species, birth, CURDATE(),</span><br><span class="line">    -&gt; TIMESTAMPDIFF(YEAR, birth, CURDATE()) AS age</span><br><span class="line">    -&gt; FROM pet</span><br><span class="line">    -&gt; ORDER BY age DESC;</span><br><span class="line">+<span class="comment">------+---------+------------+------------+------+</span></span><br><span class="line">| name | species | birth      | CURDATE()  | age  |</span><br><span class="line">+<span class="comment">------+---------+------------+------------+------+</span></span><br><span class="line">| PetD | dog     | 1979-08-25 | 2018-03-01 |   38 |</span><br><span class="line">| PetC | dog     | 1989-06-17 | 2018-03-01 |   28 |</span><br><span class="line">| PetE | bird    | 1991-02-17 | 2018-03-01 |   27 |</span><br><span class="line">| PetA | cat     | 1993-02-04 | 2018-03-01 |   25 |</span><br><span class="line">| PetB | cat     | 1994-03-17 | 2018-03-01 |   23 |</span><br><span class="line">+<span class="comment">------+---------+------------+------------+------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#死去的pet的age</span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, species, birth, death,</span><br><span class="line">    -&gt; <span class="keyword">TIMESTAMPDIFF</span>(<span class="keyword">YEAR</span>, birth, death) <span class="keyword">AS</span> age</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> pet</span><br><span class="line">    -&gt; <span class="keyword">WHERE</span> death <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">    -&gt; <span class="keyword">ORDER</span> <span class="keyword">BY</span> age;</span><br><span class="line">+<span class="comment">------+---------+------------+------------+------+</span></span><br><span class="line">| name | species | birth      | death      | age  |</span><br><span class="line">+<span class="comment">------+---------+------------+------------+------+</span></span><br><span class="line">| PetD | dog     | 1979-08-25 | 1995-02-21 |   15 |</span><br><span class="line">+<span class="comment">------+---------+------------+------------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><br></p><ul><li><code>YEAR()</code><ul><li>年</li></ul></li><li><code>MONTH()</code><ul><li>月</li></ul></li><li><code>DAYOFMONTH()</code><ul><li>日</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name, birth,</span><br><span class="line">    -&gt; YEAR(birth) AS bir_year,</span><br><span class="line">    -&gt; MONTH(birth) AS bir_month,</span><br><span class="line">    -&gt; DAYOFMONTH(birth) AS bir_day</span><br><span class="line">    -&gt; FROM pet;</span><br><span class="line">+<span class="comment">------+------------+----------+-----------+---------+</span></span><br><span class="line">| name | birth      | bir_year | bir_month | bir_day |</span><br><span class="line">+<span class="comment">------+------------+----------+-----------+---------+</span></span><br><span class="line">| PetA | 1993-02-04 |     1993 |         2 |       4 |</span><br><span class="line">| PetB | 1994-03-17 |     1994 |         3 |      17 |</span><br><span class="line">| PetC | 1989-06-17 |     1989 |         6 |      17 |</span><br><span class="line">| PetD | 1979-08-25 |     1979 |         8 |      25 |</span><br><span class="line">| PetE | 1991-02-17 |     1991 |         2 |      17 |</span><br><span class="line">+<span class="comment">------+------------+----------+-----------+---------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查找生日是<span class="number">2</span>月的pet</span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, birth <span class="keyword">FROM</span> pet <span class="keyword">WHERE</span> <span class="keyword">MONTH</span>(birth) =<span class="number">2</span>;</span><br><span class="line">+<span class="comment">------+------------+</span></span><br><span class="line">| name | birth      |</span><br><span class="line">+<span class="comment">------+------------+</span></span><br><span class="line">| PetA | 1993-02-04 |</span><br><span class="line">| PetE | 1991-02-17 |</span><br><span class="line">+<span class="comment">------+------------+</span></span><br></pre></td></tr></table></figure><p><br></p><ul><li><code>DATE_ADD()</code><ul><li>将日期间隔添加到给定日期</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name, birth FROM pet</span><br><span class="line">    -&gt; WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(), INTERVAL 1 MONTH));</span><br></pre></td></tr></table></figure><p><br></p><h4 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h4><p>Working with NULL Values</p><p><br></p><p>从概念上讲，NULL value意味着<strong>一个缺失的未知值</strong>，它与其它值在某种程度上是不同的。</p><ul><li>使用<code>IS NULL</code>和<code>IS NOT NULL</code>操作符</li><li>不能对NULL value使用算术运算符(arithmetic cpmparison operators)<ul><li>如：<code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;&gt;</code></li><li>任何对NULL value的算术运算符的结果也是NULL value，所以无法得到有意义的结果</li></ul></li><li>在MySQL中，0或NULL表示false，其他任何值都意味着true</li><li>两个NULL在<code>GROUP BY</code>中被认为是相等的</li><li>NULL在<code>ORDER BY</code>正向排序中首先显示。反之，最后显示</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 1 IS NULL, 1 IS NOT NULL;</span><br><span class="line">+<span class="comment">-----------+---------------+</span></span><br><span class="line">| 1 IS NULL | 1 IS NOT NULL |</span><br><span class="line">+<span class="comment">-----------+---------------+</span></span><br><span class="line">|         0 |             1 |</span><br><span class="line">+<span class="comment">-----------+---------------+</span></span><br></pre></td></tr></table></figure><p>因此，完全可以将一个<strong>zero</strong>或<strong>empty string</strong>插入到一个<strong>NOT NULL</strong>的column中，因为这些值NOT NULL。</p><p><br></p><h4 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h4><p>Pattern Matching</p><p><br></p><p>MySQL提供标准的SQL模式匹配以及基于扩展正则表达式的模式匹配形式。类似于Unix实用程序(vi, grep, sed…)</p><p>SQL模式匹配允许:</p><ul><li>使用<code>_</code>来匹配可以使用的任意单字符(single character)</li><li>使用<code>%</code>来匹配可以使用的任意数目的字符(arbitrary number of characters)</li><li>SQL模式不区分大小写</li><li>使用<code>LIKE</code>或<code>NOT LIKE</code>而不是<code>=</code>或<code>&lt;&gt;</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM pet WHERE name LIKE '%b';</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br><span class="line">| name | owner | species | sex  | birth      | death |</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br><span class="line">| PetB | Bb    | cat     | m    | 1994-03-17 | NULL  |</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE name LIkE '___A' or name LIKE '___C';</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br><span class="line">| name | owner | species | sex  | birth      | death |</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br><span class="line">| PetA | Aa    | cat     | f    | 1993-02-04 | NULL  |</span><br><span class="line">| PetC | Cc    | dog     | f    | 1989-06-17 | NULL  |</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br></pre></td></tr></table></figure><p><br></p><p>MySQL提供的其它类型的模式匹配使用扩展的正则表达式：</p><ul><li><code>REGEXP</code> 或 <code>RLIKE</code></li><li><code>NOT REGEXP</code> 或 <code>NOT RLIKE</code></li><li>了解正则表达式知识</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE '^pet[AB]';</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br><span class="line">| name | owner | species | sex  | birth      | death |</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br><span class="line">| PetA | Aa    | cat     | f    | 1993-02-04 | NULL  |</span><br><span class="line">| PetB | Bb    | cat     | m    | 1994-03-17 | NULL  |</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE owner RLIKE 'c$';</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br><span class="line">| name | owner | species | sex  | birth      | death |</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br><span class="line">| PetC | Cc    | dog     | f    | 1989-06-17 | NULL  |</span><br><span class="line">| PetE | Cc    | bird    | NULL | 1991-02-17 | NULL  |</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#包含某个字符</span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE 'ete';</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br><span class="line">| name | owner | species | sex  | birth      | death |</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br><span class="line">| PetE | Cc    | bird    | NULL | 1991-02-17 | NULL  |</span><br><span class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#匹配字符个数</span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE '^....$';</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE '^.&#123;4&#125;$';</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#强制区分大小写</span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE BINARY '^Pet[AB]';</span><br></pre></td></tr></table></figure><p><br></p><h4 id="行数计算"><a href="#行数计算" class="headerlink" title="行数计算"></a>行数计算</h4><p>Counting Rows</p><p><br></p><ul><li>使用<code>COUNT()</code>计算行数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#总行数</span><br><span class="line">mysql&gt; SELECT COUNT(*) AS count FROM pet;</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| count |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|     5 |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#针对某个统计行数</span><br><span class="line">mysql&gt; SELECT owner, COUNT(*) FROM pet GROUP BY owner;</span><br><span class="line">+<span class="comment">-------+----------+</span></span><br><span class="line">| owner | COUNT(*) |</span><br><span class="line">+<span class="comment">-------+----------+</span></span><br><span class="line">| Aa    |        2 |</span><br><span class="line">| Bb    |        1 |</span><br><span class="line">| Cc    |        2 |</span><br><span class="line">+<span class="comment">-------+----------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#多个条件</span><br><span class="line">mysql&gt; SELECT species, sex, COUNT(*) FROM pet GROUP BY species, sex;</span><br><span class="line">+<span class="comment">---------+------+----------+</span></span><br><span class="line">| species | sex  | COUNT(*) |</span><br><span class="line">+<span class="comment">---------+------+----------+</span></span><br><span class="line">| bird    | NULL |        1 |</span><br><span class="line">| cat     | f    |        1 |</span><br><span class="line">| cat     | m    |        1 |</span><br><span class="line">| dog     | f    |        1 |</span><br><span class="line">| dog     | m    |        1 |</span><br><span class="line">+<span class="comment">---------+------+----------+</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="使用多个表"><a href="#使用多个表" class="headerlink" title="使用多个表"></a>使用多个表</h4><p>Using More Than one Table</p><p><br></p><p>创建一个额外的宠物信息表：</p><table><thead><tr><th>name</th><th>date</th><th>type</th><th>remark</th></tr></thead><tbody><tr><td>Fluffy</td><td>1995-05-15</td><td>litter</td><td>4 kittens, 3 female, 1 male</td></tr><tr><td>Buffy</td><td>1993-06-23</td><td>litter</td><td>5 puppies, 2 female, 3 male</td></tr><tr><td>Buffy</td><td>1994-06-19</td><td>litter</td><td>3 puppies, 3 female</td></tr><tr><td>Chirpy</td><td>1999-03-21</td><td>vet</td><td>needed beak straightened</td></tr><tr><td>Slim</td><td>1997-08-03</td><td>vet</td><td>broken rib</td></tr><tr><td>Bowser</td><td>1991-10-12</td><td>kennel</td><td></td></tr><tr><td>Fang</td><td>1991-10-12</td><td>kennel</td><td></td></tr><tr><td>Fang</td><td>1998-08-28</td><td>birthday</td><td>Gave him a new chew toy</td></tr><tr><td>Claws</td><td>1998-03-17</td><td>birthday</td><td>Gave him a new flea collar</td></tr><tr><td>Whistler</td><td>1998-12-09</td><td>birthday</td><td>First birthday</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE event ( name VARCHAR(20), date DATE,</span><br><span class="line">    -&gt; type VARCHAR(15), remark VARCHAR(255) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; LOAD DATA INFILE '/path/event.txt' INTO TABLE event;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="获取数据库和表的信息"><a href="#获取数据库和表的信息" class="headerlink" title="获取数据库和表的信息"></a>获取数据库和表的信息</h2><p>Getting Information About Databases and Tables</p><p><br></p><ul><li>查看当前数据库<ul><li><code>mysql&gt; SELECT DATABASE();</code></li></ul></li><li>查看当前数据库下的表<ul><li><code>mysql&gt; SHOW TABLES;</code></li></ul></li><li>查看表的结构<ul><li><code>mysql&gt; DESCRIBE pet;</code></li></ul></li><li>创建数据库<ul><li><code>mysql&gt; CREATE DATABASE db_01;</code></li></ul></li><li>创建表<ul><li><code>mysql&gt; CREATE TABLE table_01 {c1 VARCHAR(10), c2 INT, ...};</code></li></ul></li><li>查看索引(如果存在)<ul><li><code>SHOW INDEX FROM table_01;</code></li></ul></li></ul><p><br><br><br></p><h2 id="在批处理下使用mysql"><a href="#在批处理下使用mysql" class="headerlink" title="在批处理下使用mysql"></a>在批处理下使用mysql</h2><p>Using mysql in Batch Mode</p><p><br></p><p>在前面，我们都是使用MySQL交互式(interactively)输入命令并查看结果。但还可在批处理模式下运行MySQL。<br>我们可以创建一个脚本文件，然后以这种方式执行脚本文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql &lt; batch-file</span><br><span class="line"></span><br><span class="line">msyql -h host -u user -p &lt; /path/batch-file</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#出现错误也继续运行</span></span><br><span class="line">msyql -h host -u user -p --force &lt; /path/batch-file</span><br></pre></td></tr></table></figure><p><br></p><p>为什么要使用脚本：</p><ul><li>如果需要反复(repeat)执行查询，将其写入脚本以避免每次执行时重新输入查询</li><li>通过复制和修改脚本文件从现有查询中生成新的查询</li><li>批处理模型在开发查询时也很有用，特别是对于多行语句。写错了直接修改脚本就好，而不必重新输入</li><li>如果查询产生大量输出，可通过传呼机而不是翻滚到屏幕的最上方<ul><li><code>mysql &lt; batch-file | more</code></li></ul></li><li>可以把输出捕获到一个文件中<ul><li><code>mysql &lt; batch-file &gt; mysql.out</code></li></ul></li><li>可将脚本文件分发给其他人</li><li>批处理模式下的MySQL输出更简洁<ul><li>可使用<code>mysql -t</code>获得交互式数据格式</li><li>使用<code>mysql -v</code>将执行语句回显</li></ul></li><li>在mysql命令行中载入脚本<ul><li><code>mysql&gt; source filename;</code></li><li>或’mysql&gt; . filename;</li></ul></li></ul><p><br><br><br></p><h2 id="常见查询"><a href="#常见查询" class="headerlink" title="常见查询"></a>常见查询</h2><p>Examples of Common Queries</p><p><br></p><ul><li>在命令行使用mysql并选择数据库</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql db_name -u user -p</span><br></pre></td></tr></table></figure><ul><li>创建和填充表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shop (</span><br><span class="line">    article <span class="built_in">INT</span>(<span class="number">4</span>) <span class="keyword">UNSIGNED</span> ZEROFILL <span class="keyword">DEFAULT</span> <span class="string">'0000'</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    dealer  <span class="built_in">CHAR</span>(<span class="number">20</span>)                 <span class="keyword">DEFAULT</span> <span class="string">''</span>     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    price   <span class="keyword">DOUBLE</span>(<span class="number">16</span>,<span class="number">2</span>)             <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(article, dealer));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shop <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="number">1</span>,<span class="string">'A'</span>,<span class="number">3.45</span>),(<span class="number">1</span>,<span class="string">'B'</span>,<span class="number">3.99</span>),(<span class="number">2</span>,<span class="string">'A'</span>,<span class="number">10.99</span>),(<span class="number">3</span>,<span class="string">'B'</span>,<span class="number">1.45</span>),</span><br><span class="line">    (<span class="number">3</span>,<span class="string">'C'</span>,<span class="number">1.69</span>),(<span class="number">3</span>,<span class="string">'D'</span>,<span class="number">1.25</span>),(<span class="number">4</span>,<span class="string">'D'</span>,<span class="number">19.95</span>);</span><br></pre></td></tr></table></figure><ul><li>查看表内容</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> shop;</span><br></pre></td></tr></table></figure><ul><li>列的最大值(maximum)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(article) <span class="keyword">AS</span> article <span class="keyword">FROM</span> shop;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> article, <span class="keyword">MAX</span>(price) <span class="keyword">AS</span> price</span><br><span class="line"><span class="keyword">FROM</span>   shop</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> article;</span><br></pre></td></tr></table></figure><ul><li>使用用户定义的变量(user-defined variables)</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @min_price:=MIN(price),@max_price:=MAX(price) FROM shop;</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM shop WHERE price=@min_price OR price=@max_price;</span><br></pre></td></tr></table></figure><ul><li>使用外键(Foreign Keys)</li></ul><p>在MySQL中，InnoDB表支持检查外键约束。<br>外键约束不仅仅需要连接两个表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">SMALLINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">CHAR</span>(<span class="number">60</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shirt (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">SMALLINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">style</span> ENUM(<span class="string">'t-shirt'</span>, <span class="string">'polo'</span>, <span class="string">'dress'</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    color ENUM(<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'orange'</span>, <span class="string">'white'</span>, <span class="string">'black'</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    owner <span class="built_in">SMALLINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">REFERENCES</span> person(<span class="keyword">id</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person <span class="keyword">VALUES</span> (<span class="literal">NULL</span>, <span class="string">'Antonio Paz'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">last</span> := <span class="keyword">LAST_INSERT_ID</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shirt <span class="keyword">VALUES</span></span><br><span class="line">(<span class="literal">NULL</span>, <span class="string">'polo'</span>, <span class="string">'blue'</span>, @<span class="keyword">last</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="string">'dress'</span>, <span class="string">'white'</span>, @<span class="keyword">last</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="string">'t-shirt'</span>, <span class="string">'blue'</span>, @<span class="keyword">last</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person <span class="keyword">VALUES</span> (<span class="literal">NULL</span>, <span class="string">'Lilliana Angelovska'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">last</span> := <span class="keyword">LAST_INSERT_ID</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shirt <span class="keyword">VALUES</span></span><br><span class="line">(<span class="literal">NULL</span>, <span class="string">'dress'</span>, <span class="string">'orange'</span>, @<span class="keyword">last</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="string">'polo'</span>, <span class="string">'red'</span>, @<span class="keyword">last</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="string">'dress'</span>, <span class="string">'blue'</span>, @<span class="keyword">last</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="string">'t-shirt'</span>, <span class="string">'white'</span>, @<span class="keyword">last</span>);</span><br></pre></td></tr></table></figure><ul><li>在两个键上查找(Searching on Two Keys)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> field1_index, field2_index <span class="keyword">FROM</span> test_table</span><br><span class="line"><span class="keyword">WHERE</span> field1_index = <span class="string">'1'</span> <span class="keyword">OR</span>  field2_index = <span class="string">'1'</span></span><br></pre></td></tr></table></figure><ul><li>使用自动增量</li></ul><p><code>AUTO_INCREMENT</code>属性能够为新行生成一个唯一的标识符。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> animals (</span><br><span class="line">     <span class="keyword">id</span> MEDIUMINT <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">     <span class="keyword">name</span> <span class="built_in">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> animals (<span class="keyword">name</span>) <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">'dog'</span>),(<span class="string">'cat'</span>),(<span class="string">'penguin'</span>),</span><br><span class="line">    (<span class="string">'lax'</span>),(<span class="string">'whale'</span>),(<span class="string">'ostrich'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#设置指定增量开始值</span><br><span class="line">mysql&gt; ALTER TABLE tbl AUTO_INCREMENT = 100;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="MySQL程序"><a href="#MySQL程序" class="headerlink" title="MySQL程序"></a>MySQL程序</h1><p><br></p><h2 id="MySQL程序概述"><a href="#MySQL程序概述" class="headerlink" title="MySQL程序概述"></a>MySQL程序概述</h2><p>Overview of MySQL Programs</p><p><br></p><p><strong>MySQL安装中有多个不同的程序：</strong></p><ul><li><strong>mysqld</strong><ul><li>SQL daemon, MySQL Server, <strong>mysqld</strong>是执行大部分工作的主要程序</li></ul></li><li><strong>mysqld_safe</strong><ul><li>服务器启动脚本</li><li>mysqld_safe尝试去启动mysqld</li></ul></li><li><strong>mysql.server</strong><ul><li>服务器启动脚本</li><li>此脚本用于System V系统，包含启动特定运行级别的系统服务脚本</li><li>它调用mysqld_safe来启动MySQL Server</li></ul></li><li><strong>mysql_multi</strong><ul><li>可启动和关闭安装在系统上的多个服务器的启动脚本</li></ul></li><li><strong>comp_err</strong><ul><li>在MySQL build/installation过程中使用</li><li>从错误源文件中编译错误消息文件</li></ul></li><li><strong>mysql_install_db</strong><ul><li>初始化MySQL(数据目录，授权表，并设置InnoDB系统表空间)</li><li>通常用于首次安装MySQL时</li></ul></li><li><strong>mysql_plugin</strong><ul><li>配置MySQL Server插件</li></ul></li><li><strong>mysql_secure_installation</strong><ul><li>能够提高MySQL安装的安全性</li></ul></li><li><strong>mysql_ssl_rsa_setup</strong><ul><li>如果这些文佳丢失，改程序会创建支持安全连接所需的SSL证书和密钥文件以及RSA密钥对文件</li></ul></li><li><strong>mysql_tzinfo_to_sql</strong><ul><li>从mysql数据库中加载时区表</li></ul></li><li><strong>mysql_upgrade</strong><ul><li>在MySQL升级操作后使用</li><li>它检查表的不兼容性并在必要时修复它们，并用更新版的MySQL的任何更改来更新授权表</li></ul></li><li><strong>mysql</strong><ul><li>交互式输入SQL语句的命令行工具</li><li>或执行一个批处理模式的文件</li></ul></li><li><strong>mysqladmin</strong><ul><li>执行管理操作的客户端</li><li>如创建或删除数据库，重新加载授权表，刷新表的磁盘…</li><li>也可用获取服务器版本、状态、进程信息</li></ul></li><li><strong>mysqlcheck</strong><ul><li>表格客户端</li><li>用于检查、修复、分析和优化表格</li></ul></li><li><strong>mysqldump</strong><ul><li>将MySQL数据库转储为SQL、文本或XML文件的客户端</li></ul></li><li><strong>mysqlimport</strong><ul><li>使用<code>LOAD DATA INFILE</code>将文本文件导入各自表格的客户端</li></ul></li><li><strong>mysqlpump</strong><ul><li>将MySQL数据库转转储为SQL文件的客户端</li></ul></li><li><strong>mysqlsh</strong><ul><li>用于MySQL Server的高级命令行客户端和代码编辑器</li><li>除了SQL外，MySQL Shell还为JS和Python提供了脚本功能</li></ul></li><li><strong>mysqlshow</strong><ul><li>显示有关数据库、表、列和索引的信息的客户端</li></ul></li><li><strong>mysqlslap</strong><ul><li>用于模拟MySQL Server的客户端负载并报告每个阶段的时间</li></ul></li></ul><p><br></p><p><strong>MySQL管理和实用程序：</strong></p><ul><li><strong>innochecksum</strong><ul><li>InnoDB脱机文件校验和程序</li></ul></li><li><strong>myisam_ftdump</strong><ul><li>在MyISAM表中显示有关全文索信息</li></ul></li><li><strong>myisamchk</strong><ul><li>描述，检查，优化和修复MyISAM表</li></ul></li><li><strong>myisamlog</strong><ul><li>处理MyISAM日志文件</li></ul></li><li><strong>myisampack</strong><ul><li>压缩MyISAM表以生成更小的只读表</li></ul></li><li><strong>mysql_config_editor</strong><ul><li>能够将认证凭证存储在名为安全的加密登录路径文件中</li></ul></li><li><strong>mysqlbinlog</strong><ul><li>从二进制日志中读取语句</li></ul></li><li><strong>mysqldumpslow</strong><ul><li>读取和总结慢查询日志内容</li></ul></li></ul><p><br></p><p><strong>MySQL程序开发实用程序：</strong></p><ul><li><strong>mysql_config</strong><ul><li>一个shell脚本，用于在编译MySQL程序是生产所需的选项值</li></ul></li><li><strong>my_print_defaults：</strong><ul><li>显示选项文件的选项组中存在哪些选项</li></ul></li><li><strong>resolve_stack_dump</strong><ul><li>将数值堆栈跟踪转储解析为符号</li></ul></li></ul><p><br></p><p><strong>杂项(Miscellaneous)工具：</strong></p><ul><li><strong>lz4_decompress</strong><ul><li>解压缩使用LZ4压缩格式的mysqldump输出</li></ul></li><li><strong>perror</strong><ul><li>显示系统或MySQL错误代码含义</li></ul></li><li><strong>replace</strong><ul><li>再输入文本中执行字符串替换</li></ul></li><li><strong>resolveip</strong><ul><li>将主机名解析为IP地址，反之亦然</li></ul></li><li><strong>zlib_decompress</strong><ul><li>解压缩使用ZLIB压缩格式的mysqldump输出</li></ul></li></ul><p><br></p><p>Oracle公司还提供了MySQL Workbench GUI工具，用于管理、创建、知悉和评估查询，以及从其它关系数据库管理系统迁移到MySQL系统。</p><p>MySQL Client和Server间的通信使用如下环境变量：</p><table><thead><tr><th>Environment Variable</th><th>Meaning</th></tr></thead><tbody><tr><td>MYSQL_UNIX_PORT</td><td>The default Unix socket file; used for connections to localhost</td></tr><tr><td>MYSQL_TCP_PORT</td><td>The default port number; used for TCP/IP connections</td></tr><tr><td>MYSQL_PWD</td><td>The default password, insecure</td></tr><tr><td>MYSQL_DEBUG</td><td>Debug trace options when debugging</td></tr><tr><td>TMPDIR</td><td>The directory where temporary tables and files are created</td></tr></tbody></table><p><br><br><br></p><h2 id="使用MySQL程序"><a href="#使用MySQL程序" class="headerlink" title="使用MySQL程序"></a>使用MySQL程序</h2><h3 id="调用MySQL程序"><a href="#调用MySQL程序" class="headerlink" title="调用MySQL程序"></a>调用MySQL程序</h3><p>从命令行调用一个MySQL程序，输入程序名称和选项及参数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mysql --user=root <span class="built_in">test</span></span><br><span class="line">$ mysqladmin extended-status variables</span><br><span class="line">$ mysqlshow --<span class="built_in">help</span></span><br><span class="line">$ mysqldump -u root personnel</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="连接到MySQL-Server"><a href="#连接到MySQL-Server" class="headerlink" title="连接到MySQL Server"></a>连接到MySQL Server</h3><p>介绍如何连接到MySQL Server。</p><p>MySQL程序环境变量的优先级最低，命令行选项最高。你可在配置文件中指定程序的默认值，同时你又可以使用命令行选项覆盖它。<br>MySQL选项按顺序处理，所以如果多次指定选型，则最后一个选项优先。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql --hostname xx --port xx --user xx --password <span class="variable">$&#123;dbname&#125;</span> --protocol=TCP</span><br><span class="line"></span><br><span class="line">mysql -h -P -u -p <span class="variable">$&#123;dbname&#125;</span></span><br></pre></td></tr></table></figure><p><code>--protocol</code>值：</p><ul><li>TCP(all)</li><li>SOCKET(Unix)</li><li>PIPE(windows)</li><li>MEMORY(windows)</li></ul><p><br></p><p>你可以在选项文件的<code>[client]</code>部分指定连接参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">host=xxx</span><br><span class="line">port=xxx</span><br><span class="line">user=xxx</span><br><span class="line">password=xxx</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u user -p --count=1k --sleep=10 ping</span><br><span class="line"></span><br><span class="line">mysql -u user -pxxx --execute=&quot;DESCRIBE db.table&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#执行多个语句</span><br><span class="line">mysql -u root -p -e &apos;SELECT VERSION(); SELECT NOW()&apos;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>大多数MySQL程序都可从选项文件中读取启动选项。</p><p>MySQL不保证配置文件的读取顺序。</p><p>Unix和Unix-Like平台的MySQL配置文件：</p><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td><code>/etc/my.cnf</code></td><td>全局选项</td></tr><tr><td><code>/etc/mysql/my.cnf</code></td><td>全局选项</td></tr><tr><td><code>$SYSCONFDIR/my.cnf</code></td><td>全局选项</td></tr><tr><td><code>$MYSQL_HOME/my.cnf</code></td><td>MySQL Server Only</td></tr><tr><td><code>~/.my.cnf</code></td><td>特定用户选项</td></tr><tr><td><code>~/.mylogin.cnf</code></td><td>特定用户登录选项，Client Only</td></tr><tr><td><code>default-extra-file</code></td><td>使用<code>--defaults-extra-file</code>指定的文件</td></tr></tbody></table><p><br></p><p>配置文件解释：</p><ul><li>空行被忽略</li><li><code>#</code>号表示注释</li><li>前后空格将自动从选项名称和值中删除</li><li><p><code>[group]</code><br>为其设置配置项的程序名或组名。在此之后，任何选项设置都会应用到指定组，知道给出结尾。选项组名称不区分大小写。</p></li><li><p>你可在选项值中使用转义序列<br><code>\b, \t, \n, \r, \\, \s</code></p></li><li><p><code>!include</code>来包含其它配置文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DATADIR</span><br><span class="line">mysqld --datadir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">port=3306</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">key_buffer_size=16M</span><br><span class="line">max_allowed_packet=8M</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">port=3306</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">no-auto-rehash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line">quick</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!include /home/mysql/myopt.cnf</span><br></pre></td></tr></table></figure><p><br></p><p><strong>影响配置文件的命令行选项</strong></p><ul><li><code>--print-defaults</code></li><li><code>--defaults-extra-file</code></li><li><code>--defaults-file</code></li><li><code>--defaults-group-suffix</code></li><li><code>--login-path</code></li><li><code>--no-defaults</code></li></ul><p><br></p><p><strong>使用选项指定环境变量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line">max_allowed_packet=16M</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">key_buffer_size=512M</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql --max_allowed_packet=16M</span><br><span class="line"></span><br><span class="line">shell&gt; mysql --max_allowed_packet=16*1024*1024</span><br><span class="line">mysql&gt; SET GLOBAL max_allowed_packet=16*1024*1024;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="MySQL-Server"><a href="#MySQL-Server" class="headerlink" title="MySQL Server"></a>MySQL Server</h2><ul><li><p><code>mysqld</code><br>The MySQL Server</p></li><li><p><code>mysql_safe</code><br>MySQL Server Startup Script</p></li><li><p><code>mysql.server</code><br>MySQL Server Startup Script</p></li><li><p><code>mysqld_multi</code><br>Manage Multiple MySQL Servers</p></li></ul><p><br></p><h3 id="mysqld"><a href="#mysqld" class="headerlink" title="mysqld"></a>mysqld</h3><p>mysqld，也被称为MySQL服务器，是执行MySQL大部分工作的主要程序。MySQL服务器管理对包含数据库和表的MySQL数据目录的访问。</p><p>查看帮助： <code>mysqld --verbose --help</code></p><p><br></p><h3 id="mysql-safe"><a href="#mysql-safe" class="headerlink" title="mysql_safe"></a>mysql_safe</h3><p><strong>对于某些Linux平台，从RPM或DBP包安装的MySQL包括了用于管理MySQL服务启动和管理的systemd支持。在这些平台上，<code>mysqld_safe</code>不会被安装，因为它不是必须的。</strong></p><p><code>mysql_safe</code>是Unix上启动mysqld服务器的推荐方式。它添加了一些安全特性，如发生错误是重启服务器并将运行时的错误记录到日志。</p><p><code>mysqld_safe</code>尝试启动一个名为mysqld的可执行程序。它会读取配置文件中<code>[mysqld], [server], [mysqld_safe]</code>部分的所有选项。</p><p><code>mysqld_safe</code>选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">--basedir</span><br><span class="line"></span><br><span class="line">--core-file-size</span><br><span class="line"></span><br><span class="line">--datadir</span><br><span class="line"></span><br><span class="line">--defaults-extra-file</span><br><span class="line"></span><br><span class="line">--defaults-file</span><br><span class="line"></span><br><span class="line">--ledir</span><br><span class="line"></span><br><span class="line">--log-error</span><br><span class="line"></span><br><span class="line">--mallocl-lib</span><br><span class="line"></span><br><span class="line">--mysqld</span><br><span class="line"></span><br><span class="line">--mysqld-safe-login-timestamps</span><br><span class="line"></span><br><span class="line">--mysql-version</span><br><span class="line"></span><br><span class="line">--nice</span><br><span class="line"></span><br><span class="line">--no-defaults</span><br><span class="line"></span><br><span class="line">--open-files-limit</span><br><span class="line"></span><br><span class="line">--pid-file</span><br><span class="line"></span><br><span class="line">--plugin-dir</span><br><span class="line"></span><br><span class="line">--plugin-dir</span><br><span class="line"></span><br><span class="line">--port</span><br><span class="line"></span><br><span class="line">--skip-kill-mysqld</span><br><span class="line"></span><br><span class="line">--skip-syslog</span><br><span class="line"></span><br><span class="line">--socket</span><br><span class="line"></span><br><span class="line">--syslog-tag</span><br><span class="line"></span><br><span class="line">--timezone</span><br><span class="line"></span><br><span class="line">--user</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="mysql-server"><a href="#mysql-server" class="headerlink" title="mysql.server"></a>mysql.server</h3><p><strong>对于某些Linux平台，从RPM和DPG包安装的MySQL包括了用于管理MySQL Server启动和关闭的systemd支持。在这些平台上，没有安装<code>mysql.server</code>和<code>mysqld_safe</code>，因为它们不是必须的。</strong></p><p>Unix和Unix-Like平台上的MySQL发行版包含一个名为<code>mysql.server</code>的脚本，该脚本使用<code>mysqld_safe</code>启动MySQL Server。</p><p><br><br><br></p><h3 id="mysqld-multi"><a href="#mysqld-multi" class="headerlink" title="mysqld_multi"></a>mysqld_multi</h3><p><strong>对于某些Linux平台，从RPM和DPG包安装的MySQL包括了用于管理MySQL Server启动和关闭的systemd支持。在这些平台上，没有安装<code>mysqld_multi</code>，因为它们不是必须的。</strong></p><p><code>mysqld_multi</code>设计用于管理多个监听不同Unix socket文件和TCP/IP port上连接的mysqld进程。</p><p><br><br><br></p><h2 id="MySQL安装相关程序"><a href="#MySQL安装相关程序" class="headerlink" title="MySQL安装相关程序"></a>MySQL安装相关程序</h2><p>这些程序用于安装或升级MySQL！</p><ul><li><p><code>com_err</code><br>Compile MySQL Error Message File</p></li><li><p><code>mysql_install_db</code><br>Initialize MySQL Data Directory</p></li><li><p><code>mysql_plugin</code><br>Configure MySQL Server Plugins</p></li><li><p><code>mysql_secure_installation</code><br>Improve MySQL Installation Security</p></li><li><p><code>mysql_ssl_rsa_setup</code><br>Create SSL/RSA Files</p></li><li><p><code>mysql_tzinfo_to_sql</code><br>Load the Time Zone Tables</p></li><li><p><code>mysql_upgrade</code><br>Check and Upgrade MySQL Tables</p></li></ul><p><br></p><h3 id="com-err"><a href="#com-err" class="headerlink" title="com_err"></a>com_err</h3><p><code>comp_err</code>创建errmsg.sys文件，<code>mysqld</code>使用此文件来确定为不同错误代码(error code)显示错误消息。通常，在构建MySQL时，<code>comp_err</code>会自动运行。它从位于MySQL源发行版<code>sq;/share/errmsg-utf8.txt</code>文本文件汇编<code>errmsg.sys</code>文件。</p><p><code>comp_err</code>同样会生成<code>mysqld_error.h, mysqld_ername.h, sql_state.h</code>头文件。</p><p><br><br><br></p><h3 id="mysql-install-db"><a href="#mysql-install-db" class="headerlink" title="mysql_install_db"></a>mysql_install_db</h3><p>在MySQL5.7中，由于<code>mysql_install_db</code>的功能已经被集成到mysqld中，因此不推荐使用它。<br>在MySQL5.7.5之前，<code>mysql_install_db</code>是一个Perl脚本并依赖于Perl。在此之后，它是由C++写的可执行二进制文件。还有一些选项的更迭。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initailize</span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">mysqld --initialize-insecure</span><br></pre></td></tr></table></figure><p><br></p><p><code>mysql_install_db</code>处理在MySQL Server(mysqld)准备好使用之前，必须执行的初始化任务：</p><ul><li>初始化MySQL数据目录，创建它包含的系统表</li><li>初始化管理InnoDB表所需的<code>system tablespace</code>和相关数据结构</li><li>加载服务器端help表</li><li>安装<code>sys schema</code></li><li>创建一个管理员账户<br>老版本的<code>mysql_install_db</code>可能会创建匿名账户。</li></ul><p><br></p><p>如果<code>mysql_install_db</code>生成了一个随机管理员密码，它将把此密码写入文件并显示此文件名。密码包含一个时间戳以指示它的写入时间。<br>默认情况下，该文件是用户主目录中的<code>.mysql_secret</code>文件。</p><p><br><br><br></p><h3 id="mysql-plugin"><a href="#mysql-plugin" class="headerlink" title="mysql_plugin"></a>mysql_plugin</h3><p>从MySQL5.7.11开始，不推荐使用<code>mysql_plugin</code>，并会在MySQL8.0中移除此功能。<br>使用如下命令替代：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--plugin-load</span><br><span class="line">--plugin-load-add</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">mysql&gt; INSTALL PLUGIN</span><br><span class="line">mysql&gt; UNINSTALL PLUGIN</span><br></pre></td></tr></table></figure><p><br></p><p><code>mysql_plugin</code>功能允许MySQL管理员管理由MySQL Server载入的插件。</p><p><br><br><br></p><h3 id="mysql-secure-installation"><a href="#mysql-secure-installation" class="headerlink" title="mysql_secure_installation"></a>mysql_secure_installation</h3><p><code>mysql_secure_installation</code>通过以下方式来提高MySQL安装的安全性：</p><ul><li>为root用户设置密码</li><li>删除可从本机外部访问的root账户</li><li>删除匿名账户</li><li>删除test数据库(默认情况下可由任何用户访问，包括匿名用户)</li><li>删除允许任何人访问以<code>test_</code>开头的数据库的权限</li></ul><p><br><br><br></p><h3 id="mysql-ssl-rsa-setup"><a href="#mysql-ssl-rsa-setup" class="headerlink" title="mysql_ssl_rsa_setup"></a>mysql_ssl_rsa_setup</h3><p><code>mysql_ssl_rsa_setup</code>创建SSL证书和key文件和RSA key-pair文件，用于支持使用SSL进行安全连接。它生成的整数是自签名的，不太安全。请考虑从注册机构申请CA证书。<br><code>mysql_ssl_rsa_setup</code>使用<code>opensll</code>命令，所以请安装OpenSSL。</p><p><br><br><br></p><h3 id="mysql-tzinfo-to-sql"><a href="#mysql-tzinfo-to-sql" class="headerlink" title="mysql_tzinfo_to_sql"></a>mysql_tzinfo_to_sql</h3><p><code>mysql_tzinfo_to_sql</code>加载MySQL数据库中的zone table。它使用系统上的<code>zoneinfo</code>信息。</p><p><br><br><br></p><h3 id="msyql-upgrade"><a href="#msyql-upgrade" class="headerlink" title="msyql_upgrade"></a>msyql_upgrade</h3><p><code>mysql_upgrade</code>检查数据库中的所有表与当前版本的MySQL Server的不兼容，它还升级系统表，以便你可以利用新权限和功能。<br>如果<code>mysql_upgrade</code>发现表有可能的不兼容性，它会执行检查表，如果发现问题，则会尝试修复表。</p><p>每次升级MySQL时都应该执行<code>mysql_upgrade</code>。<br>在执行upgrade之前，你应该始终备份你的MySQL。</p><p><br><br><br></p><h2 id="MySQL客户端程序"><a href="#MySQL客户端程序" class="headerlink" title="MySQL客户端程序"></a>MySQL客户端程序</h2><ul><li><p>mysql<br>The MySQL Command-Line Tool</p></li><li><p>mysqladmin<br>Client for Administering a MySQL Server</p></li><li><p>mysqlcheck<br>A Table Maintenance Program</p></li><li><p>mysqldump<br>A Database Backup Program</p></li><li><p>mysqlimport<br>A Data Import Program</p></li><li><p>mysqlpump<br>A Database Backup Program</p></li><li><p>mysqlsh<br>The MySQL Shell</p></li><li><p>mysqlshow<br>Display Database, Table, and Column Information</p></li><li><p>mysqlslap<br>Load Emulation Client</p></li></ul><p><br></p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>mysql是一个具有输入编辑功能的SQL shell。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="comment">--host= --port= --user= --password db_name</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#SQL文件</span><br><span class="line">#SQL语句以 ;或\g或\G结束</span><br><span class="line">mysql db_name &lt; script.sql &gt; output.tab</span><br></pre></td></tr></table></figure><p><br></p><h3 id="mysql选项"><a href="#mysql选项" class="headerlink" title="mysql选项"></a>mysql选项</h3><p>MySQL支持很多选项。这些选项可以写入配置文件的<code>[mysql]</code>和<code>[client]</code>组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --help</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="mysql命令"><a href="#mysql命令" class="headerlink" title="mysql命令"></a>mysql命令</h3><p>mysql将你发出的每个SQL语句发送到要执行的Server。如下为mysql自己解释的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; help;</span><br><span class="line"></span><br><span class="line">List of all MySQL commands:</span><br><span class="line">Note that all text commands must be first on line and end with &apos;;&apos;</span><br><span class="line">?         (\?) Synonym for `help&apos;.</span><br><span class="line">charset</span><br><span class="line">clear     (\c) Clear the current input statement.</span><br><span class="line">connect   (\r) Reconnect to the server. Optional arguments are db and host.</span><br><span class="line">delimiter (\d) Set statement delimiter.</span><br><span class="line">edit      (\e) Edit command with $EDITOR.</span><br><span class="line">ego       (\G) Send command to mysql server, display result vertically.</span><br><span class="line">exit      (\q) Exit mysql. Same as quit.</span><br><span class="line">go        (\g) Send command to mysql server.</span><br><span class="line">help      (\h) Display this help.</span><br><span class="line">nopager   (\n) Disable pager, print to stdout.</span><br><span class="line">notee     (\t) Don&apos;t write into outfile.</span><br><span class="line">pager     (\P) Set PAGER [to_pager]. Print the query results via PAGER.</span><br><span class="line">print     (\p) Print current command.</span><br><span class="line">prompt    (\R) Change your mysql prompt.</span><br><span class="line">quit      (\q) Quit mysql.</span><br><span class="line">rehash    (\#) Rebuild completion hash.</span><br><span class="line">source    (\.) Execute an SQL script file. Takes a file name as an argument.</span><br><span class="line">status    (\s) Get status information from the server.</span><br><span class="line">system    (\!) Execute a system shell command.</span><br><span class="line">tee       (\T) Set outfile [to_outfile]. Append everything into given outfile.</span><br><span class="line">use       (\u) Use another database. Takes database name as argument.</span><br><span class="line">charset   (\C) Switch to another charset. Might be needed for processing binlog with multi-byte charsets.</span><br><span class="line">warnings  (\W) Show warnings after every statement.</span><br><span class="line">nowarning (\w) Don&apos;t show warnings after every statement.</span><br><span class="line">resetconnection(\x) Clean session context.</span><br></pre></td></tr></table></figure><p><br></p><p><strong>修改MySQL提示符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#shell</span><br><span class="line">export MYSQL_PS1=&quot;(\u@\h) [\d]&gt; &quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#mysql</span><br><span class="line">mysql --prompt=&quot;(\u@\h) [\d]&gt; &quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#配置文件</span><br><span class="line">[mysql]</span><br><span class="line">prompt=(\\u@\\h) [\\d]&gt;\\_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#mysql prompt</span><br><span class="line">mysql&gt; prompt (\u@\h) [\d]&gt;\_</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="mysql服务端帮助"><a href="#mysql服务端帮助" class="headerlink" title="mysql服务端帮助"></a>mysql服务端帮助</h3><p>mysql Server-Side Help</p><p>如果给<code>help</code>命令提供一个参数，mysql将其用作搜索字符串，以从MySQL参考手册的内容访问服务端帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; help me</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; help contents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; help logs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; help rep%</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="从文本文件执行SQL语句"><a href="#从文本文件执行SQL语句" class="headerlink" title="从文本文件执行SQL语句"></a>从文本文件执行SQL语句</h3><p>mysql忽略文件开头的Unicode字节顺序标记(BOM)字符。BOM的存在不会导致MySQL更改其默认字符集(charset)。因此，请使用<code>--default-char-set</code>选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#shell</span><br><span class="line">mysql db_name &lt; test_file</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; source file_name</span><br><span class="line">mysql&gt; \. file_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#显示进度信息</span><br><span class="line">SELECT &apos;&lt;info_to_display&gt;&apos; AS &apos; &apos;;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="MySQL管理和实用程序"><a href="#MySQL管理和实用程序" class="headerlink" title="MySQL管理和实用程序"></a>MySQL管理和实用程序</h2><ul><li><p>inochecksum<br>Offline InnoDB File Checksum Utility</p></li><li><p>myisam_ftdump<br>Display Full-Text Index information</p></li><li><p>myisamchk<br>MyISAM Table-Maintenance Utility</p></li><li><p>myisamlog<br>Display MyISAM Log File Contents</p></li><li><p>myisampack<br>Generate Compressed, Read-Only MyISAM Tables</p></li><li><p>mysql_config_editor<br>MySQL Configuration Utility</p></li><li><p>mysqlbinlog<br>Utility for Processing Binary Log Files</p></li><li><p>mysqldumpslow<br>Summarize Slow Query Log Files</p></li></ul><p><br><br><br></p><h2 id="mysql开发实用程序"><a href="#mysql开发实用程序" class="headerlink" title="mysql开发实用程序"></a>mysql开发实用程序</h2><ul><li><p><code>mysql_config</code><br>Display Options for Compiling Clients</p></li><li><p><code>my_print_defaults</code><br>Display Options from Option Files</p></li><li><p><code>resolve_stack_dump</code><br>Resolve Numeric Stack Trace Dump to Symbols</p></li></ul><p><br><br><br></p><h2 id="杂项程序"><a href="#杂项程序" class="headerlink" title="杂项程序"></a>杂项程序</h2><p>Miscellaneous Programs</p><ul><li><p><code>lz4_decompress</code><br>Decompress mysqlpump LZ4-Compressed Output</p></li><li><p><code>perror</code><br>Explain Error Codes</p></li><li><p><code>replace</code><br>A String-Replacement Utility</p></li><li><p><code>resolveip</code><br>Resolve Host name to IP Address or Vice Versa</p></li><li><p><code>zlib_decompress</code><br>Decompress mysqlpump ZLIB-Compressed Output</p></li></ul><p><br><br><br></p><h2 id="MySQL环境变量"><a href="#MySQL环境变量" class="headerlink" title="MySQL环境变量"></a>MySQL环境变量</h2><p>这些环境变量直接或间接的被MySQL使用。</p><table><thead><tr><th>Variable</th><th>Description</th></tr></thead><tbody><tr><td>AUTHENTICATION_LDAP_CLIENT_LOG</td><td>Client-side LDAP authentication logging level.</td></tr><tr><td>AUTHENTICATION_PAM_LOG</td><td>PAM authentication plugin debug logging settings.</td></tr><tr><td>CC</td><td>The name of your C compiler (for running CMake).</td></tr><tr><td>CXX</td><td>The name of your C++ compiler (for running CMake).</td></tr><tr><td>CC</td><td>The name of your C compiler (for running CMake).</td></tr><tr><td>DBI_USER</td><td>The default user name for Perl DBI.</td></tr><tr><td>DBI_TRACE</td><td>Trace options for Perl DBI.</td></tr><tr><td>HOME</td><td>The default path for the mysql history file is $HOME/.mysql_history.</td></tr><tr><td>LD_RUN_PATH</td><td>Used to specify the location of libmysqlclient.so.</td></tr><tr><td>LIBMYSQL_ENABLE_CLEARTEXT_PLUGIN</td><td>Enable mysql_clear_password authentication plugin; see Section 6.5.1.6, “Client-Side Cleartext Pluggable Authentication”.</td></tr><tr><td>LIBMYSQL_PLUGIN_DIR</td><td>Directory in which to look for client plugins.</td></tr><tr><td>LIBMYSQL_PLUGINS</td><td>Client plugins to preload.</td></tr><tr><td>MYSQL_DEBUG</td><td>Debug trace options when debugging.</td></tr><tr><td>MYSQL_GROUP_SUFFIX</td><td>Option group suffix value (like specifying –defaults-group-suffix).</td></tr><tr><td>MYSQL_HISTFILE</td><td>The path to the mysql history file. If this variable is set, its value overrides the default for $HOME/.mysql_history.</td></tr><tr><td>MYSQL_HISTIGNORE</td><td>Patterns specifying statements that mysql should not log to $HOME/.mysql_history, or syslog if –syslog is given.</td></tr><tr><td>MYSQL_HOME</td><td>The path to the directory in which the server-specific my.cnf file resides.</td></tr><tr><td>MYSQL_HOST</td><td>The default host name used by the mysql command-line client.</td></tr><tr><td>MYSQL_OPENSSL_UDF_DH_BITS_THRESHOLD</td><td>Maximum key length for CREATE_DH_PARAMETERS(). See Section 12.18.2, “Enterprise Encryption Usage and Examples”.</td></tr><tr><td>MYSQL_OPENSSL_UDF_DSA_BITS_THRESHOLD</td><td>Maximum DSA key length for CREATE_ASYMMETRIC_PRIV_KEY(). See Section 12.18.2, “Enterprise Encryption Usage and Examples”.</td></tr><tr><td>MYSQL_OPENSSL_UDF_RSA_BITS_THRESHOLD</td><td>Maximum RSA key length for CREATE_ASYMMETRIC_PRIV_KEY(). See Section 12.18.2, “Enterprise Encryption Usage and Examples”.</td></tr><tr><td>MYSQL_PS1</td><td>The command prompt to use in the mysql command-line client.</td></tr><tr><td>MYSQL_PWD</td><td>The default password when connecting to mysqld. Using this is insecure. See Section 6.1.2.1, “End-User Guidelines for Password Security”.</td></tr><tr><td>MYSQL_TCP_PORT</td><td>The default TCP/IP port number.</td></tr><tr><td>MYSQL_TEST_LOGIN_FILE</td><td>The name of the .mylogin.cnf login path file.</td></tr><tr><td>MYSQL_TEST_TRACE_CRASH</td><td>Whether the test protocol trace plugin crashes clients. See note following table.</td></tr><tr><td>MYSQL_TEST_TRACE_DEBUG</td><td>Whether the test protocol trace plugin produces output. See note following table.</td></tr><tr><td>MYSQL_UNIX_PORT</td><td>The default Unix socket file name; used for connections to localhost.</td></tr><tr><td>MYSQLX_TCP_PORT</td><td>The X Plugin default TCP/IP port number.</td></tr><tr><td>MYSQLX_UNIX_PORT</td><td>The X Plugin default Unix socket file name; used for connections to localhost.</td></tr><tr><td>PATH</td><td>Used by the shell to find MySQL programs.</td></tr><tr><td>PKG_CONFIG_PATH</td><td>Location of mysqlclient.pc pkg-config file. See note following table.</td></tr><tr><td>TMPDIR</td><td>The directory in which temporary files are created.</td></tr><tr><td>TZ</td><td>This should be set to your local time zone. See Section B.5.3.7, “Time Zone Problems”.</td></tr><tr><td>UMASK</td><td>The user-file creation mode when creating files. See note following table.</td></tr><tr><td>UMASK_DIR</td><td>The user-directory creation mode when creating directories. See note following table.</td></tr><tr><td>USER</td><td>The default user name on Windows when connecting to mysqld.</td></tr></tbody></table><p><br><br><br></p><hr><p><br></p><h1 id="MySQL-Server管理"><a href="#MySQL-Server管理" class="headerlink" title="MySQL Server管理"></a>MySQL Server管理</h1><h2 id="MySQL-Server-1"><a href="#MySQL-Server-1" class="headerlink" title="MySQL Server"></a>MySQL Server</h2><p>mysqld is the MySQL Server.<br>并非所有的MySQL Server二进制文件和配置都支持所有的存储引擎。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#查看帮助</span><br><span class="line">mysqld --verbose --help</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#运行Server的环境变量</span><br><span class="line">mysql&gt; SHOW VARIABLES;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#运行Server的状态</span><br><span class="line">mysql&gt; SHOW STATUS;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="MySQL数据目录"><a href="#MySQL数据目录" class="headerlink" title="MySQL数据目录"></a>MySQL数据目录</h2><p>由MySQL管理的信息存储在称为数据目录的目录下。</p><ul><li>数据目录子目录：每个子目录都是数据库目录对应于Server管理的数据库<ul><li>mysql</li><li>performance_schema</li><li>sys</li><li>数据库</li></ul></li><li>日志文件由Server写入</li><li>innoDB表空间和日志文件</li><li>自动生成的SSL/RSA证书和密钥文件</li><li>Server PID</li></ul><p><br><br><br></p><h2 id="mysql数据库"><a href="#mysql数据库" class="headerlink" title="mysql数据库"></a>mysql数据库</h2><p>The mysql System Database</p><p>The mysql database is the system database.它的表中存储了MySQL Server运行时需要的信息。</p><p><br></p><p><strong>授权系统表</strong><br>如下这些系统表包含了用户账户和权限的授权信息。</p><ul><li><p>user<br>User accounts, global privileges, and other non-privilege columns.</p></li><li><p>db<br>Database-level privileges.</p></li><li><p>tables_priv<br>Table-level privileges.</p></li><li><p>columns_priv<br>Column-level privileges.</p></li><li><p>procs_priv<br>Stored procedure and function privileges.</p></li><li><p>proxies_priv<br>Proxy-user privileges.</p></li></ul><p><br></p><p><strong>对象信息系统表</strong><br>如下这些系统表包含了存储程序，用户定义函数和服务器端插件的信息。</p><ul><li><p>event<br>关于Event Scheduler事件的信息</p></li><li><p>func<br>用户定义函数的信息</p></li><li><p>plugin<br>服务器端的插件的信息</p></li><li><p>proc<br>有关存储过程和函数的信息</p></li></ul><p><br></p><p><strong>日志系统表</strong><br>Server使用如下系统表记录日志。日志表使用CSV存储引擎。</p><ul><li><p>general_log<br>一般查询日志表</p></li><li><p>slow_log<br>慢查询日志表</p></li></ul><p><br></p><p><strong>服务器端帮助系统表</strong><br>如下系统表包含了服务器端帮助信息。</p><ul><li><p>help_category<br>Information about help categories.</p></li><li><p>help_keyword<br>Keywords associated with help topics.</p></li><li><p>help_relation<br>Mappings between help keywords and topics.</p></li><li><p>help_topic<br>Help topic contents.</p></li></ul><p><br></p><p><strong>时区系统表</strong><br>如下系统表包含了时区信息。</p><ul><li><p>time_zone<br>Time zone IDs and whether they use leap seconds.</p></li><li><p>time_zone_leap_second<br>When leap seconds occur.</p></li><li><p>time_zone_name<br>Mappings between time zone IDs and names.</p></li><li><p>time_zone_transition, time_zone_tansition_type<br>Time zone descriptions.</p></li></ul><p><br></p><p><strong>副本系统表</strong><br>Server使用如下这些系统表来提供副本服务。这些表使用InnoDB存储引擎。</p><ul><li><p>gtid_executed<br>Table for storing GTID values.</p></li><li><p>ndb_binlog_index<br>Binary log information for NDB Cluster replication.</p></li><li><p>slave_master_info, slave_relay_log_info, slave_worker_info<br>Used to store replication information on slave servers.</p></li></ul><p><br></p><p><strong>优化器系统表</strong><br>如下系统表用于优化。</p><ul><li><p>innodb_index_stats, innodb_table_stats<br>Used for InnoDB persistent optimizer statistics</p></li><li><p>server_cost, engine_cost<br>The optimizer cost model uses tables that contain cost estimate information about operations that occur during query execution.</p></li></ul><p><br></p><p><strong>杂项系统表</strong></p><ul><li>audit_log_filter, audit_log_user</li><li>firewall_users, firewall_whitelist</li><li>servers</li></ul><p><br><br><br></p><h2 id="MySQL-Server-Logs"><a href="#MySQL-Server-Logs" class="headerlink" title="MySQL Server Logs"></a>MySQL Server Logs</h2><p>MySQL Server提供如下几种日志：</p><ul><li><p>Error log<br>启动、运行或停止mysqld遇到的问题</p></li><li><p>General query log<br>建立Client连接和从Client收到的语句</p></li><li><p>Binary log<br>更改数据的语句</p></li><li><p>Relay log<br>从replication master server收到的数据更改</p></li><li><p>Slow query log<br>执行时间超过<code>long_query_time</code>秒的查询</p></li><li><p>DDL(Metadata) log<br>由DDL语句执行的元数据操作</p></li></ul><p><br></p><p>默认情况下，不启用任何日志。</p><p>如果启用了这些日志，MySQL Server可以灵活地控制一般查询日志和慢查询日志的输出目的地——它可为日志文件或<code>mysql</code>数据库中的<code>general_log</code>和<code>slow_log</code>表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#--log-output</span><br><span class="line">#它的值可为TABLE/FILE/NONE</span><br><span class="line">#--general-log, --slow-query-log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#TABLE和FILE</span><br><span class="line">mysqld --log-output=TABLE,FILE --general-log=msyql.general_log --slow-query-log=mysql.slow_log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">[mysqld]</span><br><span class="line">log_output=</span><br><span class="line">general_log=</span><br><span class="line">slow_query_log=</span><br></pre></td></tr></table></figure><p>查看两个日志表的标准格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE mysql.general_log;</span><br><span class="line">SHOW CREATE TABLE mysql.slow_log;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>The Error Log</p><p>错误日志包含mysqld启动和关闭时间的记录。它还包含诊断信息。</p><p><br></p><p><strong>Unix/Unix-Like OS</strong><br>使用<code>mysqld --log-error</code>选项来将错误日志写入控制台(stderr)或文件。</p><p>如果未指定文件名，则默认为数据目录下的<code>host_name.err</code>文件。<br>YUM或APT包安装，则配置的错误日志文件为<code>--log-error=/var/log/mysqld.log</code>。</p><p><br></p><p><strong>将错误日志记录到系统日志</strong><br>Error Logging to the System Log</p><p>使用如下系统变量：</p><ul><li><p><code>log_syslog</code><br>启用此变量将错误日志发送到系统日志</p></li><li><p><code>log_syslog_facility</code><br>syslog消息的默认设置时daemon。设置此变量以指定其它工具。</p></li><li><p><code>log_syslog_include_pid</code><br>是否在syslog输出中包含Server的PID。</p></li><li><p><code>log_syslog_tag</code><br>在syslog消息中添加一个tag。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msyqld --log_syslog=</span><br></pre></td></tr></table></figure><p><br></p><p><strong>错误日志过滤</strong><br>Error Log Filtering</p><p><code>log_error_verbosity</code>变量控制错误日志的详细程度。值如下：</p><ul><li><p>1<br>error only</p></li><li><p>2<br>errors, warning</p></li><li><p>3(默认)<br>errors, warnings, notes</p></li></ul><p><br></p><p><strong>错误日志消息格式</strong><br>Error Log Message Format</p><p>错误日志中包含的ID是mysqld中负责编写消息的线程的ID。这表示Server的哪部分生成了消息。<br><code>log_timestamps</code>变量控制写入错误日志的时区和时间格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --log-timestamps=</span><br></pre></td></tr></table></figure><p><br></p><p><strong>错误日志文件刷新</strong><br>Error Log File Flushing and Renaming</p><p>如果你使用<code>FLUSH_ERROR_LOGS</code>, <code>FLUSH_LOGS</code>或<code>mysqladmin flush-logs</code>刷新日志，Server将关闭并重新打开它正在写的任何错误日志文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv host_name.err host_name.err-old</span><br><span class="line">mysqladmin flush-logs</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="一般查询日志"><a href="#一般查询日志" class="headerlink" title="一般查询日志"></a>一般查询日志</h3><p>The General Query Log</p><p>一般查询日志是mysqld执行操作的记录。当Client连接或断开时，Server将此信息写入日志，并记录从Client收到的每个SQL语句。<br>mysqld按照接收的顺序而不是执行顺序将语句写入日志。</p><p>默认情况下，一般查询日志是禁用的。<br>指定初始化查询日志状态<code>--general_log={0|1}</code>。<code>1</code>启用，<code>0</code>禁用。<br>指定日志文件名<code>--general-log-file=file-name</code>.如果未指定，默认为数据目录下<code>host_name.log</code>，除非指定了其它路径。<br>指定日志文件位置<code>--log-output=</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysqld --log-output=&apos;/var/log/mysql&apos; --general-log=1 --general-log-file=&apos;general.log&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shell&gt; mv host_name.log host_name-old.log</span><br><span class="line">shell&gt; mysqladmin flush-logs</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>The Binary Log</p><p><br><br><br></p><hr><p><br></p><h1 id="安全-1"><a href="#安全-1" class="headerlink" title="安全"></a>安全</h1><p><br><br><br></p><hr><p><br></p><h1 id="备份和恢复"><a href="#备份和恢复" class="headerlink" title="备份和恢复"></a>备份和恢复</h1><p>Backup and Recovery</p><p><br><br><br></p><hr><p><br></p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>Optimization</p><p><br><br><br></p><hr><p><br></p><h1 id="语言结构"><a href="#语言结构" class="headerlink" title="语言结构"></a>语言结构</h1><p>Language Structure</p><p><br><br><br></p><hr><p><br></p><h1 id="字符集和编码"><a href="#字符集和编码" class="headerlink" title="字符集和编码"></a>字符集和编码</h1><p>Character Sets, Collations, Unicode</p><p><br><br><br></p><hr><p><br></p><h1 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h1><p>Data Type</p><p>MySQL支持多种类型的SQL数据类型：</p><ul><li>numeric</li><li>date/time</li><li>string<ul><li>character</li><li>byre</li></ul></li><li>JSON</li></ul><p><br></p><p>数据类型描述使用如下约定：</p><ul><li><code>M</code>表示整数类型的最大显示宽度</li><li><code>D</code>适用于浮点和定点类型，并指示小数点后面的位数</li><li><code>fsp</code>适用于TIME, DATATIME, TIMESTAMP类型，表示小数点的秒精度</li><li>方括号<code>[]</code>表示类型定义的可选部分</li></ul><p><br><br><br></p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>Numberic type</p><p>如果为数字列指定<code>ZEROFILL</code>，MySQL会自动将<code>UNSIGNED</code>属性添加到列中。</p><p>数字数据类型允许<code>UNSIGNED</code>(无符号)属性，也允许<code>SIGNED</code>(符号)。默认情况下，这些数据类型是<code>SIGNED</code>，因此<code>SINGED</code>属性不起作用。</p><p><br></p><ul><li><p>BIT<br>A bit-value type.(1-64)</p></li><li><p>TINYINT<br>A very small integer.<br>有符号范围: <code>-128 to 127</code>, 无符号范围: <code>0-255</code></p></li><li><p>BOOL</p></li><li><p>SMALLINT<br>A small integer.<br>有符号范围: <code>-32768 to 32767</code>, 无符号范围: <code>0-65535</code></p></li><li><p>MEDIUMINT<br>A medium-sized integer.<br>有符号范围: <code>-8388608 to 8388607</code>, 无符号范围: <code>0-16777215</code></p></li><li><p>INT<br>A normal-size integer.<br>有符号范围: <code>-2147483648 to 2147483647</code>, 无符号范围: <code>0- 4294967295</code></p></li><li><p>INTERGER<br>此类型是INT的同义词。</p></li><li><p>BIGINT<br>A large integer.<br>符号范围: <code>-9223372036854775808 to 9223372036854775807</code>, 无符号范围: <code>0 to 18446744073709551615</code><br><code>SERIAL</code>是<code>BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE</code>的别名。</p></li><li><p>DECIMAL/DEC</p></li><li><p>FLOAT<br>A small(单精度) floating-point number.<br>允许的值为: -3.402823466E+38 to -1.175494351E-38, 0, and 1.175494351E-38 to 3.402823466E+38</p></li><li><p>DOUBLE<br>A normal-size(双精度) floating-point number.<br>允许值为: -1.7976931348623157E+308 to -2.2250738585072014E-308, 0, and 2.2250738585072014E-308 to 1.7976931348623157E+308</p></li><li><p>FLOAT<br>A floating-point number.</p></li></ul><p><br><br><br></p><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><p>Date and Time Type</p><p>MySQL允许的TIME, DATETIME, TIMESTAMP值的小数，精度高达微秒(小数点后6位)。</p><ul><li><p>DATE<br>A date.<br>支持范围: <code>1000-01-01</code>到<code>9999-12-31</code>。<br>MySQL以<code>YYYY-MM-DD</code>格式显示DATE值，但允许使用字符串或数字将值分配给DATE列。</p></li><li><p>DATETIME<br>A date and time combination.<br>支持范围: <code>1001-01-01 00:00:00.000000</code>到<code>9999-12-31 23:59:59.999999</code>。<br>MySQL以<code>YYYY-MM-DD HH:MM:SS.[fraction]</code>的格式显示DATETIME值，同样允许字符串或数字将值分配给DATETIME列。</p></li><li><p>TIMESTAMP<br>A timestamp.<br>支持范围: <code>1970-01-01 00:00:01.000000</code>UTC到<code>2038-01-19 03:14:07.999999</code>UTC<br>TIMESTAMP值存储为自纪元<code>1970-01-01 00:00:01.000000 UTC</code>以来的秒数，这也叫原子时间。</p></li><li><p>TIME<br>A time.<br>支持范围: <code>-838:59:59.000000</code> to <code>838:59:59.000000</code><br>MySQL以<code>HH:MM:SS[.fraction]</code>的格式显示TIME值，但允许使用字符串或数字将值分配给TIME列。</p></li><li><p>YEAR<br>A year in four-digit format.<br>MySQL以<code>YYYY</code>格式显示YEAR值，但允许使用字符串或数字将值分配给YEAR列。</p></li></ul><p><br><br><br></p><hr><p><br></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>String Type</p><p>在某些情况下，MySQL可能会使用<code>CREATE TABLE</code>或<code>ALTER TABLE</code>语句更改字符串的类型。</p><p><strong>CHARACTER SET/CHARSET</strong><br>指定字符集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t</span><br><span class="line">(</span><br><span class="line">    c1 <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8,</span><br><span class="line">    c2 <span class="built_in">TEXT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> latin1 <span class="keyword">COLLATE</span> latin1_general_cs</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><br></p><ul><li><p>CHAR<br>一个固定长度的字符串，在存储时使用用空格填充指定长度。<br>VARCHAR的有效最大长度取决于最大行大小(65535字节)和使用的字符集。</p></li><li><p>VARCHAR<br>一个可变长度的字符串。</p></li><li><p>BINARY<br>BINARY类似于CHAR，但存储二进制字节字符串而不是非二进制字符串。</p></li><li><p>VARBINARY</p></li><li><p>TINYBLOB<br>A BLOB column with a maximum length of 255 (2^8 − 1) bytes.</p></li><li><p>TINYTEXT<br>A TEXT column with a maximum length of 255 (2^8 − 1) characters.</p></li><li><p>BLOB<br>A BLOB column with a maximum length of 65,535 (2^16 − 1) bytes.</p></li><li><p>TEXT<br>A TEXT column with a maximum length of 65,535 (2^16 − 1) characters.</p></li><li><p>MEDIUMBLOB<br>A BLOB column with a maximum length of 16,777,215 (2^24 − 1) bytes.</p></li><li><p>MEDIUMTEXT<br>A TEXT column with a maximum length of 16,777,215 (2^24 − 1) characters.</p></li><li><p>LONGBLOB<br>A BLOB column with a maximum length of 4,294,967,295 or 4GB (2^32 − 1) bytes.</p></li><li><p>LONGTEXT<br>A TEXT column with a maximum length of 4,294,967,295 or 4GB (2^32 − 1) characters.</p></li><li><p>ENUM<br>An enumeration.</p></li><li><p>SET<br>A set.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL5.7参考文档： &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7.x86_64&lt;/li&gt;
&lt;li&gt;MySQL5.7&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="https://zhang21.github.io/categories/Database/"/>
    
    
      <category term="MySQL" scheme="https://zhang21.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>2018小计划</title>
    <link href="https://zhang21.github.io/2018/01/15/2018%E5%B0%8F%E8%AE%A1%E5%88%92/"/>
    <id>https://zhang21.github.io/2018/01/15/2018小计划/</id>
    <published>2018-01-15T03:08:11.000Z</published>
    <updated>2018-07-06T02:02:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><ul><li style="list-style: none"><input type="checkbox" checked> 《MongoDB官方文档》： <a href="https://docs.mongodb.com" target="_blank" rel="noopener">https://docs.mongodb.com</a></li><li style="list-style: none"><input type="checkbox"> 《SatlStack官方文档》： <a href="https://docs.saltstack.com" target="_blank" rel="noopener">https://docs.saltstack.com</a></li><li style="list-style: none"><input type="checkbox"> 《MySQL官方文档》： <a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">https://dev.mysql.com/doc/</a></li><li style="list-style: none"><input type="checkbox"> 《TCP/IP协议族》： <a href="https://book.douban.com/subject/5386194/" target="_blank" rel="noopener">https://book.douban.com/subject/5386194/</a></li><li style="list-style: none"><input type="checkbox"> 《Linux性能调优指南》： <a href="https://lihz1990.gitbooks.io/transoflptg/content/" target="_blank" rel="noopener">https://lihz1990.gitbooks.io/transoflptg/content/</a></li><li style="list-style: none"><input type="checkbox" checked> 《Docker官方文档》： <a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></li><li style="list-style: none"><input type="checkbox"> 《Consul官方文档》： <a href="https://www.consul.io/docs/index.html" target="_blank" rel="noopener">https://www.consul.io/docs/index.html</a></li><li style="list-style: none"><input type="checkbox"> 《Python工作自动化》： <a href="https://book.douban.com/subject/26836700/" target="_blank" rel="noopener">https://book.douban.com/subject/26836700/</a></li><li style="list-style: none"><input type="checkbox" checked> 《Elastic Stack》: <a href="https://www.elastic.co/guide/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/index.html</a></li><li style="list-style: none"><input type="checkbox"> 《Kubernetes官方文档》: <a href="https://kubernetes.io/cn/docs/" target="_blank" rel="noopener">https://kubernetes.io/cn/docs/</a></li><li style="list-style: none"><input type="checkbox"> 《Python3文档/标准库》: <a href="https://docs.python.org/" target="_blank" rel="noopener">https://docs.python.org/</a></li></ul><a id="more"></a><p><br><br><br></p><hr><p><br></p><h1 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h1><ul><li style="list-style: none"><input type="checkbox"> 《资本论》： <a href="https://book.douban.com/subject/1150503/" target="_blank" rel="noopener">https://book.douban.com/subject/1150503/</a></li><li style="list-style: none"><input type="checkbox"> 《灵飞经小楷》： <a href="https://book.douban.com/subject/1115916/" target="_blank" rel="noopener">https://book.douban.com/subject/1115916/</a></li><li style="list-style: none"><input type="checkbox"> 《经济学原理》： <a href="https://book.douban.com/subject/26435630/" target="_blank" rel="noopener">https://book.douban.com/subject/26435630/</a></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><ul><li style="list-style: none"><input type="checkbox"> 沉得住气</li><li style="list-style: none"><input type="checkbox"> 培养一门兴趣爱好</li><li style="list-style: none"><input type="checkbox"> 找寻另一半</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h1&gt;&lt;ul&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot; checked&gt; 《MongoDB官方文档》： &lt;a href=&quot;https://docs.mongodb.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.mongodb.com&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《SatlStack官方文档》： &lt;a href=&quot;https://docs.saltstack.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.saltstack.com&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《MySQL官方文档》： &lt;a href=&quot;https://dev.mysql.com/doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《TCP/IP协议族》： &lt;a href=&quot;https://book.douban.com/subject/5386194/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://book.douban.com/subject/5386194/&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《Linux性能调优指南》： &lt;a href=&quot;https://lihz1990.gitbooks.io/transoflptg/content/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://lihz1990.gitbooks.io/transoflptg/content/&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot; checked&gt; 《Docker官方文档》： &lt;a href=&quot;https://docs.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《Consul官方文档》： &lt;a href=&quot;https://www.consul.io/docs/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.consul.io/docs/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《Python工作自动化》： &lt;a href=&quot;https://book.douban.com/subject/26836700/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://book.douban.com/subject/26836700/&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot; checked&gt; 《Elastic Stack》: &lt;a href=&quot;https://www.elastic.co/guide/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.elastic.co/guide/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《Kubernetes官方文档》: &lt;a href=&quot;https://kubernetes.io/cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://kubernetes.io/cn/docs/&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《Python3文档/标准库》: &lt;a href=&quot;https://docs.python.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.python.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Zhang" scheme="https://zhang21.github.io/categories/Zhang/"/>
    
    
      <category term="2018" scheme="https://zhang21.github.io/tags/2018/"/>
    
  </entry>
  
  <entry>
    <title>海明威的《老人与海》</title>
    <link href="https://zhang21.github.io/2018/01/13/%E6%B5%B7%E6%98%8E%E5%A8%81%E7%9A%84%E3%80%8A%E8%80%81%E4%BA%BA%E4%B8%8E%E6%B5%B7%E3%80%8B/"/>
    <id>https://zhang21.github.io/2018/01/13/海明威的《老人与海》/</id>
    <published>2018-01-13T01:49:53.000Z</published>
    <updated>2018-01-15T02:06:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>我不相信人会有所谓的“命运”，但是我相信对于任何人来说，“限度”总是存在的。再聪明再强悍的人，能够做到的事情也总是有限度的。老人桑地亚哥不是无能之辈，然而，尽管他是最好的渔夫，也不能让那些鱼来上他的钩。他遇到他的限度了，就象最好的农民遇上了大旱，最好的猎手久久碰不到猎物一般。每一个人都会遇到这样的限度，仿佛是命运在向你发出停止前行的命令。</p><a id="more"></a><p><br></p><p>可是老人没有沮丧，没有倦怠，他继续出海，向限度挑战。他终于钓到了一条鱼。如同那老人是人中的英雄一样，这条鱼也是鱼中的英雄。鱼把他拖到海上去，把他拖到远离陆地的地方，在海上与老人决战。在这场鱼与人的恶战中，鱼也有获胜的机会。鱼在水下坚持了几天几夜，使老人不能休息，穷于应付，它用酷刑来折磨老人，把他弄得血肉模糊。这时，只要老人割断钓绳，就能使自己摆脱困境，得到解放，但这也就意味着宣告自己是失败者。老人没有作这样得选择，甚至没有产生过放弃战斗的念头。他把那条鲨鱼当作一个可与之交战的敌手，一次又一次地做着限度之外的战斗，他战胜了。</p><p><br></p><p>老人载着他的鱼回家去，鲨鱼在路上抢劫他的猎物。他杀死了一条来袭的鲨鱼，但是折断了他的鱼叉。于是他用刀子绑在棍子上做武器。到刀子又折断的时候，似乎这场战斗已经结束了。他失去了继续战斗的武器，他又遇到了他的限度。这是，他又进行了限度之外的战斗：当夜幕降临，更多的鲨鱼包围了他的小船，他用木棍、用桨、甚至用舵和鲨鱼搏斗，直到他要保卫的东西失去了保卫的价值，直到这场搏斗已经变得毫无意义的时候他才住手。</p><p><br></p><p>老人回到岸边，只带回了一条白骨，只带回了残破不堪的小船和耗尽了精力的躯体。人们怎样看待这场斗争呢？</p><p>有人说老人桑地亚哥是一个失败了得英雄。尽管他是条硬汉，但还是失败了。</p><p>什么叫失败？也许可以说，人去做一件事情，没有达到预期得目的，这就是失败。</p><p><br></p><p>但是，那些与命运斗争的人，那些做接近自己限度的斗争的人，却天生地接近这种失败。老人到海上去，不能期望天天有鱼来咬他的钩，于是他常常失败。一个常常在进行着接近自己限度的斗争的人总是会常常失败的，一个想探索自然奥秘的人也常常会失败，一个想改革社会的人更是会常常失败。只有那些安于自己限度之内的生活的人才总是“胜利”，这种“胜利者”之所以常胜不败，只是因为他的对手是早已降伏的，或者说，他根本没有投入斗争。</p><p><br></p><p>在人生的道路上，“失败“这个词还有另外的含义，即是指人失去了继续斗争的信心，放下了手中的武器。人类向限度屈服，这才是真正的失败。而没有放下手中武器，还在继续斗争，继续向限度挑战的人并没有失败。如此看来，老人没有失败，老人从未放下武器，只不过是丧失了武器。老人没有失去信心，因此不应当说他是“失败了的英雄”。</p><p><br></p><p>那么，什么也没有得到的老人竟是胜利的么？我确是这样看的。我认为，胜利就是战斗到最后的时刻。老人总怀着无比的勇气走向莫测的大海，他的信心是不可战胜的。</p><p>他和其他许多人一样，是强悍的人类的一员。我喜欢这样的人，也喜欢这样的人性。我发现，人们常常把这样的事情当作人性最可贵的表露：七尺男子汉坐在厨房里和三姑六婆磨嘴皮子，或者衣装笔挺的男女们坐在海滨，谈论着高尚的、别人不能理解的感情。我不喜欢人们像这样沉溺在人性软弱的部分之中，更不喜欢人们总是这样描写人性。</p><p><br></p><p>正像老人每天走向大海一样，很多人每天也走向与他们的限度斗争的战场，仿佛他们要与命运一比高低似的。他们是人中的强者。</p><p>人类本身也有自己的限度，但是当人们一再把手伸到限度之外，这个限度就一天一天地扩大了。人类在与限度的斗争中成长。他们把飞船送上太空，他们也用简陋的渔具在加勒比海捕捉巨大的马林鱼。这些事情是同样伟大的。做这样不可思议的事情的人都是英雄。而那些永远不肯或不能越出自己限度的人是平庸的人。</p><p><br></p><p>在人类前进的道路上，强者与弱者的命运是不同的。弱者不羡慕强者的命运，强者也讨厌弱者的命运。强者带有人性中强悍的一面，弱者带有人性中软弱的一面。强者为弱者开辟道路，但是强者往往为弱者所奴役，就像老人是为大腹便便的游客打鱼一样。</p><p><br></p><p>《老人与海》讲了一个老渔夫的故事，但是在这个故事里却揭示了人类共同的命运。我佩服老人的勇气，佩服他不屈不饶的斗争精神，也佩服海明威。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我不相信人会有所谓的“命运”，但是我相信对于任何人来说，“限度”总是存在的。再聪明再强悍的人，能够做到的事情也总是有限度的。老人桑地亚哥不是无能之辈，然而，尽管他是最好的渔夫，也不能让那些鱼来上他的钩。他遇到他的限度了，就象最好的农民遇上了大旱，最好的猎手久久碰不到猎物一般。每一个人都会遇到这样的限度，仿佛是命运在向你发出停止前行的命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="王小波" scheme="https://zhang21.github.io/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>sysctl,ulimit以及/proc</title>
    <link href="https://zhang21.github.io/2018/01/09/sysctl%E3%80%81ulimit%E5%92%8Cproc/"/>
    <id>https://zhang21.github.io/2018/01/09/sysctl、ulimit和proc/</id>
    <published>2018-01-09T09:22:48.000Z</published>
    <updated>2018-01-10T02:44:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="http://man.linuxde.net/sysctl" target="_blank" rel="noopener">sysctl命令</a></li><li><a href="http://man.linuxde.net/ulimit" target="_blank" rel="noopener">ulimit命令</a></li><li><a href="http://www.jianshu.com/p/20a2dd80cbad" target="_blank" rel="noopener">ulimit、limits.conf、sysctl和proc文件系统</a></li><li><a href="http://www.jianshu.com/p/9a8e383b5b49" target="_blank" rel="noopener">sysctl.conf学习和调优</a></li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h1><p><code>sysctl</code> 命令被用于在内核运行时动态地修改内核的运行参数，可用的内核参数在目录 <code>/proc/sys</code> 中。它包含一些<code>Tcp/Ip</code>堆栈和虚拟内存系统的高级选项，可以通过修改某些值来提高系统性能。</p><p><code>sysctl</code>可以读取和设置超过五百个系统变量。<br><code>sysctl</code>变量的设置通常是<strong>字符串、数字或布尔型</strong>（布尔型用1表示yes，0表示no）。</p><p><code>sysctl</code> - configure kernel parameters at runtime.</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#sysctl [options] [variable[=value]] [...]</span><br><span class="line"></span><br><span class="line">sysctl -w net.ipv4.tcp_syncookies=1</span><br></pre></td></tr></table></figure><p><br></p><p>可以通过<code>sysctl</code>命令修改系统变量，也可以通过编辑<code>sysctl.conf</code>配置文件来修改系统变量。</p><p><code>sysctl.conf</code> - sysctl preload/configuration file.</p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysct.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Controls source route verification</span><br><span class="line"># Default should work for all interfaces net.ipv4.conf.default.rp_filter = 1</span><br><span class="line"># net.ipv4.conf.all.rp_filter = 1</span><br><span class="line"># net.ipv4.conf.lo.rp_filter = 1</span><br><span class="line"># net.ipv4.conf.eth0.rp_filter = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Disables IP source routing</span><br><span class="line"># Default should work for all interfaces net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line"># net.ipv4.conf.all.accept_source_route = 0</span><br><span class="line"># net.ipv4.conf.lo.accept_source_route = 0</span><br><span class="line"># net.ipv4.conf.eth0.accept_source_route = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Controls the System Request debugging functionality of the kernel</span><br><span class="line">kernel.sysrq = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Controls whether core dumps will append the PID to the core filename</span><br><span class="line"># Useful for debugging multi-threaded applications</span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Increase maximum amount of memory allocated to shm</span><br><span class="line"># Only uncomment if needed</span><br><span class="line"># kernel.shmmax = 67108864</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Disable ICMP Redirect Acceptance</span><br><span class="line"># Default should work for all interfaces</span><br><span class="line">net.ipv4.conf.default.accept_redirects = 0</span><br><span class="line"># net.ipv4.conf.all.accept_redirects = 0</span><br><span class="line"># net.ipv4.conf.lo.accept_redirects = 0</span><br><span class="line"># net.ipv4.conf.eth0.accept_redirects = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># enable Log Spoofed Packets, Source Routed Packets, Redirect Packets</span><br><span class="line"># Default should work for all interfaces</span><br><span class="line">net.ipv4.conf.default.log_martians = 1</span><br><span class="line">#net.ipv4.conf.all.log_martians = 1</span><br><span class="line"># net.ipv4.conf.lo.log_martians = 1</span><br><span class="line"># net.ipv4.conf.eth0.log_martians = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Decrease the time default value for tcp_fin_timeout connection</span><br><span class="line">net.ipv4.tcp_fin_timeout = 25</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Decrease the time default value for tcp_keepalive_time connection</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Turn on the tcp_window_scaling</span><br><span class="line">net.ipv4.tcp_window_scaling = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Turn on the tcp_sack</span><br><span class="line">net.ipv4.tcp_sack = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># tcp_fack should be on because of sack</span><br><span class="line">net.ipv4.tcp_fack = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Turn on the tcp_timestamps</span><br><span class="line">net.ipv4.tcp_timestamps = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Enable TCP SYN Cookie Protection</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Enable ignoring broadcasts request</span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Disable ping requests</span><br><span class="line">net.ipv4.icmp_echo_ignore_all = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Enable bad error message Protection</span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># make more local ports available</span><br><span class="line"># net.ipv4.ip_local_port_range = 1024 65000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># set TCP Re-Ordering value in kernel to 5</span><br><span class="line">net.ipv4.tcp_reordering = 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Lower syn retry rates</span><br><span class="line">net.ipv4.tcp_synack_retries = 2</span><br><span class="line">net.ipv4.tcp_syn_retries = 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Set Max SYN Backlog to 2048</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 2048</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Various Settings</span><br><span class="line">net.core.netdev_max_backlog = 1024</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Increase the maximum number of skb-heads to be cached</span><br><span class="line">net.core.hot_list_length = 256</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Increase the tcp-time-wait buckets pool size</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 360000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># This will increase the amount of memory available for socket input/output queues</span><br><span class="line">net.core.rmem_default = 65535</span><br><span class="line">net.core.rmem_max = 8388608</span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 8388608 net.core.wmem_default = 65535</span><br><span class="line">net.core.wmem_max = 8388608</span><br><span class="line">net.ipv4.tcp_wmem = 4096 65535 8388608</span><br><span class="line">net.ipv4.tcp_mem = 8388608 8388608 8388608</span><br><span class="line">net.core.optmem_max = 40960</span><br></pre></td></tr></table></figure><p>重新加载内核参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-p, read values from file</span></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line"><span class="comment">#-a, display all variables</span></span><br><span class="line">sysctl -a</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h1><p>大多Unix-Like系统，都提供了限制每个进程和每个基本用户使用线程，文件和网络连接等系统资源的一些方法。</p><p>假设有这样一种情况，当一台Linux主机上同时登陆了10人，在资源无限制的情况下，这10个用户同时打开了500个文件。假设每个文件的大小有10M，这是系统的内存资源就会收到巨大挑战。<br>但是任何一台主机的资源都不可能是无限的。所以，资源的合理配置和分配，不仅仅是保证系统可用性的必要条件，也与系统上软件运行的性能有着密不可分的联系。</p><p><code>ulimit</code>是指每个user使用各种资源的限制值。<code>ulimit</code> 命令用来限制系统用户对shell资源的访问，它是一种简单并且有效的实现资源限制的方式。</p><ul><li><code>ulimit</code>的设置值是 per-process的，也就是说，每个进程都有自己的limits值；</li><li>使用<code>ulimit</code>进行修改，是立即生效的；</li><li><code>ulimit</code>只影响shell进程及其子进程，用户登出后失效；</li><li>修改<code>ulimit</code>设置之后，要重启程序修改值才会有效。可通过<code>/proc</code>文件系统查看运行进程当前的限制值;</li><li>使用<code>ulimit</code>对系统限制的改变在系统重启后都会恢复到默认值;</li><li>可以在<code>profile</code>中加入<code>ulimit</code>的设置，便能做到永久生效。</li></ul><p><br></p><p><strong>ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：</strong></p><ul><li>所创建的内核文件的大小；</li><li>进程数据块的大小；</li><li>Shell进程创建文件的大小；</li><li>内存锁住的大小；</li><li>常驻内存集的大小；</li><li>打开文件描述符的数量；</li><li>分配堆栈的最大大小；</li><li>CPU时间；</li><li>单个用户的最大线程数；</li><li>Shell进程所能使用的最大虚拟内存；</li><li>它支持硬资源(hard)和软资源(soft)的限制。</li></ul><p><br></p><p><strong>sort和hard</strong></p><ul><li>hard：是指用户在任何时候都可以活动的进程的最大数量，这是上限。没有任何non-root进程能够增加hard ulimit；</li><li>soft：是对会话或进程实际执行的限制，但任何进程都可以将其增加到hard ulimit的最大值。</li></ul><p><br></p><h2 id="设置ulimit"><a href="#设置ulimit" class="headerlink" title="设置ulimit"></a>设置ulimit</h2><p>可以在以下位置进行ulimit的设置：</p><ul><li><code>/etc/profile</code>，所有用户有效，永久生效；</li><li><code>~/.bash_profile</code>,当前用户有效，永久生效；</li><li>直接在控制台修改，当前用户有效，临时生效；</li></ul><p><br></p><p>永久生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p>临时生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 7170</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 7170</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改限定值</span></span><br><span class="line"><span class="built_in">ulimit</span> -n 201400</span><br><span class="line"><span class="built_in">ulimit</span> -t ulimited</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="limits-conf"><a href="#limits-conf" class="headerlink" title="limits.conf"></a>limits.conf</h1><p><code>limits.conf</code> - configuration file for the pam_limits module</p><p><code>limits.conf</code>是<code>pam_limits.so</code>的配置文件，Linux PAM(Pluggable Authentication Modules，插入式认证模块)。突破系统默认限制，对系统资源有一定保护作用。</p><p><strong>pam_limits模块</strong>对用户的会话进行资源限制，然后<code>/etc/pam.d/</code>下的应用程序调用<code>pam_***.so</code>模块。</p><p><br></p><p><strong><code>limits.conf</code>是针对用户，而<code>sysctl.conf</code>是针对整个系统参数配置。</strong></p><ul><li>一个shell的初始limits就是由pam_limits设定的，用户登录后，pam_limits会给用户的shell设定在limits.conf定义的值；</li><li>pam_limits的设定值也是per-process；</li><li>pam_limits的设置是 永久生效的。</li></ul><p><br></p><p>配置limits.conf：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br></pre></td></tr></table></figure><p><br></p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#&lt;domain&gt;      &lt;type&gt;  &lt;item&gt;         &lt;value&gt;</span><br><span class="line"></span><br><span class="line">#*               soft    core            0</span><br><span class="line">#*               hard    rss             10000</span><br><span class="line">#@student        hard    nproc           20</span><br><span class="line">#@faculty        soft    nproc           20</span><br><span class="line">#@faculty        hard    nproc           50</span><br><span class="line">#ftp             hard    nproc           0</span><br><span class="line">#@student        -       maxlogins       4</span><br></pre></td></tr></table></figure><p>domain：</p><ul><li>username</li><li>@groupname</li></ul><p>type：</p><ul><li>soft</li><li>hard</li><li>-</li></ul><p>item：</p><ul><li>core，限制内核文件的大小</li><li>date，最大数据大小</li><li>fsize，最大文件大小</li><li>memlock，最大锁定内存地址空间</li><li>nofile，打开文件的最大数目</li><li>rss，最大持久设置大小</li><li>stack，最大栈大小</li><li>cpu，以分钟为单位的最多CPU时间</li><li>nproc，进程的最大数目</li><li>as，地址空间限制</li><li>maxlogins，此用户允许登录的最大数目</li></ul><p>value：</p><ul><li>item值的大小</li></ul><p><br></p><hr><p><br></p><h1 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h1><h2 id="什么是-proc文件系统"><a href="#什么是-proc文件系统" class="headerlink" title="什么是/proc文件系统"></a>什么是/proc文件系统</h2><p>Linux内核提供了一种通过<code>/proc</code>文件系统，在运行时访问内核内部数据结构，改变内核设置的机制。</p><p>proc文件系统是一个伪文件系统，它只存在内存当中，不占用外部空间。它以文件系统的方式为访问系统内核数据的操作提供接口。</p><p>对<code>/proc</code>中内核文件的修改，针对的是<strong>整个系统</strong>的<strong>内核参数</strong>，修改后<strong>立即生效</strong>，但修改是 <strong>临时的</strong>，重启后失效。</p><p><br></p><h2 id="proc与sysctl-conf的对应关系"><a href="#proc与sysctl-conf的对应关系" class="headerlink" title="/proc与sysctl.conf的对应关系"></a>/proc与sysctl.conf的对应关系</h2><p>修改<code>/proc</code>文件系统中的参数是临时的，但修改<code>sysctl.conf</code>的参数确是永久有效的。</p><p>配置文件<code>sysctl.conf</code>变量在<code>/proc/sys</code>下，其对应关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#将文件名的 . 变为 /</span><br><span class="line"></span><br><span class="line">#/proc/sys/net/ipv4/icmp_echo_ignore_all</span><br><span class="line">#net.ipv4.icmp_echo_ignore_all</span><br><span class="line"></span><br><span class="line">echo 0 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br><span class="line"></span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line">net.ipv4.icmp_echo_ignore_all = 0</span><br></pre></td></tr></table></figure><p><br></p><h2 id="proc文件系统几个常用的内核文件"><a href="#proc文件系统几个常用的内核文件" class="headerlink" title="/proc文件系统几个常用的内核文件"></a>/proc文件系统几个常用的内核文件</h2><ul><li>/proc/meminfo    #内存信息</li><li>/proc/cpuinfo    #CPU信息</li><li>/proc/sys/fs/file-max    #文件打开数</li><li>/proc/sys/fs/file-nr    #整个系统目前使用的文件句柄数量</li></ul><p><br></p><h2 id="proc文件系统中文件的权限"><a href="#proc文件系统中文件的权限" class="headerlink" title="/proc文件系统中文件的权限"></a>/proc文件系统中文件的权限</h2><p>proc中的每个文件都有一组分配给它的非常特殊的文件许可权，并且每个文件属于特定的用户标识。</p><ul><li>只读：任何用户都不能更改该文件，它用于表示系统信息</li><li>root写</li><li>root读</li></ul><p><br></p><h2 id="对-proc进行读写"><a href="#对-proc进行读写" class="headerlink" title="对/proc进行读写"></a>对/proc进行读写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br><span class="line">#0</span><br><span class="line"></span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br><span class="line"></span><br><span class="line">#当然,也可是用sysctl来配置</span><br></pre></td></tr></table></figure><p><br></p><h2 id="proc内核文件详解"><a href="#proc内核文件详解" class="headerlink" title="/proc内核文件详解"></a>/proc内核文件详解</h2><ul><li>/proc/buddyinfo 每个内存区中的每个order有多少块可用，和内存碎片问题有关</li><li>/proc/cmdline 启动时传递给kernel的参数信息</li><li>/proc/cpuinfo cpu的信息</li><li>/proc/crypto 内核使用的所有已安装的加密密码及细节</li><li>/proc/devices 已经加载的设备并分类</li><li>/proc/dma 已注册使用的ISA DMA频道列表</li><li>/proc/execdomains Linux内核当前支持的execution domains</li><li>/proc/fb 帧缓冲设备列表，包括数量和控制它的驱动</li><li>/proc/filesystems 内核当前支持的文件系统类型</li><li>/proc/interrupts x86架构中的每个IRQ中断数</li><li>/proc/iomem 每个物理设备当前在系统内存中的映射</li><li>/proc/ioports 一个设备的输入输出所使用的注册端口范围</li><li>/proc/kcore 代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于RAM大小加上4kb</li><li>/proc/kmsg 记录内核生成的信息，可以通过/sbin/klogd或/bin/dmesg来处理</li><li>/proc/loadavg 根据过去一段时间内CPU和IO的状态得出的负载状态，与uptime命令有关</li><li>/proc/locks 内核锁住的文件列表</li><li>/proc/mdstat 多硬盘，RAID配置信息(md=multiple disks)</li><li>/proc/meminfo RAM使用的相关信息</li><li>/proc/misc 其他的主要设备(设备号为10)上注册的驱动</li><li>/proc/modules 所有加载到内核的模块列表</li><li>/proc/mounts 系统中使用的所有挂载</li><li>/proc/mtrr 系统使用的Memory Type Range Registers (MTRRs)</li><li>/proc/partitions 分区中的块分配信息</li><li>/proc/pci 系统中的PCI设备列表</li><li>/proc/slabinfo 系统中所有活动的 slab 缓存信息</li><li>/proc/stat 所有的CPU活动信息</li><li>/proc/sysrq-trigger 使用echo命令来写这个文件的时候，远程root用户可以执行大多数的系统请求关键命令，就好- 像在本地终端执行一样。要写入这个文件，需要把/proc/sys/kernel/sysrq不能设置为0。这个文件对root也是不可- 读的</li><li>/proc/uptime 系统已经运行了多久</li><li>/proc/swaps 交换空间的使用情况</li><li>/proc/version Linux内核版本和gcc版本</li><li>/proc/bus 系统总线(Bus)信息，例如pci/usb等</li><li>/proc/driver 驱动信息</li><li>/proc/fs 文件系统信息</li><li>/proc/ide ide设备信息</li><li>/proc/irq 中断请求设备信息</li><li>/proc/net 网卡设备信息</li><li>/proc/scsi scsi设备信息</li><li>/proc/tty tty设备信息</li><li>/proc/net/dev 显示网络适配器及统计信息</li><li>/proc/vmstat 虚拟内存统计信息</li><li>/proc/vmcore 内核panic时的内存映像</li><li>/proc/diskstats 取得磁盘信息</li><li>/proc/schedstat kernel调度器的统计信息</li><li>/proc/zoneinfo 显示内存空间的统计信息，对分析虚拟内存行为很有用</li></ul><p><br></p><p><strong>以下是/proc目录中进程N的信息：</strong></p><ul><li>/proc/N pid为N的进程信息</li><li>/proc/N/cmdline 进程启动命令</li><li>/proc/N/cwd 链接到进程当前工作目录</li><li>/proc/N/environ 进程环境变量列表</li><li>/proc/N/exe 链接到进程的执行命令文件</li><li>/proc/N/fd 包含进程相关的所有的文件描述符</li><li>/proc/N/maps 与进程相关的内存映射信息</li><li>/proc/N/mem 指代进程持有的内存，不可读</li><li>/proc/N/root 链接到进程的根目录</li><li>/proc/N/stat 进程的状态</li><li>/proc/N/statm 进程使用的内存的状态</li><li>/proc/N/status 进程状态信息，比stat/statm更具可读性</li><li>/proc/self 链接到当前正在运行的进程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://man.linuxde.net/sysctl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sysctl命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://man.linuxde.net/ulimit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ulimit命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/20a2dd80cbad&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ulimit、limits.conf、sysctl和proc文件系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/9a8e383b5b49&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sysctl.conf学习和调优&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="系统优化" scheme="https://zhang21.github.io/tags/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>开源许可协议</title>
    <link href="https://zhang21.github.io/2018/01/09/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
    <id>https://zhang21.github.io/2018/01/09/开源许可协议/</id>
    <published>2018-01-09T03:50:27.000Z</published>
    <updated>2018-01-09T05:55:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你为你的产品签发许可，你就是在出让自己的权利。不过，你仍拥有版权和专利（如果申请了专利）。许可的目的，是向使用你产品的人提供一定的权利。</p><p>不管产品是免费分发，还是出售，指定一份许可协议都非常有用。否则，对于免费，你相当于放弃了自己的所有权利，任何人都没有义务表明你的原始作者身份。对于出售，你将不得不花费比开发更多的精力用来处理授权问题。</p><p>而开源许可协议是这些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的身份，使你至少获得认可。开源许可协议还可以阻止其它人将某个产品据为己有。</p><p><br><br><a id="more"></a></p><p><img src="/images/opensourcelicence.png" alt="开源许可协议区别"></p><p><br></p><p><img src="/images/opensourcelicence.jpg" alt="开源许可协议区别"></p><p><br></p><hr><p><br></p><h1 id="几大开源许可协议"><a href="#几大开源许可协议" class="headerlink" title="几大开源许可协议"></a>几大开源许可协议</h1><p><br><br><br></p><h2 id="GNU-Project"><a href="#GNU-Project" class="headerlink" title="GNU Project"></a>GNU Project</h2><ul><li>GNU是“GNU’s Not Unix”的递归缩写，发音为 /‘gnu:’/；</li><li>GNU Project，是一个由自由软件集体协作项目，它的目标是创建一套完全自由的操作系统，称为GNU；</li><li>GNU是一个自由操作系统，其内容软件完全以 GPL 方式发布，它的设计类似于Unix，但它不包含具有著作权的Unix代码。</li></ul><p><br></p><h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GNU(General Public Licence)，GNU通用许可协议(简称GPL)是广泛使用的免费软件许可证，也称为 copyleft，与copyright相对应。<br>GPL保证了所有开发者的权利，同时为使用者提供了足够的复制、分发、修改的权利。</p><p>需要注意的是，分发的时候，需要明确提供源代码和二进制文件。</p><ul><li><strong>可自由复制：</strong> 你可以将软件复制到你的电脑或任何地方，复制份数没有限制；</li><li><strong>可自由分发：</strong> 可下载后拷贝分发；</li><li><strong>可以用来盈利：</strong> 你可以在分发软件的时候收费，但必须在收费前向你的客户提供该软件的 GNU GPL许可协议，以便让他们知道，他们可以从别的渠道免费得到这份软件以及你收费的理由；</li><li><strong>可自由修改：</strong> 你过你想添加或删除某个功能，没问题。如果你想在别的项目中使用部分代码，也没问题，唯一要求是使用了这段代码的项目也必须使用 GPL协议。</li></ul><p><br></p><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>GNU还有另外一种协议，叫做LGPL（Lesser General Public License），它对产品所保留的权利比GPL少。<br>总的来说，LGPL适合那些用于非GPL或非开源产品的开源类库或框架。因为GPL要求，使用了GPL代码的产品也必须使用GPL协议，开发者不允许将GPL代码用于商业产品。LGPL绕过了这一限制。</p><p>GPL和LGPL都属于GNU计划里面的许可证。</p><p><br></p><hr><p><br></p><h2 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h2><p>伯克利软件套件（Berkeley Software Distribution，缩写BSD），也被称为伯克利Unix，是一个操作系统的名称，衍生自Unix，也被用来代表一整套软件发行版。</p><p>BSD许可证（Berkeley Software Distribution License），是自由软件中使用广泛的许可证。BSD软件就是遵照这个许可证来发布，该许可证也因此而得名。</p><p>BSD在软件分发方面的限制比别的开源协议要少，且和GPL兼容，并为开源组织所认可。</p><p><br></p><hr><p><br></p><h2 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h2><p>MIT（Massachusetts Institute of Technology），麻省理工学院。<br>MIT许可协议（The MIT License）是许多软件授权条款中，被广泛使用的其中一种。与其他常见的软件许可协议相比，MIT是相对宽松的软件许可协议，除了必须包含许可声明外，再无任何限制。</p><p>MIT许可协议核心条款：</p><ul><li>该软件及其相关文档对所有人免费，可以任意处置，包括使用、复制、修改、合并、发表、分发、再授权或销售；</li><li>唯一的限制，软件中必须包含上述版权和许可证。</li></ul><p><br></p><hr><p><br></p><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>Apache许可证（Apache License），是一个由Apache软件基金会发布的自由软件许可证。Apache许可证要求被授权者保留版权和放弃权利的声明，但它不是一个反版权的许可证。兼容与GPL。</p><p>除了为用户提供版权许可之外，还有专利许可，对于那些涉及专利内容的开发者而言，该协议最适合。</p><ul><li>永久权利：一旦被授权，永久拥有；</li><li>全球范围的权利：在一个国家获得授权，适用于所有国家；</li><li>授权免费，且无版税：前后期均无任何费用；</li><li>授权不可撤销：一旦获得授权，没有任何人可以取消。</li></ul><p>分发代码方面，要在声明中对参与开发的人给予认可并包含一份许可协议原文。</p><p><br></p><hr><p><br></p><h2 id="MPL"><a href="#MPL" class="headerlink" title="MPL"></a>MPL</h2><p>MPL是The Mozilla[mɔzilə] Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。<br>MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。</p><p>同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA 认定的开源软件许可证）。</p><p>MPL几个特点：</p><ul><li>MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL 许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口；</li><li>MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序；</li><li>对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利；</li><li>对源代码的定义，MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。</li></ul><p><br></p><hr><p><br></p><h2 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h2><p>知识共享许可协议(Creative Commons License，简称CC)，并非严格意义上的开源许可，是一种公共版权许可协议。它主要用于设计，其允许分发受版权保护的作品。</p><p>CC协议主要包含4种基本形式：</p><ul><li>署名权：必须为原始作业署名，然后才可以修改、分发、复制；</li><li>保持一致：作品同样可以在CC协议的基础上修改、分发、复制；</li><li>非商业：不能用于商业用途；</li><li>不能衍生新作品：你可以复制、分发、但不能修改，也不能以此为基础创作自己的作品。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你为你的产品签发许可，你就是在出让自己的权利。不过，你仍拥有版权和专利（如果申请了专利）。许可的目的，是向使用你产品的人提供一定的权利。&lt;/p&gt;
&lt;p&gt;不管产品是免费分发，还是出售，指定一份许可协议都非常有用。否则，对于免费，你相当于放弃了自己的所有权利，任何人都没有义务表明你的原始作者身份。对于出售，你将不得不花费比开发更多的精力用来处理授权问题。&lt;/p&gt;
&lt;p&gt;而开源许可协议是这些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的身份，使你至少获得认可。开源许可协议还可以阻止其它人将某个产品据为己有。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="开源许可协议" scheme="https://zhang21.github.io/tags/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Yum源</title>
    <link href="https://zhang21.github.io/2018/01/09/Yum%E6%BA%90/"/>
    <id>https://zhang21.github.io/2018/01/09/Yum源/</id>
    <published>2018-01-09T03:46:21.000Z</published>
    <updated>2018-03-11T08:32:42.636Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="http://blog.csdn.net/leshami/article/details/78133716" target="_blank" rel="noopener">CentOS 7下配置本地yum源及yum客户端</a></li><li><a href="http://blog.csdn.net/conling_/article/details/70399694" target="_blank" rel="noopener">Centos7 配置本地源+阿里yum源/epel-yum+修改优先级</a></li><li><a href="http://blog.csdn.net/kingfox/article/details/51233153" target="_blank" rel="noopener">调整CentOS 7中yum仓库的优先级</a></li><li><a href="https://segmentfault.com/a/1190000000375848" target="_blank" rel="noopener">国内开源站点</a></li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="国内开源镜像站点"><a href="#国内开源镜像站点" class="headerlink" title="国内开源镜像站点"></a>国内开源镜像站点</h1><ul><li>网易开源镜像站：<a href="http://mirrors.163.com/" target="_blank" rel="noopener">http://mirrors.163.com/</a></li><li>阿里云开源镜像站：<a href="http://mirrors.aliyun.com" target="_blank" rel="noopener">http://mirrors.aliyun.com</a></li><li>清华大学开源镜像站：<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a></li><li>浙江大学开源镜像站： <a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/</a></li><li>中国科技大学开源镜像站：<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a></li></ul><p><br></p><hr><p><br></p><h1 id="CentOS自带源"><a href="#CentOS自带源" class="headerlink" title="CentOS自带源"></a>CentOS自带源</h1><p>rpm包管理方式，对于安装、升级、卸载却难以处理包之间的依赖关系。而yum作为一个rpm包前端管理工具，可以自动处理依赖性，并支持在线现在、安装、升级、卸载rpm软件包。</p><p>CentOS默认自带<code>CentOS-Base.repo</code>源，但官方源在国外，连接速度令人心痛。并且有很多软件在默认源里面是找不到的。</p><h2 id="配置网络yun源"><a href="#配置网络yun源" class="headerlink" title="配置网络yun源"></a>配置网络yun源</h2><p><strong>配置aliyun.repo：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#先备份默认源</span><br><span class="line">mv CentOS-Base.repo&#123;,.bak&#125;</span><br><span class="line"></span><br><span class="line">#下载阿里云源替换默认源</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line">yum clean all</span><br><span class="line">yum makecache    #重构yum缓存</span><br><span class="line"></span><br><span class="line">yum repolist    #查看yum仓库</span><br></pre></td></tr></table></figure><p><br></p><h2 id="配置本地yum源"><a href="#配置本地yum源" class="headerlink" title="配置本地yum源"></a>配置本地yum源</h2><p><strong>配置本地yum源，考虑到优先使用本地安装包，所以会涉及到一个优先级的概念。</strong></p><p>安装完毕后，就可以在yum源中添加一个优先级<code>priority</code>。</p><p><strong>安装yum优先级插件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-plugin-priorities</span><br><span class="line"></span><br><span class="line">#检查安装完成后配置</span><br><span class="line">vim /etc/yum/pluginconf.d/priorities.conf</span><br><span class="line"></span><br><span class="line">enable=1</span><br><span class="line">#enable=0</span><br></pre></td></tr></table></figure><p><br></p><p><strong>创建本地yum源：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo&#123;,.bak&#125;</span><br><span class="line"></span><br><span class="line">vim /etc/yum.repos.d/CentOS-Local.repo</span><br><span class="line"></span><br><span class="line">[base-Local]</span><br><span class="line">name=Centos- Local</span><br><span class="line">baseurl=file:///mnt/xxx</span><br><span class="line">gpgcheck=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line">priority=1    #优先级为1</span><br><span class="line"></span><br><span class="line">[updates-Local]</span><br><span class="line">name=CentOS- Local</span><br><span class="line">gpgcheck=0</span><br><span class="line">baseurl=file:///dir/path/</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line">priority=1</span><br><span class="line"></span><br><span class="line">······</span><br><span class="line">#具体可参考CentOS-Base.repo</span><br><span class="line">#可将aliyun源优先级写成2</span><br><span class="line"></span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p><br></p><h2 id="配置ftp方式源"><a href="#配置ftp方式源" class="headerlink" title="配置ftp方式源"></a>配置ftp方式源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/ftp.repo</span><br><span class="line"></span><br><span class="line">[ftp-media]</span><br><span class="line">name=name=CentOS-$releasever - media</span><br><span class="line">baseurl=ftp://ip</span><br><span class="line">gpgcheck=0</span><br><span class="line">enable=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="其他常见YUM源"><a href="#其他常见YUM源" class="headerlink" title="其他常见YUM源"></a>其他常见YUM源</h1><p>官方的默认<code>yum源</code>提供的软件包往往是很滞后的，(可能为了服务器版本的稳定性和安全性)。并且官方默认源提供的RPM包也不够丰富。</p><p><br></p><h2 id="EPEL源"><a href="#EPEL源" class="headerlink" title="EPEL源"></a>EPEL源</h2><p>EPEL的全称叫 <code>Extra Packages for Enterprise Linux</code> 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。</p><p><code>EPEL源</code>为服务器提供了大量的rpm包(这些包可能有很多在默认源中没有)，并且绝大多数rpm包比官方默认源版本要新。</p><p><strong>添加epel源：</strong><br>epel下载地址：<a href="http://download.fedora.redhat.com/pub/epel/" target="_blank" rel="noopener">http://download.fedora.redhat.com/pub/epel/</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -vih http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">#yum install -y epel-release</span></span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="remi源"><a href="#remi源" class="headerlink" title="remi源"></a>remi源</h2><p>Remi源大家或许很少听说，不过Remi源GoFace强烈推荐，尤其对于不想编译最新版的linux使用者，因为Remi源中的软件几乎都是最新稳定版。<br>或许您会怀疑稳定不？<br>放心，这些都是Linux骨灰级的玩家编译好放进源里的，他们对于系统环境和软件编译参数的熟悉程度毋庸置疑。</p><p><strong>添加remi源：</strong><br>Remi下载地址：<a href="http://rpms.famillecollet.com" target="_blank" rel="noopener">http://rpms.famillecollet.com</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">#yum install -y  http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</span></span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="RPMForge源"><a href="#RPMForge源" class="headerlink" title="RPMForge源"></a>RPMForge源</h2><p><code>RPMForge</code>是<code>CentOS</code>系统下的软件仓库，拥有4000多种的软件包, 被CentOS社区认为是最安全也是最稳定的一个软件仓库。</p><p><strong>添加RPMForge源：</strong><br>RPMForge下载地址：<a href="http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/" target="_blank" rel="noopener">http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/</a><br>GitHub:<a href="https://github.com/repoforge" target="_blank" rel="noopener">https://github.com/repoforge</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm</span><br><span class="line"></span><br><span class="line">#yum localinstall --nogpgcheckhttp://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/leshami/article/details/78133716&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CentOS 7下配置本地yum源及yum客户端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/conling_/article/details/70399694&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Centos7 配置本地源+阿里yum源/epel-yum+修改优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/kingfox/article/details/51233153&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;调整CentOS 7中yum仓库的优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000375848&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;国内开源站点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Yum" scheme="https://zhang21.github.io/tags/Yum/"/>
    
  </entry>
  
</feed>
