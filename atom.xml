<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风继续吹</title>
  
  <subtitle>Yesterday, you said tomorrow!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhang21.github.io/"/>
  <updated>2020-10-12T09:19:44.737Z</updated>
  <id>https://zhang21.github.io/</id>
  
  <author>
    <name>Leslie Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Helm</title>
    <link href="https://zhang21.github.io/2020/09/21/Helm/"/>
    <id>https://zhang21.github.io/2020/09/21/Helm/</id>
    <published>2020-09-21T07:11:22.000Z</published>
    <updated>2020-10-12T09:19:44.737Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>docs: <a href="https://docs.helm.sh/" target="_blank" rel="noopener">https://docs.helm.sh/</a></li><li>github: <a href="https://github.com/helm" target="_blank" rel="noopener">https://github.com/helm</a></li></ul><p>环境：</p><ul><li>el7x86_64</li><li>helm v3.3</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br><br><br></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>Helm</strong>是Kubernetes生态系统中的一个软件包管理工具，主要用来管理<strong>Charts</strong>，有点类似于Ubuntu中的apt或CentOS中的yum。由go编写，是Deis公司发起的一个开源工具，有助于简化部署和管理Kubernetes应用。</p><p>在Kubernetes中，应用管理是需求最多、挑战最大的领域。Helm项目提供了一个统一软件打包方式，支持版本控制，可以大大简化Kubernetes应用分发与部署中的复杂性。</p><p>Helm Chart是用来封装 Kubernetes原生应用程序的一系列YAML文件。可以在你部署应用的时候自定义应用程序的一些 Metadata，以便于应用程序的分发。</p><p>对于应用发布者而言，可以通过 Helm 打包应用、管理应用依赖关系、管理应用版本并发布应用到软件仓库。</p><p>对于使用者而言，使用 Helm 后不用需要编写复杂的应用部署文件，可以以简单的方式在 Kubernetes 上查找、安装、升级、回滚、卸载应用程序。</p><p><br></p><p><img src="/images/Helm/Helm_Logo.png" alt></p><p><br></p><p>The package manager for Kubernetes.</p><p>Helm is the best way to find, share, and use software built for Kubernetes.</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>Glossary: <a href="https://helm.sh/docs/glossary/" target="_blank" rel="noopener">https://helm.sh/docs/glossary/</a></p><p><br></p><p><strong>Chart</strong></p><p>Helm包涵盖了将k8s资源安装到k8s集群所需的足够多的信息。<br>Charts包含了<code>Chart.yaml</code>文件核模板，默认值(<code>values.yaml</code>)，以及相关依赖。<br>Charts开发设计了良好定义的目录结构，并打包为chart archive。</p><p><br></p><p><strong>Chart Archive</strong></p><p>Chart包是被<code>tar</code>和<code>gzip</code>压缩（可选签名）的chart。</p><p><br></p><p><strong>Chart Dependency(Subcharts)</strong></p><p>Chart可以依赖于其它chart。依赖有两种方式：</p><ul><li>软依赖(soft): 如果另一个chart没有在集群中安装，chart可能会无法使用</li><li>硬依赖(hard): chart包含它所依赖的chart。（在<code>charts/</code>目录中）</li></ul><p>当一个chart打包(<code>helm package</code>)时，所有的依赖都会和它绑定。</p><p><br></p><p><strong>Chart Version</strong></p><p>每个chart都需要版本号。</p><p><br></p><p><strong>Chart.yaml</strong></p><p>chart的信息说明被存储在一个特定文件(<code>Chart.yaml</code>)。每个chart都必须有这个文件。</p><p><br></p><p><strong>helm</strong></p><p>Helm是k8s包管理器。作为一个操作系统包管理器，使其很容易在操作系统中安装工具。Helm使得k8s集群中安装应用和资源变得异常简单。</p><p><br></p><p><strong>Helm Configuration Files</strong></p><p>Helm将配置文件存储在XDG目录中。<code>helm</code>第一次运行，会自动生成。</p><p><strong>Kube Config(KUBECONFIG)</strong></p><p>helm客户端通过Kube config配置文件来理解k8s集群。默认<code>$HOME/.kube/config</code>。</p><p><br></p><p><strong>Lint</strong></p><p>Helm代码规范，规范一个chart是去验证其遵照Helm chart的标准规范和要求。Helm提供了<code>helm lint</code>命令。</p><p><br></p><p><strong>Provenance</strong></p><p>Helm chart可以由来源文件(provenance file)提供chart的出处以及它所包含的内容。</p><p>来源文件(<code>.prov</code>)是Helm安全的一部分。一个来源包含chart包文件的加密哈希值，<code>Chart.yaml</code>数据，一个签名块。当再加上一个钥匙链(keychain)时，可为chart用户提供以下能力：</p><ul><li>验证chart被可信第三方签名</li><li>验证chart文件没有被篡改</li><li>验证chart的元数据内容(<code>Chart.yaml</code>)</li><li>快速匹配chart的数据来源</li></ul><p><br></p><p><strong>Release</strong></p><p>发行版本。chart安装之后，Helm库会创建一个release来跟踪这个安装。</p><p>单个chart可以在同一个集群中安装多次，并能创建多个不同的版本。</p><p><br></p><p><strong>Release Number/Version</strong></p><p>单个版本号可以被升级多次。通过连续技术来跟踪升级发布版本。</p><p><br></p><p><strong>Rollback</strong></p><p>每一次发布会更新chart或者配置。当生成发布历史后，一次发布也可以被 rolled back 之前的发布版本号。回滚使用<code>helm rollback</code>命令。</p><p>重要的是, 每一次回滚版本会生成一个新的发布版本号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">操作版本号</span><br><span class="line">installrelease 1</span><br><span class="line">upgraderelease 2</span><br><span class="line">upgraderelease 3</span><br><span class="line">rollback 1release 4 (但使用release 1的配置)</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Helm Library(SDK)</strong></p><p>Helm库（或SDK）涉及到go代码，可以直接与k8s API服务交互进行安装、升级、查询 以及移除k8s资源。</p><p><br></p><p><strong>Repository</strong></p><p>Helm chart可以被存储到专用的HTTP服务器上，称之为chart仓库。</p><p>Helm客户端可以指向零个或多个chart仓库。默认没有配置仓库，可使用<code>helm repo add</code>添加。</p><p><br></p><p><strong>Values</strong></p><p>Values 提供了一种使用您自己的信息覆盖模板默认值的方式。</p><p>Helm Chart是参数化的, 这意味着chart开发者可以在安装时显式配置。比如说，chart可以暴露<code>username</code>字段， 允许为服务设置一个用户名。这些可暴露的变量在Helm用语中称为<code>values</code>。</p><p>Values可在<code>helm install</code>, <code>helm upgrage</code>时设置。也可以在<code>values.yaml</code>文件中设置。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Introduction: <a href="https://helm.sh/docs/intro/" target="_blank" rel="noopener">https://helm.sh/docs/intro/</a></p><p><br></p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>Quickstart: <a href="https://helm.sh/docs/intro/quickstart/" target="_blank" rel="noopener">https://helm.sh/docs/intro/quickstart/</a></p><p>如何快速安装核使用Helm。</p><p><br></p><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>Prerequisites</p><p>使用Helm的前置条件：</p><ul><li>k8s集群<ul><li>建议最新k8s稳定版</li><li><code>kubectl</code></li></ul></li><li>安装的安全配置(如果有的话)</li><li>安装和配置Helm</li></ul><p>注意Helm版本对应支持的k8s版本。</p><p><br><br><br></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Install: <a href="https://helm.sh/docs/intro/install/" target="_blank" rel="noopener">https://helm.sh/docs/intro/install/</a></p><p>从源码、或二进制安装Helm CLI。</p><p><br></p><h4 id="从Helm项目"><a href="#从Helm项目" class="headerlink" title="从Helm项目"></a>从Helm项目</h4><p>From The Helm Project</p><p><br></p><p><strong>从二进制包:</strong></p><ul><li>下载特定版本包: <a href="https://github.com/helm/helm/releases" target="_blank" rel="noopener">https://github.com/helm/helm/releases</a></li><li>解压</li><li>添加到PATH</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://get.helm.sh/helm-v3.3.3-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf helm-v3.3.3-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">mv helm /usr/<span class="built_in">local</span>/bin/helm</span><br></pre></td></tr></table></figure><p><br></p><p><strong>从脚本:</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3</span><br><span class="line">chmod 700 get_helm.sh</span><br><span class="line">./get_helm.sh</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="从源码"><a href="#从源码" class="headerlink" title="从源码"></a>从源码</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/helm/helm.git</span><br><span class="line"><span class="built_in">cd</span> helm</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="初始化Helm-chart"><a href="#初始化Helm-chart" class="headerlink" title="初始化Helm chart"></a>初始化Helm chart</h3><p>Initialize a Helm Chart Repository</p><p>Helm安装好之后，你可以添加一个chart仓库。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加Helm官方仓库</span></span><br><span class="line">helm repo add stable https://kubernetes-charts.storage.googleapis.com/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看安装的charts列表</span></span><br><span class="line">helm search repo stable</span><br><span class="line">NAME                                    CHART VERSION   APP VERSION                     DESCRIPTION</span><br><span class="line">stable/acs-engine-autoscaler            2.2.2           2.1.1                           DEPRECATED Scales worker nodes within agent pools</span><br><span class="line">stable/aerospike                        0.2.8           v4.5.0.5                        A Helm chart <span class="keyword">for</span> Aerospike <span class="keyword">in</span> Kubernetes</span><br><span class="line">stable/airflow                          4.1.0           1.10.4                          Airflow is a platform to programmatically autho...</span><br><span class="line">stable/ambassador                       4.1.0           0.81.0                          A Helm chart <span class="keyword">for</span> Datawire Ambassador</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="安装Chart"><a href="#安装Chart" class="headerlink" title="安装Chart"></a>安装Chart</h3><p>Install an Example Chart</p><p>可以通过<code>helm install</code>命令安装chart。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">helm repo update</span><br><span class="line"></span><br><span class="line"><span class="comment"># helm install，都会创建一个新的release</span></span><br><span class="line"><span class="comment"># 所以一个chart在同一个集群里面可以被安装多次，每一个都可以被独立的管理和升级</span></span><br><span class="line">helm install stable/mysql --generate-name</span><br><span class="line">NAME: mysql-1600679719</span><br><span class="line">LAST DEPLOYED: Mon Sep 21 17:15:23 2020</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">NOTES:</span><br><span class="line">MySQL can be accessed via port 3306 on the following DNS name from within your cluster:</span><br><span class="line">mysql-1600679719.default.svc.cluster.local</span><br><span class="line"></span><br><span class="line">To get your root password run:</span><br><span class="line"></span><br><span class="line">    MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace default mysql-1600679719 -o jsonpath=<span class="string">"&#123;.data.mysql-root-password&#125;"</span> | base64 --decode; <span class="built_in">echo</span>)</span><br><span class="line"></span><br><span class="line">To connect to your database:</span><br><span class="line"></span><br><span class="line">1. Run an Ubuntu pod that you can use as a client:</span><br><span class="line"></span><br><span class="line">    kubectl run -i --tty ubuntu --image=ubuntu:16.04 --restart=Never -- bash -il</span><br><span class="line"></span><br><span class="line">2. Install the mysql client:</span><br><span class="line"></span><br><span class="line">    $ apt-get update &amp;&amp; apt-get install mysql-client -y</span><br><span class="line"></span><br><span class="line">3. Connect using the mysql cli, <span class="keyword">then</span> provide your password:</span><br><span class="line">    $ mysql -h mysql-1600679719 -p</span><br><span class="line"></span><br><span class="line">To connect to your database directly from outside the K8s cluster:</span><br><span class="line">    MYSQL_HOST=127.0.0.1</span><br><span class="line">    MYSQL_PORT=3306</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Execute the following command to route the connection:</span></span><br><span class="line">    kubectl port-forward svc/mysql-1600679719 3306</span><br><span class="line"></span><br><span class="line">    mysql -h <span class="variable">$&#123;MYSQL_HOST&#125;</span> -P<span class="variable">$&#123;MYSQL_PORT&#125;</span> -u root -p<span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看此chart的基本信息</span></span><br><span class="line">helm show chart stable/mysql</span><br><span class="line">helm show all stable/mysql</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Releases"><a href="#Releases" class="headerlink" title="Releases"></a>Releases</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看chart发行版</span></span><br><span class="line">helm ls</span><br><span class="line">NAME                    NAMESPACE       REVISION        UPDATED                                 STATUS          CHART           APP VERSION</span><br><span class="line">mysql-1600679719        default         1               2020-09-21 17:15:23.169811348 +0800 CST deployed        mysql-1.6.7     5.7.30</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有部署的发行</span></span><br><span class="line">helm list</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="卸载Release"><a href="#卸载Release" class="headerlink" title="卸载Release"></a>卸载Release</h3><p>使用<code>helm uninstall</code>命令卸载realease。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm uninstall mysql-1600679719</span><br><span class="line">release <span class="string">"mysql-1600679719"</span> uninstalled</span><br></pre></td></tr></table></figure><p>它会删除和该release相关的所有资源。使用<code>--keep-history</code>选项，Helm将保存release history。所以你可以审计集群历史甚至使用<code>helm rollback</code>回滚release。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>Topic Guides: <a href="https://helm.sh/docs/topics/" target="_blank" rel="noopener">https://helm.sh/docs/topics/</a></p><p><br></p><h2 id="Charts"><a href="#Charts" class="headerlink" title="Charts"></a>Charts</h2><p>Charts: <a href="https://helm.sh/docs/topics/charts/" target="_blank" rel="noopener">https://helm.sh/docs/topics/charts/</a></p><p>Helm使用的包格式称为charts。chart就是一个描述k8s相关资源的文件集合。单个chart可以用来部署简单或复杂的服务。</p><p>Chart是作为特定目录布局的文件被创建，它们可以打包到要部署的版本存档中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 下载一个chart，但不安装</span><br><span class="line">helm pull xxx</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>chart是一个组织在文件目录中的集合。目录名称就是chart名称(没有版本信息)。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wordpress/</span><br><span class="line">  Chart.yaml          # 包含了chart信息的YAML文件</span><br><span class="line">  LICENSE             # 可选: 包含chart许可证的纯文本文件</span><br><span class="line">  README.md           # 可选: 可读的README文件</span><br><span class="line">  values.yaml         # chart 默认的配置值</span><br><span class="line">  values.schema.json  # 可选: 一个使用JSON结构的values.yaml文件</span><br><span class="line">  charts/             # 包含chart依赖的其他chart</span><br><span class="line">  crds/               # 自定义资源的定义</span><br><span class="line">  templates/          # 模板目录， 当和values 结合时，可生成有效的Kubernetes manifest文件</span><br><span class="line">  templates/NOTES.txt # 可选: 包含简要使用说明的纯文本文件</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Chart-yaml"><a href="#Chart-yaml" class="headerlink" title="Chart.yaml"></a>Chart.yaml</h3><p><code>Chart.yaml</code>文件是chart必须的。包含以下字段。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">chart</span> <span class="string">API</span> <span class="string">版本</span> <span class="string">（必需）</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">chart名称</span> <span class="string">（必需）</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">语义化2</span> <span class="string">版本（必需）</span></span><br><span class="line"><span class="attr">kubeVersion:</span> <span class="string">兼容Kubernetes版本的语义化版本（可选）</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">一句话对这个项目的描述（可选）</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">chart类型</span> <span class="string">（可选）</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">关于项目的一组关键字（可选）</span></span><br><span class="line"><span class="attr">home:</span> <span class="string">项目home页面的URL</span> <span class="string">（可选）</span></span><br><span class="line"><span class="attr">sources:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">项目源码的URL列表（可选）</span></span><br><span class="line"><span class="attr">dependencies:</span> <span class="comment"># chart 必要条件列表 （可选）</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">chart名称</span> <span class="string">(nginx)</span></span><br><span class="line"><span class="attr">    version:</span> <span class="string">chart版本</span> <span class="string">("1.2.3")</span></span><br><span class="line"><span class="attr">    repository:</span> <span class="string">仓库URL</span> <span class="string">("https://example.com/charts")</span> <span class="string">或别名</span> <span class="string">("@repo-name")</span></span><br><span class="line"><span class="attr">    condition:</span> <span class="string">（可选）</span> <span class="string">解析为布尔值的yaml路径，用于启用、禁用chart</span> <span class="string">(e.g.</span> <span class="string">subchart1.enabled</span> <span class="string">)</span></span><br><span class="line"><span class="attr">    tags:</span> <span class="comment"># （可选）</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">用于一次启用/禁用</span> <span class="string">一组chart的tag</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="string">（可选）</span> <span class="string">决定是否加载chart的布尔值</span></span><br><span class="line"><span class="attr">    import-values:</span> <span class="comment"># （可选）</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ImportValue</span> <span class="string">保存源值到导入父键的映射。每项可以是字符串或者一对子/父列表项</span></span><br><span class="line"><span class="attr">    alias:</span> <span class="string">（可选）</span> <span class="string">chart中使用的别名。当你要多次添加相同的chart时会很有用</span></span><br><span class="line"><span class="attr">maintainers:</span> <span class="comment"># （可选）</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">维护者名字</span> <span class="string">（每个维护者都需要）</span></span><br><span class="line"><span class="attr">    email:</span> <span class="string">维护者邮箱</span> <span class="string">（每个维护者可选）</span></span><br><span class="line"><span class="attr">    url:</span> <span class="string">维护者URL</span> <span class="string">（每个维护者可选）</span></span><br><span class="line"><span class="attr">icon:</span> <span class="string">用做icon的SVG或PNG图片URL</span> <span class="string">（可选）</span></span><br><span class="line"><span class="attr">appVersion:</span> <span class="string">包含的应用版本（可选）。不需要是语义化的</span></span><br><span class="line"><span class="attr">deprecated:</span> <span class="string">不被推荐的chart</span> <span class="string">（可选，布尔值）</span></span><br><span class="line"><span class="attr">annotations:</span></span><br><span class="line"><span class="attr">  example:</span> <span class="string">按名称输入的批注列表</span> <span class="string">（可选）.</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>Chart和版本控制</strong></p><p>每个chart都必须有版本号。版本必须遵循SemVer2标准。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># nginx chart的版本字段version: 1.2.3</span><br><span class="line"># 按照名称设置为</span><br><span class="line">nginx-1.2.3.tgz</span><br></pre></td></tr></table></figure><p><code>Chart.yaml</code>文件中的<code>version</code>字段被很多Helm工具使用。当生成一个包时，<code>helm package</code>命令可以用<code>Chart.yaml</code>文件中找到的版本号作为包名的token。系统假设chart包名中的版本号可以与<code>Chart.yaml</code>文件中的版本号匹配。如果不满足这一假设会导致错误。</p><p><br></p><p><strong>apiVersion字段</strong></p><p>对于至少需要Helm3的chart，<code>apiVersion</code>字段应该是<code>v2</code>。</p><p><br></p><p><strong>kubeVersion字段</strong></p><p>可选的<code>kubeVersion</code>字段可以在支持的k8s版本上定义语义约束，Helm 在安装chart时会验证这个版本约束， 并在集群运行不支持的k8s版本时显示失败。</p><p>版本约束可以包含空格、比较操作符、逻辑操作符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;= 1.13.0 &lt; 1.15.0</span><br><span class="line"></span><br><span class="line">&gt;= 1.13.0 &lt; 1.14.0 || &gt;= 1.14.1 &lt; 1.15.0</span><br><span class="line"></span><br><span class="line">1.1 - 2.3.4</span><br></pre></td></tr></table></figure><p><br></p><p><strong>deprecated字段</strong></p><p>在Chart仓库管理chart时，有时需要废弃一个chart。<code>deprecated</code>字段可用来标记已弃用的chart。如果latest版本被标记为已弃用，则所有的chart都会被认为是已弃用的。以后可以通过发布未标记为已弃用的新版本来重新使用chart名称。</p><p><code>kubernetes/charts</code>项目遵循的弃用charts的流程为：</p><ul><li>升级chart的<code>Chart.yaml</code>文件，将这个文件标记为已弃用，并更改版本</li><li>在chart仓库中发布新版的chart</li><li>从源仓库中移除这个chart</li></ul><p><br></p><p><strong>type字段</strong></p><p><code>type</code>字段定义了chart的类型。有两种类型：</p><ul><li><code>application</code>：默认类型，是可以完全操作的标准chart。</li><li><code>library</code>：不能安装，提供针对chart构建的实用程序和功能。通常不包含任何资源对象。</li></ul><p>应用类型chart 可以作为库类型chart使用。可以通过将类型设置为<code>library</code>来实现。 然后这个库就被渲染成了一个库类型chart，所有的实用程序和功能都可以使用。所有的资源对象不会被渲染。</p><p><br><br><br></p><h3 id="许可证和描述"><a href="#许可证和描述" class="headerlink" title="许可证和描述"></a>许可证和描述</h3><p>Chart LICENSE, README and NOTES</p><p>Chart也可以包含描述安装、配置和使用的文件，以及chart许可证。</p><p>LICENSE是一个包含了chart license的纯文本文件。chart可以包含一个许可证，因为在模板里不只是配置，还可能有编码逻辑。如果需要，还可以为chart安装的应用程序提供单独的许可证。</p><p>README自述文件，一般包含：</p><ul><li>chart提供的应用或服务的描述</li><li>运行chart的先决条件或要求</li><li><code>values.yaml</code>的可选项和默认值的描述</li><li>与chart的安装或配置相关的其它信息</li></ul><p>chart也会包含一个简短的纯文本<code>templates/NOTES.txt</code>文件，这会在安装后及查看版本状态时打印出来。由于此文件是在运行<code>helm install</code>或<code>helm status</code>时打印到STDOUT的，因此建议保持内容简短，并指向自述文件以获取更多详细信息。</p><p><br><br><br></p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>Chart Dependencies</p><p>Helm中，chart可能会依赖其它任意个chart。这些依赖可使用<code>dependencies</code>字段(<code>Chart.yaml</code>)动态链接，或写入<code>charts/</code>目录。</p><p><br></p><p><strong>dependencies字段</strong></p><p>当前chart依赖的其它chart会在<code>dependencies</code>字段定义为一个列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">    version:</span> <span class="number">1.2</span><span class="number">.3</span></span><br><span class="line"><span class="attr">    repository:</span> <span class="attr">https://example.com/charts</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">    version:</span> <span class="number">3.2</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    repository:</span> <span class="attr">https://another.example.com/charts</span></span><br></pre></td></tr></table></figure><p>必须使用<code>helm repo add</code>在本地添加仓库。</p><p>一旦你定义好了依赖，运行<code>helm dependency update</code>就会使用你的依赖文件下载所有你指定的chart到你的<code>charts/</code>目录。</p><p><br></p><p><strong>alias字段</strong></p><p>为依赖chart添加一个别名，会使用别名作为新依赖chart的名称。 需要使用其他名称访问chart时可以使用<code>alias</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  - name: subchart</span><br><span class="line">    repository: http://localhost:10191</span><br><span class="line">    version: 0.1.0</span><br><span class="line">    alias: new-subchart-1</span><br><span class="line">  - name: subchart</span><br><span class="line">    repository: http://localhost:10191</span><br><span class="line">    version: 0.1.0</span><br><span class="line">    alias: new-subchart-2</span><br><span class="line">  - name: subchart</span><br><span class="line">    repository: http://localhost:10191</span><br><span class="line">    version: 0.1.0</span><br></pre></td></tr></table></figure><p><br></p><p><strong>tags和condition字段</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">subchart1</span></span><br><span class="line"><span class="attr">    repository:</span> <span class="attr">http://localhost:10191</span></span><br><span class="line"><span class="attr">    version:</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">    condition:</span> <span class="string">subchart1.enabled,</span> <span class="string">global.subchart1.enabled</span></span><br><span class="line"><span class="attr">    tags:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">front-end</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">subchart1</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">subchart2</span></span><br><span class="line"><span class="attr">    repository:</span> <span class="attr">http://localhost:10191</span></span><br><span class="line"><span class="attr">    version:</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">    condition:</span> <span class="string">subchart2.enabled,global.subchart2.enabled</span></span><br><span class="line"><span class="attr">    tags:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">back-end</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">subchart2</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#values.yaml</span></span><br><span class="line"><span class="attr">subchart1:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="attr">  front-end:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  back-end:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 可以在CLI使用--set参数来设置标签和条件值</span><br><span class="line">helm install --set tags.front-end=true --set subchart2.enabled=false</span><br></pre></td></tr></table></figure><p><br></p><p><strong>通过依赖导入sub values</strong></p><p>在某些情况下，允许子chart的值作为公共默认传递到父chart中是值得的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parent's Chart.yaml file</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">subchart</span></span><br><span class="line"><span class="attr">    repository:</span> <span class="attr">http://localhost:10191</span></span><br><span class="line"><span class="attr">    version:</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">    import-values:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">data</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># child's values.yaml file</span></span><br><span class="line"></span><br><span class="line"><span class="attr">exports:</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    myint:</span> <span class="number">99</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>通过charts目录手动管理依赖</strong></p><p>如果对依赖进行更多控制，通过将有依赖关系的chart复制到<code>charts/</code>目录中来显式表达这些依赖关系。</p><p>要将依赖放入<code>charts/</code>目录，使用<code>helm pull</code>命令。</p><p><br><br><br></p><h3 id="Templates-and-Values"><a href="#Templates-and-Values" class="headerlink" title="Templates and Values"></a>Templates and Values</h3><p>Helm Chart模板是按照<a href="https://golang.org/pkg/text/template/" target="_blank" rel="noopener">Go模板语言</a>书写。让我想起了Django模板语言，Jinja2模板语言。</p><p>所有模板语言存放在chart的<code>templates/</code>目录下。当Helm渲染chart时，它会通过模板引擎遍历目录中的每个文件。</p><p>模板的Value通过两种方式提供：</p><ul><li>通过<code>values.yaml</code>文件提供，此文件包含了默认值。</li><li>用户可以提供一个包含value的yaml文件，在<code>helm install</code>时使用它。</li></ul><p>当用户提供自定义的value时，会覆盖<code>values.yaml</code>中的值。</p><p><br></p><p><strong>模板文件示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: deis-database</span><br><span class="line">  namespace: deis</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/managed-by: deis</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    app.kubernetes.io/name: deis-database</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app.kubernetes.io/name: deis-database</span><br><span class="line">    spec:</span><br><span class="line">      serviceAccount: deis-database</span><br><span class="line">      containers:</span><br><span class="line">        - name: deis-database</span><br><span class="line">          image: &#123;&#123; .Values.imageRegistry &#125;&#125;/postgres:&#123;&#123; .Values.dockerTag &#125;&#125;</span><br><span class="line">          imagePullPolicy: &#123;&#123; .Values.pullPolicy &#125;&#125;</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 5432</span><br><span class="line">          env:</span><br><span class="line">            - name: DATABASE_STORAGE</span><br><span class="line">              value: &#123;&#123; default &quot;minio&quot; .Values.storage &#125;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>预定义的Values</strong></p><p>以下值是预定义的，对每个模板都有效，并且可以被覆盖。和所有值一样，名称 区分大小写：</p><ul><li><code>Release.Name</code>: 版本名称(非chart的)</li><li><code>Release.Namespace</code>: 发布的chart版本的命名空间</li><li><code>Release.Service</code>: 组织版本的服务</li><li><code>Release.IsUpgrade</code>: 如果当前操作是升级或回滚，设置为true</li><li><code>Release.IsInstall</code>: 如果当前操作是安装，设置为true</li><li><code>Chart</code>: <code>Chart.yaml</code>的内容。因此，chart的版本可以从<code>Chart.Version</code>获得， 并且维护者在<code>Chart.Maintainers</code>里</li><li><code>Files</code>：chart中的包含了非特殊文件的类图对象</li><li><code>Capabilities</code>: 包含了Kubernetes版本信息的类图对象</li></ul><p><br></p><p><strong>范围</strong></p><p>Scope, Dependencies, and Values</p><p>Values文件可以声明顶级chart的值，以及<code>charts/</code>目录中包含的其他任意chart。</p><p><br></p><p><strong>全局Values</strong></p><p>Helm支持特殊的<code>global</code>值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  app:</span> <span class="string">MyWordPress</span></span><br></pre></td></tr></table></figure><p>这个值以<code>.Values.global.app</code>在所有chart中有效。</p><p><br></p><p><strong>架构文件</strong></p><p>有时候，chart容器可能想基于它们的values值定义一个结构，这可以在<code>values.schema.json</code>文件中定义一个架构实现。</p><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"$schema"</span>: <span class="string">"https://json-schema.org/draft-07/schema#"</span>,</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"image"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"Container Image"</span>,</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"repo"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"tag"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"object"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"name"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"Service name"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"port"</span>: &#123;</span><br><span class="line">      <span class="attr">"description"</span>: <span class="string">"Port"</span>,</span><br><span class="line">      <span class="attr">"minimum"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"integer"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"protocol"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"required"</span>: [</span><br><span class="line">    <span class="string">"protocol"</span>,</span><br><span class="line">    <span class="string">"port"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"Values"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"object"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个架构会应用values值并验证它。当执行以下任意命令时会进行验证： <code>helm install, helm upgrage, helm lint, helm template</code>。</p><p><br><br><br></p><h3 id="用户自定义资源"><a href="#用户自定义资源" class="headerlink" title="用户自定义资源"></a>用户自定义资源</h3><p>Custom Resource Definitions</p><p>k8s提供了一种声明k8s新类型对象的机制。使用CustomResourceDefinition（CRD），k8s开发者可以声明自定义资源类型。</p><p>Helm3中，CRD被视为一种特殊的对象。它们被安装在chart的其他部分之前，并受到一些限制。</p><p>CRD YAML文件应被放置在chart的<code>crds/</code>目录中。 多个CRD(用YAML的开始<code>---</code>和结束符<code>...</code>分隔)可以被放置在同一个文件中。Helm会尝试加载CRD目录中所有的文件到k8s。</p><p>当Helm安装新chart时，会上传CRD，暂停安装直到CRD可以被API服务使用，然后启动模板引擎， 渲染chart其他部分，并上传k8s。</p><p><br></p><p><strong>CRD的限制</strong></p><p>不像大部分k8s对象，CRD是全局安装的。因此Helm管理CRD时会采取非常谨慎的方式。 CRD受到以下限制：</p><ul><li>CRD从不重新安装。 如果Helm确定<code>crds/</code>目录中的CRD已经存在（忽略版本），Helm不会安装或升级。</li><li>CRD从不会在升级或回滚时安装。Helm只会在安装时创建CRD。</li><li>CRD从不会被删除。自动删除CRD会删除集群中所有命名空间中的所有CRD内容。因此Helm不会删除CRD。</li></ul><p>希望升级或删除CRD的操作员应该谨慎地手动执行此操作。</p><p><br><br><br></p><h3 id="管理chart"><a href="#管理chart" class="headerlink" title="管理chart"></a>管理chart</h3><p>Using Helm to Manage Charts</p><p><code>helm</code>工具有一些命令用来处理chart。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建新chart</span><br><span class="line">helm create mychart</span><br><span class="line"></span><br><span class="line"># 打包</span><br><span class="line">helm package mychart</span><br><span class="line"></span><br><span class="line"># 格式信息</span><br><span class="line">helm lint mychart</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>Chart Repositories</p><p>当<code>helm</code>用来管理本地chart目录时， 共享chart时，首选的机制就是使用chart仓库。</p><p>仓库的主要特征存在一个名为<code>index.yaml</code>的特殊文件，文件中包含仓库提供的包的完整列表， 以及允许检索和验证这些包的元数据。</p><p>在客户端，仓库使用<code>helm repo</code>命令管理。然而，Helm不提供上传chart到远程仓库的工具。 这是因为这样做会给执行服务器增加大量的必要条件，也就增加了设置仓库的障碍。</p><p><br><br><br></p><h3 id="Starter-Packs"><a href="#Starter-Packs" class="headerlink" title="Starter Packs"></a>Starter Packs</h3><p><code>helm create</code>命令可以附带一个可选的<code>--starter</code>选项指定一个starter chart。Starter就只是普通chart，但是被放置在<code>$XDG_DATA_HOME/helm/starters</code>。</p><p><br><br><br></p><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>Chart Hooks: <a href="https://helm.sh/docs/topics/charts_hooks/" target="_blank" rel="noopener">https://helm.sh/docs/topics/charts_hooks/</a></p><p>Helm提供了一个hook机制，使chart开发者在发行版(release)生命周期的特定点进行干预。你可以使用hooks做以下事情：</p><ul><li>安装过程中，在chart载入之前载入configmap或secret。</li><li>在安装一个新chart之前，执行一个作业(job)来备份数据库，然后执行第二个作业还原数据库。</li><li>在删除一个release之气，运行一个作业，在移除之前，来优雅地取出服务轮询。</li></ul><p>hooks工作像常规模板，但它们有特殊的注释(写在annotations下)，因此helm可以不同地使用它们。本章节，我们将介绍hooks的基本使用模式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">annotations:</span></span><br><span class="line">  <span class="string">"helm.sh/hook"</span><span class="string">:</span> <span class="string">post-install</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="可用的hooks"><a href="#可用的hooks" class="headerlink" title="可用的hooks"></a>可用的hooks</h3><div class="table-container"><table><thead><tr><th>Annotation</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td><code>pre-install</code></td><td>-</td><td>模板渲染之后执行，但在k8s创建任何资源之前</td></tr><tr><td><code>post-install</code></td><td>-</td><td>所有资源载入k8s后执行</td></tr><tr><td><code>pre-delete</code></td><td>-</td><td>在从k8s删除任意资源前，执行一个删除请求</td></tr><tr><td><code>post-delete</code></td><td>-</td><td>在所有release的资源被删除后，执行一个删除请求</td></tr><tr><td><code>pre-upgrade</code></td><td>-</td><td>在模板渲染后，执行一个升级请求，但在任意资源升级之前</td></tr><tr><td><code>post-upgrade</code></td><td>-</td><td>在所有资源都升级后，执行一个升级</td></tr><tr><td><code>pre-rollback</code></td><td>-</td><td>在模板渲染后，执行一个回滚请求，但在任意资源回滚前</td></tr><tr><td><code>post-rollback</code></td><td>-</td><td>在所有资源都被修改后，执行一个回滚请求</td></tr><tr><td><code>test</code></td><td>-</td><td>当heml test子命令调用时执行</td></tr></tbody></table></div><p><br><br><br></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Chart Tests: <a href="https://helm.sh/docs/topics/chart_tests/" target="_blank" rel="noopener">https://helm.sh/docs/topics/chart_tests/</a></p><p>chart包含许多k8s资源和协同工作的组件。作为包作者，你可能想编写一个测试，来验证包安装时是否如预期那样工作。</p><p>helm chart中的测试位于<code>templates/</code>目录下，是一个作业(job)定义，指定一个容器运行特定的命令。容器成功退出(exit 0)，被认为测试成功。作业定义必须包含<code>helm.sh/hook: test</code>的注释。</p><p>示例测试：</p><ul><li>验证<code>values.yaml</code>文件被正确配置</li><li>验证服务、负载均衡正常</li><li>等等</li></ul><p>可在helm中运行预定义测试，在release上使用<code>helm test &lt;RELEASE_NAME&gt;</code>命令。对于包的使用者，这是一个检测release of chart工作正常的方式。</p><p><br></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>Example Test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">helm repo add bitnami https://charts.bitnami.com/bitnami</span><br><span class="line">helm pull bitnami/wordpress --untar</span><br><span class="line"></span><br><span class="line">wordpress/</span><br><span class="line">  Chart.yaml</span><br><span class="line">  README.md</span><br><span class="line">  values.yaml</span><br><span class="line">  charts/</span><br><span class="line">  templates/</span><br><span class="line">  templates/tests/test-mariadb-connection.yaml</span><br></pre></td></tr></table></figure><p><code>templates/tests/test-mariadb-connection.yaml</code>的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">if</span> <span class="string">.Values.mariadb.enabled</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">"<span class="template-variable">&#123;&#123; .Release.Name &#125;&#125;</span>-credentials-test"</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">"helm.sh/hook"</span><span class="string">:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-credentials-test</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">&#123;&#123;</span> <span class="string">template</span> <span class="string">"wordpress.image"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">      imagePullPolicy:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.image.pullPolicy</span> <span class="string">| quote &#125;&#125;</span></span><br><span class="line"><span class="string">      <span class="template-variable">&#123;&#123;- if .Values.securityContext.enabled &#125;&#125;</span></span></span><br><span class="line"><span class="string"></span><span class="attr">      securityContext:</span></span><br><span class="line"><span class="attr">        runAsUser:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.securityContext.runAsUser</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">      env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">MARIADB_HOST</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">&#123;&#123;</span> <span class="string">template</span> <span class="string">"mariadb.fullname"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">MARIADB_PORT</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">"3306"</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">WORDPRESS_DATABASE_NAME</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">&#123;&#123;</span> <span class="string">default</span> <span class="string">""</span> <span class="string">.Values.mariadb.db.name</span> <span class="string">| quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">        - name:</span> <span class="string">WORDPRESS_DATABASE_USER</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">&#123;&#123;</span> <span class="string">default</span> <span class="string">""</span> <span class="string">.Values.mariadb.db.user</span> <span class="string">| quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">        - name:</span> <span class="string">WORDPRESS_DATABASE_PASSWORD</span></span><br><span class="line"><span class="attr">          valueFrom:</span></span><br><span class="line"><span class="attr">            secretKeyRef:</span></span><br><span class="line"><span class="attr">              name:</span> <span class="string">&#123;&#123;</span> <span class="string">template</span> <span class="string">"mariadb.fullname"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">              key:</span> <span class="string">mariadb-password</span></span><br><span class="line"><span class="attr">      command:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">/bin/bash</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">-ec</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mysql --host=$MARIADB_HOST --port=$MARIADB_PORT --user=$WORDPRESS_DATABASE_USER --password=$WORDPRESS_DATABASE_PASSWORD</span></span><br><span class="line"><span class="string"></span><span class="attr">  restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><p>运行测试:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm install quirky-walrus wordpress --namespace default</span><br><span class="line"></span><br><span class="line">helm <span class="built_in">test</span> quirky-walrus</span><br></pre></td></tr></table></figure><p><br></p><p><strong>注意：</strong></p><ul><li>你可以在<code>templates/</code>目录下定义许多测试</li><li>你可以嵌套你的测试<code>&lt;chart-name&gt;/templates/tests/</code></li><li>一个测试就是一个helm hook</li></ul><p><br><br><br></p><h2 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h2><p>Library Charts: <a href="https://helm.sh/docs/topics/library_charts/" target="_blank" rel="noopener">https://helm.sh/docs/topics/library_charts/</a></p><p>A library chart is a type of Helm chart，定义chart可通过helm模板在其它charts中共享。</p><p><br><br><br></p><h2 id="完整性校验"><a href="#完整性校验" class="headerlink" title="完整性校验"></a>完整性校验</h2><p>Helm Provenance and Integrity: <a href="https://helm.sh/docs/topics/provenance/" target="_blank" rel="noopener">https://helm.sh/docs/topics/provenance/</a></p><p>helm有来源工具，帮助chart user验证包的来源和完整性。使用基于行业标准的PIK, GnuPG等备受推崇的包管理器，Helm 可以生成和验证签名文件。</p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 生成</span><br><span class="line">helm package --sign ...</span><br><span class="line">helm package --sign --key &apos;John Smith&apos; --keyring path/to/keyring.secret mychart</span><br><span class="line"></span><br><span class="line"># 校验</span><br><span class="line">helm install --verify</span><br><span class="line">helm verify mychart-0.1.0.tgz</span><br><span class="line">helm install --generate-name --verify mychart-0.1.0.tgz</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="仓库-1"><a href="#仓库-1" class="headerlink" title="仓库"></a>仓库</h2><p>Chart Repository: <a href="https://helm.sh/docs/topics/chart_repository/" target="_blank" rel="noopener">https://helm.sh/docs/topics/chart_repository/</a></p><p>官方的chart repo由<a href="https://github.com/helm/charts" target="_blank" rel="noopener">Kubernetes Charts</a>项目维护。欢迎各位参与。Helm也使得创建和运行自己的chart repo变得很容易。</p><p><br></p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>Create a chart repository: <a href="https://helm.sh/docs/topics/chart_repository/" target="_blank" rel="noopener">https://helm.sh/docs/topics/chart_repository/</a></p><p>一个chart repo是一个HTTP服务器，它容纳了一个<code>index.yaml</code>文件和一些包。当你准备好分享你的charts，方法是将它们上传到一个chart repository。你可以使用GCS, S3, GitHub Pages等来创建你自己的web服务器。</p><p><br><br><br></p><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>Registries: <a href="https://helm.sh/docs/topics/registries/" target="_blank" rel="noopener">https://helm.sh/docs/topics/registries/</a></p><p>Helm 3 支持OCI用于包分发。 Chart包可以通过基于OCI的注册中心存储和分发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 激活对OCI的支持</span><br><span class="line">export HELM_EXPERIMENTAL_OCI=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 运行一个注册中心</span><br><span class="line">docker run -dp 5000:5000 --restart=always --name registry registry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 认证</span><br><span class="line">htpasswd -cB -b auth.htpasswd myuser mypass</span><br><span class="line">docker run -dp 5000:5000 --restart=always --name registry \</span><br><span class="line">  -v $(pwd)/auth.htpasswd:/etc/docker/registry/auth.htpasswd \</span><br><span class="line">  -e REGISTRY_AUTH=&quot;&#123;htpasswd: &#123;realm: localhost, path: /etc/docker/registry/auth.htpasswd&#125;&#125;&quot; \</span><br><span class="line">  registry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 登录</span><br><span class="line">helm registry login -u myuser localhost:5000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 注销</span><br><span class="line">helm registry logout localhost:5000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 保存</span><br><span class="line">helm chart save mychart/ localhost:5000/myrepo/mychart:2.7.0</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line">helm chart list</span><br><span class="line"></span><br><span class="line"># 导出</span><br><span class="line">helm chart export localhost:5000/myrepo/mychart:2.7.0</span><br><span class="line"></span><br><span class="line"># 推送到远程</span><br><span class="line">helm chart push localhost:5000/myrepo/mychart:2.7.0</span><br><span class="line"></span><br><span class="line"># 从缓存中移除</span><br><span class="line">helm chart remove localhost:5000/myrepo/mychart:2.7.0</span><br><span class="line"></span><br><span class="line"># 从远程拉取</span><br><span class="line">helm chart pull localhost:5000/myrepo/mychart:2.7.0</span><br></pre></td></tr></table></figure><p><br></p><p>使用上述命令存储的chart会被缓存到文件系统中。OCI 镜像设计规范 严格遵守文件系统布局的。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tree ~/Library/Caches/helm/</span><br><span class="line">└── registry</span><br><span class="line">    ├── cache</span><br><span class="line">    │   ├── blobs</span><br><span class="line">    │   │   └── sha256</span><br><span class="line">    │   │       ├── 1b251d38cfe948dfc0a5745b7af5ca574ecb61e52aed10b19039db39af6e1617</span><br><span class="line">    │   │       ├── 31fb454efb3c69fafe53672598006790122269a1b3b458607dbe106aba7059ef</span><br><span class="line">    │   │       └── 8ec7c0f2f6860037c19b54c3cfbab48d9b4b21b485a93d87b64690fdb68c2111</span><br><span class="line">    │   ├── index.json</span><br><span class="line">    │   ├── ingest</span><br><span class="line">    │   └── oci-layout</span><br><span class="line">    └── config.json</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Helm Architecture: <a href="https://helm.sh/docs/topics/architecture/" target="_blank" rel="noopener">https://helm.sh/docs/topics/architecture/</a></p><p>介绍Helm在高级别的架构。</p><p><br></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>The Purpose of Helm</p><p>Helm是管理称为chart的k8s包的工具。Helm可以做以下事情：</p><ul><li>从头开始创建一个新的charts</li><li>packages charts为归档(tgz) chart文件</li><li>与chart repo交互，并存储在那</li><li>安装和卸载charts到k8s集群</li><li>管理已安装的charts的发行版</li></ul><p>对于Helm，有三个重要的概念：</p><ul><li>chart是创建一个k8s应用实例所需的信息束</li><li>config包含配置信息，可以合并到package chart来创建一个可发行的对象</li><li>release是一个运行的chart实例，包含特定的配置</li></ul><p><br><br><br></p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>Components</p><p>Helm被实现为两个不同部分来执行：</p><p>Helm CLI客户端，负责以下事情：</p><ul><li>本地chart开发</li><li>管理repo</li><li>管理release</li><li>与Helm Library接口<ul><li>发送chart安装</li><li>请求升级或卸载releases</li></ul></li></ul><p>Helm Library提供了执行所有helm操作的逻辑。与k8s API接口交互，并提供以下功能：</p><ul><li>组合chart和配置来构建一个release</li><li>安装chart到k8s，并提供release对象</li><li>通过与k8s交互，升级和卸载chart</li></ul><p><br><br><br></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Implementation</p><p>Helm client和library由go编写。library使用k8s client与k8s集群通信。目前，library使用<code>REST+JSON</code>。它存储信息在k8s内的secrets里，不需要自己的数据库。配置文件以YAML编写。</p><p><br><br><br></p><h2 id="高级技术"><a href="#高级技术" class="headerlink" title="高级技术"></a>高级技术</h2><p>Advanced Helm Techniques: <a href="https://helm.sh/docs/topics/advanced/" target="_blank" rel="noopener">https://helm.sh/docs/topics/advanced/</a></p><p><br></p><h3 id="后置渲染"><a href="#后置渲染" class="headerlink" title="后置渲染"></a>后置渲染</h3><p>Post Rendering</p><p><br><br><br></p><h3 id="GO-SDK"><a href="#GO-SDK" class="headerlink" title="GO SDK"></a>GO SDK</h3><p><br><br><br></p><h3 id="后端存储"><a href="#后端存储" class="headerlink" title="后端存储"></a>后端存储</h3><p>Storage backends</p><p><br><br><br></p><h2 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h2><p>Role-based Access Control: <a href="https://helm.sh/docs/topics/rbac/" target="_blank" rel="noopener">https://helm.sh/docs/topics/rbac/</a></p><p>k8s rbac: <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/access-authn-authz/rbac/</a></p><p>介绍Helm如何与k8s RBAC进行交互。</p><p>在k8s中，授权角色给特定用户或应用的服务账号(service account)，以确保应用程序的操作在特定范围内。从k8s v1.6开始，RBAC默认启用。</p><p>使用RBAC，你可以：</p><ul><li>授权特权操作给管理员</li><li>限制用户在特定命名空间/集群范围创建资源的能力</li><li>限制用户在特定命名空间/集群范围内查看资源的能力</li></ul><p><br></p><h3 id="管理用户账户"><a href="#管理用户账户" class="headerlink" title="管理用户账户"></a>管理用户账户</h3><p>Managing user accounts</p><p>所有的k8s集群有两种类型的用户：</p><ul><li>service accounts managed by Kubernetes</li><li>normal users</li></ul><p>普通用户假定由外部进行管理，独立的服务。管理员分发私钥，用户存储密码，甚至是用户名密码列表这样的文件。在这方面，k8s不具有代表普通用户账户的对象。普通用户无法通过API调用被添加到集群。</p><p>相比之下，服务账号是由k8s API管理的用户。它们被绑定到特定的命名空间，通过API server自动创建，或通过API调用手动创建。服务账号绑定在一组凭据里，存储为secret，它被挂载到pod，允许集群内进程与k8s API进行交谈。</p><p>API请求被绑定到任何一个用户（普通用户、服务账号），或者被视为匿名请求。这意味着集群内或集群外的每一个进程，从工作站上输入<code>kubectl</code>的人类用户，到节点上的kubelets，到控制面板的成员，在进行请求API server时必须进行认证，或被视为匿名用户。</p><p><br><br><br></p><h3 id="角色、集群角色、角色绑定、集群角色绑定"><a href="#角色、集群角色、角色绑定、集群角色绑定" class="headerlink" title="角色、集群角色、角色绑定、集群角色绑定"></a>角色、集群角色、角色绑定、集群角色绑定</h3><p>Roles, ClusterRoles, RoleBindings, and ClusterRoleBindings</p><p>在k8s中，用户账户和服务账户只能够根据授权访问来查看和修改资源。这种授权是通过使用<strong>角色(Roles)</strong>和<strong>角色绑定(RoleBindings)</strong>。角色和角色绑定被绑定到特定的命名空间，它通过角色提供授权，授予用户在此命名空间内查看或修改资源的能力。</p><p>在集群范围内，这些被称为<strong>集群角色(ClusterRoles)</strong>和<strong>集群角色绑定(ClusterRoleBindings)</strong>。授权用户集群角色，允许它们访问和修改整个集群的资源。这也需要查看和修改集群范围(命名空间，资源配额，节点)的资源。</p><p>集群角色可通过角色绑定的引用来绑定到特定的命名空间。<code>admin</code>, <code>edit</code>, <code>view</code>是最常使用的默认集群角色。</p><p>k8s有一些默认的集群角色可用，它们的本意是面向用户的角色。它们包含超级角色(<code>cluster-admin</code>)，和细粒度访问的角色(<code>admin</code>, <code>edit</code>, <code>view</code>)。</p><p><br></p><div class="table-container"><table><thead><tr><th>Default ClusterRole</th><th>Default ClusterRoleBinding</th><th>描述</th></tr></thead><tbody><tr><td>cluster-admin</td><td>system:masters group</td><td>允许超级用户访问对任意资源执行任意动作。</td></tr><tr><td>admin</td><td>None</td><td>允许管理员访问，在命名空间内使用角色绑定来授权。如读写命名空间内的大部分资源，包括在命名空间内创建角色和角色绑定的能力。但不允许对资源配额或命名空间进行写操作。</td></tr><tr><td>edit</td><td>None</td><td>允许在命名空间内读取大多数对象的权限，不允许查看或修改角色和角色绑定</td></tr><tr><td>view</td><td>None</td><td>允许在命名空间内查看大多数对象的权限。不允许查看角色和角色绑定。不允许查看secrets。</td></tr></tbody></table></div><p><br><br><br></p><h3 id="限制用户账户使用RBAC访问"><a href="#限制用户账户使用RBAC访问" class="headerlink" title="限制用户账户使用RBAC访问"></a>限制用户账户使用RBAC访问</h3><p>Restricting a user account access using RBAC</p><p>现在让我们了解基于角色的访问控制的基础知识，让我们讨论管理员如何限制用户的访问范围。</p><p><br></p><p><strong>示例：授予用户命名空间范围的读写权限</strong></p><p>Grant a user read/write access to a particular namespace</p><p>要限制用户对特定命名空间的读写权限，可以使用<code>edit</code>或<code>admin</code>角色。</p><p>此外，你还可以使用<code>cluster-admin</code>来创建一个角色绑定。授予在命名空间范围内的<code>cluster-admin</code>来提供在此命名空间内完整控制资源的权限，包含命名空间自身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建ns</span><br><span class="line">kubectl create namespace foo</span><br><span class="line"></span><br><span class="line">#创建RoleBinding</span><br><span class="line">kubectl create rolebinding sam-edit</span><br><span class="line">    --clusterrole edit \</span><br><span class="line">    --user sam \</span><br><span class="line">    --namespace foo</span><br></pre></td></tr></table></figure><p><br></p><p><strong>示例：授予用户集群范围的读写权限</strong></p><p>Example: Grant a user read/write access at the cluster scope</p><p>如果用户希望安装chart，在集群范围内安装集群资源（ns, roles, crd…），它们将需要集群范围的写权限。要这样做，授予用户<code>admin</code>或<code>cluster-admin</code>角色权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding sam-view</span><br><span class="line">    --clusterrole view \</span><br><span class="line">    --user sam</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl create clusterrolebinding sam-secret-reader</span><br><span class="line">    --clusterrole secret-reader \</span><br><span class="line">    --user sam</span><br></pre></td></tr></table></figure><p><br></p><p><strong>示例：授予用户命名空间范围的只读权限</strong></p><p>Example: Grant a user read-only access to a particular namespace</p><p>你可能注意到了，没有查看secret的集群角色。<code>view</code>集群角色没有授予用户访问secret的权限。然而，Helm默认将release metadata存储为secret。</p><p>为了使用户运行<code>helm list</code>，它需要读取这些secrets。为此，我们将创建一个特殊的<code>secret-reader</code>集群角色。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cluster-role-secret-reader.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">secret-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="attr">- apiGroups:</span> <span class="string">[""]</span></span><br><span class="line"><span class="attr">  resources:</span> <span class="string">["secrets"]</span></span><br><span class="line"><span class="attr">  verbs:</span> <span class="string">["get",</span> <span class="string">"watch"</span><span class="string">,</span> <span class="string">"list"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f clusterrole-secret-reader.yaml</span><br><span class="line"></span><br><span class="line">kubectl create namespace foo</span><br><span class="line"></span><br><span class="line">kubectl create rolebinding sam-view</span><br><span class="line">    --clusterrole view \</span><br><span class="line">    --user sam \</span><br><span class="line">    --namespace foo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl create rolebinding sam-secret-reader</span><br><span class="line">    --clusterrole secret-reader \</span><br><span class="line">    --user sam \</span><br><span class="line">    --namespace foo</span><br></pre></td></tr></table></figure><p><br></p><p><strong>示例：授予用户集群范围的只读权限</strong></p><p>Example: Grant a user read-only access at the cluster scope</p><p>如果用户想运行<code>helm l ist --all-namespaces</code>命令，API需要用户拥有集群范围内的读权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding sam-view</span><br><span class="line">    --clusterrole view \</span><br><span class="line">    --user sam</span><br><span class="line"></span><br><span class="line">kubectl create clusterrolebinding sam-secret-reader</span><br><span class="line">    --clusterrole secret-reader \</span><br><span class="line">    --user sam</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>The Helm Plugins Guide: <a href="https://helm.sh/docs/topics/plugins/" target="_blank" rel="noopener">https://helm.sh/docs/topics/plugins/</a></p><p>Helm plugin是一个可通过helm CLI访问的工具，但不是内置的helm基础代码的一部分。</p><p><br><br><br></p><h2 id="V2迁移到V3"><a href="#V2迁移到V3" class="headerlink" title="V2迁移到V3"></a>V2迁移到V3</h2><p>Migrating Helm v2 to v3: <a href="https://helm.sh/docs/topics/v2_v3_migration/" target="_blank" rel="noopener">https://helm.sh/docs/topics/v2_v3_migration/</a></p><p><br><br><br></p><h2 id="弃用的k8s-api"><a href="#弃用的k8s-api" class="headerlink" title="弃用的k8s api"></a>弃用的k8s api</h2><p>Deprecated Kubernetes APIs: <a href="https://helm.sh/docs/topics/kubernetes_apis/" target="_blank" rel="noopener">https://helm.sh/docs/topics/kubernetes_apis/</a></p><p><br><br><br></p><h2 id="版本支持"><a href="#版本支持" class="headerlink" title="版本支持"></a>版本支持</h2><p>Helm Version Support Policy: <a href="https://helm.sh/docs/topics/version_skew/" target="_blank" rel="noopener">https://helm.sh/docs/topics/version_skew/</a></p><p><br><br><br></p><h2 id="SQL存储后端的权限管理"><a href="#SQL存储后端的权限管理" class="headerlink" title="SQL存储后端的权限管理"></a>SQL存储后端的权限管理</h2><p>Permissions management for SQL storage backend: <a href="https://helm.sh/docs/topics/permissions_sql_storage_backend/" target="_blank" rel="noopener">https://helm.sh/docs/topics/permissions_sql_storage_backend/</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>The Chart Best Practices Guide: <a href="https://helm.sh/docs/chart_best_practices/" target="_blank" rel="noopener">https://helm.sh/docs/chart_best_practices/</a></p><p>涵盖了Helm团队对创建chart的最佳做法。它侧重于chart应该如何构造。主要关注那些可能会公开部署的charts的最佳实践。</p><p><br></p><h2 id="一般约定"><a href="#一般约定" class="headerlink" title="一般约定"></a>一般约定</h2><p>General Conventions: <a href="https://helm.sh/docs/chart_best_practices/conventions/" target="_blank" rel="noopener">https://helm.sh/docs/chart_best_practices/conventions/</a></p><p><br></p><h3 id="chart名称"><a href="#chart名称" class="headerlink" title="chart名称"></a>chart名称</h3><p>Chart Names</p><p>chart名称必须是小写字母和数字，可用<code>-</code>隔开。</p><p>chart目录必须与chart名称相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 示例</span><br><span class="line">drupal</span><br><span class="line">nginx-lego</span><br><span class="line">aws-cluster-autoscaler</span><br><span class="line"></span><br><span class="line">nginx-lego</span><br><span class="line">nginx-lego/</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>Version Numbers</p><p>只要有可能，Helm使用SemVer2来表示版本号。请注意，Docker image tag并不一定遵循SemVer，注意。</p><p><br><br><br></p><h3 id="格式化YAML"><a href="#格式化YAML" class="headerlink" title="格式化YAML"></a>格式化YAML</h3><p>Formatting YAML</p><p>YAML应该使用两个空格（别使用tab）。</p><p><br><br><br></p><h3 id="词"><a href="#词" class="headerlink" title="词"></a>词</h3><p>Usage of the Words Helm and Chart</p><p>Helm词的一些约定：</p><ul><li>Helm指作为一个整体的项目</li><li><code>helm</code>客户端CLI</li><li><code>chart</code>不需要大写，它不是专有名词</li><li><code>Chart.yaml</code>需要大写，因为该文件名是大小写敏感的</li></ul><p><br><br><br></p><h2 id="值"><a href="#值" class="headerlink" title="值"></a>值</h2><p>Values: <a href="https://helm.sh/docs/chart_best_practices/values/" target="_blank" rel="noopener">https://helm.sh/docs/chart_best_practices/values/</a></p><p>提供给你如何组织和设计chart的<code>values.yaml</code>文件，并使用你的值。</p><p><br></p><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><p>Naming Conventions</p><p>变量名必须小写字母开头，使用驼峰分开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chicken: true</span><br><span class="line">chickenNoodleSoup: true</span><br></pre></td></tr></table></figure><p>请注意，所有Helm内置变量以大写字母开头，用户可以轻松区分开:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.Release.Name</span><br><span class="line">.Capabilities.KubeVersion</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="嵌套值"><a href="#嵌套值" class="headerlink" title="嵌套值"></a>嵌套值</h3><p>YAML是一种灵活的格式，值可以被深度嵌套。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  name: nginx</span><br><span class="line">  port: 80</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; if .Values.server &#125;&#125;</span><br><span class="line">  &#123;&#123; default &quot;none&quot; .Values.server.name &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使类型清晰"><a href="#使类型清晰" class="headerlink" title="使类型清晰"></a>使类型清晰</h3><p>Make Types Clear</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># YAM的类型强制规则有时是反直觉的。例如一下两者是不同的</span></span><br><span class="line"><span class="attr">foo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">foo:</span> <span class="string">"false"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 避免类型转化错误的最简单的方法是要明确字符串和隐含的一切。使用引号引用字符串</span></span><br><span class="line"><span class="comment"># 要避免整数转换错误，将整数存储为字符串，使用以下方法来获取整数值</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">int</span> <span class="string">$value</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在大多数情况下，显式类型标签被尊重。如以下1234被当作字符串</span></span><br><span class="line"><span class="attr">foo:</span> <span class="type">!!string</span> <span class="number">1234</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="考虑用户如何使用你的值"><a href="#考虑用户如何使用你的值" class="headerlink" title="考虑用户如何使用你的值"></a>考虑用户如何使用你的值</h3><p>Consider How Users Will Use Your Values</p><p>值有三个来源：</p><ul><li><code>values.yaml</code>文件</li><li><code>helm install -f</code>或<code>helm upgrade -f</code>时指定的文件里</li><li><code>--set</code>或<code>--set-string</code>选项指定</li></ul><p>当设计值的组织结构时，用户是希望可通过<code>-f</code>或<code>--set</code>选项来覆盖它们。YAML建议写成映射(mapping)，便于替换<code>--set servers.foo.port=80</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">servers:</span><br><span class="line">  foo:</span><br><span class="line">    port: 80</span><br><span class="line">  bar:</span><br><span class="line">    port: 81</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="values-yaml"><a href="#values-yaml" class="headerlink" title="values.yaml"></a>values.yaml</h3><p>每个在<code>values.yaml</code>中定义的属性应该被记录(documented)。文档字符串应该用它描述的属性的名称开始，然后给出至少一个单句描述。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># serverHost is the host name for the webserver</span></span><br><span class="line"><span class="attr">serverHost:</span> <span class="string">example</span></span><br><span class="line"><span class="comment"># serverPort is the HTTP listener port for the webserver</span></span><br><span class="line"><span class="attr">serverPort:</span> <span class="number">9191</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>Templates: <a href="https://helm.sh/docs/chart_best_practices/templates/" target="_blank" rel="noopener">https://helm.sh/docs/chart_best_practices/templates/</a></p><p><br></p><h3 id="templates目录架构"><a href="#templates目录架构" class="headerlink" title="templates目录架构"></a>templates目录架构</h3><p>Structure of <code>templates/</code></p><p><code>templates/</code>目录应该是如下结构：</p><ul><li>模板文件是<code>.yaml</code>扩展的YAML输出。<code>.tpl</code>扩展可用于未经格式化的模板文件</li><li>模板文件名应使用虚线(example-configmap.yaml)，而不是驼峰</li><li>每个资源定义应该有自己的模板文件</li><li>模板文件应放映资源类型（如<code>foo-pod.yaml</code>, <code>bar-svc.yaml</code>）</li></ul><p><br><br><br></p><h3 id="定义的模板的名称"><a href="#定义的模板的名称" class="headerlink" title="定义的模板的名称"></a>定义的模板的名称</h3><p>Names of Defined Templates</p><p>定义的模板(模板文件内的<code></code>)是全局访问的。这意味着，chart和它的subchart可以访问所有<code></code>创建的模板。这样我想起了Pythond的模板语言（Django模板语言，Jinja2等等）。</p><p>出于此原因，所有定义的模板名称都应该命名空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- define &quot;nginx.fullname&quot; &#125;&#125;</span><br><span class="line">&#123;&#123;/* ... */&#125;&#125;</span><br><span class="line">&#123;&#123; end -&#125;&#125;</span><br></pre></td></tr></table></figure><p>It is highly recommended that new charts are created via helm create command as the template names are automatically defined as per this best practice.</p><p><br><br><br></p><h3 id="格式化模板"><a href="#格式化模板" class="headerlink" title="格式化模板"></a>格式化模板</h3><p>Formatting Templates</p><p>模板应该使用两个空格，而不是tab。花括号前后应该有空格。有适当的空格和缩进。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; .foo &#125;&#125;</span><br><span class="line">&#123;&#123; print &quot;foo&quot; &#125;&#125;</span><br><span class="line">&#123;&#123;- print &quot;bar&quot; -&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; if $foo -&#125;&#125;</span><br><span class="line">  &#123;&#123;- with .Bar &#125;&#125;Hello&#123;&#123; end -&#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="生成模板中的空格"><a href="#生成模板中的空格" class="headerlink" title="生成模板中的空格"></a>生成模板中的空格</h3><p>Whitespace in Generated Templates</p><p>优选的是，保持在生成的模板中的空格数量降到最低。特别是，许多空行不应出现彼此相邻。但偶尔空行还是可以的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is best</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">example</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    first:</span> <span class="string">first</span></span><br><span class="line"><span class="attr">    second:</span> <span class="string">second</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is okay</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">example</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    first:</span> <span class="string">first</span></span><br><span class="line"><span class="attr">    second:</span> <span class="string">second</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Comments (YAML Comments vs Template Comments)</p><p>YAML文件注释和模板注释。当一个模板记录功能时，应该使用模板注释。当Helm用户通过查看注释调试时，在模板内应该使用YANML注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># yaml 注释</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;- /*</span><br><span class="line">模板注释</span><br><span class="line">*/ -&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;- /*</span><br><span class="line">mychart.shortname provides a 6 char truncated version of the release name.</span><br><span class="line">*/ -&#125;&#125;</span><br><span class="line">&#123;&#123; define &quot;mychart.shortname&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123; .Release.Name | trunc 6 &#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># This may cause problems if the value is more than 100Gi</span><br><span class="line">memory: &#123;&#123; .Values.maxMem | quote &#125;&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="在模板和模板输出中使用JSON"><a href="#在模板和模板输出中使用JSON" class="headerlink" title="在模板和模板输出中使用JSON"></a>在模板和模板输出中使用JSON</h3><p>Use of JSON in Templates and Template Output</p><p>YAML是JSON的超集(superset)。在一些情况下，使用JSON语法可比其它YAML表示更具有可读性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 列表</span><br><span class="line"></span><br><span class="line"># yaml</span><br><span class="line">arguments:</span><br><span class="line">  - &quot;--dirname&quot;</span><br><span class="line">  - &quot;/foo&quot;</span><br><span class="line"></span><br><span class="line"># json</span><br><span class="line">arguments: [&quot;--dirname&quot;, &quot;/foo&quot;]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h2><p>Dependencies: <a href="https://helm.sh/docs/chart_best_practices/dependencies/" target="_blank" rel="noopener">https://helm.sh/docs/chart_best_practices/dependencies/</a></p><p>介绍<code>Chart.yaml</code>内声明的<code>dependencies</code>的最佳实践。</p><p><br></p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>Versions</p><p>如果可能的化，使用版本范围，而不是某个确切的版本。建议使用补丁级别(patch-level)版本匹配:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># &gt;= 1.2.3, &lt; 1.3.0</span><br><span class="line">version: ~1.2.3</span><br></pre></td></tr></table></figure><p>repo ruls，如果可能，使用HTTPS。文件URL(<code>file://...</code>)被认为是一个特殊，对由一个固定部署的流水线charts。</p><p><br><br><br></p><h3 id="条件和标记"><a href="#条件和标记" class="headerlink" title="条件和标记"></a>条件和标记</h3><p>Conditions and Tags</p><p>条件或标记应被添加到任何依赖（可选的）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 条件的推荐格式</span><br><span class="line">condition: somechart.enabled</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 标记</span><br><span class="line">tags:</span><br><span class="line">  - webaccelerator</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="标签和注释"><a href="#标签和注释" class="headerlink" title="标签和注释"></a>标签和注释</h2><p>Labels and Annotations: <a href="https://helm.sh/docs/chart_best_practices/labels/" target="_blank" rel="noopener">https://helm.sh/docs/chart_best_practices/labels/</a></p><p>讨论chart中使用标签和注释的最佳实践。</p><p><br></p><h3 id="标签还是注释"><a href="#标签还是注释" class="headerlink" title="标签还是注释"></a>标签还是注释</h3><p>Is it a Label or an Annotation?</p><p>以下条件的元数据项应该为标签(label)：</p><ul><li>它利用k8s来标识此资源</li><li>暴露给查询系统的目的是有用的</li></ul><p>如果元数据的条目不用于查询，它应该设置为注释。Helm hooks总是注释。</p><p><br><br><br></p><h3 id="标准的标签"><a href="#标准的标签" class="headerlink" title="标准的标签"></a>标准的标签</h3><p>Standard Labels</p><p>下表定义了Helm chart常用的标签。Helm自身从未要求特定的标签存在。REC的标签是建议的，并应该放置到全局一致性的chart。OPT的标签是可选的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">名称    状态   描述</span><br><span class="line">app.kubernetes.io/name  REC    这应该是app名称。通常使用&#123;&#123; template &quot;name&quot; . &#125;&#125; 这由许多k8s manifests使用，不是Helm特定的</span><br><span class="line">helm.sh/chart           REC  chart名称和版本: &#123;&#123; .Chart.Name &#125;&#125;-&#123;&#123; .Chart.Version &#125;&#125;</span><br><span class="line">app.kubernetes.io/managed-by    REC    这应该始终设置为&#123;&#123; .Release.Service &#125;&#125;</span><br><span class="line">app.kubernetes.io/instance    REC    这应该为&#123;&#123; .Release.Name &#125;&#125;，有助于在同意应用不同实例之间进行区分</span><br><span class="line">app.kubernetes.io/version    OPT   应用的版本设置为&#123;&#123; .Chart.AppVersion &#125;&#125;</span><br><span class="line">app.kubernetes.io/component    OPT   This is a common label for marking the different roles that pieces may play in an application</span><br><span class="line">|app.kubernetes.io/part-of    OPT   当多个charts或软件片一起使用来做一个应用</span><br></pre></td></tr></table></figure><p>可在k8s 文档中，带有<code>app.kubernetes.io</code>前缀的文档中查看更多信息。</p><p><br><br><br></p><h2 id="Pods和PodTemplates"><a href="#Pods和PodTemplates" class="headerlink" title="Pods和PodTemplates"></a>Pods和PodTemplates</h2><p>Pods and PodTemplates: <a href="https://helm.sh/docs/chart_best_practices/pods/" target="_blank" rel="noopener">https://helm.sh/docs/chart_best_practices/pods/</a></p><p>以下资源列表使用PodTemplate：</p><ul><li>Deployment</li><li>ReplicationController</li><li>ReplicaSet</li><li>DaemonSet</li><li>StatefulSet</li></ul><p><br></p><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Images</p><p>容器镜像应该使用确定的标记或镜像的SHA。但不应该使用<code>latest</code>, <code>head</code>, <code>canary</code>这样的标记。</p><p>镜像可以在<code>values.yaml</code>文件中定义，使其很容易替换镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: &#123;&#123; .Values.redisImage | quote &#125;&#125;</span><br></pre></td></tr></table></figure><p>镜像和标记可在<code>values.yaml</code>中被定义为分开的两个字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: &quot;&#123;&#123; .Values.redisImage &#125;&#125;:&#123;&#123; .Values.redisTag &#125;&#125;&quot;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="镜像拉取策略"><a href="#镜像拉取策略" class="headerlink" title="镜像拉取策略"></a>镜像拉取策略</h3><p>ImagePullPolicy</p><p><code>helm create</code>默认在<code>deployment.yaml</code>中设置<code>imagePullPolicy</code>为<code>IfNotPresent</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">imagePullPolicy:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.image.pullPolicy</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># values.yaml</span></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line"><span class="attr">  pullPolicy:</span> <span class="string">IfNotPresent</span></span><br></pre></td></tr></table></figure><p>同样，如果未设置<code>impagePullPolicy</code>，k8s默认会将其设置为<code>IfNotPresent</code>。如果想要修改此值，只需在<code>values.yaml</code>文件中更新此值。</p><p><br><br><br></p><h3 id="PodTemplate应该声明选择器"><a href="#PodTemplate应该声明选择器" class="headerlink" title="PodTemplate应该声明选择器"></a>PodTemplate应该声明选择器</h3><p>PodTemplates Should Declare Selectors</p><p>所有的PodTemplate部分应该指定一个选择器。示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">  matchLabels:</span></span><br><span class="line">      <span class="string">app.kubernetes.io/name:</span> <span class="string">MyName</span></span><br><span class="line"><span class="attr">template:</span></span><br><span class="line"><span class="attr">  metadata:</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line">      <span class="string">app.kubernetes.io/name:</span> <span class="string">MyName</span></span><br></pre></td></tr></table></figure><p>这是一个很好的做法，因为它使set和pod相关联。</p><p>但是，这对于像Deployment这样的集更为重要。没有这一点，整个标签集(set of labels)用于选择匹配pod，如果你使用的标签发生改变（如版本或日期），这将打破匹配。</p><p><br><br><br></p><h2 id="自定义资源的定义"><a href="#自定义资源的定义" class="headerlink" title="自定义资源的定义"></a>自定义资源的定义</h2><p>Custom Resource Definitions</p><p>当使用自定义资源定义(CRDs)，区分两种不同的片是很重要的：</p><ul><li>声明一个CRD(<code>kind: CustomResourceDefinition</code>)</li><li>然后资源使用CRD</li></ul><p><br></p><h3 id="使用资源前安装CRD声明"><a href="#使用资源前安装CRD声明" class="headerlink" title="使用资源前安装CRD声明"></a>使用资源前安装CRD声明</h3><p>Install a CRD Declaration Before Using the Resource</p><p>Helm是尽可能优化地载入更多的资源到k8s中。按照设计，k8s可以采取一整套清单(manifests)，并带它们所有上线（这就是所谓的和解循环(reconciliation loop))）。</p><p>但是，CRDs有一些不同。对于CRD，在任意CRDs类型资源被使用之前，必须先注册声明。注册过程有时需要几秒。</p><p><br></p><p><strong>方法1：让helm为你做此事</strong></p><p>Method 1: Let helm Do It For You</p><p>随着Helm3的到来，出于更简单的方法，Helm移除了旧的<code>crd-install</code> hooks。这在是一个称为<code>crds</code>的新目录，在你创建的chart的此目录下保存你的CRDs。这些CRDs没有模板，但会在chart运行<code>helm install</code>时默认安装。如果CRD已存在，它会被跳过。你也可以通过传递<code>--skip-crds</code>选项来跳过CRD的安装。</p><p><strong>一些注意事项:</strong></p><p>目前不支持使用Helm更新或删除CRDs。这是一个经过反复讨论的明确的决定，由于存在非故意丢失数据的危险。此外，目前社区如何处理CRDs和它的生命周期没有共识，由于这种演变，Helm将添加对这些用例的支持。</p><p><code>helm install</code>和<code>helm upgrade</code>的<code>--dry-run</code>选项暂不支持CRDs。Dry Run的目的是去验证chart的输出将实际地工作，如果发送到服务器。但CRDs可通过服务器行为的修改。Helm无法在dry run上安装CRD，因此发现客户端将不知道自定义资源(CR)，并验证将失败。你可以可选地移动CRDs到它们自己的chart，或使用<code>helm template</code>来代替。</p><p>围绕CRD支持的另一个重要的考虑点是如何处理模板的渲染(rendering of templates)。一个在Helm2中使用<code>crd-install</code>方法的明显的缺点是不能正确验证chart，由于改变API可用性（一个CRD被实际添加到另一个可用API到k8s集群）。如果一个chart安装了CRD，<code>helm</code>不再有一组API版本的有效集。这也是在移除从CRDs的模板支持的原因。随着安装CRD的新的<code>crds</code>方法，我们现在确保<code>helm</code>有关于当前集群状态的完整信息。</p><p><br></p><p><strong>方法2：独立chart</strong></p><p>Separate Charts</p><p>另一种方法是，把CRD定义在一个chart中，然后把所有资源使用的该CRD放在另一个chart。</p><p>在此方法中，每个char都必须单独安装。然而，这个工作流程可能是集群操作器(cluster operators)（对集群拥有admin权限）使用。</p><p><br><br><br></p><h2 id="RBAC-1"><a href="#RBAC-1" class="headerlink" title="RBAC"></a>RBAC</h2><p>Role-Based Access Control: <a href="https://helm.sh/docs/chart_best_practices/rbac/" target="_blank" rel="noopener">https://helm.sh/docs/chart_best_practices/rbac/</a></p><p>RBAC资源有：</p><ul><li>ServiceAccount (namespaced)</li><li>Role (namespaced)</li><li>ClusterRole</li><li>RoleBinding (namespaced)</li><li>ClusterRoleBinding</li></ul><p><br></p><h3 id="YAML配置"><a href="#YAML配置" class="headerlink" title="YAML配置"></a>YAML配置</h3><p>RBAC和ServiceAccount配置因该在单独的密钥里。它们是不同的东西。拆分这两个概念在YAML歧义消除它们，使之更清楚。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rbac:</span></span><br><span class="line">  <span class="comment"># Specifies whether RBAC resources should be created</span></span><br><span class="line"><span class="attr">  create:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">serviceAccount:</span></span><br><span class="line">  <span class="comment"># Specifies whether a ServiceAccount should be created</span></span><br><span class="line"><span class="attr">  create:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># The name of the ServiceAccount to use.</span></span><br><span class="line">  <span class="comment"># If not set and create is true, a name is generated using the fullname template</span></span><br><span class="line"><span class="attr">  name:</span></span><br></pre></td></tr></table></figure><p>多个服务账号可以扩展为更复杂的charts。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">someComponent:</span><br><span class="line">  serviceAccount:</span><br><span class="line">    create: true</span><br><span class="line">    name:</span><br><span class="line">anotherComponent:</span><br><span class="line">  serviceAccount:</span><br><span class="line">    create: true</span><br><span class="line">    name:</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="RBAC资源应该被默认创建"><a href="#RBAC资源应该被默认创建" class="headerlink" title="RBAC资源应该被默认创建"></a>RBAC资源应该被默认创建</h3><p>RBAC Resources Should be Created by Default</p><p><code>rbac.create</code>应该是一个布尔值，由RBAC资源来控制创建。默认应该为true。希望管理RBAC访问控制的用户可以将此设置为false。</p><p><br><br><br></p><h3 id="使用RBAC资源"><a href="#使用RBAC资源" class="headerlink" title="使用RBAC资源"></a>使用RBAC资源</h3><p>Using RBAC Resources</p><p><code>serviceAccount.name</code>应该被设置为由chart创建的访问控制资源使用的服务账号名称。如果<code>serviceAccount.create</code>为true，那么此名称的服务名称应该被创建。如果此名称未设置，则使用模板<code>fullname</code>来生成。如果为false，则它不应该被创建，但它应该与同样的资源相关联，以便创建后引用该手动创建RBAC资源正常工作。如果为false且没有指定名称，则使用默认的服务账号。</p><p>下面的助手模板应该用于服务账号：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;&#123;/*</span></span><br><span class="line"><span class="string">Create</span> <span class="string">the</span> <span class="string">name</span> <span class="string">of</span> <span class="string">the</span> <span class="string">service</span> <span class="string">account</span> <span class="string">to</span> <span class="string">use</span></span><br><span class="line"><span class="string">*/&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">define</span> <span class="string">"mychart.serviceAccountName"</span> <span class="bullet">-&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">if</span> <span class="string">.Values.serviceAccount.create</span> <span class="bullet">-&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;</span> <span class="string">default</span> <span class="string">(include</span> <span class="string">"mychart.fullname"</span> <span class="string">.)</span> <span class="string">.Values.serviceAccount.name</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">else</span> <span class="bullet">-&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;</span> <span class="string">default</span> <span class="string">"default"</span> <span class="string">.Values.serviceAccount.name</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="bullet">-&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="bullet">-&#125;&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h1><p>Chart Template: <a href="https://helm.sh/docs/chart_template_guide/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/</a></p><p>Helm‘s chart templates，重点介绍模板语言。让我想起的Django模板语言、Jinja2模板语言。</p><p>模板生成清单文件，这是k8s可理解的YAML格式的资源描述。本章重点介绍以下概念：</p><ul><li>Helm模板语言</li><li>Values使用</li><li>使用模板的技术</li></ul><p><br></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>Getting Started: <a href="https://helm.sh/docs/chart_template_guide/getting_started/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/getting_started/</a></p><p>创建一个chart并添加一个模板。</p><p><br></p><h3 id="Charts-1"><a href="#Charts-1" class="headerlink" title="Charts"></a>Charts</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mychart/</span><br><span class="line">  Chart.yaml</span><br><span class="line">  values.yaml</span><br><span class="line">  charts/</span><br><span class="line">  templates/</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><code>templates/</code>目录存放模板文件。当Helm评估一个chart，它会发送所有模板目录中的文件到模板渲染引擎。然后，它收集模板的结果，并将它们发送到k8s。</p><p><code>values.yaml</code>文件对模板也很重要。此文件包含了一个chart的默认值。默认值可通过命令行选项进行覆盖。</p><p><code>Chart.yaml</code>文件包含对chart包的描述信息。你可在模板中访问它。<code>charts/</code>目录可能包含其它chats(称为subcharts)。</p><p><br><br><br></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>A Starter Chart</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个名为mychart的chart包</span><br><span class="line">helm create mychart</span><br><span class="line">Creating mychart</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 目录结构</span><br><span class="line">tree ./mychart -L 2</span><br><span class="line">./mychart</span><br><span class="line">├── charts</span><br><span class="line">├── Chart.yaml</span><br><span class="line">├── templates</span><br><span class="line">│   ├── deployment.yaml</span><br><span class="line">│   ├── _helpers.tpl    #模板助手，你可以重新使用整个chart</span><br><span class="line">│   ├── hpa.yaml    #</span><br><span class="line">│   ├── ingress.yaml</span><br><span class="line">│   ├── NOTES.txt    #chart包的帮助文本(help text)，会在运行helm install显示</span><br><span class="line">│   ├── serviceaccount.yaml</span><br><span class="line">│   ├── service.yaml</span><br><span class="line">│   └── tests</span><br><span class="line">└── values.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建自己的模板</span><br><span class="line">rm -rf mychart/templates/*</span><br></pre></td></tr></table></figure><p>当编写生产环境的chart包时，有这些charts包的基础版本可能很有用。</p><p><br><br><br></p><h3 id="第一个模板"><a href="#第一个模板" class="headerlink" title="第一个模板"></a>第一个模板</h3><p>A First Template</p><p>创建一个<code>ConfigMap</code>资源的模板。由于它是一个基本的资源，因此它为我们提供了一个很好的起点。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mychart/templates/configmap.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mychart-configpmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br></pre></td></tr></table></figure><p>小技巧：模板名称不遵循严格的命名模式。然而，我们建议为YAML文件使用<code>.yaml</code>后缀，为模板助手使用<code>.tpl</code>后缀。</p><p>上述YAML文件是一个最基本的ConfigMap，最有最小的必要的字段。它会通过模板引擎进行发送。</p><p>一个普通的平YAML文件是蛮好的。当Helm读取此模板，它会简单地将文件原样发送给k8s。</p><p>在这个简单的例子中，我们现在有了一个可安装的chart包。安装一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">helm install full-coral mychart</span><br><span class="line">NAME: full-coral</span><br><span class="line">LAST DEPLOYED: Sun Sep 27 10:38:03 2020</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">helm ls</span><br><span class="line">NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART           APP VERSION</span><br><span class="line">full-coral      default         1               2020-09-27 10:38:03.546664865 +0800 CST deployed        mychart-0.1.0   1.16.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">helm get manifest full-coral</span><br><span class="line">---</span><br><span class="line"># Source: mychart/templates/configmap.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: mychart-configmap</span><br><span class="line">data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl get configmap</span><br><span class="line">NAME                DATA   AGE</span><br><span class="line">mychart-configmap   1      9m47s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 卸载</span><br><span class="line">helm uninstall full-coral</span><br></pre></td></tr></table></figure><p><br></p><p><strong>添加一个简单的模板调用</strong></p><p>Adding a Simple Template Call</p><p>硬编码的<code>name</code>，通常被认为是不好的做法。每个发行版的名称应该是唯一的。因此，我们可能将生成一个名称字段来写入发行版名称。</p><p>注意，由于DNS系统的限制，<code>name</code>字段被限制为63字符。出于这个原因，发行版名称被限制为53字符。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 模板指令放置于&#123;&#123; xxx &#125;&#125; 块内</span><br><span class="line">helm install clunky-serval mychart/</span><br><span class="line">NAME: clunky-serval</span><br><span class="line">LAST DEPLOYED: Sun Sep 27 11:16:20 2020</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">helm get manifest clunky-serval</span><br><span class="line">---</span><br><span class="line"># Source: mychart/templates/configmap.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: clunky-serval-configmap</span><br><span class="line">data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 可使用--debug查看详情</span><br><span class="line"># 下面将渲染模板，返回渲染输出，不会真正安装</span><br><span class="line">helm install --debug --dry-run goodly-guppy ./mychart</span><br></pre></td></tr></table></figure><p>使用<code>--dry-run</code>将更容易对代码进行测试，但它不会保证k8s会接受你生成的模板。</p><p><br><br><br></p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>Built-in Objects: <a href="https://helm.sh/docs/chart_template_guide/builtin_objects/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/builtin_objects/</a></p><p>对象动模板引擎传递到模板。你的代码可以传递对象范围（如<code>with</code>和<code>range</code>）。有一些方法可在模板中创建新的对象，如<code>tuple</code>函数。</p><p>对象可以很简单，它只有一个值。它们也可以包含其它对象或函数。如，<code>Realease</code>对象可包含几个对象（如<code>Release.Name</code>），<code>Files</code>对象有一些函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- `Release`对象</span><br><span class="line">  - `Release.Name`</span><br><span class="line">  - `Release.Namespace`</span><br><span class="line">  - `Release.IsUpgrade`</span><br><span class="line">  - `Release.IsInstall`</span><br><span class="line">  - `Release.Revision`</span><br><span class="line">  - `Release.Service`：在Helm中，总是Helm</span><br><span class="line">- `Values`: `values.yaml`中传递给模板的值</span><br><span class="line">- `Chart`: `Chart.yaml`文件内容</span><br><span class="line">- `Files`: 访问chart包中非模板的文件</span><br><span class="line">  - `Files.Get`: 通过名称生成文件的函数</span><br><span class="line">  - `Files.GetBytes`</span><br><span class="line">  - `Files.Glob`: 返回文件为列表的函数</span><br><span class="line">  - `Files.Lines`: 一行行读取文件的函数</span><br><span class="line">  - `Files.AsSecrets`: 返回文件内容为base64编码字符串的函数</span><br><span class="line">  - `Files.AsConfig`: 返回文件内容为YAML map的函数</span><br><span class="line">- `Capabilities`</span><br><span class="line">  - `Capabilities.APIVersions`</span><br><span class="line">  - `Capabilities.APIVersions.Has $version`</span><br><span class="line">  - `Capabilities.KubeVersion`, `Capabilities.KubeVersion.Version`</span><br><span class="line">  - `Capabilities.KubeVersion.Major`</span><br><span class="line">  - `Capabilities.KubeVersion.Minor`</span><br><span class="line">- `Template`</span><br><span class="line">  - `Template.Name`</span><br><span class="line">  - `Template.BasePath`</span><br></pre></td></tr></table></figure><p>内置的值总以大写字母开头。这与go命名方式保持一致。</p><p><br><br><br></p><h3 id="值文件"><a href="#值文件" class="headerlink" title="值文件"></a>值文件</h3><p>Values Files: <a href="https://helm.sh/docs/chart_template_guide/values_files/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/values_files/</a></p><p><code>Values</code>是一个内置的对象。它提供了访问值并传递到chart包。值文件是平YAML文件。其内容来源于多个源：</p><ul><li>chart包中的<code>values.yaml</code>文件</li><li>如果是一个subchart包，则为parent chart包的<code>values.yaml</code>文件</li><li>通过<code>helm install/upgrade</code>的<code>-f myvals.yaml</code>传递值</li><li>通过<code>helm install/upgrade</code>的<code>--set foo=bar</code>选项传递值</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># values.yaml</span></span><br><span class="line"><span class="attr">favoriteDrink:</span> <span class="string">coffee</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favoriteDrink</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 渲染</span><br><span class="line">helm install geared-marsupi ./mychart --dry-run --debug</span><br><span class="line">HOOKS:</span><br><span class="line">MANIFEST:</span><br><span class="line">---</span><br><span class="line"># Source: mychart/templates/configmap.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: geared-marsupi-configmap</span><br><span class="line">data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br><span class="line">  drink: coffee</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 通过命令行选项覆盖值</span><br><span class="line">helm install solid-vulture ./mychart --dry-run --debug --set favoriteDrink=slurm</span><br><span class="line">HOOKS:</span><br><span class="line">MANIFEST:</span><br><span class="line">---</span><br><span class="line"># Source: mychart/templates/configmap.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: solid-vulture-configmap</span><br><span class="line">data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br><span class="line">  drink: slurm</span><br></pre></td></tr></table></figure><p>值文件也可以包含更多结构化的内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># values.yaml</span></span><br><span class="line"><span class="attr">favorite:</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">coffee</span></span><br><span class="line"><span class="attr">  food:</span> <span class="string">pizza</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.drink</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">  food:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.food</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>虽然结构化数据这种方式是可行的，但建议你保持值的浅度(shallow)，有利于平整。当看到subcharts包的值时，我们将看到值是如何使用树状结构命名的。</p><p><br><br><br></p><h3 id="删除一个默认键"><a href="#删除一个默认键" class="headerlink" title="删除一个默认键"></a>删除一个默认键</h3><p>Deleting a default key</p><p>如果你需要从默认值删除一个键，你可以覆盖这个键的值为<code>null</code>，在这种情况下，Helm将从覆盖值得合并中移除这个键。</p><p><br><br><br></p><h2 id="模板函数和管道"><a href="#模板函数和管道" class="headerlink" title="模板函数和管道"></a>模板函数和管道</h2><p>Template Functions and Pipelines: <a href="https://helm.sh/docs/chart_template_guide/functions_and_pipelines/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/functions_and_pipelines/</a></p><p>到目前为止，我们以将看到如何将信息转换为模板。但这些信息放入未修改的模板。有时候，我们希望以一种更可用的方式来转换提供的数据。</p><p>在模板指令中调用<code>quote</code>函数：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">&#123;&#123;</span> <span class="string">quote</span> <span class="string">.Values.favorite.drink</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">  food:</span> <span class="string">&#123;&#123;</span> <span class="string">quote</span> <span class="string">.Values.favorite.food</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>模板函数使用<code>funcationName arg1 arg2...</code>语法。上面的<code>quote .Values.favorite.drink</code>调用<code>quote</code>函数并传递一个参数。</p><p>Helm有超过60个可用的函数。一些通过go模板语言定义。大多数是Sprig template library的一部分。</p><p><br></p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>pipelines(<code>|</code>)</p><p>模板语言的一个强大功能就是它的管道(<code>|</code>)。管道是让几件事情依序进行的有效方式。让我们使用管道重写上面的示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.drink</span> <span class="string">| quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">  food:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.food</span> <span class="string">| quote &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>使用管道，我们可以将多个函数链接在一起：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.drink</span> <span class="string">| repeat 5 | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">food:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.food</span> <span class="string">| upper | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#drink: "coffeecoffeecoffeecoffeecoffee"</span></span><br><span class="line"><span class="string">#food: "PIZZA"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="default函数"><a href="#default函数" class="headerlink" title="default函数"></a>default函数</h3><p><code>default</code>函数经常在模板中使用(<code>default DEFAULT_VALUE GIVEN_VALUE</code>)。此函数允许你指定一个默认值。有则替换它，无则使用默认值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.drink</span> <span class="string">| default "tea" | quote &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>在实际的chart包中，所有静态默认值都应该位于<code>values.yaml</code>中，而不应该使用<code>default</code>重复。然而，<code>default</code>命令对于不能在<code>values.yaml</code>中声明的值，是完美的计算值的方法。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.drink</span> <span class="string">| default (printf "%s-tea" (include "fullname" .)) &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="lookup函数"><a href="#lookup函数" class="headerlink" title="lookup函数"></a>lookup函数</h3><p><code>lookup</code>函数可用于在正在运行的集群中查找资源。它查找<code>apiVersion</code>, <code>kind</code>, <code>namespace</code>, <code>name</code>到resource或resource list。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># apiVersion, kind, namespace, name都是string</span><br><span class="line"># name, namespace两个是可选的，可以为空进行传递</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 下列将会返回mynamespace对象的注释</span><br><span class="line">(lookup &quot;v1&quot; &quot;Namespace&quot; &quot;&quot; &quot;mynamespace&quot;).metadata.annotations</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 当lookup返回一个列表(list)对象时，可以通过items字段访问列表对象</span><br><span class="line">&#123;&#123; range $index, $service := (lookup &quot;v1&quot; &quot;Service&quot; &quot;mynamespace&quot; &quot;&quot;).items &#125;&#125;</span><br><span class="line">    &#123;&#123;/* do something with each service */&#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>当没有找到对象时，则返回一个空值。这可以用于检查对象是否存在。</p><p><code>lookup</code>函数使用Helm现有的k8s连接配置来查询k8s。如果调用API server进行交互时返回错误，则Helm的模板处理将失败。</p><p>请记住，Helm是不应该在<code>helm template</code>或<code>helm install|update|delete|rollback --dry-run</code>期间连接到k8s API server，因此，<code>lookup</code>在此情况下将会获得一个空列表。</p><p><br><br><br></p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>Operators are functions</p><p>对于模板，操作符(<code>eq</code>, <code>ne</code>, <code>lt</code>, <code>gt</code>, <code>and</code>, <code>or</code>等)都被实现为函数。在管道中，操作符可使用括号<code>()</code>进行分组。</p><p><br><br><br></p><h2 id="函数列表"><a href="#函数列表" class="headerlink" title="函数列表"></a>函数列表</h2><p>Template Function List: <a href="https://helm.sh/docs/chart_template_guide/function_list/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/function_list/</a></p><p>Helm包含很多模板函数，你可以在模板中使用它们。下面按照功能列出：</p><ul><li>Cryptographic and Security</li><li>Date</li><li>Dictionaries</li><li>Encoding</li><li>File Path</li><li>Kubernetes and Chart</li><li>Logic and Flow Control</li><li>Lists</li><li>Math</li><li>Network</li><li>Reflection</li><li>Regular Expressions</li><li>Semantic Versions</li><li>String</li><li>Type Conversion</li><li>URL</li><li>UUID</li></ul><p><br><br><br></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>Flow Control: <a href="https://helm.sh/docs/chart_template_guide/control_structures/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/control_structures/</a></p><p>控制结构（在模板原语中称为行动）提供给模板作者，模板生成的控制流程的能力。Helm的模板语言提供了如下控制结构：</p><ul><li><code>if</code>, <code>else</code>：创建条件块</li><li><code>with</code>：指定一个范围</li><li><code>range</code>： 提供一个类似的for循环</li></ul><p>除此之外，它为声明和使用命名模板段提供了一些动作：</p><ul><li><code>define</code>：在模板内声明一个新的命名模板</li><li><code>template</code>：导入一个命名的模板</li><li><code>block</code>：声明一个特殊的可填写的模板区域</li></ul><p>这些都让我想起之前用Django模板语言写前端的时候，基本上一样的原理。</p><p><br></p><h3 id="if和else"><a href="#if和else" class="headerlink" title="if和else"></a>if和else</h3><p><code>if</code>, <code>else</code>块示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;&#123;</span> <span class="string">if</span> <span class="string">PIPELINE</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="comment"># Do something</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">else</span> <span class="string">if</span> <span class="string">OTHER</span> <span class="string">PIPELINE</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="comment"># Do something else</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">else</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="comment"># Default case</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.drink</span> <span class="string">| default "tea" | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">  food:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.food</span> <span class="string">| upper | quote &#125;&#125;</span></span><br><span class="line"><span class="string">  <span class="template-variable">&#123;&#123; if eq .Values.favorite.drink "coffee" &#125;&#125;</span>mug: true<span class="template-variable">&#123;&#123; end &#125;&#125;</span></span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="控制空格"><a href="#控制空格" class="headerlink" title="控制空格"></a>控制空格</h3><p>Controlling Whitespace</p><p>虽然我们看到了条件语句，我们也应该了解模板中的空格的控制方式。这主要是确保对于生成的YAML文件的缩进的正确性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.drink</span> <span class="string">| default "tea" | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">  food:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.food</span> <span class="string">| upper | quote &#125;&#125;</span></span><br><span class="line"><span class="string">  <span class="template-variable">&#123;&#123; if eq .Values.favorite.drink "coffee" &#125;&#125;</span></span></span><br><span class="line"><span class="string"></span><span class="attr">    mug:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">&#123;&#123;</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>生成的不正确的YAML格式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Source: mychart/templates/configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">eyewitness-elk-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">"coffee"</span></span><br><span class="line"><span class="attr">  food:</span> <span class="string">"PIZZA"</span></span><br><span class="line"><span class="attr">    mug:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>mug被不正确地缩进。让我们修改模板：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.drink</span> <span class="string">| default "tea" | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">  food:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.food</span> <span class="string">| upper | quote &#125;&#125;</span></span><br><span class="line"><span class="string">  <span class="template-variable">&#123;&#123; if eq .Values.favorite.drink "coffee" &#125;&#125;</span></span></span><br><span class="line"><span class="string"></span><span class="attr">  mug:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">&#123;&#123;</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>这样生成的YAML是有效的，但显得很滑稽：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Source: mychart/templates/configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">telling-chimp-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">"coffee"</span></span><br><span class="line"><span class="attr">  food:</span> <span class="string">"PIZZA"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  mug:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>请注意，在YAML文件中生成了几个空行。为什么？当模板引擎运行时，它将删除花括号里的内容，但它留下的剩余空格完全一样。</p><p><br></p><p>YAML对空白很在意，所以管理空白变得非常重要。幸运的是，Helm有一些工具来帮助我们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 首先，模板声明的花括号 &#123;&#123; 可以使用特殊字符进行修改，来告诉模板引擎排列空白</span><br><span class="line">&#123;&#123;- 表示空白应靠左(chomped left)</span><br><span class="line">-&#125;&#125; 表示空白应在右边消耗(right should be consumed)</span><br><span class="line"># 注意，换行也是空白（Newlines are whitespace)</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.drink</span> <span class="string">| default "tea" | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">  food:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.food</span> <span class="string">| upper | quote &#125;&#125;</span></span><br><span class="line"><span class="string">  <span class="template-variable">&#123;&#123;- if eq .Values.favorite.drink "coffee" &#125;&#125;</span></span></span><br><span class="line"><span class="string"></span><span class="attr">  mug:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Source: mychart/templates/configmap.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: clunky-cat-configmap</span><br><span class="line">data:</span><br><span class="line">  myvalue: &quot;Hello World&quot;</span><br><span class="line">  drink: &quot;coffee&quot;</span><br><span class="line">  food: &quot;PIZZA&quot;</span><br><span class="line">  mug: true</span><br></pre></td></tr></table></figure><p>小心使用排列修改器(chomping modifier)。很容易不小心做了下面的事情：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">food:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.favorite.food</span> <span class="string">| upper | quote &#125;&#125;</span></span><br><span class="line"><span class="string"><span class="template-variable">&#123;&#123;- if eq .Values.favorite.drink "coffee" -&#125;&#125;</span></span></span><br><span class="line"><span class="string"></span><span class="attr">mug:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="bullet">-&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>这会生成<code>food: &quot;PIZZA&quot;mug:true</code>这样，因为它消耗了两侧的换行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 最后，有时很容易告诉模板系统如何缩进，而不是试图掌握模板指令的空格。</span><br><span class="line"># 出于此原因，你有时可能会发现使用 indent函数 处理缩进是很有用的</span><br><span class="line">&#123;&#123; indent 2 &quot;mug: true&quot; &#125;&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用with修改范围"><a href="#使用with修改范围" class="headerlink" title="使用with修改范围"></a>使用with修改范围</h3><p>Modifying scope using with</p><p>另一个控制结构是<code>with</code>动作。这可以控制变量的范围，<code>.</code>是指的当前范围。因此，<code>.Values</code>告诉模板到当前范围下去寻找<code>Values</code>对象。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with语法和if语句类似</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">with</span> <span class="string">PIPELINE</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="comment"># restricted scope</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>范围可以被更改。<code>with</code>可以允许你将当前范围(<code>.</code>)设置为特定对象。例如，我们使用<code>.Values.favorite</code>工作。让我们在<code>.Values.favorite</code>范围来重写ConfigMap：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">with</span> <span class="string">.Values.favorite</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.drink</span> <span class="string">| default "tea" | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">  food:</span> <span class="string">&#123;&#123;</span> <span class="string">.food</span> <span class="string">| upper | quote &#125;&#125;</span></span><br><span class="line"><span class="string">  <span class="template-variable">&#123;&#123;- end &#125;&#125;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注意，由于我们使用 with 将范围设置在了 .Values.favorite</span><br><span class="line"># 所以我们使用 .drink, .food。范围在 &#123;&#123; end &#125;&#125; 后被还原</span><br></pre></td></tr></table></figure><p>但这里有一个值得注意的问题！在限制的范围内，你将无法从父对象范围(<code>.</code>)访问其它对象。以下示例会失败：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">with</span> <span class="string">.Values.favorite</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.drink</span> <span class="string">| default "tea" | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">food:</span> <span class="string">&#123;&#123;</span> <span class="string">.food</span> <span class="string">| upper | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">release:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">release-2:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>由于<code>Release.Name</code>没有在限制的范围(<code>.</code>)内，会报错。但在限制的之外就没有问题。</p><p>或者，我们可以使用<code>$</code>符号从父范围访问<code>Release.Name</code>对象。<code>$</code>符号在开始执行时会映射到根范围内，在模板执行时也不会改变。示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">with</span> <span class="string">.Values.favorite</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.drink</span> <span class="string">| default "tea" | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">food:</span> <span class="string">&#123;&#123;</span> <span class="string">.food</span> <span class="string">| upper | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">release:</span> <span class="string">&#123;&#123;</span> <span class="string">$.Release.Name</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>在了解<code>range</code>后，我们会看到模板变量，它提供了一个解决上述作用域问题的方法。</p><p><br><br><br></p><h3 id="range循环"><a href="#range循环" class="headerlink" title="range循环"></a>range循环</h3><p>Looping with the range action</p><p>许多编程语言都是用<code>for</code>循环，在Helm模板语言中，它使用<code>range</code>操作符来实现迭代。</p><p>首先，让我们在<code>values.yaml</code>文件里添加一个列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favorite:</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">coffee</span></span><br><span class="line"><span class="attr">  food:</span> <span class="string">pizza</span></span><br><span class="line"><span class="attr">pizzaToppings:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">mushrooms</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cheese</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">peppers</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">onions</span></span><br></pre></td></tr></table></figure><p>在我们的ConfigMap中获取值里面的列表：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">with</span> <span class="string">.Values.favorite</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.drink</span> <span class="string">| default "tea" | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">  food:</span> <span class="string">&#123;&#123;</span> <span class="string">.food</span> <span class="string">| upper | quote &#125;&#125;</span></span><br><span class="line"><span class="string">  <span class="template-variable">&#123;&#123;- end &#125;&#125;</span></span></span><br><span class="line"><span class="string"></span><span class="attr">  toppings:</span> <span class="string">|-</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">ranage</span> <span class="string">.Values.pizzaToppings</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;&#123;</span> <span class="string">.</span> <span class="string">| title | quote &#125;&#125;</span></span><br><span class="line"><span class="string">    <span class="template-variable">&#123;&#123;- end &#125;&#125;</span></span></span><br></pre></td></tr></table></figure><p>我们可以使用<code>$</code>来访问父范围内的<code>Values.pizzaToppings</code>。<code>$</code>符号映射到根目录下，并在函数执行时不会改变。示例如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">with</span> <span class="string">$.Values.favorite</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.drink</span> <span class="string">| default "tea" | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">  food:</span> <span class="string">&#123;&#123;</span> <span class="string">.food</span> <span class="string">| upper | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">  toppings:</span> <span class="string">|-</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">range</span> <span class="string">$.Values.pizzaToppings</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;&#123;</span> <span class="string">.|</span> <span class="string">title</span> <span class="string">| quote &#125;&#125;</span></span><br><span class="line"><span class="string">    <span class="template-variable">&#123;&#123;- end &#125;&#125;</span></span></span><br><span class="line"><span class="string">  <span class="template-variable">&#123;&#123;- end &#125;&#125;</span></span></span><br></pre></td></tr></table></figure><p>渲染示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Source: mychart/templates/configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">edgy-dragonfly-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">"coffee"</span></span><br><span class="line"><span class="attr">  food:</span> <span class="string">"PIZZA"</span></span><br><span class="line"><span class="attr">  toppings:</span> <span class="string">|-</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"Mushrooms"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"Cheese"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"Peppers"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"Onions"</span></span><br></pre></td></tr></table></figure><p>符号<code>|-</code>声明一个多行字符串。因此，实际上我们的toppings不是一个YAML list，而是一个big string。我们为什么要这样做？因为在ConfigMaps <code>data</code>里的数据是由键值对(k/v)组成，其中键和值都是简单的字符串。要理解为什么这样的化，请查看k8s configmap文档。</p><p>YAML里的<code>|-</code>符号表示一个多行字符串(multi-line string)。这可以在文件中嵌入一大块数据。</p><p>Helm模板具有一个<code>tuple</code>函数，来使得操作更简单。让我想起了Python中的tuple数据类型。示例如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sizes:</span> <span class="string">|-</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">range</span> <span class="string">ruple</span> <span class="string">"small"</span> <span class="string">"medium"</span> <span class="string">"large"</span><span class="string">&#125;&#125;</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">&#123;&#123;</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sizes:</span> <span class="string">|-</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">small</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">medium</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">large</span></span><br></pre></td></tr></table></figure><p>除了list和tuple，<code>range</code>还可以迭代具有有键值对的map和dict。我们将在后面的章节中了解它们。</p><p><br><br><br><br><br></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Variables: <a href="https://helm.sh/docs/chart_template_guide/variables/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/variables/</a></p><p>我们可以在模板中使用变量。在Helm模板中，变量是其它对象的命名引用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Releae.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">$relname</span> <span class="string">:=</span> <span class="string">.Release.Name</span> <span class="bullet">-&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">with</span> <span class="string">.Values.favorite</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">&#123;&#123;</span> <span class="string">.drink</span> <span class="string">| default "tea" | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">  food:</span> <span class="string">&#123;&#123;</span> <span class="string">.food</span> <span class="string">| upper | quote &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">  release:</span> <span class="string">&#123;&#123;</span> <span class="string">$relname</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>在<code>with</code>块之前，我们赋值了一个变量。在<code>with</code>块内，<code>$relname</code>变量仍然指向版本名称。</p><p>在<code>range</code>循环中使用变量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">toppings:</span> <span class="string">|-</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">range</span> <span class="string">$index,</span> <span class="string">$topping</span> <span class="string">:=</span> <span class="string">.Values.pizzaToppings</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;</span> <span class="string">$index</span> <span class="string">&#125;&#125;:</span> <span class="string">&#123;&#123;</span> <span class="string">$topping</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>渲染效果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">toppings:</span> <span class="string">|-</span></span><br><span class="line">    <span class="number">0</span><span class="string">:</span> <span class="string">mushrooms</span></span><br><span class="line">    <span class="number">1</span><span class="string">:</span> <span class="string">cheese</span></span><br><span class="line">    <span class="number">2</span><span class="string">:</span> <span class="string">peppers</span></span><br><span class="line">    <span class="number">3</span><span class="string">:</span> <span class="string">onions</span></span><br></pre></td></tr></table></figure><p>有一个变量(<code>$</code>)它永远是全局的，此变量将永远指向根上下文(root context)。放你使用<code>range</code>循环，并且需要知道chart的版本名称时，这非常有用。示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">range</span> <span class="string">.Values.tlsSecrets</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.name</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="comment"># Many helm templates would use `.` below, but that will not work,</span></span><br><span class="line">    <span class="comment"># however `$` will work here</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">&#123;&#123;</span> <span class="string">template</span> <span class="string">"fullname"</span> <span class="string">$</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="comment"># I cannot reference .Chart.Name, but I can do $.Chart.Name</span></span><br><span class="line">    <span class="string">helm.sh/chart:</span> <span class="string">"<span class="template-variable">&#123;&#123; $.Chart.Name &#125;&#125;</span>-<span class="template-variable">&#123;&#123; $.Chart.Version &#125;&#125;</span>"</span></span><br><span class="line">    <span class="string">app.kubernetes.io/instance:</span> <span class="string">"<span class="template-variable">&#123;&#123; $.Release.Name &#125;&#125;</span>"</span></span><br><span class="line">    <span class="comment"># Value from appVersion in Chart.yaml</span></span><br><span class="line">    <span class="string">app.kubernetes.io/version:</span> <span class="string">"<span class="template-variable">&#123;&#123; $.Chart.AppVersion &#125;&#125;</span>"</span></span><br><span class="line">    <span class="string">app.kubernetes.io/managed-by:</span> <span class="string">"<span class="template-variable">&#123;&#123; $.Release.Service &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/tls</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">tls.crt:</span> <span class="string">&#123;&#123;</span> <span class="string">.certificate</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">tls.key:</span> <span class="string">&#123;&#123;</span> <span class="string">.key</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>到目前为止，我们已看到了只在一个文件中声明的模板。但是Helm模板语言的一个强大功能是声明多个模板和使用它们。我们将在后面的章节了解到。</p><p><br><br><br><br><br></p><h2 id="命名模板"><a href="#命名模板" class="headerlink" title="命名模板"></a>命名模板</h2><p>Named Templates: <a href="https://helm.sh/docs/chart_template_guide/named_templates/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/named_templates/</a></p><p>是时候使用多个模板了。本章中，我们将在一个文件中命名模板，然后在其它地方使用它们。这让我想起了Python写Web是的模板。命名模板（有时称为子模板）是在文件中定义的一个简单的模板。有两种方法来创建它，有几种不同的方法来使用它。</p><p>在流程控制(flow control)章节，我们介绍了<code>define</code>, <code>template</code>, <code>block</code>这三个声明和管理模板的动作。在本章中，我们将讨论这三种动作，并引入一种特殊目的的<code>include</code>函数。</p><p>命名模板的一个重要细节：模板名称是全局的。如果声明了两个相同名称的模板，whichever one is loaded last will be the one used. 由于subcharts中的模板与顶级模板一起编译，你应该小心命名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一种流行的命名约定是使用chart名作为前缀：</span><br><span class="line">&#123;&#123; define &quot;mychart.labels&quot; &#125;&#125;</span><br><span class="line"># 通过使用特定的chart名称作为前缀，我们可以避免相同模板名称所带来的冲突</span><br></pre></td></tr></table></figure><p><br></p><h3 id="下划线文件"><a href="#下划线文件" class="headerlink" title="下划线文件"></a>下划线文件</h3><p>Partials and <code>_</code> files</p><p>目前为止，我们使用的一个文件中包含一个模板。但是Helm模板语言允许你创建命名嵌套模板，可通过名称在其它任何地方进行访问。</p><p>在我们开始编写这些模板之前，我们需要注意一下命名规范：</p><ul><li><code>templates/</code>下的大多数文件被视为包含k8s manifests</li><li><code>NOTES.txt</code>是一个例外</li><li>以下划线(<code>_</code>)开头的文件被假定为不包含k8s manifests。这些文件不会被渲染为k8s对象定义，但可在任意chart templates中使用。</li></ul><p>这些文件用来存储特定(partials)和助手(helpers)。实际上，当我们第一次创建<code>mychart</code>，我们会看到<code>_helpers.tpl</code>文件，此文件是默认的template partials。</p><p><br><br><br></p><h3 id="声明和使用模板"><a href="#声明和使用模板" class="headerlink" title="声明和使用模板"></a>声明和使用模板</h3><p>Declaring and using templates with <code>define</code> and <code>template</code>。</p><p><code>define</code>动作允许我们在一个模板文件中创建命名模板(named template)。语法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define &quot;MY.NAME &quot;&#125;&#125;</span><br><span class="line">  # body of template here</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">define</span> <span class="string">"mychart.labels"</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    generator:</span> <span class="string">helm</span></span><br><span class="line"><span class="attr">    data:</span> <span class="string">&#123;&#123;</span> <span class="string">now</span> <span class="string">| htmlDate &#125;&#125;</span></span><br><span class="line"><span class="string"><span class="template-variable">&#123;&#123;- end &#125;&#125;</span></span></span><br><span class="line"><span class="string"></span><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">template</span> <span class="string">"mychart.labels"</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line">    <span class="string">&#123;&#123;-</span> <span class="string">range</span> <span class="string">$key,</span> <span class="string">$va1</span> <span class="string">:=</span> <span class="string">.Values.favorite</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;</span> <span class="string">$key</span> <span class="string">&#125;&#125;:</span> <span class="string">&#123;&#123;</span> <span class="string">$va1</span> <span class="string">| quote &#125;&#125;</span></span><br><span class="line"><span class="string">    <span class="template-variable">&#123;&#123;- end &#125;&#125;</span></span></span><br></pre></td></tr></table></figure><p>渲染之后的效果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Source: mychart/templates/configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">running-panda-configmap</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    generator:</span> <span class="string">helm</span></span><br><span class="line"><span class="attr">    date:</span> <span class="number">2016</span><span class="bullet">-11</span><span class="bullet">-02</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">"coffee"</span></span><br><span class="line"><span class="attr">  food:</span> <span class="string">"pizza"</span></span><br></pre></td></tr></table></figure><p><code>define</code>仅定义，只有在模板中调用时才会产生输出。</p><p>按照惯例，Helm charts将这些模板放在partials文件中（通常是<code>_helpers.tpl</code>），如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;/* Generate basic labels */&#125;&#125;</span><br><span class="line">&#123;&#123;- define &quot;mychart.labels&quot; &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    generator: helm</span><br><span class="line">    date: &#123;&#123; now | htmlDate &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 按照管理，define函数 应该有一个简单的文档块 &#123;&#123;/*...*/&#125;&#125;</span><br><span class="line"># 如上。然后在其它模板文件中访问它。</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="设置模板范围"><a href="#设置模板范围" class="headerlink" title="设置模板范围"></a>设置模板范围</h3><p>Setting the scope of a template</p><p>在上面定义的模板中，我们没有使用任何对象。让我们做些修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;/* Generate basic labels */&#125;&#125;</span><br><span class="line">&#123;&#123;- define &quot;mychart.labels&quot; &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    generator: helm</span><br><span class="line">    data: &#123;&#123; now | htmlData &#125;&#125;</span><br><span class="line">    chart: &#123;&#123; .Chart.Name &#125;&#125;</span><br><span class="line">    version: &#123;&#123; .Chart.Version &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><p>上面定义的名称和版本是动态的，会根据不同的模板生成不同的值。</p><p>之前的引用并没有床底范围，因此在模板内我们不能使用<code>.</code>来访问任何事物。现在我们对模板加上范围:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">template</span> <span class="string">"mychart.labels"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>注意上面在模板调用处使用的点(<code>.</code>)。我们可以非常容易地传递<code>.Values</code>或<code>.Values.favorite</code>或任何我们需要的范围。但是，我们需要的是顶级范围。</p><p>现在运行渲染(<code>helm install --dry-run --debug plinking-anaco ./mychart</code>)来预览下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Source: mychart/templates/configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">plinking-anaco-configmap</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    generator:</span> <span class="string">helm</span></span><br><span class="line"><span class="attr">    date:</span> <span class="number">2016</span><span class="bullet">-11</span><span class="bullet">-02</span></span><br><span class="line"><span class="attr">    chart:</span> <span class="string">mychart</span></span><br><span class="line"><span class="attr">    version:</span> <span class="number">0.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p>The <code>include</code> function</p><p>假设我们定义了如下一个简单模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- define &quot;mychart.app&quot; -&#125;&#125;</span><br><span class="line">app_name: &#123;&#123; .Chart.Name &#125;&#125;</span><br><span class="line">app_version: &quot;&#123;&#123; .Chart.Version &#125;&#125;&quot;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>一个错误的栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">&#123;&#123;</span> <span class="string">template</span> <span class="string">"mychart.app"</span> <span class="string">.</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">range</span> <span class="string">$key,</span> <span class="string">$val</span> <span class="string">:=</span> <span class="string">.Values.favorite</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;</span> <span class="string">$key</span> <span class="string">&#125;&#125;:</span> <span class="string">&#123;&#123;</span> <span class="string">$val</span> <span class="string">| quote &#125;&#125;</span></span><br><span class="line"><span class="string">  <span class="template-variable">&#123;&#123;- end &#125;&#125;</span></span></span><br><span class="line"><span class="string"><span class="template-variable">&#123;&#123; template "mychart.app" . &#125;&#125;</span></span></span><br></pre></td></tr></table></figure><p>渲染的结果并不正确：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Source: mychart/templates/configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">measly-whippet-configmap</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app_name:</span> <span class="string">mychart</span></span><br><span class="line"><span class="attr">app_version:</span> <span class="string">"0.1.0+1478129847"</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">"coffee"</span></span><br><span class="line"><span class="attr">  food:</span> <span class="string">"pizza"</span></span><br><span class="line"><span class="attr">  app_name:</span> <span class="string">mychart</span></span><br><span class="line"><span class="attr">app_version:</span> <span class="string">"0.1.0+1478129847"</span></span><br></pre></td></tr></table></figure><p>Because the template that is substituted in has the text aligned to the right. Because template is an action, and not a function, there is no way to pass the output of a template call to other functions; the data is simply inserted inline.</p><p>To work around this case, Helm provides an alternative to template that will import the contents of a template into the present pipeline where it can be passed along to other functions in the pipeline.</p><p>因为模板是靠右对齐的文本，因为<code>template</code>是一个动作，不是一个函数，因此无法传递调用其它函数的<code>template</code>的输出，数据被简单的插入内联。</p><p><br></p><p>现在我们需要使用<code>ident</code>来告诉模板正确的缩进，栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">include</span> <span class="string">"mychart.app"</span> <span class="string">.</span> <span class="string">| indent 4 &#125;&#125;</span></span><br><span class="line"><span class="string"></span><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">range</span> <span class="string">$key,</span> <span class="string">$va1</span> <span class="string">:=</span> <span class="string">.Values.favorite</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;</span> <span class="string">$key</span> <span class="string">&#125;&#125;:</span> <span class="string">&#123;&#123;</span> <span class="string">$val</span> <span class="string">| quote &#125;&#125;</span></span><br><span class="line"><span class="string">  <span class="template-variable">&#123;&#123;- end &#125;&#125;</span></span></span><br><span class="line"><span class="string">  <span class="template-variable">&#123;&#123; include "mychart.app" . | indent 2 &#125;&#125;</span></span></span><br></pre></td></tr></table></figure><p>正确的渲染结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Source: mychart/templates/configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">edgy-mole-configmap</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app_name:</span> <span class="string">mychart</span></span><br><span class="line"><span class="attr">    app_version:</span> <span class="string">"0.1.0+1478129987"</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  myvalue:</span> <span class="string">"Hello World"</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">"coffee"</span></span><br><span class="line"><span class="attr">  food:</span> <span class="string">"pizza"</span></span><br><span class="line"><span class="attr">  app_name:</span> <span class="string">mychart</span></span><br><span class="line"><span class="attr">  app_version:</span> <span class="string">"0.1.0+1478129987"</span></span><br></pre></td></tr></table></figure><p>在Helm template中使用<code>include</code>对<code>template</code>被认为更好，这使得输出格式可以为YAML文档更好地处理。</p><p>有时候，我们想要导入内容，但不作为模板。也就是逐字导入文件。我们可以通过<code>.Files</code>对象访问文件来实现这一目标。</p><p><br><br><br></p><h2 id="在模板内访问文件"><a href="#在模板内访问文件" class="headerlink" title="在模板内访问文件"></a>在模板内访问文件</h2><p>Accessing Files Inside Templates: <a href="https://helm.sh/docs/chart_template_guide/accessing_files/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/accessing_files/</a></p><p>Helm提供了<code>.Files</code>对象来访问文件。在开始模板示例之前，有些事需要注意下：</p><ul><li>可以添加额外的文件到Helm chart。这些文件将被捆绑。要注意，charts必须小于1MB，因为k8s对象的存储限制。</li><li>某些文件无法通过<code>.Files</code>对象访问，通常出于安全原因<ul><li><code>templates/</code>目录内的文件无法访问</li><li><code>.helmignore</code>中包含的文件无法访问</li></ul></li><li>Charts不保留UNIX mode信息，当设计到<code>.Files</code>对象时，文件级别的权限对一个文件的可用性没有影响。</li></ul><p><br></p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>Basic example</p><p>添加三个位于<code>mychart/</code>目录下的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># config1.toml</span><br><span class="line">message = Hello from config 1</span><br><span class="line"></span><br><span class="line"># config1.tom2</span><br><span class="line">message = Hello from config 2</span><br><span class="line"></span><br><span class="line"># config1.tom3</span><br><span class="line">message = Goodbye from config 3</span><br></pre></td></tr></table></figure><p>在模板中访问文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">$files</span> <span class="string">:=</span> <span class="string">.Files</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">range</span> <span class="string">tuple</span> <span class="string">"config1.tom1"</span> <span class="string">"config2.toml"</span> <span class="string">"config3.toml"</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;</span> <span class="string">.&#125;&#125;:</span> <span class="string">|-</span></span><br><span class="line">    <span class="string">&#123;&#123;</span> <span class="string">$files.Get</span> <span class="string">.&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;-</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 首先，创建了一个 $files变量 来保存.Files对象的引用</span><br><span class="line"># 我们同样使用 tuple函数来创建循环的文件列表</span><br><span class="line"># 接着打印每个文件名 &#123;&#123; . &#125;&#125;: |- 后面接着文件内容 &#123;&#123; $files.Get . &#125;&#125;</span><br></pre></td></tr></table></figure><p>渲染效果示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Source: mychart/templates/configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">quieting-giraf-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">config1.toml:</span> <span class="string">|-</span></span><br><span class="line">    <span class="string">message</span> <span class="string">=</span> <span class="string">Hello</span> <span class="string">from</span> <span class="string">config</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="string">config2.toml:</span> <span class="string">|-</span></span><br><span class="line">    <span class="string">message</span> <span class="string">=</span> <span class="string">This</span> <span class="string">is</span> <span class="string">config</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="string">config3.toml:</span> <span class="string">|-</span></span><br><span class="line">    <span class="string">message</span> <span class="string">=</span> <span class="string">Goodbye</span> <span class="string">from</span> <span class="string">config</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="路径助手"><a href="#路径助手" class="headerlink" title="路径助手"></a>路径助手</h3><p>Path helpers</p><p>使用文件时，对文件路径执行一些标准的操作是有用的。为了帮助处理，Helm从go path包中引入了许多函数供你使用:</p><ul><li><code>Base</code></li><li><code>Dir</code></li><li><code>Ext</code></li><li><code>IsAbs</code></li><li><code>Clean</code></li></ul><p><br><br><br></p><h3 id="Glob模式"><a href="#Glob模式" class="headerlink" title="Glob模式"></a>Glob模式</h3><p>Glob patterns</p><p>随着你的chart包的增长，你会发现你有一个更大的需来组织你的文件，因此我们提供了<code>Files.Glob(pattern string)</code>方法，以帮助提取某些文件与glob patterns的所有灵活性。</p><p><code>.Glob</code>返回一个<code>Files</code>类型，因此你可以在返回的对象上调用任意<code>Files</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 示例的目录结构</span><br><span class="line">foo/:</span><br><span class="line">  foo.txt foo.yaml</span><br><span class="line"></span><br><span class="line">bar/:</span><br><span class="line">  bar.go bar.conf baz.yaml</span><br></pre></td></tr></table></figure><p>使用Globs的多种选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; $currentScope := .&#125;&#125;</span><br><span class="line">&#123;&#123; range $path, $_ :=  .Files.Glob  &quot;**.yaml&quot; &#125;&#125;</span><br><span class="line">    &#123;&#123;- with $currentScope&#125;&#125;</span><br><span class="line">        &#123;&#123; .Files.Get $path &#125;&#125;</span><br><span class="line">    &#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; range $path, $_ :=  .Files.Glob  &quot;**.yaml&quot; &#125;&#125;</span><br><span class="line">      &#123;&#123; $.Files.Get $path &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="ConfigMap和Secrets的实用功能"><a href="#ConfigMap和Secrets的实用功能" class="headerlink" title="ConfigMap和Secrets的实用功能"></a>ConfigMap和Secrets的实用功能</h3><p>ConfigMap and Secrets utility functions</p><p>将文件内容放置到K8s ConfigMap或Secrets中非常常见，然后在运行的时候挂载到容器。为了帮助实现此功能，我们在<code>Files</code>类型上提供了几种实用的方法：</p><ul><li><code>AsCoinfig</code></li><li><code>AsSecrets</code></li></ul><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">conf</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">(.Files.Glob</span> <span class="string">"foo/*"</span><span class="string">).AsConfig</span> <span class="string">| indent 2 &#125;&#125;</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">very-secret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">(.Files.Glob</span> <span class="string">"bar/*"</span><span class="string">).AsSecrets</span> <span class="string">| indent 2 &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>Encoding</p><p>你可以导入一个文件，并实用base64编码来确保成功传输：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-secret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  token:</span> <span class="string">|-</span></span><br><span class="line">    <span class="string">&#123;&#123;</span> <span class="string">.Files.Get</span> <span class="string">"config1.toml"</span> <span class="string">| b64enc &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>渲染后的效果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Source: mychart/templates/secret.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">lucky-turkey-secret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  token:</span> <span class="string">|-</span></span><br><span class="line">    <span class="string">bWVzc2FnZSA9IEhlbGxvIGZyb20gY29uZmlnIDEK</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>Lines</p><p>有时候需要在模板中访问一个文件中的每行内容。我们为此提供了<code>Lines</code>方法。</p><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">some-file.txt:</span> <span class="string">&#123;&#123;</span> <span class="string">range</span> <span class="string">.Files.Lines</span> <span class="string">"foo/bar.txt"</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="string">&#123;&#123;</span> <span class="string">.</span> <span class="string">&#125;&#125;&#123;&#123;</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="NOTES-txt"><a href="#NOTES-txt" class="headerlink" title="NOTES.txt"></a>NOTES.txt</h2><p>Creating a NOTES.txt File: <a href="https://helm.sh/docs/chart_template_guide/notes_files/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/notes_files/</a></p><p>在<code>helm install</code>或<code>helm upgrade</code>结束，Helm可以为用户打印一块有用的信息。此信息使用模板且高度可定制。</p><p>要为你的chart包添加安装说明，简单地创建一个<code>templates/NOTES.txt</code>文件。此文件是纯文本文件，但它像作为模板一样处理，并可访问所有正常模板函数和对象。</p><p><code>NOTES.txt</code>文件示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thank you for installing &#123;&#123; .Chart.Name &#125;&#125;</span><br><span class="line"></span><br><span class="line">Your release is named &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line"></span><br><span class="line">To learn more about the release, try:</span><br><span class="line">  $ helm status &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">  $ helm get all &#123;&#123; .Release.Name &#125;&#125;</span><br></pre></td></tr></table></figure><p>接下来运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">helm install rude-cardinal ./mychart</span><br><span class="line"></span><br><span class="line">RESOURCES:</span><br><span class="line">==&gt; v1/Secret</span><br><span class="line">NAME                   TYPE      DATA      AGE</span><br><span class="line">rude-cardinal-secret   Opaque    1         0s</span><br><span class="line"></span><br><span class="line">==&gt; v1/ConfigMap</span><br><span class="line">NAME                      DATA      AGE</span><br><span class="line">rude-cardinal-configmap   3         0s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line">Thank you for installing mychart.</span><br><span class="line"></span><br><span class="line">Your release is named rude-cardinal.</span><br><span class="line"></span><br><span class="line">To learn more about the release, try:</span><br><span class="line"></span><br><span class="line">  $ helm status rude-cardinal</span><br><span class="line">  $ helm get all rude-cardinal</span><br></pre></td></tr></table></figure><p>强烈建议创建<code>NOTES.txt</code>文件，以帮助用户获得chart包的有用信息。</p><p><br><br><br></p><h2 id="Subcharts"><a href="#Subcharts" class="headerlink" title="Subcharts"></a>Subcharts</h2><p>Subcharts and Global Values: <a href="https://helm.sh/docs/chart_template_guide/subcharts_and_globals/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/subcharts_and_globals/</a></p><p>之前我们只有一个chart，但charts可能会有依赖(dependencies)，称为subcharts。subcharts也有自己的值和模板。本章我们将会创建subchart，并看看我们可以从模板访问值的不同的方式。</p><p>subcharts的一些重要详情：</p><ul><li>一个subchart被认为是独立的(stand-alone)，这意味着一个subchart不能明确依赖它的parent chart</li><li>出于此原因，subchart不能访问parent chart的值</li><li>parent chart可以覆盖subcharts的值</li><li>Helm有一个全局值(global values)的概念，这些全局值可被所有charts访问</li></ul><p><br></p><h3 id="创建一个subchart"><a href="#创建一个subchart" class="headerlink" title="创建一个subchart"></a>创建一个subchart</h3><p>Creating a Subchart</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> mychart/charts</span><br><span class="line"></span><br><span class="line">helm create mysubchart</span><br><span class="line"></span><br><span class="line">rm -rf mysubchart/templates/*.*</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="对subchart添加值和模板"><a href="#对subchart添加值和模板" class="headerlink" title="对subchart添加值和模板"></a>对subchart添加值和模板</h3><p>Adding Values and a Template to the Subchart</p><p>为subchart添加一个简单的值和模板：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># values.yaml</span></span><br><span class="line"><span class="attr">dessert:</span> <span class="string">cake</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-cfgmap2</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  dessert:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.dessert</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>因为每个subchart都是独立的chart，我们可以测试mysubchart：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">helm install --generate-name --dry-run --debug mychart/charts/mysubchart</span><br><span class="line">SERVER: <span class="string">"localhost:44134"</span></span><br><span class="line">CHART PATH: /Users/mattbutcher/Code/Go/src/helm.sh/helm/_scratch/mychart/charts/mysubchart</span><br><span class="line">NAME:   newbie-elk</span><br><span class="line">TARGET NAMESPACE:   default</span><br><span class="line">CHART:  mysubchart 0.1.0</span><br><span class="line">MANIFEST:</span><br><span class="line">---</span><br><span class="line"><span class="comment"># Source: mysubchart/templates/configmap.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: newbie-elk-cfgmap2</span><br><span class="line">data:</span><br><span class="line">  dessert: cake</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="从parent-chart覆盖值"><a href="#从parent-chart覆盖值" class="headerlink" title="从parent chart覆盖值"></a>从parent chart覆盖值</h3><p>现在，mychart是mysubchart的parent chart。因为mychart是parent chart，我们可以在mychart中指定配置，并将配置推送到mysubchart中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mychart/values.yaml</span></span><br><span class="line"><span class="attr">favorite:</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">coffee</span></span><br><span class="line"><span class="attr">  food:</span> <span class="string">pizza</span></span><br><span class="line"><span class="attr">pizzaToppings:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">mushrooms</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cheese</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">peppers</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">onions</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mysubchart:</span></span><br><span class="line"><span class="attr">  dessert:</span> <span class="string">ice</span> <span class="string">cream</span></span><br></pre></td></tr></table></figure><p>我们在parent chart(mychart)的值文件里添加了mysubchart的值，mysubchart这部分值会发送到mysubchart包，这回覆盖mysubchart的值。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">helm install --dry-run --debug mychart</span><br><span class="line"></span><br><span class="line"><span class="comment"># Source: mychart/charts/mysubchart/templates/configmap.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: unhinged-bee-cfgmap2</span><br><span class="line">data:</span><br><span class="line">  dessert: ice cream</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="全局值"><a href="#全局值" class="headerlink" title="全局值"></a>全局值</h3><p>Global Chart Values</p><p>有时候你需要将值提供给所有模板，这可以使用全局值(global chart values)。全局值可被任意chart或subchart通过相同的名称来访问。全局需要明确地声明。</p><p>值数据类型保留在称为<code>Values.global</code>的区域，此区域可以设置全局值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mychart/values.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">favorite:</span></span><br><span class="line"><span class="attr">  drink:</span> <span class="string">coffee</span></span><br><span class="line"><span class="attr">  food:</span> <span class="string">pizza</span></span><br><span class="line"><span class="attr">pizzaToppings:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">mushrooms</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cheese</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">peppers</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">onions</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mysubchart:</span></span><br><span class="line"><span class="attr">  dessert:</span> <span class="string">ice</span> <span class="string">cream</span></span><br><span class="line"></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  salad:</span> <span class="string">caesar</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 任意chart和subchart都可以使用 &#123;&#123; .Values.global.salad &#125;&#125; 来访问这个值</span></span><br><span class="line"><span class="comment"># mychart/templates/configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  salad:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.global.salad</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysubchart/templates/configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Release.Name</span> <span class="string">&#125;&#125;-cfgmap2</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  dessert:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.dessert</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">  salad:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.global.salad</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>渲染输出效果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Source: mychart/templates/configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">silly-snake-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  salad:</span> <span class="string">caesar</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># Source: mychart/charts/mysubchart/templates/configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">silly-snake-cfgmap2</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  dessert:</span> <span class="string">ice</span> <span class="string">cream</span></span><br><span class="line"><span class="attr">  salad:</span> <span class="string">caesar</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="共享模板"><a href="#共享模板" class="headerlink" title="共享模板"></a>共享模板</h3><p>Sharing Templates with Subcharts</p><p>parent charts和subcharts可以共享模板。任意在chart中定义的block(块)都可以被其它charts所使用。</p><p>定义一个简单的模板栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;&#123;-</span> <span class="string">define</span> <span class="string">"labels"</span> <span class="string">&#125;&#125;from:</span> <span class="string">mychart</span> <span class="string">&#123;&#123;</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>尽管chart开发者可以在<code>include</code>和<code>template</code>之间选择，但使用<code>include</code>的优点是它可以动态引用模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; include $mytemplate &#125;&#125;</span><br></pre></td></tr></table></figure><p>上面间接引用<code>$mytemplate</code>。<code>template</code>函数，相反它只接受一个字符串。</p><p><br><br><br></p><h3 id="避免使用块"><a href="#避免使用块" class="headerlink" title="避免使用块"></a>避免使用块</h3><p>Avoid Using Blocks</p><p>go模板语言提供了一个<code>block</code>关键字，来允许开发者提供一个覆盖的默认实现。在Helm chart中，块(block)并不是覆盖的最佳工具，因为如果提供了相同块的多个实现，选择的那个是不可预测的。</p><p>建议使用<code>include</code>来代替。</p><p><br><br><br></p><h2 id="helmignore"><a href="#helmignore" class="headerlink" title=".helmignore"></a>.helmignore</h2><p>The .helmignore file: <a href="https://helm.sh/docs/chart_template_guide/helm_ignore_file/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/helm_ignore_file/</a></p><p><code>.helmignore</code>也就类似于<code>.gitignore</code>, <code>.dockerignore</code>，指定不需要包含在chart包中的文件。</p><p>如果此文件存在，<code>helm package</code>命令将忽略<code>.helmignore</code>里面匹配到的文件打包到应用的包里。</p><p>一个<code>.helmignore</code>文件的栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># comment</span><br><span class="line"></span><br><span class="line"># Match any file or path named .git</span><br><span class="line">.git</span><br><span class="line"></span><br><span class="line"># Match any text file</span><br><span class="line">*.txt</span><br><span class="line"></span><br><span class="line"># Match only directories named mydir</span><br><span class="line">mydir/</span><br><span class="line"></span><br><span class="line"># Match only text files in the top-level directory</span><br><span class="line">/*.txt</span><br><span class="line"></span><br><span class="line"># Match only the file foo.txt in the top-level directory</span><br><span class="line">/foo.txt</span><br><span class="line"></span><br><span class="line"># Match any file named ab.txt, ac.txt, or ad.txt</span><br><span class="line">a[b-d].txt</span><br><span class="line"></span><br><span class="line"># Match any file under subdir matching temp*</span><br><span class="line">*/temp*</span><br><span class="line"></span><br><span class="line">*/*/temp*</span><br><span class="line">temp?</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="模板调试"><a href="#模板调试" class="headerlink" title="模板调试"></a>模板调试</h2><p>Debugging Templates: <a href="https://helm.sh/docs/chart_template_guide/debugging/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/debugging/</a></p><p>有几个命令可帮助调试模板：</p><ul><li><code>helm lint</code>: 验证chart最佳实践的工具</li><li><code>helm install --dry-run --debug</code>或<code>helm template --debug</code>：渲染模板并返回k8s manifest文件</li><li><code>helm get manifest</code>：查看安装了哪些模板</li></ul><p><br><br><br></p><h2 id="YAML技巧"><a href="#YAML技巧" class="headerlink" title="YAML技巧"></a>YAML技巧</h2><p>YAML Techniques: <a href="https://helm.sh/docs/chart_template_guide/yaml_techniques/" target="_blank" rel="noopener">https://helm.sh/docs/chart_template_guide/yaml_techniques/</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Helm命令"><a href="#Helm命令" class="headerlink" title="Helm命令"></a>Helm命令</h1><p>Helm Commands: <a href="https://helm.sh/docs/helm/" target="_blank" rel="noopener">https://helm.sh/docs/helm/</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="社区指南"><a href="#社区指南" class="headerlink" title="社区指南"></a>社区指南</h1><p>Community Guides: <a href="https://helm.sh/docs/community/" target="_blank" rel="noopener">https://helm.sh/docs/community/</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><p>Frequently Asked Questions: <a href="https://helm.sh/docs/faq/" target="_blank" rel="noopener">https://helm.sh/docs/faq/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;docs: &lt;a href=&quot;https://docs.helm.sh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.helm.sh/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;github: &lt;a href=&quot;https://github.com/helm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/helm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;el7x86_64&lt;/li&gt;
&lt;li&gt;helm v3.3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Helm" scheme="https://zhang21.github.io/tags/Helm/"/>
    
      <category term="K8s" scheme="https://zhang21.github.io/tags/K8s/"/>
    
      <category term="DevOps" scheme="https://zhang21.github.io/tags/DevOps/"/>
    
      <category term="CNCF" scheme="https://zhang21.github.io/tags/CNCF/"/>
    
  </entry>
  
  <entry>
    <title>Go</title>
    <link href="https://zhang21.github.io/2020/07/22/Go/"/>
    <id>https://zhang21.github.io/2020/07/22/Go/</id>
    <published>2020-07-22T11:02:32.000Z</published>
    <updated>2020-09-15T11:49:50.799Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>github: <a href="https://github.com/golang/go" target="_blank" rel="noopener">https://github.com/golang/go</a></li><li>Docs: <a href="https://golang.org/doc/" target="_blank" rel="noopener">https://golang.org/doc/</a></li><li>awesome-go: <a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">https://github.com/avelino/awesome-go</a></li></ul><p><br></p><p>版本:</p><ul><li>go v1.14</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Go编程语言是一个开源项目，使开发人员更高效。</p><p>Go是传神，简洁，干净，高效的。它的并发机制(concurrency mechanisms)可充分利用多核和网络机器编写程序，它的新颖类型系统允许灵活和模块化结构。它是一个快速、静态类型、编译型语言，像一个动态类型、解释型语言。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下载对应平台的二进制包，解压，添加路径。</p><p><br></p><p>测试安装:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"hello, world\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 编译</span><br><span class="line">go build hello.go</span><br><span class="line"># 执行</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p><br></p><p>安装其它版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org/dl/go1.10.7</span><br><span class="line"></span><br><span class="line">go1.10.7 version</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p><br></p><h2 id="旅程"><a href="#旅程" class="headerlink" title="旅程"></a>旅程</h2><p>Tour: <a href="https://tour.go-zh.org/list" target="_blank" rel="noopener">https://tour.go-zh.org/list</a></p><p><br></p><p>交互式地分三部分介绍Go：</p><ul><li>基本语法和数据结构</li><li>方法和接口</li><li>并发原语(concurrency primitives)</li></ul><p>可在线上或本地开启旅程：</p><ul><li>线上: <a href="https://tour.golang.org/welcome/1" target="_blank" rel="noopener">https://tour.golang.org/welcome/1</a></li><li>本地: <code>go get golang.org/x/tour</code>，会在go path的<code>bin/tour</code>。</li></ul><p><br></p><p><code>sandbox.go</code>测试程序显示时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Welcomt to the playground!"</span>)</span><br><span class="line">  fmt.Println(<span class="string">"The time is"</span>, time.Now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>学习go程序的基本结构。</p><p><br></p><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>每个go程序都是由包构成。程序从<code>main</code>包开始运行。</p><p>按照约定，包名与导入路径的最后一个元素一致。例如，<code>math/rand</code>包中的源码均以<code>package rand</code>语句开始。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入两个包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"My favorite number is"</span>, rand.Intn(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>使用圆括号进行分组导入，也可以编写多个导入语句。分组导入语句是更好的形式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分组导入</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="导出名"><a href="#导出名" class="headerlink" title="导出名"></a>导出名</h4><p>在Go中，如果一个名字以大写字母，那么它就是已导出的。</p><p>在导入一个包时，你只能引用其中已导出的名字。任何未导出的名字在该包外均无法访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exporter-nams.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(math.pi)</span><br><span class="line">    <span class="comment">//fmt.Println(math.Pi)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行math.pi会报错</span><br><span class="line">./prog.go:9:14: cannot refer to unexported name math.pi</span><br><span class="line">./prog.go:9:14: undefined: math.pi</span><br><span class="line"></span><br><span class="line">运行math.Pi</span><br><span class="line">3.141592653589793</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数可以没有参数或接受多个参数。注意类型在变量名之后。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functions.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略模式: x, y int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(add(<span class="number">42</span>, <span class="number">13</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="多值返回"><a href="#多值返回" class="headerlink" title="多值返回"></a>多值返回</h4><p>函数可以返回任意数量的返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiple-results.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := swap(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h4><p>go的返回值可被命名，它们会被视作定义在函数顶部的变量。返回值的名称应当具有一定的意义。</p><p>没有参数的<code>return</code>语句返回已命名的返回值，也就是<strong>直接</strong>返回。直接返回语句应当仅在短函数中，在长函数中会影响代码的可读性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name-result.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum -x</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(split(<span class="number">17</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><code>var</code>语句用于声明一个变量列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// variables.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    fmt.Println(i, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><p>变量声明可以包含初始值。<br>如果初始化值已存在，则可以省略类型，变量会从初始值中获得类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var-ini.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">impoort <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i, j, <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"no!"</span></span><br><span class="line">    fmt.Println(i, j, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数中，简洁赋值语句<code>:=</code>可在类型明确的地方代替<code>var</code>声明。</p><p>函数外的每个语句都必须以关键字(var, func…)开始，因此<code>:=</code>结构不能在函数外使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// short-var-declarations.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i, j <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    k := <span class="number">3</span></span><br><span class="line">    c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"no!"</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(i, j, k, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>go的基本类型有：</p><ul><li>bool</li><li>string</li><li>int, int8, int16, int32, int64</li><li>uint, uint8, uint16, uint32, uint64, uintptr</li><li>byte(uint8的别名)</li><li>rune(int32的别名，表示一个unicode码点)</li><li>float32, float64</li><li>complex64, complex128</li></ul><p>int, uint 和 uintptr 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 int 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic-types.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/cmplx"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ToBe <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line">    MaxInt <span class="keyword">uint64</span> = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">    x <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> ++ <span class="number">12i</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Type: %T Value: %v\n"</span>, ToBe, ToBe)</span><br><span class="line">    fmt.Printf(<span class="string">"Type: %T Value: %v\n"</span>, MaxInt, MaxInt)</span><br><span class="line">    fmt.Printf(<span class="string">"Type: %T Value: %v"</span>, z, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h4><p>没有明确初始值的变量声明会被赋予它们的<strong>零值</strong>。</p><p>零值是:</p><ul><li>数值类型为 <code>0</code></li><li>布尔类型为 <code>false</code></li><li>字符串为空字符串</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zero.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> f <span class="keyword">float64</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v %v %v %q\n"</span>, i, f, b, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><code>T(v)</code>将v转换为T类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type-conversions.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x, y <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">    <span class="keyword">var</span> f <span class="keyword">float64</span> = math.Sqrt(<span class="keyword">float64</span>(x*x + y*y))</span><br><span class="line">    <span class="keyword">var</span> z unit = unit(f)</span><br><span class="line">    fmt.Println(x, y, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>在声明一个变量而不指定其类型时，变量的类型由右值推导而出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type-inference.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := <span class="number">42</span> <span class="comment">// int</span></span><br><span class="line">    fmt.Printf(<span class="string">"v is of type %T\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量的声明与变量类似，只不过使用<code>const</code>关键字。</p><p>常量可以是字符、字符串、布尔值、数值。</p><p>常量不能用<code>:=</code>语法声明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> World = <span class="string">"世界"</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello"</span>, World)</span><br><span class="line">    fmt.Println(<span class="string">"Happy"</span>, Pi, <span class="string">"Day"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Truth = <span class="literal">true</span></span><br><span class="line">    fmt.Println(<span class="string">"Go rules?"</span> Truth)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h4><p>数值常量是高精度的<strong>值</strong>。一个未指定类型的常量由上下文来决定其类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nemeric-constants.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 将1左移100位来创建一个非常大的数字，即这个数的二进制是1后面跟着100个0</span></span><br><span class="line">    Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line">    <span class="comment">// 再往右移99位，即Small = 1 &lt;&lt; 1，或Small = 2</span></span><br><span class="line">    Small = Big &gt;&gt; <span class="number">99</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needInt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x*<span class="number">10</span> + <span class="number">1</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needFloat</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;<span class="keyword">return</span> x * <span class="number">0.1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(needInt(Small))</span><br><span class="line">    fmt.Println(needFloat(Small))</span><br><span class="line">    fmt.Println(needFloat(Big))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>flowcontrol: <a href="https://tour.go-zh.org/flowcontrol" target="_blank" rel="noopener">https://tour.go-zh.org/flowcontrol</a></p><p>学习如何使用条件、循环、分支和推迟语句来控制代码的流程。</p><p><br></p><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>go只有一种循环结构: <code>for</code>循环。它由三部分组成：</p><ul><li>初始化语句： 在第一次迭代前执行</li><li>条件表达式：在每次迭代前求值</li><li>后置语句： 在每次迭代的结尾执行</li></ul><p>初始化语句和后置语句是可选的。</p><p>初始化语句通常为一句短变量声明，该变量声明仅在for语句的作用域中可见。一旦条件表达式的布尔值为false，循环迭代就会终止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        sum += i</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for-continued.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sum := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">        sum += sum</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="for是while"><a href="#for是while" class="headerlink" title="for是while"></a>for是while</h4><p>go的for就是while。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for-is-while.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sum := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">        sum += sum</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>如果省略循环条件，该循环就不会结束，因此无限循环可以写的很紧凑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forever.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(-x) + <span class="string">"i"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(sqrt(<span class="number">2</span>), sqrt(<span class="number">-4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="简短的if"><a href="#简短的if" class="headerlink" title="简短的if"></a>简短的if</h4><p>if语句可在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在if之内。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if-short.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(</span><br><span class="line">        pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">        pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="else"><a href="#else" class="headerlink" title="else"></a>else</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// else.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%g &gt;= %g\n"</span>, v, lim)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(</span><br><span class="line">        pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">        pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>switch是一连串的if-else语句的简单写法。它运行第一个值等于条件表达式的case语句。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">"Go runs on "</span>)</span><br><span class="line">    <span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Linux."</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%s. \n"</span>, os)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>switch的case语句从上到下依次执行，知道匹配成功时停止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch-order.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"When's Saturday?"</span>)</span><br><span class="line">    today := time.NOw().Weekday()</span><br><span class="line">    <span class="keyword">switch</span> time.Saturday &#123;</span><br><span class="line">    <span class="keyword">case</span> today + <span class="number">0</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Today."</span>)</span><br><span class="line">    <span class="keyword">case</span> today + <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Tomorrow."</span>)</span><br><span class="line">    <span class="keyword">case</span> today + <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">"In two days."</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Too far away."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>没有条件的switch同<code>switch true</code>一样。这种形式能将一长串if-then-else写得更加清晰。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch-no-condition.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := Now()</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">        fmt.Pringln(<span class="string">"Good morning!"</span>)</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Good afternoon."</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Good evening."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>defer语句会将函数推迟到外层函数返回之后执行。</p><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defer.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Pringln(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照<strong>后进先出</strong>的顺序调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defer-multi.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Pringln(<span class="string">"counting"</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Pringln(i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="更多类型"><a href="#更多类型" class="headerlink" title="更多类型"></a>更多类型</h3><p>学习如何基于现有类型定义新的类型，包含结构体、数组、切片和映射。</p><p><br></p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>go拥有指针。指针保存了值的内存地址。类型<code>*T</code>是指向T类型值的指针。其零值位nil。<code>&amp;</code>操作符会生成一个指向其操作数的指针。<code>*</code>操作符表示指针指向的底层值。这也就是常说的间接引用和重定向。</p><p>与C不同，go没有指针运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pointers.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i, j := <span class="number">42</span>, <span class="number">2701</span></span><br><span class="line"></span><br><span class="line">    p := &amp;i <span class="comment">// 指向i</span></span><br><span class="line">    fmt.Pringln(*p) <span class="comment">// 通过指针读取i的值</span></span><br><span class="line">    *p = <span class="number">21</span> <span class="comment">// 通过指针设置i的值</span></span><br><span class="line">    fmt.Pringln(i)</span><br><span class="line"></span><br><span class="line">    p = &amp;j</span><br><span class="line">    *p = *p /<span class="number">37</span></span><br><span class="line">    fmt.Pringln(j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>一个结构体(struct)就是一组字段(field)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// structs.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>结构体字段使用点号来访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct-fields.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    v.X = <span class="number">4</span></span><br><span class="line">    fmt.Println(v.X)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>结构体字段可以通过结构体指针来访问。</p><p>如果有一个指向结构体的指针P，那么可通过<code>(*p).X</code>来访问其字段X。不过这样写太啰嗦，可隐式间接引用，直接写<code>p.X</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct-pointers.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    p :=  &amp;v <span class="comment">// 指针</span></span><br><span class="line">    p.X = <span class="number">1e9</span></span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>结构体文法通过直接列出字段的值来新分配一个结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct-literals.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个Vertex类型的结构体</span></span><br><span class="line">    v2 = Vertex&#123;X: <span class="number">1</span>&#125; <span class="comment">// Y:0被隐式地赋予</span></span><br><span class="line">    v3 = Vertex&#123;&#125; <span class="comment">// X:0 Y:0</span></span><br><span class="line">    p = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个*Vertex类型的结构体(指针)</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(v1, p, v2, v3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>类型<code>[n]T</code>表示拥有n个T类型的值的数组。</p><p>数组的长度是其类型的一部分，因此数组不能改变大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">    a[<span class="number">0</span>] = “Hello<span class="string">"</span></span><br><span class="line"><span class="string">    a[1] = "</span>World<span class="string">"</span></span><br><span class="line"><span class="string">    fmt.Pringln(a[0], a[1])</span></span><br><span class="line"><span class="string">    fmt.Println(a)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125;</span></span><br><span class="line"><span class="string">    fmt.Println(primes)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>每个数组大小都是固定的，而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p><p>类型<code>[]T</code>表示一个元素类型为T的切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slices.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片并不存储任何数据，它只是描述了底层数组中的一段。更改切片的元素会修改其底层数组中对应的元素。与它共享底层数组的切片都会观测到这些修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slices-pointers.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    names := [<span class="number">4</span>]<span class="keyword">string</span>&#123;<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="string">"George"</span>, <span class="string">"Ringo"</span>,&#125;</span><br><span class="line">    fmt.Println(names)</span><br><span class="line"></span><br><span class="line">    a := names[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    b := names[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Pringln(a, b)</span><br><span class="line"></span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">"XXX"</span></span><br><span class="line">    fmt.Pringln(a, b)</span><br><span class="line">    fmt.Pringln(names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>切片文法类似于没有长度的数组文法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slice-literals.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125; <span class="comment">// 创建一个数组，并构建一个引用数组的切片</span></span><br><span class="line">    fmt.Pringln(q)</span><br><span class="line"></span><br><span class="line">    r := []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>&#125;</span><br><span class="line">    fmt.Pringln(r)</span><br><span class="line"></span><br><span class="line">    s := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        i <span class="keyword">int</span></span><br><span class="line">        b <span class="keyword">bool</span></span><br><span class="line">    &#125; &#123;</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="number">11</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">        &#123;<span class="number">13</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Pringln(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p><p>切片拥有长度和容量。切片的长度就是它所包含的元素个数。切片的容量从第一个元素开始数，到元素末尾的个数。</p><p>可通过<code>len()</code>和<code>cap()</code>来获取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slice-len-cap.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取切片使其长度为0</span></span><br><span class="line">    s = s[:<span class="number">0</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展长度</span></span><br><span class="line">    s = s[:<span class="number">4</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 舍弃前两个值</span></span><br><span class="line">    s = s[<span class="number">2</span>:]</span><br><span class="line">    printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"len=%d cap=%d %v\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>切片的零值<code>nil</code>。nil切片的长度和容量为0且没有底层数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nil-slices.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Pringln(<span class="string">"nil!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>切片可以使用内建函数<code>make</code>来创建，这也是创建动态数组的方式。<code>make</code>函数会分配一个元素为零值的数组并返回一个引用了它的切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// making-slices.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    PrintSlice(<span class="string">"a"</span>, a)</span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    printSlice(<span class="string">"b"</span>, b)</span><br><span class="line"></span><br><span class="line">    c := b[:<span class="number">2</span>]</span><br><span class="line">    printSlice(<span class="string">"c"</span>, c)</span><br><span class="line"></span><br><span class="line">    d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">    printSlice(<span class="string">"d"</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="keyword">string</span>, x []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s lend=%d cap=%d %v\n"</span>,</span><br><span class="line">        s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>切片可包含任何类型，甚至包括其他切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slices-of-slices.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"STRINGS"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个井字板</span></span><br><span class="line">    board := [][]<span class="keyword">string</span>&#123;</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>, <span class="string">"_"</span>&#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>, <span class="string">"_"</span>&#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>, <span class="string">"_"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个玩家轮流打上 x和o</span></span><br><span class="line">    board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">"X"</span></span><br><span class="line">    board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">"O"</span></span><br><span class="line">    board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line">    board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">"O"</span></span><br><span class="line">    board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(board); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, strings.Join(board[i], <span class="string">" "</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>向切片追加新的元素是常用的操作，为此go提供了内建的<code>append</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个空切片</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性添加多个元素</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"len=%d cap=%d %v\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>for循环的range形式可以遍历切片或映射。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 下标，元素副本</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"2**%d = %d\n"</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>可将下标或值赋予下划线(<code>_</code>)来忽略它。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pow</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> pow</span><br><span class="line"></span><br><span class="line"># 若只要索引，忽略第二个变量即可</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range-continued.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pow := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        pow[i] = <span class="number">1</span> &lt;&lt; <span class="keyword">uint</span>(i) <span class="comment">// == 2**i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>映射将键映射到值。映射的零值为<code>nil</code>。nil映射既没有键，也不能添加键。<code>make</code>函数会返回给定类型的映射，并将其初始化备用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maps.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">    m[<span class="string">"Bell Labs"</span>] = Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(m[<span class="string">"Bell Labs"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>映射的文法与结构体类似，不过必须有键名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map-literals.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">"Bell Labs"</span>: Vertex&#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>,&#125;,</span><br><span class="line">    <span class="string">"Google"</span>: Vertex&#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>若顶级类型只有一个类型名，可以在文法的元素中省略它。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map-literals-continued.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">"Bell Labs"</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">    <span class="string">"Google"</span>: &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>可对映射进行增删查改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 插入或修改</span><br><span class="line">m[key] = elem</span><br><span class="line"># 获取</span><br><span class="line">elem = m[key]</span><br><span class="line"># 删除</span><br><span class="line"><span class="built_in">delete</span>(m, key)</span><br><span class="line"></span><br><span class="line"># 通过双赋值检测某个键是否存在</span><br><span class="line">elem, ok = m[key]</span><br><span class="line"># 若 key 在 m 中，ok 为 <span class="literal">true</span> ；否则，ok 为 <span class="literal">false</span>。</span><br><span class="line"># 若 key 不在映射中，那么 elem 是该映射元素类型的零值。</span><br><span class="line"># 当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutating-maps.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    m[<span class="string">"Answer"</span>] = <span class="number">42</span></span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    m[<span class="string">"Answer"</span>] = <span class="number">48</span></span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">"Answer"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    v, ok := m[<span class="string">"Answer"</span>]</span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, v, <span class="string">"Present?"</span>, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h4><p>函数也是值。它们可以像其它值一样传递。</p><p>函数值可以用作函数的参数或返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function-values.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(compute(hypot))</span><br><span class="line">    fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h4><p>go函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量绑定在一起。</p><p>例如，函数adder返回一个闭包。每个闭包都被绑定在其各自的sum变量上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functtion-closures.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        sum += x</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pos, neg := adder(), adder()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(</span><br><span class="line">            pos(i),</span><br><span class="line">            neg(<span class="number">-2</span>*i),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>斐波那契闭包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fibonacci-closure.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个int函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := fibonacci()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h3><p>docs: <a href="https://tour.go-zh.org/methods/1" target="_blank" rel="noopener">https://tour.go-zh.org/methods/1</a></p><p>包含方法和接口，可以用这种构造来定义对象及其行为。</p><p><br></p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>go没有类。</p><p>不过你可以为结构体类型定义方法。方法就是一类带特殊的接收者参数的函数。方法接收者在它自己的参数列表内，位于func关键字和方法名之间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methods.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Abs方法拥有一个名为v，类型为Vertex的接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>方法只是个带接收者参数的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// metheods-funcs.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y float</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>也可以为非结构体类型声明方法。接收者的类型定义和方法声明必须在同一包内，不能为内建类型声明方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methods-continued.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h4><p>可以为指针接收者声明方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methods-pointers.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v, Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    v.Scale(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methods-pointers-explained.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span><span class="params">(v *Vertex, f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    x.Y = x.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    Scale(&amp;v, <span class="number">10</span>)</span><br><span class="line">    fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// indirection.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    x.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScaleFunc</span><span class="params">(v *Vertex, f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = V.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    v.Scale(<span class="number">2</span>)</span><br><span class="line">    ScaleFunc(&amp;v, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">    p.Scale(<span class="number">3</span>)</span><br><span class="line">    ScaleFunc(p, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(v, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// indirection-values.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AbsFunc</span><span class="params">(v Vertex)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">    fmt.Println(AbsFunc(v))</span><br><span class="line"></span><br><span class="line">    p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(p.Abs())</span><br><span class="line">    fmt.Println(AbsFunc(*p))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="选择值或指针作为接收者"><a href="#选择值或指针作为接收者" class="headerlink" title="选择值或指针作为接收者"></a>选择值或指针作为接收者</h4><p>使用指针接收者的原因有二：</p><ul><li>方法能够修改其接收者指向的值</li><li>可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methods-pointer-receivers.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Before scaling: %+v, Abs: %v\n"</span>, v, v.Abs())</span><br><span class="line">    v.Scale(<span class="number">5</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"After scaling: %+v, Abs: %v\n"</span>, v, v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口类型是由一组方法签名定义的集合。接口类型的变量可以保存任何实现了这些方法的值。</p><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有<code>implements</code>关键字。隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces-implicitly.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法表示类型T实现了接口I，但我们无需显式声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i I = T&#123;<span class="string">"Hello"</span>&#125;</span><br><span class="line">    i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>接口也是值。它们可以像其它值一样传递。接口值可以用作函数的参数或返回值。</p><p>在内部，接口值可以看做包含值和具体类型的元组：<code>(value, type)</code>。接口值保存了一个具体底层类型的具体值。接口值调用方法时会执行其底层类型的同名方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface-values.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line">    i = &amp;T[<span class="string">"Hello"</span>]</span><br><span class="line">    describe(i)</span><br><span class="line">    i.M()</span><br><span class="line"></span><br><span class="line">    i = F(math.Pi)</span><br><span class="line">    describe(i)</span><br><span class="line">    i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"(%v, %T)\n"</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>底层值为nil的接口值。</p><p>即便接口内的具体值为nil， 方法仍然会被nil接收者调用。注意，保存了nil具体值的接口其自身并不为nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface-values-nil.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    S tring</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"&lt;nil&gt;"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t *T</span><br><span class="line">    i = t</span><br><span class="line">    describe(i)</span><br><span class="line">    i.M()</span><br><span class="line"></span><br><span class="line">    i = &amp;T&#123;<span class="string">"hello"</span>&#125;</span><br><span class="line">    describe(i)</span><br><span class="line">    i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"(%v, %T)\n"</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="nil接口值"><a href="#nil接口值" class="headerlink" title="nil接口值"></a>nil接口值</h4><p>nil接口值既不保存值也不保存具体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nil-interface-values.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i I</span><br><span class="line">    describe(i)</span><br><span class="line">    i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"(%v, %T)\n"</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p>指定了零个方法的接口值被称为<strong>空接口</strong>: <code>interface{}</code></p><p>空接口可保存任何类型的值，因为每个类型都至少实现了零个方法。空接口被用来处理未知类型的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// empty-interface.go</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var i interface&#123;&#125;</span><br><span class="line">    describe(i)</span><br><span class="line"></span><br><span class="line">    i = 42</span><br><span class="line">    describe(i)</span><br><span class="line"></span><br><span class="line">    i = &quot;hello&quot;</span><br><span class="line">    describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func describe(i interface&#123;&#125;) &#123;</span><br><span class="line">    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>类型断言提供了访问接口值底层具体值的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 该语句断言接口值i保存了具体类型T，并将其底层类型为T的值赋予变量t</span><br><span class="line">t := i.(T)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 类型断言可返回两个值</span><br><span class="line">// 底层值以及一个报告断言是否成功的布尔值</span><br><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type-assertions.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">    s := i.(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Pringln(s)</span><br><span class="line"></span><br><span class="line">    s, ok := i.(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">    f, ok := i.(<span class="keyword">float64</span>)</span><br><span class="line">    fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">    f = i.(<span class="keyword">float64</span>) <span class="comment">// 报错(panic)</span></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h4><p>类型选择是一种按顺序从几个类型断言中选择分支的结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type-switches.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Twice $v is %v\n"</span>, v, v*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%q is %v bytes long\n"</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"I don't how about type %T!\n"</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do(<span class="number">21</span>)</span><br><span class="line">    do(<span class="string">"hello"</span>)</span><br><span class="line">    do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h4><p><code>fmt</code>包中定义的<code>Stringer</code>是最普遍的接口之一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// stringer.go</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">    Age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p Person) String() string &#123;</span><br><span class="line">    return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a := Person&#123;&quot;Arthur Dent&quot;, 42&#125;</span><br><span class="line">    z := Person&#123;&quot;Zaphod Beeb12brox&quot;, 9001&#125;</span><br><span class="line">    fmt.Println(a, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>go程序使用<code>error</code>值来表示错误状态，它是一个内建接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// errors.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    When time.Time</span><br><span class="line">    What <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"at %v, %s"</span>,</span><br><span class="line">        e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">        time.Now(),</span><br><span class="line">        <span class="string">"it didn't work"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p><code>io</code>包指定了<code>io.Reader</code>接口，它表示从数据流的末尾进行读取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reader.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := strings.NewReader(<span class="string">"Hello, Reader!"</span>)</span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := r.Read(b)</span><br><span class="line">        fmt.Printf(<span class="string">"n = %v err = %v b = %v\n"</span>, n, err, b)</span><br><span class="line">        fmt.Printf(<span class="string">"b[:n] = %q\n"</span>, b[:n])</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><p><code>image</code>包定义了<code>Image</code>接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// images.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"image"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := image.NewRGBA(image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line">    fmt.Println(m.Bounds())</span><br><span class="line">    fmt.Println(m.At(<span class="number">0</span>, <span class="number">0</span>).RGBA())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>doc: <a href="https://tour.go-zh.org/concurrency/1" target="_blank" rel="noopener">https://tour.go-zh.org/concurrency/1</a></p><p>作为语言的核心部分，go提供了并发的特性。这一部分概览了goroutine和channel，以及如何使用它们来实现不同的并发模式。</p><p><br></p><h4 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h4><p>go程(goroutine)是由go运行时管理的轻量级线程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> f(x, y, z)</span><br><span class="line"># 会启动一个新的goroutine并执行</span><br><span class="line">f(x, y, z)</span><br><span class="line"># f, x, y, z的求值发生在goroutine中</span><br><span class="line"># 而f的执行发生在新的goroutine中</span><br></pre></td></tr></table></figure><p>goroutine在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goroutines.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">"world"</span>)</span><br><span class="line">    sqy(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h4><p>信道是带有类型的管道，通过它用信道操作符<code>&lt;-</code>来发送或接收值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信道在使用前必须创建</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头就是数据流的方向</span></span><br><span class="line">ch &lt;- v   <span class="comment">// 将v发送至信道ch</span></span><br><span class="line">v := &lt;-ch <span class="comment">// 从ch接收值并赋予v</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// channels.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- sum <span class="comment">// 将和送入c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c <span class="comment">// 从c中接收</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="带缓冲的信道"><a href="#带缓冲的信道" class="headerlink" title="带缓冲的信道"></a>带缓冲的信道</h4><p>将缓冲长度作为第二个参数提供给<code>make</code>来初始化一个带缓冲的信道，仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buffered-channels.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    <span class="comment">// ch &lt;- 3 填满缓冲区</span></span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p>发送者可通过<code>close</code>关闭一个信道来表示没有需要发送的值。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭。</p><p>只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌(panic)。信道与文件不同，通常情况下不需要关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个range循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若没有值可接收且信道已关闭，在执行完后,ok会被设置为false</span></span><br><span class="line">v, ok := &lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环for i := range c会不断从信道接收值，直到它关闭</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range-and-close.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x+y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select语句使一个go routine可以等待多个通信操作。<br>它会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">                x, y = y, x+y</span><br><span class="line">            <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">                fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>当select中的其它分支都没有转杯好时，default分支就会执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default-selection.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tick := time.Tick(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    boom := time.After(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tick:</span><br><span class="line">            fmt.Println(<span class="string">"tick."</span>)</span><br><span class="line">        <span class="keyword">case</span> &lt;-boom:</span><br><span class="line">            fmt.Println(<span class="string">"BOOM!"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"    ."</span>)</span><br><span class="line">            time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>信道非常适合在各个Go routine间进行通信。但如果并不需要通信，只想保证每次只有一个go routine能够访问一个共享的变量，从而避免冲突。</p><p>这里面涉及的概念就做<strong>互斥</strong>(mutual exclusion)，通常使用<strong>互斥锁</strong>(Mutex)这一数据结构来提供这种机制。go标准库提供了<code>sync.Mutex</code>互斥锁及其两个方法: <code>Lock</code>, <code>Unlock</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutex-counter.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter 的并发使用是安全的</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">    v <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 增加给定 key 的计数器的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Inc</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    <span class="comment">// Lock 之后同一时刻只有一个 go routine 能访问c.v</span></span><br><span class="line">    c.v[key]++</span><br><span class="line">    c.mux.Unlocak</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 返回给定key的计数器的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    <span class="comment">// Lock之后同一时刻只有一个 go routine 能访问c.v</span></span><br><span class="line">    <span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> c.Inc(<span class="string">"somekey"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(c.Value(<span class="string">"somekey"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="如何编写go代码"><a href="#如何编写go代码" class="headerlink" title="如何编写go代码"></a>如何编写go代码</h2><p>doc: <a href="https://golang.org/doc/code.html" target="_blank" rel="noopener">https://golang.org/doc/code.html</a></p><p><br></p><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>本文介绍如何开发一个模块内的一组简单的go包集合，并使用go工具，以标准的方式去fetch, build, install go modules, packages, commands。</p><blockquote><p>注意:<br><br>本文使用go <code>v1.13+</code>，并且没有设置<code>GO111MODULE</code>环境变量。</p></blockquote><p><br><br><br></p><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p>go程序被组织到包。包是编译在同一目录中的源文件的集合。定义在一个源文件中的函数、类型、变量、常量对同一个包中的其它源文件可见。</p><p>一个仓库(repo)包含一个或多个模块。模块是发布到一起关联go包的集合。一个go仓库通常只包含一个模块，位于该库的根目录。<code>go.mod</code>文件声明了模块路径，该模块内所有包的导入路径前缀。该模块包含了<code>go.mod</code>文件此目录及其子目录的包。</p><p>注意，在你可以构建之前，你并不需要将代码发布到远程仓库。一个模块可以定义在本地而不属于一个仓库。然而，如果你某天希望发布你的代码，那么组织你的代码是一个很好的习惯。</p><p>每个模块的路径不仅作为其包的导入路径前缀，也预示着go命令在哪里下载它。例如，要下载<code>golang.org/x/tools</code>模块，go命令会通过协商表示<code>https://golang.org/x/tools</code>。</p><p>导入路径是用来导入包的字符串。一个包的导入路径是它和模块内子目录的加入模块的路径。例如，模块<code>github.com/google/go-cmp</code>在<code>cmp/</code>目录下包含一个包，这个包的导入路径是<code>github.com/google/go-cmp/cmp</code>。标准库中的包没有模块路径前缀。</p><p><br><br><br></p><h3 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h3><p>要编译和运行一个简单的程序，首先要选择一个模块路径（如<code>example.com/user/hello</code>）并创建一个<code>go.mod</code>文件来声明它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">make hello</span><br><span class="line">cd hello</span><br><span class="line"></span><br><span class="line">go mod init example.com/user/hello</span><br><span class="line">go: creating new go.mod: module example.com/user/hello</span><br><span class="line"></span><br><span class="line">cat go.mod</span><br><span class="line">module example.com/user/hello</span><br><span class="line"></span><br><span class="line">go 1.14</span><br></pre></td></tr></table></figure><p><br></p><p>go源文件的第一个语句必须是包名(package name)。可执行命令必须使用<code>package main</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello, world."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在你可以使用go工具来构建和安装程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install example/user/hello</span><br></pre></td></tr></table></figure><p>此命令构建<code>hello</code>命令，产生一个可执行二进制文件，安装此二进制到<code>$HOME/go/bin/hello</code>。</p><p>安装目录由<code>GOPATH</code>和<code>GOBIN</code>环境变量控制。如果<code>GOBIN</code>有设置，则安装到它这个目录。如果<code>GOPATH</code>有设置，二进制被安装到<code>$GOPATH/bin/</code>下。否则，二进制文件被安装到默认<code>$GOPATH/bin</code>目录下。</p><p>可以使用<code>go env</code>命令来设置和取消环境变量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 设置</span><br><span class="line">go env -w GOBIN=/somewhere/else/bin</span><br><span class="line"></span><br><span class="line"># 取消</span><br><span class="line">go env -u GOBIN</span><br></pre></td></tr></table></figure><p><br></p><p>像<code>go install</code>这样的命令应用在包含当前工作目录的模块上下文内。如果当前工作目录不在<code>example.com/user/hell</code>模块内，则<code>go install</code>命令可能会失败。</p><p>为了方便，如果没有给定其它路径，go命令接收相对于当前工作目录的路径，默认为包的当前路径。因此，在当前工作目录下，下面的命令是等效的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go install example.com/user/hello</span><br><span class="line"></span><br><span class="line">go install .</span><br><span class="line"></span><br><span class="line">go install</span><br></pre></td></tr></table></figure><p><br></p><p>接下来，让我们运行此程序以确保它工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:$(dirname $(go list -f &apos;&#123;&#123;.Target&#125;&#125;&apos; .))</span><br><span class="line">hello</span><br><span class="line">Hello, world</span><br></pre></td></tr></table></figure><p><br></p><p>如果你在使用版本控制，那现在是初始化仓库，添加文件并提交你的第一个变化的好时机。这一步是可选的，你不需要使用版本控制编写go代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go init</span><br><span class="line"></span><br><span class="line">git add go.mod hello.go</span><br><span class="line">git commit -m &quot;initial commit&quot;</span><br></pre></td></tr></table></figure><p>go命令通过请求HTTPS URL和从HTML响应中读取元数据来定位仓库包含的模块路径(<code>go help importpath</code>)。许多托管服务已经提供了包含go代码的元数据，使你的模块对其他人可用的最简单的方法通常是——使模块路径匹配仓库URL。</p><p><br><br><br></p><h4 id="从你的模块导入包"><a href="#从你的模块导入包" class="headerlink" title="从你的模块导入包"></a>从你的模块导入包</h4><p>Importing packages from your module</p><p>让我们编写一个<code>morestrings</code>包，并从<code>hello</code>程序来使用它。首先，为包创建一个目录<code>$HOME/hello/morestrings</code>，并在目录下编写<code>reverse.go</code>源文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package morestrings implements additional functions to manipulate UTF-8</span></span><br><span class="line"><span class="comment">// encoded strings, beyond what is provided in the standard "strings" package.</span></span><br><span class="line"><span class="keyword">package</span> morestrings</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReverseRunes returns its argument string reversed rune-wise left to right.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseRunes</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">r := []<span class="keyword">rune</span>(s)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">r[i], r[j] = r[j], r[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试并使用<code>go build</code>来编译包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd hello/morestrings</span><br><span class="line"></span><br><span class="line">go build</span><br></pre></td></tr></table></figure><p>这不会生成一个输出文件。相反，它在本地构建缓存(local build cache)中保存编译包(compiled package)。</p><p>在确认了<code>morestrings</code>包构建之后，让我们修改<code>hello.go</code>来使用morestrings包:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"example.com/usr/hello/morestrings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(morestrings.ReverseRunes(<span class="string">"!oG ,0lleH"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// install hello</span><br><span class="line">go install example.com/user/hello</span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line">Hello, Go!</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="从远程模块导入包"><a href="#从远程模块导入包" class="headerlink" title="从远程模块导入包"></a>从远程模块导入包</h4><p>Importing packages from remote modules</p><p>导入路径可以描述如何使用版本控制获得源代码。go工具使用该属性从远程仓库自动获取包。比如，在程序中使用<code>github.com/google/go-cmp/cmp</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"example.com/user/hello/morestrings"</span></span><br><span class="line">    <span class="string">"github.com/google/go-cmp/cmp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(morestrings.ReverseRunes(<span class="string">"!oG ,olleH"</span>))</span><br><span class="line">fmt.Println(cmp.Diff(<span class="string">"Hello World"</span>, <span class="string">"Hello Go"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你运行<code>go install</code>, <code>go build</code>, <code>go run</code>这些命令时，go命令会自动下载远程模块并在<code>go.mod</code>文件中记录版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go install example.com/user/hello</span><br><span class="line">go: finding module for package github.com/google/go-cmp/cmp</span><br><span class="line">go: downloading github.com/google/go-cmp v0.4.0</span><br><span class="line">go: found github.com/google/go-cmp/cmp in github.com/google/go-cmp v0.4.0</span><br><span class="line">$ hello</span><br><span class="line">Hello, Go!</span><br><span class="line">  string(</span><br><span class="line">- &quot;Hello World&quot;,</span><br><span class="line">+ &quot;Hello Go&quot;,</span><br><span class="line">  )</span><br><span class="line">$ cat go.mod</span><br><span class="line">module example.com/user/hello</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line">require github.com/google/go-cmp v0.4.0</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>模块依赖关系自动下载到<code>$GOPATH/pkg/mod</code>目录。一个模块的特定版本的下载内容，要求该版本与所有其它模块之间共享，因此go命令标记目录和文件为只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除所有下载的模块</span><br><span class="line">go clean --modcache</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>go有一个轻量测试框架<code>go test</code>命令和<code>testing</code>包。</p><p>你可以通过创建一个以<code>_test.go</code>名称结尾的文件来编写一个测试，此测试文件包含以<code>func (t *testing.T)</code>签名的<code>TestXXX</code>函数。测试框架运行每个这样的函数，如果此函数调用一个失败的函数（如<code>t.Error</code>或<code>t.Fail</code>），则测试被认为失败。</p><p>通过创建包含以下代码的<code>morestrings/reverse_test.go</code>文件，对<code>morestrings</code>包添加一个测试。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"test"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverseRunes</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        in, want <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">"Hello, world"</span>, <span class="string">"dlrow ,olleH"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Hello, 世界"</span>, <span class="string">"界世 ,olleH"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">""</span>, <span class="string">""</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">        got := ReverseRunes(c.in)</span><br><span class="line">        <span class="keyword">if</span> got != c.want &#123;</span><br><span class="line">            t.Errorf(<span class="string">"ReverseRunes(%q) == %q, want %q, c.in, got, c.want"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着使用<code>go test</code>运行测试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go test</span><br><span class="line">PASS</span><br><span class="line">ok  example.com/user/morestrings 0.165s</span><br><span class="line">$</span><br><span class="line"></span><br><span class="line"># 帮助</span><br><span class="line">go help test</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="ide和插件"><a href="#ide和插件" class="headerlink" title="ide和插件"></a>ide和插件</h2><p>doc: <a href="https://golang.org/doc/editors.html" target="_blank" rel="noopener">https://golang.org/doc/editors.html</a></p><ul><li>vim-go: <a href="https://github.com/fatih/vim-go" target="_blank" rel="noopener">https://github.com/fatih/vim-go</a></li><li>Visual Studio Code: <a href="https://marketplace.visualstudio.com/items?itemName=golang.Go" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=golang.Go</a></li></ul><p><br></p><p>我是用的k-vim已经添加了vim-go，只需要将<code>let g:bundle_groups=</code>中添加golang即可。</p><p><br><br><br><br><br></p><h2 id="高效go编程"><a href="#高效go编程" class="headerlink" title="高效go编程"></a>高效go编程</h2><p>Effective Go: <a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">https://golang.org/doc/effective_go.html</a></p><p><br></p><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>Go是一门新语言。要把go写好，了解其性质和惯用语法是很重要的。同样重要的是要知道在go中程序所建立的约定。如命名、格式、项目建设等，让你写的程序会很容易为其他go程序员所理解。</p><p>此文档对编写清晰、惯用的go代码给出了一些技巧。</p><p><br><br><br></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="https://golang.org/src/" target="_blank" rel="noopener">go package sources</a> 不仅作为核心库，而且为如何使用语言做了示例。</p><p><br><br><br></p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>格式问题最具争议，但却始终没有形成统一的定论。若所有人都遵循相同的编码风格，在这类问题上浪费的时间将会更少。</p><p>在go中我们另辟蹊跷，让机器来处理大部分的格式问题。<code>gofmt</code>程序将go程序安装标准风格 进行缩进、对齐，保留注释并在需要时重新格式化。</p><p>举例来说，你无需花时间将结构体中的字段对其，<code>gofmt</code>将会为你代劳。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="keyword">string</span> <span class="comment">// 对象名</span></span><br><span class="line">        value <span class="keyword">int</span> <span class="comment">// 对象值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gofmt</code>会将它按列对齐：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">        name    <span class="keyword">string</span> <span class="comment">// 对象名</span></span><br><span class="line">        value   <span class="keyword">int</span>    <span class="comment">// 对象值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准包中的所有go代码都已经用<code>gofmt</code>格式化过了。一些关于格式化的细节：</p><ul><li><p>缩进(Indentation)<br>使用制表符<code>tab</code>，<code>gofmt</code>也默认使用它。在你认为有必要的时候使用空格符(space)。</p></li><li><p>行长度(Line length)<br>go对行长度没有限制。如果一行实在太长，可以拆行并插入适当的tab缩进。</p></li><li><p>括号(Parentheses)<br>比起C和Java，Go所需的括号更少。控制结构(<code>if, for, switch</code>)在语法上并不需要圆括号。此外，操作符优先级处理变得更加简洁：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&lt;&lt;<span class="number">8</span> + y&lt;&lt;<span class="number">16</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>go提供了C风格的块注释(<code>/* */</code>)和c++风格的行注释(<code>//</code>)。</p><p>godoc既是一个程序，又是一个Web服务器，它对go源码进行处理，并提取包中的文档内容。出现在顶级声明之前，且与该声明之间没有空行的注释，将与该声明一起被提取出来，作为该条目的说明文档。让我想起了Python的文档字符串(docstring)。</p><p>每个包都应包含一个包说明(package comment)——即放置在包子句前的一个块注释。对于包含多个文件的包，包注释只需出现在其中的任一文件中即可。包注释应在整体上对该包进行介绍，并提供包的相关信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">regexp 包为正则表达式实现了一个简单的库。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">它接受的正则表达式语法为：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    正则：</span></span><br><span class="line"><span class="comment">        串联 &#123; '|' 串联&#125;</span></span><br><span class="line"><span class="comment">    串联：</span></span><br><span class="line"><span class="comment">        &#123; 闭包 &#125;</span></span><br><span class="line"><span class="comment">    闭包：</span></span><br><span class="line"><span class="comment">        条目 [ '*' | '+' | '?' ]</span></span><br><span class="line"><span class="comment">    条目：</span></span><br><span class="line"><span class="comment">        '^'</span></span><br><span class="line"><span class="comment">        '$'</span></span><br><span class="line"><span class="comment">        '.'</span></span><br><span class="line"><span class="comment">        字符</span></span><br><span class="line"><span class="comment">        '[' [ '^' ] 字符遍历 ']'</span></span><br><span class="line"><span class="comment">        '(' 正则表达式 ')'</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> regexp</span><br></pre></td></tr></table></figure><p>如果包比较简单，包说明可以简洁些：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package path implements utility routines for</span></span><br><span class="line"><span class="comment">// manipulating slash-separated filename paths.</span></span><br></pre></td></tr></table></figure><p>注释无需额外的格式化。<code>godoc</code>会像<code>gofmt</code>一样处理好一切。注释是不会被解析的纯文本，因此特定的格式不会被渲染。<code>godoc</code>是否会重新格式化注释取决于上下文，因此必须确保它看起来清晰易辨：使用正确的拼写、标点、句子结构以及折叠长行等。</p><p>在包中，任何顶级声明前的注释都作为该声明的文档说明。每个可导出名称的程序(首字母大写)都有该用文档说明。这让我想起了Python的类。</p><p>文档注释最好是完整的句子，这样它才能适应各种自动化的展示。 第一句应当以被声明的东西开头，并且是单句的摘要。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compile parses a regular expression and returns, if successful,</span></span><br><span class="line"><span class="comment">// a Regexp that can be used to match against text.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(*Regexp, error)</span></span> &#123;</span><br></pre></td></tr></table></figure><p>若注释总是以名称开头，<code>godoc</code>的输出就能通过<code>grep</code>变得更加有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go doc -all regexp | grep -i parse</span><br></pre></td></tr></table></figure><p>go的声明语法允许成组声明。单个文档注释应介绍一组相关的常量或变量。 由于是整体声明，这种注释往往较为笼统。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error codes returned by failures to parse an expression.</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrInternal      = errors.New(<span class="string">"regexp: internal error"</span>)</span><br><span class="line">    ErrUnmatchedLpar = errors.New(<span class="string">"regexp: unmatched '('"</span>)</span><br><span class="line">    ErrUnmatchedRpar = errors.New(<span class="string">"regexp: unmatched ')'"</span>)</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>即便是对于私有名称，也可通过成组声明来表明各项间的关系，例如某一组由互斥体保护的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    countLock   sync.Mutex</span><br><span class="line">    inputCount  <span class="keyword">uint32</span></span><br><span class="line">    outputCount <span class="keyword">uint32</span></span><br><span class="line">    errorCount  <span class="keyword">uint32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>names</p><p>命名在编程语言中很重要！</p><p><br></p><h4 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h4><p>package names</p><p>当一个包被导入后，包名就会成为内容的访问器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"bytes</span></span><br></pre></td></tr></table></figure><p>包的名称应该简洁明了以便于理解。按照惯例，包应当以小写的单个单词来命名，且不应该使用下划线或驼峰记法(mixedCaps)。包名是就是导入时所需的默认名称，它并不需要在所有源码中保持唯一，即使在少数发生冲突的情况下，也可为导入的包选择一个别名来局部使用。无论如何，通过文件名来判定使用的包，基本不会产生混淆。</p><p>另一个约定就是包名应为其源码目录的基本名称。在<code>src/encoding/base64</code>中的包应作为<code>encoding/base64</code>导入，其包名为<code>base64</code>，而非<code>encoding_base64</code>或<code>encodingBase64</code>。</p><p>包的导入者可通过包名来引用其内容，因此包中的可导出名称可以此来避免冲突。请勿使用<code>import .</code>记法，它可以简化必须在被测试包外运行的测试， 除此之外应尽量避免使用。</p><p>另一个简短的例子是<code>once.Do</code>，<code>once.Do(setup)</code>表述足够清晰， 使用<code>once.DoOrWaitUntilDone(setup)</code>完全就是画蛇添足。 长命名并不会使其更具可读性。一份有用的说明文档通常比额外的长名更有价值。</p><p><br><br><br></p><h4 id="获取器"><a href="#获取器" class="headerlink" title="获取器"></a>获取器</h4><p>Getters</p><p>Go并不对获取器（getter）和设置器（setter）提供自动支持。 你应当自己提供获取器和设置器，通常很值得这样做，但若要将 Get 放到获取器的名字中，既不符合习惯，也没有必要。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">owner := obj.Owner()</span><br><span class="line"><span class="keyword">if</span> owner != user &#123;</span><br><span class="line">obj.SetOwner(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="接口名"><a href="#接口名" class="headerlink" title="接口名"></a>接口名</h4><p>Interface names</p><p>按照约定，只包含一个方法的接口应当以该方法的名称加上<code>-er</code>后缀来命名，如<code>Reader</code>、<code>Writer</code>、 <code>Formatter</code>、<code>CloseNotifier</code>等。</p><p><br><br><br></p><h4 id="驼峰记法"><a href="#驼峰记法" class="headerlink" title="驼峰记法"></a>驼峰记法</h4><p>MixedCaps</p><p>最后，go中约定使用<code>MexedCaps</code>或<code>mixedCaps</code>而不是下划线来编写多个词的名字。</p><p><br><br><br></p><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>Semicolons</p><p>和C一样，Go的正式语法使用分号(<code>;</code>)来结束语句。但和C不同的是，这些分号不会出现在源码中。取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此大部分输入文本是自由的。</p><p>若在新行前的最后一个标记为一个标识符(包括<code>int</code>, <code>float64</code>)，数值或字符串常量的基本字面或以下标记之一:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break continue fallthrough return ++ -- ) &#125;</span><br></pre></td></tr></table></figure><p>词法分析器将始终在该标记后面插入一个分号。这可以概括为：<strong>如果新行前的标记为语句的末尾，则插入一个分号</strong>。</p><p>分号也可以在关闭括号之前直接省略，因此一个语句像如下这样，不需要分号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go func() &#123; for &#123; dst &lt;- &lt;-src &#125; &#125;()</span><br></pre></td></tr></table></figure><p>通常go程序只在诸如<code>for</code>循环子句这样的地方使用分号。如果在一行中写多个语句，也需要使用分号分隔。</p><p>无论如何，你都不应该将控制结构(<code>if, for, switch, select</code>)的左括号放到下一行。你应该这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &lt; f() &#123;</span><br><span class="line">    g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &lt; f() <span class="comment">// wrong!</span></span><br><span class="line">&#123;          <span class="comment">// wrong!</span></span><br><span class="line">    g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><p>Control structures</p><p>go的控制结构与C有许多相似之处，但其不同才是独到之处。go不使用<code>do</code>或<code>while</code>循环，只有一个更通用的<code>for</code>；<code>switch</code>要更灵活些；<code>if</code>和<code>switch</code>像<code>for</code>一样接受一个可选的初始化语句；<code>break</code>和<code>continue</code>语句有一个可选的标签来确定那些break或continue；此外，还有一个包含类型选择和多路通信复用器的新控制结构——<code>select</code>。它们的语法也有些许不同，没有圆括号，主体必须始终使用大括号括住。</p><p><br></p><h4 id="if-1"><a href="#if-1" class="headerlink" title="if"></a>if</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>if</code>和<code>switch</code>可接收初始化语句，因此用它们来设置局部变量很常见。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := file.Chmod(<span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Print(err)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="重新声明和重新赋值"><a href="#重新声明和重新赋值" class="headerlink" title="重新声明和重新赋值"></a>重新声明和重新赋值</h4><p>Redeclaration and reassignment</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line"></span><br><span class="line">d, err := f.Stat()</span><br></pre></td></tr></table></figure><p>满足下列条件时，已被声明的变量可出现在<code>:=</code>声明中：</p><ul><li>本次声明与已声明的变量出于同一作用域（若变量已在外层作用域中声明过，则此次声明会创建一个新的变量<code>§</code>）</li><li>在初始化中与其类型相应的值才能赋予变量，且在此次声明中至少另有一个变量是新声明的</li></ul><p><br><br><br></p><h4 id="for-1"><a href="#for-1" class="headerlink" title="for"></a>for</h4><p>go的<code>for</code>循环统一了for和while。它有三种形式，但只有一种需要分号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Like a C for</span></span><br><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like a C while</span></span><br><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like a C for(;;)</span></span><br><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>简短的声明使得更容易在循环中声明下标变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若你想遍历数组、切片、字符串、映射，或从信道中读取消息，<code>range</code>子句能够帮你轻松实现循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要遍历下标，去掉第二个</span></span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m &#123;</span><br><span class="line">    <span class="keyword">if</span> key.expired() &#123;</span><br><span class="line">        <span class="built_in">delete</span>(m, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要值，使用空白标识符(_)来丢弃下标</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> array &#123;</span><br><span class="line">        sum += value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="switch-1"><a href="#switch-1" class="headerlink" title="switch"></a>switch</h4><p>go的<code>switch</code>比C更通用。其表达式无需为常量或整数，<code>case</code>语句会自上而下逐一进行求值直到匹配为止。如果<code>switch</code>后面没有表达式，它将匹配<code>true</code>。因此，我们可以将<code>if-else-if-else</code>链写成一个<code>switch</code>，这也更符合go的风格。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unhex</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'0'</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'f'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="number">10</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'F'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code>并不会自动下溯，但<code>case</code>可通过逗号分隔来列举相同的处理条件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldEscape</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> c &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">' '</span>, <span class="string">'?'</span>, <span class="string">'&amp;'</span>, <span class="string">'='</span>, <span class="string">'#'</span>, <span class="string">'+'</span>, <span class="string">'%'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>break</code>语句可以使<code>switch</code>提前终止。不仅是<code>switch</code>，有时候也需要打破层层的循环。在go中，只需将标签(label)放置到循环外，然后break到标签。下例展示了两者的用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Loop:</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="built_in">len</span>(src); n += size &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> src[n] &lt; sizeOne:</span><br><span class="line"><span class="keyword">if</span> validateOnly &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">size = <span class="number">1</span></span><br><span class="line">update(src[n])</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> src[n] &lt; sizeTwo:</span><br><span class="line"><span class="keyword">if</span> n+<span class="number">1</span> &gt;= <span class="built_in">len</span>(src) &#123;</span><br><span class="line">err = errShortInput</span><br><span class="line"><span class="keyword">break</span> Loop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> validateOnly &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">size = <span class="number">2</span></span><br><span class="line">update(src[n] + src[n+<span class="number">1</span>]&lt;&lt;shift)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<code>continue</code>语句也能接受一个可选的标签，不过它只能应用在循环中。</p><p>作为这一节的结束，下例使用两个switch语句对字节切片进行比较：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compare returns an integer comparing the two byte slices,</span></span><br><span class="line"><span class="comment">// lexicographically.</span></span><br><span class="line"><span class="comment">// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compare</span><span class="params">(a, b []<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a) &amp;&amp; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> a[i] &gt; b[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> a[i] &lt; b[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">len</span>(a) &gt; <span class="built_in">len</span>(b):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">len</span>(a) &lt; <span class="built_in">len</span>(b):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="类型选择-1"><a href="#类型选择-1" class="headerlink" title="类型选择"></a>类型选择</h4><p>type switch</p><p><code>switch</code>也可用于判断接口变量的动态类型。如type switch通过括号中的关键字<code>type</code>使用类型断言。若<code>switch</code>在表达式中声明了一个变量，那么该变量的每个子句中都将有该变量对应的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"unexpected type %T\n"</span>, t)     <span class="comment">// %T prints whatever type t has</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"boolean %t\n"</span>, t)             <span class="comment">// t has type bool</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"integer %d\n"</span>, t)             <span class="comment">// t has type int</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"pointer to boolean %t\n"</span>, *t) <span class="comment">// t has type *bool</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"pointer to integer %d\n"</span>, *t) <span class="comment">// t has type *int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>function</p><p><br></p><h4 id="多值返回-1"><a href="#多值返回-1" class="headerlink" title="多值返回"></a>多值返回</h4><p>multiple return values</p><p>以下简单的函数可从字节数组中的特定位置获取其值，并返回该数值和下一个位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextInt</span><span class="params">(b []<span class="keyword">byte</span>, i <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(b) &amp;&amp; !isDigit(b[i]); i++ &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    x := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(b) &amp;&amp; isDigit(b[i]); i++ &#123;</span><br><span class="line">        x = x*<span class="number">10</span> + <span class="keyword">int</span>(b[i]) - <span class="string">'0'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x, i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取多值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); &#123;</span><br><span class="line">    x, i = nextInt(b, i)</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="命名结果形参"><a href="#命名结果形参" class="headerlink" title="命名结果形参"></a>命名结果形参</h4><p>Named result parameters</p><p>go函数的返回值(return)或结果(result)<strong>行参</strong>可被命名，并作为常规变量使用。就像传入的形参一样。命名后，一旦该函数开始执行，它们就会被初始化为与其类型相应的零值；若该函数执行了一条不带参数的<code>return</code>语句，则结果形参的当前值将作为返回值。</p><p>此名称不是强制性的，但它们能使代码更加简洁明了：它们就是文档。如果我们命名了nextInt的结果，那么它返回的int就值如其意了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextInt</span><span class="params">(b []<span class="keyword">byte</span>, pos <span class="keyword">int</span>)</span> <span class="params">(value, nextPos <span class="keyword">int</span>)</span></span> &#123;</span><br></pre></td></tr></table></figure><p>由于被命名的结果已经初始化，且已经关联至无参数的返回，它们就能让代码简单而清晰。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(buf) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nr <span class="keyword">int</span></span><br><span class="line">        nr, err = r.Read(buf)</span><br><span class="line">        n += nr</span><br><span class="line">        buf = buf[nr:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h4><p>go的<code>defer</code>语句用于预设一个函数调用(即推迟执行函数(deferred function))，该函数会在执行<code>defer</code>的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是解锁互斥和关闭文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Contents returns the file's contents as a string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contents</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()  <span class="comment">// f.Close will run when we're finished.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">byte</span></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := f.Read(buf[<span class="number">0</span>:])</span><br><span class="line">        result = <span class="built_in">append</span>(result, buf[<span class="number">0</span>:n]...) <span class="comment">// append is discussed later.</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>, err  <span class="comment">// f will be closed if we return here.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(result), <span class="literal">nil</span> <span class="comment">// f will be closed if we return here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推迟如<code>Close</code>之类的函数调用有两个好处。第一， 它能确保你不会忘记关闭文件。如果你以后又为该函数添加了新的返回路径时，这种情况往往就会发生。第二，它意味着<strong>关闭</strong>离<strong>打开</strong>很近， 这总比将它放在函数结尾处要清晰明了。</p><p>推迟函数（如果函数是一个方法则还包括接收者）的实参在推迟执行时就会求值，而不是在调用执行时才求值。这样不仅无需担心变量值在函数执行时被改变， 同时还意味着单个已推迟的调用可推迟多个函数的执行。一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被推迟的函数会按照<strong>后见先出(LIFO)</strong>的顺序执行，因此上述返回为<code>4 3 2 1 0</code>。一个更具实际意义的例子，让程序跟踪函数的运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="keyword">string</span>)</span></span>   &#123; fmt.Println(<span class="string">"entering:"</span>, s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">untrace</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123; fmt.Println(<span class="string">"leaving:"</span>, s) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use them like this:</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    trace(<span class="string">"a"</span>)</span><br><span class="line">    <span class="keyword">defer</span> untrace(<span class="string">"a"</span>)</span><br><span class="line">    <span class="comment">// do something....</span></span><br><span class="line">    fmt.Println(<span class="string">"---"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entering: a</span><br><span class="line">---</span><br><span class="line">leaving: a</span><br></pre></td></tr></table></figure><p>我们可以充分利用这个特点，即被推迟函数的实参在<code>defer</code>执行时才会求值。跟踪go程可针对反跟踪go程设置实参。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"entering:"</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"leaving:"</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">"a"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"in a"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">"b"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"in b"</span>)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entering: b</span><br><span class="line">in b</span><br><span class="line">entering: a</span><br><span class="line">in a</span><br><span class="line">leaving: a</span><br><span class="line">leaving: b</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>Data</p><p><br></p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>go有两种分配原语，即内建函数<code>new</code>和<code>make</code>。<code>new</code>用来分配内存，但与其它同名函数不同，它不会初始化内存，只会将内存置零(zero)。<code>new(T)</code>会为类型T的新项分配已置零的内存控制，并返回它的地址，也即是类型<code>*T</code>的值。用go的术语，它返回一个指针，该指针指向新分配的类型为T的零值。</p><p>既然<code>new</code>返回的内存已置零，那么当你设计数据结构时，每种类型的零值就不必进一步初始化，这意味着该数据结构的使用者只需用<code>new</code>创建一个新的对象就能正常工作。</p><p>零值属性有各种好处，考虑以下声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncedBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock    sync.Mutex</span><br><span class="line">    buffer  bytes.Buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SyncedBuffer</code>类型的值也是在声明时就分配好内存就绪了。后续代码中， p和v无需进一步处理即可正确工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(SyncedBuffer)  <span class="comment">// type *SyncedBuffer</span></span><br><span class="line"><span class="keyword">var</span> v SyncedBuffer      <span class="comment">// type  SyncedBuffer</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="构造函数与复合字面"><a href="#构造函数与复合字面" class="headerlink" title="构造函数与复合字面"></a>构造函数与复合字面</h4><p>Constructors and composite literals</p><p>有时零值还不够好，这时就需要一个初始化构造函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    f := <span class="built_in">new</span>(File)</span><br><span class="line">    f.fd = fd</span><br><span class="line">    f.name = name</span><br><span class="line">    f.dirinfo = <span class="literal">nil</span></span><br><span class="line">    f.nepipe = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里显得代码过于冗长。我们可通过复合字面来简化它， 该表达式在每次求值时都会创建新的实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，返回一个局部变量的地址完全没有问题，这点与C不同。该局部变量对应的数据 在函数返回后依然有效。实际上，每当获取一个复合字面的地址时，都将为一个新的实例分配内存， 因此我们可以将上面的最后两行代码合并：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>复合字面的字段必须按顺序全部列出。但如果以<code>k:v</code>对的形式明确地标出元素，初始化字段时就可以按任何顺序出现，未给出的字段值将赋予零值。 因此，我们可以用如下形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;File&#123;fd: fd, name: name&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="make"><a href="#make" class="headerlink" title="make"></a>make</h4><p>再回到内存分配上来。不同于<code>new</code>，<code>make</code>只用于创建切片、映射和信道，并返回类型为T的一个已初始化的值。出现这种差异的原因在于，这三种类型本质上为引用数据类型，它们在使用前必须初始化。对于切片、映射和信道，<code>make</code>用于初始化其内部的数据结构并准备好将要使用的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ew([]int) 会返回一个指向新分配的，已置零的切片结构， 即一个指向 nil 切片值的指针</span></span><br><span class="line"><span class="comment">// 会分配一个具有100个int的数组空间，接着创建一个长度为10， 容量为100并指向该数组中前10个元素的切片结构</span></span><br><span class="line"><span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><br></p><p><code>new</code>和<code>make</code>的区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *[]<span class="keyword">int</span> = <span class="built_in">new</span>([]<span class="keyword">int</span>)       <span class="comment">// allocates slice structure; *p == nil; rarely useful</span></span><br><span class="line"><span class="keyword">var</span> v  []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>) <span class="comment">// the slice v now refers to a new array of 100 ints</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unnecessarily complex:</span></span><br><span class="line"><span class="keyword">var</span> p *[]<span class="keyword">int</span> = <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br><span class="line">*p = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Idiomatic:</span></span><br><span class="line">v := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>请记住，<code>make</code>只适用于映射、切片和信道且不返回指针。若要获得明确的指针， 请使用<code>new</code>分配内存。</p><p><br><br><br></p><h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><p>在详细规划内存布局时，数组非常有用，有时还能避免过多的内存分配，但它们主要用作切片的构件。</p><p>Go中数组：</p><ul><li>数组是值。将一个数组赋予另一个数组会复制其所有元素。</li><li>若将某个数组传入某个函数，它将接收到该数组的一份副本而非指针。</li><li>数组的大小是其类型的一部分。类型<code>[10]int</code>和<code>[20]int</code>是不同的。</li></ul><p>数组为值的属性很有用，但代价高昂。若你想要C那样的行为和效率，你可以传递一个指向该数组的指针。但这并不是Go的习惯用法，切片才是。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a *[3]<span class="keyword">float64</span>)</span> <span class="params">(sum <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> *a &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array := [...]<span class="keyword">float64</span>&#123;<span class="number">7.0</span>, <span class="number">8.5</span>, <span class="number">9.1</span>&#125;</span><br><span class="line">x := Sum(&amp;array)  <span class="comment">// Note the explicit address-of operator</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h4><p>切片通过对数组进行封装，为数据序列提供了更通用、强大而方便的接口。 除了矩阵变换这类需要明确维度的情况外，Go中的大部分数组编程都是通过切片来完成的。</p><p>切片保存了对底层数组的引用，若你将某个切片赋予另一个切片，它们会引用同一个数组。只要切片不超出底层数组的限制，它的长度就是可变的。尽管<code>append</code>可修改切片的元素，但切片自身（其运行时数据结构包含指针、长度和容量）是通过值传递的。</p><p><br><br><br></p><h4 id="二维切片"><a href="#二维切片" class="headerlink" title="二维切片"></a>二维切片</h4><p>Two-dimensional slices</p><p>Go的数组和切片都是一维的。要创建等价的二维数组或切片，就必须定义一个数组的数组， 或切片的切片。像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transform [<span class="number">3</span>][<span class="number">3</span>]<span class="keyword">float64</span>  <span class="comment">// A 3x3 array, really an array of arrays.</span></span><br><span class="line"><span class="keyword">type</span> LinesOfText [][]<span class="keyword">byte</span>     <span class="comment">// A slice of byte slices.</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><p>映射是方便而强大的内建数据结构，它可以关联不同类型的值。其键可以是任何相等性操作符支持的类型， 如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构以及数组。 切片不能用作映射键，因为它们的相等性还未定义。与切片一样，映射也是引用类型。 若将映射传入函数中，并更改了该映射的内容，则此修改对调用者同样可见。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeZone = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"UTC"</span>:  <span class="number">0</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">"EST"</span>: <span class="number">-5</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">"CST"</span>: <span class="number">-6</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">"MST"</span>: <span class="number">-7</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">"PST"</span>: <span class="number">-8</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赋值和获取映射值的语法类似于数组，不同的是映射的索引不必为整数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset := timeZone[<span class="string">"EST"</span>]</span><br></pre></td></tr></table></figure><p>有时你需要区分某项是不存在还是其值为零值。可以使用多重赋值的形式来分辨这种情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> seconds <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">seconds, ok = timeZone[tz]</span><br></pre></td></tr></table></figure><p>若仅需判断映射中是否存在某项而不关心实际的值，可使用空白标识符(<code>_</code>)来代替该值的一般变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, present := timeZone[tz]</span><br></pre></td></tr></table></figure><p>要删除映射中的某项，可使用内建函数 delete，它以映射及要被删除的键为实参。 即便对应的键不在该映射中，此操作也是安全的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(timeZone, <span class="string">"PDT"</span>)  <span class="comment">// Now on Standard Time</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Printing"><a href="#Printing" class="headerlink" title="Printing"></a>Printing</h4><p>Go采用的格式化打印风格和C的<code>printf</code>族类似，但却更加丰富而通用。这些函数位于<code>fmt</code>包中，且函数名首字母均为大写：如<code>fmt.Printf</code>、<code>fmt.Fprintf</code>，<code>fmt.Sprintf</code>等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"Hello %d\n"</span>, <span class="number">23</span>)</span><br><span class="line">fmt.Fprint(os.Stdout, <span class="string">"Hello "</span>, <span class="number">23</span>, <span class="string">"\n"</span>)</span><br><span class="line">fmt.Println(<span class="string">"Hello"</span>, <span class="number">23</span>)</span><br><span class="line">fmt.Println(fmt.Sprint(<span class="string">"Hello "</span>, <span class="number">23</span>))</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><p>内建函数<code>append</code>像这个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []T, elements ...T)</span> []<span class="title">T</span></span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Initialization</p><p>尽管从表面上看，Go的初始化过程与C或C++并不算太大，但它确实更为强大。 在初始化过程中，不仅可以构建复杂的结构，还能正确处理不同包对象间的初始化顺序。</p><p><br></p><h4 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h4><p>Constants</p><p>Go中的常量就是不变量。它们在编译时创建，即便它们可能是函数中定义的局部变量。 常量只能是数字、字符（符文）、字符串或布尔值。由于编译时的限制， 定义它们的表达式必须也是可被编译器求值的常量表达式。</p><p><br><br><br></p><h4 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h4><p>变量的初始化与常量类似，但其初始值也可以是在运行时才被计算的一般表达式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    home   = os.Getenv(<span class="string">"HOME"</span>)</span><br><span class="line">    user   = os.Getenv(<span class="string">"USER"</span>)</span><br><span class="line">    gopath = os.Getenv(<span class="string">"GOPATH"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p>The init function</p><p>最后，每个源文件都可以通过定义自己的无参数<code>init</code>函数来设置一些必要的状态。而它的结束就意味着初始化结束： 只有该包中的所有变量声明都通过它们的初始化器求值后<code>init</code>才会被调用， 而那些<code>init</code>只有在所有已导入的包都被初始化后才会被求值。</p><p>除了那些不能被表示成声明的初始化外，init 函数还常被用在程序真正开始执行前，检验或校正程序的状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Besides initializations that cannot be expressed as declarations, a common use of init functions is to verify or repair correctness of the program state before <span class="built_in">real</span> execution begins.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">""</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"$USER not set"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> home == <span class="string">""</span> &#123;</span><br><span class="line">        home = <span class="string">"/home/"</span> + user</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gopath == <span class="string">""</span> &#123;</span><br><span class="line">        gopath = home + <span class="string">"/go"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// gopath may be overridden by --gopath flag on command line.</span></span><br><span class="line">    flag.StringVar(&amp;gopath, <span class="string">"gopath"</span>, gopath, <span class="string">"override default GOPATH"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>Methods</p><p><br></p><h4 id="指针与值"><a href="#指针与值" class="headerlink" title="指针与值"></a>指针与值</h4><p>Pointers vs. Values</p><p>以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用。</p><p><br><br><br></p><h3 id="接口和其它类型"><a href="#接口和其它类型" class="headerlink" title="接口和其它类型"></a>接口和其它类型</h3><p><br></p><h4 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h4><p>Go中的接口为指定对象的行为提供了一种方法：如果某样东西可以完成这个， 那么它就可以用在这里。</p><p>每种类型都能实现多个接口。</p><p><br><br><br></p><h4 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h4><p>Conversions</p><p><br><br><br></p><h4 id="接口转换与类型断言"><a href="#接口转换与类型断言" class="headerlink" title="接口转换与类型断言"></a>接口转换与类型断言</h4><p>Interface conversions and type assertions</p><p>类型选择是类型转换的一种形式：它接受一个接口，在选择中根据其判断选择对应的情况， 并在某种意义上将其转换为该种类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Value provided by caller.</span></span><br><span class="line"><span class="keyword">switch</span> str := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">case</span> Stringer:</span><br><span class="line">    <span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型断言接受一个接口值， 并从中提取指定的明确类型的值。</p><p><br><br><br></p><h4 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h4><p>Generality</p><p>若某种现有的类型仅实现了一个接口，且除此之外并无可导出的方法，则该类型本身就无需导出。 仅导出该接口能让我们更专注于其行为而非实现，其它属性不同的实现则能镜像该原始类型的行为。 这也能够避免为每个通用接口的实例重复编写文档。</p><p>在这种情况下，构造函数应当返回一个接口值而非实现的类型。</p><p><br><br><br></p><h4 id="接口和方法"><a href="#接口和方法" class="headerlink" title="接口和方法"></a>接口和方法</h4><p>Interfaces and methods</p><p>由于几乎任何类型都能添加方法，因此几乎任何类型都能满足一个接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个很直观的例子就是 http 包中定义的 Handler 接口。任何实现了 Handler 的对象都能够处理HTTP请求</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符"></a>空白标识符</h3><p>The blank identifier</p><p>空白标识符(<code>_</code>)可被赋予或声明为任何类型的任何值，而其值会被无害地丢弃。它有点像Unix中的<code>/dev/null</code>文件：它表示只写的值，在需要变量但不需要实际值的地方用作占位符。</p><p><br></p><h4 id="多重赋值中的空白标识符"><a href="#多重赋值中的空白标识符" class="headerlink" title="多重赋值中的空白标识符"></a>多重赋值中的空白标识符</h4><p>The blank identifier in multiple assignment</p><p><code>for range</code>循环中对空表标识符的用法是一种具体情况，更一般的情况即为多重赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := os.Stat(path); os.IsNotExist(err) &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s does not exist\n"</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="未使用的导入和变量"><a href="#未使用的导入和变量" class="headerlink" title="未使用的导入和变量"></a>未使用的导入和变量</h4><p>Unused imports and variables</p><p>若导入某个包或声明某个变量而不使用它就会产生错误。未使用的包会让程序膨胀并拖慢编译速度， 而已初始化但未使用的变量不仅会浪费计算能力，还有可能暗藏着更大的Bug。</p><p>要让编译器停止关于未使用导入的抱怨，需要空白标识符来引用已导入包中的符号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = fmt.Printf <span class="comment">// For debugging; delete when done.</span></span><br><span class="line"><span class="keyword">var</span> _ io.Reader    <span class="comment">// For debugging; delete when done.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fd, err := os.Open(<span class="string">"test.go"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> use fd.</span></span><br><span class="line">    _ = fd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="为副作用而导入"><a href="#为副作用而导入" class="headerlink" title="为副作用而导入"></a>为副作用而导入</h4><p>Import for side effect</p><p>有时导入某个包只是为了其副作用， 而没有任何明确的使用。只为了其副作用来导入该包， 只需将包重命名为空白标识符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"net/http/pprof"</span></span><br></pre></td></tr></table></figure><p>这种导入格式能明确表示该包是为其副作用而导入的，因为没有其它使用该包的可能： 在此文件中，它没有名字。（若它有名字而我们没有使用，编译器就会拒绝该程序。）</p><p><br><br><br></p><h4 id="接口检查"><a href="#接口检查" class="headerlink" title="接口检查"></a>接口检查</h4><p>Interface checks</p><p>一个类型无需显式地声明它实现了某个接口。取而代之，该类型只要实现了某个接口的方法， 其实就实现了该接口。在实践中，大部分接口转换都是静态的，因此会在编译时检测。</p><p>若只需要判断某个类型是否是实现了某个接口，而不需要实际使用接口本身 （可能是错误检查部分），就使用空白标识符来忽略类型断言的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := val.(json.Marshaler); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"value %v of type %T implements json.Marshaler\n"</span>, val, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种结构中出现空白标识符，即表示该声明的存在只是为了类型检查。 不过请不要为满足接口就将它用于任何类型。作为约定， 仅当代码中不存在静态类型转换时才能这种声明，毕竟这是种罕见的情况。</p><p><br><br><br></p><h3 id="内嵌"><a href="#内嵌" class="headerlink" title="内嵌"></a>内嵌</h3><p>Embedding</p><p>Go并不提供典型的，类型驱动的子类化概念，但通过将类型内嵌到结构体或接口中， 它就能借鉴部分实现。</p><p><br><br><br></p><h3 id="并发-1"><a href="#并发-1" class="headerlink" title="并发"></a>并发</h3><p>Concurrency</p><p><br></p><h4 id="通过通信共享内存"><a href="#通过通信共享内存" class="headerlink" title="通过通信共享内存"></a>通过通信共享内存</h4><p>Share by communicating</p><p>并发编程是个很大的话题。这里只讨论一些go特有的东西。</p><p>在并发编程中，为实现对共享变量的正确访问需要精确的控制，这在多数环境下都很困难。 Go语言另辟蹊径，它将共享的值通过信道传递，实际上，多个独立执行的线程从不会主动共享。 在任意给定的时间点，只有一个Go程能够访问该值。数据竞争从设计上就被杜绝了。</p><p>为了提倡这种思考方式，我们将它简化为一句口号： <strong>不要通过共享内存来通信，而应通过通信来共享内存(Do not communicate by sharing memory; instead, share memory by communicating)。</strong></p><p>这种方法意义深远。例如，引用计数通过为整数变量添加互斥锁来很好地实现。 但作为一种高级方法，通过信道来控制访问能够让你写出更简洁，正确的程序。</p><p><br><br><br></p><h4 id="go程"><a href="#go程" class="headerlink" title="go程"></a>go程</h4><p>Goroutines</p><p>称它为<strong>GO程</strong>是因为现有的术语——线程(threads), 协程(coroutines), 进程(process)无法准确表达它的含义。Go程具有简单的模型：它是与其它Go程并发运行在同一地址空间的函数。它是轻量级的， 所有小号几乎就只有栈空间的分配。而且栈最开始是非常小的，所以它们很廉价， 仅在需要时才会随着堆空间的分配（和释放）而变化。</p><p>Go程在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待I/O， 那么其它的线程就会运行。Go程的设计隐藏了线程创建和管理的诸多复杂性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数或方法前添加go关键字能够在新的Go程中调用它。当调用完成后， 该Go程也会安静地退出</span></span><br><span class="line"><span class="comment">// 效果有点像Unix Shell中的 &amp; 符号，它能让命令在后台运行</span></span><br><span class="line"><span class="keyword">go</span> list.Sort() <span class="comment">// run list.Sort concurrently; don't wait for it.</span></span><br></pre></td></tr></table></figure><p>函数字面在Go程调用中非常有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Announce</span><span class="params">(message <span class="keyword">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(delay)</span><br><span class="line">        fmt.Println(message)</span><br><span class="line">    &#125;()  <span class="comment">// Note the parentheses - must call the function.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go中，函数字面都是闭包(closures)：其实现在保证了函数内引用变量的生命周期与函数的活动时间相同。这些函数没什么实用性，因为它们没有实现完成时的信号处理。因此，我们需要信道。</p><p><br><br><br></p><h4 id="信道-1"><a href="#信道-1" class="headerlink" title="信道"></a>信道</h4><p>Channels</p><p>信道与映射一样，也需要通过<code>make</code>来分配内存，其结果充当了对底层数据结构的引用。若提供了一个可选的整数形参，它就会为该信道设置缓冲区大小。默认值是零，表示不带缓冲(unbuffered)的或同步(synchronous)的信道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ci := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)            <span class="comment">// unbuffered channel of integers</span></span><br><span class="line">cj := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>)         <span class="comment">// unbuffered channel of integers</span></span><br><span class="line">cs := <span class="built_in">make</span>(<span class="keyword">chan</span> *os.File, <span class="number">100</span>)  <span class="comment">// buffered channel of pointers to Files</span></span><br></pre></td></tr></table></figure><p>无缓冲信道在通信时会同步交换数据，它能确保（goroutine）计算处于确定状态。</p><p>信道有很多惯用方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)  <span class="comment">// Allocate a channel.</span></span><br><span class="line"><span class="comment">// Start the sort in a goroutine; when it completes, signal on the channel.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list.Sort()</span><br><span class="line">    c &lt;- <span class="number">1</span>  <span class="comment">// Send a signal; value does not matter.</span></span><br><span class="line">&#125;()</span><br><span class="line">doSomethingForAWhile()</span><br><span class="line">&lt;-c   <span class="comment">// Wait for sort to finish; discard sent value.</span></span><br></pre></td></tr></table></figure><p>接收者在收到数据前会一直阻塞。若信道是不带缓冲的，那么在接收者收到值前， 发送者会一直阻塞；若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞； 若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。</p><p>带缓冲的信道可被用作信号量，例如限制吞吐量。</p><p>回到编写服务器的一般问题上来。另一种管理资源的好方法就是启动固定数量的<code>handle</code>Go程，一起从请求信道中读取数据。Go程的数量限制了同时调用<code>process</code>的数量。Serve同样会接收一个通知退出的信道， 在启动所有Go程后，它将阻塞并暂停从信道中接收消息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> r := <span class="keyword">range</span> queue &#123;</span><br><span class="line">        process(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(clientRequests <span class="keyword">chan</span> *Request, quit <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Start handlers</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; MaxOutstanding; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> handle(clientRequests)</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;-quit  <span class="comment">// Wait to be told to exit.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="信道中的信道"><a href="#信道中的信道" class="headerlink" title="信道中的信道"></a>信道中的信道</h4><p>Channels of channels</p><p>Go最重要的特性就是信道是一等值，它可以被分配并像其它值到处传递。 这种特性通常被用来实现安全(safe)、并行(parallel)的多路分解(demultiplexing)。</p><p><br><br><br></p><h4 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h4><p>Parallelization</p><p>这些设计的另一个应用是在多CPU核心上实现并行计算。如果计算过程能够被分为几块 可独立执行的过程，它就可以在每块计算结束时向信道发送信号，从而实现并行处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numCPU = <span class="number">4</span> <span class="comment">// number of CPU cores</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vector)</span> <span class="title">DoAll</span><span class="params">(u Vector)</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, numCPU)  <span class="comment">// Buffering optional but sensible.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCPU; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> v.DoSome(i*<span class="built_in">len</span>(v)/numCPU, (i+<span class="number">1</span>)*<span class="built_in">len</span>(v)/numCPU, u, c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Drain the channel.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCPU; i++ &#123;</span><br><span class="line">        &lt;-c    <span class="comment">// wait for one task to complete</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// All done.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前Go运行时的实现默认并不会并行执行代码，它只为用户层代码提供单一的处理核心。 任意数量的Go程都可能在系统调用中被阻塞，而在任意时刻默认只有一个会执行用户层代码。 它应当变得更智能，而且它将来肯定会变得更智能。但现在，若你希望CPU并行执行， 就必须告诉运行时你希望同时有多少Go程能执行代码。除了为CPU数量创建一个创建，还有两种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> numCPU = runtime.NumCPU()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> numCPU = runtime.GOMAXPROCS(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><br></p><p>注意不要混淆并发(concurrency)和并行(parallelism)的概念。并发是用可独立执行的组件构造程序的方法， 而并行则是为了效率在多CPU上平行地进行计算。</p><p>尽管Go的并发特性能够让某些问题更易构造成并行计算， 但Go仍然是种并发而非并行的语言，且Go的模型并不适合所有的并行问题。</p><p><br><br><br></p><h4 id="泄露的缓冲区"><a href="#泄露的缓冲区" class="headerlink" title="泄露的缓冲区"></a>泄露的缓冲区</h4><p>A leaky buffer</p><p>并发编程的工具甚至能很容易地表达非并发的思想。</p><p>这里有个提取自RPC包的例子。 客户端Go程从某些来源，可能是网络中循环接收数据。为避免分配和释放缓冲区， 它保存了一个空闲链表，使用一个带缓冲信道表示。若信道为空，就会分配新的缓冲区。 一旦消息缓冲区就绪，它将通过serverChan被发送到服务器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> freeList = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> serverChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">client</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> b *Buffer</span><br><span class="line">        <span class="comment">// Grab a buffer if available; allocate if not.</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> b = &lt;-freeList:</span><br><span class="line">            <span class="comment">// Got one; nothing more to do.</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// None free, so allocate a new one.</span></span><br><span class="line">            b = <span class="built_in">new</span>(Buffer)</span><br><span class="line">        &#125;</span><br><span class="line">        load(b)              <span class="comment">// Read next message from the net.</span></span><br><span class="line">        serverChan &lt;- b      <span class="comment">// Send to server.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器从客户端循环接收每个消息，处理它们，并将缓冲区返回给空闲列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        b := &lt;-serverChan    <span class="comment">// Wait for work.</span></span><br><span class="line">        process(b)</span><br><span class="line">        <span class="comment">// Reuse buffer if there's room.</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> freeList &lt;- b:</span><br><span class="line">            <span class="comment">// Buffer on free list; nothing more to do.</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Free list full, just carry on.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端试图从freeList中获取缓冲区；若没有缓冲区可用， 它就将分配一个新的。服务器将b放回空闲列表freeList中直到列表已满，此时缓冲区将被丢弃，并被垃圾回收器回收。依靠带缓冲的信道和垃圾回收器的记录， 我们仅用短短几行代码就构建了一个可能导致缓冲区槽位泄露的空闲列表。</p><p><br><br><br></p><h3 id="错误-1"><a href="#错误-1" class="headerlink" title="错误"></a>错误</h3><p>error</p><p>库例程通常需要向调用者返回某种类型的错误提示。之前提到过，Go语言的多值返回特性， 使得它在返回常规的值时，还能轻松地返回详细的错误描述。</p><p>按照约定，错误的类型通常为<code>error</code>，这是一个内建的简单接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>库的编写者通过更丰富的底层模型可以轻松实现这个接口，这样不仅能看见错误， 还能提供一些上下文。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PathError records an error and the operation and</span></span><br><span class="line"><span class="comment">// file path that caused it.</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op <span class="keyword">string</span>    <span class="comment">// "open", "unlink", etc.</span></span><br><span class="line">    Path <span class="keyword">string</span>  <span class="comment">// The associated file.</span></span><br><span class="line">    Err error    <span class="comment">// Returned by the system call.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Op + <span class="string">" "</span> + e.Path + <span class="string">": "</span> + e.Err.Error()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的错误信息例子</span></span><br><span class="line"><span class="comment">// open /etc/passwx: no such file or directory</span></span><br></pre></td></tr></table></figure><p>错误字符串应尽可能地指明它们的来源，例如产生该错误的包名前缀。若调用者关心错误的完整细节，可使用类型选择或者类型断言来查看特定错误，并抽取其细节。</p><p><br><br><br></p><h4 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h4><p>向调用者报告错误的一般方式就是将<code>error</code>作为额外的值返回。但如果错误时不可恢复的呢？有时程序就是不能继续运行。为此，我们提供了内建的<code>panic</code>函数，它会产生一个运行时错误并终止程序。该函数接受一个任意类型的实参（一般为字符串），并在程序终止时打印。 它还能表明发生了意料之外的事情，比如从无限循环中退出了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A toy implementation of cube root using Newton's method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CubeRoot</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    z := x/<span class="number">3</span>   <span class="comment">// Arbitrary initial value</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1e6</span>; i++ &#123;</span><br><span class="line">        prevz := z</span><br><span class="line">        z -= (z*z*z-x) / (<span class="number">3</span>*z*z)</span><br><span class="line">        <span class="keyword">if</span> veryClose(z, prevz) &#123;</span><br><span class="line">            <span class="keyword">return</span> z</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A million iterations has not converged; something is wrong.</span></span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"CubeRoot(%g) did not converge"</span>, x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的库函数应避免<code>panic</code>。若问题可以被屏蔽或解决， 最好就是让程序继续运行而不是终止整个程序。</p><p><br><br><br></p><h4 id="Recover"><a href="#Recover" class="headerlink" title="Recover"></a>Recover</h4><p>当<code>panic</code>被调用后，程序将立刻终止当前函数的执行，并开始回溯Go程的栈，运行任何被推迟的函数。 若回溯到达Go程栈的顶端，程序就会终止。不过我们可以用内建的<code>recover</code>函数来重新或来取回Go程的控制权限并使其恢复正常执行。</p><p>调用<code>recover</code>将停止回溯过程，并返回传入<code>panic</code>的实参。 由于在回溯时只有被推迟函数中的代码在运行，因此<code>recover</code>只能在被推迟的函数中才有效。</p><p>recover的一个应用就是在服务器中终止失败的Go程而无需杀死其它正在执行的Go程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(workChan &lt;-<span class="keyword">chan</span> *Work)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> work := <span class="keyword">range</span> workChan &#123;</span><br><span class="line">        <span class="keyword">go</span> safelyDo(work)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safelyDo</span><span class="params">(work *Work)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"work failed:"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    do(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此例中，若<code>do(work)</code>触发了Panic，其结果就会被记录， 而该Go程会被干净利落地结束，不会干扰到其它Go程。我们无需在推迟的闭包中做任何事情， <code>recover</code>会处理好这一切。</p><p>通过恰当地使用恢复模式，do函数（及其调用的任何代码）可通过调用 panic 来避免更坏的结果。我们可以利用这种思想来简化复杂软件中的错误处理。 让我们看看regexp包的理想化版本，它会以局部的错误类型调用 panic 来报告解析错误。以下是一个error类型的 Error方法和一个Compile函数的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error is the type of a parse error; it satisfies the error interface.</span></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Error)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error is a method of *Regexp that reports parsing errors by</span></span><br><span class="line"><span class="comment">// panicking with an Error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(regexp *Regexp)</span> <span class="title">error</span><span class="params">(err <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(Error(err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile returns a parsed representation of the regular expression.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(regexp *Regexp, err error)</span></span> &#123;</span><br><span class="line">    regexp = <span class="built_in">new</span>(Regexp)</span><br><span class="line">    <span class="comment">// doParse will panic if there is a parse error.</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            regexp = <span class="literal">nil</span>    <span class="comment">// Clear return value.</span></span><br><span class="line">            err = e.(Error) <span class="comment">// Will re-panic if not a parse error.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> regexp.doParse(str), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便一提，这种重新触发Panic的惯用法会在产生实际错误时改变Panic的值。 然而，不管是原始的还是新的错误都会在崩溃报告中显示，因此问题的根源仍然是可见的。 这种简单的重新触发Panic的模型已经够用了，毕竟他只是一次崩溃。 但若你只想显示原始的值，也可以多写一点代码来过滤掉不需要的问题，然后用原始值再次触发Panic。</p><p><br><br><br></p><h3 id="A-web-server"><a href="#A-web-server" class="headerlink" title="A web server"></a>A web server</h3><p>让我们以一个完整的Go程序作为结束吧，一个Web服务器。该程序其实只是个Web服务器的重用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"html/template"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addr = flag.String(<span class="string">"addr"</span>, <span class="string">":1718"</span>, <span class="string">"http service address"</span>) <span class="comment">// Q=17, R=18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> templ = template.Must(template.New(<span class="string">"qr"</span>).Parse(templateStr))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    http.Handle(<span class="string">"/"</span>, http.HandlerFunc(QR))</span><br><span class="line">    err := http.ListenAndServe(*addr, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QR</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    templ.Execute(w, req.FormValue(<span class="string">"s"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> templateStr = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">&lt;title&gt;QR Link Generator&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;if .&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;img src="http://chart.apis.google.com/chart?chs=300x300&amp;cht=qr&amp;choe=UTF-8&amp;chl=&#123;&#123;.&#125;&#125;" /&gt;</span></span><br><span class="line"><span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;.&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;form action="/" name=f method="GET"&gt;</span></span><br><span class="line"><span class="string">    &lt;input maxLength=1024 size=70 name=s value="" title="Text to QR Encode"&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=submit value="Show QR" name=qr&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>Go语言强大到能让很多事情以短小精悍的方式解决。</p><p><br><br><br><br><br></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>Diagnostics: <a href="https://golang.org/doc/diagnostics.html" target="_blank" rel="noopener">https://golang.org/doc/diagnostics.html</a></p><p>总结工具和方法来诊断Go程序</p><p><br></p><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>Go生态提供了一套API和工具来诊断go程序的逻辑和性能问题。本章总结了可用的工具，帮助用户去选择正确的工具来解决问题。</p><p>调试方案可分为一下几组：</p><ul><li><strong>Profiling</strong>： 分析工具分析go程序的复杂性和成本，如内存使用和调用函数的频率，以确定go程序的昂贵的部分；</li><li><strong>Tracing</strong>： 追踪是分析整个延迟和调用或用户请求的生命周期的一种方法；</li><li><strong>Debugging</strong>： 调试可以让我们暂停go程序，检查并执行。程序的状态和流程可通过调试进行验证；</li><li><strong>Runtime statistics and events</strong>： 收集和分析运行时状态和事件，提供go程序运行状态的高度概括。</li></ul><p><br><br><br></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>Profiling</p><p>对于识别昂贵的或频繁调用的代码部分，分析很有用。go runtime通过<code>pprof</code>可视化工具以格式化形式提供了分析数据。可通过<code>go test</code>或<code>net/http/pprof</code>包来收集分析数据。用户需要在代码顶级路径使用<code>pprof</code>工具来收集分析路径。</p><p>由<code>runtime/pprof</code>包预分析：</p><ul><li><strong>cpu</strong>: cpu porfile，报告程序花费的CPU时间。</li><li><strong>heap</strong>： heap profile，报告内存分配样本，监控当前和历史的内存使用，并检查内存泄漏。</li><li><strong>threadcreate</strong>： thread profile，报告程序的操作系统的线程创建部分。</li><li><strong>goroutine</strong>： goroutine profile，报告当前所有goroutine的栈追踪(stack trace)。</li><li><strong>block</strong>： block profile，报告goroutine在哪里等待同步原语(synchronization primitives)阻塞。此功能默认关闭，使用<code>runtime.SetBlockProfileRate</code>开启。</li><li><strong>mutex</strong>： mutex profile，报告锁的争用情况。当你认为由于互斥锁争用，CPU没有得到充分利用时，使用此功能。此功能默认关闭，使用<code>runtime.SetMutexProfileFraction</code>启用。</li></ul><p><br><br><br></p><h3 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h3><p>Tracing</p><p>追踪是一种来分析整个调用链的生命周期的延迟的方法。go提供了<code>golang.org/x/net/trace</code>包作为每个go节点的最小化追踪后端，并使用一个简单的面板来提供一个小型的仪器库。go还提供了一个可执行的追踪程序在内部追踪运行时事件。</p><p>追踪使我们能够：</p><ul><li>在go程序内工具和分析应用延迟。</li><li>衡量一个长链调用的特定调用的开销。</li><li>计算使用率和性能优化。</li></ul><p>go的生态提供了多种追踪库。</p><p><br><br><br></p><h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>Debugging</p><p>调试是识别一个程序行为不端的过程。调试器让我们了解程序的执行流程和当前状态。有几种调试风格，本章节将仅聚焦于一个调试器附加到一个程序和核心转储(core dump)调试。</p><p>go用户大多使用以下调试器：</p><ul><li><strong>(Delve)[<a href="https://github.com/go-delve/delve" target="_blank" rel="noopener">https://github.com/go-delve/delve</a>]</strong>： Delve是一个go lang调试器。它支持go runtime和内建类型。它正努力成为一个go程序的全功能可靠的调试器。</li><li><strong>(GDB)[<a href="https://golang.org/doc/gdb" target="_blank" rel="noopener">https://golang.org/doc/gdb</a>]</strong>： go通过标准的go编译器和Gccgo提供了GDB支持。尽管GDB可以用来调试go程序，但这不理想，可能导致混乱。</li></ul><p><br><br><br></p><h3 id="运行时统计数据和事件"><a href="#运行时统计数据和事件" class="headerlink" title="运行时统计数据和事件"></a>运行时统计数据和事件</h3><p>Runtime statistics and events</p><p>运行时(runtime)提供了统计信息和内部事件的报告，为用户在运行时级别诊断性能和利用率的问题。</p><p>用户可以监控这些数据，以便于更好地了解go程序的总体运行状况和性能。一些常用的监控统计数据和状态：</p><ul><li><code>runtime.ReadMemStats</code>： 报告与堆分配(heap allocation)和垃圾回收(garbage collection)相关的指标。内存统计数据对监控进程消耗了多少内存资源是有用的，进程是否能很好地利用内存，并捕捉到内存泄漏。</li><li><code>debug.ReadGCStats</code>： 阅读关于垃圾回收的统计数据。查看多少资源都花在了垃圾回收阶段也是很有用的。它还报告垃圾回收暂停和暂停事件百分数的时间线。</li><li><code>debug.Stack</code>： 返回当前的栈追踪。栈追踪对于查看有多少goroutine正在运行，它们在做什么，它们是否阻塞很有用。</li><li><code>debug.WriteHeapDump</code>： 中止所有goroutine的执行，并允许转存(dump)堆(heap)到文件。一个堆转存是go程序在特定时间内存的快照。它包含所有分配的对象，以及goroutine, finalizers…</li><li><code>runtime.NumGoroutine</code>： 返回当前的goroutine数量。该值可以被监测、以了解是否有足够的goroutine被利用，或检测goroutine泄漏。</li></ul><p><br><br><br></p><h4 id="执行追踪"><a href="#执行追踪" class="headerlink" title="执行追踪"></a>执行追踪</h4><p>Execution tracer</p><p>go使用runtime execution tracer来捕获广泛的运行时事件。调度、系统调用、垃圾回收、堆大小和其它收集的事件。执行追踪器是一个检测延迟和使用率问题的工具。你可以检查CPU如何利用，网络或系统调用时，抢占对goroutine的原因。</p><p>追踪器对这些有用：</p><ul><li>理解你的goroutine如何执行</li><li>理解一些核心(core)的运行时事件，如垃圾回收</li><li>确定不佳的并行执行</li></ul><p><br></p><p>然而，它不是很大用于识别热点（如分析内存溢出或CPU使用的原因）。使用分析工具而不是先定位它们。</p><p>详细信息查看<code>go tool trace</code>，来收集和分析运行时追踪。</p><p><br><br><br></p><h4 id="GODEBUG"><a href="#GODEBUG" class="headerlink" title="GODEBUG"></a>GODEBUG</h4><p>如果<code>GODEBUG</code>环境变量相应地设置，运行时也会发出事件和信息。</p><ul><li><code>GODEBUG=gctrace=1</code>： 在每个收集中打印垃圾回收器事件，汇总内存收集量和停顿的长度。</li><li><code>GODEBUG=schedtrace=X</code>： 每个x毫秒打印调度事件。</li></ul><p>GODEBUG环境变量可用于在标准库和运行时中禁用指令集扩展。</p><ul><li><code>GODEBUG=cpu.all=off</code>： 禁止使用所有可选的扩展指令集。</li><li><code>GODEBUG=cpu.extension=off</code>： 禁止从指定的指令集扩展中使用指令。</li></ul><p><br><br><br><br><br></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>docs: <a href="https://golang.org/doc/faq" target="_blank" rel="noopener">https://golang.org/doc/faq</a></p><p>有关go的常见问答。</p><p><br><br><br><br><br></p><h2 id="Go-wiki"><a href="#Go-wiki" class="headerlink" title="Go wiki"></a>Go wiki</h2><p>docs: <a href="https://github.com/golang/go/wiki" target="_blank" rel="noopener">https://github.com/golang/go/wiki</a></p><p>由GO社区维护的wiki。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>References</p><p><br><br><br></p><h2 id="包-1"><a href="#包-1" class="headerlink" title="包"></a>包</h2><p>Package Documentation: <a href="https://golang.org/pkg/" target="_blank" rel="noopener">https://golang.org/pkg/</a></p><p>Go标准库文档。</p><p><br><br><br><br><br></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>Command Documentation: <a href="https://golang.org/doc/cmd" target="_blank" rel="noopener">https://golang.org/doc/cmd</a></p><p>Go工具文档。</p><p><br><br><br><br><br></p><h2 id="语言规范"><a href="#语言规范" class="headerlink" title="语言规范"></a>语言规范</h2><p>Language Specification: <a href="https://golang.org/ref/spec" target="_blank" rel="noopener">https://golang.org/ref/spec</a></p><p>官方Go语言规范。</p><p><br><br><br></p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>The Go Memory Model: <a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github: &lt;a href=&quot;https://github.com/golang/go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/golang/go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docs: &lt;a href=&quot;https://golang.org/doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://golang.org/doc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;awesome-go: &lt;a href=&quot;https://github.com/avelino/awesome-go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/avelino/awesome-go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;版本:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;go v1.14&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Go" scheme="https://zhang21.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://zhang21.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Ansible</title>
    <link href="https://zhang21.github.io/2019/12/26/Ansible/"/>
    <id>https://zhang21.github.io/2019/12/26/Ansible/</id>
    <published>2019-12-26T09:40:11.000Z</published>
    <updated>2020-08-26T11:16:38.117Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>Ansible docs: <a href="https://docs.ansible.com" target="_blank" rel="noopener">https://docs.ansible.com</a></li></ul><p><br></p><p>环境:</p><ul><li>RHELx86_64</li><li>Ansible v2.9</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>About Ansible: <a href="https://docs.ansible.com/ansible/latest/index.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/index.html</a></p><p>Ansible是一个IT自动化工具。它可以配置系统，部署软件和编排更先进的IT任务。Ansible的主要目标是简单和易于使用。它也专注于安全性和可靠性。</p><p>Ansible以无代理(agent-less)方式管理机器。Ansible是分散的，它依赖于现有操作系统的平局来控制访问到远程主机。如果需要，Ansible可以很容易地使用Kerberos, LDAP等集中认证管理系统连接。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h1><p><a href="https://docs.ansible.com/ansible/latest/reference_appendices/glossary.html" target="_blank" rel="noopener">Glossary</a></p><ul><li><p><strong>Action</strong><br>动作(action)是任务的一部分，用于指定要运行的模块和传递给该模块的参数。每个任务只能有一个动作，但也可能有其它参数。</p></li><li><p><strong>Ad Hoc</strong><br>指使用<code>/usr/bin/ansible</code>运行Ansible执行一些快速命令，而不是编排语言，即<code>/usr/bin/ansible-play-book</code>。ad hoc命令的示例可能是重新启动基础结构中的50台计算机。你可以通过编写playbook来完成你可以做的任何事情，而playbook也可以将许多其它操作粘合在一起。</p></li><li><p><strong>Async</strong><br>指配置为在后台运行而不是等待完成的任务。如果你的进程时间长度超过了SSH超时时间，那么以异步(async)模式启动该任务是有意义的。异步模式可以每隔很多秒轮询完成，或者可配置为’fire and  forget’，在这种情况下，Ansible甚至不会再次检查任务，它将开始并继续进行未来的步骤。异步模式使用<code>/usr/bin/ansible</code>和<code>/usr/bin/ansible-playbook</code>。</p></li><li><p><strong>Callback Plugin</strong><br>指一些用户编写的代码，可拦截Ansible的结构并对它们执行某些操作。GitHub中提供的一些示例执行自定义日志记录，发送电子邮件…</p></li><li><p><strong>Check Mode</strong><br>值运行带有<code>--check</code>选项的Ansible，它不会对远程系统进行任何更改，但仅输出在没有此标志的情况下运行时才有可能发生的更改。</p></li><li><p><strong>Connection Plugin</strong><br>默认情况下，Ansible通过pluggable libraries与远程计算机通信。Ansible支持原生OpenSSH或称为paramiko的Python实现。如果您使用的是最新版本，则首选OpenSSH，并启用Kerberos和jump host等功能。还有其它连接类型，如<code>accelerate</code>模式，必须通过一种基于SSH的连接类型进行引导，但速度非常快，而本地模式则作用于本地系统。用户还可以编写自己的连接插件。</p></li></ul><ul><li><p><strong>Conditionals</strong><br>条件是一个表达式，其计算结果为<code>true</code>或<code>false</code>，用于决定给定任务是否在给定计算机上执行。</p></li><li><p><strong>Declarative</strong><br>实现使用最终状态描述的任务的方法，而不是实现该状态所需的步骤序列的描述。对于真实世界的栗子，任务的声明规范将是: “put me in California”。根据你当前的位置，前往加州的步骤顺序可能会有所不同，如果你已在加州，则根本不需要做任何事情。Ansible的资源是声明性的；它确定了实现最终状态所需的步骤。它还可让你知道是否需要采取任何步骤才能到达最终状态。</p></li><li><p><strong>Diff Mode</strong><br>将<code>--diff</code>标志传递给Ansible，以显示支持它的模块。</p></li><li><p><strong>Executor</strong><br>Ansible的核心软件组件，它是<code>/usr/bin/ansible</code>背后的力量——并且对应于剧本中每个任务的调用。</p></li><li><p><strong>Facts</strong><br>事实是发现的有关远程节点的事情。通过在远程节点上执行内部设置模块来运行，Ansible会自动发现事实。</p></li><li><p><strong>Filter Plugin</strong><br>这允许创建新的Jinja2过滤器，这只适用于知道Jinja2过滤器的人。</p></li><li><p><strong>Fork</strong><br>Ansible并行地与远程节点通信，并且可通过传递<code>--forks</code>或编辑配置文件中的默认值来设置并行级别。</p></li><li><p><strong>Gather Facts (Boolean)</strong><br>有时，当运行多重playbook时，如果不需要利用任何这些值，则希望有一些不打扰事实计算的playbook。</p></li><li><p><strong>Globbing</strong><br>通配符是一种选择大量主机，或它们所在组的名称的方法</p></li><li><p><strong>Group</strong><br>一组主机</p></li><li><p><strong>Group Vars</strong><br>这是将提供给指定组的变量，尤其是复杂的数据结构，这样这些变量就不必嵌入到库存文件或playbook中。</p></li><li><p><strong>Handlers</strong><br>处理程序就像Ansible playbook中的常规任务，但只有在任务包含<code>notify</code>指定并且还指示它已更改某些内容时才会运行。</p></li><li><p><strong>Host</strong><br>主机是Ansible管理的远程机器。</p></li><li><p><strong>Host Specifier</strong><br>Ansible中的每个<code>play</code>都将一系列任务映射到一组系统。每个<code>play</code>中的<code>hosts:</code>指令通常称为主机说明符。它可以选择一个或多个系统，一个或多个组，甚至一个组中的一些主机，而不是另一个组中的主机。</p></li><li><p><strong>Host Vars</strong><br>主机变量类似与组变量。</p></li><li><p><strong>Idempotency</strong><br>如果执行一次的结果与在没有任何干预动作的情况下重复执行它的结果完全相同，则操作是幂等的。</p></li><li><p><strong>Includes</strong><br>playbook文件可以包括其它play list，任务列表可以外部化其它文件中的任务列表，类似于处理程序。</p></li><li><p><strong>Inventory</strong><br>用于描述Ansible中的主机和组的文件。</p></li><li><p><strong>Inventory Script</strong><br>一个程序，用于查找主机，主机的组关系以及外部资源的变量信息——无论是SQL数据库，CMDB方案，还是LDAP等。</p></li><li><p><strong>Jinja2</strong><br>Jinja2是Ansible模板模块的首选语言。它是一种非常简单的Python模板语言，可读且易于编写。</p></li><li><p><strong>JSON</strong><br>Ansible使用JSON从远程模块返回数据。这允许用任何语言编写。</p></li><li><p><strong>Lazy Evaluation</strong><br>通常，Ansible会在最后一秒评估playbook内容中的任何变量。</p></li><li><p><strong>Library</strong><br>Ansible的模块集合。</p></li><li><p><strong>Limit Groups</strong><br>通过将<code>--limit somegroup</code>传递给Ansible或ansible-playbook可以限制主机的子集。</p></li><li><p><strong>Local Action</strong><br>针对远程计算机的playbook中的本地活动指令意味着给定的步骤实际上将在本地计算机上发生，但是可以传入变量<code></code>以引用该步骤中引用的远程主机名。</p></li><li><p><strong>Local Connection</strong><br>通过在playbook中使用<code>connection: local</code>，或将<code>-c local</code>传递给<code>/usr/bin/ansible</code>，这表明我们正在管理本地主机而不是远程主机。</p></li><li><p><strong>Lookup Plugin</strong><br>查找插件是一种从外部获取数据到Ansible的方法。</p></li><li><p><strong>Loops</strong><br>通常，Ansible不是一种编程语言。它更喜欢声明性，尽管循环这样的各种结构允许对列表中的多个项重复特定任务。</p></li><li><p><strong>Modules</strong><br>模块是Ansible发送到远程机器的工作单元。</p></li><li><p><strong>Multi-Tier</strong><br>IT系统不是一次管理一个系统的概念，而是通过明确定义的订单中多个系统和系统组之间的交互。</p></li><li><p><strong>Notify</strong><br>任务注册更改事件并通知处理程序任务需要在play结束时运行另一个操作的行为。</p></li><li><p><strong>Orchestration</strong><br>许多软件自动化系统使用这个词来表示不同的东西。Ansible使用它作为编排的指挥。</p></li><li><p><strong>paramiko</strong><br>默认情况下，Ansible通过SSH管理机器。Ansible默认使用的库是一个名为paramiko的Python驱动库。</p></li><li><p><strong>Playbooks</strong><br>playbook是Ansible编排，配置，管理或部署系统的语言。它被称为剧本，部分原因在于它是一种运动类比，并且使用它们应该很有趣。</p></li><li><p><strong>Plays</strong><br>A playbook is a list of plays。剧本最小是由主机说明符选择的一组主机之间的映射，以及在这些主机上运行定义这些系统将执行的角色的任务。</p></li><li><p><strong>Pull Mode</strong><br>默认情况下，Ansible以<code>push</code>模式运行，这使得它可以在与每个系统进行通信时进行非常精细的控制。当你希望在特定计划时间点检查节点时，可以使用<code>pull</code>模式。</p></li><li><p><strong>Push Mode</strong></p></li><li><p><strong>Register Variable</strong><br>在Ansible中运行任何任务的结果可以存储在变量中，以便在模板或条件语句中使用。</p></li><li><p><strong>Resource Model</strong><br>Ansible模块在资源方面起作用。</p></li><li><p><strong>Roles</strong><br>角色是Ansible的组织单位。</p></li><li><p><strong>Rolling Update</strong><br>一次解决组中的多个节点的行为，以避免一次更新所有节点并使系统脱机。</p></li><li><p><strong>Sudo</strong></p></li><li><p><strong>SSH (Native)</strong></p></li><li><p><strong>Tags</strong><br>Ansible允许使用任意关键字标记剧本中的资源，然后仅运行与这些关键字对应的剧本部分。</p></li><li><p><strong>Task</strong><br>任务将操作(模块及其参数)与名称和可选的其他关键字(如循环指令)组合在一起。</p></li><li><p><strong>Templates</strong><br>Ansible可以轻松地将文件传输到远程系统，但通常需要在其它文件中替换变量。</p></li><li><p><strong>Transport</strong><br>Ansible使用<code>term:</code>连接插件来定以可用传输的类型。</p></li><li><p><strong>When</strong><br>一个可选的条件语句。</p></li><li><p><strong>Vars (Variables)</strong><br>与事实相反，变量是值的名称(int, bool, string)或复杂的数据(dict, hash, lists)。它是声明的东西，而不是从远程系统获取的东西。</p></li><li><p><strong>YAML</strong><br>Ansible不想强迫人们编写程序代码来自动化基础设施，因此使用YAML来定义剧本配置语言和变量文件。</p></li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h1><p>Installtion Guide: <a href="https://docs.ansible.com/ansible/latest/installation_guide/index.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/installation_guide/index.html</a></p><p><br></p><h2 id="安装Ansible"><a href="#安装Ansible" class="headerlink" title="安装Ansible"></a>安装Ansible</h2><p>Installing Ansible: <a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html</a></p><p>Ansible是一个默认通过SSH协议管理机器的无代理(agentless)的自动化工具。一旦安装，Ansible不添加数据库，并且不需要启动守护进程。你只需要在一台机器上安装它，它可以从该中心点管理远程所有机器。</p><p><br></p><p><br></p><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>Prerequisite</p><p>在控制节点上安装Ansible，然后使用SSH(默认)与管理的节点通信。</p><p><br></p><p><strong>控制节点的依赖</strong><br>Control node requirements</p><p>目前，Ansible可以从任何安装了Python2.7或Python3.5+的机器上运行。不支持Windows。</p><p><br></p><p><strong>被管理节点的依赖</strong></p><p>Managed node requirements</p><p>在被管理的节点上，你需要一种方法来通信（通常是SSH）。</p><p><br><br><br></p><h3 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a>选择版本</h3><p>Selecting an Ansible version to install</p><p>选择自己需要的Ansible版本进行安装，可选择一下几种方式：</p><ul><li>使用操作系统包管理器进行安装</li><li>使用pip进行安装</li><li>使用源码进行安装</li></ul><p><br><br><br></p><h3 id="在RHEL上安装"><a href="#在RHEL上安装" class="headerlink" title="在RHEL上安装"></a>在RHEL上安装</h3><p>Installing Ansible on RHEL, CentOS, or Fedora</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum search ansible</span><br><span class="line"></span><br><span class="line">sudo yum install ansible</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用pip安装"><a href="#使用pip安装" class="headerlink" title="使用pip安装"></a>使用pip安装</h3><p>Installing Ansible with pip</p><p>使用Python的包管理工具pip来安装Ansible。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># env</span></span><br><span class="line"><span class="comment"># python -m virtualenv ansible</span></span><br><span class="line"><span class="comment"># source ansible/bin/activate</span></span><br><span class="line">pip install --user ansible</span><br><span class="line">pip install --user paramiko</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Ansible-command-shell-completion"><a href="#Ansible-command-shell-completion" class="headerlink" title="Ansible command shell completion"></a>Ansible command shell completion</h3><p>Ansible 2.9的命令行工具由称为<code>argcomplete</code>的依赖提供。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install python-argcomplete</span><br><span class="line"></span><br><span class="line"><span class="comment"># pip</span></span><br><span class="line"><span class="comment"># pip install argcomplete</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置argcomplete</strong></p><p>有两种方式来配置Ansible的命令行工具argcomplete：</p><ul><li>全局(Globally)</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global completion requires bash 4.2.</span></span><br><span class="line">sudo activate-global-python-argcomplete</span><br></pre></td></tr></table></figure><ul><li>每个命令(Per command)</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If you do not have bash 4.2, you must register each script independently.</span></span><br><span class="line"><span class="comment"># 可将这些写入.profile里</span></span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-config)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-console)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-doc)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-galaxy)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-inventory)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-playbook)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-pull)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-vault)</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="配置Ansible"><a href="#配置Ansible" class="headerlink" title="配置Ansible"></a>配置Ansible</h2><p>Configuring Ansible: <a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_configuration.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/installation_guide/intro_configuration.html</a></p><p><br></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Configuration file</p><p>Ansible将按照一下顺序搜索配置文件：</p><ul><li><code>ANSIBLE_CONFIG</code>环境变量</li><li><code>ansible.cfg</code>当前目录</li><li><code>~/.ansible.cfg</code></li><li><code>/etc/ansible/ansible.cfg</code></li></ul><p><br></p><p><a href="https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings" target="_blank" rel="noopener">Ansible配置参考</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Ansible移植指南"><a href="#Ansible移植指南" class="headerlink" title="Ansible移植指南"></a>Ansible移植指南</h1><p>Ansible Porting Guides: <a href="https://docs.ansible.com/ansible/latest/porting_guides/porting_guides.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/porting_guides/porting_guides.html</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="用户指南"><a href="#用户指南" class="headerlink" title="用户指南"></a>用户指南</h1><p>User Guide: <a href="https://docs.ansible.com/ansible/latest/user_guide/index.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/index.html</a></p><p>本指南介绍如何使用Ansible工作，包括CLI, invetory, playbooks。</p><p><br><br><br></p><h2 id="Quickstart"><a href="#Quickstart" class="headerlink" title="Quickstart"></a>Quickstart</h2><p>Ansible Quickstart Guide: <a href="https://docs.ansible.com/ansible/latest/user_guide/quickstart.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/quickstart.html</a></p><p><br><br><br></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Ansible concepts: <a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html</a></p><ul><li><strong>Controle node</strong>：按照Ansible的任意机器。Windows机器无法作为控制节点。可以有多个控制节点。</li><li><strong>Managed nodes</strong>：使用Ansible管理的网络设备。通常称为主机，Ansible未安装在管理节点上。</li><li><strong>Inventory</strong>：一组管理节点的列表。清单文件有时称为主机文件(hostfile)。</li><li><strong>Modules</strong>：Ansible执行代码单元。<a href="https://docs.ansible.com/ansible/latest/modules/modules_by_category.html#modules-by-category" target="_blank" rel="noopener">Ansible模块列表</a></li><li><strong>Tasks</strong>：Ansible中的动作单元。可使用<code>ad-hoc</code>命令执行单一任务一次。</li><li><strong>Playbooks</strong>：任务的有序列表。可按照顺序反复执行这些任务。剧本可以包含变量和任务。它以YAML格式编写。</li></ul><p><br><br><br></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>Getting Started: <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html</a></p><p>一个基本的Ansible命令或playbooks：</p><ul><li>从清单中选择机器来执行</li><li>连接到这些机器（通常是SSH）</li><li>复制一个或多个模块到远程机器，并执行</li></ul><p>Ansible可以做很多事。一旦你理解了Ansible是如何工作的，你可以阅读有关的<code>ad-hoc</code>命令的详细信息，使用清单组织你的基础架构，并利用Ansible强大的playbooks。</p><p><br><br><br></p><h3 id="从清单选择机器"><a href="#从清单选择机器" class="headerlink" title="从清单选择机器"></a>从清单选择机器</h3><p>Ansible从你的清单中读取管理的机器的信息。虽然你可以通过IP地址和<code>ad-hoc</code>命令，你也需要清单来增加Ansible的灵活性和重复性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个基本的清单</span><br><span class="line"># 在此文件中添加远程系统</span><br><span class="line">vim /etc/ansible/hosts</span><br><span class="line">192.0.2.50</span><br><span class="line">aserver.example.org</span><br><span class="line">bserver.example.org</span><br></pre></td></tr></table></figure><p>也可以使用别名(aliases)，主机变量(host vars)，组变量(group vars)。</p><p><br><br><br></p><h3 id="连接到远程节点"><a href="#连接到远程节点" class="headerlink" title="连接到远程节点"></a>连接到远程节点</h3><p>Ansible与远程机器通过SSH协议进行通信。默认情况下，Ansible使用原生的OpenSSH连接到远程机器。</p><p>确认用户名可使用SSH进行连接。如有必要，将SSH公钥添加到系统的<code>authorized_keys</code>文件。</p><p><br><br><br></p><h3 id="复制和执行模块"><a href="#复制和执行模块" class="headerlink" title="复制和执行模块"></a>复制和执行模块</h3><p>一旦建立连接，Ansible传输你的命令或剧本需要的模块到远程机器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 运行第一个ansible命令</span><br><span class="line">ansible all -m ping</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 运行一个节点上的命令</span><br><span class="line">ansible all -a &quot;/bin/echo hell&quot;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="如何构建清单"><a href="#如何构建清单" class="headerlink" title="如何构建清单"></a>如何构建清单</h2><p>How to build your inventory: <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html</a></p><p>Ansible对多个被管理的节点使用被称为清单的列表或组列表。一旦清单定义，你可以选择主机或组来运行。</p><p>清单的默认位置是<code>/etc/ansible/hosts</code>。可以通过<code>-i</code>选项来指定不同的清单文件。也可以同时使用多个清单文件。从动态或云拉取清单。</p><p><br><br><br></p><h3 id="清单基本"><a href="#清单基本" class="headerlink" title="清单基本"></a>清单基本</h3><p>formats, hosts, groups。</p><p>清单文件有多种形式。最常用的是INI和YAML。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># INI格式</span></span><br><span class="line">mail.example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组名</span></span><br><span class="line"><span class="section">[webservers]</span></span><br><span class="line">a.example.com</span><br><span class="line">b.example.com</span><br><span class="line"></span><br><span class="line"><span class="section">[dbserver]</span></span><br><span class="line">db1.example.com</span><br><span class="line">db2.example.com</span><br><span class="line">db3.example.com</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># YAML格式</span></span><br><span class="line"><span class="attr">all:</span></span><br><span class="line"><span class="attr">  hosts:</span></span><br><span class="line">    <span class="string">mail.example.com:</span></span><br><span class="line"><span class="attr">  children:</span></span><br><span class="line"><span class="attr">    webserver:</span></span><br><span class="line"><span class="attr">      hosts:</span></span><br><span class="line">        <span class="string">a.example.com:</span></span><br><span class="line">        <span class="string">b.example.com:</span></span><br><span class="line"><span class="attr">    dbservers:</span></span><br><span class="line"><span class="attr">      hosts:</span></span><br><span class="line">        <span class="string">db1.example.com:</span></span><br><span class="line">        <span class="string">db2.example.com:</span></span><br><span class="line">        <span class="string">db3.example.com:</span></span><br></pre></td></tr></table></figure><p><br></p><p>默认组(default groups)，有两个默认组。</p><ul><li><code>all</code>：包含每个主机</li><li><code>ungrouped</code>：all中没有组的主机</li></ul><p><br></p><p>在多个组中的主机(Hosts in multiple groups)。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">all:</span></span><br><span class="line"><span class="attr">  hosts:</span></span><br><span class="line">    <span class="string">mail.example:</span></span><br><span class="line"><span class="attr">  children:</span></span><br><span class="line"><span class="attr">    webservers:</span></span><br><span class="line"><span class="attr">      hosts:</span></span><br><span class="line">        <span class="string">f.example.com:</span></span><br><span class="line">        <span class="string">b.example.com:</span></span><br><span class="line"><span class="attr">    dbservers:</span></span><br><span class="line"><span class="attr">      hosts:</span></span><br><span class="line">        <span class="string">one.example.com:</span></span><br><span class="line">        <span class="string">two.example.com:</span></span><br><span class="line"><span class="attr">    east:</span></span><br><span class="line"><span class="attr">      hosts:</span></span><br><span class="line">        <span class="string">f.example.com:</span></span><br><span class="line">        <span class="string">one.example.com:</span></span><br><span class="line"><span class="attr">    west:</span></span><br><span class="line"><span class="attr">      hosts:</span></span><br><span class="line">        <span class="string">b.example.com:</span></span><br><span class="line">        <span class="string">two.example.com:</span></span><br><span class="line"><span class="attr">    prod:</span></span><br><span class="line"><span class="attr">      children:</span></span><br><span class="line"><span class="attr">        east:</span></span><br><span class="line"><span class="attr">    test:</span></span><br><span class="line"><span class="attr">      hosts:</span></span><br><span class="line">        <span class="string">b.example.com:</span></span><br></pre></td></tr></table></figure><p><br></p><p>添加主机范围(Adding ranges of hosts)。如果有很多主机有一个类似的模式，可将其添加为一个范围，而不是单独列出每个主机名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">  webservers:</span></span><br><span class="line"><span class="attr">    hosts:</span></span><br><span class="line">      <span class="string">www[01:20].example.com:</span></span><br><span class="line"><span class="attr">  dbservers:</span></span><br><span class="line"><span class="attr">    hosts:</span></span><br><span class="line">      <span class="string">db-[a:f].example.com</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="添加变量到清单"><a href="#添加变量到清单" class="headerlink" title="添加变量到清单"></a>添加变量到清单</h3><p>Adding variables to inventory</p><p>可以在清单中存储涉及到特定主机或组的变量值。</p><p><br><br><br></p><h3 id="主机变量"><a href="#主机变量" class="headerlink" title="主机变量"></a>主机变量</h3><p>Assigning a variable to one machine: host variables</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">atlanta:</span></span><br><span class="line"><span class="attr">  hosts1:</span></span><br><span class="line"><span class="attr">    http_port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    maxRequestPerChild:</span> <span class="number">808</span></span><br><span class="line"><span class="attr">  hosts2:</span></span><br><span class="line"><span class="attr">    http_port:</span> <span class="number">303</span></span><br><span class="line"><span class="attr">    maxRequestPerChild:</span> <span class="number">909</span></span><br></pre></td></tr></table></figure><p><br></p><p>清单别名(Inventory aliases)。在清单中定义别名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">  hosts:</span></span><br><span class="line"><span class="attr">    jumper:</span></span><br><span class="line"><span class="attr">      ansible_port:</span> <span class="number">5555</span></span><br><span class="line"><span class="attr">      ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.50</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="组变量"><a href="#组变量" class="headerlink" title="组变量"></a>组变量</h3><p>Assigning a variable to many machines: group variables</p><p>在一组的主机中共享变量值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">atlanta:</span></span><br><span class="line"><span class="attr">  hosts:</span></span><br><span class="line"><span class="attr">    hosts1:</span></span><br><span class="line"><span class="attr">    host2:</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    ntp_server:</span> <span class="string">ntp.atlanta.example.com</span></span><br><span class="line"><span class="attr">    proxy:</span> <span class="string">proxy.atlanta.example.com</span></span><br></pre></td></tr></table></figure><p><br></p><p>继承变量值(Inheriting variable values: group variables for groups of groups)。可使用<code>children:</code>(yaml)来构建组的组，同样，可使用<code>vars:</code>来构建组变量的组变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">all:</span></span><br><span class="line"><span class="attr">  children:</span></span><br><span class="line"><span class="attr">    usa:</span></span><br><span class="line"><span class="attr">      children:</span></span><br><span class="line"><span class="attr">        southeast:</span></span><br><span class="line"><span class="attr">          children:</span></span><br><span class="line"><span class="attr">            atlanta:</span></span><br><span class="line"><span class="attr">              hosts:</span></span><br><span class="line"><span class="attr">                hosts1:</span></span><br><span class="line"><span class="attr">                hosts2:</span></span><br><span class="line"><span class="attr">            raleigh:</span></span><br><span class="line"><span class="attr">              hosts:</span></span><br><span class="line"><span class="attr">                hosts2:</span></span><br><span class="line"><span class="attr">                hosts3:</span></span><br><span class="line"><span class="attr">            vars:</span></span><br><span class="line"><span class="attr">              some_server:</span> <span class="string">foo.southeast.example.com</span></span><br><span class="line"><span class="attr">              halon_system_timeout:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">              self_destruct_countdown:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">              escape_pods:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">          northeast:</span></span><br><span class="line"><span class="attr">          norethwest:</span></span><br><span class="line"><span class="attr">          southwest:</span></span><br></pre></td></tr></table></figure><p>子组有几个属性的注意事项：</p><ul><li>子组成员的任何主机自动成为父组的成员</li><li>子组的变量的优先级高于(覆盖)父组的变量</li><li>组可以有多个父亲和孩子</li><li>主机可以在多个组，但只会有一台主机实例，合并来自多个组的数据</li></ul><p><br><br><br></p><h3 id="组织主机和组变量"><a href="#组织主机和组变量" class="headerlink" title="组织主机和组变量"></a>组织主机和组变量</h3><p>Organizing host and group variables</p><p>尽管你可以将变量存储在清单文件，但存储独立的主机和组变量可以帮助您更轻松地阻止你的变量值。主机和组变量文件必须使用YAML语法。</p><p>Ansible通过搜索清单文件或剧本文件的路径来载入主机和组变量文件。</p><p><br><br><br></p><h3 id="变量如何合并"><a href="#变量如何合并" class="headerlink" title="变量如何合并"></a>变量如何合并</h3><p>How variables are merged</p><p>默认情况下，在play运行前变量被合并到特定的主机。这使Ansible集中在主机和任务，因此组并没有真正生存在清单和主机匹配之外。Ansible覆盖变量的顺序：</p><ul><li>all group</li><li>parent group</li><li>child group</li><li>host</li></ul><p>默认情况下Ansible在相同的父/子级按字母顺序合并组，并在最后一组加载覆盖前面的组。你可以通过设置组变量<code>ansible_group_priority</code>来改变同级组合并顺序的行为。数字越大，优先级就越高。默认值是1。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># testvar == a</span></span><br><span class="line"><span class="attr">a_group:</span></span><br><span class="line"><span class="attr">  testvar:</span> <span class="string">a</span></span><br><span class="line"><span class="attr">  ansible_group_priority:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">b_group:</span></span><br><span class="line"><span class="attr">  testvar:</span> <span class="string">b</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用多个清单源"><a href="#使用多个清单源" class="headerlink" title="使用多个清单源"></a>使用多个清单源</h3><p>Using multiple inventory sources</p><p>可通过在命令行中或配置<code>ANSIBLE_INVENTORY</code>通过给定多个清单参数在同一时间目标多个清单源（目录，动态清单脚本，清单插件…）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># target 2 sources</span></span><br><span class="line"><span class="string">ansible-playbook</span> <span class="string">get_logs.yml</span> <span class="bullet">-i</span> <span class="string">staging</span> <span class="bullet">-i</span> <span class="string">production</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>以一个目录组合多个清单源(Aggregating inventory sources with a directory)</strong></p><p>还可以通过一个目录下结合多个清单源和原类型来创建清单。这对于动静结合主机和管理它们为一体化清单很有用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">inventory/</span></span><br><span class="line">  <span class="string">openstack.yml</span>          <span class="comment"># configure inventory plugin to get hosts from Openstack cloud</span></span><br><span class="line">  <span class="string">dynamic-inventory.py</span>   <span class="comment"># add additional hosts with dynamic inventory script</span></span><br><span class="line">  <span class="string">static-inventory</span>       <span class="comment"># add static hosts and groups</span></span><br><span class="line">  <span class="string">group_vars/</span></span><br><span class="line">    <span class="string">all.yml</span>              <span class="comment"># assign variables to all hosts</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># target inventory</span></span><br><span class="line">ansible-playbook example.yml -i inventory</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="清单参数"><a href="#清单参数" class="headerlink" title="清单参数"></a>清单参数</h3><p>Connecting to hosts: behavioral inventory parameters</p><p>以下变量控制与远程主机如何与Ansible相互作用。</p><p><br><br><br></p><h3 id="清单配置样例"><a href="#清单配置样例" class="headerlink" title="清单配置样例"></a>清单配置样例</h3><p>Inventory setup examples</p><ul><li>每个环境一个清单(One inventory per environment)</li><li>通过功能分组(Group by function)</li><li>通过地址分组(Group by location)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Example: One inventory per environment</span><br><span class="line"># inventory_test</span><br><span class="line">[dbservers]</span><br><span class="line">db01.test.example.com</span><br><span class="line">db02.test.example.com</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: Group by function</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">dbservers</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">allow</span> <span class="string">access</span> <span class="string">from</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    iptables:</span></span><br><span class="line"><span class="attr">      chain:</span> <span class="string">INPUT</span></span><br><span class="line"><span class="attr">      jump:</span> <span class="string">ACCEPT</span></span><br><span class="line"><span class="attr">      source:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Example: Group by location</span><br><span class="line">[dc1]</span><br><span class="line">db01.test.example.com</span><br><span class="line">app01.test.example.com</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="动态清单"><a href="#动态清单" class="headerlink" title="动态清单"></a>动态清单</h2><p>Working with dynamic inventory: <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html</a></p><p><br></p><h3 id="cobbler"><a href="#cobbler" class="headerlink" title="cobbler"></a>cobbler</h3><p><br><br><br></p><h3 id="AWS-ec2"><a href="#AWS-ec2" class="headerlink" title="AWS ec2"></a>AWS ec2</h3><p><br><br><br></p><h3 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h3><p><br><br><br></p><h3 id="其它清单脚本"><a href="#其它清单脚本" class="headerlink" title="其它清单脚本"></a>其它清单脚本</h3><p>Other inventory scripts</p><p><br><br><br><br><br></p><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>Patterns: targeting hosts and groups: <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html</a></p><p>当你通过<code>ad-hoc</code>或<code>playbook</code>执行Ansible时，你必须选择要对哪些节点或组执行。模式可以让你针对清单中的特定主机或组执行。一个Ansible Pattern可以指定单个主机、IP地址、清单组、一组组、所有主机…模式非常灵活，可以排除需要的主机子集、使用通配符、正则表达式…Ansible将在包含在模式上的所有清单主机上执行。</p><p><br></p><h3 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h3><p>Using patterns</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ad-hoc</span></span><br><span class="line"><span class="comment"># ansible &#123;pattern&#125; -m &#123;module_name&#125; -a "&#123;module_options&#125;"</span></span><br><span class="line">ansible webservers -m service -a <span class="string">"name=httpd state=restarted"</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># palybook</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">&#123;play_name&#125;</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">&#123;pattern&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">restart</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">webservers</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="常见模式"><a href="#常见模式" class="headerlink" title="常见模式"></a>常见模式</h3><p>Common patterns</p><div class="table-container"><table><thead><tr><th>描述</th><th>模式</th><th>目标</th></tr></thead><tbody><tr><td>All hosts</td><td>all(*)</td><td>-</td></tr><tr><td>One host</td><td>host1</td><td>-</td></tr><tr><td>Multiple hosts</td><td>host1:host2(host1,host2)</td><td>-</td></tr><tr><td>One group</td><td>g1</td><td>-</td></tr><tr><td>Multiple groups</td><td>g1:g2</td><td>all hosts in g1 and g2</td></tr><tr><td>Excluding groups</td><td>g1:!g2</td><td>all hosts in g1 except those in g2</td></tr><tr><td>Intersection of groups</td><td>g1:&amp;g2</td><td>g1和g2的交集</td></tr></tbody></table></div><p><br><br><br></p><h3 id="模式的局限性"><a href="#模式的局限性" class="headerlink" title="模式的局限性"></a>模式的局限性</h3><p>Limitations of patterns</p><p>模式依赖于清单。如果主机或组不在清单中，则不能使用模式来目标它。如果模式中包含清单中不存在的IP地址或主机名，会报错。模式必须匹配清单语法。</p><p><br><br><br></p><h3 id="高级的模式选项"><a href="#高级的模式选项" class="headerlink" title="高级的模式选项"></a>高级的模式选项</h3><p>Advanced pattern options</p><p>常用的模式将满足你的大部分需求，但Ansible提供了几种方法来定义你需要定位(target)的主机和组。</p><p><strong>在模式中使用环境变量</strong><br>Using variables in patterns</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># playbook</span><br><span class="line">webservers:!&#123;&#123; excluded &#125;&#125;:&amp;&#123;&#123; required &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>在模式中使用组位置</strong><br>Using group position in patterns</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[g1]</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">cc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1[0]</span><br><span class="line">g1[-1]</span><br><span class="line">g1[0:2]</span><br><span class="line">g1[1:]</span><br></pre></td></tr></table></figure><p><strong>在模式中使用正则</strong><br>Using regexes in patterns</p><p>以<code>~</code>符号开始使用模式的正则: <code>~(web|db).*\.example\.com</code></p><p><br><br><br></p><h3 id="playbook标志"><a href="#playbook标志" class="headerlink" title="playbook标志"></a>playbook标志</h3><p>Patterns and ansible-playbook flags</p><p>可以使用命令行选项改变playbook中定义的行为。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook site.yml --<span class="built_in">limit</span> datacenter2</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="ad-hoc"><a href="#ad-hoc" class="headerlink" title="ad-hoc"></a>ad-hoc</h2><p>Introduction to ad-hoc commands: <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_adhoc.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/intro_adhoc.html</a></p><p>一个Ansible的<code>ad-hoc</code>命令使用ansible命令行工具在一个或多个管理节点上执行单一任务。<code>ad-hoc</code>命令是快速和容易的，但却无法重复使用。那么为什么首先学习<code>ad-hoc</code>命令呢？它表明Ansible的简单和功能。在这学的内容可直接到playbook里。在执行前，请先阅读构建清单。</p><p><code>ansible</code>命令行实用程序的默认模块是<a href="https://docs.ansible.com/ansible/latest/modules/command_module.html" target="_blank" rel="noopener">command module</a>。</p><p>如果像重复一个命令，可使用playbook中的template module。</p><p><br></p><h3 id="为什么使用它"><a href="#为什么使用它" class="headerlink" title="为什么使用它"></a>为什么使用它</h3><p>Why use ad-hoc commands?</p><p><code>ad-hoc</code>命令针对的是很少会重复的任务。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 栗子</span></span><br><span class="line">ansible [pattern] -m [module] -a <span class="string">"[module options]"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>Use cases for ad-hoc tasks</p><p><code>ad-hoc</code>任务可用来重启服务器、复制文件、管理包和用户…可在<code>ad-hoc</code>任务中使用任意Ansible模块。Ad-hoc tasks与playbooks类似，使用一个声明模型，计算并执行以达到规定的最终状态所需的操作。</p><p><br></p><p><strong>重启服务器</strong></p><p><code>ad-hoc</code>任务调用命令模块。在执行前，确保清单和SSH。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rebooting servers</span></span><br><span class="line">ansible host1 -a <span class="string">"/sbin/reboot"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认是5并发进程</span></span><br><span class="line">ansible host1 -a <span class="string">"/sbin/reboot"</span> -f 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible将默认为你的用户账户</span></span><br><span class="line">ansible host1 -a <span class="string">"/sbin/reboot"</span> -f 10 -u username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务器可能需要特权提升，如从user到root</span></span><br><span class="line">ansible host1 -a <span class="string">"/sbin/reboot"</span> -f 10 -u username --become [--ask-become-pass]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用不同的模块</span></span><br><span class="line">ansible host1 -m shell -a <span class="string">'echo $&#123;TERM&#125;'</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>文件管理</strong></p><p><code>ad-hoc</code>可利用Ansible和scp的力量，并行传输文件到多台机器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制文件</span></span><br><span class="line">ansible atlanta -m copy -a <span class="string">"src=/etc/hosts dest=/tmp/hosts"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># file模块属主和权限，创建目录，递归删除</span></span><br><span class="line">ansible webservers -m file -a <span class="string">"dest=/srv/foo/b.txt mode=600 owner=mdehaan group=mdehaan"</span></span><br><span class="line">ansible webservers -m file -a <span class="string">"dest=/path/to/c mode=755 owner=mdehaan group=mdehaan state=directory"</span></span><br><span class="line">ansible webservers -m file -a <span class="string">"dest=/path/to/c state=absent"</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>包管理</strong></p><p>使用<code>ad-hoc</code>任务使用包管理模块（如yum），来安装、升级、移除包。</p><p>Ansible有许多平台的许多包管理工具的模块，详情请看文档。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装了包不更新</span></span><br><span class="line">ansible webservers -m yum -a <span class="string">"name=acme state=present"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定包版本</span></span><br><span class="line">ansible webservers -m yum -a <span class="string">"name=acme-1.5 state=present"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认包是最新版</span></span><br><span class="line">ansible webservers -m yum -a <span class="string">"name=acme state=latest"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保未安装</span></span><br><span class="line">ansible webservers -m yum -a <span class="string">"name=acme state=absent"</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>管理用户和组</strong></p><p>使用<code>ad-hoc</code>任务在管理的节点上创建、管理、移除用户账户。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m user -a <span class="string">"name=foo password=&#123;crypted password here&#125;"</span></span><br><span class="line"></span><br><span class="line">ansible all -m user -a <span class="string">"name=foo state=absent"</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>服务管理</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保服务已启动</span></span><br><span class="line">ansible webservers -m service -a <span class="string">"name=httpd state=started"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">ansible webservers -m service -a <span class="string">"name=httpd state=restarted"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保服务已停止</span></span><br><span class="line">ansible webservers -m service -a <span class="string">"name=httpd state=stopped"</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>收集事实</strong></p><p>事实代表发现关于系统的变量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有facts</span></span><br><span class="line">ansible all -m setup</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="连接方法和详情"><a href="#连接方法和详情" class="headerlink" title="连接方法和详情"></a>连接方法和详情</h2><p>Connection methods and details: <a href="https://docs.ansible.com/ansible/latest/user_guide/connection_details.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/connection_details.html</a></p><p><br></p><h3 id="ControlPersist和paramiko"><a href="#ControlPersist和paramiko" class="headerlink" title="ControlPersist和paramiko"></a>ControlPersist和paramiko</h3><p>默认情况下，Ansible使用原生的OpenSSH，因为它支持ControlPersist（一个性能特点），Kerberos，和<code>~/.ssh/config</code>中的配置。如果你的控制机使用的旧版本OpenSSH不支持ControlPersist，Ansible将回退到称为<code>paramiko</code>的一个Python实现的OpenSSH。</p><p><br><br><br></p><h3 id="ssh-key配置"><a href="#ssh-key配置" class="headerlink" title="ssh-key配置"></a>ssh-key配置</h3><p>SSH key setup</p><p>默认情况下，Ansible假定您使用SSH keys连接到远程主机。推荐使用key，但可使用<code>--ask-pass</code>选项来使用密码。使用<code>--ask-become-pass</code>选项来使用特权提升。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立ssh agent来避免输入密码</span></span><br><span class="line">ssh-agent bash</span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><p>Running against localhost</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible localhost -m ping -e <span class="string">'ansible_python_interpreter="/usr/bin/env python"'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="主机密钥检查"><a href="#主机密钥检查" class="headerlink" title="主机密钥检查"></a>主机密钥检查</h3><p>Host key checking</p><p>Ansible默认启用主机密钥检查。如果主机重装并在<code>known_hosts</code>中有不同的密钥，这将导致一个错误消息，知道纠正。</p><p>可在<code>/etc/ansible/ansible.cfg</code>或<code>~/.ansible.cfg</code>中禁用它:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[defaults]</span><br><span class="line">host_key_checking = False</span><br></pre></td></tr></table></figure><p>或设置环境变量: <code>export ANSIBLE_HOST_KEY_CHECKING=False</code></p><p><br><br><br></p><h3 id="其它连接方法"><a href="#其它连接方法" class="headerlink" title="其它连接方法"></a>其它连接方法</h3><p>Other connection methods</p><p>除了SSH之外，Ansible还可以使用许多连接方法。</p><p><br><br><br><br><br></p><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>Working with command line tools: <a href="https://docs.ansible.com/ansible/latest/user_guide/command_line_tools.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/command_line_tools.html</a></p><p>大多数用户对<code>ansible</code>和<code>ansilbe-playbook</code>比较熟悉，但它们不是Ansible提供的唯一实用工具。下面是完整的Ansible使用工具列表。</p><ul><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible.html" target="_blank" rel="noopener">ansible</a>: 在一组主机上定义和运行一个单任务playbook</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-config.html" target="_blank" rel="noopener">ansible-config</a>: 查看Ansible配置信息</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-console.html" target="_blank" rel="noopener">ansible-console</a>: REPL控制台执行Ansible任务</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-doc.html" target="_blank" rel="noopener">ansible-doc</a>: 插件文档工具</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-galaxy.html" target="_blank" rel="noopener">ansible-galaxy</a>: 执行各种角色并收集相关的操作</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-inventory.html" target="_blank" rel="noopener">ansible-invotory</a>: 显示或转配置清单</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-playbook.html" target="_blank" rel="noopener">ansible-playbook</a>: 运行Ansible playbook</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-pull.html" target="_blank" rel="noopener">ansible-pull</a>: 从仓库拉playbook并为本地主机执行</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-vault.html" target="_blank" rel="noopener">ansible-valut</a>: Ansible数据文件的加解密工具</li></ul><p><br><br><br><br><br></p><h2 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h2><p>Working With Playbooks: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks.html</a></p><p>Playbooks是Ansible的配置(configuration)、部署(deployment)和编排(orchestration)语言。它可以描述你希望你的远程系统强制执行的策略，或在IT流程的步骤。</p><p>在最基本的级别上，playbook可以被用来管理部署的配置到远程机器。在更高级的，它们可以序列进行涉及多层(mulit-tier)的滚动更新和回滚，并可以委托操作其它主机，与监控服务器进行交互和负载均衡。它有很多功能和信息，详情看文档。</p><p>playbook被设计为人类可读的和基于文本语言开发。有多种方式来组织playbook和它包含的文件。</p><p>你应该看一看<a href="https://github.com/ansible/ansible-examples" target="_blank" rel="noopener">Example Playbooks</a>，并与playbook文档一起阅读。这些说明的最佳实践，以及如何把众多的各种概念混合在一起。</p><p><br></p><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Intro to Playbooks: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html</a></p><p>playbook是比在<code>ad-hoc</code>任务执行模式下的一个完全不同的使用ansible的方式，并且特别强大。</p><p>简单来说，Playbook是一个非常基础的用于配置管理和多机部署系统，不同于任何已存在的，并且非常适合部署复杂的应用程序。</p><p>playbook可以声明配置，但它也可以通过编排任意手动排序进程的步骤，尽管不同的步骤必须来回在特定命令的机器之间。它可以同步(synchronously)或异步(asynchronously)发射任务。</p><p>虽然你为<code>ad-hoc</code>任务运行主要的<code>/usr/bin/ansible</code>程序，playbook更可能被保持在原控制和用于推送配置或保证远程系统上的配置。palybook example中有许多栗子，建议去看一看。</p><p><br></p><h4 id="playbook-language"><a href="#playbook-language" class="headerlink" title="playbook language"></a>playbook language</h4><p>playbook以YAML语法格式表示，故意不设计成一种编程语言或脚本，而是过程或配置的模型。</p><p>每个playbooks由列表中的play组成。play的目标是映射一组主机到一些良好定义的角色(roles)，由ansible调用任务来表示。通过多个paly组成playbook，有可能协调多机部署，在某个组的所有机器上运行某些步骤…你可以由相当多的影响你的系统做不同事情的paly。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅包含一个paly的`verigy-apache.yml`的playbook的栗子</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webserver</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    http_port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    max_clients:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">at</span> <span class="string">the</span> <span class="string">latest</span> <span class="string">version</span></span><br><span class="line"><span class="attr">    yum:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">latest</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">write</span> <span class="string">the</span> <span class="string">apache</span> <span class="string">config</span> <span class="string">file</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">      src:</span> <span class="string">/srv/httpd.j2</span></span><br><span class="line"><span class="attr">      dest:</span> <span class="string">/etc/httpd.conf</span></span><br><span class="line"><span class="attr">    notify:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">running</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">started</span></span><br><span class="line"><span class="attr">  handlers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">      service:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含多个play的栗子</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">at</span> <span class="string">the</span> <span class="string">lastest</span> <span class="string">version</span></span><br><span class="line"><span class="attr">    yum:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">latest</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">write</span> <span class="string">the</span> <span class="string">apache</span> <span class="string">config</span> <span class="string">file</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">      src:</span> <span class="string">/srv/httpd.j2</span></span><br><span class="line"><span class="attr">      dest:</span> <span class="string">/etc/httpd.conf</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">databases</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ensure</span> <span class="string">pgsql</span> <span class="string">is</span> <span class="string">at</span> <span class="string">the</span> <span class="string">latest</span> <span class="string">version</span></span><br><span class="line"><span class="attr">    yum:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">postgresql</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">latest</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ensure</span> <span class="string">that</span> <span class="string">postgresql</span> <span class="string">is</span> <span class="string">started</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">postgresql</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">started</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><p>Basics</p><p><br></p><p><strong>主机和用户</strong><br>Hosts and Users</p><p>对于playbook中的每个play，你可以选择哪些机器在你的基础设施到目标，什么远程用户完成这些步骤。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hosts行是一个或多个主机或组的模式，以冒号分隔</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">      ping:</span></span><br><span class="line"><span class="attr">      remote_user:</span> <span class="string">username</span> <span class="comment"># 远程用户可在每个用户中定义</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特权提升</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">username</span></span><br><span class="line"><span class="attr">  become:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可在每个paly中使用become</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">g1</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">uername</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - service:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">started</span></span><br><span class="line"><span class="attr">      become:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">      become_method:</span> <span class="string">sudo</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 权限提升为特定用户</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">g1</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">username</span></span><br><span class="line"><span class="attr">  become:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">  become_user:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 控制运行顺序，默认是清单里面的顺序</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  order:</span> <span class="string">sorted</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">False</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        var:</span> <span class="string">inventory_hostname</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>任务列表</strong><br>Tasks list</p><p>每个play包含任务列表。任务在移动到下一个任务之前执行，一次一个，由模式匹配的所有主机。理解在一个play中，所用主机都将得到同样的任务指令是很重要的。这是play映射选择主机到任务的目的。</p><p>当运行playbook时，它从上到下运行，失败任务的主机被从playbook轮转中取出。如果事情失败，只是纠正playbook文件，然后重新运行。</p><p>每个任务的目标是执行带有特定参数的模块，变量可以在参数中传给模块。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个任务的基本栗子</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">make</span> <span class="string">sure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">running</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">started</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># command, shell模块</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">enable</span> <span class="string">selinux</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">/sbin/setenfore</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">run</span> <span class="string">this</span> <span class="string">command</span> <span class="string">and</span> <span class="string">ignore</span> <span class="string">the</span> <span class="string">result</span></span><br><span class="line"><span class="attr">    shell:</span> <span class="string">/usr/bin/somecommand</span> <span class="string">||</span> <span class="string">/bin/true</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">create</span> <span class="string">a</span> <span class="string">virtual</span> <span class="string">host</span> <span class="string">file</span> <span class="string">for</span> <span class="string">&#123;&#123;</span> <span class="string">vhost&#125;&#125;</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">      src:</span> <span class="string">somefile.j2</span></span><br><span class="line"><span class="attr">      dest:</span> <span class="string">/etc/httpd/conf.d/&#123;&#123;</span> <span class="string">vhost&#125;&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="action-shorthand"><a href="#action-shorthand" class="headerlink" title="action shorthand"></a>action shorthand</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ansible prefers listing modules like this:</span></span><br><span class="line"><span class="attr">template:</span></span><br><span class="line"><span class="attr">  src:</span> <span class="string">template/foo.j2</span></span><br><span class="line"><span class="attr">  dest:</span> <span class="string">/etc/foo.conf</span></span><br></pre></td></tr></table></figure><p>早期版本使用以下格式，仍旧有效: <code>action: template src=templates/foo.j2 dest=/etc/foo.conf</code></p><p><br><br><br></p><h4 id="Handlers"><a href="#Handlers" class="headerlink" title="Handlers"></a>Handlers</h4><p>Handlers: Running Operations On Change</p><p>如前所述，当远程系统上做了改变时模块应该是幂等的和可以中继(relay)。playbook认识到了这一点，并有一个基本的事件系统用于应对改变。</p><p>这些play中的<code>notify</code>行动在任务的每个末尾块触发，即使被多个不同任务通知也只能被触发一次。</p><p>例如，多个资源可能表明Apache需要重启，因为配置文件发生了更改，但Apache将跳跃一次，以避免不必要的重启。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当一个文件的内容更改时（仅此文件），重启两个服务的栗子</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">template</span> <span class="string">configuration</span> <span class="string">file</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">template.j2</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">/etc/foo.conf</span></span><br><span class="line"><span class="attr">  notify:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">restart</span> <span class="string">memcached</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">restart</span> <span class="string">apache</span></span><br></pre></td></tr></table></figure><p>在任务的<code>notify</code>中列出的事情的部分被称为处理程序(handlers)。</p><p>处理程序是任务列表，与常规的任务没什么区别，由一个全局唯一的名称进行引用，并通过通知程序(notifier)进行通知。如果没有事情通知一个处理程序，它将不会运行。不管有多少任务通知处理程序，它只能运行一次，在一个特定paly中的所有任务完成之后。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># handlers section</span></span><br><span class="line"><span class="attr">handlers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">restart</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">restarted</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">restart</span> <span class="string">apached</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><p>你可能想让Ansible handlers使用变量。如果handlers name使用的变量不可用，则整个paly将失败。取而代之的是，在handlers的任务参数中使用变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">Set</span> <span class="string">host</span> <span class="string">variables</span> <span class="string">based</span> <span class="string">on</span> <span class="string">distribution</span></span><br><span class="line"><span class="attr">    include_vars:</span> <span class="string">"<span class="template-variable">&#123;&#123; ansible_facts.distribution&#125;&#125;</span>.yml"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">handlers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">restart</span> <span class="string">web</span> <span class="string">service</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">"<span class="template-variable">&#123;&#123; web_service_name | default('httpd') &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><p>Ansible 2.2，handlers可以监听(listen)通用话题(generic topics)，任务可以通知这些话题。以下这种使用使它更容易触发多个处理程序。它还从名称解耦处理程序，使得在playbook和roles之间更容易共享处理程序。（特别是当使用像Galaxy的第三方角色时）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">handlers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">restart</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">restarted</span></span><br><span class="line"><span class="attr">    listen:</span> <span class="string">"restart web service"</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">apached</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">restarted</span></span><br><span class="line"><span class="attr">    listen:</span> <span class="string">"restart web services"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">restart</span> <span class="string">everything</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">echo</span> <span class="string">"this task will restart the web services"</span></span><br><span class="line"><span class="attr">    notify:</span> <span class="string">"resstart web service"</span></span><br></pre></td></tr></table></figure><p><br></p><blockquote><p><strong>注意:</strong><br>Notify handlers are always run in the same order they are defined, not in the order listed in the notify-statement. This is also the case for handlers using listen.<br>Handler names and listen topics live in a global namespace.<br>Handler names are templatable and listen topics are not.<br>Use unique handler names. If you trigger more than one handler with the same name, the first one(s) get overwritten. Only the last one defined will run.<br>You cannot notify a handler that is defined inside of an include. As of Ansible 2.1, this does work, however the include must be static.</p></blockquote><p><br></p><p>角色(Roles)后面会说明，但它值得指出的是：</p><ul><li>handlers notified within <code>pre_tasks</code>, <code>tasks</code>, and <code>post_tasks</code> sections are automatically flushed in the end of section where they were notified</li><li>handlers notified within <code>roles</code> section are automatically flushed in the end of <code>tasks</code> section, but before any <code>tasks</code> handlers</li><li>handlers are play scoped and as such can be used outside of the role they are defined in</li></ul><p><br><br><br></p><h4 id="执行playbook"><a href="#执行playbook" class="headerlink" title="执行playbook"></a>执行playbook</h4><p>Executing A Playbook</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook playbook.yml -f 10</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Ansible-Pull"><a href="#Ansible-Pull" class="headerlink" title="Ansible-Pull"></a>Ansible-Pull</h4><p>节点检查到重要位置，而不是推送配置给它们。<code>ansilbe-pull</code>是一个检查从git指令配置仓库的一个脚本，然后针对改内容运行<code>ansible-playbook</code>。</p><p><br><br><br></p><h4 id="Linting-playbooks"><a href="#Linting-playbooks" class="headerlink" title="Linting playbooks"></a>Linting playbooks</h4><p>你可以在执行前使用<code>ansible-lint</code>来检查playbook的运行情况。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ansible-lint</span> <span class="string">verify-apache.yml</span></span><br><span class="line"><span class="string">[403]</span> <span class="string">Package</span> <span class="string">installs</span> <span class="string">should</span> <span class="string">not</span> <span class="string">use</span> <span class="string">latest</span></span><br><span class="line"><span class="string">verify-apache.yml:8</span></span><br><span class="line"><span class="string">Task/Handler:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">at</span> <span class="string">the</span> <span class="string">latest</span> <span class="string">version</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="其它playbook验证项"><a href="#其它playbook验证项" class="headerlink" title="其它playbook验证项"></a>其它playbook验证项</h4><p>Other playbook verification options</p><p>查看<a href="https://docs.ansible.com/ansible/latest/community/other_tools_and_programs.html#validate-playbook-tools" target="_blank" rel="noopener">验证playbook工具</a>的详情列表，你可以使用它们来验证playbook。这里有些情况你应该考虑：</p><ul><li>要检查playbook语法问题，使用<code>ansible-playbook</code>的<code>--syntax-check</code>标志。</li><li>要查看完整的输出信息，使用<code>--verbose</code>标志。</li><li>要查看playbook会影响哪些主机，可运行: <code>ansible-playbook playbook.yml --list-hosts</code></li></ul><p><br><br><br></p><h3 id="可重复使用的playbook"><a href="#可重复使用的playbook" class="headerlink" title="可重复使用的playbook"></a>可重复使用的playbook</h3><p>Creating Reusable Playbooks: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html</a></p><p>虽然可以在一个非常大的文件里编写playbook，最终你会想重新使用文件和整理东西。在Ansible中，有三种方式可以做到这一点：</p><ul><li>includes</li><li>imports</li><li>roles</li></ul><p>includes和imports允许用户将大型playbook分解为小型文件，可跨多个parent playbook或设置多次在相同的playbook里。<br>roles允许不仅仅是任务可以打包在一起，可以包括变量(variables)，处理程序(handlers)，甚至模块(modules)和其它插件(plugins)。不同于includes和imports，roles也可上传并经由Ansible Galaxy共享。</p><p><br></p><h4 id="including和importing"><a href="#including和importing" class="headerlink" title="including和importing"></a>including和importing</h4><p>Including and Importing: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_includes.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_includes.html</a></p><p>include和import语句相似，但Ansible执行引擎处理它们却非常不同。</p><p><code>import*</code>语句在playbook被解析的时候进行预处理(pre-processed)。<br><code>include*</code>语句在playbook的执行过程中遇到才处理。</p><p>include和import语句可以在任意深度使用。</p><p><br></p><p>在一个master playbook内包含playbook：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- import_playbook:</span> <span class="string">a.yml</span></span><br><span class="line"><span class="attr">- import_playbook:</span> <span class="string">b.yml</span></span><br></pre></td></tr></table></figure><p>每个playbook中列出的plays和tasks将以列出的顺序 执行，就好像它们已经在这里直接定义。</p><p><br></p><p>大型任务划分成不同的文件是组织复杂任务或重用它们的一种好方式。一个任务文件只包含简单的任务列表：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">aaa</span></span><br><span class="line"><span class="attr">  command:</span> <span class="string">/bin/aaa</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">bbb</span></span><br><span class="line"><span class="attr">  command:</span> <span class="string">/bin/bbb</span></span><br></pre></td></tr></table></figure><p>可以使用<code>import_tasks</code>或<code>include_tasks</code>来执行在主任务列表中的文件的任务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">- import_tasks:</span> <span class="string">aaa_tasks.yml</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="attr">- include_tasks:</span> <span class="string">aaa_tasks.yml</span></span><br></pre></td></tr></table></figure><p>你也可以传递变量到imports和includes：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">- import_tasks:</span> <span class="string">aaa.yaml</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    user:</span> <span class="string">aaa</span></span><br><span class="line"><span class="attr">- import_tasks:</span> <span class="string">aaa.yml</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    user:</span> <span class="string">bbb</span></span><br><span class="line"><span class="attr">- import_tasks:</span> <span class="string">aaa.yml</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    user:</span> <span class="string">ccc</span></span><br></pre></td></tr></table></figure><p><br></p><p>include和import同样可以用于<code>handlers:</code>部分。栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># more_handlers.yml</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">  service:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">handlers:</span></span><br><span class="line"><span class="attr">- include_tasks:</span> <span class="string">more_handlers.yml</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="attr">- import_tasks:</span> <span class="string">more_handlers.yml</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h4><p>roles: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html</a></p><p>角色(role)是基于已知的文件架构自动加载某些变量文件、任务和处理程序的方式。按角色分组的内容还可以方便地与其他用户共享。</p><p><br></p><h5 id="角色目录结构"><a href="#角色目录结构" class="headerlink" title="角色目录结构"></a>角色目录结构</h5><p>Role Directory Structure</p><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">site.yml</span></span><br><span class="line"><span class="string">webservers.yml</span></span><br><span class="line"><span class="string">fooservers.yml</span></span><br><span class="line"><span class="string">roles/</span></span><br><span class="line">    <span class="string">common/</span></span><br><span class="line">        <span class="string">tasks/</span></span><br><span class="line">        <span class="string">handlers/</span></span><br><span class="line">        <span class="string">files/</span></span><br><span class="line">        <span class="string">templates/</span></span><br><span class="line">        <span class="string">vars/</span></span><br><span class="line">        <span class="string">defaults/</span></span><br><span class="line">        <span class="string">meta/</span></span><br><span class="line">    <span class="string">webservers/</span></span><br><span class="line">        <span class="string">tasks/</span></span><br><span class="line">        <span class="string">defaults/</span></span><br><span class="line">        <span class="string">meta/</span></span><br></pre></td></tr></table></figure><p>角色在特定目录名下期待文件。角色必须包括这些目录中的至少一个，但它是完全没排除任何未使用。在使用时，每个目录必须包含一个<code>main.yml</code>文件，其中包含的相关内容：</p><ul><li><code>tasks</code>：包含由角色执行的主任务列表</li><li><code>handlers</code>：包含可通过此角色甚至此角色外的任何地方使用的处理程序</li><li><code>defaults</code>：角色的默认变量</li><li><code>vars</code>：角色的其它变量</li><li><code>files</code>：通过此角色可以部署的文件</li><li><code>templates</code>：通过此角色可以部署的模板</li><li><code>meta</code>：为角色定义的元数据</li></ul><p>其它YAML文件可能包含在特定目录。栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># roles/example/tasks/main.yml</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">added</span> <span class="string">in</span> <span class="number">2.4</span><span class="string">,</span> <span class="string">previously</span> <span class="string">you</span> <span class="string">used</span> <span class="string">include</span></span><br><span class="line"><span class="attr">  import_tasks:</span> <span class="string">redhat.yml</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">ansible_facts['os_family']|lower</span> <span class="string">==</span> <span class="string">'redhat'</span></span><br><span class="line"><span class="attr">  import_tasks:</span> <span class="string">debian.yml</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">ansible_facts['os_family']|lower</span> <span class="string">==</span> <span class="string">'debian'</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># roles/example/tasks/redhat.yml</span></span><br><span class="line"><span class="attr">- yum:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">"httpd"</span></span><br><span class="line"><span class="attr">  state:</span> <span class="string">present</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># roles/example/tasks/debian.yml</span></span><br><span class="line"><span class="attr">- pat:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">"apache2"</span></span><br><span class="line"><span class="attr">  state:</span> <span class="string">present</span></span><br></pre></td></tr></table></figure><p>角色还可以包含模块和其它插件类型。</p><p><br><br><br></p><h5 id="角色使用"><a href="#角色使用" class="headerlink" title="角色使用"></a>角色使用</h5><p>使用角色的原始的方式是在play中通过<code>roles:</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">common</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">webservers</span></span><br></pre></td></tr></table></figure><p>这将为每个角色(x)指定以下行为：</p><ul><li>如果<code>roles/x/tasks/main.yml</code>存在，其中列出的任务将被添加到play；</li><li>如果<code>roles/x/handlers/main.yml</code>存在，其中列出的处理程序将被添加到play；</li><li>如果<code>roles/x/vars/main.yml</code>存在，其中列出的变量将被添加到play；</li><li>如果<code>roles/x/defaults/main.yml</code>存在，其中列出的变量将被添加到play；</li><li>如果<code>roles/x/meta/main.yml</code>存在，其中列出的任何角色的依赖都将被添加到角色列表；</li><li>角色中的任意copy, script, template, include tasks，可在<code>roles/x/{files,templates,tasks}/dir</code>进行引用，而不必关心它们的相对或绝对路径。</li></ul><p>当以这种方式使用时，playbook的执行顺序如下：</p><ul><li>play中定义的任意<code>pre_tasks</code></li><li>任意处理程序触发到目前为止将会运行</li><li>在roles中列出的每个角色将依次执行。在角色<code>meta/main.yml</code>中定义的任意角色依赖将首先运行，受标签过滤和条件</li><li>play中定义的任意<code>tasks</code></li><li>任意处理程序触发到目前为止将会运行</li><li>play中定义的任意<code>post_tasks</code></li><li>任意处理程序触发到目前为止将会运行</li></ul><p>可使用<code>import_role</code>或<code>include_role</code>在其它任务中使用角色：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">"before we run our role"</span></span><br><span class="line"><span class="attr">    - import_role:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">example</span></span><br><span class="line"><span class="attr">    - include_role:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">example</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">"after we ran our role"</span></span><br></pre></td></tr></table></figure><p>当角色在原始方式中定义，它们被视为静态导入和在playbook解析时进行处理。</p><p>角色的名称可是很简单，也可以是一个完全合格的路径：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="attr">    - role:</span> <span class="string">'/path/to/roles/common'</span></span><br></pre></td></tr></table></figure><p>角色可以接受其它关键字：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - include_role:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">foo_app_instance</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">"ansible_facts['os_family'] == 'RedHat'"</span></span><br><span class="line"><span class="attr">      vars:</span></span><br><span class="line"><span class="attr">        dir:</span> <span class="string">'/opt/a'</span></span><br><span class="line"><span class="attr">        app_port:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">      tags:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">aaa</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">bbb</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="角色副本和扩展"><a href="#角色副本和扩展" class="headerlink" title="角色副本和扩展"></a>角色副本和扩展</h5><p>Role Duplication and Execution</p><p>Ansible只允许一个角色执行一次，即使多次定义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">foo</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">foo</span></span><br></pre></td></tr></table></figure><p>上面给出的<code>foo</code>角色仅将运行一次。为了使角色多次运行，有两种选择：</p><ol><li>每个角色传递不同的参数</li><li>添加<code>allow_duplicates: true</code>到<code>meta/main.yml</code>文件</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># playbook.yml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">foo</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># roles/foo/meta/main.yml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">allow_duplicates:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="角色默认变量"><a href="#角色默认变量" class="headerlink" title="角色默认变量"></a>角色默认变量</h5><p>Role Default Variables</p><p>角色的默认变量允许你为角色设定默认变量。在角色目录中添加<code>defaults/main.yml</code>文件。这些变量具有最低优先级，可以轻易被覆盖。</p><p><br><br><br></p><h5 id="角色依赖"><a href="#角色依赖" class="headerlink" title="角色依赖"></a>角色依赖</h5><p>Role Dependencies</p><p>角色依赖让你在其它角色使用角色时自动拉取。角色依赖存储在角色目录的<code>meta/main.yml</code>文件。此文件应包含角色和参数列表在指定角色之前插入：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># orles/myapp/meta/main.yml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  - role:</span> <span class="string">common</span></span><br><span class="line"><span class="attr">    vars:</span></span><br><span class="line"><span class="attr">      come_parameter:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  - role:</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">    vars:</span></span><br><span class="line"><span class="attr">      apache_port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  - role:</span> <span class="string">postgres</span></span><br><span class="line"><span class="attr">    vars:</span></span><br><span class="line"><span class="attr">      dbname:</span> <span class="string">blarg</span></span><br><span class="line"><span class="attr">      other_parameter:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="角色中的嵌入模块和插件"><a href="#角色中的嵌入模块和插件" class="headerlink" title="角色中的嵌入模块和插件"></a>角色中的嵌入模块和插件</h5><p>Embedding Modules and Plugins In Roles</p><p><br><br><br></p><h5 id="角色搜索路径"><a href="#角色搜索路径" class="headerlink" title="角色搜索路径"></a>角色搜索路径</h5><p>Ansible将按以下方式为角色搜索：</p><ul><li>相对于playbook文件的<code>roles/</code>目录</li><li>默认情况下，在<code>/etc/ansible/roles</code></li></ul><p><br><br><br></p><h5 id="Galaxy"><a href="#Galaxy" class="headerlink" title="Galaxy"></a>Galaxy</h5><p>Ansible Galaxy是一个用于查找、下载、评级、审查各种社区ansible roles的免费网站。</p><p><code>ansible-galaxy</code>客户端包含在Ansible中。可使用它从Ansible Galaxy下载角色。</p><p><br><br><br></p><h4 id="动态与静态"><a href="#动态与静态" class="headerlink" title="动态与静态"></a>动态与静态</h4><p>Dynamic vs. Static</p><p>Ansible有两种操作模式用于可重用内容：动态与静态。</p><p>如果你使用<code>include*</code>，它将是动态的。如果你使用<code>import*</code>，它是静态的。</p><p><br></p><p><strong>动态与静态的区别</strong></p><p>两种操作模式都非常简单：</p><ul><li>动态包含在遇到任务运行时处理</li><li>静态导入在解析playbook前处理</li></ul><p>当遇到<code>tag</code>或<code>when</code>：</p><ul><li>动态包含仅适用于动态的任务，不会复制到子任务</li><li>静态导入，将被复制到所有子任务</li></ul><p><br><br><br></p><h4 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h4><p>使用<code>include*</code>与<code>import*</code>有一定的优势，权衡两者。</p><p>使用<code>include*</code>语句的最大优势是循环。当在include中使用循环，所包含的将在每个循环中执行。</p><ul><li>tags仅在动态包含内存在</li><li>tasks仅在动态包含内存在</li><li>在动态包含内不能使用<code>notify</code>来触发处理程序</li><li><p>在动态包含内不能使用<code>--start-at-task</code>来开始执行</p></li><li><p>静态导入内循环不能使用</p></li><li>静态导入内不能从库存源使用变量</li><li>静态导入内当通知它们的名字时，使用处理程序将不会触发</li></ul><p><br><br><br></p><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>Using Variables: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html</a></p><p>Ansible中使用变量可以更好地帮助处理各系统之间的差异。</p><p><br></p><h4 id="创建有效的变量名"><a href="#创建有效的变量名" class="headerlink" title="创建有效的变量名"></a>创建有效的变量名</h4><p>Creating valid variable names</p><p>有效的变量名是很重要的。变量名应该是字母 、数字和下划线，且总是以字母开头。</p><p>YAML也支持映射键值对的字典：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">foo:</span></span><br><span class="line"><span class="attr">  field1:</span> <span class="string">one</span></span><br><span class="line"><span class="attr">  field2:</span> <span class="string">two</span></span><br></pre></td></tr></table></figure><p>你可以使用中括号或点来引用特定字段的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo[&apos;field1&apos;]</span><br><span class="line">foo.field2</span><br></pre></td></tr></table></figure><p>请注意，如果使用点来引用，它们属性和Python字典的方法相冲突可能会导致一些问题。如果你使用的键开始和结束有两个下划线，或它们是已知的公共属性，则你应该使用中括号来代替点使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 公共属性</span><br><span class="line">add, append, count, decode...</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="在清单中定义变量"><a href="#在清单中定义变量" class="headerlink" title="在清单中定义变量"></a>在清单中定义变量</h4><p>Defining variables in inventory</p><p>通常，你需要为单独的主机或组设置变量。你可以在清单文件(如hosts)中定义所需的变量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">west:</span></span><br><span class="line"><span class="attr">  host1:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    maxRequest:</span> <span class="number">808</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">east:</span></span><br><span class="line"><span class="attr">  hosts:</span></span><br><span class="line"><span class="attr">    host1:</span> <span class="string">xx</span></span><br><span class="line"><span class="attr">    host2:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="在playbook中定义变量"><a href="#在playbook中定义变量" class="headerlink" title="在playbook中定义变量"></a>在playbook中定义变量</h4><p>Defining variables in a playbook</p><p>你可以直接在playbook中定义变量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="在文件和角色中定义变量"><a href="#在文件和角色中定义变量" class="headerlink" title="在文件和角色中定义变量"></a>在文件和角色中定义变量</h4><p>Defining variables in included files and roles</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="attr">    - role:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">      vars:</span></span><br><span class="line"><span class="attr">        dir:</span> <span class="string">'/opt/a'</span></span><br><span class="line"><span class="attr">    - role:</span> <span class="string">test2</span></span><br><span class="line"><span class="attr">      vars:</span></span><br><span class="line"><span class="attr">        dir:</span> <span class="string">'/opt/b'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="在Jinja2中使用变量"><a href="#在Jinja2中使用变量" class="headerlink" title="在Jinja2中使用变量"></a>在Jinja2中使用变量</h4><p>Using variables with Jinja2</p><p>一旦你定义了变量，便可以在Jinja2的模板系统中引用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ma amp goes to &#123;&#123; max_amp_value &#125;&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用Jinja2过滤器转换变量"><a href="#使用Jinja2过滤器转换变量" class="headerlink" title="使用Jinja2过滤器转换变量"></a>使用Jinja2过滤器转换变量</h4><p>Transforming variables with Jinja2 filters</p><p>Jinja2 filters 让你在模板表达式内转换变量的值。如<code>capitalize</code>大写过滤器，<code>to_yaml</code>和<code>to_json</code>过滤器来转换成对应格式。</p><p>Jinja2包含了许多内置过滤器： <a href="https://jinja.palletsprojects.com/en/2.11.x/templates/#builtin-filters" target="_blank" rel="noopener">https://jinja.palletsprojects.com/en/2.11.x/templates/#builtin-filters</a><br>Ansible也支持许多过滤器： <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#playbooks-filters" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#playbooks-filters</a></p><p><br><br><br></p><h4 id="YAML疑难杂症"><a href="#YAML疑难杂症" class="headerlink" title="YAML疑难杂症"></a>YAML疑难杂症</h4><p>Hey wait, a YAML gotcha</p><p>YAML语法要求，如果你使用<code></code>值引用整行，它要确保你不是想开始一个YAML字典。所以记得使用双引号。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wrong</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">vars:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">&#123;&#123;</span> <span class="string">dir</span> <span class="string">&#125;&#125;/22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># right</span></span><br><span class="line"><span class="attr">vars:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">"<span class="template-variable">&#123;&#123; dir &#125;&#125;</span>/22"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="系统facts中的变量"><a href="#系统facts中的变量" class="headerlink" title="系统facts中的变量"></a>系统facts中的变量</h4><p>Variables discovered from systems: Facts</p><p>facts是从远程系统获得的信息。你可以从<code>ansible_facts</code>变量中找到。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看facts</span></span><br><span class="line">ansible hostname -m setup</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- debug:</span></span><br><span class="line"><span class="attr">    var:</span> <span class="string">ansible_facts</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; ansible_facts[&apos;devices&apos;][&apos;xvda&apos;][&apos;model&apos;]&#125;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>禁用facts</strong></p><p>如果你不需要fact数据，你可以禁用它。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>Local facts(facts.d)</strong></p><p>facts通常都是由Ansible setup模块自动发现。用户也可以编写自定义的facts模块，请参考API指南。但是，如果你想要一个简单的方法来使用用户提供的数据，而不需要写一个facts模块。</p><p><code>facts.d</code>是一种可让用户控制它们的系统是如果管理的某些方面的机制。</p><p>如果远程管理系统有<code>/etc/ansible/facts.d</code>目录，该目录中的所有<code>.fact</code>文件（JSON, INI…）。可使用<code>fact_path</code> paly 关键字作为可选目录。</p><p><br><br><br></p><h4 id="注册变量"><a href="#注册变量" class="headerlink" title="注册变量"></a>注册变量</h4><p>Registering variables</p><p>另一个主要使用的变量是正在运行一个命令和将此命令的返回的结果注册为一个变量，供其它地方使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - shell:</span> <span class="string">/usr/bin/foo</span></span><br><span class="line"><span class="attr">      register:</span> <span class="string">foo_result</span></span><br><span class="line"><span class="attr">      ignore_errors:</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">    - shell:</span> <span class="string">/usr/bin/bar</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">foo_result.rc</span> <span class="string">==</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="访问复杂的变量数据"><a href="#访问复杂的变量数据" class="headerlink" title="访问复杂的变量数据"></a>访问复杂的变量数据</h4><p>Accessing complex variable data</p><p>有些提供的facts，如网络信息，包含了复杂的嵌套结构。取值会稍微麻烦一些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; ansible_facts[&apos;eth0&apos;][&apos;ipv4&apos;][&apos;address&apos;]&#125;&#125;</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">&#123;&#123; ansible_facts.eth0.ipv4.address &#125;&#125;</span><br><span class="line"></span><br><span class="line"># 访问数组的第一个元素</span><br><span class="line">&#123;&#123; foo[0] &#125;&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用magic变量访问其它主机的信息"><a href="#使用magic变量访问其它主机的信息" class="headerlink" title="使用magic变量访问其它主机的信息"></a>使用magic变量访问其它主机的信息</h4><p>Accessing information about other hosts with magic variables</p><p>无论你是否定义变量，你也可以利用特殊的Ansible变量访问有关主机的信息，包括magic, facts, connection变量。magic变量名称被保留，所以不要使用这些名称来设置变量。<code>enviroment</code>变量也同样被保留。</p><p>最常使用的魔术变量有：<code>hostvars</code>, <code>groups</code>, <code>group_names</code>, <code>inventory_hostname</code>。</p><p><code>host_vars</code>允许你访问其它主机的变量，包括该主机的facts。你可以在playbook中的任意一点访问主机变量。即使你在playbook中并没有连接到此主机，你仍可以得到变量。<br><code>groups</code>是清单中所有组的列表。这可以用于枚举组内的所有主机。<br><code>group_names</code>是所有组中当前主机的列表或数组。<br><code>inventory_hostname</code>是清单主机文件中配置的主机名。使用<code>inventory_hostname_short</code>获取更简短的信息。<br><code>ansible_play_hosts</code>是当前play中仍然活跃的主机列表。<br><code>ansible_play_batch</code>是当前批量paly上可用的主机名列表。<br><code>ansible_playbook_python</code>是python执行调用ansible命令行工具的路径。<br><code>role_path</code>返回当前角色的路径名。这仅在角色里工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; hostvars[&apos;test.example.com&apos;][&apos;ansible_facts&apos;][&apos;distribution&apos;] &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;% for host in groups[&apos;app_servers&apos;] %&#125;</span><br><span class="line">    &#123;&#123; hostvars[host][&apos;ansible_facts&apos;][&apos;eth0&apos;][&apos;ipv4&apos;][&apos;address&apos;] &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if &apos;webserver&apos; in group_names %&#125;</span><br><span class="line">    # xxx</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="在文件中定义变量"><a href="#在文件中定义变量" class="headerlink" title="在文件中定义变量"></a>在文件中定义变量</h4><p>Defining variables in files</p><p>让playbook使用版本控制是很好的想法，但你可能希望让playbook 源公开化，但同时又保证一定的重要的私有变量。</p><p>你可以通过一个外部变量文件来这么做：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    color:</span> <span class="string">blue</span></span><br><span class="line"><span class="attr">  vars_files:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/vars/external_vars.yml</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># external_vars.yml</span></span><br><span class="line"><span class="attr">user:</span> <span class="string">xx</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">xxxx</span></span><br></pre></td></tr></table></figure><p>这消除了分享playbook但避免分享数据的风险。</p><p><br><br><br></p><h4 id="在命令行上传递参数"><a href="#在命令行上传递参数" class="headerlink" title="在命令行上传递参数"></a>在命令行上传递参数</h4><p>Passing variables on the command line</p><p>可在命令行上使用<code>--extra-vars</code>参数来设置变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># k:v格式</span></span><br><span class="line">ansible-playbook release.yml --extra-vars <span class="string">"version=1.23.45 other_variable=foo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># json格式</span></span><br><span class="line">ansible-playbook arcade.yml --extra-vars <span class="string">'&#123;"pacman":"mrs","ghosts":["inky","pinky","clyde","sue"]&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件</span></span><br><span class="line">ansible-playbook release.yml --extra-vars <span class="string">"@some_file.json"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="变量的优先级：我应该把变量放在哪"><a href="#变量的优先级：我应该把变量放在哪" class="headerlink" title="变量的优先级：我应该把变量放在哪"></a>变量的优先级：我应该把变量放在哪</h4><p>Variable precedence: Where should I put a variable?</p><p>同一名称的变量如果在多个地方被定义，则它们会以特定的顺序发生覆盖，所需需要知道Ansible变量的优先级，以及它们的放置位置。下面是从小到大的优先级：</p><ol><li>command line values</li><li>role defaults</li><li>inventory file or script group vars</li><li>inventory group_vars/all</li><li>playbook group_vars/all</li><li>inventory group_vars/*</li><li>playbook group_vars/*</li><li>inventory file or script host vars</li><li>inventory host_vars/*</li><li>playbook host_vars/*</li><li>host facts / cached set_facts</li><li>play vars</li><li>play vars_prompt</li><li>play vars_files</li><li>role vars (defined in role/vars/main.yml)</li><li>block vars (only for tasks in block)</li><li>task vars (only for the task)</li><li>include_vars</li><li>set_facts/registered vars</li><li>role (and include_role) params</li><li>include params</li><li>extra vars (always win precedence)</li></ol><p><br><br><br></p><h3 id="Jinja2模板"><a href="#Jinja2模板" class="headerlink" title="Jinja2模板"></a>Jinja2模板</h3><p>Templating (Jinja2): <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html</a></p><p>Ansible使用Jinja2模板化来实现动态表达式和访问变量。Ansilbe大大扩展的filters和tests数量，以及新增了一个插件类型：lookups。</p><p>请注意，所有模板发生在Ansible控制器上，在任务发送和执行在目标主机之前。</p><p><br></p><h4 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h4><p>Filters: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html</a></p><p><br><br><br></p><h4 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h4><p>Tests: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html</a></p><p>Jinja中的测试是评估模板表达式并返回True或False。许多内置测试: <a href="https://jinja.palletsprojects.com/en/2.11.x/templates/#builtin-tests" target="_blank" rel="noopener">https://jinja.palletsprojects.com/en/2.11.x/templates/#builtin-tests</a></p><p>测试器和过滤器的主要区别是测试用于比较，而过滤去用于数据操作。测试同样可以在列表处理器中使用，如<code>map()</code>和<code>select()</code>在列表中选择项。</p><p>与所有模板一样，测试始终在Ansible控制器上执行，而不是任务的目标主机。除了这些Jinja2的测试，Ansible支持用户轻松创建自己的测试。</p><p><br><br><br></p><h4 id="Lookups"><a href="#Lookups" class="headerlink" title="Lookups"></a>Lookups</h4><p>Lookups: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_lookups.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_lookups.html</a></p><p>查找插件允许访问外部数据源。与所有模板一样，这些插件在Ansible控制器上进行评估，并且可以包括读取文件系统、对外联络网络数据存储和服务。这些数据使用Ansible标准模板系统提供。</p><p><br></p><blockquote><p><strong>注意</strong><br>查找发生在本地主机，而不是远程主机；<br>它们在包含role或play的目录内执行，而不是与执行脚本的目录执行本地任务；<br>可以传递<code>wantlist=True</code>给lookups来使用Jinja2中的for循环；<br>查找是一个高级的功能，你应该对Ansible有足够的了解。</p></blockquote><p><br><br><br></p><h4 id="Python版本和模板"><a href="#Python版本和模板" class="headerlink" title="Python版本和模板"></a>Python版本和模板</h4><p>Python Version and Templating: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_python_version.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_python_version.html</a></p><p>Jinja2模板利用Python数据类型和标准函数。这使得可对数据进行丰富的操作。然而，这也意味着潜在的Python的某些细节对模板编写者可见。由于Ansible playbook使用Jinja2用于模板与变量，这意味着playbook作者需要了解这些细节。</p><p>除了这些，请注意在Python2和Python3上运行Ansible的不同。</p><p><br><br><br></p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>Conditionals: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html</a></p><p>经常的一个play的结果可能依赖于一个变量的值，或之前的任务的结果。在某些情况下，变量的值可能依赖于其它变量。本主题介绍如何在playbook中使用条件语句。</p><p><br></p><h4 id="When语句"><a href="#When语句" class="headerlink" title="When语句"></a>When语句</h4><p>The When Statement</p><p>有时你会想在某个特定主机上跳过特定的步骤。</p><p>在Ansible中使用<code>when</code>子句很容易达到，它不包含Jinja2中的双花括号表达式。它非常简单：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"shut down CentOS 6 systems"</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">/sbin/shutdown</span> <span class="bullet">-t</span> <span class="string">now</span></span><br><span class="line"><span class="attr">    when:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ansible_facts['distribution']</span> <span class="string">==</span> <span class="string">"CentOS"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ansible_facts['distribution_major_version']</span> <span class="string">==</span> <span class="string">"6"</span></span><br></pre></td></tr></table></figure><p>许多Jinja2的测试器和过滤器都可在<code>when</code>子句中使用，其中某些是由Ansible单独提供的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - command:</span> <span class="string">/bin/false</span></span><br><span class="line"><span class="attr">    register:</span> <span class="string">result</span></span><br><span class="line"><span class="attr">    ignore_errors:</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - command:</span> <span class="string">/bin/something</span></span><br><span class="line"><span class="attr">    when:</span> <span class="string">result</span> <span class="string">is</span> <span class="string">failed</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># In older versions of ansible use ``success``, now both are valid but succeeded uses the correct tense.</span></span><br><span class="line"><span class="attr">  - command:</span> <span class="string">/bin/something_else</span></span><br><span class="line"><span class="attr">    when:</span> <span class="string">result</span> <span class="string">is</span> <span class="string">succeeded</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - command:</span> <span class="string">/bin/still/something_else</span></span><br><span class="line"><span class="attr">    when:</span> <span class="string">result</span> <span class="string">is</span> <span class="string">skipped</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">    - shell:</span> <span class="string">echo</span> <span class="string">"This certainly is epic!"</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">epic</span> <span class="string">or</span> <span class="string">monumental|bool</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">    - shell:</span> <span class="string">echo</span> <span class="string">"I've got '<span class="template-variable">&#123;&#123; foo &#125;&#125;</span>' and am not afraid to use it!"</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">foo</span> <span class="string">is</span> <span class="string">defined</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - fail:</span> <span class="string">msg="Bailing</span> <span class="string">out.</span> <span class="string">this</span> <span class="string">play</span> <span class="string">requires</span> <span class="string">'bar'</span><span class="string">"</span></span><br><span class="line"><span class="string">      when: bar is undefined</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="循环和条件"><a href="#循环和条件" class="headerlink" title="循环和条件"></a>循环和条件</h4><p>Loops and Conditionals</p><p><code>when</code>和<code>loops</code>结合使用，请注意when语句是根据每个项分别处理。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">    - command:</span> <span class="string">echo</span> <span class="string">&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">      loop:</span> <span class="string">[</span> <span class="number">0</span><span class="string">,</span> <span class="number">2</span><span class="string">,</span> <span class="number">4</span><span class="string">,</span> <span class="number">6</span><span class="string">,</span> <span class="number">8</span><span class="string">,</span> <span class="number">10</span> <span class="string">]</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">item</span> <span class="string">&gt; 5</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="在自定义facts中载入"><a href="#在自定义facts中载入" class="headerlink" title="在自定义facts中载入"></a>在自定义facts中载入</h4><p>Loading in Custom Facts</p><p>如果你想提供自己的facts也很简单。要运行它们，只需要在任务顶部调用你自己定义的模块，这里返回的变量将能访问未来的任务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">gather</span> <span class="string">site</span> <span class="string">specific</span> <span class="string">fact</span> <span class="string">data</span></span><br><span class="line"><span class="attr">      action:</span> <span class="string">site_facts</span></span><br><span class="line"><span class="attr">    - command:</span> <span class="string">/usr/bin/thingy</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">my_custom_fact_just_retrieved_from_the_remote_system</span> <span class="string">==</span> <span class="string">'1234'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Applying-when-to-roles-imports-and-includes"><a href="#Applying-when-to-roles-imports-and-includes" class="headerlink" title="Applying when to roles,imports,and includes"></a>Applying when to roles,imports,and includes</h4><p>在roles, imports, includes中使用when语句：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="attr">     - role:</span> <span class="string">debian_stock_config</span></span><br><span class="line"><span class="attr">       when:</span> <span class="string">ansible_facts['os_family']</span> <span class="string">==</span> <span class="string">'Debian'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="有条件的导入"><a href="#有条件的导入" class="headerlink" title="有条件的导入"></a>有条件的导入</h4><p>Conditional Imports</p><p>一个剧本适用于多个平台和操作系统是很好的栗子。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  vars_files:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"vars/common.yml"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">[</span> <span class="string">"vars/<span class="template-variable">&#123;&#123; ansible_facts['os_family'] &#125;&#125;</span>.yml"</span><span class="string">,</span> <span class="string">"vars/os_defaults.yml"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">make</span> <span class="string">sure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">started</span></span><br><span class="line"><span class="attr">    service:</span> <span class="string">name=&#123;&#123;</span> <span class="string">apache</span> <span class="string">&#125;&#125;</span> <span class="string">state=started</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="基于变量来选择文件和模板"><a href="#基于变量来选择文件和模板" class="headerlink" title="基于变量来选择文件和模板"></a>基于变量来选择文件和模板</h4><p>Selecting Files And Templates Based On Variables</p><p>基于不同的系统来生成不同的配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">template</span> <span class="string">a</span> <span class="string">file</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">      src:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      dest:</span> <span class="string">/etc/myapp/foo.conf</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; query('first_found', &#123; 'files': myfiles, 'paths': mypaths&#125;) &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    myfiles:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"<span class="template-variable">&#123;&#123;ansible_facts['distribution']&#125;&#125;</span>.conf"</span></span><br><span class="line"><span class="bullet">      -</span>  <span class="string">default.conf</span></span><br><span class="line"><span class="attr">    mypaths:</span> <span class="string">['search_location_one/somedir/',</span> <span class="string">'/opt/other_location/somedir/'</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="注册变量-1"><a href="#注册变量-1" class="headerlink" title="注册变量"></a>注册变量</h4><p>Register Variables</p><p>存储一个给定命令的结果，以便后面来访问它，在playbook中可能很有用。</p><blockquote><p>注意：<br>即使当一个任务由于条件语句跳过，注册也会发生。</p></blockquote><p><code>register</code>关键字决定将结果保存哪个变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">check</span> <span class="string">registered</span> <span class="string">variable</span> <span class="string">for</span> <span class="string">emptiness</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">all</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">list</span> <span class="string">contents</span> <span class="string">of</span> <span class="string">directory</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">ls</span> <span class="string">mydir</span></span><br><span class="line"><span class="attr">        register:</span> <span class="string">contents</span></span><br><span class="line"></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">check</span> <span class="string">contents</span> <span class="string">for</span> <span class="string">emptiness</span></span><br><span class="line"><span class="attr">        debug:</span></span><br><span class="line"><span class="attr">          msg:</span> <span class="string">"Directory is empty"</span></span><br><span class="line"><span class="attr">        when:</span> <span class="string">contents.stdout</span> <span class="string">==</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="常用facts"><a href="#常用facts" class="headerlink" title="常用facts"></a>常用facts</h4><p>Commonly Used Facts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ansible_facts[‘distribution’]</span><br><span class="line"></span><br><span class="line">ansible_facts[‘distribution_major_version’]</span><br><span class="line"></span><br><span class="line">ansible_facts[‘os_family’]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>Loops: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html</a></p><p>常见的Ansible循环包括改变多个文件/目录的权限、创建多个用户、重复轮询…Ansible提供了两个关键字来创建循环：</p><ul><li><code>loop</code></li><li><code>with_&lt;lookup&gt;</code></li></ul><p><br></p><blockquote><p>注意：<br>We added loop in Ansible 2.5. It is not yet a full replacement for <code>with_&lt;lookup&gt;</code>, but we recommend it for most use cases.<br>We have not deprecated the use of <code>with_&lt;lookup&gt;</code><br>We are looking to improve loop syntax</p></blockquote><p><br></p><h4 id="两者比较-1"><a href="#两者比较-1" class="headerlink" title="两者比较"></a>两者比较</h4><p>Comparing <code>loop</code> and <code>with_*</code></p><ul><li><code>with_&lt;lookup&gt;</code>关键字依赖于Lookup插件，即便<code>items</code>也是查找；</li><li><code>loop</code>关键字等于<code>with_list</code>，它是简单循环的最佳选择；</li><li><code>loop</code>关键字不接受字符串作为输入；</li><li>一般来说，任何在Migrating from with_X to loop中使用<code>with_*</code>可以更新为使用<code>loop</code>；</li><li>当更改<code>with_items</code>为<code>loop</code>时请小心，<code>with_items</code>执行单级的。你需要在<code>loop</code>中使用<code>flatten(1)</code>。栗子如下：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">with_items:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">1</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">[2,3]</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># you would need</span></span><br><span class="line"><span class="attr">loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; [1, [2,3] ,4] | flatten(1) &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="标准循环"><a href="#标准循环" class="headerlink" title="标准循环"></a>标准循环</h4><p>Standard loops</p><p><br></p><h5 id="遍历一个简单列表"><a href="#遍历一个简单列表" class="headerlink" title="遍历一个简单列表"></a>遍历一个简单列表</h5><p>Iterating over a simple list</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">add</span> <span class="string">several</span> <span class="string">users</span></span><br><span class="line"><span class="attr">  user:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">    groups:</span> <span class="string">"wheel"</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">testuser1</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">testuser2</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="遍历一个散列列表"><a href="#遍历一个散列列表" class="headerlink" title="遍历一个散列列表"></a>遍历一个散列列表</h5><p>Iterating over a list of hashes</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">add</span> <span class="string">several</span> <span class="string">users</span></span><br><span class="line"><span class="attr">  user:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.name &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">    groups:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.groups &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'testuser1'</span><span class="string">,</span> <span class="attr">groups:</span> <span class="string">'wheel'</span> <span class="string">&#125;</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'testuser2'</span><span class="string">,</span> <span class="attr">groups:</span> <span class="string">'root'</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="遍历一个字典"><a href="#遍历一个字典" class="headerlink" title="遍历一个字典"></a>遍历一个字典</h5><p>Iterating over a dictionary</p><p>使用<code>dict2items</code>字典过滤器来遍历字典：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">create</span> <span class="string">a</span> <span class="string">tag</span> <span class="string">dictionary</span> <span class="string">of</span> <span class="string">non-empty</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  set_fact:</span></span><br><span class="line"><span class="attr">    tags_dict:</span> <span class="string">"<span class="template-variable">&#123;&#123; (tags_dict|default(&#123;&#125;))|combine(&#123;item.key: item.value&#125;) &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; tags|dict2items &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    tags:</span></span><br><span class="line"><span class="attr">      Environment:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">      Application:</span> <span class="string">payment</span></span><br><span class="line"><span class="attr">      Another:</span> <span class="string">"<span class="template-variable">&#123;&#123; doesnotexist|default() &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">item.value</span> <span class="string">!=</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="循环与注册变量"><a href="#循环与注册变量" class="headerlink" title="循环与注册变量"></a>循环与注册变量</h4><p>Registering variables with a loop</p><p>你可以将循环的输出注册为变量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- shell:</span> <span class="string">"echo <span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"one"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"two"</span></span><br><span class="line"><span class="attr">  register:</span> <span class="string">echo</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="复杂循环"><a href="#复杂循环" class="headerlink" title="复杂循环"></a>复杂循环</h4><p>Complex loops</p><p><br></p><h5 id="遍历嵌套的列表"><a href="#遍历嵌套的列表" class="headerlink" title="遍历嵌套的列表"></a>遍历嵌套的列表</h5><p>Iterating over nested lists</p><p>你可以使用Jinja2的表达式来遍历复杂的列表：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">give</span> <span class="string">users</span> <span class="string">access</span> <span class="string">to</span> <span class="string">multiple</span> <span class="string">databases</span></span><br><span class="line"><span class="attr">  mysql_user:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"<span class="template-variable">&#123;&#123; item[0] &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    priv:</span> <span class="string">"<span class="template-variable">&#123;&#123; item[1] &#125;&#125;</span>.*:ALL"</span></span><br><span class="line"><span class="attr">    append_privs:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">"foo"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; ['alice', 'bob'] |product(['clientdb', 'employeedb', 'providerdb'])|list &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="重试任务直到满足条件"><a href="#重试任务直到满足条件" class="headerlink" title="重试任务直到满足条件"></a>重试任务直到满足条件</h5><p>Retrying a task until a condition is met</p><p>可以使用<code>until</code>关键字来重试任务直到满足特定条件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- shell:</span> <span class="string">/usr/bin/foo</span></span><br><span class="line"><span class="attr">  register:</span> <span class="string">result</span></span><br><span class="line"><span class="attr">  until:</span> <span class="string">result.stdout.find("all</span> <span class="string">systems</span> <span class="string">go")</span> <span class="string">!=</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">  retries:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  delay:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="循环清单"><a href="#循环清单" class="headerlink" title="循环清单"></a>循环清单</h5><p>Looping over inventory</p><p>遍历资产清单：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># show all the hosts in the inventory</span></span><br><span class="line"><span class="attr">- debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; groups['all'] &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># show all the hosts in the current play</span></span><br><span class="line"><span class="attr">- debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; ansible_play_batch &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># show all the hosts in the inventory</span></span><br><span class="line"><span class="attr">- debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; query('inventory_hostnames', 'all') &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># show all the hosts matching the pattern, ie all but the group www</span></span><br><span class="line"><span class="attr">- debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; query('inventory_hostnames', 'all:!www') &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="query与lookup"><a href="#query与lookup" class="headerlink" title="query与lookup"></a>query与lookup</h4><p><code>loop</code>关键字需要一个列表作为输入，但是<code>lookup</code>关键字默认返回逗号分隔的值的字符串。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># same thing</span></span><br><span class="line"><span class="attr">loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; query('inventory_hostnames', 'all') &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; lookup('inventory_hostnames', 'all', wantlist=True) &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><p>Adding controls to loops</p><p><code>loop_control</code>关键字让你可以以有效的方式管理自己的循环。</p><p><br></p><h5 id="限制循环输出"><a href="#限制循环输出" class="headerlink" title="限制循环输出"></a>限制循环输出</h5><p>Limiting loop output with label</p><p>当遍历复杂的数据结构，你的任务的控制台输出可能是巨大的。为了限制显示的输出，在<code>loop_control</code>中使用<code>label</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此任务输出仅显示每项的name字段</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">create</span> <span class="string">servers</span></span><br><span class="line"><span class="attr">  digital_ocean:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.name &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">server1</span></span><br><span class="line"><span class="attr">      disks:</span> <span class="number">3</span><span class="string">gb</span></span><br><span class="line"><span class="attr">      ram:</span> <span class="number">15</span><span class="string">Gb</span></span><br><span class="line"><span class="attr">      network:</span></span><br><span class="line"><span class="attr">        nic01:</span> <span class="number">100</span><span class="string">Gb</span></span><br><span class="line"><span class="attr">        nic02:</span> <span class="number">10</span><span class="string">Gb</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line"><span class="attr">  loop_control:</span></span><br><span class="line"><span class="attr">    label:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.name &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="暂停循环"><a href="#暂停循环" class="headerlink" title="暂停循环"></a>暂停循环</h5><p>Pausing within a loop</p><p>要控制每个项的执行之间的时间(seconds)，在<code>loop_control</code>中使用<code>pause</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.yml</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">create</span> <span class="string">servers,</span> <span class="string">pause</span> <span class="number">3</span><span class="string">s</span> <span class="string">before</span> <span class="string">creating</span> <span class="string">next</span></span><br><span class="line"><span class="attr">  digital_ocean:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">server1</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">server2</span></span><br><span class="line"><span class="attr">  loop_control:</span></span><br><span class="line"><span class="attr">    pause:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="追踪流程"><a href="#追踪流程" class="headerlink" title="追踪流程"></a>追踪流程</h5><p>Tracking progress through a loop with <code>index_var</code></p><p>要追踪你在循环的位置，在<code>loop_control</code>中使用<code>index_var</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">count</span> <span class="string">our</span> <span class="string">fruit</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span> with index <span class="template-variable">&#123;&#123; my_idx &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">apple</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">banana</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">pear</span></span><br><span class="line"><span class="attr">  loop_control:</span></span><br><span class="line"><span class="attr">    index_var:</span> <span class="string">my_idx</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="inner-and-outer-variable-names"><a href="#inner-and-outer-variable-names" class="headerlink" title="inner and outer variable names"></a>inner and outer variable names</h5><p>Defining inner and outer variable names with <code>loop_var</code></p><p>可使用<code>include_tasks</code>嵌套两个循环任务。然而，默认情况下Ansible为每个循环<code>item</code>设置循环变量。This means the inner, nested loop will overwrite the value of item from the outer loop.你可以在<code>loop_control</code>中使用<code>loop_var</code>来为每个循环指定变量名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- include_tasks:</span> <span class="string">inner.yml</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">1</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">2</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  loop_control:</span></span><br><span class="line"><span class="attr">    loop_var:</span> <span class="string">outer_item</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># inner.yml</span></span><br><span class="line"><span class="attr">- debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"outer item=<span class="template-variable">&#123;&#123; outer_item &#125;&#125;</span> inner item=<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">a</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">b</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">c</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="扩展的循环变量"><a href="#扩展的循环变量" class="headerlink" title="扩展的循环变量"></a>扩展的循环变量</h5><p>Extended loop variables</p><p>在循环控制中使用<code>extended</code>选项来获取扩展的循环信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loop_control:</span></span><br><span class="line"><span class="attr">  extended:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VariableDescription</span><br><span class="line">ansible_loop.allitemsThe list of all items in the loop</span><br><span class="line">ansible_loop.indexThe current iteration of the loop. (1 indexed)</span><br><span class="line">ansible_loop.index0The current iteration of the loop. (0 indexed)</span><br><span class="line">ansible_loop.revindexThe number of iterations from the end of the loop (1 indexed)</span><br><span class="line">ansible_loop.revindex0The number of iterations from the end of the loop (0 indexed)</span><br><span class="line">ansible_loop.firstTrue if first iteration</span><br><span class="line">ansible_loop.lastTrue if last iteration</span><br><span class="line">ansible_loop.lengthThe number of items in the loop</span><br><span class="line">ansible_loop.previtemThe item from the previous iteration of the loop. Undefined during the first iteration.</span><br><span class="line">ansible_loop.nextitemThe item from the following iteration of the loop. Undefined during the last iteration.</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="从with-x迁移到loop"><a href="#从with-x迁移到loop" class="headerlink" title="从with_x迁移到loop"></a>从with_x迁移到loop</h4><p>Migrating from with_X to loop</p><p>从Ansible 2.5开始，执行循环的推荐的方式是使用新的<code>loop</code>关键字来取代<code>with_x</code>格式的循环。</p><p>在许多情况下，<code>loop</code>语法是使用过滤器的更好的表达，而不是更复杂的<code>query</code>或<code>lookup</code>。</p><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_list被loop替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_list</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_list:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">one</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">two</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_list</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">one</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">two</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_items被loop和flatten过滤器替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_items</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_items:</span> <span class="string">"<span class="template-variable">&#123;&#123; items &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_items</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; items|flatten(levels=1) &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_indexed_items被loop, flatten, loop_control.index_var替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_indexed_items</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0 &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_indexed_items:</span> <span class="string">"<span class="template-variable">&#123;&#123; items &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_indexed_items</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; index &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; items|flatten(levels=1) &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop_control:</span></span><br><span class="line"><span class="attr">    index_var:</span> <span class="string">index</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_flattened被loop和flatten替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_flattened</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_flattened:</span> <span class="string">"<span class="template-variable">&#123;&#123; items &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_flattened</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; items|flatten &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_together被loop和zip替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_together</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0 &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_together:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"<span class="template-variable">&#123;&#123; list_one &#125;&#125;</span>"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"<span class="template-variable">&#123;&#123; list_two &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_together</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0 &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; list_one|zip(list_two)|list &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_dict可通过loop和 dictsort或dict2items替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_dict</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.key &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.value &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_dict:</span> <span class="string">"<span class="template-variable">&#123;&#123; dictionary &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_dict</span> <span class="bullet">-&gt;</span> <span class="string">loop</span> <span class="string">(option</span> <span class="number">1</span><span class="string">)</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.key &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.value &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; dictionary|dict2items &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_dict</span> <span class="bullet">-&gt;</span> <span class="string">loop</span> <span class="string">(option</span> <span class="number">2</span><span class="string">)</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0 &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; dictionary|dictsort &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_sequence被loop, range, format替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_sequence</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_sequence:</span> <span class="string">start=0</span> <span class="string">end=4</span> <span class="string">stride=2</span> <span class="string">format=testuser%02x</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_sequence</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; 'testuser%02x' | format(item) &#125;&#125;</span>"</span></span><br><span class="line">  <span class="comment"># range is exclusive of the end point</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; range(0, 4 + 1, 2)|list &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_subelements被loop, subelements替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_subelements</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0.name &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_subelements:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"<span class="template-variable">&#123;&#123; users &#125;&#125;</span>"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">mysql.hosts</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_subelements</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0.name &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; users|subelements('mysql.hosts') &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_nested/with_cartesian被loop, product替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_nested</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0 &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_nested:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"<span class="template-variable">&#123;&#123; list_one &#125;&#125;</span>"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"<span class="template-variable">&#123;&#123; list_two &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_nested</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0 &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; list_one|product(list_two)|list &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_random_choice被random替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_random_choice</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_random_choice:</span> <span class="string">"<span class="template-variable">&#123;&#123; my_list &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_random_choice</span> <span class="bullet">-&gt;</span> <span class="string">loop</span> <span class="string">(No</span> <span class="string">loop</span> <span class="string">is</span> <span class="string">needed</span> <span class="string">here)</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; my_list|random &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">random</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>Blocks: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_blocks.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_blocks.html</a></p><p>块允许任务的逻辑分组，并在play中错误处理。大多数可以适用于单任务的也可适用于块(block)，这使得它很容易设置数据或常见指令到任务。这并不意味着该指令影响块自身，而是有一个块包围的任务继承。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">   - name:</span> <span class="string">Install,</span> <span class="string">configure,</span> <span class="string">and</span> <span class="string">start</span> <span class="string">Apache</span></span><br><span class="line"><span class="attr">     block:</span></span><br><span class="line"><span class="attr">       - name:</span> <span class="string">install</span> <span class="string">httpd</span> <span class="string">and</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">         yum:</span></span><br><span class="line"><span class="attr">           name:</span></span><br><span class="line"><span class="bullet">           -</span> <span class="string">httpd</span></span><br><span class="line"><span class="bullet">           -</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">           state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line"><span class="attr">       - name:</span> <span class="string">apply</span> <span class="string">the</span> <span class="string">foo</span> <span class="string">config</span> <span class="string">template</span></span><br><span class="line"><span class="attr">         template:</span></span><br><span class="line"><span class="attr">           src:</span> <span class="string">templates/src.j2</span></span><br><span class="line"><span class="attr">           dest:</span> <span class="string">/etc/foo.conf</span></span><br><span class="line"><span class="attr">       - name:</span> <span class="string">start</span> <span class="string">service</span> <span class="string">bar</span> <span class="string">and</span> <span class="string">enable</span> <span class="string">it</span></span><br><span class="line"><span class="attr">         service:</span></span><br><span class="line"><span class="attr">           name:</span> <span class="string">bar</span></span><br><span class="line"><span class="attr">           state:</span> <span class="string">started</span></span><br><span class="line"><span class="attr">           enabled:</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">     when:</span> <span class="string">ansible_facts['distribution']</span> <span class="string">==</span> <span class="string">'CentOS'</span></span><br><span class="line"><span class="attr">     become:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">     become_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">     ignore_errors:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>在上面的栗子中，块中3个任务中的每一个附加在when条件后，在任务上下文评估之后都将执行。</p><p>块中的任务名在Ansible 2.3时可用。建议在所有任务中使用名称，无论是块还是其它地方。</p><p><br></p><h4 id="块错误处理"><a href="#块错误处理" class="headerlink" title="块错误处理"></a>块错误处理</h4><p>Blocks error handling</p><p>块同样介绍了类似于大多数编程语言的异常处理的错误处理的方法。块仅处理任务的失败(failed)状态。一个糟糕的任务定义或主机不可达不是rescuable错误。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># block error handling example</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr"> - name:</span> <span class="string">Handle</span> <span class="string">the</span> <span class="string">error</span></span><br><span class="line"><span class="attr">   block:</span></span><br><span class="line"><span class="attr">     - debug:</span></span><br><span class="line"><span class="attr">         msg:</span> <span class="string">'I execute normally'</span></span><br><span class="line"><span class="attr">     - name:</span> <span class="string">i</span> <span class="string">force</span> <span class="string">a</span> <span class="string">failure</span></span><br><span class="line"><span class="attr">       command:</span> <span class="string">/bin/false</span></span><br><span class="line"><span class="attr">     - debug:</span></span><br><span class="line"><span class="attr">         msg:</span> <span class="string">'I never execute, due to the above task failing, :-('</span></span><br><span class="line"><span class="attr">   rescue:</span></span><br><span class="line"><span class="attr">     - debug:</span></span><br><span class="line"><span class="attr">         msg:</span> <span class="string">'I caught an error, can do stuff here to fix it, :-)'</span></span><br></pre></td></tr></table></figure><p><br></p><p><code>always</code>部分，无论什么任务状态都将会运行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Always</span> <span class="string">do</span> <span class="string">X</span></span><br><span class="line"><span class="attr">  block:</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">'I execute normally'</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">i</span> <span class="string">force</span> <span class="string">a</span> <span class="string">failure</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">/bin/false</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">'I never execute :-('</span></span><br><span class="line"><span class="attr">  always:</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">"This always executes, :-)"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="高级的playbook功能"><a href="#高级的playbook功能" class="headerlink" title="高级的playbook功能"></a>高级的playbook功能</h3><p>Advanced Playbooks Features: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_special_topics.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_special_topics.html</a></p><p>下面有许多playbook功能不需要每个人都去学习，但可以为特定应用提供有用的功能。浏览这些话题，因为你可能找有一些有用的技巧。</p><p><br></p><h4 id="特权晋升"><a href="#特权晋升" class="headerlink" title="特权晋升"></a>特权晋升</h4><p><br><br><br></p><h4 id="异步操作和轮询"><a href="#异步操作和轮询" class="headerlink" title="异步操作和轮询"></a>异步操作和轮询</h4><p>Asynchronous Actions and Polling: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_async.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_async.html</a></p><p>默认情况下，playbook块中的任务，直到任务在每个节点上完成后连接才会断开。这可能不总是可取的，或者你需要运行超过ssh timeout的操作。</p><p><br></p><p><strong>限时后台操作(Time-limited background operations)</strong></p><p>你可以在后台运行长时间运行的操作，之后再检查它们的状态。例如，异步地在后台执行<code>long_running_operation</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -B 超时时间， -p 轮询数</span></span><br><span class="line">ansible all -B 3600 -P 0 -a <span class="string">"/usr/bin/long_running_operation --do-stuff"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># async_status模块 检查状态</span></span><br><span class="line">ansible web1.example.com -m async_status -a <span class="string">"jid=488359678239.2844"</span></span><br></pre></td></tr></table></figure><p>轮询模式是智能的，所以在轮询将在任意机器上开始之前所有的工作都将启动。如果想要所有工作快速开始，请确保使用足够高的<code>--forks</code>。在超时之后，远程节点上的进程将会被终止。</p><p>通常，你只需在后台长时间运行shell命令或软件更新。后台复制模块不会进行文件传输。</p><p>为了避免阻塞或超时问题，你可以使用异步模式来一次运行你的所有任务，并轮询直到它们完成。</p><p>异步模式的行为依赖于poll值。</p><p><br></p><p><strong>Avoid connection timeouts: poll &gt; 0</strong></p><p>当poll是正值，playbook仍然会阻塞任务直到它完成、失败或超时。</p><p>要异步启动任务，请指定其最大运行实践和要轮询状态的频率。如果未指定poll，则默认由<code>DEFAULT_POLL_INTERVAL</code>设置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">simulate</span> <span class="string">long</span> <span class="string">running</span> <span class="string">op</span> <span class="string">(15</span> <span class="string">sec),</span> <span class="string">wait</span> <span class="string">for</span> <span class="string">up</span> <span class="string">to</span> <span class="number">45</span> <span class="string">sec,</span> <span class="string">poll</span> <span class="string">every</span> <span class="number">5</span> <span class="string">sec</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">/bin/sleep</span> <span class="number">15</span></span><br><span class="line"><span class="attr">    async:</span> <span class="number">45</span></span><br><span class="line"><span class="attr">    poll:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>Concurrent tasks: poll=0</strong></p><p>当poll为0时，Ansible将启动任务，并立即移动到下一个而不必等待结果。</p><p>从序列试图这点是异步编程：任务现在可以同时运行。playbook将结束而不检查异步返回。异步任务将执行根据async的值，直到它们完成、失败或超时。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">simulate</span> <span class="string">long</span> <span class="string">running</span> <span class="string">op,</span> <span class="string">allow</span> <span class="string">to</span> <span class="string">run</span> <span class="string">for</span> <span class="number">45</span> <span class="string">sec,</span> <span class="string">fire</span> <span class="string">and</span> <span class="string">forget</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">/bin/sleep</span> <span class="number">15</span></span><br><span class="line"><span class="attr">    async:</span> <span class="number">45</span></span><br><span class="line"><span class="attr">    poll:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="检查模式"><a href="#检查模式" class="headerlink" title="检查模式"></a>检查模式</h4><p>Check Mode: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_checkmode.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_checkmode.html</a></p><p><br><br><br></p><h4 id="Debugger"><a href="#Debugger" class="headerlink" title="Debugger"></a>Debugger</h4><p>Playbook Debugger</p><p>Ansible包含了debugger作为策略插件的一部分。此调试器允许你调试任务。你可以在任务的上下文中访问所有的调试器的功能，以帮助解决失败的问题。</p><p>有多种方式来调用调试器。</p><p><br></p><p><strong>使用debugger关键字(Using the debugger keyword)</strong></p><p>可在提供<code>name</code>属性的块中使用<code>debugger</code>关键字，如paly, role, block, task。<code>debugger</code>关键字接受下列值：</p><ul><li>always: 总是调用调试器</li><li>never: 绝不调用调试器</li><li>on_failed: 任务失败才调用调试器</li><li>on_skipped: 任务跳过才调用调试器</li></ul><p><br></p><p>全局配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># on a task</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">execute</span> <span class="string">a</span> <span class="string">command</span></span><br><span class="line"><span class="attr">  command:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  debugger:</span> <span class="string">on_failed</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># on a play</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">play</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  debugger:</span> <span class="string">on_skipped</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Execute</span> <span class="string">a</span> <span class="string">command</span></span><br><span class="line"><span class="attr">      command:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      when:</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>在特定层级上：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Play</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  debugger:</span> <span class="string">never</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Execute</span> <span class="string">a</span> <span class="string">command</span></span><br><span class="line"><span class="attr">      command:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      debugger:</span> <span class="string">on_failed</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置或环境变量(Configuration or environment variable)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ansible.cfg</span><br><span class="line">[defaults]</span><br><span class="line">enable_task_debugger = True</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># environment variable</span><br><span class="line">ANSIBLE_ENABLE_TASK_DEBUGGER=True ansible-playbook -i hosts site.yml</span><br></pre></td></tr></table></figure><p><br></p><p><strong>策略(As a Strategy)</strong></p><p>要使用debug策略，改变strategy属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  strategy:</span> <span class="string">debug</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ansible.cfg</span><br><span class="line">[defaults]</span><br><span class="line">strategy = debug</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># environment variable</span><br><span class="line">ANSIBLE_STRATEGY=debug</span><br></pre></td></tr></table></figure><p><br></p><p><strong>可用命令(Available Commands)</strong></p><p>打印值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[192.0.2.10] TASK: install package (debug)&gt; p task</span><br><span class="line">TASK: install package</span><br><span class="line">[192.0.2.10] TASK: install package (debug)&gt; p task.args</span><br><span class="line">&#123;u&apos;name&apos;: u&apos;&#123;&#123; pkg_name &#125;&#125;&apos;&#125;</span><br><span class="line">[192.0.2.10] TASK: install package (debug)&gt; p task_vars</span><br><span class="line">&#123;u&apos;ansible_all_ipv4_addresses&apos;: [u&apos;192.0.2.10&apos;],</span><br><span class="line"> u&apos;ansible_architecture&apos;: u&apos;x86_64&apos;,</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">[192.0.2.10] TASK: install package (debug)&gt; p task_vars[&apos;pkg_name&apos;]</span><br><span class="line">u&apos;bash&apos;</span><br><span class="line">[192.0.2.10] TASK: install package (debug)&gt; p host</span><br><span class="line">192.0.2.10</span><br><span class="line">[192.0.2.10] TASK: install package (debug)&gt; p result._result</span><br><span class="line">&#123;&apos;_ansible_no_log&apos;: False,</span><br><span class="line"> &apos;changed&apos;: False,</span><br><span class="line"> u&apos;failed&apos;: True,</span><br><span class="line"> ...</span><br><span class="line"> u&apos;msg&apos;: u&quot;No package matching &apos;not_exist&apos; is available&quot;&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="滚动升级"><a href="#滚动升级" class="headerlink" title="滚动升级"></a>滚动升级</h4><p>Delegation, Rolling Updates, and Local Actions: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html</a></p><p><br><br><br></p><h4 id="设置环境"><a href="#设置环境" class="headerlink" title="设置环境"></a>设置环境</h4><p>Setting the Environment: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_environment.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_environment.html</a></p><p><code>environment</code>关键字可以允许你为远程目标主机设置环境变量。例如，需要为http请求设置一个代理。获取其它工具需要的环境变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Install</span> <span class="string">cobbler</span></span><br><span class="line"><span class="attr">      package:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">cobbler</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">      environment:</span></span><br><span class="line"><span class="attr">        http_proxy:</span> <span class="attr">http://proxy.example.com:8080</span></span><br></pre></td></tr></table></figure><p>也可以存储在一个变量里：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="comment"># here we make a variable named "proxy_env" that is a dictionary</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    proxy_env:</span></span><br><span class="line"><span class="attr">      http_proxy:</span> <span class="attr">http://proxy.example.com:8080</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Install</span> <span class="string">cobbler</span></span><br><span class="line"><span class="attr">      package:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">cobbler</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">      environment:</span> <span class="string">"<span class="template-variable">&#123;&#123; proxy_env &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="特定语言版本管理器"><a href="#特定语言版本管理器" class="headerlink" title="特定语言版本管理器"></a>特定语言版本管理器</h4><p>Working With Language-Specific Version Managers</p><p>一些特定语言版本管理器(如nvm)要求，而这些工具在使用中都要求环境变量。挡手动使用这些工具，通常需要在配置文件中添加一些环境变量，在Ansible中，你可使用enviroment代替：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">### A playbook demonstrating a common npm workflow:</span><br><span class="line"># - Check for package.json in the application directory</span><br><span class="line"># - If package.json exists:</span><br><span class="line">#   * Run npm prune</span><br><span class="line">#   * Run npm install</span><br><span class="line"></span><br><span class="line">- hosts: application</span><br><span class="line">  become: false</span><br><span class="line"></span><br><span class="line">  vars:</span><br><span class="line">    node_app_dir: /var/local/my_node_app</span><br><span class="line"></span><br><span class="line">  environment:</span><br><span class="line">    NVM_DIR: /var/local/nvm</span><br><span class="line">    PATH: /var/local/nvm/versions/node/v4.2.1/bin:&#123;&#123; ansible_env.PATH &#125;&#125;</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">  - name: check for package.json</span><br><span class="line">    stat:</span><br><span class="line">      path: &apos;&#123;&#123; node_app_dir &#125;&#125;/package.json&apos;</span><br><span class="line">    register: packagejson</span><br><span class="line"></span><br><span class="line">  - name: npm prune</span><br><span class="line">    command: npm prune</span><br><span class="line">    args:</span><br><span class="line">      chdir: &apos;&#123;&#123; node_app_dir &#125;&#125;&apos;</span><br><span class="line">    when: packagejson.stat.exists</span><br><span class="line"></span><br><span class="line">  - name: npm install</span><br><span class="line">    npm:</span><br><span class="line">      path: &apos;&#123;&#123; node_app_dir &#125;&#125;&apos;</span><br><span class="line">    when: packagejson.stat.exists</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>Error Handling In Playbooks: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html</a></p><p>Ansible通常有默认值来确保检查命令和模块的返回码和是否失败，进行错误处理，除非你做了决定。</p><p><br></p><p><strong>忽略错误命令(Ignoring Failed Commands)</strong></p><p>一般来说，如果主机上有任务失败，playbook将停止执行。有时，你想让它继续进行：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">this</span> <span class="string">will</span> <span class="string">not</span> <span class="string">be</span> <span class="string">counted</span> <span class="string">as</span> <span class="string">a</span> <span class="string">failure</span></span><br><span class="line"><span class="attr">  command:</span> <span class="string">/bin/false</span></span><br><span class="line"><span class="attr">  ignore_errors:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>重置不可达的主机(Resetting Unreachable Hosts)</strong></p><p>连接失败将设置主机为不可达(UNREACHABLE)，它将从运行活跃主机列表中删除。可以使用<code>meta: clear_host_errors</code>来设置。</p><p><br></p><p><strong>处理程序和失败(Handlers and Failure)</strong></p><p>当主机上的一个任务失败时，先前通知(notify)的处理程序(handler)将不会在此主机上运行。例如，任务更新配置文件并通知处理程序去重启服务。如果任务以后的同一个play失败，则服务不会重启尽管配置已经更改。</p><p>可以使用<code>--force-handlers</code>命令行选项来改变此行为。或在play中包含<code>force_handlers: True</code>，或在ansible配置中包含<code>force_handlers = True</code>。当处理程序被强制执行，无论任务成功与否它们都会执行。</p><p><br></p><p><strong>控制如何定义失败(Controlling What Defines Failure)</strong></p><p>Ansible允许你使用<code>filed_when</code>条件来定义失败。栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Fail</span> <span class="string">task</span> <span class="string">when</span> <span class="string">the</span> <span class="string">command</span> <span class="string">error</span> <span class="string">output</span> <span class="string">prints</span> <span class="string">FAILED</span></span><br><span class="line"><span class="attr">  command:</span> <span class="string">/usr/bin/example-command</span> <span class="bullet">-x</span> <span class="bullet">-y</span> <span class="bullet">-z</span></span><br><span class="line"><span class="attr">  register:</span> <span class="string">command_result</span></span><br><span class="line"><span class="attr">  failed_when:</span> <span class="string">"'FAILED' in command_result.stderr"</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>覆盖改变的结果(Overriding The Changed Result)</strong></p><p>当一个模块运行，它通常会基于机器状态是否被影响而报告<code>changed</code>状态。</p><p>有时候你知道，基于返回码或返回结果，它并没有发生改变，并希望去覆盖<code>changed</code>结果，使它不出现在报告输出里：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- command:</span> <span class="string">/bin/fake_command</span></span><br><span class="line"><span class="attr">  register:</span> <span class="string">result</span></span><br><span class="line"><span class="attr">  ignore_errors:</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">  changed_when:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'"ERROR" in result.stderr'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">result.rc</span> <span class="string">==</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>终止play(Aborting the play)</strong></p><p>有时需要终止失败的play，而不是为某主机跳过剩余任务。</p><p><code>any_errors_fatal</code>选项将终止Play，并防止任何后续的plays运行。当遇到一个错误，当前批次的所有主机都有机会完成致命的任务，然后play的执行停止。<code>any_errors_fatal</code>可在play或block层级设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">somehosts</span></span><br><span class="line"><span class="attr">  any_errors_fatal:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">myrole</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">somehosts</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - block:</span></span><br><span class="line"><span class="attr">        - include_tasks:</span> <span class="string">mytasks.yml</span></span><br><span class="line"><span class="attr">      any_errors_fatal:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用块(blocks)</strong></p><p>大多数可应用到单个任务的也可应用到块，这使得它更容易设置数据或指定到任务。块只处理任务的失败(failed)状态。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Handle</span> <span class="string">the</span> <span class="string">error</span></span><br><span class="line"><span class="attr">  block:</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">'I execute normally'</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">i</span> <span class="string">force</span> <span class="string">a</span> <span class="string">failure</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">/bin/false</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">'I never execute, due to the above task failing, :-('</span></span><br><span class="line"><span class="attr">  rescue:</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">'I caught an error, can do stuff here to fix it, :-)'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h4><p>Advanced Syntax: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_advanced_syntax.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_advanced_syntax.html</a></p><p>高级的YANL语法可以给你在Ansible的YAML文件中更多控制数据的地方。你可以在<a href="https://pyyaml.org/wiki/PyYAMLDocumentation#YAMLtagsandPythontypes" target="_blank" rel="noopener">PyYAML文档</a>中找到等多Python特定化的YAML信息。</p><p><br></p><p><strong>不安全和原生字符串</strong><br>Unsafe or Raw Strings</p><p>Ansible提供了一个内部的数据类型，用来声明变量不安全(unsafe)。这意味着变量中保存的数据应为不安全，防止字符串被替换和披露。</p><p>Jinja2包含了转义，或告诉Jinja2不渲染数据，如<code>...</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用 !unsafe 标签</span><br><span class="line">my_unsafe_variable: !unsafe &apos;this variable has &#123;&#123; characters that should not be treated as a jinja2 template&apos;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">vars:</span></span><br><span class="line"><span class="attr">    my_unsafe_variable:</span> <span class="string">!unsafe</span> <span class="string">'unsafe value'</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>锚和别名</strong><br>YAML anchors and aliases: sharing variable values</p><p>YAML的锚(anchor)和别名(aliase)可以帮助你在灵活的方式中定义、维护和使用共享变量。使用<code>&amp;</code>定义一个锚，使用别名(<code>*</code>)指向它。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 锚内设置了3个变量，别名使用其它2个，并覆盖第3个</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">vars:</span></span><br><span class="line"><span class="attr">    app1:</span></span><br><span class="line"><span class="attr">        jvm:</span> <span class="meta">&amp;jvm_opts</span></span><br><span class="line"><span class="attr">            opts:</span> <span class="string">'-Xms1G -Xmx2G'</span></span><br><span class="line"><span class="attr">            port:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/usr/lib/app1</span></span><br><span class="line"><span class="attr">    app2:</span></span><br><span class="line"><span class="attr">        jvm:</span></span><br><span class="line">            <span class="string">&lt;&lt;:</span> <span class="meta">*jvm_opts</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/usr/lib/app2</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>path的值由合并操作符(<code>&lt;&lt;</code>)所合并。</p><p><br><br><br></p><h4 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h4><p>Working With Plugins: <a href="https://docs.ansible.com/ansible/latest/plugins/plugins.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/plugins/plugins.html</a></p><p>插件时扩展Ansible的核心功能。Ansible使用插件架构来实现丰富的、灵活的、可扩展的功能集。</p><p>Ansible ships附带了许多插件，你也可以自己编写。</p><ul><li>Action Plugins</li><li>Become Plugins</li><li>Cache Plugins</li><li>Callback Plugins</li><li>Cliconf Plugins</li><li>Connection Plugins</li><li>Httpapi Plugins</li><li>Inventory Plugins</li><li>Lookup Plugins</li><li>Netconf Plugins</li><li>Shell Plugins</li><li>Strategy Plugins</li><li>Vars Plugins</li><li>Filters</li><li>Tests</li><li>Plugin Filter Configuration</li></ul><p><br><br><br></p><h4 id="提示和输入"><a href="#提示和输入" class="headerlink" title="提示和输入"></a>提示和输入</h4><p>Prompts: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_prompts.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_prompts.html</a></p><p>当运行playbook时，你可能希望提示某些用户输入信息，可使用<code>vars_prompt</code>来完成。一个常见的用途可能是要求输入敏感的数据，但不希望记录。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  vars_prompt:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">username</span></span><br><span class="line"><span class="attr">      prompt:</span> <span class="string">"What is your username?"</span></span><br><span class="line"><span class="attr">      private:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">password</span></span><br><span class="line"><span class="attr">      prompt:</span> <span class="string">"What is your password?"</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">'Logging in as <span class="template-variable">&#123;&#123; username &#125;&#125;</span>'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>Tags: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html</a></p><p>如果你有一个大型的playbook，它可能成为一个有用的能够运行playbook的一个特定部分，而不是playbook中的所有。Ansible支持使用标签(tags)来完成。</p><p>标签可应用于Ansible的许多结构，但最简单的方法是单个任务。</p><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">- yum:</span></span><br><span class="line"><span class="attr">    name:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">httpd</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">packages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- template:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">templates/src.j2</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">/etc/foo.conf</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">configuration</span></span><br></pre></td></tr></table></figure><p>当你执行playbook，你可以用两种方法基于标签过滤任务：</p><ul><li>在命令行使用<code>--tags</code>或<code>--skip-tags</code>选项；</li><li>在Ansible配置中，使用<code>TAGS_RUN</code>或<code>TAGS_SKIP</code>选项。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 仅执行某个标签</span><br><span class="line">ansible-playbook example.yml --tags &quot;configuration,packages&quot;</span><br><span class="line"></span><br><span class="line"># 跳过某个标签</span><br><span class="line">ansible-playbook example.yml --skip-tags &quot;packages&quot;</span><br><span class="line"></span><br><span class="line"># 产看标签执行情况</span><br><span class="line">ansible-playbook example.yml --tags &quot;configuration,packages&quot; --list-tasks</span><br></pre></td></tr></table></figure><p><br></p><p><strong>标签重用</strong><br>Tag Reuse</p><p><br><br><br></p><h3 id="控制playbook执行"><a href="#控制playbook执行" class="headerlink" title="控制playbook执行"></a>控制playbook执行</h3><p>Controlling playbook execution: strategies and more: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_strategies.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_strategies.html</a></p><p>默认情况下，Ansible在使用5forks任意主机上开始下一个任务之前在所有被play影响的主机上运行每个任务。如果你想要改变此默认的行为，你可以使用不同的策略插件，改变fork数，或应用几个play级别的关键字（如<code>serial</code>）。</p><p><br></p><h4 id="选择策略"><a href="#选择策略" class="headerlink" title="选择策略"></a>选择策略</h4><p>Selecting a strategy</p><ul><li>linear strategy: <a href="https://docs.ansible.com/ansible/latest/plugins/strategy/linear.html#linear-strategy" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/plugins/strategy/linear.html#linear-strategy</a></li><li>debug strategy: <a href="https://docs.ansible.com/ansible/latest/plugins/strategy/debug.html#debug-strategy" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/plugins/strategy/debug.html#debug-strategy</a></li><li>free strategy: <a href="https://docs.ansible.com/ansible/latest/plugins/strategy/free.html#free-strategy" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/plugins/strategy/free.html#free-strategy</a></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  strategy:</span> <span class="string">free</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="设置fork数"><a href="#设置fork数" class="headerlink" title="设置fork数"></a>设置fork数</h4><p>Setting the number of forks</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ansible.cfg</span><br><span class="line">[defaults]</span><br><span class="line">forks = 30</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># or cli</span><br><span class="line">ansible-playbook -f 30 my_playbook.ym</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用关键字控制执行"><a href="#使用关键字控制执行" class="headerlink" title="使用关键字控制执行"></a>使用关键字控制执行</h4><p>Using keywords to control execution</p><p><a href="https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#playbook-keywords" target="_blank" rel="noopener">play level</a>的关键字会影响paly的执行。</p><p>最常见的是<code>serial</code>，还有<code>throttle</code>, <code>ignore_errors</code>, <code>ignore_unreachable</code>, <code>any_errors_fatal</code>。</p><p><br><br><br></p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>Best Practices: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html</a></p><p>使用Ansible和playbooks的一些技巧。</p><p>你可以在<a href="https://github.com/ansible/ansible-examples" target="_blank" rel="noopener">ansible-examples</a>仓库中找到最佳用法。</p><p><br></p><h4 id="内容组织"><a href="#内容组织" class="headerlink" title="内容组织"></a>内容组织</h4><p>Content Organization</p><p>下面将介绍组织Playbook内容的多种方式。你的ansible的使用应该适合你的需求，因此你可以按需组合各种方法。</p><p>组织ansible playbook内容的一个关键方式是role。你应该理解它。</p><p><br></p><h5 id="目录布局"><a href="#目录布局" class="headerlink" title="目录布局"></a>目录布局</h5><p>Directory Layout</p><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">staging</span>                   <span class="comment"># inventory file for staging environment</span></span><br><span class="line"></span><br><span class="line"><span class="string">group_vars/</span></span><br><span class="line">   <span class="string">group1.yml</span>             <span class="comment"># here we assign variables to particular groups</span></span><br><span class="line">   <span class="string">group2.yml</span></span><br><span class="line"><span class="string">host_vars/</span></span><br><span class="line">   <span class="string">hostname1.yml</span>          <span class="comment"># here we assign variables to particular systems</span></span><br><span class="line">   <span class="string">hostname2.yml</span></span><br><span class="line"></span><br><span class="line"><span class="string">library/</span>                  <span class="comment"># if any custom modules, put them here (optional)</span></span><br><span class="line"><span class="string">module_utils/</span>             <span class="comment"># if any custom module_utils to support modules, put them here (optional)</span></span><br><span class="line"><span class="string">filter_plugins/</span>           <span class="comment"># if any custom filter plugins, put them here (optional)</span></span><br><span class="line"></span><br><span class="line"><span class="string">site.yml</span>                  <span class="comment"># master playbook</span></span><br><span class="line"><span class="string">webservers.yml</span>            <span class="comment"># playbook for webserver tier</span></span><br><span class="line"><span class="string">dbservers.yml</span>             <span class="comment"># playbook for dbserver tier</span></span><br><span class="line"></span><br><span class="line"><span class="string">roles/</span></span><br><span class="line">    <span class="string">common/</span>               <span class="comment"># this hierarchy represents a "role"</span></span><br><span class="line">        <span class="string">tasks/</span>            <span class="comment">#</span></span><br><span class="line">            <span class="string">main.yml</span>      <span class="comment">#  &lt;-- tasks file can include smaller files if warranted</span></span><br><span class="line">        <span class="string">handlers/</span>         <span class="comment">#</span></span><br><span class="line">            <span class="string">main.yml</span>      <span class="comment">#  &lt;-- handlers file</span></span><br><span class="line">        <span class="string">templates/</span>        <span class="comment">#  &lt;-- files for use with the template resource</span></span><br><span class="line">            <span class="string">ntp.conf.j2</span>   <span class="comment">#  &lt;------- templates end in .j2</span></span><br><span class="line">        <span class="string">files/</span>            <span class="comment">#</span></span><br><span class="line">            <span class="string">bar.txt</span>       <span class="comment">#  &lt;-- files for use with the copy resource</span></span><br><span class="line">            <span class="string">foo.sh</span>        <span class="comment">#  &lt;-- script files for use with the script resource</span></span><br><span class="line">        <span class="string">vars/</span>             <span class="comment">#</span></span><br><span class="line">            <span class="string">main.yml</span>      <span class="comment">#  &lt;-- variables associated with this role</span></span><br><span class="line">        <span class="string">defaults/</span>         <span class="comment">#</span></span><br><span class="line">            <span class="string">main.yml</span>      <span class="comment">#  &lt;-- default lower priority variables for this role</span></span><br><span class="line">        <span class="string">meta/</span>             <span class="comment">#</span></span><br><span class="line">            <span class="string">main.yml</span>      <span class="comment">#  &lt;-- role dependencies</span></span><br><span class="line">        <span class="string">library/</span>          <span class="comment"># roles can also include custom modules</span></span><br><span class="line">        <span class="string">module_utils/</span>     <span class="comment"># roles can also include custom module_utils</span></span><br><span class="line">        <span class="string">lookup_plugins/</span>   <span class="comment"># or other types of plugins, like lookup in this case</span></span><br><span class="line"></span><br><span class="line">    <span class="string">webtier/</span>              <span class="comment"># same kind of structure as "common" was above, done for the webtier role</span></span><br><span class="line">    <span class="string">monitoring/</span>           <span class="comment"># ""</span></span><br><span class="line">    <span class="string">fooapp/</span>               <span class="comment"># ""</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="可选的目录布局"><a href="#可选的目录布局" class="headerlink" title="可选的目录布局"></a>可选的目录布局</h5><p>Alternative Directory Layout</p><p>此布局为大型环境提供了更多灵活性，栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">inventories/</span></span><br><span class="line">   <span class="string">production/</span></span><br><span class="line">      <span class="string">hosts</span>               <span class="comment"># inventory file for production servers</span></span><br><span class="line">      <span class="string">group_vars/</span></span><br><span class="line">         <span class="string">group1.yml</span>       <span class="comment"># here we assign variables to particular groups</span></span><br><span class="line">         <span class="string">group2.yml</span></span><br><span class="line">      <span class="string">host_vars/</span></span><br><span class="line">         <span class="string">hostname1.yml</span>    <span class="comment"># here we assign variables to particular systems</span></span><br><span class="line">         <span class="string">hostname2.yml</span></span><br><span class="line"></span><br><span class="line">   <span class="string">staging/</span></span><br><span class="line">      <span class="string">hosts</span>               <span class="comment"># inventory file for staging environment</span></span><br><span class="line">      <span class="string">group_vars/</span></span><br><span class="line">         <span class="string">group1.yml</span>       <span class="comment"># here we assign variables to particular groups</span></span><br><span class="line">         <span class="string">group2.yml</span></span><br><span class="line">      <span class="string">host_vars/</span></span><br><span class="line">         <span class="string">stagehost1.yml</span>   <span class="comment"># here we assign variables to particular systems</span></span><br><span class="line">         <span class="string">stagehost2.yml</span></span><br><span class="line"></span><br><span class="line"><span class="string">library/</span></span><br><span class="line"><span class="string">module_utils/</span></span><br><span class="line"><span class="string">filter_plugins/</span></span><br><span class="line"></span><br><span class="line"><span class="string">site.yml</span></span><br><span class="line"><span class="string">webservers.yml</span></span><br><span class="line"><span class="string">dbservers.yml</span></span><br><span class="line"></span><br><span class="line"><span class="string">roles/</span></span><br><span class="line">    <span class="string">common/</span></span><br><span class="line">    <span class="string">webtier/</span></span><br><span class="line">    <span class="string">monitoring/</span></span><br><span class="line">    <span class="string">fooapp/</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="使用云动态资产"><a href="#使用云动态资产" class="headerlink" title="使用云动态资产"></a>使用云动态资产</h5><p>Use Dynamic Inventory With Clouds</p><p>如果你使用云服务提供商，你不应该在静态文件中管理你的资产。请参考<a href="https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html#intro-dynamic-inventory" target="_blank" rel="noopener">Working with dynamic inventory</a></p><p><br></p><h5 id="如何区分测试与生产"><a href="#如何区分测试与生产" class="headerlink" title="如何区分测试与生产"></a>如何区分测试与生产</h5><p>How to Differentiate Staging vs Production</p><p>如果管理静态清单，经常会问到如何区分不同类型的环境。下面的例子提供了一个好方法。分组的类似方法可以适用动态清单。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file: production</span></span><br><span class="line"></span><br><span class="line"><span class="section">[atlanta_webservers]</span></span><br><span class="line">www-atl-1.example.com</span><br><span class="line">www-atl-2.example.com</span><br><span class="line"></span><br><span class="line"><span class="section">[boston_webservers]</span></span><br><span class="line">www-bos-1.example.com</span><br><span class="line">www-bos-2.example.com</span><br><span class="line"></span><br><span class="line"><span class="section">[atlanta_dbservers]</span></span><br><span class="line">db-atl-1.example.com</span><br><span class="line">db-atl-2.example.com</span><br><span class="line"></span><br><span class="line"><span class="section">[boston_dbservers]</span></span><br><span class="line">db-bos-1.example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># webservers in all geos</span></span><br><span class="line"><span class="section">[webservers:children]</span></span><br><span class="line">atlanta_webservers</span><br><span class="line">boston_webservers</span><br><span class="line"></span><br><span class="line"><span class="comment"># dbservers in all geos</span></span><br><span class="line"><span class="section">[dbservers:children]</span></span><br><span class="line">atlanta_dbservers</span><br><span class="line">boston_dbservers</span><br><span class="line"></span><br><span class="line"><span class="comment"># everything in the atlanta geo</span></span><br><span class="line"><span class="section">[atlanta:children]</span></span><br><span class="line">atlanta_webservers</span><br><span class="line">atlanta_dbservers</span><br><span class="line"></span><br><span class="line"><span class="comment"># everything in the boston geo</span></span><br><span class="line"><span class="section">[boston:children]</span></span><br><span class="line">boston_webservers</span><br><span class="line">boston_dbservers</span><br></pre></td></tr></table></figure><p><br></p><h5 id="组和主机变量"><a href="#组和主机变量" class="headerlink" title="组和主机变量"></a>组和主机变量</h5><p>Group And Host Variables</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># file: group_vars/atlanta</span></span><br><span class="line"><span class="attr">ntp:</span> <span class="string">ntp-atlanta.example.com</span></span><br><span class="line"><span class="attr">backup:</span> <span class="string">backup-atlanta.example.com</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># file: group_vars/webservers</span></span><br><span class="line"><span class="attr">apacheMaxRequestsPerChild:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">apacheMaxClients:</span> <span class="number">900</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># file: group_vars/all</span></span><br><span class="line"><span class="attr">ntp:</span> <span class="string">ntp-boston.example.com</span></span><br><span class="line"><span class="attr">backup:</span> <span class="string">backup-boston.example.com</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="顶级playbook通过角色分离"><a href="#顶级playbook通过角色分离" class="headerlink" title="顶级playbook通过角色分离"></a>顶级playbook通过角色分离</h5><p>Top Level Playbooks Are Separated By Role</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># file: site.yml</span></span><br><span class="line"><span class="attr">- import_playbook:</span> <span class="string">webservers.yml</span></span><br><span class="line"><span class="attr">- import_playbook:</span> <span class="string">dbservers.yml</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># file: webservers.yml</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">common</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">webtier</span></span><br></pre></td></tr></table></figure><p>这里，我们可以选择运行<code>site.yml</code>来配置我们的整个基础架构，或者通过运行<code>webservers.yml</code>来只运行一个子集。类似于下面：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ansible-playbook</span> <span class="string">site.yml</span> <span class="bullet">--limit</span> <span class="string">webservers</span></span><br><span class="line"><span class="string">ansible-playbook</span> <span class="string">webservers.yml</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="角色的任务和处理程序组织"><a href="#角色的任务和处理程序组织" class="headerlink" title="角色的任务和处理程序组织"></a>角色的任务和处理程序组织</h5><p>Task And Handler Organization For A Role</p><p>下面解释一个NTP任务是如何工作：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file: roles/common/tasks/main.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">be</span> <span class="string">sure</span> <span class="string">ntp</span> <span class="string">is</span> <span class="string">installed</span></span><br><span class="line"><span class="attr">  yum:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">ntp</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">ntp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">be</span> <span class="string">sure</span> <span class="string">ntp</span> <span class="string">is</span> <span class="string">configured</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">ntp.conf.j2</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">/etc/ntp.conf</span></span><br><span class="line"><span class="attr">  notify:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">restart</span> <span class="string">ntpd</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">ntp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">be</span> <span class="string">sure</span> <span class="string">ntpd</span> <span class="string">is</span> <span class="string">running</span> <span class="string">and</span> <span class="string">enabled</span></span><br><span class="line"><span class="attr">  service:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">ntpd</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">started</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">ntp</span></span><br></pre></td></tr></table></figure><p>这是一个处理程序(handler)文件栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># file: roles/common/handlers/main.yml</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">restart</span> <span class="string">ntpd</span></span><br><span class="line"><span class="attr">  service:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">ntpd</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="什么组织启用"><a href="#什么组织启用" class="headerlink" title="什么组织启用"></a>什么组织启用</h5><p>What This Organization Enables</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 重新配置基础服务</span><br><span class="line">ansible-playbook -i production site.yml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 重新配置NTP</span><br><span class="line">ansible-playbook -i production site.yml --tags ntp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 重新配置webservers</span><br><span class="line">ansible-playbook -i production webservers.yml</span><br><span class="line"># boston</span><br><span class="line">ansible-playbook -i production webservers.yml --limit boston</span><br><span class="line"># boston first 10</span><br><span class="line">ansible-playbook -i production webservers.yml --limit boston[0:9]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ad-hoc</span><br><span class="line">ansible boston -i production -m command -a &apos;/sbin/reboot&apos;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="部署于配置组织"><a href="#部署于配置组织" class="headerlink" title="部署于配置组织"></a>部署于配置组织</h5><p>Deployment vs Configuration Organization</p><p>上面的配置模型是一个典型的配置拓扑。当进行多级部署中，会有一些额外的playbook（hop between tiers to roll out an application）。</p><p><br><br><br></p><h4 id="测试与生产"><a href="#测试与生产" class="headerlink" title="测试与生产"></a>测试与生产</h4><p>Staging vs Production</p><p>如上所述，让staging(testing)和production环境分离是为不同的环境使用单独的清单文件。你的环境不一定是相同的大小，你可以使用变量来控制它们。</p><p><br><br><br></p><h4 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h4><p>Rolling Updates</p><p>理解<code>serial</code>关键字。</p><p><br><br><br></p><h4 id="注意状态"><a href="#注意状态" class="headerlink" title="注意状态"></a>注意状态</h4><p>Always Mention The State</p><p><code>state</code>参数对许多模块是可选的。如<code>state=present</code>或<code>state=absent</code>。</p><p><br><br><br></p><h4 id="通过角色分组"><a href="#通过角色分组" class="headerlink" title="通过角色分组"></a>通过角色分组</h4><p>Group By Roles</p><p>一个系统可以在多个组。这使得playbook基于角色来选择目标主机。以及使用该组变量系统来分配角色特定的变量。</p><p><br><br><br></p><h4 id="操作系统和发行版本"><a href="#操作系统和发行版本" class="headerlink" title="操作系统和发行版本"></a>操作系统和发行版本</h4><p>Operating System and Distribution Variance</p><p>当在两个不同的操作系统之间处理一个参数时，处理它的一个好方法是使用<code>group_by</code>模块。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr"> - name:</span> <span class="string">talk</span> <span class="string">to</span> <span class="string">all</span> <span class="string">hosts</span> <span class="string">just</span> <span class="string">so</span> <span class="string">we</span> <span class="string">can</span> <span class="string">learn</span> <span class="string">about</span> <span class="string">them</span></span><br><span class="line"><span class="attr">   hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">   tasks:</span></span><br><span class="line"><span class="attr">     - name:</span> <span class="string">Classify</span> <span class="string">hosts</span> <span class="string">depending</span> <span class="string">on</span> <span class="string">their</span> <span class="string">OS</span> <span class="string">distribution</span></span><br><span class="line"><span class="attr">       group_by:</span></span><br><span class="line"><span class="attr">         key:</span> <span class="string">os_&#123;&#123;</span> <span class="string">ansible_facts['distribution']</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># now just on the CentOS hosts...</span></span><br><span class="line"></span><br><span class="line"><span class="attr"> - hosts:</span> <span class="string">os_CentOS</span></span><br><span class="line"><span class="attr">   gather_facts:</span> <span class="literal">False</span></span><br><span class="line"><span class="attr">   tasks:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="comment"># tasks that only happen on CentOS go here</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Set</span> <span class="string">OS</span> <span class="string">distribution</span> <span class="string">dependent</span> <span class="string">variables</span></span><br><span class="line"><span class="attr">      include_vars:</span> <span class="string">"os_<span class="template-variable">&#123;&#123; ansible_facts['distribution'] &#125;&#125;</span>.yml"</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        var:</span> <span class="string">asdf</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用playbook捆绑ansible模块"><a href="#使用playbook捆绑ansible模块" class="headerlink" title="使用playbook捆绑ansible模块"></a>使用playbook捆绑ansible模块</h4><p>Bundling Ansible Modules With Playbooks</p><p>如果playbook有相对于其它YAML文件的<code>./library</code>目录，此目录可以用来添加ansible module，它会自动在ansible模块路径。这是一个保持模块与playbook在一起的好方法。</p><p><br><br><br></p><h4 id="空白和注释"><a href="#空白和注释" class="headerlink" title="空白和注释"></a>空白和注释</h4><p>Whitespace and Comments</p><p>空白和注释有利于文件可读性，值得使用。</p><p><br><br><br></p><h4 id="任务命名"><a href="#任务命名" class="headerlink" title="任务命名"></a>任务命名</h4><p>Always Name Tasks</p><p>给任务建立一个正在做什么的名称。在运行时，playbook显示此名称。</p><p><br><br><br></p><h4 id="使它简单"><a href="#使它简单" class="headerlink" title="使它简单"></a>使它简单</h4><p>Keep It Simple</p><p>当你能够简单地做事，那就简单地做。不要为了达到使用所有ansible功能而一起使用它们。使用你需要的。把复杂的事情简单化。</p><p><br><br><br></p><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>Version Control</p><p>使用版本控制来管理playbook。</p><p><br><br><br></p><h4 id="变量和拱顶"><a href="#变量和拱顶" class="headerlink" title="变量和拱顶"></a>变量和拱顶</h4><p>Variables and Vaults</p><p>当运行playbook，Ansible在未加密的文件中查找变量，并且所有敏感的变量来自加密文件。</p><p>一个最佳实践方法是在组下开始一个<code>group_vars</code>子目录。在此子目录内，创建两个名为<code>vars</code>和<code>vault</code>的文件。<code>vars</code>文件内定义所有需要的变量，包括敏感的。接下来，复制所有的敏感变量到<code>vault</code>文件或以<code>vault_</code>开头的文件。你应该在<code>vars</code>文件内使用Jinja2语法调整变量指向匹配的<code>vault_</code>文件，并确保<code>vault</code>文件是vault encrypted。</p><p><br><br><br></p><h3 id="持续交付和滚动更新"><a href="#持续交付和滚动更新" class="headerlink" title="持续交付和滚动更新"></a>持续交付和滚动更新</h3><p>Playbook Example: Continuous Delivery and Rolling Upgrades: <a href="https://docs.ansible.com/ansible/latest/user_guide/guide_rolling_upgrade.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/guide_rolling_upgrade.html</a></p><p><br></p><h4 id="什么是持续交付"><a href="#什么是持续交付" class="headerlink" title="什么是持续交付"></a>什么是持续交付</h4><p>What is continuous delivery</p><p>Continuous delivery(CD)是指经常更新你的软件应用程序。</p><p><br><br><br><br><br></p><h2 id="特权晋升-1"><a href="#特权晋升-1" class="headerlink" title="特权晋升"></a>特权晋升</h2><p>Understanding privilege escalation: become: <a href="https://docs.ansible.com/ansible/latest/user_guide/become.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/become.html</a></p><p>Ansible使用现有的权限升级系统来执行具有root或其它权限的任务。此功能允许你成为(<code>become</code>)其它用户，与登录到远程机器不同，我们称之为<code>become</code>。become关键字利用现有的权限提升工具（如<code>sudo</code>, <code>su</code>, <code>pfexec</code>, <code>doas</code>, <code>pbrun</code>, <code>dzdo</code>, <code>ksu</code>, <code>runas</code>）。</p><p><br></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>你可以在任务、连接变量、命令行等控制<code>become</code>的使用。如果你以多种方式设置了特权提升，请注意优先级。</p><p>所有become plugins完整的列表: <a href="https://docs.ansible.com/ansible/latest/plugins/become.html#become-plugin-list" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/plugins/become.html#become-plugin-list</a></p><p><br></p><p><strong>become</strong></p><p>你可在play或task层设置<code>become</code>指令。你可以设置连接变量，从不同主机之间覆盖它们。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活特权提升</span></span><br><span class="line"><span class="attr">become:</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 默认root</span></span><br><span class="line"><span class="attr">become_user:</span> <span class="string">xxx</span></span><br><span class="line"><span class="comment"># 参考become plugins，可在ansible.cfg中配置。默认sudo</span></span><br><span class="line"><span class="attr">become_method:</span> <span class="string">sudo</span></span><br><span class="line"><span class="comment"># 为role或task执行特定标志</span></span><br><span class="line"><span class="attr">become_flags:</span> <span class="string">xxx</span></span><br></pre></td></tr></table></figure><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- name: Ensure the httpd is running</span><br><span class="line">  become: yes</span><br><span class="line">  service:</span><br><span class="line">    name: httpd</span><br><span class="line">    state: started</span><br><span class="line"></span><br><span class="line">- name: Run a command as the apache user</span><br><span class="line">  command: somecommand</span><br><span class="line">  become: yes</span><br><span class="line">  become_user: apache</span><br><span class="line"></span><br><span class="line">- name: Run a command as nobody</span><br><span class="line">  command: somecommand</span><br><span class="line">  become: yes</span><br><span class="line">  become_method: su</span><br><span class="line">  become_user: nobody</span><br><span class="line">  become_flags: &apos;-s /bin/sh&apos;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>连接变量</strong></p><p>Become connection variables</p><p>你可以定义不同的选型来管理node或group。你可以在资产中定义这些变量，或将其作为正常的变量使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ansible_become</span><br><span class="line">ansible_become_method</span><br><span class="line">ansible_become_user</span><br><span class="line">ansible_become_password</span><br><span class="line"></span><br><span class="line"># 栗子</span><br><span class="line">webserver ansible_user=manager ansible_become=yes</span><br></pre></td></tr></table></figure><p><br></p><p><strong>命令行选项</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--ask-become-pass, -K</span><br><span class="line">--become, -b</span><br><span class="line">--become-method=BECOME_METHOD</span><br><span class="line">--become-user=BECOME_USER</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="风险和局限性"><a href="#风险和局限性" class="headerlink" title="风险和局限性"></a>风险和局限性</h3><p>Risks and limitations of become</p><p>虽然权限提升是很直观的，但它如何工作也有一些限制。用户应该知道这些，以避免意外。</p><p><br></p><p><strong>成为一个非特权用户的风险</strong><br>Risks of becoming an unprivileged user</p><p>Ansible模块由第一个参数带入模块文件，然后将其复制到远程主机，最后在远程机器上执行它。</p><p>如果模块文件不使用<code>become</code>，当<code>become_ueer</code>为root时，或当远程机器被设置为root时，一切都好。在这些情况下，Ansible创建具有只允许由所述用户和root读取，或只允许由所述非特权用户切换到读取权限模块文件。</p><p>然而，当连接用户和<code>become_user</code>都不是特权用户，模块文件被写入需要由Ansible设置为用户可读。在这种情况下，Ansible使得模块文件世界可读的Ansible模块执行的持续时间。一旦模块执行完毕，Ansible删除临时文件。</p><p><br></p><p><strong>不是所有连接插件都支持</strong><br>Not supported by all connection plugins</p><p>特权升级方法也必须由连接使用的插件支持。</p><p><br></p><p><strong>每个主机只能启用一个方法</strong><br>Only one method may be enabled per host</p><p><br></p><p><strong>特权提升必须通用</strong><br>Privilege escalation must be general</p><p>你不能限制权限提升某些命令的权限。</p><p><br><br><br><br><br></p><h2 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h2><p>Ansible Vault: <a href="https://docs.ansible.com/ansible/latest/user_guide/vault.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/vault.html</a></p><p>Ansible Vault是Ansible的一个功能，可以让你在加密的文件中保存敏感数据（如密码、密钥），而不是像普通文本或playbooks或roles中。这些vault文件可以分布或放置在版本控制中。</p><p>要启用此功能，使用命令行选型<code>-ansible-vault</code>，和<code>--vault-password-file</code>。</p><p><br><br><br><br><br></p><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>Ansible Modules: <a href="https://docs.ansible.com/ansible/latest/user_guide/modules.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/modules.html</a></p><p>Ansible包含了大量的模块(module library)，可以直接在远程主机或通过playbook执行。</p><p>用户也可以编写自己的模块。这些模块可以控制系统资源（服务、包、文件…），或执行系统命令。</p><p><br><br><br></p><h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><p>Introduction to modules: <a href="https://docs.ansible.com/ansible/latest/user_guide/modules_intro.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/modules_intro.html</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># adhoc</span></span><br><span class="line">ansible webservers -m service -a <span class="string">"name=httpd state=started"</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># playbook</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">restart</span> <span class="string">webserver</span></span><br><span class="line"><span class="attr">  service:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>Return Values: <a href="https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.html</a></p><p>Ansible模块通常正常返回一个可以注册为一个变量的数据结构，或直接看到由ansible程序输出。每个模块都可选的记录自己唯一的返回值。</p><p>本章节包含的返回值适用于所有模块。</p><p><br></p><ul><li>Common<ul><li>backup_file</li><li>changed</li><li>failed</li><li>invocation</li><li>msg</li><li>rc</li><li>results</li><li>skipped</li><li>stderr</li><li>stderr_lines</li><li>stdout</li><li>stdout_lines</li></ul></li><li>Internal use<ul><li>ansible_facts</li><li>exception</li><li>warning</li><li>deprecations</li></ul></li></ul><p><br><br><br></p><h3 id="模块索引"><a href="#模块索引" class="headerlink" title="模块索引"></a>模块索引</h3><p>Module Index: <a href="https://docs.ansible.com/ansible/latest/modules/modules_by_category.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/modules/modules_by_category.html</a></p><p><br><br><br><br><br></p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Working With Plugins: <a href="https://docs.ansible.com/ansible/latest/plugins/plugins.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/plugins/plugins.html</a></p><p>插件是一段代码，可以扩充Ansible的核心功能。Ansible使用插件架构，以实现丰富的、灵活的、可扩展的功能集。</p><p>Ansible附带了一些方便的插件，你也可以很容易地编写自己的插件。</p><p><br><br><br><br><br></p><h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><p>collections: <a href="https://docs.ansible.com/ansible/latest/user_guide/collections_using.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/collections_using.html</a></p><p>Collections是Ansible的内容分发格式，可以包括playbooks, roles, modules, plugins。你可以通过Ansible Galaxy安装和使用collections。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="开发指南"><a href="#开发指南" class="headerlink" title="开发指南"></a>开发指南</h1><p>Developer Guide: <a href="https://docs.ansible.com/ansible/latest/dev_guide/index.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/dev_guide/index.html</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Ansible-Galaxy"><a href="#Ansible-Galaxy" class="headerlink" title="Ansible Galaxy"></a>Ansible Galaxy</h1><p>Ansible Galaxy: <a href="https://docs.ansible.com/ansible/latest/galaxy/user_guide.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/galaxy/user_guide.html</a></p><p>Ansible Galaxy是一个查找、分享、下载社区开发的roles的网站。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ansible docs: &lt;a href=&quot;https://docs.ansible.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.ansible.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RHELx86_64&lt;/li&gt;
&lt;li&gt;Ansible v2.9&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="DevOps" scheme="https://zhang21.github.io/tags/DevOps/"/>
    
      <category term="Ansible" scheme="https://zhang21.github.io/tags/Ansible/"/>
    
      <category term="Automation" scheme="https://zhang21.github.io/tags/Automation/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus</title>
    <link href="https://zhang21.github.io/2018/09/11/Prometheus/"/>
    <id>https://zhang21.github.io/2018/09/11/Prometheus/</id>
    <published>2018-09-11T03:01:12.000Z</published>
    <updated>2020-10-30T08:24:03.925Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>Prometheus文档： <a href="https://prometheus.io/docs" target="_blank" rel="noopener">https://prometheus.io/docs</a></li><li>GitHub: <a href="https://github.com/prometheus/" target="_blank" rel="noopener">https://github.com/prometheus/</a></li><li>PrometheusAlert: <a href="https://github.com/feiyu563/PrometheusAlert" target="_blank" rel="noopener">https://github.com/feiyu563/PrometheusAlert</a></li></ul><p>环境：</p><ul><li>CentOS7x86_64</li><li>Prometheus v2.14</li></ul><p><br></p><a id="more"></a><p><img src="/images/Prometheus/prometheus.jpg" alt="Prometheus"></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Introduction</p><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><br></p><h3 id="Prometheus是什么"><a href="#Prometheus是什么" class="headerlink" title="Prometheus是什么"></a>Prometheus是什么</h3><p>What is Prometheus?</p><p>Prometheus是一个最初在SoundCloud上构建的<strong>开源监控系统和报警工具包</strong>。现在是一个独立的开源项目，由社区进行维护。</p><p><br></p><p><strong>功能(Features)</strong><br>Prometheus的主要特点：</p><ul><li>具有由度量名称(metric name)和键值对(key-value)标识的时间序列(time series)数据的多维(multi-dimensional)数据模型</li><li>灵活的查询语言，以利用此维度</li><li>不依赖分布式存储(distributed storage)，单个服务器节点是自治的(autonomous)</li><li>时间序列集合通过HTPP的<code>pull model</code>发生</li><li><code>push</code>时间序列通过中间网关(intermediary gateway)的支持</li><li>通过服务发现或静态配置来发现目标</li><li>图形和仪表盘支持多种模式</li></ul><p><br></p><p><strong>组件(Components)</strong><br>Prometheus系统由多个组件构成，其中某些组件是可选的：</p><ul><li>主要的<strong>Prometheus Server</strong>，用于存储时间序列数据</li><li><strong>client libraries</strong>，用于检测应用程序代码</li><li><strong>push gateway</strong>，用于支持短暂的(short-lived)工作</li><li><strong>exporters</strong>，用于服务的特殊目的</li><li><strong>alertmanager</strong>，用于处理报警</li><li>各种支持工具</li></ul><p><br></p><p><strong>架构(Architecture)</strong><br>Prometheus的体系结构和系统组件图：</p><p><img src="/images/Prometheus/architecture.png" alt="Prometheus架构图"></p><p><br><br><br></p><h3 id="什么时候适合"><a href="#什么时候适合" class="headerlink" title="什么时候适合"></a>什么时候适合</h3><p>When does it fit?</p><p>Prometheus适用于记录任何纯数字时间序列。它既适用于以机器为中心的监控，也适用于高度动态的面向服务架构的监控。在微服务的世界中，它对多维数据收集和查询的支持是一种特殊的优势。<br>Prometheus专为提高可靠性而设计，是你在断电期间可以快速诊断问题的系统。每个Prometheus Server都是独立的，不依赖于网络存储或其它远程服务。当基础架构其它部分损坏时，你仍可以依赖它，并且你不需要设置大量的基础架构来使用它。</p><p><br><br><br></p><h3 id="什么时候不适合"><a href="#什么时候不适合" class="headerlink" title="什么时候不适合"></a>什么时候不适合</h3><p>When does it not fit?</p><p>Prometheus重视可靠性。即使在系统故障情况下，你也可以随时查看有关系统的可用统计信息。如果你需要100%的准确度，Prometheus不是一个好的选择，你可能需要使用其它系统。</p><p><br><br><br><br><br></p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>步骤：</p><ul><li>下载</li><li>配置</li><li>运行</li><li>使用表达式浏览器</li><li>使用图形接口</li><li>监控其它目标</li></ul><p><br><br><br><br><br></p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>GLOSSARY</p><ul><li><p><strong>Alert</strong><br>是Prometheus正在开火的警报规则的结果。警报从Prometheus发送到AlterManger。</p></li><li><p><strong>Alertmanager</strong><br>接收警报，将它们聚合成组，删除重复数据，应用静音、限制，然后发送电子邮件等通知。</p></li><li><p><strong>Bridge</strong><br>是一个从Client Library中获取样本并将它们暴露给 non-Prometheus 监控系统的组件。例如，Python、Java、Go…客户端可将指标导出到Graphite。</p></li><li><p><strong>Client library</strong><br>是某种语言的库(Go, Java, Python…)，可以直接检测代码，编写自定义收集器以从其它系统中收集指标并将指标公开给Prometheus。</p></li><li><p><strong>Collector</strong><br>是表示一组度量标准的 exporter 的一部分。如果它是直接检测的一部分，则可以是单个度量，如果是从另一个系统提取度量，则可以是许多度量。</p></li><li><p><strong>Direct instrumentation</strong><br>作为源代码程序的一部分内联添加的检测。</p></li><li><p><strong>Endpoint</strong></p></li><li><p><strong>Exporter</strong><br>是一个公开Prometheus指标的程序，通常将 non-prometheus 格式的指标转换为 Prometheus 支持的格式。</p></li><li><p><strong>Instance</strong><br>唯一标识作业中目标的标签</p></li><li><p><strong>Job</strong><br>具有相同目的的目标集合</p></li><li><p><strong>Notification</strong><br>代表一组多个警报</p></li><li><p><strong>Promdash</strong><br>原生Prometheus仪表盘构建器。它已被弃用，并被 Grafana 取代</p></li><li><p><strong>Prometheus</strong><br>通常指的是Prometheus System的核心程序，也可指整个监控系统。</p></li><li><p><strong>PromQL</strong><br>Prometheus Query Language</p></li><li><p><strong>Pushgateway</strong><br>持续从批量作业中最新推出的指标</p></li><li><p><strong>Remote Read</strong><br>允许从其它系统透明读取时间序列作为查询的一部分</p></li><li><p><strong>Remote Read Adapter</strong><br>并非所有系统都支持远程读取。远程读取适配器便是用于此。</p></li><li><p><strong>Remote Read Endpoint</strong><br>Prometheus进行远程读取时的对象</p></li><li><p><strong>Remote Write</strong><br>允许动态地将采集的样本发送到其它系统</p></li><li><p><strong>Remote Write Adapter</strong></p></li><li><p><strong>Remote Write Endpoint</strong></p></li><li><p><strong>Sample</strong><br>时间序列中某个时间点的单个值，Prometheus中，每个样本都包含一个<code>float64</code>和<code>ms</code>精度的时间戳。</p></li><li><p><strong>Silence</strong><br>防止报警</p></li><li><p><strong>Target</strong><br>抓取对象的定义</p></li></ul><p><br><br><br><br><br></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>faq: <a href="https://prometheus.io/docs/introduction/faq/" target="_blank" rel="noopener">https://prometheus.io/docs/introduction/faq/</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>CONCEPTS</p><p><br></p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Data model</p><p>Prometheus从根本上将所有数据存储为<strong>时间序列(time series)</strong>: 属于同一指标和同一标记维度的带时间戳值的流。除了存储时间序列，Prometheus还可以临时生成时间序列作为查询的结果。</p><p><br><br><br></p><h3 id="指标名称和标签"><a href="#指标名称和标签" class="headerlink" title="指标名称和标签"></a>指标名称和标签</h3><p>Metric names and labels</p><p>每个时间序列都是有<strong>指标名称(metric name)</strong>和一组键值对(也称为<strong>标签(label)</strong>)来唯一标识。</p><p>指标名称： 可能包含ASCII字母，下划线，冒号。它必须匹配正则: <code>[a-zA-Z_:][a-zA-Z0-9_:]*</code>。<br>标签启用Prometheus的维度数据模型：</p><p><br><br><br><br><br></p><h2 id="指标类型"><a href="#指标类型" class="headerlink" title="指标类型"></a>指标类型</h2><p>metric types: <a href="https://prometheus.io/docs/concepts/metric_types/" target="_blank" rel="noopener">https://prometheus.io/docs/concepts/metric_types/</a></p><p>Prometheus Client Library提供了四个核心指标类型。这些目前仅在客户端和在有线协议(wire protocol)中区分。Prometheus Server尚未使用的类型信息和所有数据合并为无类型(untyped)时间序列。这在未来可能改变。</p><p><br></p><p>Prometheus clinet使用文档:</p><ul><li><a href="https://godoc.org/github.com/prometheus/client_golang/prometheus" target="_blank" rel="noopener">Go</a></li><li><a href="https://github.com/prometheus/client_java" target="_blank" rel="noopener">Java</a></li><li><a href="https://github.com/prometheus/client_python" target="_blank" rel="noopener">Python</a></li></ul><p><br></p><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>Counter，只增不减的计数器。</p><p>Counter是一个累计指标，代表一个单调递增计数器，即只增不减，除非重启或被重置为0。例如，你可以使用counter来代表服务的请求数、已完成的任务数、错误的数量…</p><p>不要用counter来暴露一个可以减少的值。例如，不要对当前运行的进程数使用<code>counter</code>类型，使用<code>gauge</code>类型。</p><p>一般在定义counter类型指标的名称时，推荐使用<code>xxx_total</code>作为后缀名。（如<code>http_request_total</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 获取HTTP请求量的增长率</span><br><span class="line">rate(http_requests_total[5m])</span><br><span class="line"></span><br><span class="line"># 统计前十</span><br><span class="line">topk(10, http_requests_total)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Gauge"><a href="#Gauge" class="headerlink" title="Gauge"></a>Gauge</h3><p>Gauge，可以任意变化的仪表盘。</p><p>Gauge类型代表一个样本数据可以任意变化，即可增可减。通常用于像温度、内存使用率这种指标数据，也可表示能随时升降的计数（如当前的并发数）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 获取一段时间内的变化情况</span><br><span class="line">dalta(cpu_temp_celsius&#123;host=&quot;zeus&quot;&#125;[2h])</span><br><span class="line"></span><br><span class="line"># 简单线性回归，预测未来数据</span><br><span class="line">predict_linear(node_filesystem_free&#123;job=&quot;node&quot;&#125;[2h], 4 * 3600) &lt; 0</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h3><p>Histogram和Summary主用用于统计和分析样本的分布情况。</p><p>Histogram(直方图)在一段时间范围内对数据进行采样（通常是请求持续时间(request durations)和响应大小(response sizes)等），并将其计入可配置的存储桶(bucket)中，后续可通过指定区间筛选样本，也可以统计样本总数，最后一般将数据展示为直方图。</p><p>Histogram类型的样本会提供三种指标：</p><ul><li>样本值分布在桶中的数量，命名为<code>xxx_bucket{le=&quot;&lt;上边界&gt;&quot;}</code>。标识指标值小于等于上边界所有样本数量。</li><li>所有样本值的大小总和，命名为<code>xxx_sum</code>。</li><li>样本总数，命名为<code>xxx_count</code>，值和<code>xxx_bucket{le=&quot;+Inf}</code>相同。</li></ul><p>可使用<code>histogram_quantile()</code>函数来计算Histogram类型样本的分位数。</p><p><br><br><br></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Summary(摘要)与Histogram类似，表示一段时间内的数据采集结果（通常是请求持续时间或响应大小）。它直接存储了分位数，而不是通过区间来计算。</p><p>Summary类型的样本也提供了三种指标：</p><ul><li>样本值的分位数分布情况，命名为<code>xxx{quantile=&quot;&lt;φ&gt;&quot;}</code>。</li><li>所有样本值的大小总和，命名为<code>xxx_sum</code>。</li><li>样本总数，命名为<code>xxx_count</code>。</li></ul><p><br><br><br><br><br></p><h2 id="作业和实例"><a href="#作业和实例" class="headerlink" title="作业和实例"></a>作业和实例</h2><p>Job and Instance</p><p>Prometheus配置文件中配置。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h1><p><br></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>GETTING STARTED</p><p>本节介绍如何安装，配置，使用Prometheus的简单例子。你将在本地安装和运行Prometheus，将其配置为自我填充和示例应用程序，然后使用查询，规则和图表来使用收集的序列数据。</p><p><br></p><p><strong>下载</strong></p><p>下载地址: <a href="https://prometheus.io/download/" target="_blank" rel="noopener">https://prometheus.io/download/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xvfz prometheus-*.tar.gz</span><br><span class="line"></span><br><span class="line">cd prometheus-*</span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置和监控</strong><br>Prometheus通过在目标上通过HTTP endPoints来抓取指标，来收集受监控目标的指标。由于Prometheus也以相同的方式公开自身数据，它也可以获取和监测自身的健康状况。<br>虽然Prometheus Server只收集有关自身的数据在实践中不是很有用，但它是一个很好的示例。如<code>prometheus.yml</code>示例配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">15</span><span class="string">s</span> <span class="comment"># By default, scrape targets every 15 seconds.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Attach these labels to any time series or alerts when communicating with</span></span><br><span class="line">  <span class="comment"># external systems (federation, remote storage, Alertmanager).</span></span><br><span class="line"><span class="attr">  external_labels:</span></span><br><span class="line"><span class="attr">    monitor:</span> <span class="string">'codelab-monitor'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it's Prometheus itself.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Override the global default and scrape targets from this job every 5 seconds.</span></span><br><span class="line"><span class="attr">    scrape_interval:</span> <span class="number">5</span><span class="string">s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">['localhost:9090']</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>启动</strong><br>启动后，可访问9090端口查看状态。可访问<code>localhost:9090/metrics</code>查看有关自身的相关指标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd prometheus-2.3.2.linux-amd64</span><br><span class="line">./prometheus --config.file=&quot;prometheus.yml&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/Prometheus/9090.png" alt="9090"></p><p><br></p><p><strong>使用表达式浏览器</strong><br>让我们看一下Prometheus收集的一些数据。要使用Prometheus的内建表达式浏览器(expression browser)，请跳转到<code>http://localhost:9090/graph</code>并选择<code>Graph -&gt; Console</code>，在其中输入表达式。<br>绘制表达式图形同样在此操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#表达式</span><br><span class="line">prometheus_target_interval_length_seconds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#表达式</span><br><span class="line">prometheus_target_interval_length_seconds&#123;quantile=&quot;0.99&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#计算返回的时间序列数</span><br><span class="line">count(prometheus_target_interval_length_seconds)</span><br></pre></td></tr></table></figure><p><img src="/images/Prometheus/expression01.png" alt="表达式结果"></p><p><img src="/images/Prometheus/expression02.png" alt="表达式图形"></p><p><br></p><p><strong>启动简单的目标</strong><br>启动一些示例目标让Prometheus获取。<br>确保已安装Go表一起并设置了正常的GO PATH。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mkdir ./sample &amp;&amp; cd sample</span><br><span class="line"></span><br><span class="line">git clone https://github.com/prometheus/client_golang.git</span><br><span class="line">cd client_golang/examples/random</span><br><span class="line">go get -d</span><br><span class="line">go build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Start 3 example targets in separate terminals:</span><br><span class="line">./random -listen-address=:9091</span><br><span class="line">./random -listen-address=:9092</span><br><span class="line">./random -listen-address=:9093</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#访问</span><br><span class="line">http://localhost:9091/metrices</span><br><span class="line">http://localhost:9092/metrices</span><br><span class="line">http://localhost:9093/metrices</span><br></pre></td></tr></table></figure><p><br></p><p><strong>监控示例目标</strong><br>现在需要配置Prometheus来抓取目标。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span>       <span class="string">'example-random'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Override the global default and scrape targets from this job every 5 seconds.</span></span><br><span class="line"><span class="attr">    scrape_interval:</span> <span class="number">5</span><span class="string">s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">['localhost:8080',</span> <span class="string">'localhost:8081'</span><span class="string">]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          group:</span> <span class="string">'production'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">['localhost:8082']</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          group:</span> <span class="string">'canary'</span></span><br></pre></td></tr></table></figure><p>重启Prometheus，检测<code>rpc_durations_seconds</code> metric来验证。</p><p><br></p><p><strong>配置规则</strong><br>Configure rules for aggregating scraped data into new time series</p><p>聚合超过数千个时间序列的查询在计算<code>ad-hoc</code>时会变慢。为了提高效率，Prometheus允许你通过配置的规则将预录表达式预先记录到全新的持久时间序列中。</p><p>创建规则文件<code>prometheus.rules.yml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#job_service:rpc_durations_seconds_count:avg_rate5m</span><br><span class="line">groups:</span><br><span class="line">- name: example</span><br><span class="line">  rules:</span><br><span class="line">  - record: job_service:rpc_durations_seconds_count:avg_rate5m</span><br><span class="line">    expr: avg(rate(rpc_durations_seconds_count[5m])) by (job, service)</span><br></pre></td></tr></table></figure></p><p>要是Prometheus选择此新规则，需要修改Prometheus配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval:     15s # By default, scrape targets every 15 seconds.</span><br><span class="line">  evaluation_interval: 15s # Evaluate rules every 15 seconds.</span><br><span class="line"></span><br><span class="line">  # Attach these extra labels to all timeseries collected by this Prometheus instance.</span><br><span class="line">  external_labels:</span><br><span class="line">    monitor: &apos;codelab-monitor&apos;</span><br><span class="line"></span><br><span class="line">rule_files:</span><br><span class="line">  - &apos;prometheus.rules.yml&apos;</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &apos;prometheus&apos;</span><br><span class="line"></span><br><span class="line">    # Override the global default and scrape targets from this job every 5 seconds.</span><br><span class="line">    scrape_interval: 5s</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&apos;localhost:9090&apos;]</span><br><span class="line"></span><br><span class="line">  - job_name:       &apos;example-random&apos;</span><br><span class="line"></span><br><span class="line">    # Override the global default and scrape targets from this job every 5 seconds.</span><br><span class="line">    scrape_interval: 5s</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&apos;localhost:8091&apos;, &apos;localhost:8092&apos;]</span><br><span class="line">        labels:</span><br><span class="line">          group: &apos;production&apos;</span><br><span class="line"></span><br><span class="line">      - targets: [&apos;localhost:9093&apos;]</span><br><span class="line">        labels:</span><br><span class="line">          group: &apos;canary&apos;</span><br></pre></td></tr></table></figure><p>重启Prometheus，使用<code>job_service:rpc_durations_seconds_count:avg_rate5m</code> metric验证。</p><p><br><br><br></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><br></p><h3 id="使用预编译的二进制文件"><a href="#使用预编译的二进制文件" class="headerlink" title="使用预编译的二进制文件"></a>使用预编译的二进制文件</h3><p><br><br><br></p><h3 id="使用源码"><a href="#使用源码" class="headerlink" title="使用源码"></a>使用源码</h3><p><br><br><br></p><h3 id="使用Docker"><a href="#使用Docker" class="headerlink" title="使用Docker"></a>使用Docker</h3><p>所有的Prometheus服务都可以作为 Docker image 来使用。<br>Prometheus image 使用 volume 来存储实际的指标。对于生产部署，强烈建议使用 Data Volume Container 来升级数据的管理。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#bind-mount</span><br><span class="line">docker run -p 9090:9090 -v /tmp/prometheus.yml:/etc/prometheus.yml  prom/prometheus</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#volume</span><br><span class="line">docker run -p 9090:9090 -v /promethe-data  prom/prometheus  --config.file=/prometheus-data/prometheus.yml</span><br></pre></td></tr></table></figure><p><br></p><p><strong>自定义镜像</strong></p><p>Dockerfile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM prom/prometheus</span><br><span class="line">ADD prometheus.yml /etc/prometheus/</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure><p>构建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-prometheus .</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用配置管理系统"><a href="#使用配置管理系统" class="headerlink" title="使用配置管理系统"></a>使用配置管理系统</h3><ul><li>Ansible</li><li>Chef</li><li>Puppet</li><li>SaltStack</li></ul><p><br><br><br><br><br></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Configuration</p><p>Prometheus通过命令行标志(flag)和配置文件进行配置。使用<code>./prometheus -h</code>查看所有命令行标志。<br>Prometheus可在运行时重新加载配置。</p><p><br></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>configuration file: <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/" target="_blank" rel="noopener">https://prometheus.io/docs/prometheus/latest/configuration/configuration/</a></p><p>使用<code>--config.file</code>标志指定配置文件。配置文件使用<code>YAML</code>格式。</p><p>一个配置文件栗子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="comment"># How frequently to scrape targets by default.</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">scrape_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = 1m ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # How long until a scrape request times out.</span></span><br><span class="line"><span class="string">  [ scrape_timeout: &lt;duration&gt; | default = 10s ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # How frequently to evaluate rules.</span></span><br><span class="line"><span class="string">  [ evaluation_interval: &lt;duration&gt; | default = 1m ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  # The labels to add to any time series or alerts when communicating with</span></span><br><span class="line"><span class="string">  # external systems (federation, remote storage, Alertmanager).</span></span><br><span class="line"><span class="string"></span><span class="attr">  external_labels:</span></span><br><span class="line">    <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Rule files specifies a list of globs. Rules and alerts are read from</span></span><br><span class="line"><span class="comment"># all matching files.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;filepath_glob&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A list of scrape configurations.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;scrape_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alerting specifies settings related to the Alertmanager.</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line"><span class="attr">  alert_relabel_configs:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="attr">  alertmanagers:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;alertmanager_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings related to the remote write feature.</span></span><br><span class="line"><span class="attr">remote_write:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;remote_write&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings related to the remote read feature.</span></span><br><span class="line"><span class="attr">remote_read:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;remote_read&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p><br></p><p>各个配置项，详细详细请看文档: <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/" target="_blank" rel="noopener">https://prometheus.io/docs/prometheus/latest/configuration/configuration/</a></p><ul><li><code>scrape_config</code></li><li><code>tls_config</code></li><li><code>azure_sd_config</code></li><li><code>consul_sd_config</code></li><li><code>dns_sd_config</code></li><li><code>ec2_sd_config</code></li><li><code>openstack_sd_config</code></li><li><code>file_sd_config</code></li><li><code>gce_sd_config</code></li><li><code>kubernetes_sd_config</code></li><li><code>marathon_sd_config</code></li><li><code>nerve_sd_config</code></li><li><code>serverset_sd_config</code></li><li><code>triton_sd_config</code></li><li><code>static_config</code></li><li><code>relabel_config</code></li><li><code>metric_relabel_configs</code></li><li><code>alert_relabel_configs</code></li><li><code>alertmanager_config</code></li><li><code>remote_write</code></li><li><code>remote_read</code></li></ul><p><br><br><br><br><br></p><h3 id="记录规则"><a href="#记录规则" class="headerlink" title="记录规则"></a>记录规则</h3><p>Recording rules</p><p><br></p><h4 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h4><p>Configuring rules</p><p>Prometheus支持两种类型的可被配置的以规定的间隔进行评估的规则:</p><ul><li>recording rules</li><li>alterting rules</li></ul><p>要在Prometheus中包含规则，创建包含必要规则的语句并在Prometheus配置文件中通过<code>rule_files</code>字段配置并加载文件。规则使用YAML格式。</p><p>规则文件可在Prometheus运行通过发送<code>SIGHUP</code>到Prometheus来进行重载。只有在所有规则文件都是正确格式下才会应用更改。</p><p><br><br><br></p><h4 id="语法检查规则"><a href="#语法检查规则" class="headerlink" title="语法检查规则"></a>语法检查规则</h4><p>Syntax-checking rules</p><p>要快速检查规则文件的语法是否正确，而无需启动Prometheus Server，可安装和运行Prometheus的<code>promtool</code>命令行工具:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/prometheus/prometheus/cmd/promtool</span><br><span class="line"></span><br><span class="line">promtool check rules /path/to/example.rules.yml</span><br></pre></td></tr></table></figure><p>如果规则文件语法正确，会返回<code>0</code>状态码。如果语法错误，会返回错误信息和<code>1</code>状态码。</p><p><br><br><br></p><h4 id="记录规则-1"><a href="#记录规则-1" class="headerlink" title="记录规则"></a>记录规则</h4><p>Recording rules</p><p>记录规则允许你预先计算经常需要或计算昂贵的表达式并保存它们的结果到一个新的时序集(set of time series)。查询预先计算的结果会比每次执行原始表达式快得多。这对Dashboard来说尤其有用，它经常刷新时间反复查询同样的表达式。</p><p>记录和告警规则位于一个规则组(rule group)。一个组内的规则在一个规定的间隔内依序运行。</p><p>规则文件语法:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;rule_group&gt;</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">groups:</span><br><span class="line">  - name: example</span><br><span class="line">    relues:</span><br><span class="line">    - record: job:http_inprogress_requests:sum</span><br><span class="line">      expr: sum(http_inprogress_requests) by (job)</span><br></pre></td></tr></table></figure><p><br></p><p><strong><rule_group></rule_group></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The name of the group. Must be unique within a file.</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># How often rules in the group are evaluated.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = global.evaluation_interval ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span><span class="attr">rules:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;rule&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong><rule></rule></strong></p><p>记录规则的语法:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The name of the time series to output to. Must be a valid metric name.</span></span><br><span class="line"><span class="attr">record:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The PromQL expression to evaluate. Every evaluation cycle this is</span></span><br><span class="line"><span class="comment"># evaluated at the current time, and the result recorded as a new set of</span></span><br><span class="line"><span class="comment"># time series with the metric name as given by 'record'.</span></span><br><span class="line"><span class="attr">expr:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Labels to add or overwrite before storing the result.</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;]</span></span><br></pre></td></tr></table></figure><p>告警规则的语法:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The name of the alert. Must be a valid metric name.</span></span><br><span class="line"><span class="attr">alert:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The PromQL expression to evaluate. Every evaluation cycle this is</span></span><br><span class="line"><span class="comment"># evaluated at the current time, and all resultant time series become</span></span><br><span class="line"><span class="comment"># pending/firing alerts.</span></span><br><span class="line"><span class="attr">expr:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alerts are considered firing once they have been returned for this long.</span></span><br><span class="line"><span class="comment"># Alerts which have not yet fired for long enough are considered pending.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">for:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = 0s ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Labels to add or overwrite for each alert.</span></span><br><span class="line"><span class="string"></span><span class="attr">labels:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;tmp_string&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Annotations to add to each alert.</span></span><br><span class="line"><span class="attr">annotations:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;tmpl_string&gt;</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="告警规则"><a href="#告警规则" class="headerlink" title="告警规则"></a>告警规则</h3><p>Alerting rules</p><p>告警规则允许你根据Prometheus表达式语言来定义告警条件，并发送提醒到外部服务。每当告警表达式在给定的时间内导致一个或多个矢量元素，告警计数主动作为这些元素的标签集。</p><p><br></p><h4 id="定义告警规则"><a href="#定义告警规则" class="headerlink" title="定义告警规则"></a>定义告警规则</h4><p>在Prometheus中，告警规则的配置与记录规则的配置一样。</p><p>栗子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">example</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - alerts:</span> <span class="string">HighRequestLatency</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="attr">job:request_latency_seconds:mean5m&#123;job="myjob"&#125;</span> <span class="string">&gt; 0.5</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">10</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">page</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">High</span> <span class="string">request</span> <span class="string">latency</span></span><br></pre></td></tr></table></figure><p>可选的<code>for</code>子句导致Prometheus等待在第一次遇到一个新的表达式输出矢量元素和计数的告警作为点燃的此元素的一定持续时间。在这个栗子中，Prometheus将检查在点燃告警之前的每个10分钟的警告持续激活。元素是活跃的，但未点燃，出于待定(pending)状态。</p><p><code>labels</code>子句允许指定一组附加标签到告警。任何目前有冲突的标签将被覆盖。标签的值可以作为模板。</p><p><code>annotations</code>子句指定的一组信息可用来存储更长的附加信息。注释的值可以作为模板。</p><p><br><br><br></p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>Templating</p><p>标签和注释的值可以使用<code>console template</code>作为模板。<code>$labels</code>变量保存一个告警实例的k/v键值对。已配置的外部标签可通过<code>$externalLabels</code>变量进行访问。<code>$value</code>变量保存告警实例的评估值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To insert a firing element's label values:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">$labels.&lt;labelname&gt;</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To insert the numeric expression value of the firing element:</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">$value</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>栗子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">example</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Alert for any instance that is unreachable for &gt;5 minutes.</span></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">InstanceDown</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">up</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    for:</span> <span class="number">5</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">page</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"Instance <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> down"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> of job <span class="template-variable">&#123;&#123; $labels.job &#125;&#125;</span> has been down for more than 5 minutes."</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Alert for any instance that has a median request latency &gt;1s.</span></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">APIHighRequestLatency</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">api_http_request_latencies_second&#123;quantile="0.5"&#125;</span> <span class="string">&gt; 1</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">10</span><span class="string">m</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"High request latency on <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> has a median request latency above 1s (current value: <span class="template-variable">&#123;&#123; $value &#125;&#125;</span>)s"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="运行时检查告警"><a href="#运行时检查告警" class="headerlink" title="运行时检查告警"></a>运行时检查告警</h4><p>Inspecting alerts during runtime</p><p>要手动检查告警是否活跃(active)(pending或firing)，请浏览原生Prometheus的Alerts栏目项。这里将确切地显示标签集，每个定义的告警当前的状态。</p><p><img src="/images/Prometheus/alerts_state.png" alt></p><p>对于<code>pengding</code>和<code>firing</code>的告警，Prometheus还存储合成<code>ALERTS{alertname=&quot;&lt;alert name&gt;&quot;, alertstate=&quot;pending|firing&quot;, &lt;additional alert labels&gt;}</code>形式的时间序列。只要该警告是在所指示的active(pending或firing)状态，样本值被设置为1。当不再是这样时，该系列被标记为stale。</p><p><br><br><br></p><h4 id="发送告警通知"><a href="#发送告警通知" class="headerlink" title="发送告警通知"></a>发送告警通知</h4><p>Sending alert notifications</p><p>Prometheus的告警规则善于盘算现在什么坏了(broken)，但是它不是一个成熟的通知解决方案。需要另一层添加汇总，通知速率限制，沉默和告警依赖于简单告警定义。在Prometheus的生态系统中，<strong>Alertmanager</strong>承担了这一角色。因此，Prometheus可以配置成定期发送关于告警状态信息到Alertmanager实例，然后采取调度权发送通知。<br>Prometheus通过集成服务发现，可配置为自动发现可用的Alertmanager实例。</p><p><br><br><br></p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><p>Template example</p><p>Prometheus在alerts的annotations和labels中支持模板化，以及在控制台页面。模板要针对本地数据库运行查询、迭代数据，使用条件、格式数据等能力。Prometheus模板语言是基于Go template system。</p><p><br></p><h4 id="简单告警字段模板"><a href="#简单告警字段模板" class="headerlink" title="简单告警字段模板"></a>简单告警字段模板</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">alert:</span> <span class="string">InstanceDown</span></span><br><span class="line"><span class="attr">expr:</span> <span class="string">up</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line"><span class="attr">for:</span> <span class="number">5</span><span class="string">m</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="attr">  severity:</span> <span class="string">page</span></span><br><span class="line"><span class="attr">annotations:</span></span><br><span class="line"><span class="attr">  summary:</span> <span class="string">"Instance <span class="template-variable">&#123;&#123;$labels.instance&#125;&#125;</span> down"</span></span><br><span class="line"><span class="attr">  description:</span> <span class="string">"<span class="template-variable">&#123;&#123;$labels.instance&#125;&#125;</span> of job <span class="template-variable">&#123;&#123;$labels.job&#125;&#125;</span> has been down for more than 5 minutes."</span></span><br></pre></td></tr></table></figure><p>告警字段模板为每个点燃的告警在每一个规则迭代过程中执行，所以保持任意查询和模板的轻量化。如果你需要为告警编写更复杂的模板，建议链接到控制台。</p><p><br><br><br></p><h4 id="简单迭代"><a href="#简单迭代" class="headerlink" title="简单迭代"></a>简单迭代</h4><p>simple iteration</p><p>这显示的实例列表，以及它们是否up:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;&#123;</span> <span class="string">range</span> <span class="string">query</span> <span class="string">"up"</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;</span> <span class="string">.Labels.instance</span> <span class="string">&#125;&#125;</span> <span class="string">&#123;&#123;</span> <span class="string">.Value</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>特殊的<code>.</code>变量包含对于每次循环迭代当前样本的值。</p><p><br><br><br></p><h4 id="展示一个值"><a href="#展示一个值" class="headerlink" title="展示一个值"></a>展示一个值</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;&#123;</span> <span class="string">with</span> <span class="string">query</span> <span class="string">"some_metric&#123;instance='someinstance'&#125;"</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">&#123;&#123;</span> <span class="string">.</span> <span class="string">| first | value | humanize &#125;</span></span><br><span class="line"><span class="string"><span class="template-variable">&#123;&#123; end &#125;&#125;</span></span></span><br></pre></td></tr></table></figure><p>Go和Go的模板语言两者都是强类型，因此必须检查阳平返回，以避免执行错误。<br>这里所包含的<code>prom_query_drilldown</code>模板处理，允许结果的格式，并链接到表达式浏览器。</p><p><br><br><br></p><h4 id="使用控制台url参数"><a href="#使用控制台url参数" class="headerlink" title="使用控制台url参数"></a>使用控制台url参数</h4><p>Using console URL parameters</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;&#123;</span> <span class="string">with</span> <span class="string">printf</span> <span class="string">"node_memory_MemTotal&#123;job='node', instance='%s'&#125;"</span> <span class="string">.Params.instance</span> <span class="string">| query&#125;&#125;</span></span><br><span class="line"><span class="string">  <span class="template-variable">&#123;&#123; . | first | value | humanize1024 &#125;&#125;</span>B</span></span><br><span class="line"><span class="string"><span class="template-variable">&#123;&#123; end &#125;&#125;</span></span></span><br></pre></td></tr></table></figure><p>如果作为<code>console.html?instance=hostname</code>访问, <code>.Params.instance</code>将评估<code>hostname</code>。</p><p><br><br><br></p><h4 id="高级的迭代"><a href="#高级的迭代" class="headerlink" title="高级的迭代"></a>高级的迭代</h4><p>Advanced iteration</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;table&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">range</span> <span class="string">printf</span> <span class="string">"node_network_receive_bytes&#123;job='node',instance='%s',device!='lo'&#125;"</span> <span class="string">.Params.instance</span> <span class="string">| query | sortByLabel "device"&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;tr&gt;&lt;th colspan=2&gt;<span class="template-variable">&#123;&#123; .Labels.device &#125;&#125;</span>&lt;/th&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="string">&lt;tr&gt;</span></span><br><span class="line"><span class="string">  &lt;td&gt;Received&lt;/td&gt;</span></span><br><span class="line"><span class="string">  &lt;td&gt;<span class="template-variable">&#123;&#123; with printf "rate(node_network_receive_bytes&#123;job='node',instance='%s',device='%s'&#125;[5m])" .Labels.instance .Labels.device | query &#125;&#125;</span><span class="template-variable">&#123;&#123; . | first | value | humanize &#125;&#125;</span>B/s<span class="template-variable">&#123;&#123;end&#125;&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">&lt;/tr&gt;</span></span><br><span class="line"><span class="string">&lt;tr&gt;</span></span><br><span class="line"><span class="string">  &lt;td&gt;Transmitted&lt;/td&gt;</span></span><br><span class="line"><span class="string">  &lt;td&gt;<span class="template-variable">&#123;&#123; with printf "rate(node_network_transmit_bytes&#123;job='node',instance='%s',device='%s'&#125;[5m])" .Labels.instance .Labels.device | query &#125;&#125;</span><span class="template-variable">&#123;&#123; . | first | value | humanize &#125;&#125;</span>B/s<span class="template-variable">&#123;&#123;end&#125;&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">  &lt;/tr&gt;<span class="template-variable">&#123;&#123; end &#125;&#125;</span></span></span><br><span class="line"><span class="string">&lt;/table&gt;</span></span><br></pre></td></tr></table></figure><p>这里，我们迭代了所有网络设备，并显示每个设备的网络流量。随着<code>range</code>动作不指定变量，<code>.Params.instance</code>循环内不可用，<code>.</code>现在是作为循环变量。</p><p><br><br><br></p><h4 id="定义可重复使用的模板"><a href="#定义可重复使用的模板" class="headerlink" title="定义可重复使用的模板"></a>定义可重复使用的模板</h4><p>Defining reusable templates</p><p>Prometheus支持定义可重复使用的模板。当与控制台库相结合时，使得可共享模板，这很有用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;&#123;</span> <span class="string">/*</span> <span class="string">Define</span> <span class="string">the</span> <span class="string">template</span> <span class="string">*/</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;define</span> <span class="string">"myTemplate"</span><span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">do</span> <span class="string">something</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#123;&#123;/*</span> <span class="string">Use</span> <span class="string">the</span> <span class="string">template</span> <span class="string">*/&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;template</span> <span class="string">"myTemplate"</span><span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>模板仅限于一个参数。<code>args</code>函数可包装多个参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;&#123;define</span> <span class="string">"myMultiArgTemplate"</span><span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="string">First</span> <span class="attr">argument:</span> <span class="string">&#123;&#123;.arg0&#125;&#125;</span></span><br><span class="line">  <span class="string">Second</span> <span class="attr">argument:</span> <span class="string">&#123;&#123;.arg1&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">end</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">template</span> <span class="string">"myMultiArgTemplate"</span> <span class="string">(args</span> <span class="number">1</span> <span class="number">2</span><span class="string">)&#125;&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h3><p>TEMPLATE REFERENCE</p><p><br></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>Data Structures</p><p>用于处理时间序列数据的主要数据结构栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type sample struct &#123;</span><br><span class="line">    Labels map[string]string</span><br><span class="line">    Value float64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栗子的指标名称(metric)编码在<code>Labels</code>map的特殊的<code>__name__</code>标签里。<br><code>[]sample</code>表示实例列表。<br>Go中的<code>interface{}</code>与C中的void pointer类似。</p><p><br><br><br></p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>除了Go模板提供的默认函数，Prometheus为模板查询结果提供了更易处理的函数。<br>如果函数在管道中使用，管道值将作为最后一个参数传递。</p><p><strong>Queries</strong></p><p><br></p><p><strong>Numbers</strong></p><p><br></p><p><strong>Strings</strong></p><p><br></p><p><strong>Others</strong></p><p><br><br><br></p><h4 id="模板类型差异"><a href="#模板类型差异" class="headerlink" title="模板类型差异"></a>模板类型差异</h4><p>Template type differences</p><p>每种类型的模板提供了可用于参数模板的不同信息，并有一些其它差异。</p><p><br><br><br></p><h3 id="规则单元测试"><a href="#规则单元测试" class="headerlink" title="规则单元测试"></a>规则单元测试</h3><p>Unit Testing for Rules</p><p>你可使用<code>promtool</code>来测试你的规则。</p><p><br><br><br><br><br></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>Querying</p><p><br></p><h3 id="查询Prometheus"><a href="#查询Prometheus" class="headerlink" title="查询Prometheus"></a>查询Prometheus</h3><p>Prometheus提供了一个名为<code>PromQL</code>(Prometheus Query Language)功能化查询语言，让用户选择并实时汇总时间序列数据。表达式的结果可被显示为图形，可在Prometheus浏览器上查看，或通过HTTP API来获取。</p><p><br></p><h4 id="表达式语言数据类型"><a href="#表达式语言数据类型" class="headerlink" title="表达式语言数据类型"></a>表达式语言数据类型</h4><p>Expression language data types</p><p>在Prometheus表达式语言中，一个表达式或子表达式可以评估为四种类型中的一种:</p><ul><li><strong>瞬时向量(Instant vector)</strong>: 包含每个时间序列的单个样品的一组时间序列，全部共享相同的时间戳</li><li><strong>区间向量(Range vector)</strong>: 包含随时间序列的范围的数据点的一组时间序列</li><li><strong>标量(Scalar)</strong>: 一个简单的数字浮点值</li><li><strong>字符串(String)</strong>: 一个简单的字符串值，当前未使用</li></ul><p>根据不同的使用情况(graphing, displaying the output of an expression)，例如：瞬时向量表达式返回的数据类型是唯一可以直接绘制成图表的数据类型。</p><p><br><br><br></p><h4 id="Literals"><a href="#Literals" class="headerlink" title="Literals"></a>Literals</h4><p><strong>String literals</strong></p><p>字符串可以被指定为在单引号、双引号或反引号内的文字。</p><p>PromQL遵循Go的转义规则。<br>不像Go，Prometheus不丢弃反引号里面的换行符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;this is a string&quot;</span><br><span class="line">&apos;these are unescaped: \n \\ \t&apos;</span><br><span class="line">`these are not unescaped: \n &apos; &quot; \t`&quot;&apos;`</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Float literals</strong></p><p>标量浮点值可被逐字地写为<code>[-](digits)[.(digits)]</code>数字形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-2.43</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="时序选择器"><a href="#时序选择器" class="headerlink" title="时序选择器"></a>时序选择器</h4><p>Time series Selectors</p><p>Prometheus中的所有正则表达式使用<a href="https://github.com/google/re2/wiki/Syntax" target="_blank" rel="noopener">RE2 syntax</a>。</p><p><br></p><p><strong>Instant vector selectors</strong></p><p>Instant vector selectors允许一组时间序列并为每个在给定的时间戳单一样品值的选择: 在最简单的格式中，只制定了一个指标名称。这导致了包含有该指标名称的所有时间序列的元素instant vector。</p><p>这个栗子将选择具有<code>http_requests_total</code>指标名称的所有时间序列:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total</span><br></pre></td></tr></table></figure><p>有可能通过附加一组标签在大括号来匹配进一步过滤这些时间序列。</p><p>这个栗子只选择<code>job label为</code>prometheus<code>和group lable为</code>canary的<code>http_requests_total</code>指标名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=&quot;prometheus&quot;, group=&quot;canary&quot;&#125;</span><br></pre></td></tr></table></figure><p>也可将标签值负匹配，或匹配正则表达式。下面的标签匹配操作符存在:</p><ul><li><code>=</code>: 等于;</li><li><code>!=</code> 不等于;</li><li><code>=~</code>: 正则匹配;</li><li><code>!~</code>: 非正则匹配.</li></ul><p>举个栗子，以下匹配<code>staging</code>, <code>testing</code>, <code>development</code>环境变量和<code>GET</code>以外的HTTP方法的<code>http_requests_total</code>指标名称的所有时序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;environment=~&quot;staging|testing|development&quot;, method!=&quot;GET&quot;&#125;</span><br></pre></td></tr></table></figure><p>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;job=~&quot;.*&quot;&#125; # Bad!</span><br><span class="line"></span><br><span class="line">&#123;job=~&quot;.+&quot;&#125;              # Good!</span><br><span class="line">&#123;job=~&quot;.*&quot;,method=&quot;get&quot;&#125; # Good!</span><br><span class="line"></span><br><span class="line">&#123;__name__=~&quot;job:.*&quot;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Range Vector Selectors</strong></p><p>Range vector literals与 instant vector literals类似，不同之处在于它选择了一个范围。时间序列放在方括号<code>[]</code>内。</p><p>时间范围被指定为一个数字，使用以下单位:</p><ul><li><code>s</code>: 秒;</li><li><code>m</code>: 分;</li><li><code>h</code>: 时;</li><li><code>d</code>: 天;</li><li><code>w</code>: 周;</li><li><code>y</code>: 年。</li></ul><p>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=&quot;prometheus&quot;&#125;[5m]</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Offset modifier</strong></p><p><code>offset</code>修饰符允许为查询中的individual instant和range vectors改变时间偏移。</p><p>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total offset 5m</span><br><span class="line"></span><br><span class="line">sum(http_requests_total&#123;method=&quot;GET&quot;&#125; offset 5m) // GOOD.</span><br><span class="line"></span><br><span class="line">sum(http_requests_total&#123;method=&quot;GET&quot;&#125;) offset 5m // INVALID.</span><br><span class="line"></span><br><span class="line">rate(http_requests_total[5m] offset 1w)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>Subquery</p><p>子查询允许你为一个给定的range和resolution运行一个即时查询(instant)。子查询的结果为range vector。</p><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># resolution可选。Default is the global evaluation interval.</span><br><span class="line">Syntax: &lt;instant_query&gt; &apos;[&apos; &lt;range&gt; &apos;:&apos; [&lt;resolution&gt;] &apos;]&apos; [ offset &lt;duration&gt; ]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>Operators: <a href="https://prometheus.io/docs/prometheus/latest/querying/operators/" target="_blank" rel="noopener">https://prometheus.io/docs/prometheus/latest/querying/operators/</a></p><p><br></p><h4 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h4><p>Binary Operators</p><p>Prometheus查询语言支持基本的逻辑和算数运算符。</p><p><br></p><p><strong>Arithmetic binary operators</strong></p><p>Prometheus中存在以下二元算术运算符:</p><ul><li><code>+</code> (addition)</li><li><code>-</code> (subtraction)</li><li><code>*</code> (multiplication)</li><li><code>/</code> (division)</li><li><code>%</code> (modulo)</li><li><code>^</code> (power/exponentiation)</li></ul><p>二元运算符在下列之间定义:</p><ul><li>scalar/scalar</li><li>vector/scalar</li><li>vector/vector</li></ul><p><br></p><p><strong>Comparison binary operators</strong></p><p>Prometheus中有以下二元比较符:</p><ul><li><code>==</code> (equal)</li><li><code>!=</code> (not-equal)</li><li><code>&gt;</code> (greater-than)</li><li><code>&lt;</code> (less-than)</li><li><code>&gt;=</code> (greater-or-equal)</li><li><code>&lt;=</code> (less-or-equal)</li></ul><p>比较运算符在下列之间定义，默认情况下进行筛选。它们的行为可由运算符之后提供的<code>bool</code>进行修改，这将返回<code>0</code>或<code>1</code>而不是过滤。</p><ul><li>scalar/scalar</li><li>vector/scalar</li><li>vector/vector</li></ul><p><br></p><p><strong>Logical/set binary operators</strong></p><p>logical/set 二元运算符尽在instan vectors之间定义:</p><ul><li><code>and</code> (intersection)</li><li><code>or</code> (union)</li><li><code>unless</code> (complement)</li></ul><p><br><br><br></p><h4 id="矢量匹配"><a href="#矢量匹配" class="headerlink" title="矢量匹配"></a>矢量匹配</h4><p>Vector matching</p><p>矢量之间的操作试图找到为左手侧的每个条目匹配右手侧的元素。有两种基本类型匹配的行为: One-to-one 和 many-to-one/one-to-many。</p><p><br></p><p><strong>One-to-one vector matches</strong></p><p>一对一从操作的每一侧查找唯一的一对条目。在默认情况下，操作遵循如下格式<code>vector1 &lt;operator&gt; vector2</code>。如果它们有完全相同的一组标签和相应的值，则两个条目匹配。<code>ignoring</code>关键字允许匹配忽略某些标签，<code>on</code>关键字允许降低考虑的标签集来提供列表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) &lt;vector expr&gt;</span><br></pre></td></tr></table></figure><p>输入案例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m&#123;method=&quot;get&quot;, code=&quot;500&quot;&#125;  24</span><br><span class="line">method_code:http_errors:rate5m&#123;method=&quot;get&quot;, code=&quot;404&quot;&#125;  30</span><br><span class="line">method_code:http_errors:rate5m&#123;method=&quot;put&quot;, code=&quot;501&quot;&#125;  3</span><br><span class="line">method_code:http_errors:rate5m&#123;method=&quot;post&quot;, code=&quot;500&quot;&#125; 6</span><br><span class="line">method_code:http_errors:rate5m&#123;method=&quot;post&quot;, code=&quot;404&quot;&#125; 21</span><br><span class="line"></span><br><span class="line">method:http_requests:rate5m&#123;method=&quot;get&quot;&#125;  600</span><br><span class="line">method:http_requests:rate5m&#123;method=&quot;del&quot;&#125;  34</span><br><span class="line">method:http_requests:rate5m&#123;method=&quot;post&quot;&#125; 120</span><br></pre></td></tr></table></figure><p>查询栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m&#123;code=&quot;500&quot;&#125; / ignoring(code) method:http_requests:rate5m</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Many-to-one and one-to-many vector matches</strong></p><p>多对一或一对多匹配指的是一侧能够匹配多侧的多个元素。这明确要求必须使用<code>group_left</code>或<code>group_right</code>修饰符，其中左/右确定该矢量有更高的基数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span><br></pre></td></tr></table></figure><p>查询案例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m / ignoring(code) group_left method:http_request:rate5m</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;method=&quot;get&quot;, code=&quot;500&quot;&#125;  0.04            //  24 / 600</span><br><span class="line">&#123;method=&quot;get&quot;, code=&quot;404&quot;&#125;  0.05            //  30 / 600</span><br><span class="line">&#123;method=&quot;post&quot;, code=&quot;500&quot;&#125; 0.05            //   6 / 120</span><br><span class="line">&#123;method=&quot;post&quot;, code=&quot;404&quot;&#125; 0.175           //  21 / 120</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="聚合运算符"><a href="#聚合运算符" class="headerlink" title="聚合运算符"></a>聚合运算符</h4><p>Aggregation operators</p><p>Prometheus支持以下内置聚合运算符，可以用于聚合单一瞬间向量的元素:</p><ul><li><code>sum</code> (calculate sum over dimensions)</li><li><code>min</code> (select minimum over dimensions)</li><li><code>max</code> (select maximum over dimensions)</li><li><code>avg</code> (calculate the average over dimensions)</li><li><code>stddev</code> (calculate population standard deviation over dimensions)</li><li><code>stdvar</code> (calculate population standard variance over dimensions)</li><li><code>count</code> (count number of elements in the vector)</li><li><code>count_values</code> (count number of elements with the same value)</li><li><code>bottomk</code> (smallest k elements by sample value)</li><li><code>topk</code> (largest k elements by sample value)</li><li><code>quantile</code> (calculate φ-quantile (<code>0 ≤ φ ≤ 1</code>) over dimensions)</li></ul><p>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;aggr-op&gt; [without|by (&lt;label list&gt;)] ([parameter,] &lt;vector expression&gt;)</span><br><span class="line"></span><br><span class="line">&lt;aggr-op&gt;([parameter,] &lt;vector expression&gt;) [without|by (&lt;label list&gt;)]</span><br><span class="line"></span><br><span class="line">sum without (instance) (http_requests_total)</span><br><span class="line"></span><br><span class="line">sum by (application, group) (http_requests_total)</span><br><span class="line"></span><br><span class="line">count_values(&quot;version&quot;, build_version)</span><br><span class="line"></span><br><span class="line">topk(5, http_requests_total)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="二元运算符优先级"><a href="#二元运算符优先级" class="headerlink" title="二元运算符优先级"></a>二元运算符优先级</h4><p>Binary operator precedence</p><p>以下优先级由高到低:</p><ul><li><code>^</code></li><li><code>*</code>, <code>/</code>, <code>%</code></li><li><code>+</code>, <code>-</code></li><li><code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code></li><li><code>and</code>, <code>unless</code></li><li><code>or</code></li></ul><p><br><br><br></p><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>Founctions: <a href="https://prometheus.io/docs/prometheus/latest/querying/functions/" target="_blank" rel="noopener">https://prometheus.io/docs/prometheus/latest/querying/functions/</a></p><p>一些函数有默认的参数，如<code>year(v=vector(time()) instant-vector)</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">abs()</span><br><span class="line">abs(v instant-vector) 返回输入向量的所有样本的绝对值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">absent()</span><br><span class="line">absent(v instant-vector)，判断是否存在</span><br><span class="line"></span><br><span class="line">absent(nonexistent&#123;job=&quot;myjob&quot;&#125;)</span><br><span class="line"># =&gt; &#123;job=&quot;myjob&quot;&#125;</span><br><span class="line"></span><br><span class="line">absent(nonexistent&#123;job=&quot;myjob&quot;,instance=~&quot;.*&quot;&#125;)</span><br><span class="line"># =&gt; &#123;job=&quot;myjob&quot;&#125;</span><br><span class="line"></span><br><span class="line">absent(sum(nonexistent&#123;job=&quot;myjob&quot;&#125;))</span><br><span class="line"># =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ceil()</span><br><span class="line">ceil(v instant-vector) 将v中所有元素的样本值向上四舍五入到最接近的整数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">floor()</span><br><span class="line">floor(v instant-vector) 与ceil()相反，将v中所有元素的样本值向下四舍五入到最接近的整数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">changes()</span><br><span class="line">changes(v range-vector) 输入一个区间向量，返回这个区间向量内每个样本数据值变化的次数（瞬时向量）。如果样本数据值没有发生变化，则返回结果为1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clamp_max()</span><br><span class="line">clamp_max(v instant-vector, max scalar) 输入一个瞬时向量和最大值，样本数据值若大于max，则改为max，否则不变</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clamp_min()</span><br><span class="line">clamp_min(v instant-vector, min scalar) 输入一个瞬时向量和最小值，样本数据值若小于min，则改为min，否则不变</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">day_of_month()</span><br><span class="line">day_of_month(v=vector(time()) instant-vector) 值范围为1-31</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">day_of_week()</span><br><span class="line">day_of_week(v=vector(time()) instant-vector) 值范围为0-6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">days_in_month()</span><br><span class="line">days_in_month(v=vector(time()) instant-vector) 月份的天数，值范围为28-31</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">minute()</span><br><span class="line">minute(v=vector(time()) instant-vector) 函数返回给定UTC时间当前小时的第多少分钟，范围为0-59</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">month()</span><br><span class="line">month(v=vector(time()) instant-vector) 函数返回给定UTC时间当前属于第几个月，范围为1-12</span><br><span class="line"></span><br><span class="line">year()</span><br><span class="line">year(v=vector(time()) instant-vector) 返回被给定 UTC 时间的当前年份</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hour()</span><br><span class="line">hour(v=vector(time()) instant-vector) 值范围为0-23</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delta()</span><br><span class="line">delta(v range-vector) 它计算一个区间向量v的第一个元素和最后一个元素之间的差值，返回一个瞬时向量</span><br><span class="line">delta(cpu_temp_celsius&#123;host=&quot;zeus&quot;&#125;[2h]) # 现在和两小时前的CPU温度差</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">idelta()</span><br><span class="line">idelta(v range-vector) 计算最后两个样本之间的差</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deriv()</span><br><span class="line">deriv(v range-vector) 使用简单的线性回归计算区间向量v中各个时间序列的导数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exp()</span><br><span class="line">exp(v instant-vector) 输入一个瞬时向量，返回各个样本值的e的指数值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">histogram_quantile()</span><br><span class="line">histogram_quantile(φ float, b instant-vector)</span><br><span class="line">histogram_quantile(0.9, rate(http_request_duration_seconds_bucket[10m])) # 计算过去10分钟内请求持续在90%</span><br><span class="line">histogram_quantile(0.9, sum(rate(http_request_duration_seconds_bucket[10m])) by (job, le)) # 聚合</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">holt_winters()</span><br><span class="line">holt_winters(v range-vector, sf scalar, tf scalar) 基于区间向量v，生成时间序列数据平滑值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">increase()</span><br><span class="line">increase(v range-vector) 获取区间向量中的第一个和最后一个样本并返回其增长量</span><br><span class="line">increase(http_requests_total&#123;job=&quot;api-server&quot;&#125;[5m]) # 区间向量中每个时间序列过去5分钟内HTTP请求数的增长数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">label_join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">label_replace()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ln()</span><br><span class="line">ln(v instant-vector) 计算瞬时向量v中所有样本数据的自然对数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log2()</span><br><span class="line">log2(v instant-vector) 函数计算瞬时向量v中所有样本数据的二进制对数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log10()</span><br><span class="line">log10(v instant-vector) 计算瞬时向量v中所有样本数据的十进制对数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">predict_linear()</span><br><span class="line">predict_linear(v range-vector, t scalar) 函数可以预测时间序列v在t秒后的值</span><br><span class="line">predict_linear(node_filesystem_free&#123;job=&quot;node&quot;&#125;[2h], 4 * 3600) &lt; 0 # 基于2小时的样本数据，来预测主机可用磁盘空间的是否在4个小时候被占满</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rate()</span><br><span class="line">rate(v range-vector) 直接计算区间向量 v 在时间窗口内平均增长速率</span><br><span class="line">rate(http_requests_total[5m]) 区间向量中每个时间序列过去5分钟内HTTP请求数的每秒增长率</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">irate()</span><br><span class="line">irate(v range-vector) 用于计算区间向量的增长率，但是其反应出的是瞬时增长率。通过区间向量中最后两个两本数据来计算区间向量的增长速率。</span><br><span class="line">irate(http_requests_total&#123;job=&quot;api-server&quot;&#125;[5m]) # 区间向量中每个时间序列过去 5 分钟内最后两个样本数据的 HTTP 请求数的增长率</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resets()</span><br><span class="line">resets(v range-vector) 的参数是一个区间向量。对于每个时间序列，它都返回一个计数器重置的次数。两个连续样本之间的值的减少被认为是一次计数器重置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">round()</span><br><span class="line">round(v instant-vector, to_nearest=1 scalar) 与ceil和floor函数类似，返回向量中所有样本值的最接近的整数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scalar()</span><br><span class="line">scalar(v instant-vector) 函数的参数是一个单元素的瞬时向量,它返回其唯一的时间序列的值作为一个标量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sort()</span><br><span class="line">sort(v instant-vector) 函数对向量按元素的值进行升序排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sort_desc()</span><br><span class="line">降序排列</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sqrt()</span><br><span class="line">sqrt(v instant-vector) 计算向量v 所有元素的平方根</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector()</span><br><span class="line">vector(s scalar)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;aggregation&gt;_over_time()</span><br><span class="line">avg_over_time(range-vector) : 区间向量内每个度量指标的平均值。</span><br><span class="line">min_over_time(range-vector) : 区间向量内每个度量指标的最小值。</span><br><span class="line">max_over_time(range-vector) : 区间向量内每个度量指标的最大值。</span><br><span class="line">sum_over_time(range-vector) : 区间向量内每个度量指标的求和。</span><br><span class="line">count_over_time(range-vector) : 区间向量内每个度量指标的样本数据个数。</span><br><span class="line">quantile_over_time(scalar, range-vector) : 区间向量内每个度量指标的样本数据值分位数，φ-quantile (0 ≤ φ ≤ 1)。</span><br><span class="line">stddev_over_time(range-vector) : 区间向量内每个度量指标的总体标准差。</span><br><span class="line">stdvar_over_time(range-vector) : 区间向量内每个度量指标的总体标准方差。</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="查询栗子"><a href="#查询栗子" class="headerlink" title="查询栗子"></a>查询栗子</h3><p>Query examples: <a href="https://prometheus.io/docs/prometheus/latest/querying/examples/" target="_blank" rel="noopener">https://prometheus.io/docs/prometheus/latest/querying/examples/</a></p><p><br></p><h4 id="简单时序选择"><a href="#简单时序选择" class="headerlink" title="简单时序选择"></a>简单时序选择</h4><p>返回指标<code>http_requests_total</code>的所有时间序列数据:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total</span><br></pre></td></tr></table></figure><p>返回指标名为<code>http_requests_total</code>，给定标签job和handler:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=&quot;apiserver&quot;, handler=&quot;/api/comments&quot;&#125;</span><br></pre></td></tr></table></figure><p>加上时间，5分钟内:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=&quot;apiserver&quot;, handler=&quot;/api/comments&quot;&#125;[5m]</span><br></pre></td></tr></table></figure><p>使用正则:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;job=~&quot;.*server&quot;&#125;</span><br></pre></td></tr></table></figure><p>http状态码不为4xx:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;status!~&quot;4..&quot;&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="子查询-1"><a href="#子查询-1" class="headerlink" title="子查询"></a>子查询</h4><p>Return the 5-minute rate of the http_requests_total metric for the past 30 minutes, with a resolution of 1 minute.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m])[30m:1m]</span><br></pre></td></tr></table></figure><p>嵌套子查询:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_over_time(deriv(rate(distance_covered_total[5s])[30s:5s])[10m:])</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用函数，运算符"><a href="#使用函数，运算符" class="headerlink" title="使用函数，运算符"></a>使用函数，运算符</h4><p>过去5分钟的平均值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m])</span><br></pre></td></tr></table></figure><p>过去5分钟平均值综合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum by (job) (</span><br><span class="line">  rate(http_requests_total[5m])</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果两个指标具有相同维度的标签，我们可以使用二元操作符计算样本数据:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(instance_memory_limit_bytes - instance_memory_usage_bytes) / 1024 / 1024</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 同样的表达式，只不过通过应用相加</span><br><span class="line">sum by (app, proc) (</span><br><span class="line">  instance_memory_limit_bytes - instance_memory_usage_bytes</span><br><span class="line">) / 1024 / 1024</span><br></pre></td></tr></table></figure><p>获取CPU使用最高的三个样本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topk(3, sum by (app, proc) (rate(instance_cpu_time_ns[5m])))</span><br></pre></td></tr></table></figure><p>假设一个服务实例只有一个时间序列数据，那么我们可以通过下面表达式统计出每个应用的实例数量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count(instance_cpu_time_ns) by (app)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="HTTP-API"><a href="#HTTP-API" class="headerlink" title="HTTP API"></a>HTTP API</h3><p>HTTP API: <a href="https://prometheus.io/docs/prometheus/latest/querying/api/" target="_blank" rel="noopener">https://prometheus.io/docs/prometheus/latest/querying/api/</a></p><p>目前稳定的HTTP API在Prometheus Server的<code>/api/v1</code>下。</p><p><br></p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>API响应格式为JSON。每个成功的请求都返回<code>2xx</code>状态码。</p><p>到达API处理程序无效的请求返回一个错误的JSON对象和以下状态码之一:</p><ul><li><code>400 Bad Request</code>: 当参数错误或者缺失</li><li><code>422 Unprocessable Entity</code>: 当表达式无法执行</li><li><code>503 Service Unavailable</code>:  当请求超时或者被中断时</li></ul><p>JSON响应包格式如下:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"success"</span> | <span class="string">"error"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: &lt;data&gt;,</span><br><span class="line"></span><br><span class="line">  // Only set if status is "error". The data field may still hold</span><br><span class="line">  // additional data.</span><br><span class="line">  "errorType": "&lt;string&gt;",</span><br><span class="line">  "error": "&lt;string&gt;",</span><br><span class="line"></span><br><span class="line">  // Only if there were warnings while executing the request.</span><br><span class="line">  // There will still be data in the data field.</span><br><span class="line">  "warnings": ["&lt;string&gt;"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求中输入的时间为RFC3339或Unix原子时间，输出时间戳总是Unix原子时间。</p><p>查询参数的名称可用中括号<code>[]</code>重复次数。</p><p><code>&lt;duration&gt;</code>占位符指的是<code>[0-9]+[smhdwy]</code>形式的Prometheus 持续时间字符串。例如，<code>5m</code>表示5分钟的持续时间。</p><p><br><br><br></p><h4 id="表达式查询"><a href="#表达式查询" class="headerlink" title="表达式查询"></a>表达式查询</h4><p>查询语言表达式可在单个时刻或一定范围内进行评估。以下部分用于描述每个类型的表达式查询的API endpoint。</p><p><br></p><p><strong>瞬时查询(Instant query)</strong></p><p>端点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/query</span><br><span class="line">POST /api/v1/query</span><br></pre></td></tr></table></figure><p>URL查询参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 表达式</span><br><span class="line">query=&lt;string&gt;</span><br><span class="line"></span><br><span class="line"># 时间戳，可选。默认使用当前系统时间</span><br><span class="line">time=&lt;rfc3339 | unix_timestamp&gt;</span><br><span class="line"></span><br><span class="line"># 超时，可选。默认使用全局的-query.timeout参数</span><br><span class="line">timeout=&lt;duration&gt;</span><br></pre></td></tr></table></figure><p>查询结果的<code>data</code>部分格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;resultType&quot;: &quot;matrix&quot; | &quot;vector&quot; | &quot;scalar&quot; | &quot;string&quot;,</span><br><span class="line">  &quot;result&quot;: &lt;value&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:9090/api/v1/query?query=up&amp;time=2015-07-01T20:10:51.781Z&apos;</span><br><span class="line">&#123;</span><br><span class="line">   &quot;status&quot; : &quot;success&quot;,</span><br><span class="line">   &quot;data&quot; : &#123;</span><br><span class="line">      &quot;resultType&quot; : &quot;vector&quot;,</span><br><span class="line">      &quot;result&quot; : [</span><br><span class="line">         &#123;</span><br><span class="line">            &quot;metric&quot; : &#123;</span><br><span class="line">               &quot;__name__&quot; : &quot;up&quot;,</span><br><span class="line">               &quot;job&quot; : &quot;prometheus&quot;,</span><br><span class="line">               &quot;instance&quot; : &quot;localhost:9090&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;value&quot;: [ 1435781451.781, &quot;1&quot; ]</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            &quot;metric&quot; : &#123;</span><br><span class="line">               &quot;__name__&quot; : &quot;up&quot;,</span><br><span class="line">               &quot;job&quot; : &quot;node&quot;,</span><br><span class="line">               &quot;instance&quot; : &quot;localhost:9100&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;value&quot; : [ 1435781451.781, &quot;0&quot; ]</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>区间查询(range query)</strong></p><p>端点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/query_range</span><br><span class="line">POST /api/v1/query_range</span><br></pre></td></tr></table></figure><p>URL查询参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 表达式</span><br><span class="line">query=&lt;string&gt;</span><br><span class="line"></span><br><span class="line"># 时间戳</span><br><span class="line">start=&lt;rfc3339 | unix_timestamp&gt;</span><br><span class="line">end=&lt;rfc3339 | unix_timestamp&gt;</span><br><span class="line"></span><br><span class="line"># 查询时间步长，时间区间内每step秒执行一次</span><br><span class="line">step=&lt;duration | float&gt;</span><br><span class="line"></span><br><span class="line"># 超时，可选</span><br><span class="line">timeout=&lt;duration&gt;</span><br></pre></td></tr></table></figure><p>查询结果的<code>data</code>部分格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;resultType&quot;: &quot;matrix&quot;,</span><br><span class="line">  &quot;result&quot;: &lt;value&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:9090/api/v1/query_range?query=up&amp;start=2015-07-01T20:10:30.781Z&amp;end=2015-07-01T20:11:00.781Z&amp;step=15s&apos;</span><br><span class="line">&#123;</span><br><span class="line">   &quot;status&quot; : &quot;success&quot;,</span><br><span class="line">   &quot;data&quot; : &#123;</span><br><span class="line">      &quot;resultType&quot; : &quot;matrix&quot;,</span><br><span class="line">      &quot;result&quot; : [</span><br><span class="line">         &#123;</span><br><span class="line">            &quot;metric&quot; : &#123;</span><br><span class="line">               &quot;__name__&quot; : &quot;up&quot;,</span><br><span class="line">               &quot;job&quot; : &quot;prometheus&quot;,</span><br><span class="line">               &quot;instance&quot; : &quot;localhost:9090&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;values&quot; : [</span><br><span class="line">               [ 1435781430.781, &quot;1&quot; ],</span><br><span class="line">               [ 1435781445.781, &quot;1&quot; ],</span><br><span class="line">               [ 1435781460.781, &quot;1&quot; ]</span><br><span class="line">            ]</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            &quot;metric&quot; : &#123;</span><br><span class="line">               &quot;__name__&quot; : &quot;up&quot;,</span><br><span class="line">               &quot;job&quot; : &quot;node&quot;,</span><br><span class="line">               &quot;instance&quot; : &quot;localhost:9091&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;values&quot; : [</span><br><span class="line">               [ 1435781430.781, &quot;0&quot; ],</span><br><span class="line">               [ 1435781445.781, &quot;0&quot; ],</span><br><span class="line">               [ 1435781460.781, &quot;1&quot; ]</span><br><span class="line">            ]</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="查询元数据"><a href="#查询元数据" class="headerlink" title="查询元数据"></a>查询元数据</h4><p><strong>通过标签匹配器查找序列(Finding series by label matchers)</strong></p><p>端点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/series</span><br><span class="line">POST /api/v1/series</span><br></pre></td></tr></table></figure><p>URL请求参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 标签选择器是 series_selector。必须至少提供一个match[]参数</span><br><span class="line">match[]=&lt;series_selector&gt;</span><br><span class="line"></span><br><span class="line"># 时间戳</span><br><span class="line">start=&lt;rfc3339 | unix_timestamp&gt;</span><br><span class="line">end=&lt;rfc3339 | unix_timestamp&gt;</span><br></pre></td></tr></table></figure><p>返回结果的data部分，由k/v键值对的对象列表组成。<br>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ curl -g &apos;http://localhost:9090/api/v1/series?&apos; --data-urlencode=&apos;match[]=up&apos; --data-urlencode=&apos;match[]=process_start_time_seconds&#123;job=&quot;prometheus&quot;&#125;&apos;</span><br><span class="line">&#123;</span><br><span class="line">   &quot;status&quot; : &quot;success&quot;,</span><br><span class="line">   &quot;data&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;__name__&quot; : &quot;up&quot;,</span><br><span class="line">         &quot;job&quot; : &quot;prometheus&quot;,</span><br><span class="line">         &quot;instance&quot; : &quot;localhost:9090&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;__name__&quot; : &quot;up&quot;,</span><br><span class="line">         &quot;job&quot; : &quot;node&quot;,</span><br><span class="line">         &quot;instance&quot; : &quot;localhost:9091&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;__name__&quot; : &quot;process_start_time_seconds&quot;,</span><br><span class="line">         &quot;job&quot; : &quot;prometheus&quot;,</span><br><span class="line">         &quot;instance&quot; : &quot;localhost:9090&quot;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>获取标签名(label)</strong></p><p>端点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/labels</span><br><span class="line">POST /api/v1/labels</span><br></pre></td></tr></table></figure><p>返回结果的<code>data</code>部分是一个标签名字符串列表。<br>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;localhost:9090/api/v1/labels&apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &quot;__name__&quot;,</span><br><span class="line">        &quot;call&quot;,</span><br><span class="line">        &quot;code&quot;,</span><br><span class="line">        &quot;config&quot;,</span><br><span class="line">        &quot;dialer_name&quot;,</span><br><span class="line">        &quot;endpoint&quot;,</span><br><span class="line">        &quot;event&quot;,</span><br><span class="line">        &quot;goversion&quot;,</span><br><span class="line">        &quot;handler&quot;,</span><br><span class="line">        &quot;instance&quot;,</span><br><span class="line">        &quot;interval&quot;,</span><br><span class="line">        &quot;job&quot;,</span><br><span class="line">        &quot;le&quot;,</span><br><span class="line">        &quot;listener_name&quot;,</span><br><span class="line">        &quot;name&quot;,</span><br><span class="line">        &quot;quantile&quot;,</span><br><span class="line">        &quot;reason&quot;,</span><br><span class="line">        &quot;role&quot;,</span><br><span class="line">        &quot;scrape_job&quot;,</span><br><span class="line">        &quot;slice&quot;,</span><br><span class="line">        &quot;version&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>查询标签值</strong></p><p>请求如下端点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/label/&lt;label_name&gt;/values</span><br></pre></td></tr></table></figure><p>JSON响应的<code>data</code>部分是标签值字符串列表。<br>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://localhost:9090/api/v1/label/job/values</span><br><span class="line">&#123;</span><br><span class="line">   &quot;status&quot; : &quot;success&quot;,</span><br><span class="line">   &quot;data&quot; : [</span><br><span class="line">      &quot;node&quot;,</span><br><span class="line">      &quot;prometheus&quot;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="表达式查询结果的格式"><a href="#表达式查询结果的格式" class="headerlink" title="表达式查询结果的格式"></a>表达式查询结果的格式</h4><p>Expression query result formats</p><p>表达式查询结果可能会在<code>data</code>部分的<code>result</code>字段中返回以下响应值。</p><p><br></p><p><strong>区间向量(range vectors)</strong></p><p>区间向量返回<code>matrix</code> resultType。<code>result</code>的响应格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;metric&quot;: &#123; &quot;&lt;label_name&gt;&quot;: &quot;&lt;label_value&gt;&quot;, ... &#125;,</span><br><span class="line">    &quot;values&quot;: [ [ &lt;unix_time&gt;, &quot;&lt;sample_value&gt;&quot; ], ... ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><p><strong>瞬时向量(instant vectors)</strong></p><p>瞬时向量返回<code>vector</code> resultType。<code>result</code>的响应格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;metric&quot;: &#123; &quot;&lt;label_name&gt;&quot;: &quot;&lt;label_value&gt;&quot;, ... &#125;,</span><br><span class="line">    &quot;value&quot;: [ &lt;unix_time&gt;, &quot;&lt;sample_value&gt;&quot; ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><p><strong>标量(Scalars)</strong></p><p>标量返回<code>scalar</code> resultType。<code>result</code>的响应格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &lt;unix_time&gt;, &quot;&lt;scalar_value&gt;&quot; ]</span><br></pre></td></tr></table></figure><p><br></p><p><strong>字符串(string)</strong></p><p>字符串返回<code>string</code> resultType。<code>result</code>的响应格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &lt;unix_time&gt;, &quot;&lt;string_value&gt;&quot; ]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>Targets</p><p>以下端点返回Prometheus目标发现的当前状态的概述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/targets</span><br></pre></td></tr></table></figure><p>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9090/api/v1/targets</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;activeTargets&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;discoveredLabels&quot;: &#123;</span><br><span class="line">          &quot;__address__&quot;: &quot;127.0.0.1:9090&quot;,</span><br><span class="line">          &quot;__metrics_path__&quot;: &quot;/metrics&quot;,</span><br><span class="line">          &quot;__scheme__&quot;: &quot;http&quot;,</span><br><span class="line">          &quot;job&quot;: &quot;prometheus&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;labels&quot;: &#123;</span><br><span class="line">          &quot;instance&quot;: &quot;127.0.0.1:9090&quot;,</span><br><span class="line">          &quot;job&quot;: &quot;prometheus&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;scrapeUrl&quot;: &quot;http://127.0.0.1:9090/metrics&quot;,</span><br><span class="line">        &quot;lastError&quot;: &quot;&quot;,</span><br><span class="line">        &quot;lastScrape&quot;: &quot;2017-01-17T15:07:44.723715405+01:00&quot;,</span><br><span class="line">        &quot;health&quot;: &quot;up&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;droppedTargets&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;discoveredLabels&quot;: &#123;</span><br><span class="line">          &quot;__address__&quot;: &quot;127.0.0.1:9100&quot;,</span><br><span class="line">          &quot;__metrics_path__&quot;: &quot;/metrics&quot;,</span><br><span class="line">          &quot;__scheme__&quot;: &quot;http&quot;,</span><br><span class="line">          &quot;job&quot;: &quot;node&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>Rules</p><p>此api端点返回当前载入的告警和记录规则的列表。此外，它还会返回由每个告警规则的Prometheus实例点燃的当前激活的告警。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/rules</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9090/api/v1/rules</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;groups&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;rules&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;alerts&quot;: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                &quot;activeAt&quot;: &quot;2018-07-04T20:27:12.60602144+02:00&quot;,</span><br><span class="line">                                &quot;annotations&quot;: &#123;</span><br><span class="line">                                    &quot;summary&quot;: &quot;High request latency&quot;</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &quot;labels&quot;: &#123;</span><br><span class="line">                                    &quot;alertname&quot;: &quot;HighRequestLatency&quot;,</span><br><span class="line">                                    &quot;severity&quot;: &quot;page&quot;</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &quot;state&quot;: &quot;firing&quot;,</span><br><span class="line">                                &quot;value&quot;: &quot;1e+00&quot;</span><br><span class="line">                            &#125;</span><br><span class="line">                        ],</span><br><span class="line">                        &quot;annotations&quot;: &#123;</span><br><span class="line">                            &quot;summary&quot;: &quot;High request latency&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;duration&quot;: 600,</span><br><span class="line">                        &quot;health&quot;: &quot;ok&quot;,</span><br><span class="line">                        &quot;labels&quot;: &#123;</span><br><span class="line">                            &quot;severity&quot;: &quot;page&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;name&quot;: &quot;HighRequestLatency&quot;,</span><br><span class="line">                        &quot;query&quot;: &quot;job:request_latency_seconds:mean5m&#123;job=\&quot;myjob\&quot;&#125; &gt; 0.5&quot;,</span><br><span class="line">                        &quot;type&quot;: &quot;alerting&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;health&quot;: &quot;ok&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;job:http_inprogress_requests:sum&quot;,</span><br><span class="line">                        &quot;query&quot;: &quot;sum(http_inprogress_requests) by (job)&quot;,</span><br><span class="line">                        &quot;type&quot;: &quot;recording&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                &quot;file&quot;: &quot;/rules.yaml&quot;,</span><br><span class="line">                &quot;interval&quot;: 60,</span><br><span class="line">                &quot;name&quot;: &quot;example&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h4><p>Alerts</p><p>此端点返回所有激活的告警的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/alerts</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9090/api/v1/alerts</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;alerts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;activeAt&quot;: &quot;2018-07-04T20:27:12.60602144+02:00&quot;,</span><br><span class="line">                &quot;annotations&quot;: &#123;&#125;,</span><br><span class="line">                &quot;labels&quot;: &#123;</span><br><span class="line">                    &quot;alertname&quot;: &quot;my-alert&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;state&quot;: &quot;firing&quot;,</span><br><span class="line">                &quot;value&quot;: &quot;1e+00&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="查询目标元数据"><a href="#查询目标元数据" class="headerlink" title="查询目标元数据"></a>查询目标元数据</h4><p>Query target metadata</p><p>此段点返回目前由目标爬取的关于指标的元数据。这是实验性的，未来可能发生改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/targets/metadata</span><br></pre></td></tr></table></figure><p>URL查询参数:</p><ul><li><code>match_target=&lt;label_selectors&gt;</code>: 标签选择器通过标签集匹配的目标。如果为空，则所有目标都被选中。</li><li><code>metics=&lt;string&gt;</code>: 检索元数据的指标名称。如果为空，则所有指标元数据都被检索。</li><li><code>limit=&lt;number&gt;</code>: 匹配的目标的最大数量。</li></ul><p>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">curl -G http://localhost:9091/api/v1/targets/metadata \</span><br><span class="line">    --data-urlencode &apos;metric=go_goroutines&apos; \</span><br><span class="line">    --data-urlencode &apos;match_target=&#123;job=&quot;prometheus&quot;&#125;&apos; \</span><br><span class="line">    --data-urlencode &apos;limit=2&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;target&quot;: &#123;</span><br><span class="line">        &quot;instance&quot;: &quot;127.0.0.1:9090&quot;,</span><br><span class="line">        &quot;job&quot;: &quot;prometheus&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;type&quot;: &quot;gauge&quot;,</span><br><span class="line">      &quot;help&quot;: &quot;Number of goroutines that currently exist.&quot;,</span><br><span class="line">      &quot;unit&quot;: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;target&quot;: &#123;</span><br><span class="line">        &quot;instance&quot;: &quot;127.0.0.1:9091&quot;,</span><br><span class="line">        &quot;job&quot;: &quot;prometheus&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;type&quot;: &quot;gauge&quot;,</span><br><span class="line">      &quot;help&quot;: &quot;Number of goroutines that currently exist.&quot;,</span><br><span class="line">      &quot;unit&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">curl -G http://localhost:9091/api/v1/targets/metadata \</span><br><span class="line">    --data-urlencode &apos;match_target=&#123;instance=&quot;127.0.0.1:9090&quot;&#125;&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">    // ...</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;target&quot;: &#123;</span><br><span class="line">        &quot;instance&quot;: &quot;127.0.0.1:9090&quot;,</span><br><span class="line">        &quot;job&quot;: &quot;prometheus&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;metric&quot;: &quot;prometheus_treecache_zookeeper_failures_total&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;counter&quot;,</span><br><span class="line">      &quot;help&quot;: &quot;The total number of ZooKeeper failures.&quot;,</span><br><span class="line">      &quot;unit&quot;: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;target&quot;: &#123;</span><br><span class="line">        &quot;instance&quot;: &quot;127.0.0.1:9090&quot;,</span><br><span class="line">        &quot;job&quot;: &quot;prometheus&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;metric&quot;: &quot;prometheus_tsdb_reloads_total&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;counter&quot;,</span><br><span class="line">      &quot;help&quot;: &quot;Number of times the database reloaded block data from disk.&quot;,</span><br><span class="line">      &quot;unit&quot;: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    // ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="告警器"><a href="#告警器" class="headerlink" title="告警器"></a>告警器</h4><p>AlertManagers</p><p>此端点返回Prometheus alertmanager discovery的当前状态的概述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/alertmanagers</span><br></pre></td></tr></table></figure><p>active和dropped Alertmanagers都是响应的一部分:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9090/api/v1/alertmanagers</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;activeAlertmanagers&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;url&quot;: &quot;http://127.0.0.1:9090/api/v1/alerts&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;droppedAlertmanagers&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;url&quot;: &quot;http://127.0.0.1:9093/api/v1/alerts&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>Status</p><p>以下状态端点暴露当前Prometheus配置。</p><p><br></p><p><strong>Config</strong></p><p>此端点返回当前加载的配置文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/status/config</span><br></pre></td></tr></table></figure><p>配置返回为转存的YAML文件。由于YAML库的限制，YAML中不包含注释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9090/api/v1/status/config</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;yaml&quot;: &quot;&lt;content of the loaded config file in YAML&gt;&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Flags</strong></p><p>此端点返回Prometheus配置的标志值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/status/flags</span><br></pre></td></tr></table></figure><p>所有值的结果类型都是字符串:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9090/api/v1/status/flags</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;alertmanager.notification-queue-capacity&quot;: &quot;10000&quot;,</span><br><span class="line">    &quot;alertmanager.timeout&quot;: &quot;10s&quot;,</span><br><span class="line">    &quot;log.level&quot;: &quot;info&quot;,</span><br><span class="line">    &quot;query.lookback-delta&quot;: &quot;5m&quot;,</span><br><span class="line">    &quot;query.max-concurrency&quot;: &quot;20&quot;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>RunTime Information</strong></p><p>此端点返回Prometheus Server的各种运行信息属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/status/runtimeinfo</span><br></pre></td></tr></table></figure><p>根据运行属性，返回的值有两种类型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9090/api/v1/status/runtimeinfo</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;startTime&quot;: &quot;2019-11-02T17:23:59.301361365+01:00&quot;,</span><br><span class="line">    &quot;CWD&quot;: &quot;/&quot;,</span><br><span class="line">    &quot;reloadConfigSuccess&quot;: true,</span><br><span class="line">    &quot;lastConfigTime&quot;: &quot;2019-11-02T17:23:59+01:00&quot;,</span><br><span class="line">    &quot;chunkCount&quot;: 873,</span><br><span class="line">    &quot;timeSeriesCount&quot;: 873,</span><br><span class="line">    &quot;corruptionCount&quot;: 0,</span><br><span class="line">    &quot;goroutineCount&quot;: 48,</span><br><span class="line">    &quot;GOMAXPROCS&quot;: 4,</span><br><span class="line">    &quot;GOGC&quot;: &quot;&quot;,</span><br><span class="line">    &quot;GODEBUG&quot;: &quot;&quot;,</span><br><span class="line">    &quot;storageRetention&quot;: &quot;15d&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Build Information</strong></p><p>此端点返回各种关于Prometheus Server的构建信息属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/v1/status/buildinfo</span><br></pre></td></tr></table></figure><p>所有结果的值的类型都是字符串:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9090/api/v1/status/buildinfo</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.13.1&quot;,</span><br><span class="line">    &quot;revision&quot;: &quot;cb7cbad5f9a2823a622aaa668833ca04f50a0ea7&quot;,</span><br><span class="line">    &quot;branch&quot;: &quot;master&quot;,</span><br><span class="line">    &quot;buildUser&quot;: &quot;julius@desktop&quot;,</span><br><span class="line">    &quot;buildDate&quot;: &quot;20191102-16:19:59&quot;,</span><br><span class="line">    &quot;goVersion&quot;: &quot;go1.13.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="TSDB-Admin-APIs"><a href="#TSDB-Admin-APIs" class="headerlink" title="TSDB Admin APIs"></a>TSDB Admin APIs</h4><p>这些都是为高级用户公开的数据库功能的API。除非设置<code>--web.enable-admin-api</code>，否则不启用这些API。</p><p>我们也公开了一个gRPC API。这是实验性的，未来可能会改变。</p><p><br></p><p><strong>Snapshot</strong></p><p>创建所有当前数据的快照<code>snapshots/datetime-rand</code>早TSDB的数据目录并返回目录作为响应。它将可选地跳过快照数据尽在头部块，并且未被压缩到磁盘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1/admin/tsdb/snapshot</span><br><span class="line">PUT /api/v1/admin/tsdb/snapshot</span><br></pre></td></tr></table></figure><p>URL查询参数:</p><ul><li><code>skip_head=&lt;bool&gt;</code>: 跳过存在于头部块(head block)的数据，可选。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:9090/api/v1/admin/tsdb/snapshot</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;20171210T211224Z-2be650b6d019eb54&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快照现在位于: <code>&lt;data-dir&gt;/snapshots/20171210T211224Z-2be650b6d019eb54</code></p><p><br></p><p><strong>Delete Series</strong></p><p>删除在一个时间范围内选择的一些列数据。实际数据仍然存在于磁盘上，并在未来被清除或通过点击Clean Tombstones endpoint来明确清理。<br>如果成功，返回<code>204</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1/admin/tsdb/delete_series</span><br><span class="line">PUT /api/v1/admin/tsdb/delete_series</span><br></pre></td></tr></table></figure><p>URL查询参数:</p><ul><li><code>match[]=&lt;series_selector&gt;</code>: 至少必须提供一个</li><li><code>start=&lt;rfc3339 | unix_timestamp&gt;</code></li><li><code>end=&lt;rfc3339 | unix_timestamp&gt;</code></li></ul><p>未指定时间范围将删除匹配的所有数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -g &apos;http://localhost:9090/api/v1/admin/tsdb/delete_series?match[]=up&amp;match[]=process_start_time_seconds&#123;job=&quot;prometheus&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Clean Tombstones</strong></p><p>从磁盘中删除已删除的数据并清理现有的tombstones。这可在清理数据后腾出磁盘空间。</p><p>如果成功，返回<code>204</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1/admin/tsdb/clean_tombstones</span><br><span class="line">PUT /api/v1/admin/tsdb/clean_tombstones</span><br></pre></td></tr></table></figure><p>不需要任何参数或body:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://localhost:9090/api/v1/admin/tsdb/clean_tombstones</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>Storage: <a href="https://prometheus.io/docs/prometheus/latest/storage/" target="_blank" rel="noopener">https://prometheus.io/docs/prometheus/latest/storage/</a></p><p>Prometheus包含了一个本地磁盘上的时序数据库(time series database)，但是可选地与远程存储系统集成。</p><p><br></p><h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>Local storage</p><p>Prometheus本地时序数据库存储时序数据自定义格式存储到磁盘上。</p><p><br></p><p><strong>On-disk layout</strong></p><p>Prometheus按两小时为一个时间窗口分组存储在一个块(block)中。每个块是一个单独地目录，里面包含该时间窗口内的所有样本数据(chunks)，元数据文件(meta.json)以及索引文件(index)。其中索引文件会将指标名称和标签索引到样板数据的时间序列中。此期间如果通过 API 删除时间序列，删除记录会保存在单独的逻辑文件<code>tombstone</code>当中。</p><p>当前样本数据所在的块会被直接保存在内存中，不会持久化到磁盘中。为了确保Prometheus发生崩溃或重启时能够恢复数据，Prometheus启动时会通过预写日志（write-ahead-log(WAL)）重新记录，从而恢复数据。预写日志文件保存在<code>wal</code>目录中，每个文件大小为<code>128MB</code>。wal 文件包括还没有被压缩的原始数据，所以比常规的块文件大得多。一般情况下，Prometheus 会保留三个 wal 文件，但如果有些高负载服务器需要保存两个小时以上的原始数据，wal文件的数量就会大于3个。</p><p>Prometheus块数据的目录结构如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">./data</span><br><span class="line">├── 01BKGV7JBM69T2G1BGBGM6KB12</span><br><span class="line">│   └── meta.json</span><br><span class="line">├── 01BKGTZQ1SYQJTR4PB43C8PD98</span><br><span class="line">│   ├── chunks</span><br><span class="line">│   │   └── 000001</span><br><span class="line">│   ├── tombstones</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── meta.json</span><br><span class="line">├── 01BKGTZQ1HHWHV8FBJXW1Y3W0K</span><br><span class="line">│   └── meta.json</span><br><span class="line">├── 01BKGV7JC0RY8A6MACW02A2PJD</span><br><span class="line">│   ├── chunks</span><br><span class="line">│   │   └── 000001</span><br><span class="line">│   ├── tombstones</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── meta.json</span><br><span class="line">└── wal</span><br><span class="line">    ├── 00000002</span><br><span class="line">    └── checkpoint.000001</span><br></pre></td></tr></table></figure><p>本地存储的局限性是它无法构建集群(clustered)或副本(replicated)。因此，如果本地磁盘或节点出现故障，存储将无法扩展和迁移。使用RAID用于磁盘的可用性，使用快照用于备份，容量规划…建议提高耐用性。如果你对数据持久化的要求不是很严格，可以使用本地磁盘存储多达数年的数据。</p><p>可替代地，外部存储可通过使用<code>remote read/write APIs</code>。仔细评估这些系统，因为它们在耐用性，性能和效率差异很大。</p><p>有关存储格式的详细信息，请参考 <a href="https://github.com/prometheus/prometheus/blob/master/tsdb/docs/format/README.md" target="_blank" rel="noopener">TSDB格式</a></p><p><br><br><br></p><h3 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h3><p>最初两个小时的块最终会在后台被压缩成更长的块。</p><p><br></p><h3 id="操作配置"><a href="#操作配置" class="headerlink" title="操作配置"></a>操作配置</h3><p>Prometheus提供了几个标志来允许配置本地存储。最重要的几个:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 数据存储路径，默认data/</span><br><span class="line">--storage.tsdb.path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 样本数据在存储中保存的时间。超过该时间限制的数据就会被删除。默认15d</span><br><span class="line">-storage.tsdb.retention.time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 每个块的最大字节数（不包括 wal 文件）。如果超过限制，最早的样本数据会被优先删除。支持的单位有 KB, MB, GB, PB。默认0，即为不限制</span><br><span class="line">--storage.tsdb.retention.size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 压缩wal</span><br><span class="line">--storage.tsdb.wal-compression</span><br></pre></td></tr></table></figure><p><br></p><p>一般情况下，Prometheus中存储的每一个样本大概会占用1-2Byte。因此，如果需要对Prometheus Server的本地磁盘空间做容量规划，可通过以下公式计算:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">needed_disk_space = retention_time_seconds * ingested_samples_per_second * bytes_per_sample</span><br></pre></td></tr></table></figure><p>从上面公式中可以看出在保留时间（<code>retention_time_seconds</code>）和样本大小（<code>bytes_per_sample</code>）不变的情况下，如果想减少本地磁盘的容量需求，只能通过减少每秒获取样本数（<code>ingested_samples_per_second</code>）的方式。因此有两种手段，一是减少时间序列的数量，二是增加采集样本的时间间隔。考虑到 Prometheus 会对时间序列进行压缩效率，减少时间序列的数量效果更明显。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><p>Visualization</p><p><br></p><h2 id="表达式浏览器"><a href="#表达式浏览器" class="headerlink" title="表达式浏览器"></a>表达式浏览器</h2><p>Expression browser</p><p>表达其浏览器在 Prometheus Server 的 <code>/graph</code> 处。<br>对于图形，请使用 Grafana 或 Console template。</p><p><br><br><br><br><br></p><h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>Grafana: <a href="https://grafana.com/" target="_blank" rel="noopener">https://grafana.com/</a></p><p>Grafana，美丽的分析和监控的开放平台，时序分析的开源那软件。</p><p>Grafana 支持查询 Prometheus。如下是一个Grafana仪表盘，用于查询Prometheus的数据：</p><p><img src="/images/Prometheus/grafana_prometheus.png" alt></p><p><br></p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>完整的安装说明，请查看Grafana Docs。</p><p><br></p><h4 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h4><p><strong>RPM</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#sudo yum install &lt;rpm package url&gt;</span><br><span class="line">sudo yum install https://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-5.1.4-1.x86_64.rpm</span><br></pre></td></tr></table></figure><p><strong>repo</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[grafana]</span><br><span class="line">name=grafana</span><br><span class="line">baseurl=https://packagecloud.io/grafana/stable/el/7/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://packagecloud.io/gpg.key https://grafanarel.s3.amazonaws.com/RPM-GPG-KEY-grafana</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo yum install -y grafana</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启动</span><br><span class="line">systemctl start grafana-server</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#命令行工具</span><br><span class="line">grafana-cli</span><br></pre></td></tr></table></figure><p><strong>包详情</strong></p><ul><li>Installs binary to <code>/usr/sbin/grafana-server</code></li><li>Copies init.d script to <code>/etc/init.d/grafana-server</code></li><li>Installs default file (environment vars) to <code>/etc/sysconfig/grafana-server</code></li><li>Copies configuration file to <code>/etc/grafana/grafana.ini</code></li><li>Installs systemd service (if systemd is available) name <code>grafana-server.service</code></li><li>The default configuration uses a log file at <code>/var/log/grafana/grafana.log</code></li><li>The default configuration specifies an sqlite3 database at <code>/var/lib/grafana/grafana.db</code></li></ul><p><br></p><p><strong>二进制tar文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Download and unpack Grafana from binary tar (adjust version as appropriate).</span><br><span class="line">curl -L -O https://grafanarel.s3.amazonaws.com/builds/grafana-2.5.0.linux-x64.tar.gz</span><br><span class="line">tar zxf grafana-2.5.0.linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"># Start Grafana.</span><br><span class="line">cd grafana-2.5.0/</span><br><span class="line">./bin/grafana-server web</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#基础栗子</span><br><span class="line">docker run -d -p 3000:3000 grafana/grafana</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#配置化</span><br><span class="line">docker run \</span><br><span class="line">  -d \</span><br><span class="line">  -p 3000:3000 \</span><br><span class="line">  --name=grafana \</span><br><span class="line">  -e &quot;GF_SERVER_ROOT_URL=http://grafana.server.name&quot; \</span><br><span class="line">  -e &quot;GF_SECURITY_ADMIN_PASSWORD=secret&quot; \</span><br><span class="line">  grafana/grafana:version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#默认环境变量值</span><br><span class="line">GF_PATHS_CONFIG/etc/grafana/grafana.ini</span><br><span class="line">GF_PATHS_DATA/var/lib/grafana</span><br><span class="line">GF_PATHS_HOME/usr/share/grafana</span><br><span class="line">GF_PATHS_LOGS/var/log/grafana</span><br><span class="line">GF_PATHS_PLUGINS/var/lib/grafana/plugins</span><br><span class="line">GF_PATHS_PROVISIONING/etc/grafana/provisioning</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>默认情况下，访问<code>http://localhost:3000</code>来访问Grafana。默认登录的用户名和密码： <code>admin/admin</code>。</p><p><img src="/images/Prometheus/grafana_login.png" alt="Grafana"></p><p><br></p><p><strong>创建Prometheus数据源</strong></p><p><img src="/images/Prometheus/add_prometheus_datasource.png" alt></p><p><br></p><p><strong>创建Prometheus图表</strong></p><p><br><br><br><br><br></p><h2 id="Console-template"><a href="#Console-template" class="headerlink" title="Console template"></a>Console template</h2><p>控制台模板允许使用Go templating language创建任意控制台。这些都是从Prometheus Server提供的。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h1><p>由于prometheus自带的alertmanager对国内通知支持不够完善，因此使用PrometheusAlert做告警通知。</p><p><br></p><h2 id="prometheus配置样例"><a href="#prometheus配置样例" class="headerlink" title="prometheus配置样例"></a>prometheus配置样例</h2><p>prometheus的配置示例:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my global config</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">1</span><span class="string">m</span> <span class="comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span></span><br><span class="line"><span class="attr">  evaluation_interval:</span> <span class="number">1</span><span class="string">m</span> <span class="comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span></span><br><span class="line"><span class="attr">  scrape_timeout:</span> <span class="number">1</span><span class="string">m</span></span><br><span class="line">  <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line">  <span class="comment"># for thanos</span></span><br><span class="line"><span class="attr">  external_labels:</span></span><br><span class="line"><span class="attr">    region:</span> <span class="string">ali</span> <span class="comment"># hw|tx</span></span><br><span class="line"><span class="attr">    replica:</span> <span class="string">full</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alertmanager configuration</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line"><span class="attr">  alertmanagers:</span></span><br><span class="line"><span class="attr">  - static_configs:</span></span><br><span class="line"><span class="attr">    - targets:</span> <span class="string">["localhost:9093"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load rules once and periodically evaluate them according to the global 'evaluation_interval'.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"rules/*.yml"</span>  <span class="comment"># 通用告警规则模板</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"rules/nodes/*.yml"</span>  <span class="comment"># 各主机告警规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it's Prometheus itself.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">node-process-exporter</span></span><br><span class="line"><span class="attr">    file_sd_configs:</span></span><br><span class="line"><span class="attr">      - files:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"discovery/exporter/*.yml"</span></span><br><span class="line">    <span class="comment"># metrics_path defaults to '/metrics'</span></span><br><span class="line">    <span class="comment"># scheme defaults to 'http'.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">mongodb-exporter</span></span><br><span class="line"><span class="attr">    file_sd_configs:</span></span><br><span class="line"><span class="attr">      - files:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"discovery/mongodb/*.yml"</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">kafka-exporter</span></span><br><span class="line"><span class="attr">    file_sd_configs:</span></span><br><span class="line"><span class="attr">      - files:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"discovery/kafka/*.yml"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">aliyun-exporter</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">        - targets:</span> <span class="string">["localhost:9525",</span> <span class="string">"localhost:9526"</span><span class="string">,</span> <span class="string">"localhost:9527"</span><span class="string">,</span> <span class="string">"localhost:9528"</span><span class="string">,</span> <span class="string">"localhost:9529"</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">blackbox_exporter</span></span><br><span class="line"><span class="attr">    metrics_path:</span> <span class="string">/probe</span></span><br><span class="line"><span class="attr">    file_sd_configs:</span></span><br><span class="line"><span class="attr">      - files:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"discovery/blackbox/*.yml"</span></span><br><span class="line"><span class="attr">    relabel_configs:</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">[__address__]</span></span><br><span class="line"><span class="attr">        target_label:</span> <span class="string">__param_target</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">[module]</span></span><br><span class="line"><span class="attr">        target_label:</span> <span class="string">__param_module</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">[__param_target]</span></span><br><span class="line"><span class="attr">        target_label:</span> <span class="string">instance</span></span><br><span class="line"><span class="attr">      - target_label:</span> <span class="string">__address__</span></span><br><span class="line"><span class="attr">        replacement:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9115</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="alertmanager配置样例"><a href="#alertmanager配置样例" class="headerlink" title="alertmanager配置样例"></a>alertmanager配置样例</h2><p>alertmanager的配置示例:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># global config</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  resolve_timeout:</span> <span class="number">5</span><span class="string">m</span></span><br><span class="line">  <span class="comment"># smtp config</span></span><br><span class="line">  <span class="comment"># slack config</span></span><br><span class="line">  <span class="comment"># wechat config</span></span><br><span class="line">  <span class="comment"># http config</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># templates config</span></span><br><span class="line"><span class="attr">templates:</span> <span class="string">[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># route tree</span></span><br><span class="line"><span class="attr">route:</span></span><br><span class="line"><span class="attr">  receiver:</span> <span class="string">'web.hook.prometheusalert'</span></span><br><span class="line"><span class="attr">  group_by:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">instanceId</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">hostname</span></span><br><span class="line"><span class="attr">  group_wait:</span> <span class="number">30</span><span class="string">s</span></span><br><span class="line"><span class="attr">  group_interval:</span> <span class="number">1</span><span class="string">m</span></span><br><span class="line">  <span class="comment"># notification again</span></span><br><span class="line"><span class="attr">  repeat_interval:</span> <span class="number">10</span><span class="string">m</span></span><br><span class="line">  <span class="comment"># continue config</span></span><br><span class="line">  <span class="comment"># match: [ &lt;labelname&gt;: &lt;labelvalue&gt;, ... ]</span></span><br><span class="line">  <span class="comment"># match_re: [ &lt;labelname&gt;: &lt;regex&gt;, ... ]</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">  - match:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">warning</span></span><br><span class="line"><span class="attr">      repeat_interval:</span> <span class="number">1</span><span class="string">h</span></span><br><span class="line"><span class="attr">  - match_re:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">notice|info</span></span><br><span class="line"><span class="attr">      repeat_interval:</span> <span class="number">6</span><span class="string">h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># receiver lists</span></span><br><span class="line"><span class="attr">receivers:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">'web.hook.prometheusalert'</span></span><br><span class="line"><span class="attr">  webhook_configs:</span></span><br><span class="line"><span class="attr">      - url:</span> <span class="string">'http://127.0.0.1:8080/prometheus/alert'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list of inhibit rules</span></span><br><span class="line"><span class="attr">inhibit_rules:</span></span><br><span class="line">  <span class="comment"># aliyun</span></span><br><span class="line"><span class="attr">  - source_match:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">'critical'</span></span><br><span class="line"><span class="attr">    target_match_re:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">'warning'</span></span><br><span class="line">    <span class="comment"># source_match_re</span></span><br><span class="line">    <span class="comment"># target_match_re</span></span><br><span class="line">    <span class="comment"># Labels that must have an equal value in the source and target</span></span><br><span class="line"><span class="attr">    equal:</span> <span class="string">['instance','job','instanceId','kind']</span></span><br><span class="line">  <span class="comment"># nodes</span></span><br><span class="line"><span class="attr">  - source_match:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">'critical'</span></span><br><span class="line"><span class="attr">    target_match_re:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">'warning'</span></span><br><span class="line"><span class="attr">    equal:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">instance</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">job</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">hostname</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">kind</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="prometheus自动发现"><a href="#prometheus自动发现" class="headerlink" title="prometheus自动发现"></a>prometheus自动发现</h2><p>prometheus的文件自动发现示例:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- labels:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    hostgroup:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  targets:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"localhost:9100"</span> <span class="comment"># node-exporter</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"localhost:9256"</span> <span class="comment"># process-exporter</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="prometheus告警规则"><a href="#prometheus告警规则" class="headerlink" title="prometheus告警规则"></a>prometheus告警规则</h2><p>prometheus的告警规则示例:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">node-cpu</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line">  <span class="comment"># cpu核数</span></span><br><span class="line"><span class="attr">  - record:</span> <span class="attr">instance:node_cpus:count</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">count</span> <span class="string">without</span> <span class="string">(cpu,</span> <span class="string">mode)</span> <span class="string">(node_cpu_seconds_total&#123;mode="idle"&#125;)</span></span><br><span class="line">  <span class="comment"># 每个cpu使用率</span></span><br><span class="line"><span class="attr">  - record:</span> <span class="attr">instance_cpu:node_cpu_seconds_not_idle:rate2m</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">sum</span> <span class="string">without</span> <span class="string">(mode)</span> <span class="string">(1</span> <span class="bullet">-</span> <span class="string">rate(node_cpu_seconds_total&#123;mode="idle"&#125;[2m]))</span></span><br><span class="line">  <span class="comment"># 总cpu使用率</span></span><br><span class="line"><span class="attr">  - record:</span> <span class="attr">instance:node_cpu_utilization:ratio</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">avg</span> <span class="string">without</span> <span class="string">(cpu)</span> <span class="string">(instance_cpu:node_cpu_seconds_not_idle:rate2m)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">cpu使用率大于85%</span></span><br><span class="line">    <span class="comment">### expr: (1 - avg(irate(node_cpu_seconds_total&#123;mode="idle"&#125;[5m])) by(instance,hostname)) * 100 &gt; 85</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="attr">instance:node_cpu_utilization:ratio</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt; 85</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">3</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">warning</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">CpuUsage</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"cpu使用率大于85%: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>的cpu使用率: <span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>%"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">cpu使用率大于90%</span></span><br><span class="line">    <span class="comment">### expr: (1 - avg(irate(node_cpu_seconds_total&#123;mode="idle"&#125;[5m])) by(instance,hostname)) * 100 &gt; 90</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="attr">instance:node_cpu_utilization:ratio</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt; 90</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">1</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">critical</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">CpuUsage</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"cpu使用率大于90%: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>的cpu使用率: <span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>%"</span></span><br><span class="line"><span class="attr">      wxurl:</span> <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">cpu使用率一分钟内增长30%且大于70%</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">delta(instance:node_cpu_utilization:ratio[2m])</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt; 30 and on(hostname) instance:node_cpu_utilization:ratio * 100 &gt; 70</span></span><br><span class="line"><span class="string"></span><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">warning</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">CpuUsageDelta</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"cpu使用率一分钟内增长30%且大于70%: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span> 的cpu使用率一分钟内增长30%且大于70%，增长率: <span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>%"</span></span><br><span class="line"><span class="attr">      wxurl:</span> <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">cpu使用率一分钟内增长40%且大于80%</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">delta(instance:node_cpu_utilization:ratio[2m])</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt; 40 and on(hostname) instance:node_cpu_utilization:ratio * 100 &gt; 80</span></span><br><span class="line"><span class="string"></span><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">critical</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">CpuUsageDelta</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"cpu使用率一分钟内增长40%且大于80%: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span> 的cpu使用率一分钟内增长40%且大于80%，增长率: <span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>%"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">cpu使用率一分钟内增长50%</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">delta(instance:node_cpu_utilization:ratio[2m])</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt; 50</span></span><br><span class="line"><span class="string"></span><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">critical</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"cpu使用率一分钟内增长50%: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span> 的cpu使用率一分钟内增长50%，增长率: <span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>%"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">cpu负载大于Cores</span></span><br><span class="line">    <span class="comment">### expr: node_load1 &gt; count(node_cpu_seconds_total&#123;mode="idle"&#125;) without (cpu,mode)</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">node_load1</span> <span class="string">&gt; instance:node_cpus:count</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">3</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">warning</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">CpuLoad</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"cpu负载大于cpu核数: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>的cpu负载: <span class="template-variable">&#123;&#123; $value &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">cpu负载大于2Cores-2</span></span><br><span class="line">    <span class="comment">### expr: node_load1 &gt; 2 * (count(node_cpu_seconds_total&#123;mode="idle"&#125;) without (cpu,mode)) - 2</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">node_load1</span> <span class="string">&gt; (instance:node_cpus:count * 2) - 2</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">1</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">critical</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">CpuLoad</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"cpu负载大于2Cores-2: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>的cpu负载: <span class="template-variable">&#123;&#123; $value &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">主机上下文切换忙</span></span><br><span class="line">    <span class="comment">### expr: (rate(node_context_switches_total[5m])) / (count without(cpu, mode) (node_cpu_seconds_total&#123;mode="idle"&#125;)) &gt; 2000</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">(rate(node_context_switches_total[5m])</span> <span class="string">/</span> <span class="attr">instance:node_cpus:count)</span> <span class="string">&gt; 2000</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">5</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">warning</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"主机上下文切换忙: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"主机<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>的上下文切换大于2000/s: <span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>/s"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">node-memory</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line">  <span class="comment"># 内存可用率</span></span><br><span class="line"><span class="attr">  - record:</span> <span class="attr">instance:node_memory_available:ratio</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">      (</span></span><br><span class="line"><span class="string">        node_memory_MemAvailable_bytes or</span></span><br><span class="line"><span class="string">        (</span></span><br><span class="line"><span class="string">          node_memory_Buffers_bytes +</span></span><br><span class="line"><span class="string">          node_memory_Cached_bytes +</span></span><br><span class="line"><span class="string">          node_memory_MemFree_bytes +</span></span><br><span class="line"><span class="string">          node_memory_Slab_bytes</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">      ) /</span></span><br><span class="line"><span class="string">      node_memory_MemTotal_bytes</span></span><br><span class="line"><span class="string">  # 内存使用率</span></span><br><span class="line"><span class="string"></span><span class="attr">  - record:</span> <span class="attr">instance:node_memory_utilization:ratio</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="number">1</span> <span class="bullet">-</span> <span class="attr">instance:node_memory_available:ratio</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">主机内存面临压力</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">rate(node_vmstat_pgmajfault[1m])</span> <span class="string">&gt; 1000</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">5</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">warning</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"主机内存面临压力: <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"节点内存面临压力。High rate of major page faults: <span class="template-variable">&#123;&#123; $value &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">内存使用率大于85%</span></span><br><span class="line">    <span class="comment">### expr: (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 &gt; 85</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="attr">instance:node_memory_utilization:ratio</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt; 85</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">3</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">warning</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">MemoryUsage</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"内存使用率超过85%: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>的内存使用率: <span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>%"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">内存使用率大于90%</span></span><br><span class="line">    <span class="comment">### expr: (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 &gt; 90</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="attr">instance:node_memory_utilization:ratio</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt; 90</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">1</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">critical</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">MemoryUsage</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"内存使用率超过90%: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>的内存使用率: <span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>%"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">内存使用率一分钟内增长30%且大于70%</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">delta(instance:node_memory_utilization:ratio[2m])</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt; 30 and on(hostname) instance:node_memory_utilization:ratio * 100 &gt; 70</span></span><br><span class="line"><span class="string"></span><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">warning</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">MemoryUsageDelta</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"内存使用率一分钟内增长30%且大于70%: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span> 的内存使用率一分钟内增长30%且大于70%，增长率: <span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>%"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">内存使用率一分钟内增长40%且大于80%</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">delta(instance:node_memory_utilization:ratio[2m])</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt; 40 and on(hostname) instance:node_memory_utilization:ratio * 100 &gt; 80</span></span><br><span class="line"><span class="string"></span><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">critical</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">MemoryUsageDelta</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"内存使用率一分钟内增长40%且大于80%: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span> 的内存使用率一分钟内增长40%且大于80%，增长率: <span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>%"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">内存使用率一分钟内增长50%</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">delta(instance:node_memory_utilization:ratio[2m])</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt; 50</span></span><br><span class="line"><span class="string"></span><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">critical</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"内存使用率一分钟内增长50%: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span> 的内存使用率一分钟内增长50%，增长率: <span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>%"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">主机检测到oom</span> <span class="string">kill</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">      increase(node_vmstat_oom_kill[1h]) &gt; 2</span></span><br><span class="line"><span class="string">      or</span></span><br><span class="line"><span class="string">      increase(syslog_oom_kills_total[1h]) &gt; 2</span></span><br><span class="line"><span class="string"></span><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">warning</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"主机检测到oom kill: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>检测到oom kill: <span class="template-variable">&#123;&#123; $value &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">node-filesystem</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line">  <span class="comment"># 磁盘分区可用率</span></span><br><span class="line"><span class="attr">  - record:</span> <span class="attr">instance:node_filesystem_avail:ratio</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">node_filesystem_avail_bytes&#123;device=~"(/dev/.+|tank/dataset)"&#125;</span> <span class="string">/</span> <span class="string">node_filesystem_size_bytes&#123;device=~"(/dev/.+|tank/dataset)"&#125;</span></span><br><span class="line">  <span class="comment"># 磁盘分区使用率</span></span><br><span class="line"><span class="attr">  - record:</span> <span class="attr">instance:node_filesystem_utilization:ratio</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="number">1</span> <span class="bullet">-</span> <span class="attr">instance:node_filesystem_avail:ratio</span></span><br><span class="line">  <span class="comment"># 分区inode可用率</span></span><br><span class="line"><span class="attr">  - record:</span> <span class="attr">instance:node_filesystem_files_avail:ratio</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">node_filesystem_files_free</span> <span class="string">/</span> <span class="string">node_filesystem_files</span></span><br><span class="line">  <span class="comment"># 分区inode使用率</span></span><br><span class="line"><span class="attr">  - record:</span> <span class="attr">instance:node_filesystem_files_utilization:ratio</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="number">1</span> <span class="bullet">-</span> <span class="attr">instance:node_filesystem_files_avail:ratio</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">磁盘分区使用率大于85%</span></span><br><span class="line">    <span class="comment">### expr: (1- (node_filesystem_avail_bytes&#123;fstype=~"ext4|xfs"&#125; / node_filesystem_size_bytes&#123;fstype=~"ext4|xfs"&#125;)) * 100 &gt; 85</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="attr">instance:node_filesystem_utilization:ratio&#123;fstype=~"(ext.|xfs|zfs)"&#125;</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt; 85</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">10</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">warning</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.mountpoint &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"磁盘分区<span class="template-variable">&#123;&#123; $labels.mountpoint&#125;&#125;</span>使用率大于85%"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>的磁盘分区<span class="template-variable">&#123;&#123; $labels.mountpoint &#125;&#125;</span>使用率为: <span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>%"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">磁盘分区使用率大于90%</span></span><br><span class="line">    <span class="comment">### expr: (1- (node_filesystem_avail_bytes&#123;fstype=~"ext4|xfs"&#125; / node_filesystem_size_bytes&#123;fstype=~"ext4|xfs"&#125;)) * 100 &gt; 90</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="attr">instance:node_filesystem_utilization:ratio&#123;fstype=~"(ext.|xfs|zfs)"&#125;</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt; 90</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">3</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">critical</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.mountpoint &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"磁盘分区<span class="template-variable">&#123;&#123; $labels.mountpoint&#125;&#125;</span>使用率大于90%"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>的磁盘分区<span class="template-variable">&#123;&#123; $labels.mountpoint &#125;&#125;</span>使用率为: <span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>%"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">分区inode使用率大于70%</span></span><br><span class="line">    <span class="comment">### expr: (1 - (node_filesystem_files_free&#123;fstype=~"ext4|xfs"&#125; / node_filesystem_files&#123;fstype=~"ext4|xfs"&#125;)) * 100 &gt; 70</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="attr">instance:node_filesystem_files_utilization:ratio&#123;fstype=~"(ext.|xfs)"&#125;</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt; 70</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">3</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"磁盘分区<span class="template-variable">&#123;&#123; $labels.mountpoint &#125;&#125;</span>的inode使用率大于70%"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>的磁盘分区<span class="template-variable">&#123;&#123; $labels.mountpoint &#125;&#125;</span>的inode使用率: '<span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>%'"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">分区inode使用率大于80%</span></span><br><span class="line">    <span class="comment">### expr: (1 - (node_filesystem_files_free&#123;fstype=~"ext4|xfs"&#125; / node_filesystem_files&#123;fstype=~"ext4|xfs"&#125;)) * 100 &gt; 80</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="attr">instance:node_filesystem_files_utilization:ratio&#123;fstype=~"(ext.|xfs)"&#125;</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt; 80</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">3</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">warning</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"磁盘分区<span class="template-variable">&#123;&#123; $labels.mountpoint &#125;&#125;</span>的inode使用率大于80%"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>的磁盘分区<span class="template-variable">&#123;&#123; $labels.mountpoint &#125;&#125;</span>的inode使用率: '<span class="template-variable">&#123;&#123; $value | humanize &#125;&#125;</span>%'"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="进程探针配置"><a href="#进程探针配置" class="headerlink" title="进程探针配置"></a>进程探针配置</h2><p>process-exporter探针配置示例:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/ncabatoff/process-exporter</span></span><br><span class="line"><span class="comment"># /proc/&lt;pid&gt;/xxx</span></span><br><span class="line"><span class="attr">process_names:</span></span><br><span class="line">  <span class="comment"># java</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"<span class="template-variable">&#123;&#123;.Matches&#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    cmdline:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'.+/bin/java .+'</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"<span class="template-variable">&#123;&#123;.Matches&#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    cmdline:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'java .+'</span></span><br><span class="line">  <span class="comment">#匹配完整的运行命令</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"<span class="template-variable">&#123;&#123;.Matches&#125;&#125;</span>"</span></span><br><span class="line">  <span class="comment">#- name: "&#123;&#123;.Comm&#125;&#125;"</span></span><br><span class="line"><span class="attr">    cmdline:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'.+'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="进程告警规则"><a href="#进程告警规则" class="headerlink" title="进程告警规则"></a>进程告警规则</h2><p>prometheus进程告警规则示例:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">测试进程告警规则</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">nginx进程不存在</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">'sum(namedprocess_namegroup_states&#123;groupname=~"map\\[:nginx: master process .+"&#125;) without(state) == 0'</span></span><br><span class="line"><span class="attr">    for:</span> <span class="number">1</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">critical</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"nginx进程不存在, 实例: <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"主机: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>, 进程不存在: <span class="template-variable">&#123;&#123; $labels.groupname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      wxurl:</span> <span class="string">webhook1,webhook2</span></span><br><span class="line"><span class="attr">      mobile:</span> <span class="string">phone1,phone2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">filebeat进程不存在</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">sum</span> <span class="string">without(state)</span> <span class="string">(namedprocess_namegroup_states&#123;groupname=~"map\\[:/usr/share/filebeat/bin/filebeat</span> <span class="bullet">-e</span> <span class="bullet">-c</span> <span class="string">.+",</span> <span class="string">hostgroup="xxx"&#125;)</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    for:</span> <span class="number">1</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      severity:</span> <span class="string">critical</span></span><br><span class="line"><span class="attr">      level:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">"filebeat进程不存在, 实例: <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"主机: <span class="template-variable">&#123;&#123; $labels.hostname &#125;&#125;</span>, 进程不存在: <span class="template-variable">&#123;&#123; $labels.groupname &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      wxurl:</span> <span class="string">webhook1,webhook2</span></span><br><span class="line"><span class="attr">      mobile:</span> <span class="string">phone1,phone2</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><p>INSTRUMENTING</p><p><br></p><h2 id="客户端库"><a href="#客户端库" class="headerlink" title="客户端库"></a>客户端库</h2><p>CLIENT LIBRARIES: <a href="https://prometheus.io/docs/instrumenting/clientlibs/" target="_blank" rel="noopener">https://prometheus.io/docs/instrumenting/clientlibs/</a></p><p>在监控服务之前，您需要通过 Prometheus 客户端库在其代码中添加集成。</p><p>选择与你编程语言相匹配的prometheus client library。你可以通过你的应用程序实例的HTTP endpoint来定义和暴露内部指标数据。</p><p>当prometheus采集你实例的HTTP端点时，客户端库会将所有指标的当前状态发送给prometheus server。</p><p><br><br><br></p><h2 id="编写客户端库"><a href="#编写客户端库" class="headerlink" title="编写客户端库"></a>编写客户端库</h2><p>WRITING CLIENT LIBRARIES: <a href="https://prometheus.io/docs/instrumenting/writing_clientlibs/" target="_blank" rel="noopener">https://prometheus.io/docs/instrumenting/writing_clientlibs/</a></p><p>本章涵盖了Prometheus client libraries应该提供的功能和API。支持10种编程语言，因此编写客户端有很好的感觉。</p><p><br></p><h3 id="惯例"><a href="#惯例" class="headerlink" title="惯例"></a>惯例</h3><p>Conventions</p><p>应该注意的事：</p><ul><li>采取每门语言的优点</li><li>常见的使用情况应该很容易</li><li>做某事的正确方式应该是简单的方式</li><li>更复杂的用例应该是可能的</li></ul><p>常见用例：</p><ul><li>Counters without labels spread liberally around libraries/applications</li><li>Timing functions/blocks of code in Summaries/Histograms</li><li>Gauges to track current states of things (and their limits)</li><li>Monitoring of batch jobs</li></ul><p><br><br><br></p><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>Overall structure</p><p>客户端必须在内部进行回调以进行写操作。客户端一般应该遵循如下描述的结构。</p><p>关键类是收集器(collector)。这有个方法(一般称为collect)，此方法返回0和更多指标和样本。Collectors get registered with a CollectorRegistry. 数据通过传递一个CollectorRegistry到一个bridge类/方法/函数来公开，返回的是Promehteus支持的格式指标。每次CollectorRegistry抓取它必须回调每个收集器的收集方法。</p><p>大多数用户交互的接口是Counter, Gauge, Summary, Histogram收集器。这些代表一个单一指标，并应涵盖绝大多数使用情况，其中用户集成自己的代码。</p><p>更高级的用户案例（如从其它监控系统进行代理）需要编写一个自定义收集器。有人可能还希望编写一个bridge，以一个格式不同的监控系统来产生CollectorRegistry和生成数据，允许用户只考虑一个集成系统。</p><p>CollectorRegistry应该提供<code>register()</code>, <code>unregister()</code>函数，并且一个收集器应该被允许注册到多个CollectorRegistrys。</p><p>客户端必须是线程安全的。</p><p><br></p><p><strong>命名</strong></p><p>Namming</p><p>客户端库应遵循此文档中提及的函数，方法，类名称，记住它们的命名规范。例如，<code>set_to_current_time()</code>是一个好的Python命名规范，<code>SetToCurrentTime()</code>是一个好的Go命名规范，<code>setToCurrentTime()</code>是一个好的Java命名规范。</p><p><br><br><br></p><h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><p>Metrics</p><p>Counter, Gauge, Summary, Histogram指标类型是用户的主要接口。</p><p>Counter和Gauge必须是客户端库的一部分。Summary和Histogram至少有一个必须提供。</p><p>这些应主要用于为静态文件变量(file-static variables)，也就是说，全局变量定义在同一个文件，因为他们集成代码。客户端库应该启用它。常用情况是集成一段整体代码，而不是一个对象的一个实例的上下文中的一段代码。用户不应该在代码中担心探测他们的指标，客户端库应该代劳。</p><p>必须有一个默认的CollectorRegistry，默认的标准指标必须隐式注册到它与该用户不需要的特殊工作。必须有一个方式来让指标不注册到默认CollectorRegistry，在批处理作业和单元测试。自定义收集器应该遵顼这一点。</p><p>究竟编程语言应该如何创建指标。对于一些(Java, Go)构建器方法是最好的，对于其它(Python)函数参数是足够丰富的。</p><p>Java样例客户端:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YourClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Counter requests = Counter.build()</span><br><span class="line">      .name(<span class="string">"requests_total"</span>)</span><br><span class="line">      .help(<span class="string">"Requests."</span>).register();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Counter</strong></p><p>Counter是一个单调递增的计数器。它不允许值减少，但可能被重置为0（如服务器重启）。</p><p>计数器必须有以下方法：</p><ul><li><code>inc()</code>：计数器递增1</li><li><code>inc(douvel v)</code>：计数器由给定数增加（<code>v&gt;=0</code>）</li></ul><p>计数器必须从0开始。</p><p>计数器建议有：</p><ul><li>计算给定一段代码异常抛出/升起的方法，可选地仅特定异常类型</li></ul><p><br></p><p><strong>Gauge</strong></p><p>Gauge表示一个值可增可减。</p><p>测量必须有以下方法：</p><ul><li><code>inc()</code>：测量递增1</li><li><code>inc(double v)</code>：测量由给定数增加</li><li><code>dec()</code>：测量递减1</li><li><code>dec(double v)</code>：测量由戈丁数减少</li><li><code>set(double v)</code>：测量被设置为给定值</li></ul><p>测量必须从0开始，你也可以在启动时提供一个不同值。</p><p>测量应该有以下方法：</p><ul><li><code>set_to_current_time()</code>：将测量设置为unixtime</li></ul><p>测量建议有：</p><ul><li>使用一个方法来追踪某条函数/代码正在进行的请求。在Python中是<code>track_inprogress</code>。</li></ul><p>测试一段代码实践的一个方法和测试测量的持续时间。这对于批量作业很有用。</p><p><br></p><p><strong>Summary</strong></p><p>Summary样例观察滑动时间窗，兵器提供分布、频率、和的瞬时观察。</p><p>摘要绝不允许用户设置quantile作为标签名，因为这是内部使用的指定摘要总数(summary quantiles)。摘要鼓励提供quantiles作为exports，但这些都布恩那个进行聚合，并趋于缓慢。摘要必须允许每个quantiles，如<code>_count</code>, <code>_sum</code>是非常有用的，这必须是默认的。</p><p>摘要<code>_count</code>, <code>_sum</code>必须从0开始。</p><p>摘要必须有的方法：</p><ul><li><code>observe(double v)</code>：观察给定的量</li></ul><p>摘要应该有的方法：</p><ul><li>以秒为用户的时间码。在Python中是<code>time()</code>。不能提供除了秒之外的其它单位。</li></ul><p><br></p><p><strong>Histogram</strong></p><p>Histogram允许事件的可分布聚合，如请求的等待时间。</p><p>直方图绝不允许<code>le</code>作为用户设置的label，<code>le</code>用于内部指派桶。</p><p>直方图必须提供一个方式来手动选择桶。方式以<code>linear(start, width, count)</code>和<code>exponential(start, factor, count)</code>应该提供来设置桶。计数必须排除<code>+Inf</code>桶。</p><p>直方图应该有相同的默认桶作为其它客户端库。一旦创建了指标桶就不能改变。</p><p>直方图必须有的方法：</p><ul><li><code>observe(double v)</code></li></ul><p>直方图应该有的方法：</p><ul><li>以秒为用户的时间码。不能提供除了秒之外的其它单位。</li></ul><p><br></p><p><strong>标签</strong></p><p>Labels</p><p>标签是Prometheus最强大的一个方面，但容易被滥用。因此客户端库必须在提供标签给用户时必须非常小心。</p><p>客户端库必须在任何情况下让用户为Gauge, Counter, Summary, Histogram或其它由库提供的任意收集器有不同的标签名。</p><p>自定义收集器指标应该总是具有一致的标签名。客户端不该对此进行验证。</p><p>虽然标签很强大，但多数指标没有标签。因此，API应该允许标签，而不是控制它。</p><p>一个客户端库必须允许在Gauge, Counter, Summary, Histogram创建时间指定任意标签名的列表。客户端库应该支持任意数量的标签名。客户端库必须验证标签名称符合文件要求。</p><p>提供访问指标的标记尺寸的一般方法是通过<code>labels()</code>方法，它可以以标签指列表或从标签名到标签执的映射，并返回一个child。通常是<code>.inc()</code>, <code>.dec()</code>, <code>.observe()</code>等等。方法可以在child上调用。</p><p>通过<code>labels()</code>返回的Child应该由用户缓存，以避免再次看到它。</p><p>有标签的指标应该支持有相同签名作为<code>labels()</code>的<code>remove()</code>方法，这将从指标中移除一个child并不再公开它，<code>clear()</code>方法将移除指标的所有孩子。</p><p>这应该有一个方法，来初始化一个带有默认值的孩子，通常只是调用<code>labels()</code>。不带标签的指标必须总是被初始化，以避免缺失指标问题。</p><p><br></p><p><strong>指标名称</strong></p><p>Metric names</p><p>指标名称必须遵循规范。正如指标名称，这必须满足Gauge, Counter, Summary, Histogram的用途，并与该库提供的任意收集器。</p><p>许多客户端库提供三个部分来设置名称：<code>namespace_subsystem_name</code>。</p><p>动态/生成 指标名称或指标名子部分必须阻止，当一个自定义收集器从其它监控系统代理时除外。动态的/生成的 指标名称是你要使用的标签而不是一个标志。</p><p><br></p><p><strong>指标描述和帮助</strong></p><p>Metric description and help</p><p>Gauge/Counter/Summary/Histogram 必须要求提供指标描述和帮助。客户端库提供的任意自定义收集器必须在指标上有描述和帮助。</p><p><br><br><br></p><h3 id="公开"><a href="#公开" class="headerlink" title="公开"></a>公开</h3><p>Exposition</p><p>客户端必须执行基于文本的公开格式，详细文档: <a href="https://prometheus.io/docs/instrumenting/exposition_formats/" target="_blank" rel="noopener">https://prometheus.io/docs/instrumenting/exposition_formats/</a></p><p>公开的指标的可再现的顺序是鼓励的（尤其是以人类可读的格式），如果它可在没有显著资源成本增加来实现。</p><p><br><br><br></p><h3 id="标准和运行时收集器"><a href="#标准和运行时收集器" class="headerlink" title="标准和运行时收集器"></a>标准和运行时收集器</h3><p>Standard and runtime collectors</p><p>客户端库应该在标准导出中提供些什么，下面将介绍。</p><p>这些应该被实现为自定义收集器，并在默认的CollectorRegistry默认注册。应该有方式来禁用这些。</p><p><br></p><p><strong>进程指标</strong></p><p>Process metrics</p><p>这有一些以<code>process_</code>为前缀的指标。如果获得必要的值是有问题的，或甚至根本无法使用语言，或运行时，客户端库应该留出相应的指标或特殊值(如<code>NaN</code>)。所有以字节的内存值，所有以unixtime/seconds的时间。</p><div class="table-container"><table><thead><tr><th>指标名</th><th>帮助字符串</th><th>单位</th></tr></thead><tbody><tr><td><code>process_cpu_seconds_total</code></td><td>Total user and system CPU time spent in seconds</td><td>seconds</td></tr><tr><td><code>process_open_fds</code></td><td>Number of open file descriptors</td><td>file descriptors</td></tr><tr><td><code>process_max_fds</code></td><td>Maximum number of open file descriptors</td><td>file descriptors</td></tr><tr><td><code>process_virtual_memory_bytes</code></td><td>Virtual memory size in bytes</td><td>bytes</td></tr><tr><td><code>process_virtual_memory_max_bytes</code></td><td>Maximum amount of virtual memory available in bytes</td><td>bytes</td></tr><tr><td><code>process_resident_memory_bytes</code></td><td>Resident memory size in bytes</td><td>bytes</td></tr><tr><td><code>process_heap_bytes</code></td><td>Process heap size in bytes</td><td>bytes</td></tr><tr><td><code>process_start_time_seconds</code></td><td>Start time of the process since unix epoch in seconds</td><td>seconds</td></tr></tbody></table></div><p><br></p><p><strong>运行时指标</strong></p><p>Runtime metrics</p><p>此外，客户端库鼓励提供有意义的指标当语言运行时，如<code>go_</code>, <code>hotspot_</code>等等前缀开头的相关指标。</p><p><br><br><br></p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>Unit tests</p><p>客户端库应该有覆盖核心集成库和公开的单元测试。</p><p>客户端库鼓励提供一个方式，使用户更容易进行单元测试。例如，在Python中有<code>CollectorRegistry.get_sample_value</code>。</p><p><br><br><br></p><h3 id="打包和依赖"><a href="#打包和依赖" class="headerlink" title="打包和依赖"></a>打包和依赖</h3><p>Packaging and dependencies</p><p>理想情况下，客户端库可以被包括在任意应用程序中添加一些集成而不会破坏程序。因此，添加客户端库的依赖时请小心。</p><p><br><br><br></p><h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><p>Performance considerations</p><p>由于客户端库必须是线程安全的，需要某种形式的并发控制和考虑多核机器和应用程序的性能。</p><p>根据经验最少的高性能是互斥。处理器原子指令往往是在中间，并且一般是可接受的。</p><p>如上所述，<code>labels()</code>的结果应该是可缓存的。指标应该避免被阻塞当它们被递增或递减时。</p><p><br><br><br></p><h2 id="推送指标"><a href="#推送指标" class="headerlink" title="推送指标"></a>推送指标</h2><p>PUSHING METRICS: <a href="https://prometheus.io/docs/instrumenting/pushing/" target="_blank" rel="noopener">https://prometheus.io/docs/instrumenting/pushing/</a></p><p>偶尔，你需要监控不能被抓取的组件。Prometheus Pushgateway允许你推送指标。与Prometheus简单额基于文本格式相结合，这使得它很容易集成，甚至使用shell脚本而不需要客户端库。</p><p><br><br><br></p><h2 id="探针和集成"><a href="#探针和集成" class="headerlink" title="探针和集成"></a>探针和集成</h2><p>EXPORTERS AND INTEGRATIONS: <a href="https://prometheus.io/docs/instrumenting/exporters/" target="_blank" rel="noopener">https://prometheus.io/docs/instrumenting/exporters/</a></p><p>有许多库和第三方系统可为Prometheus提供相应的指标。</p><p><br></p><h3 id="第三方探针"><a href="#第三方探针" class="headerlink" title="第三方探针"></a>第三方探针</h3><p>Third-party exporters</p><p>有一些探针是由Prometheus官方维护的，其它的是由第三方贡献和维护。</p><p><br><br><br></p><h2 id="编写探针"><a href="#编写探针" class="headerlink" title="编写探针"></a>编写探针</h2><p>WRITING EXPORTERS: <a href="https://prometheus.io/docs/instrumenting/writing_exporters/" target="_blank" rel="noopener">https://prometheus.io/docs/instrumenting/writing_exporters/</a></p><p>如果你在集成自己的代码，那么Prometheus client library如何集成自己的代码的通用规则应该被遵守。当从另一个监控或集成系统采取指标时，事情往往并不是非黑即白。</p><p>当编写一个探针或自定义收集器时，此文档包含的事情你应该考虑。</p><p><br><br><br></p><h3 id="可维护性和纯度"><a href="#可维护性和纯度" class="headerlink" title="可维护性和纯度"></a>可维护性和纯度</h3><p>Maintainability and purity</p><p>当你编写一个探针时，你需要做出的一个决定是有多少工作你愿意放在获得完美的指标上。</p><p>如果有问题的系统只有很少改变的指标的一小撮，然后让一切完美是一个容易的选择，一个好的样例是<a href="https://github.com/prometheus/haproxy_exporter" target="_blank" rel="noopener">HAProxy exporter</a></p><p>在另一方面，当系统上有上百个指标是新版本经常变动的，如果你想试图把事情做完美，那么你已经给自己制造了许多正在进行的工作。<a href="https://github.com/prometheus/mysqld_exporter" target="_blank" rel="noopener">MysQL exporter</a>在这系列(spectrum)的末端。</p><p><a href="https://github.com/prometheus/node_exporter" target="_blank" rel="noopener">node exporter</a>是这些的混合。例如，<code>mdadm</code>收集器手动解析一个文件并公开为此收集器特定创建的指标。对于<code>meminfo</code>收集器，结果跨越不同内核版本，因此我们最终做足够的转换来创建有效的指标。</p><p><br><br><br></p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>Configuration</p><p>当程序工作时，你的目标应该是探针不需要用户自定配置就可以运行。你可能还希望提供过滤某些指标的能力（用户定义只需要收集的指标，不需要收集所有指标），降低系统的开销。例如node exporter可让用户定义收集哪些指标，虽然我是全部收集。</p><p>当与其它监控系统一起工作时，框架和协议，你将提供额外的配置或自定义来生成适合Prometheus的指标。在最好的情况下，一个监控系统有类似的足够的Prometheus数据模型，你可以自动确定如何转换指标。如Cloudwatch, SNMP, collectd的情况。至多，我们需要让用户选择获取的那些指标。</p><p>也就是探针配置简单化，探针指标用户可选择。</p><p>在其它情况下，系统指标是不是十分标准的，这却决于系统和底层应用的使用情况。在这种情况下，用户必须告诉我们如何转换转换指标。<a href="https://github.com/prometheus/jmx_exporter" target="_blank" rel="noopener">JMX exporter</a>是最明显的案例，与<a href="https://github.com/prometheus/graphite_exporter" target="_blank" rel="noopener">Graphite exporter</a>和<a href="https://github.com/prometheus/statsd_exporter" target="_blank" rel="noopener">StatsD exporter</a>也需要配置来提取标签。</p><p>确保探针出口开箱没有配置，以及提供需要转换的示例配置的选择，这是一个建议。</p><p>YAML是标准的Prometheus配置格式，所有配置默认都应该适应YAML。</p><p><br><br><br></p><h3 id="指标-1"><a href="#指标-1" class="headerlink" title="指标"></a>指标</h3><p>Metrics</p><p><br></p><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>Naming</p><p>遵循指标命名的最佳实践。</p><p>指标名不应该由程序产生，除非在编写自定义收集器或探针时。</p><p>指标必须使用基础单位并让它们转换为更可读的图形工具。无论你使用了什么单位，指标名中的单位必须匹配在使用的单位。类似地，公开比率(ratios)，而不是百分比(percentages)。</p><p>指标名不应该包含导出的标签，如果标签被聚集将没有意义。Prometheus指标和标签名以<code>snake_case</code>编写。公开的指标不应包含冒号，这些被保留用于用户定义记录规则(recording rules)，当使用聚合时。</p><p>只有<code>[a-zA-Z0-9:_]</code>是有效的指标名。</p><p><code>_sum</code>, <code>_count</code>, <code>_bucket</code>, <code>_total</code>后缀用于Summary, Histogram, Counter。<code>_total</code>是Counter的惯例，如果你使用COUNTER类型你应该使用它。</p><p><code>process_</code>, <code>scrape_</code>前缀是保留的。</p><p>当你有一个successful request count和一个failed request count，最佳的方式是一个指标用于成功的请求，另一个指标用于失败的请求。这很容易计算出失败率。不要使用带success或failed标签的一个指标。同样，此规则也同样适用于其它指标。</p><p>一个带有原始名的<code>HELP</code>字符串可以提供大部分相同的好处。</p><p><br><br><br></p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>Labels</p><p>避免将type作为标签名称，它过于笼统往往无意义。你应该尝试尽可能地避免发生冲突，如<code>region</code>, <code>cluster</code>等等。但是，如果这就是应用程序调用的一些资源，最好不要通过重命名来引起混乱。</p><p>因此要避免把东西放入一个指标，只是因为它们共享一个前缀。除非你确定一个指标是有意义的，多个指标是安全的。</p><p><code>le</code>标签对于Histogram有特殊意义，<code>quantile</code>标签对于Summary有特殊意义。通常避免使用这些标签。write/read， send/receive最好划分为单独的指标，而不是一个指标。</p><p>经验法则是，当求和或求平均值时，一个指标应该是有意义的。</p><p><br><br><br></p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>Type</p><p>你应该尝试匹配你的指标类型到Prometheus类型。这通常是counters和gauges。通常它不会很明显指标是什么类型，特别是如果你自动处理一组指标。一般<code>UNTYPED</code>是一个安全的默认值。</p><p><br><br><br></p><h4 id="帮助字符串"><a href="#帮助字符串" class="headerlink" title="帮助字符串"></a>帮助字符串</h4><p>Help strings</p><p>当你转换指标时，它对用于能够追踪原来是什么样的有帮助，以及造成这种转换有什么规则。将收集器或探针名称、应用的任意规则的ID和名称和原始指标的详情写入帮助字符串将极大地帮助用户。</p><p>Prometheus不喜欢一个字段有不同的帮助字符串。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># HELP node_cooling_device_max_state Maximum throttle state of the cooling device</span><br><span class="line"># TYPE node_cooling_device_max_state gauge</span><br><span class="line">node_cooling_device_max_state&#123;name=&quot;0&quot;,type=&quot;Processor&quot;&#125; 7</span><br><span class="line">node_cooling_device_max_state&#123;name=&quot;1&quot;,type=&quot;Processor&quot;&#125; 7</span><br><span class="line">node_cooling_device_max_state&#123;name=&quot;2&quot;,type=&quot;Processor&quot;&#125; 7</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="丢弃更少的有用信息"><a href="#丢弃更少的有用信息" class="headerlink" title="丢弃更少的有用信息"></a>丢弃更少的有用信息</h4><p>Drop less useful statistics</p><p>有些集成系统公开了1m, 5m, 15m率、平均率，在应用程序启动的时候。</p><p>这些都应该被丢弃，因为它们不是很有用，并添加了混乱。Prometheus可以自己计算比率，并且通常作为公开的平均值呈指数衰减。</p><p><br><br><br></p><h4 id="点字符串"><a href="#点字符串" class="headerlink" title="点字符串"></a>点字符串</h4><p>Dotted strings</p><p>许多监控系统没有标签，而是使用点: <code>my.class.path.mymetric.labelvalue1.labelvalue2.labelvalue3</code></p><p><br><br><br></p><h3 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h3><p>Collectors</p><p>当为探针实现收集器时，你永远不应该使用通常的直接集成方法，并在每个抓取上更新指标。</p><p>每次创建新的指标。在Go的<code>Collect()</code>方法中使用<code>MustNewConstMetric</code>。Python请参考: <a href="https://github.com/prometheus/client_python#custom-collectors" target="_blank" rel="noopener">https://github.com/prometheus/client_python#custom-collectors</a></p><p>原因有两方面。首先，两个抓取可能发生在同一时间，和直接集成使用的什么是文件级别的全局变量。其次，如果一个标签执消失，它仍然将公开。</p><p><br></p><h4 id="关于抓取自身的指标"><a href="#关于抓取自身的指标" class="headerlink" title="关于抓取自身的指标"></a>关于抓取自身的指标</h4><p>Metrics about the scrape itself</p><p>有时你想导出关于抓取的指标，如处理了多少记录等。这应该被公开为gauges当它们关于事件时，通过探针名的指标名前缀，如<code>jmx_scrape_duration_seconds</code>。</p><p><br><br><br></p><h4 id="机器和进程指标"><a href="#机器和进程指标" class="headerlink" title="机器和进程指标"></a>机器和进程指标</h4><p>Machine and process metrics</p><p>许多系统，如ES，会公开机器指标（如cpu, memory, filesystem）等信息。Prometheus生态中的node exporter提供了这些信息，这些指标就应该被丢弃。</p><p>在Java世界里，许多集成框架公开了程序级别和JVM级别的统计信息，如CPU, GC等。Java客户端和JMX探针已包含这些，所以也应该丢弃。这同样也可用于其它类似的语言和框架。</p><p><br><br><br></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>Deployment</p><p>每个探针应该监控只有一个实例的应用程序，preferably sitting right beside it on the same machine。这意味着你运行没给一个HAProxy，你运行了一个<code>haproxy_exporter</code>进程。</p><p><br></p><h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p>Scheduling</p><p>当Prometheus抓取指标时，指标应该从应用处拉取，探针不应该基于自己的定时器执行抓取。也就是说，所有的抓取都应该是同步的(synchronous)。</p><p>因此，你不应该在公开的指标上设置时间戳，而让Prometheus来做。如果你认为需要时间戳，那么你可能需要使用pushgateway来代替。</p><p>如果检索指标特别昂贵，即超过了一分钟，可以接受的是缓存它(cache it)。这应该在注释在HELP字符串中。</p><p>Prometheus默认抓取的超时时间是10s。如果你的探针希望超过这一点，你应该在你的用户文档中明确的调用此。</p><p><br><br><br></p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>Pushes</p><p>有些应用程序和监控系统只能推送指标(push metrics)，如StatsD, Graphite, collectd。有两方面的考虑：</p><p>首先，指标什么时候过期？<br>其次，这些类型的系统倾向于允许你的用户发送变化量(deltas)或原始计数器(raw counter)。你应该尽可能依赖原生计数器，因为这一般是Prometheus model。</p><p>对于服务级别的指标，你应该有探针推送到Pushgateway，在事件而不是你自己处理状态之后退出。对于实例级别的指标，还没有明确模式。</p><p><br><br><br></p><h4 id="抓取失败"><a href="#抓取失败" class="headerlink" title="抓取失败"></a>抓取失败</h4><p>Failed scrapes</p><p>目前有两种模式的抓取失败，当应用程序不响应或其它问题时。</p><p>第一个就是返回<code>5xx</code>错误。</p><p>第二个是有一个<code>myexporter_up</code>，如<code>haproxy_up</code>，值是0还是1依赖于抓取工作。</p><p>后者更好，即使抓取失败，你还可以得到一些有用的指标。</p><p><br><br><br></p><h4 id="抓取页面"><a href="#抓取页面" class="headerlink" title="抓取页面"></a>抓取页面</h4><p>Landing page</p><p>访问地址，如<code>http://expoter:port</code>作为一个简单的包含探针名称的HTML页面，并有指向<code>/metrics</code>页面的链接。</p><p><br><br><br></p><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>Port numbers</p><p>用户在一个机器上可能有多个探针和Prometheus组件，为了使得事情更简单每个需要有一个唯一的端口号。这个页面<a href="https://github.com/prometheus/prometheus/wiki/Default-port-allocations" target="_blank" rel="noopener">https://github.com/prometheus/prometheus/wiki/Default-port-allocations</a>包含了Prometheus组件和探针目前使用的端口号。</p><p>为自己的探针分配一个合理的，没有使用的端口号。</p><p><br><br><br></p><h3 id="宣布"><a href="#宣布" class="headerlink" title="宣布"></a>宣布</h3><p>Announcing</p><p>一旦你准备向世界宣布你的探针，请在<a href="https://github.com/prometheus/docs/blob/master/content/docs/instrumenting/exporters.md" target="_blank" rel="noopener">可用的探针列表</a>提交一个PR。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>BEST PRACTICES</p><p><br></p><h2 id="指标和标签命名"><a href="#指标和标签命名" class="headerlink" title="指标和标签命名"></a>指标和标签命名</h2><p>METRIC AND LABEL NAMING: <a href="https://prometheus.io/docs/practices/naming/" target="_blank" rel="noopener">https://prometheus.io/docs/practices/naming/</a></p><p>指标和标签的约定不需要使用Prometheus，但可以作为一个风格指南和最佳实践的集合。</p><p><br></p><h3 id="指标名称"><a href="#指标名称" class="headerlink" title="指标名称"></a>指标名称</h3><p>Metric names</p><p>一个指标名称：</p><ul><li>必须符合有效字符的数据模型</li><li>应该有一个应用程序(single-word)相关的指标所属前缀。如：<ul><li><code>prometheus_notifications_total</code></li><li><code>process_cpu_seconds_total</code></li><li><code>http_request_duration_seconds</code></li></ul></li><li>必须有一个单一的单位（如秒，毫秒等）</li><li>应该使用基本单位（如seconds, bytes, meters，而不是milliseconds, megabytes, kilometers）</li><li>应该有一个描述单位的后缀。如：<ul><li><code>http_request_duration_seconds</code></li><li><code>node_memory_usage_bytes</code></li><li><code>http_requests_total</code></li><li><code>process_cpu_seconds_total</code></li><li><code>foobar_build_info</code></li></ul></li><li>should represent the same logical thing-being-measured across all label dimensions<ul><li>request duration</li><li>bytes of data transfer</li><li>instantaneous resource usage as a percentage</li></ul></li></ul><p>作为一个经验，在给定指标的所有尺寸上，无论是<code>sum()</code>还是<code>avg()</code>都应该是有意义的。如果没有意义，则将数据分裂成多个指标。</p><p><br><br><br></p><h3 id="标签-1"><a href="#标签-1" class="headerlink" title="标签"></a>标签</h3><p>Labels</p><p>使用标签来区分被测量的事物的特点：</p><ul><li><code>api_http_requests_total</code>，不同的请求类型：<code>operation=&quot;create|update|delete&quot;</code></li><li><code>api_request_duration_seconds</code>，不同的请求阶段：<code>stage=&quot;extract|transform|load&quot;</code></li></ul><p>不要将标签名对应到指标名，如果相应的标签聚合了，这会冗余并造成混乱。</p><blockquote><p>注意：<br>请记住，标签键值对每一个独特的组合代表了一个新的时间序列，这可能会极大的提高存储的数据量。不要使用标签来存储高基数，如用户ID，邮件地址等。</p></blockquote><p><br><br><br></p><h3 id="基本单位"><a href="#基本单位" class="headerlink" title="基本单位"></a>基本单位</h3><p>Base units</p><p>Prometheus没有硬编码任何单位。为了更好的兼容性，应该使用基本单位。以下是一些栗子：</p><div class="table-container"><table><thead><tr><th>Family</th><th>Base unit</th><th>Remark</th></tr></thead><tbody><tr><td>Time</td><td>seconds</td><td>-</td></tr><tr><td>Temperature</td><td>celsius</td><td>摄氏度优于开尔文</td></tr><tr><td>Length</td><td>meters</td><td>-</td></tr><tr><td>Bytes</td><td>bytes</td><td>-</td></tr><tr><td>Bits</td><td>bytes</td><td>为了避免混淆，通常使用bytes</td></tr><tr><td>Percent</td><td>ratio</td><td>0-1而不是0-100</td></tr><tr><td>Voltage</td><td>volts</td><td>-</td></tr><tr><td>Electric current</td><td>amperes</td><td>-</td></tr><tr><td>Energy</td><td>joules</td><td>-</td></tr><tr><td>Mass</td><td>grams</td><td>克优于千克</td></tr></tbody></table></div><p><br><br><br></p><p><br><br><br></p><h2 id="控制台和仪表盘"><a href="#控制台和仪表盘" class="headerlink" title="控制台和仪表盘"></a>控制台和仪表盘</h2><p>CONSOLES AND DASHBOARDS: <a href="https://prometheus.io/docs/practices/consoles/" target="_blank" rel="noopener">https://prometheus.io/docs/practices/consoles/</a></p><p>可在仪表盘上显示尽可能多的数据，特别是像Prometheus这样的系统提供了集成你的应用程序的能力。</p><p>我们发现以下原则非常有效：</p><ul><li>在一个控制台上不要超过五个图</li><li>每个图上不要超过五个线</li><li>当使用控制台提供的模板示例，请避免在右边表超过20-30项</li></ul><p><br><br><br></p><h2 id="集成-1"><a href="#集成-1" class="headerlink" title="集成"></a>集成</h2><p>INSTRUMENTATION: <a href="https://prometheus.io/docs/practices/instrumentation/" target="_blank" rel="noopener">https://prometheus.io/docs/practices/instrumentation/</a></p><p>本章提供了集成你的代码的一套指导方案。</p><p><br></p><h3 id="如何集成"><a href="#如何集成" class="headerlink" title="如何集成"></a>如何集成</h3><p>How to instrument</p><p>简短的回答是集成一切。每个库、子系统和服务应该至少有几个指标来给你一个粗略的想法它是如何执行的。</p><p><br></p><h4 id="服务的三种类型"><a href="#服务的三种类型" class="headerlink" title="服务的三种类型"></a>服务的三种类型</h4><p>The three types of services</p><p>为了监控的目的，服务大致可以分为三类：在线服务(online-serving)，离线处理(offline-processing)，批处理作业(batch jobs)。它们之间有重叠，但每个服务往往很好地成为这些类别。</p><p><br></p><p><strong>在线服务系统</strong></p><p>Online-serving systems</p><p>一个在线服务系统期待立即响应。例如，大多数数据库和HTTP请求都属于这一类。这种系统的关键指标是执行的查询数，错误和延迟。</p><p><br></p><p><strong>离线处理</strong></p><p>Offline processing</p><p>对于离线处理，没有人正在等待响应。也可能有多个处理阶段。对于每一个阶段，跟踪进入的项目，有多少在处理，最后一次处理的事物，以及发送了多少事物。</p><p><br></p><p><strong>批处理作业</strong></p><p>Batch jobs</p><p>在离线处理和批处理作业之间有一些模糊线，离线处理也可在批处理作业中完成。批处理作业不连续运行，这使得它们难以区分。</p><p>批处理作业的关键指标是它最后一次成功。这对于追踪各个阶段的花费时间，整体运行和最后一次作业完成很有用。对于那些超过几分钟时间运行的批处理作业，使用基于Pull监控的数据抓取很有用。对于运行很频繁地批处理作业，你应该考虑将其转换为守护程序(daemons)，作为离线处理作业来处理它们。</p><p><br><br><br></p><h4 id="子系统"><a href="#子系统" class="headerlink" title="子系统"></a>子系统</h4><p>Subsystems</p><p>除了三种主要类型的服务，系统也应该监控子部分(sub-parts)。</p><p><br></p><p><strong>库</strong></p><p>Libraries</p><p>库应该提供无需用户额外配置的集成。</p><p>如果一个库经常访问进程外的资源（如网络、磁盘、IPC…），追踪整个查询计数，错误和延迟。</p><p><br></p><p><strong>日志</strong></p><p>Logging</p><p>作为一般规则，对与日志代码的每一行，你应该有一个递增的计数器(counter)。如果你发现一个有趣的日志信息，你要能过够看到它如何发生，而且持续多久。</p><p><br></p><p><strong>失败</strong></p><p>Failures</p><p>故障应该与日志有相似的处理。每次出现故障，计数器(counter)都应增加。不像日志，取决于你的代码结构，错误也可以丢到一个更普遍的错误计数器。当报告故障，你通常应该有一些其它指标来表示尝试的总数。这使得故障率很容易计算。</p><p><br></p><p><strong>线程池</strong></p><p>Threadpools</p><p>对于任何形式的线程池，关键指标是排队请求数，在使用的线程数，总线程数，处理的任务数，以及它们耗时多久。</p><p><br></p><p><strong>缓存</strong></p><p>Caches</p><p>缓存的关键指标是总查询、点击、总延时、查询数、错误和任何在线服务缓存前的延迟。</p><p><strong>收集器</strong></p><p>Collectors</p><p>当实现一个自定义指标收集器时，建议为收集花费的时间(s)导出为gauge，另一个是遇到的错误的数量。</p><p><br><br><br></p><h3 id="要提防的事"><a href="#要提防的事" class="headerlink" title="要提防的事"></a>要提防的事</h3><p>Things to watch out for</p><p>当做监控时，有些事需要注意，Prometheus-specific尤其如此。</p><p><br></p><h4 id="使用标签"><a href="#使用标签" class="headerlink" title="使用标签"></a>使用标签</h4><p>Use labels</p><p>很少有监控系统有标签和表达式语言的来利用这些优点，所以需要一些时间来使用。当你有多个指标要添加/求平均值/求和，它们通常是带有标签的指标，而不是多个指标。</p><p>例如，创建一个带有<code>code</code>标签的<code>http_responses_total</code>指标，而不是<code>http_responses_500_total</code>，<code>http_responses_403_total</code>两个指标。</p><p><br><br><br></p><h4 id="不要滥用标签"><a href="#不要滥用标签" class="headerlink" title="不要滥用标签"></a>不要滥用标签</h4><p>Do not overuse labels</p><p>每个标签集(labelset)是具有RAM, CPU, disk, network开销的额外时间序列。通常情况下，开销可以忽略不计，但有很多机器和很多指标和很多标签的情况下，这可能会迅速增加。</p><p>作为一般原则，尽量保持指标的基础低于10。绝大多数的指标没有任何标签。如果你有一个有100多个基数的指标，调查替代解决方案。</p><p>为了让你对基数有一个更好的主意，让我们来看下<code>node_exporter</code>。节点探针公开每个挂载的文件系统的指标。如果你有10000台机器，有10000个<code>node_filesystem_avail</code>时间序列，这对于Prometheus处理很好。</p><p>如果你不确定，就不用标签，并随着时间的推移添加更多标签。</p><p><br><br><br></p><h4 id="四种类型比较"><a href="#四种类型比较" class="headerlink" title="四种类型比较"></a>四种类型比较</h4><p>Counter vs. gauge, summary vs. histogram</p><p>对一个给定的指标用哪个四种主要的指标类型是很重要的。</p><p>在Counter和Gauge之间选择，有一个简单的经验法则：如果值可减少，这是一个Gauge。Counter只能增加，如累积的量。Gauge可以设置，增加或减少。</p><p>Summaries和Histograms是更复杂的指标类型。</p><p><br><br><br></p><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>Timestamps, not time since</p><p>如果你想追踪从某事发生时的时间量，导出在它发生时的Unix时间戳，而不是从它发生的时间。</p><p>导出了时间戳，可以使用<code>time() - my_timestamp_metric</code>表达式计算时间。</p><p><br><br><br></p><h4 id="避免缺失指标"><a href="#避免缺失指标" class="headerlink" title="避免缺失指标"></a>避免缺失指标</h4><p>Avoid missing metrics</p><p>时间序列，直到某事发生不存在难以应付，因为通常的简单操作不足以正确处理它们。为了避免这种情况，你事先知道可能存在的任何时间序列输出为0(或NaN)。</p><p>大多数Prometheus Client Libraries(go, java, python)会为没有标签的指标自动导出0。</p><p><br><br><br><br><br></p><h2 id="Hisgogram和Summary"><a href="#Hisgogram和Summary" class="headerlink" title="Hisgogram和Summary"></a>Hisgogram和Summary</h2><p>HISTOGRAMS AND SUMMARIES: <a href="https://prometheus.io/docs/practices/histograms/" target="_blank" rel="noopener">https://prometheus.io/docs/practices/histograms/</a></p><p><br><br><br><br><br></p><h2 id="告警-1"><a href="#告警-1" class="headerlink" title="告警"></a>告警</h2><p>ALERTING: <a href="https://prometheus.io/docs/practices/alerting/" target="_blank" rel="noopener">https://prometheus.io/docs/practices/alerting/</a></p><p>请先阅读<a href="https://docs.google.com/document/d/199PqyG3UsyXlwieHaqbGiWVa8eMWi8zzAn0YfcApr8Q/edit" target="_blank" rel="noopener">My Philosophy on Alerting</a></p><p><br></p><h3 id="告警什么"><a href="#告警什么" class="headerlink" title="告警什么"></a>告警什么</h3><p>What to alert on</p><p>目标是告警越少越好，告警要有目的，别瞎告。告警应该很容易找到哪些部件的故障。</p><p><br><br><br><br><br></p><h2 id="记录规则-2"><a href="#记录规则-2" class="headerlink" title="记录规则"></a>记录规则</h2><p>RECORDING RULES: <a href="https://prometheus.io/docs/practices/rules/" target="_blank" rel="noopener">https://prometheus.io/docs/practices/rules/</a></p><p>记录规则的一致性命名方案，可以一目了然地理解规则的含义。本节可以正确聚合和建议命名规范。</p><p><br></p><h3 id="命名和聚合"><a href="#命名和聚合" class="headerlink" title="命名和聚合"></a>命名和聚合</h3><p>Naming and aggregation</p><p>记录规则(recording rules)应该是这样的一般形式：<code>level:metric:operations</code>。level表示聚合级别和规则输出的标签；metric是指标名称并在使用<code>rate()</code>这些方法时应该保持不变；operations是一个应用到指标的操作列表。</p><p>保持指标名称不变，使得易于知道指标是什么和容易在代码库中找到它。</p><p>如一些常见的: <code>sum</code>, <code>ratio</code>, <code>count</code>这些。</p><p><br><br><br></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- record:</span> <span class="attr">instance_path:requests:rate5m</span></span><br><span class="line"><span class="attr">  expr:</span> <span class="string">rate(requests_total&#123;job="myjob"&#125;[5m])</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- record:</span> <span class="attr">path:requests:rate5m</span></span><br><span class="line"><span class="attr">  expr:</span> <span class="string">sum</span> <span class="string">without</span> <span class="string">(instance)(instance_path:requests:rate5m&#123;job="myjob"&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- record:</span> <span class="attr">instance_path:request_failures:rate5m</span></span><br><span class="line"><span class="attr">  expr:</span> <span class="string">rate(request_failures_total&#123;job="myjob"&#125;[5m])</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- record:</span> <span class="attr">instance_path:request_failures_per_requests:ratio_rate5m</span></span><br><span class="line"><span class="attr">  expr:</span> <span class="string">|2</span></span><br><span class="line"><span class="attr">      instance_path:</span><span class="attr">request_failures:rate5m&#123;job="myjob"&#125;</span></span><br><span class="line">    <span class="string">/</span></span><br><span class="line"><span class="attr">      instance_path:</span><span class="attr">requests:rate5m&#123;job="myjob"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- record:</span> <span class="attr">job:request_latency_seconds_count:avg_rate5m</span></span><br><span class="line"><span class="attr">  expr:</span> <span class="string">avg</span> <span class="string">without</span> <span class="string">(instance,</span> <span class="string">path)(instance:request_latency_seconds_count:rate5m&#123;job="myjob"&#125;)</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="Pushgateway"><a href="#Pushgateway" class="headerlink" title="Pushgateway"></a>Pushgateway</h2><p>WHEN TO USE THE PUSHGATEWAY: <a href="https://prometheus.io/docs/practices/pushing/" target="_blank" rel="noopener">https://prometheus.io/docs/practices/pushing/</a></p><p>Pushgateway是一个中间服务，允许你从无法抓取的作业处推送指标。更多详情，查看<a href="https://prometheus.io/docs/instrumenting/pushing/" target="_blank" rel="noopener">push metrics</a></p><p><br></p><h3 id="应该使用Pushgateway吗"><a href="#应该使用Pushgateway吗" class="headerlink" title="应该使用Pushgateway吗"></a>应该使用Pushgateway吗</h3><p>Should I be using the Pushgateway?</p><p>我们只建议在某些有限的示例中使用Pushgateway。盲目地使用Pushgateway push来代替Prometheus pull有几个陷阱：</p><ul><li>通过Pushgateway监控多个实例，Pushgateway成为单一的失败点和潜在的瓶颈。</li><li>你失去了Prometheus通过<code>up</code>自动检测实例健康。</li><li>Pushgateway永远不会忘记推送它，并公开它们给Prometheus，除非这些序列通过PushgatewayApi手动删除。</li></ul><p>如果原始实例重命名或删除，实例的指标将保留在Pushgateway中。这是因为PushGateway作为指标缓存的生命周期与推送指标的进程的生命周期分开。与Prometheus pull方式对比时，当一个实例消失时，实例的指标将自动消失。使用Pushgateway时，不不是这种情况，你必须手动删除任何陈旧的指标，或自动执行生命周期同步。</p><p>通常，Pushgateway的唯一有效用例是用于捕获一个服务级别的批处理作业的结果(outcome)。一个服务级别的批处理作业是与特定机器或作业实例相关的。这样的作业的指标不应包含一个机器或实例标签，以将特定机器的生命周期与推送指标的实例分开。这降低了管理Pushgateway中的陈旧指标的负担。</p><p><br><br><br></p><h3 id="替代策略"><a href="#替代策略" class="headerlink" title="替代策略"></a>替代策略</h3><p>Alternative strategies</p><p>如果入站防火墙和NAT阻止您从目标机器抓取指标，考虑将Prometheus Server移动到网络后面。我们通常建议在同一网络上运行Prometheus Server来作为监控实例。否则，考虑<a href="https://github.com/prometheus-community/PushProx" target="_blank" rel="noopener">PushProx</a>，它允许Prometheus跨过防火墙或NAT。</p><p><br><br><br><br><br></p><h2 id="远程存储"><a href="#远程存储" class="headerlink" title="远程存储"></a>远程存储</h2><p>REMOTE WRITE TUNING: <a href="https://prometheus.io/docs/practices/remote_write/" target="_blank" rel="noopener">https://prometheus.io/docs/practices/remote_write/</a></p><p>Prometheus实现了合理的默认远程写，但许多用户有不同的要求，并希望优化远程设置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Prometheus文档： &lt;a href=&quot;https://prometheus.io/docs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://prometheus.io/docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub: &lt;a href=&quot;https://github.com/prometheus/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/prometheus/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PrometheusAlert: &lt;a href=&quot;https://github.com/feiyu563/PrometheusAlert&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/feiyu563/PrometheusAlert&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7x86_64&lt;/li&gt;
&lt;li&gt;Prometheus v2.14&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="DevOps" scheme="https://zhang21.github.io/tags/DevOps/"/>
    
      <category term="Prometheus" scheme="https://zhang21.github.io/tags/Prometheus/"/>
    
      <category term="Monitor" scheme="https://zhang21.github.io/tags/Monitor/"/>
    
      <category term="Alert" scheme="https://zhang21.github.io/tags/Alert/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://zhang21.github.io/2018/03/27/Docker/"/>
    <id>https://zhang21.github.io/2018/03/27/Docker/</id>
    <published>2018-03-27T00:38:33.000Z</published>
    <updated>2018-07-08T04:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>Docker文档:  <a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></li><li><a href="https://blog.csdn.net/sD7O95O/article/details/78623697" target="_blank" rel="noopener">https://blog.csdn.net/sD7O95O/article/details/78623697</a></li><li><a href="https://www.zhihu.com/question/22969309/answer/34030581" target="_blank" rel="noopener">https://www.zhihu.com/question/22969309/answer/34030581</a></li></ul><p>环境：</p><ul><li>CentOS7x86_64</li><li>Docker v18.03</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br><br><br></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Docker是一个开发、shipping、运行应用程序的开放平台。Docker使你能够将应用程序与基础架构(infrastructure)分离开，从而可以快速交付软件。借助Docker，你可以像管理应用程序一样管理基础架构。利用Docker的方法快速进行运输、测试和部署代码，可以显著缩短编写代码和在生存环境中运行代码之间的延迟。</p><p><br></p><h2 id="Docker平台"><a href="#Docker平台" class="headerlink" title="Docker平台"></a>Docker平台</h2><p>Docker提供了在称为容器的松散隔离(isolated)环境中 打包和运行应用程序的能力。隔离性和安全性允许你在给定的主机上同时运行多个容器。容器是轻量级(lightweight)的，因为它们不需要hypervisor的额外负载，而是直接使用主机的内核运行。这意味着，与使用虚拟机相比，你可以在给定的硬件组合上运行更多的容器。你甚至可以在虚拟主机中运行Docker容器。</p><p>Docker提供了工具和平台来管理容器的生命周期(lifecycle)：</p><ul><li>使用容器开发应用程序及其支持组件</li><li>容器成为分发和测试你应用程序的单元</li><li>准备好后，将你的应用程序部署到生产环境中，作为容器协调服</li></ul><p><br></p><h2 id="Docker引擎"><a href="#Docker引擎" class="headerlink" title="Docker引擎"></a>Docker引擎</h2><p>Docker引擎是一个包含如下部件的client-server应用程序：</p><ul><li>Server是称为守护进程的dockerd</li><li>REST API是指定程序可用于与守护进程进行通信并指示其执行操作的接口</li><li>Client是command line interface(CLI)</li></ul><p><img src="/images/Docker/engine-components-flow.png" alt></p><p>Docker的开源许可协议是Apache2.0</p><p><br></p><h2 id="能用Docker做什么"><a href="#能用Docker做什么" class="headerlink" title="能用Docker做什么"></a>能用Docker做什么</h2><p><strong>快速、一致的交付应用程序</strong></p><p>通过允许开发人员在 提供应用程序和服务的本地容器 的标准化环境 下工作，Docker简化了开发生命周期。容器非常适合<strong>持续集成(continuous intergration,CI)和持续交付(continuous deliver,CD)</strong>工作流程。</p><p>考虑如下示例场景：</p><ul><li>开发者在本地编写代码，并使用Docker容器分享工作给他们的同事</li><li>使用Docker将应用程序push到测试环境，并自动执行和手动测试</li><li>当开发人员发现bug，他们能在开发环境中修复bug，并重新部署应用程序到测试环境进行测试和验证</li><li>测试完成后，向客户提供修补的应用程序 与将更新的image push到生产环境一样简单</li></ul><p><br></p><p><strong>响应式部署和伸缩</strong></p><ul><li>Docker的基于容器的平台支持高度可移植的工作负载。Docker container可以运行在笔记本、物理机、虚拟机、云平台…</li><li>Docker的可移植性和轻量化特性也使得动态管理工作负载非常容易，可以近乎实时地按业务需求扩展或拆分应用程序和服务</li></ul><p><br></p><p><strong>在同一硬件上运行更多的工作负载</strong></p><p>Docker轻量且快速。它为基于hypersior的虚拟机提供了一种可行、经济高效的替代方案，因此你可以使用更多计算容量来实现业务目标。Docker是高密度环境和中小型部署的理想选择，你需要用更小的资源做更多的事情。</p><p><br></p><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><p>Docker使用了client-server的体系架构。客户端向守护进程发送消息，守护进程负责构建、运行和分发 Docker容器。客户端和守护进程可以在同一系统上运行，也可将客户端连接到远程的Docker守护进程。客户端和守护进程使用REST API，通过Unix socket或network interface进程通信。</p><p><img src="/images/Docker/architecture.png" alt="Docker架构图"></p><p><br></p><h3 id="Docker-daemon"><a href="#Docker-daemon" class="headerlink" title="Docker daemon"></a>Docker daemon</h3><p>Docker daemon(<code>dockerd</code>)，监听Docker API请求并管理Docker对象——image、container、network、volume。<br>docker daemon还可与其它docker daemon通信来管理docker service。</p><p><br></p><h3 id="Docker-client"><a href="#Docker-client" class="headerlink" title="Docker client"></a>Docker client</h3><p>Docker client(<code>docker</code>)是许多Docker用户与Docker进行交互的主要方式。客户端将命令发送给守护进程，守护进程执行命令。<br>Docker命令使用Docker API，Docker客户端可与多个守护进程进行通信。</p><p><br></p><h3 id="Docker-registry"><a href="#Docker-registry" class="headerlink" title="Docker registry"></a>Docker registry</h3><p>Docker registry存储Docker image。Docker Hub和Docker Cloud是任何人都可使用的public registry，你可以创建private registry。</p><p><code>docker pull</code>或<code>docker run</code>需要的image便是从配置的registry中提取。<code>docker push</code>推送image到你配置的registry。</p><p><br></p><h2 id="Docker对象"><a href="#Docker对象" class="headerlink" title="Docker对象"></a>Docker对象</h2><p>当你使用Docker时，你会创建和使用 image、container、network、volume、plugin和其它对象。</p><p><br></p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>镜像是一个只读模板，带有创建Docker容器的说明。通常，镜像基于其它镜像，并具有一些额外的自定义功能。<br>例如，你可构建基于Ubuntu镜像的镜像，但会按照ApacheWeb服务器和应用程序，以及应用程序所需的配置。</p><p>你可能创建自己的镜像，或使用由别人创建并推送到registry上的镜像。构建自己的镜像，需要使用简单的语法创建一个Dockerfile，以定义创建镜像并运行它所需的步骤。</p><p><br></p><h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><p>容器是镜像的可运行实例。可将容器连接到一个或多个网络，将存储器连接到它，还可根据当前状态创建新镜像。</p><p>默认情况下，容器与其它容器以及主机是相对隔离的。你可以控制容器的网络、存储、其它底层子系统与其它容器或主机的隔离程度。</p><p>容器由镜像定义，以及你在创建或启动时提供给它的任何配置选项。当一个容器被移除时，其未被存储在永久存储器中的状态会消失。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#运行一个Ubuntu镜像，交互地连接到本地命令会话</span><br><span class="line"></span><br><span class="line">docker run -i -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>以上命令会发生如下步骤:</p><ol><li>如果本地没有Ubuntu镜像，docker会从registry拉取，就好像你手动运行 <code>docker pull ubuntu</code></li><li>Docker创建一个新容器，就好像你手动执行<code>docker container create</code></li><li>Docker分配一个读写文件系统给容器，作为它的最后一层</li><li>如果你没有指定任何网络选项，Docker会创建一个网络接口将容器连接到默认网络。</li><li>Docker开启容器并执行/bin/bash</li><li>发送<code>exit</code>到<code>/bin/bash</code>，容器停止但并未被移除</li></ol><p><br></p><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>服务允许你伸缩多个Docker守护进程的容器，这些守护进程可以作为一个swarm与多个manager和worker一起工作。默认情况下，该服务在所有node之间进行负载均衡。</p><p><br></p><h3 id="底层技术"><a href="#底层技术" class="headerlink" title="底层技术"></a>底层技术</h3><p>Docker使用GO编写，利用Linux内核的几个特性来提供其功能。</p><p><br></p><p><strong>namespace</strong></p><p>Docker使用一个称为<code>namespace</code>的技术来提供称为容器的独立工作空间。当你运行一个容器时，Docker会为该容器创建一组命名空间。<br>命名空间提供了一个隔离层。容器的每个方面都在单独<code>namespace</code>中运行，并且其访问权限仅限于该单独的<code>namespace</code>。</p><p>Docker引擎在Linux上使用如下<code>namespace</code>：</p><ul><li><code>pid</code> namespace： 进程隔离</li><li><code>net</code> namespace： 管理网络接口</li><li><code>ipc</code> namespace： 管理对IPC(InterProcess Communication)资源的访问</li><li><code>mnt</code> namespace： 管理文件系统挂载点</li><li><code>ust</code> namespace： 隔离内核和版本标识符(Unix Timesharing System)</li></ul><p><br></p><p><strong>control groups</strong></p><p>Linux上的Docker Engine也依赖与另一种称为控制组(cgroups)的技术。cgroup将应用程序限制为一组特定的资源。控制组允许Docker引擎将可用的硬件资源共享给容器，并可选地强制实施限制和约束。<br>例如，你可限制特定容器的内存是CPU使用率等。</p><p><br></p><p><strong>union file systems</strong></p><p>union file systems(UnionFS)，是通过创建layer进行操作的文件系统，使得它们非常轻量和快速。Docker引擎使用UnioFS为容器提供构建block。Docker引擎可以使用多种UnionFS变体，包括AUFS, brrfs, vfs, DeviceMapper…</p><p><br></p><p><strong>container format</strong></p><p>Docker引擎将namespace、cgroup、UnionFS组合成一个名为容器格式的包装器。默认的容器格式为<code>libcontainer</code>。</p><p><br><br><br></p><hr><p><br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Docker有两个可获取的版本：</p><ul><li>Community Edition(CE)<ul><li>适合开始使用Docker并尝试基于容器的应用程序的开发人员和小型团队</li></ul></li><li>Enterprise Edition(EE)<ul><li>专为企业开发和IT团队而设计，可以在生产规模上构建，发布和运行关键业务应用程序</li></ul></li></ul><p><br><br><br></p><h2 id="CentOS7安装Docker-CE"><a href="#CentOS7安装Docker-CE" class="headerlink" title="CentOS7安装Docker CE"></a>CentOS7安装Docker CE</h2><h3 id="OS要求"><a href="#OS要求" class="headerlink" title="OS要求"></a>OS要求</h3><ul><li>CentOS7.x</li><li><code>centos-extras</code> repository</li><li>推荐使用<code>overlay2</code>存储驱动</li><li>安装新版本Docker需卸载老版本Docker</li><li>Docker CE包被称为<code>docker-ce</code></li></ul><p><br></p><h3 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h3><ul><li><a href="https://download.docker.com/" target="_blank" rel="noopener">https://download.docker.com/</a></li></ul><p>多种安装方法：</p><ul><li>Docker’s repository</li><li>RPM package</li><li>scripts</li></ul><p><br></p><p><strong>使用repository安装：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#安装依赖</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#设置repository</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#安装Docker CE</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"></span><br><span class="line"> <span class="comment">#Docker安装但未启动，docker group会被创建，但没有用户添加到组中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#在生产环境中，你可能需要安装特定版本的Docker CE，而不是最新版</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line">yum search docker-ce --showduplicates</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#开启docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#测试docker</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"> <span class="comment">#此命令下载一个测试image并将其运行到container中</span></span><br><span class="line"> <span class="comment">#Hello from Docker!</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用package安装：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#下载rpm包</span></span><br><span class="line">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#安装</span></span><br><span class="line">yum install -y /path/docker-cexxx.rpm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用scripts安装：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line"></span><br><span class="line">sh get-docker.sh</span><br><span class="line"></span><br><span class="line"> <span class="comment">#手动添加group合user</span></span><br><span class="line">usermod -aG docker your-user</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="卸载Docker-CE"><a href="#卸载Docker-CE" class="headerlink" title="卸载Docker CE"></a>卸载Docker CE</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker-ce</span><br><span class="line"></span><br><span class="line"> <span class="comment">#默认文件</span></span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line"> <span class="comment">#你还需要手动删除其它配置文件</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p><br><br><br></p><h2 id="关于Docker"><a href="#关于Docker" class="headerlink" title="关于Docker"></a>关于Docker</h2><p>Docker文档会有如下讲解：</p><ul><li>设置你的Docker环境</li><li>在一个容器(container)中构建并运行一个镜像</li><li>延伸你的APP以便在多个容器中运行</li><li>在整个集群中分配你的APP</li><li>通过添加后端数据库来堆栈服务</li><li>将应用部署到生产</li></ul><p><br></p><h3 id="Docker的概念"><a href="#Docker的概念" class="headerlink" title="Docker的概念"></a>Docker的概念</h3><p>Docker是开发人员，系统管理员使用容器来开发、部署和运行APP的平台。使用Linux容器来部署APP被称为<strong>集装箱化(containerzation)</strong></p><p><img src="/images/Docker/laurel-docker-containers.png" alt></p><p>集装箱受欢迎的几点原因：</p><ul><li>灵活(flexible)</li><li>轻量(lightweight)</li><li>通用(Interchangeable)</li><li>可移植(portable)</li><li>延伸(scalable)</li><li>堆栈(stackable)</li></ul><p><br></p><h3 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h3><p>通过运行镜像(image)启动容器(container)。镜像是一个可执行包，包含运行APP所需的所有内容：代码，库，环境变量，配置文件…</p><p>容器是镜像的运行时(runtime)实例。在Linux上使用<code>docker ps</code>命令查看运行的容器列表。</p><p><br></p><h3 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h3><p>容器在Linux本地上运行，并与其它容器共享主机Kernel。它是一个独立的进程，不占其它可执行文件内存，使其轻量化。</p><p>虚拟机(VM)运行一个完整的访客操作系统，通过虚拟机管理程序访问主机资源。一般来说，虚拟机比大多数应用程序需要的资源更多。</p><p><img src="/images/Docker/docker002.png" alt></p><p><br><br><br></p><h3 id="准备Docker环境"><a href="#准备Docker环境" class="headerlink" title="准备Docker环境"></a>准备Docker环境</h3><p>Docker版本：</p><ul><li>CE: Docker Community Edition</li><li>EE: Docker Enterprise Edition</li></ul><p><a href="#安装Docker">Install Docker</a></p><p><br></p><h2 id="测试Docker"><a href="#测试Docker" class="headerlink" title="测试Docker"></a>测试Docker</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看详细信息</span></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试安装工作是否正常</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看镜像</span></span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出容器</span></span><br><span class="line">docker container ls -all</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker命令</span></span><br><span class="line">docker</span><br><span class="line">docker container --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>集装箱化使得<strong>CI/CD</strong>无缝：</p><ul><li>持续集成(Continuous integration, CI)</li><li>持续部署(continuous deployment, CD)</li><li>APP无系统依赖</li><li>更新能够推送到分布式APP的任何部分</li><li>资源密度可以被优化</li></ul><p>使用Docker，扩展APP的过程就是启动新的可执行文件，而不是运行繁重的VM主机。</p><p><br><br><br></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Container</p><p><br></p><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><br></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>是时候使用Docker方式来构建一个APP了。</p><ul><li>从应用程序的层次结构底部开始，这是一个容器(container)</li><li>在此级别之上，是一个服务(service)，它定义了容器在生产中的表现</li><li>最后，顶层是堆栈(stack)，定义所有服务的交互(interaction)</li></ul><p>Like this:</p><ul><li>Stack</li><li>Service</li><li>Container</li></ul><p><br></p><h3 id="新开发环境"><a href="#新开发环境" class="headerlink" title="新开发环境"></a>新开发环境</h3><p>在过去，如果你要开始编写一个Python APP，你的第一要务是在你的机器运行时安装Python。但是，这会造成你的计算机上的环境，需要如预期般完美适合你的APP，并且还需要与你的生产环境相匹配。</p><p>使用Docker，你可以将一个可移植的Python运行时作为一个image，无需安装。接着，你的构建可以将基础Python image与APP代码一起包含在内，确保你的APP，依赖项…都构建一起。</p><p><br></p><h3 id="使用Dockerfile定义一个容器"><a href="#使用Dockerfile定义一个容器" class="headerlink" title="使用Dockerfile定义一个容器"></a>使用<code>Dockerfile</code>定义一个容器</h3><p><code>Dockerfile</code>定义了容器内环境中发生的事情。访问的网络接口(network interface)和磁盘驱动(disk driver)等资源是在此环境中虚拟化的(virtualized)，与系统其余部分隔离。因此你需要将端口映射(map port)到外部世界，并明确指定要将哪些文件<strong>复制</strong>到此环境中。但是，在完成这些后，你完全可以将它们看做一致 —— 在<code>Dockerfile</code>中定义的构建的APP的行为与它运行时的行为完全相同。</p><p><strong>Dockerfile</strong></p><p>创建一个空目录，并创建一个名叫<code>Dockerfile</code>的文件，复制以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to /app</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at /app</span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><p>注意代理服务器会阻断你与APP的连接！</p><p>这个<code>Dockerfile</code>引用了一些我们还没有创建的文件，分别是<code>app.py</code>和<code>requirements.txt</code>。接下来创建它们。</p><p><br></p><h3 id="APP自身"><a href="#APP自身" class="headerlink" title="APP自身"></a>APP自身</h3><p>创建另外的文件，如上面的<code>app.py</code>和<code>requirements.txt</code>，并将它们与<code>Dockerfile</code>放置于同一目录下。这就完成了我们的APP，这看起来非常简单。当这个<code>Dockerfile</code>被构建成一个image时，由于<code>Dockerfile</code>的<code>ADD</code>命令，<code>app.py</code>和<code>requirements.txt</code>仍然存在，而且由于使用了EXPOSE命令，<code>app.py</code>的输出仍可以通过HTTP访问。</p><p><strong>requirements.txt: </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><p><strong>app.py: </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br></pre></td></tr></table></figure><blockquote><p>在容器内访问主机的名称将检索容器ID，这进程ID类似。</p></blockquote><p>仅此而已，在你的系统中，你不需要任何Python或requirements.txt文件，也不需要在你的系统上安装 构建或运行的image。看起来你并没有真正用Python和Flask建立一个环境，但是你确实已经拥有了。</p><p><br></p><h3 id="构建APP"><a href="#构建APP" class="headerlink" title="构建APP"></a>构建APP</h3><p>我们准备去构建(build)APP。确保你仍在目录的顶层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#查看是否还在顶层</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">Dockerfileapp.pyrequirements.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在此目录运行build命令，这将创建一个Docker image，用 -t 命名</span><br><span class="line">docker build -t friendlyhello .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看你build的image</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">friendlyhello       latest              b24e21d7645f        13 minutes ago      150MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#运行APP</span><br><span class="line">docker run -p 4000:80 friendlyhello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#测试</span><br><span class="line">curl http://localhost:4000</span><br><span class="line">links http://localhost:4000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在后台运行</span><br><span class="line">docker run -d -p 4000:80 friendlyhello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看容器</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">146662dca737        friendlyhello       &quot;python app.py&quot;     16 seconds ago      Up 16 seconds       0.0.0.0:4000-&gt;80/tcp   goofy_chaplygin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#停止</span><br><span class="line">Ctrl + C</span><br><span class="line">docker container stop docker-ID</span><br><span class="line">docker container stop 146662dca737</span><br></pre></td></tr></table></figure><p><img src="/images/Docker/docker003.png" alt="效果图"></p><p><br></p><p>端口重映射<code>4000:80</code>是为了证明Dockerfile中的EXPOSE与使用<code>docker run -p</code>发布的内容之间的区别。<br>在后续步骤中，我们只需将主机的80端口映射到容器的80端口就好。</p><p><br></p><h3 id="分享你的image"><a href="#分享你的image" class="headerlink" title="分享你的image"></a>分享你的image</h3><p>为了演示刚才创建的image的可移植性(portability)，让我们上传build的image并在其它地方run它。毕竟，当你需要将container部署到生产环境时，你需要知道如何push注册。</p><p>注册表(registry)是一个repository的集合，而repository是image的集合——有点类似于GitHub repository，但代码是已经构建了的。<br>注册表上的账户可以创建许多repository。docker CLI 默认使用Docker’s public registry。你也可以选择其它注册表，或创建自己的注册表。</p><p><br></p><p><strong>使用Docker ID登录：</strong></p><p>如果没有Docker账户，请先注册 <cloud.docker.com>。</cloud.docker.com></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br><span class="line"></span><br><span class="line">docker login -u zhang21</span><br><span class="line"></span><br><span class="line">#时候docker login认证过后，会有~/.docker/config.json文件，里面包含了docker认证信息</span><br><span class="line">#k8s可使用此信息添加secret</span><br><span class="line"></span><br><span class="line">cat ~/.docker/config.json</span><br><span class="line">&#123;</span><br><span class="line">        &quot;auths&quot;: &#123;</span><br><span class="line">                &quot;https://index.docker.io/v1/&quot;: &#123;</span><br><span class="line">                        &quot;auth&quot;: &quot;base64encoding&quot;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;HttpHeaders&quot;: &#123;</span><br><span class="line">                &quot;User-Agent&quot;: &quot;Docker-Client/18.03.1-ce (linux)&quot;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>标记image：</strong></p><p>使用<code>username/repository:tag</code>将本地image与registry中的repository相关联。tag是可选的，但推荐使用tag。因为它是注册管理机构用于为Docker image提供版本的机制。为该内容提供一个有意义的repository和tag，例如<code>get-started:part2</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker tag image username/repository:tag</span><br><span class="line"></span><br><span class="line">#例子</span><br><span class="line">docker tag friendlyhello zhang/test:tag-test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看tag</span><br><span class="line">docker images ls</span><br></pre></td></tr></table></figure><p><br></p><p><strong>发布image：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#上传你标记了的image到repository</span><br><span class="line">docker push username/repository:tag</span><br><span class="line"></span><br><span class="line">docker push zhang21/test:tag-test</span><br><span class="line"></span><br><span class="line">#完成后，此image便可以公开获取</span><br></pre></td></tr></table></figure><p><br></p><p><strong>从远处repository拉取并运行image：</strong></p><p>无论在哪里执行<code>docker run</code>，它都会将你的image以及Python和所有依赖关系一起拉取下来，并运行你的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 username/repository:tag</span><br><span class="line"></span><br><span class="line">docker run -p 80:80 zhang21/test:tag-test</span><br></pre></td></tr></table></figure><p><br></p><h3 id="本节基础命令"><a href="#本节基础命令" class="headerlink" title="本节基础命令"></a>本节基础命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从Dockerfile创建image</span></span><br><span class="line">docker build -t image-name .</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行image</span></span><br><span class="line">docker run -p 4000:80 image-name</span><br><span class="line"></span><br><span class="line"><span class="comment">#后台运行</span></span><br><span class="line">docker run -d -p 4000:80 image-name</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出运行的容器</span></span><br><span class="line">docker container ls</span><br><span class="line"><span class="comment">#列出所有容器，包括未运行</span></span><br><span class="line">docker container ls -a</span><br><span class="line"></span><br><span class="line"><span class="comment">#优雅停止容器</span></span><br><span class="line">docker container stop 容器ID</span><br><span class="line"><span class="comment">#强制停止</span></span><br><span class="line">docker container <span class="built_in">kill</span> 容器ID</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除容器</span></span><br><span class="line">docker container rm 容器ID</span><br><span class="line"><span class="comment">#删除所有容器</span></span><br><span class="line">docker container rm $(docker container ls -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出镜像</span></span><br><span class="line">docker image ls</span><br><span class="line"><span class="comment">#列出所有镜像</span></span><br><span class="line">docker image ls -a</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除镜像</span></span><br><span class="line">docker image rm 镜像ID</span><br><span class="line"><span class="comment">#删除所有镜像</span></span><br><span class="line">docker image rm $(docker image ls -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment">#登录</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment">#标记</span></span><br><span class="line">docker tag 镜像 username/repository:tag</span><br><span class="line"></span><br><span class="line"><span class="comment">#上传到注册表</span></span><br><span class="line">docker push username/repository:tag</span><br><span class="line"></span><br><span class="line"><span class="comment">#从注册表拉取</span></span><br><span class="line">docker run username/repository:tag</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>service</p><p><br></p><h3 id="先决条件-1"><a href="#先决条件-1" class="headerlink" title="先决条件"></a>先决条件</h3><ul><li>安装Docker</li><li>获取Docker Compose</li><li>阅读Orientation</li><li>阅读Container</li><li>确保已发布friendlyhello image到你的registry</li><li>确保你的image工作为一个部署的container。<code>docker run -p 80:80 username/repo:tag</code></li></ul><p><br></p><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>在此，我们<strong>扩展(scale)</strong>APP并启用<strong>负载均衡(load balancing)</strong>。要做到这样，我们必须在分布式(distributed)应用程序的层次结构中升一级: 服务</p><ul><li>Stack</li><li>Service</li><li>Container</li></ul><p><br></p><h3 id="关于服务"><a href="#关于服务" class="headerlink" title="关于服务"></a>关于服务</h3><p>在分布式应用程序中，应用程序的不同部分称为服务(service)。</p><p>例如，一个视频共享站点。那么它可能包含：</p><ul><li>用于将应用程序数据 存储到数据库中的服务</li><li>用户上传后的视频转码服务</li><li>前端服务</li><li>…</li></ul><p>服务是真正的生产环境中的容器。一个service只运行一个image，但它可修改image的运行方式 —— 哪个端口、容器应该运行多少个副本以便于服务所需的容量等.<br>伸缩服务会更改运行该软件的容器实例数量，从而为进程中的服务分配更多的计算资源。</p><p>在Docker平台上定义、运行和伸缩服务都是很简单的 —— 只需修改<code>docker-compose.yml</code>文件。</p><p><br></p><h3 id="你的第一个docker-compose-yml文件"><a href="#你的第一个docker-compose-yml文件" class="headerlink" title="你的第一个docker-compose.yml文件"></a>你的第一个<code>docker-compose.yml</code>文件</h3><p><code>docker-compose.yml</code>是一个YAML文件，它定义了Docker container在生产中的行为方式。</p><p><strong>docker-compose.yml：</strong></p><p>将如下信息保存为<code>docker-compose.yml</code>，确保你已经<code>pushed the image</code>到registry，并通过修改<code>.yml</code>文件的image detail来替换<code>username/repo:tag</code>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line">    <span class="comment"># replace username/repo:tag with your name and image details</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">username/repo:tag</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">      resources:</span></span><br><span class="line"><span class="attr">        limits:</span></span><br><span class="line"><span class="attr">          cpus:</span> <span class="string">"0.1"</span></span><br><span class="line"><span class="attr">          memory:</span> <span class="number">50</span><span class="string">M</span></span><br><span class="line"><span class="attr">      restart_policy:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:80"</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">webnet</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  webnet:</span></span><br></pre></td></tr></table></figure><p><br></p><p><code>docker-compose.yml</code>文件告诉Docker之下如下操作：</p><ul><li>pull the image</li><li>Run 5 instances of that image as a service called <code>web</code></li><li>限制每个实例最多使用10%的CPU和50MB的RAM</li><li>如果一个失败，马上重启container</li><li>映射主机的80端口到web的80端口</li><li>指示web container通过称为<code>webnet</code>的负载均衡网络共享80端口</li><li>使用默认设置定义<code>webnet</code>网络</li></ul><p><br></p><h3 id="运行你的负载均衡APP"><a href="#运行你的负载均衡APP" class="headerlink" title="运行你的负载均衡APP"></a>运行你的负载均衡APP</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行并设置APP名字</span></span><br><span class="line">docker stack -c docker-compose.yml app-name</span><br><span class="line"></span><br><span class="line">docker stack -c docker-compose.yml LoadBalance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在一个主机上，单个服务栈通过部署的image运行5个container instance</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取service ID</span></span><br><span class="line">docker service ls</span><br><span class="line"></span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                   PORTS</span><br><span class="line">3d1a48yse0t4        LoabBalance_web     replicated          5/5                 zhang21/<span class="built_in">test</span>:tag-test   *:80-&gt;80/tcp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看服务中的任务</span></span><br><span class="line">docker service ps app-name_web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker container ls -q</span><br><span class="line"></span><br><span class="line"><span class="comment">#5个容器ID</span></span><br><span class="line">c7ce0075890e</span><br><span class="line">52ba026bf28c</span><br><span class="line">6d4381be438f</span><br><span class="line">bd297a42e89d</span><br><span class="line">357b05cc38eb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#访问的时候容器ID会在此5个负载中变化</span></span><br></pre></td></tr></table></figure><p>在服务中运行的单个container称为任务(task)。任务是具有数字增量的唯一ID，最大数量是在<code>docker-compose.yml</code>中定义的副本数量。</p><p><br></p><h3 id="伸缩APP"><a href="#伸缩APP" class="headerlink" title="伸缩APP"></a>伸缩APP</h3><p>通过修改<code>docker-compose.yml</code>中<code>replicas</code>的值，并重新运行<code>docker stack deploy -c xxx app-name</code>来伸缩APP。</p><p>Docker执行就地更新，不需要stack down或kill any containers.</p><p><strong>卸下APP和swarm：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app</span></span><br><span class="line">docker stack rm app-name</span><br><span class="line"></span><br><span class="line">docker stack rm LoadBalance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#swarm</span></span><br><span class="line">docker swarm leave --force</span><br></pre></td></tr></table></figure><p>使用Docker扩展APP非常简单。</p><p><br></p><h3 id="本节命令"><a href="#本节命令" class="headerlink" title="本节命令"></a>本节命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出栈或APP</span></span><br><span class="line">docker stack ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行指定配置文件</span></span><br><span class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出与APP相关联的服务</span></span><br><span class="line">docker service ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出与APP相关联的任务</span></span><br><span class="line">docker service ps &lt;service&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查任务</span></span><br><span class="line">docker inspect &lt;task or container&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出容器ID</span></span><br><span class="line">docker container ls -q</span><br><span class="line"></span><br><span class="line"><span class="comment">#除掉APP</span></span><br><span class="line">docker stack rm &lt;appname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#从管理中除掉一个单一节点swarm</span></span><br><span class="line">docker swarm leave --force</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="swarm"><a href="#swarm" class="headerlink" title="swarm"></a>swarm</h2><p><br></p><h3 id="先决条件-2"><a href="#先决条件-2" class="headerlink" title="先决条件"></a>先决条件</h3><ul><li>前面几个小节的内容</li></ul><p><br></p><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>前面你将一个服务运行在生产环境，并扩展为5个副本进程。</p><p>在此，你将APP部署到到集群上，并在多台机器上运行它。通过将多台主机连接到成为<strong>swarm</strong>的<strong>Dockerized</strong>集群，使得多容器、多主机应用成为可能。</p><p><br></p><h3 id="理解swarm集群"><a href="#理解swarm集群" class="headerlink" title="理解swarm集群"></a>理解swarm集群</h3><p>swarm是一组运行Docker并加入到集群中的机器。这样以后，你可以在集群的swarm manager上执行Docker命令。swarm中的机器可以是物理的或虚拟的，当他们加入swarm后，他们便被成为node。</p><p>swarm manager可以使用多种策略来运行容器，你可在compose file中指定相应的策略。</p><p>swarm manager是swarm中唯一可以执行命令、授权其他机器作为工作者加入swarm的机器。工作者(worker)只能在那提供能力(capacity)，并没有权力告诉任何机器能够做什么。</p><p>但目前为止，你已经在本机机器上以单主机(single host)模式使用Docker。但Docker也可以切换为swarm(集群)模式，这就是使用swarm的原因。立即启用swarm模式使得当前机器成为swarm manager。从此，Docker将运行在你管理的swarm上执行命令，而不仅仅是在当前机器上执行。</p><p><br></p><h3 id="建立swarm"><a href="#建立swarm" class="headerlink" title="建立swarm"></a>建立swarm</h3><p>一个swarm由多个节点组成，不管它是虚拟机还是物理机。</p><ul><li>基本概念很简单，运行<code>docker swarm init</code>来开启swarm模式并使得当前机器成为swarm manager</li><li>在其它机器上运行<code>docker swarm join</code>使他们作为worker加入swarm</li></ul><p><br></p><p><strong>栗子：</strong><br>使用VM快速创建两台机器的集群，并将其变为swarm。</p><p>使用<code>docker-machine</code>创建一对VM:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#CentOS7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装VirtualBox</span></span><br><span class="line">wget https://download.virtualbox.org/virtualbox/5.2.8/VirtualBox-5.2-5.2.8_121009_el7-1.x86_64.rpm &amp;&amp; yum install -y Virtual.xx.rpm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装docker-machine</span></span><br><span class="line"> curl -L https://github.com/docker/machine/releases/download/v0.14.0/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp; install /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在BIOS中开启虚拟化支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在VMware中开启虚拟化支持(如果是VM)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker-machine create --driver virtual myvm1</span><br><span class="line">docker-machine create --driver virtual myvm2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出虚拟机</span></span><br><span class="line">docker-machine ls</span><br></pre></td></tr></table></figure><p><br></p><p><strong>初始化swarm并添加node</strong></p><p>第一台机器作为swarm manager，执行命令和join认证，后面的机器作为worker。</p><p>你可以使用<code>docker-machine ssh</code>发送命令到VM。在<code>swarm mananger</code>上执行<code>docker swarm init</code>初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh &lt;swarm manager&gt; &quot;docker swarm init --advertise-assr &lt;mananger-IP&gt;&quot;</span><br><span class="line"></span><br><span class="line">#add worker</span><br><span class="line">docker swarm jion --toker &lt;token&gt; &lt;wroker-ip&gt;:&lt;port&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加manager</span><br><span class="line">docker swarm join-token manaer</span><br></pre></td></tr></table></figure><p><strong>由于我的虚拟的无法使用VT，因此我用的两台机器两个Docker来做swarm。</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化这台机器默认为manager</span></span><br><span class="line">docker swarm init</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#作为worker加入，ip是manager的</span></span><br><span class="line"><span class="comment">#以下信息会在manager初始化时生成</span></span><br><span class="line"><span class="comment">#注意防火墙，可能会阻碍加入</span></span><br><span class="line"></span><br><span class="line">docker swarm join --toker &lt;toker&gt; &lt;ip:port&gt;</span><br><span class="line">docker swarm join --token SWMTKN-1-3vrbnuneu0hyu41evxlhbn5fp04ad5jvg9v5rzvdaedg2bghkt-e24mjnni3hu7782t3gkz0ny39 172.16.129.150:2377</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看swarm</span></span><br><span class="line">docker node ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#离开swarm</span></span><br><span class="line">docker swarm leave</span><br></pre></td></tr></table></figure><p><br></p><h3 id="在swarm集群上部署APP"><a href="#在swarm集群上部署APP" class="headerlink" title="在swarm集群上部署APP"></a>在swarm集群上部署APP</h3><p>主需要记住，只有swarm manager才能执行docker命令，worker仅仅是容量(capacity)。</p><p>在swarm manager上使用<code>docker-composr.yml</code>和<code>docker stack deploy</code>命令来部署APP。使用<code>docker  service ps &lt;service name&gt;</code>来验证部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#在manager部署</span><br><span class="line">docker stack deploy -c ./docker-compose.yml LoadBalance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker service ls</span><br><span class="line"></span><br><span class="line">docker stack ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#注意node名</span><br><span class="line">docker stack ps LoadBalance</span><br><span class="line"></span><br><span class="line">ID                  NAME                IMAGE                   NODE                DESIRED STATE       CURRENT STATE             ERROR               PORTS</span><br><span class="line">6nrn4mwc6pvt        LoadBalance_web.1   zhang21/test:tag-test   zhang22             Running             Preparing 2 minutes ago</span><br><span class="line">bpssrnzesl7n        LoadBalance_web.2   zhang21/test:tag-test   zhang22             Running             Preparing 2 minutes ago</span><br><span class="line">kmhd8p5wkc12        LoadBalance_web.3   zhang21/test:tag-test   zhang21             Running             Running 2 minutes ago</span><br><span class="line">i0pkf4foms87        LoadBalance_web.4   zhang21/test:tag-test   zhang22             Running             Preparing 2 minutes ago</span><br><span class="line">rvtpjk781frn        LoadBalance_web.5   zhang21/test:tag-test   zhang21             Running             Running 2 minutes ago</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#分别访问个主机的IP</span><br><span class="line">#创建的网络在它们之间共享并负载均衡</span><br><span class="line">links ip1</span><br><span class="line">links ip2</span><br></pre></td></tr></table></figure><p>两个IP地址工作的原因是集群中的节点参与入口(ingress)路由网络(routing mesh)。这可以确保部署在swarm中某个端口的服务始终将该端口保留给自己，而不管实际运行容器的节点是什么。</p><p><img src="/images/Docker/ingress-routing-mesh.png" alt="入口路由"></p><p><br></p><h3 id="清理并重启"><a href="#清理并重启" class="headerlink" title="清理并重启"></a>清理并重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack rm LoadBalance</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>先决条件，已完成前面的步骤。</p><p><br></p><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>你已到达分布式应用程序层次结构的顶端——stack。堆栈是一组相互关联的服务，它们可以共享依赖关系，并可以进行协调和缩放。单个堆栈能够定义和协调整个应用程序的功能(尽管非常复杂的应用程序可能需要使用多个堆栈)。</p><p>在前面使用的<code>docker deploy</code>——是运行在单主机上的单个服务堆栈，这通常不会发生在生产环境中。在这里，你会使用学到的东西使多个服务相互关联，并在多台机器上运行它们。</p><p><br></p><h3 id="添加一个新服务并部署"><a href="#添加一个新服务并部署" class="headerlink" title="添加一个新服务并部署"></a>添加一个新服务并部署</h3><p>docker-compose2.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username/repo:tag with your name and image details</span><br><span class="line">    image: username/repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  #可视化</span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure><p>新增的东西使web对等服务，称为visualizer。注意两个事：</p><ul><li>volumes: 给予visualizer访问主机Docker的socket文件</li><li>placement： 确保服务运行在manager而不是worker上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c ./docker-compose2.yml stack-test</span><br><span class="line"></span><br><span class="line">Creating network stack-test_webnet</span><br><span class="line">Creating service stack-test_visualizer</span><br><span class="line">Creating service stack-test_web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看visualizer，要等一会才能正常访问，别着急</span><br><span class="line">访问 IP:8080</span><br></pre></td></tr></table></figure><p><img src="/images/Docker/visualizer.png" alt></p><p><br></p><h3 id="持久化数据"><a href="#持久化数据" class="headerlink" title="持久化数据"></a>持久化数据</h3><p>让我们再次通过相同的工作流程来添加用于存储应用程序数据的Redis数据库。</p><p>docker-compose3.yml，添加一个Redis服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username/repo:tag with your name and image details</span><br><span class="line">    image: username/repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/home/docker/data:/data&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    command: redis-server --appendonly yes</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#部署</span><br><span class="line">docker stack deploy -c docker-compose3.yml redis-test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#测试</span><br><span class="line">访问 IP:port</span><br></pre></td></tr></table></figure><p>Redis是一个Docker library中的官方image，并被授予redis镜像名称。</p><p>redis规范中有几件事使数据在这个堆栈的部署之间持续存在：</p><ul><li>redis运行在manager，所以它总是使用相同的文件系统</li><li>redis将数据存储在上面的目录</li><li>确保redis服务始终使用相同的主机</li><li>确保存储的数据的连续性</li></ul><p>如果没有创建，redis会将数据存储在容器文件系统的/data中，如果该容器被重新部署，则数据将被清除。</p><p><br><br><br></p><h2 id="部署APP"><a href="#部署APP" class="headerlink" title="部署APP"></a>部署APP</h2><p>先决条件为前面的操作步骤。</p><p><br></p><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>compose file在生产环境中的效果与在您的计算机上的效果相同。</p><p><br></p><h3 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a>选择版本</h3><p>我安装的是社区版(ce)。如果你在生产环境中使用docker-ce，则可以使用Docker Cloud帮助管理你的应用程序，如AWS、Aliyun、腾讯云。<br>docker cloud： <cloud.docker.com>, 可注册后建立、上传、管理自己的repo。</cloud.docker.com></p><p>设置和部署：</p><ul><li>连接Docker Cloud并授权它自动为你配置Dockerize VM</li><li>使用Docker Cloud创建你的计算资源和swarm</li><li>部署应用程序</li></ul><p><br></p><h3 id="连接DockerCloud"><a href="#连接DockerCloud" class="headerlink" title="连接DockerCloud"></a>连接DockerCloud</h3><p>你可以标准模式或swarm模式运行Docker Cloud。</p><ul><li>AWS配置指南</li><li>Aliyun配置指南</li><li>腾讯云配置指南</li></ul><p><br></p><h3 id="创建swarm"><a href="#创建swarm" class="headerlink" title="创建swarm"></a>创建swarm</h3><p>你可在Docker Cloud UI创建你的node，或<code>docker swarm init|join</code>命令。</p><p><br></p><h3 id="在云提供商上部署应用程序"><a href="#在云提供商上部署应用程序" class="headerlink" title="在云提供商上部署应用程序"></a>在云提供商上部署应用程序</h3><p><img src="/images/Docker/dockercloud.png" alt="栗子"></p><p>我觉得阿里云和腾讯云也有对应的平台。</p><p>运行部署命令: <code>docker stack deploy -c xxx.yml &lt;cus_appname&gt;</code>，现在你的APP就运行在云提供商上。</p><p><strong>运行swarm命令来验证部署</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br><span class="line"></span><br><span class="line">docker service ls</span><br><span class="line"></span><br><span class="line">docker service ps &lt;service&gt;</span><br></pre></td></tr></table></figure><p><strong>在云提供商开放端口</strong></p><div class="table-container"><table><thead><tr><th>service</th><th>type</th><th>protocol</th><th>port</th></tr></thead><tbody><tr><td>web</td><td>http</td><td>tcp</td><td>80</td></tr><tr><td>visualizer</td><td>http</td><td>tcp</td><td>8080</td></tr><tr><td>redis</td><td>tcp</td><td>tcp</td><td>6379</td></tr></tbody></table></div><p>具体操作参见各云提供商。</p><p><br></p><h3 id="迭代和清理"><a href="#迭代和清理" class="headerlink" title="迭代和清理"></a>迭代和清理</h3><ul><li>改变<code>*.yml</code>文件伸缩应用程序</li><li>使用<code>docker stack deploy</code>部署应用程序</li><li>push和pull image</li><li>使用<code>docker stack rm &lt;name&gt;</code>清除stack</li></ul><p><br><br><br></p><h2 id="修改Docker默认路径"><a href="#修改Docker默认路径" class="headerlink" title="修改Docker默认路径"></a>修改Docker默认路径</h2><p>docker默认的目录为<code>/var/lib/docker</code>，但很多时候<code>/var</code>目录并没有单独挂载，可能导致空间不够。<br>前提是你已经把源配置目录对应的文件拷贝到替换的目录。</p><ul><li>方法1：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">cd /etc/docker</span><br><span class="line"></span><br><span class="line">vim daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;graph&quot;: &quot;/opt/docker&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line">#systemctl reload docker</span><br><span class="line"></span><br><span class="line">#查看变更</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><p><br></p><ul><li>方法2:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">cd /etc/sysconfig/</span><br><span class="line"></span><br><span class="line">vim docker-storage</span><br><span class="line"></span><br><span class="line">DOCKER_STORAGE_OPTIONS=--graph=/opt/docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">#查看变更</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="容器服务自启动"><a href="#容器服务自启动" class="headerlink" title="容器服务自启动"></a>容器服务自启动</h2><p>在运行docker容器时可以加如下参数来保证每次docker服务重启后容器也自动重启:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart=always -d -p 80:80 &lt;container-id&gt;</span><br><span class="line"></span><br><span class="line">#对于已启动的容器服务，更新它</span><br><span class="line">docker update --restart=always &lt;container-id&gt;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="交互式容器"><a href="#交互式容器" class="headerlink" title="交互式容器"></a>交互式容器</h2><p>进入Docker容器以获得交互式体验。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;container&gt; /bin/bash</span><br><span class="line"></span><br><span class="line">docker exec -it &lt;container&gt; /bin/sh</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="使用systemd"><a href="#使用systemd" class="headerlink" title="使用systemd"></a>使用systemd</h2><p>默认情况下，容器是不直接支持使用systemd的。可在运行容器时添加选项来使用systemd。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#centos:7</span><br><span class="line">docker run -dit --privileged --name=centos7-systemd  centos:7 init</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul><li>docker服务日志：<ul><li><code>journalctl -u docker.service</code></li></ul></li><li>docker容器日志：<ul><li><code>&lt;docker-graph&gt;/containers/&lt;container-id&gt;/&lt;container-id&gt;-json.log</code></li><li>由于容器ID会变化，请注意提取容器ID</li><li>可使用ELK在此收集容器日志</li></ul></li></ul><p><br><br><br></p><h2 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h2><p>使用<code>docker commit</code>从改变的容器中生成一个新镜像。</p><p>更新镜像步骤：</p><ol><li>备份镜像: <code>docker tag</code></li><li>运行镜像</li><li>修改容器</li><li>生成新镜像: <code>docker commit</code></li><li>推送镜像: <code>docker push</code></li></ol><p><br><br><br></p><h2 id="动态映射端口"><a href="#动态映射端口" class="headerlink" title="动态映射端口"></a>动态映射端口</h2><p>如何给运行中的容器添加映射端口。有两种方法:</p><ul><li>将运行的容器生成一个新镜像，之后有这个镜像重新映射端口</li><li>通过iptables</li></ul><p><br></p><p>第一种方法就相当于重新启动一个镜像，在启动时重新映射端口。实在是麻烦。</p><p><br></p><p>由于docker 命令设置端口映射其实也就是下发 <code>iptables</code> 规则，所以我们可以直接创建 <code>iptables</code> 规则进行端口流量转发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看本机docker iptabels rules</span></span><br><span class="line">iptables-save</span><br><span class="line"></span><br><span class="line"><span class="comment">#我的一个hexo镜像</span></span><br><span class="line"><span class="comment">#-A DOCKER -d 172.17.0.2/32 ! -i docker0 -o docker0 -p tcp -m tcp --dport 4000 -j ACCEPT</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#再它在添加一个端口</span></span><br><span class="line">iptables -t nat -A DOCKER ! -i dokcer0 -p tcp -m tcp --dport 56789 -j DNAT --to-destination 172.17.0.2:56789</span><br></pre></td></tr></table></figure><h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><p><br></p><h3 id="备份容器"><a href="#备份容器" class="headerlink" title="备份容器"></a>备份容器</h3><ul><li><code>docker commit</code>: 生成新镜像</li><li><code>docker save</code>： 生成本地tar包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Usage:  docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">docker commit -m &quot;Just a test&quot; -p $&#123;container-id&#125; Zhang21/test:01</span><br><span class="line">docker image ls</span><br><span class="line">docker login</span><br><span class="line">docker push</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Usage:  docker save [OPTIONS] IMAGE [IMAGE...] [flags]</span><br><span class="line"></span><br><span class="line">docker save -o /path/$&#123;image&#125;.tar $&#123;image&#125;</span><br><span class="line">ls /path</span><br></pre></td></tr></table></figure><p><br></p><h3 id="恢复容器"><a href="#恢复容器" class="headerlink" title="恢复容器"></a>恢复容器</h3><ul><li><code>docker run ${image}</code></li><li><code>docker load</code>: 载入本地.tar镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage:  docker load [OPTIONS]</span><br><span class="line"></span><br><span class="line">docker load -i /path/$&#123;image&#125;.tar</span><br><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="应用场景与注意事项"><a href="#应用场景与注意事项" class="headerlink" title="应用场景与注意事项"></a>应用场景与注意事项</h2><p><br></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>本地依赖</li><li>搭建环境</li><li>微服务</li><li>自动测试</li><li>部署过程</li><li>CI/CD</li><li>多租户环境</li><li>一台机器的多个APP</li><li>弹性伸缩</li><li>资源隔离</li></ul><p><br></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>一个进程，一个容器<br>不推荐在Docker容器中运行多个进程！</p></li><li><p>不要将数据存放到容器内<br>所以请使用挂在卷的方式映射到本地磁盘目录</p></li></ul><ul><li><p>使用磁盘进行数据存储</p></li><li><p>容器通信<br>每当一个Docker容器需要与另一个容器通信时，传递信息最好使用名称或环境变量。</p></li><li><p>以non-root用户运行Docker<br>默认情况下，Docker容器以root用户身份运行，众所周知，以root用户运行的容器完全可以控制主机系统。</p></li><li><p>注意容器的体积<br>选择一个容器的主要原因之一是它的体积小。但是，如果你把它做得更大，它的主要优势就没了。</p></li><li><p>制定控策略<br>开发和部署Docker容器不是你的工作的结束。您需要持续监控已部署的容器以及整个系统的运行状况。选择合适的工具并制定一个策略来有效地监控您的Docker容器，以确保最短的停机时间，从而使客户满意。</p></li><li><p>安全问题<br>安全补丁、防火墙…</p></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>参考:</p><ul><li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a></li></ul><p><br></p><p>将镜像每一层的修改、安装、配置、操作的命令写入Dockerfile，并用它来构建、定制镜像，那么镜像构建透明性问题便会得到解决。</p><p>Dockerfile是一个文本文件，包含了一条条指令(instrction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p><br><br><br></p><h2 id="使用Dockerfile定制镜像"><a href="#使用Dockerfile定制镜像" class="headerlink" title="使用Dockerfile定制镜像"></a>使用Dockerfile定制镜像</h2><p><br></p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>所谓指定镜像，就是以一个镜像为基础，在其上进行定制。基础镜像必须指定，而<code>FROM</code>就是指定<strong>基础镜像</strong>，因此一个<code>Dockerfile</code>中<code>FROM</code>是必备的指令，并且必须是第一条指令。</p><p>只有有可能，请使用当前官方repo作为你的基础镜像。我们推荐使用<strong>Alpine</strong>镜像，因为它严格控制，体积小(只有5MB)，同时也是完整的Linux发行版。</p><p>Docker Hub中有很多常用的官方镜像——常用软件、常用语言和常用系统镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#特殊镜像，scratch，空白镜像</span><br><span class="line">FROM scratch</span><br></pre></td></tr></table></figure><p><br></p><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>在多行中使用反斜杠<code>\</code>或复杂的<code>RUN</code>语句，使Dockerfile更具可读性、易理解性和可维护性。</p><p><code>RUN</code>指令是用来执行命令行命令的。有两种格式：</p><ul><li><code>shell</code>格式<ul><li><code>RUN &lt;CMD&gt;</code>，就像直接在命令行中输入命令一样</li></ul></li><li><code>exec</code>格式<ul><li><code>RUN [&quot;可执行文件&quot;, &quot;参数&quot;]</code>，这更像函数调用中的格式</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure><p>Dockerfile中的每一个指令都会建立一层，<code>RUN</code>也不例外。每一个<code>RUN</code>的行为，就和手工建立镜像的过程一样 —— 新建立一层，在其上执行这些命令，执行结束后，<code>commit</code>这一层的修改，构成新的镜像。</p><p>上面这种写法，创建了7层镜像，这是完全没有意义的，而且很多运行时不需要的东西都被装进了镜像里，比如编译环境和更新的软件包等。结果就会产生非常臃肿、非常多层的镜像，不仅增加了构建部署的时间，也容易出错。这是很多初学Docker的人常犯的一个错误。</p><p>UnionFS是Linux、FreeBSD的文件系统服务，UnionFS是有最大层数限制的。</p><p>修改后的Dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line">RUN buildDeps=&apos;gcc libc6-dev make&apos; \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure><p>仅仅使用一个<code>RUN</code>指令，并使用<code>&amp;&amp;</code>将各指令串联起来。将之前的7层简化为1层。在编写<code>Dockerfile</code>时，要经常提醒自己，这并不是在写shell脚本，而是在定义每一层该如何构建。</p><p><code>Dockerfile</code>支持shell类的换行<code>\</code>、注释<code>#</code>等格式，良好的格式，如换行、缩进、注释等，会让维护、排障更为容易，这也是一个好习惯。</p><p>此外，还可看到命令最后添加了清理工作的命令，删除了为编译构建所需要的软件，清理了所有下载文件。这很重要，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随镜像。<br>因此，构建镜像时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。<br>很多人初学docker制作出了很臃肿的镜像，原因之一就是顽疾了每一层构建的最后一定要清理无关文件。</p><p><br></p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在<code>Dockerfile</code>目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#docker build [OPTIONS] PATH | URL | - [flags]</span><br><span class="line">#Build an image from a Dockerfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#-t指定镜像名称</span><br><span class="line">#.指的是上下文目录</span><br><span class="line">docker build -t nginx:test .</span><br></pre></td></tr></table></figure><p><br></p><p><strong>构建上下文(content)</strong></p><p>上面的<code>.</code>是在指定<strong>上下文路径</strong>。</p><p>当我们在进行镜像构建的时候，并非所有的定制都会通过<code>RUN</code>指令完成，经常会需要一些本地文件复制进镜像，比如通过<code>COPY</code>, <code>ADD</code>指令。而<code>docker build</code>命令并非是在本地构建镜像，而是在服务端，也就是Docker引擎<code>dockerd</code>中构建的。那么在这种C/S架构中，如何才能让服务端获得本地文件呢？</p><p>这就引进了上下文的概念。当构建的时候，用户会指定构建镜像的上下文的路径，<code>docker build</code>命令得知这个路径后，会将路径下的所有内容打包，然后上传给Docker引擎。这样Docker引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#复制上下文目录下的package.json</span><br><span class="line">COPY ./package.json /app/</span><br></pre></td></tr></table></figure><p>因此<code>COPY</code>这类指令中的源文件的路径都是相对路径，因为绝对路径已经超出了上下文的范围，Docker引擎无法获取这些位置的文件。如果真需要这些文件，请将它们复制到上下文目录中去。</p><p>理解构建上下文对于镜像构建很重要，避免犯一些不应该的错误。</p><p>一般来说，应将<code>Dockerfile</code>置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，则应该把所需文件复制一份过来。如果目录下有些东西不希望构建时传给Docker引擎，可以写一个<code>.dockerignore</code>文件，用于剔除不需要作为上下文传递给Docker引擎的。</p><p>实际上，<code>Dockerfile</code>的文件名并不要求必须为<code>Dockerfile</code>，也并不要求必须位于上下文目录中。可使用<code>-f</code>指定某个文件为<code>Dockerfile</code>。</p><p><br></p><p><strong>其它<code>docker build</code>的用法</strong></p><ol><li>直接使用Git repo进行构建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#docker build URL</span><br><span class="line"></span><br><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14</span><br><span class="line">#docker会自己去clone、切换分支、并进入指定目录开始构建</span><br></pre></td></tr></table></figure><p><br></p><ol><li>使用给定tar压缩包构建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build http://server/context.tar.gz</span><br><span class="line"></span><br><span class="line">#自动下载/解压缩 压缩包，以其作为上下文，开始构建</span><br></pre></td></tr></table></figure><p><br></p><ol><li>从标准输入中读取Dockerfile进行构建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat Dockerfile | docker build -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><p><code>Dockerfile</code>提供了十多个指令供我们操作。</p><p><br></p><h3 id="LABLE"><a href="#LABLE" class="headerlink" title="LABLE"></a>LABLE</h3><p>你可以为你的镜像添加标签，以助于通过项目来组织镜像，记录相关信息。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set multiple labels at once, using line-continuation characters to break long lines</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> vendor=ACME\ Incorporated \</span></span><br><span class="line"><span class="bash">      com.example.is-beta= \</span></span><br><span class="line"><span class="bash">      com.example.is-production=<span class="string">""</span> \</span></span><br><span class="line"><span class="bash">      com.example.version=<span class="string">"0.0.1-beta"</span> \</span></span><br><span class="line"><span class="bash">      com.example.release-date=<span class="string">"2015-02-12"</span></span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>尽管<code>ADD</code>和<code>COPY</code>在功能上相似，但一般来说，<code>COPY</code>是首选，因为它比<code>ADD</code>更透明。<br><code>COPY</code>只支持将本地文件复制到容器中，而<code>ADD</code>具有一些功能(如提取tar文件和远程URL支持)</p><p><br></p><p><code>COPY</code>,复制文件。<br>从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置。</p><blockquote><p>源路径可以是多个，或通配符(需满足Go的规则)<br>目标路径可是容器内的绝对路径，也可是相对于工作目录(<code>WORKDIR</code>)的相对路径。目标路径不需要事先创建。<br>使用COPY指令，源文件的各种元数据都会保留 —— 如读、写、执行权限、文件变更时间…</p></blockquote><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">COPY  &lt;sourch&gt;  &lt;destination&gt;</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">COPY  [&quot;&lt;source1&gt;&quot;, ... &quot;&lt;destination&gt;&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子</span><br><span class="line">COPY package.json /usr/src/app/</span><br><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#目录</span><br><span class="line">COPY dir/ /dir/</span><br><span class="line">#复制目录的错误用法</span><br><span class="line">#COPY  dir/* /dir/</span><br></pre></td></tr></table></figure><p><br></p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p><code>ADD</code>是更高级的复制文件。<br><code>ADD</code>和<code>COPY</code>的格式和性质基本一致，但增加了一些功能。<code>ADD</code>支持通过URL从远程服务器读取资源，但对远程的压缩包没有解压缩功能。<br>尽可能的使用<code>COPY</code>，因为<code>COPY</code>的语义很明确，就是复制文件而已，而<code>ADD</code>则包含了更复杂的功能，其行为也不一定很清晰。<br>最适合<code>ADD</code>的场合，就是所提及的需要自动解压缩的场合。</p><p>因此在<code>COPY</code>和<code>ADD</code>指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用<code>COPY</code>指令，仅在需要自动解压缩或远程资源的场合使用<code>ADD</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line"></span><br><span class="line">ADD ADD http://foo.com/bar.go /tmp/main.go</span><br><span class="line"></span><br><span class="line">ADD abc.tar.gz / &amp;&amp; \</span><br><span class="line">    http://example.com/big.tar.xz /usr/src/things/ &amp;&amp; \</span><br><span class="line">RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span><br><span class="line">RUN make -C /usr/src/things all</span><br></pre></td></tr></table></figure><p><br></p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>CMD</code>，容器启动命令。用于运行镜像中包含的软件以及任何参数。</p><p>也有两个格式：</p><ul><li><code>shell</code>格式： <code>CMD &lt;command&gt;</code></li></ul><p><code>shell</code>格式，在实际中会被包装成<code>sh -c</code>的参数形式进行执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CMD echo $HOME</span><br><span class="line"></span><br><span class="line">#转变为</span><br><span class="line">CMD[&quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot;]</span><br><span class="line"></span><br><span class="line">#-c string If  the  -c option is present, then commands are read from string.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理</span><br></pre></td></tr></table></figure><p><br></p><ul><li><code>exec</code>格式： <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot; ...]</code><br>CMD几乎总是以此格式使用。</li></ul><p>Docker不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code>指令就是用于指定默认的容器主进程的启动命令的。<br>``</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p><p><br></p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p><code>ENTRYPOINT</code>，入口点。指令格式同样分为<code>shell</code>格式和<code>exec</code>两种。</p><p><code>ENTRYPOINT</code>和<code>CMD</code>一样，都是在指定容器启动程序及参数。<br>当指定了<code>ENTRYPOINT</code>后，<code>CMD</code>的含义就发生了改变，不再是直接的运行其命令，而是将<code>CMD</code>的内容作为参数传给<code>ENTRYPOINT</code>指令。即变为如下模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure><p><br></p><p>有几大好处：</p><ul><li><strong>让镜像变成像命令一样使用</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#可以从腾讯上拉取，快一些</span><br><span class="line">#ccr.ccs.tencentyun.com/qcloud/ubuntu</span><br><span class="line"></span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker build -t myip</span><br><span class="line">docker run myip</span><br><span class="line">#当前 IP：182.150.x.xx 来自：四川省成都市 电信</span><br></pre></td></tr></table></figure><p>不过命令总有参数，例如我想查看HTTP header，使用<code>-i</code>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run myip -i</span><br><span class="line">#这样会报错，-i替换了CMD命令，而不是-s参数，然而-i并不是命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#重新完整输入命令</span><br><span class="line">docker run myip curl -s http://ip.cn -i</span><br><span class="line">#这样又太麻烦</span><br></pre></td></tr></table></figure><p>这时便可以使用<code>ENTRYPOINT</code>解决这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker build it myip</span><br><span class="line">docker run myip</span><br><span class="line">#当前 IP：182.150.x.xx 来自：四川省成都市 电信</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run myip -i</span><br><span class="line">#成功</span><br></pre></td></tr></table></figure><p>当存在<code>ENTRYPOINT</code>后，<code>CMD</code>的内容将作为参数传递给<code>ENTRYPOINT</code>，而<code>-i</code>就是新的<code>CMD</code>，因此会作为参数传递给<code>curl</code>，从而达到预期效果。</p><p><br></p><ul><li><strong>应用运行前的准备工作</strong></li></ul><p>有时，在启动前需要做一些准备工作。</p><ul><li>如MySQL，需要一些配置文件、初始化工作，这些工作需要在MySQL server运行前解决</li><li>避免使用root用户去启动服务，从而提高安全性</li><li>这些准备工作和<code>CMD</code>无关</li></ul><p><br></p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p><code>ENV</code>，设置环境变量。<br>为了使新软件更容易运行，使用此命令为你的容器内安装的软件更新环境变量。</p><p>两种格式：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV PATH $PATH:/root/bin \</span><br><span class="line">EMAIL abc@zhang21.cn \</span><br><span class="line">NAME=&quot;Zhang21&quot;</span><br></pre></td></tr></table></figure><p>下列指令可以支持环境变量展开： <code>ADD</code>, <code>COPY</code>, <code>ENV</code>, <code>EXPOSE</code>, <code>LABEL</code>, <code>USER</code>, <code>WORKDIR</code>, <code>VOLUME</code>, <code>STOPGIGNAL</code>, <code>ONBUILD</code>。</p><p>通过环境变量，我们可以让一份<code>Dockerfile</code>制作更多的镜像，只需使用不同的环境变量即可。</p><p><br></p><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p><code>ARG</code>，构建参数</p><p>格式：</p><ul><li><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></li></ul><p><br></p><p>构建参数和<code>ENV</code>的效果一样，都是设置环境变量。所不同的是，<code>ARG</code>所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。</p><p><br></p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><code>VOLUME</code>，定义匿名卷。用于显示有docker容器创建的任何数据库存储区域，配置存储或文件/文件夹。<br>强烈建议将VOLUME用于镜像的任何可变部分和用户可用部分。</p><p>格式：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p><br></p><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。<br>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在<code>Dockerfile</code>中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会像容器存储层写入大量数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#在运行时自动挂载为匿名卷</span><br><span class="line">VOLUME /data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#覆盖挂载</span><br><span class="line">docker run -d -v mydata:/data xxx</span><br></pre></td></tr></table></figure><p><br></p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><code>EXPOSE</code>，声明容器监听连接的端口。</p><p>格式：</p><ul><li><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></li></ul><p><code>EXPOSE</code>指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。<br>在<code>Dockerfile</code>中写入这个声明有两个好处：</p><ul><li>一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便映射</li><li>另一个用处则是在运行时使用随机端口映射(未定义时)</li></ul><p>要将<code>EXPOSE</code>和在运行时使用<code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code>区分开。<code>EXPOSE</code>仅仅声明容器打算使用哪些端口，并未包含端口映射。</p><p><br></p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p><code>WORKDIR</code>，指定工作目录。为了清晰可靠，请使用绝对路径。</p><p>使用<code>WORKDIR</code>指令可以来指定工作目录，以后各层的当前目录就被改为指定的目录，如目录不存在，<code>WORKDIR</code>会帮你建立目录。<br>如果需要改变<code>Dockerfile</code>各层的工作目录的位置，那么应该使用<code>WORKDIR</code>指令。</p><p>格式：</p><ul><li><code>WORKDIR &lt;工作目录&gt;</code></li></ul><p><br></p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p><code>USER</code>，指定当前用户。<br>如果服务可以在非特权模式下运行，请使用USER将其改为non-root用户。首先在Dockerfile中创建相应的用户和组:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r group &amp;&amp; \</span><br><span class="line">useradd -r -g group group</span><br></pre></td></tr></table></figure><p><code>USER</code>和<code>WORKDIR</code>相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code>是改变工作目录，<code>USER</code>则是改变之后的层执行<code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>这类命令的身份。这个用户必须存在。</p><p>格式：</p><ul><li><code>USER &lt;用户名&gt;</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USER redis</span><br><span class="line">RUN [&quot;redis-server&quot;]</span><br></pre></td></tr></table></figure><p><br></p><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p><code>HEALTHCHECK</code>，健康检查<br><code>HEALTHCHECK</code>指令告诉docker应该如何进行判断容器的状态是否正常。</p><p>格式：</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>， 设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>， 如果基础镜像有健康检查，使用这行可以屏蔽其健康检查指令</li></ul><p>当在一个镜像指定了<code>HEALTHCHECK</code>指令后，用其启动容器，初始状态会为<code>starting</code>，在<code>HEALTHCHECK</code>指令检查成功后变为<code>healthy</code>，如果连续一定次数失败，则会变为<code>unhealthy</code>。<br>和<code>CMD</code>, <code>ENTRYPOINT</code>一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p><p><br></p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p><code>ONBUILD</code>，为他人做嫁衣。</p><p><code>ONBUILD</code>是一个特殊的指令，它后面跟的是其它指令。而这些指令，在当前镜像构建时不会被执行。只有当以当前镜像为基础镜像(父镜像)，去构建下一级镜像(子镜像)的时候才会被执行。<code>ONBUILD</code>命令在子镜像的Dockerfile中任何命令之前执行。<br><code>Dockerfile</code>中的其它指令都是为了定制当前镜像而准备的，唯有<code>ONBUILD</code>是为了帮助别人定制自己而准备的。</p><p>格式：</p><ul><li><code>ONBUILD &lt;其它指令&gt;</code></li></ul><p><br><br><br></p><h2 id="Dockerfile多阶段构建"><a href="#Dockerfile多阶段构建" class="headerlink" title="Dockerfile多阶段构建"></a>Dockerfile多阶段构建</h2><p><strong>全部放入一个Dockerfile</strong></p><p>将所有的构建过程包含在一个<code>Dockerfile</code>中，包括项目及其依赖库的编译、测试、打包等流程。<br>这可能会带来一些问题：</p><ul><li><code>Dockerfile</code>特别长，可维护性降低</li><li>镜像层次多，镜像体积较大，部署时间变长</li><li>源代码存在泄漏的风险</li></ul><p><br></p><p><strong>分散到多个Dockerfile</strong></p><p>事先在一个<code>Dockerfile</code>将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中。这种方式需要编写两个<code>Dockerfile</code>和一些编译脚本才能将两个阶段自动整合起来。这种方式虽然可以很好避免全部写入一个Dockerfile的风险，但明显部署过程较复杂。</p><p><br></p><p><strong>多阶段构建</strong></p><p>使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个<code>Dockerfile</code>。</p><p><br><br><br></p><h2 id="Dockerfile最佳实践"><a href="#Dockerfile最佳实践" class="headerlink" title="Dockerfile最佳实践"></a>Dockerfile最佳实践</h2><ul><li>一般性建议<ul><li>容器应该是短暂的</li><li>使用<code>.dockerignore</code>文件</li><li>使用多阶段构建减少镜像大小</li><li>避免安装不必要的包</li><li>一个镜像只运行一个进程</li><li>镜像层数尽可能少</li><li>将多行参数排序</li><li>构建缓存</li></ul></li><li>Dockerfile指令<ul><li><code>FROM</code></li><li><code>LABEL</code></li><li><code>RUN</code></li><li><code>CMD</code></li><li><code>EXPOSE</code></li><li><code>ENV</code></li><li><code>ADD</code></li><li><code>COPY</code></li><li><code>ENTRYPOINT</code></li><li><code>VOLUME</code></li><li><code>USER</code></li><li><code>WORKDIR</code></li></ul></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="多平台构建"><a href="#多平台构建" class="headerlink" title="多平台构建"></a>多平台构建</h1><p>参考:</p><ul><li>buildx: <a href="https://docs.docker.com/buildx/working-with-buildx/" target="_blank" rel="noopener">https://docs.docker.com/buildx/working-with-buildx/</a></li><li>qemu-uer-static: <a href="https://github.com/multiarch/qemu-user-static" target="_blank" rel="noopener">https://github.com/multiarch/qemu-user-static</a></li></ul><p>版本:</p><ul><li>大于Docker 19.03</li><li>linux kernel: <code>5.x</code></li></ul><p><br></p><p>使用Docker新功能<code>buildx</code>构建多平台的镜像。<br>升级内核版本，不然使用<code>qemu-user-static</code>使会失败。</p><p><br></p><p>使用如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 开启此功能</span><br><span class="line">export DOCKER_CLI_EXPERIMENTAL=enabled</span><br><span class="line"></span><br><span class="line"># 需要使用qemu-user</span><br><span class="line"># 注意内核版本，升级到5.x的内核大版本</span><br><span class="line">docker run --rm --privileged multiarch/qemu-user-static --reset -p yes</span><br><span class="line">docker buildx create --name builder --driver docker-container --use</span><br><span class="line">docker buildx inspect --bootstrap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># arm64，--load存放本地</span><br><span class="line">docker buildx build -t xxx:arm64-tag --load --platform linux/arm64 .</span><br><span class="line"># amd64，--push推送</span><br><span class="line">docker buildx build -t xxx:amd64-tag --push --platform linux/amd64 .</span><br><span class="line"></span><br><span class="line"># 多平台</span><br><span class="line">docker buildx build --platform linux/arm64,linux/amd64 -t user/test:latest --push .</span><br></pre></td></tr></table></figure><p>多平台构建的镜像支持运行在各自的架构上，使用同一个tag。多平台构建只能使用<code>--push</code>, <code>--load</code>只能对应单个平台。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Compose-file"><a href="#Compose-file" class="headerlink" title="Compose file"></a>Compose file</h1><p>参考:</p><ul><li><a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="使用Docker进行开发"><a href="#使用Docker进行开发" class="headerlink" title="使用Docker进行开发"></a>使用Docker进行开发</h1><p>Develop with Docker</p><p><br><br><br></p><h2 id="在Docker上开发应用程序"><a href="#在Docker上开发应用程序" class="headerlink" title="在Docker上开发应用程序"></a>在Docker上开发应用程序</h2><p>Develop new apps on Docker</p><ul><li>Learn to build an image from a Dockerfile</li><li>Use multistage builds to keep your images lean</li><li>Manage application data using volumes and bind mounts</li><li>Scale your app as a swarm service</li><li>Define your app stack using a compose file</li><li>General application development best practices</li></ul><p><br></p><p>了解有关Docker上特定语言的开发：</p><ul><li>Java</li><li>node.js</li><li>Ruby on Rails</li><li>.Net</li><li>ASP.Net</li></ul><p><br><br><br></p><h3 id="Docker开发最佳实践"><a href="#Docker开发最佳实践" class="headerlink" title="Docker开发最佳实践"></a>Docker开发最佳实践</h3><p>Docker development best practices</p><p>如下开发模式已被证明有助于人么使用Docker构建应用程序。</p><p><br></p><h4 id="如何保持较小的镜像"><a href="#如何保持较小的镜像" class="headerlink" title="如何保持较小的镜像"></a>如何保持较小的镜像</h4><p>How to keep your images small</p><p>在启动容器或服务时，小图像可以更快速通过网络pull镜像并加载到内存中。有几条经验法则可保持较小的镜像：</p><ul><li><p>从适当的基础镜像开始<br>例如，如果需要JDK，请考虑官方镜像，而不是从一个通用的Ubuntu/Centos镜像并将Openjdk作为Dockerfile的一部分安装开始。</p></li><li><p>使用多阶段构建<br>例如，你可以使用maven镜像构建java程序，然后重置到tomcat镜像，并将java构件复制到正确位置以部署应用程序，所有这些都位于相同的Dockerfile。这意味着你的最终镜像不包含构建时所引入的所有库和依赖项，仅包含运行它们所需的构件和环境。</p></li><li><p>如果你有多个共同的镜像，请考虑使用共享组件创建你的基本镜像，并在其上创建独特的镜像<br>Docker只要家在一次通用层，然后便会缓存。</p></li><li><p>保持生产环境镜像精简但允许调试(degub)，请考虑使用生产环境镜像作为调试镜像的基本镜像</p></li><li><p>在构建镜像时，应该始终使用有用的标签对其进行标记，如(test, prod)。不要依赖自动创建的<code>latest</code>标签</p></li></ul><p><br></p><h4 id="何处以及如何持久化应用程序数据"><a href="#何处以及如何持久化应用程序数据" class="headerlink" title="何处以及如何持久化应用程序数据"></a>何处以及如何持久化应用程序数据</h4><p>Where and how to persist application data</p><ul><li><p>避免使用存储驱动(storge drivers)将应用程序的数据存储在容器的可写层(writeable layer)中<br>与使用卷(volume)或绑定挂载(bound mounts)相比，这增加了容器的大小，并且从I/O角度来看效率较低</p></li><li><p>使用卷存储数据</p></li><li>适合使用绑定挂载的一种情况是在开发过程中，对于生产环境，请改用卷</li><li>对于生产环境，使用secerts来存储服务使用的敏感的应用程序数据，使用config来存储不敏感的数据(如配置文件)</li></ul><p><br></p><h4 id="尽可能使用swarm服务"><a href="#尽可能使用swarm服务" class="headerlink" title="尽可能使用swarm服务"></a>尽可能使用swarm服务</h4><p>Use swarm services when possible</p><ul><li>在可能的情况下，使用swarm服务进行伸缩的能力来设计你的应用程序</li><li>即使你只需运行单个实例，swarm服务也比standalone容器提供更多的优势</li><li>网络和卷可使用swarm服务连接和断开，并且docker可以以不中断的方式重新部署各个服务容器。standalone容器需要手动停止/移除/重新创建</li><li>一些功能仅适用于服务而不适用于standalone容器</li><li>让<code>docker stack deploy</code>处理任意镜像，而不是使用<code>docker pull</code>。通过这种方式，你的部署不会尝试从down的节点进行pull。此外，当新节点添加到集群时，镜像会自动pull</li></ul><p><br></p><h4 id="使用CI-CD进行测试和部署"><a href="#使用CI-CD进行测试和部署" class="headerlink" title="使用CI/CD进行测试和部署"></a>使用CI/CD进行测试和部署</h4><p>Use CI/CD for testing and deployment</p><ul><li>CI(Continuous integration)</li><li>CD(continuous deployment)</li><li>当更新源码库或创建拉取请求时，请使用CI/CD pipeline 自动构建并标记Docker镜像，并对其进行测试。也可将测试过的应用程序直接部署到生产环境中</li></ul><p><br><br><br></p><h3 id="Develop-images"><a href="#Develop-images" class="headerlink" title="Develop images"></a>Develop images</h3><h4 id="编写Dockerfile的最佳实践"><a href="#编写Dockerfile的最佳实践" class="headerlink" title="编写Dockerfile的最佳实践"></a>编写Dockerfile的最佳实践</h4><p>Best practices for writing Dockerfiles</p><p>Docker通过读取Dockerfile(一个包含命令的文本文件)中的命令来自动构建镜像。<br>Dockerfile reference: <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p><p><br></p><p>Dockerfile由read-only layer组成，每层代表一个Dockerfile指令。如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:15.04</span><br><span class="line">COPY . /app</span><br><span class="line">RUN make /app</span><br><span class="line">CMD python /app/app.py</span><br></pre></td></tr></table></figure><p>每个命令创建一个层:</p><ul><li><p><code>FROM</code><br>从<code>ubuntu:15.04</code> Docker image创建一个层</p></li><li><p><code>COPY</code><br>从Docker client的当前目录添加文件</p></li><li><p><code>RUN</code><br>使用<code>make</code>构建你的应用程序</p></li><li><p><code>CMD</code><br>指定在容器内运行的命令</p></li></ul><p>当你运行镜像并生成容器时，会在基础层的顶部添加一个可写层(writable layer)，也称容器层(container layer)。对正在运行的容器所做的所有更改(增删改文件)都会写入此可写容器层。</p><p><br></p><h4 id="一般准则和建议"><a href="#一般准则和建议" class="headerlink" title="一般准则和建议"></a>一般准则和建议</h4><p>General guidelines and recommendations</p><p><strong>创建临时(ephemeral)容器</strong></p><p>Create ephemeral containers<br>由Dockerfile定义的镜像应该生成尽可能临时的容器。临时的意思为容器可以被停止(stop)和销毁(destroy)，然后重建(rebuild)并使用绝对最小化的设置和配置来替代。</p><p><br></p><p><strong>理解构建上下文</strong></p><p>Understand build context<br>当你发出<code>docker build</code>命令时，当前的工作目录被称为构建上下文(build context)。默认情况下，假设Dockerfile位于此，但你也可以使用文件标志(-f)指定位置。无论Dockerfile位于何处，当前目录内的所有内容(除了.dockerignore中忽略的内容)都将作为构建上下文发送给Docker守护进程。</p><p><br></p><p><strong>从stdin读取Dockerfile</strong></p><p>Pipe Dockerfile through stdin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#local build-context</span><br><span class="line">docker build -t . -f-&lt;&lt;EOF</span><br><span class="line">FROM busybox</span><br><span class="line">RUN echo &quot;hello world&quot;</span><br><span class="line">COPY . /my-copied-files</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#remote</span><br><span class="line">docker build -t foo https://github.com/thajeztah/pgadmin4-docker.git -f-&lt;&lt;EOF</span><br><span class="line">FROM busybox</span><br><span class="line">COPY LICENSE config_local.py /usr/local/lib/python2.7/site-packages/pgadmin4/</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用<code>.dockerignore</code>排除文件</strong></p><p>Exclude with .dockerignore<br>要排除与构建无关的文件，请使用<code>.dockerignore</code>文件，这与<code>.gitignore类似</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ./dockerignore</span><br><span class="line"></span><br><span class="line">file1</span><br><span class="line">dir2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用多阶段构建</strong></p><p>Use multi-stage builds<br>多阶段构建允许你大幅缩减镜像大小，而不需要减少中间层和文件数。<br>由于镜像是在构建过程的最后阶段构建的，因此可以通过利用构建缓存(build cache)来最小化镜像层</p><p>例如，如果你的版本博涵包含多个层，你可以从 不经常改动的版本到频繁改动的版本进行排序:</p><ul><li>安装构建应用程序需要的工具</li><li>安装或更新依赖库</li><li>生成应用程序</li></ul><p>A Dockerfile for Go application:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.9.2-alpine3.6 AS build</span><br><span class="line"></span><br><span class="line"># Install tools required for project</span><br><span class="line"># Run `docker build --no-cache .` to update dependencies</span><br><span class="line">RUN apk add --no-cache git</span><br><span class="line">RUN go get github.com/golang/dep/cmd/dep</span><br><span class="line"></span><br><span class="line"># List project dependencies with Gopkg.toml and Gopkg.lock</span><br><span class="line"># These layers are only re-built when Gopkg files are updated</span><br><span class="line">COPY Gopkg.lock Gopkg.toml /go/src/project/</span><br><span class="line">WORKDIR /go/src/project/</span><br><span class="line"># Install library dependencies</span><br><span class="line">RUN dep ensure -vendor-only</span><br><span class="line"></span><br><span class="line"># Copy the entire project and build it</span><br><span class="line"># This layer is rebuilt when a file changes in the project directory</span><br><span class="line">COPY . /go/src/project/</span><br><span class="line">RUN go build -o /bin/project</span><br><span class="line"></span><br><span class="line"># This results in a single layer image</span><br><span class="line">FROM scratch</span><br><span class="line">COPY --from=build /bin/project /bin/project</span><br><span class="line">ENTRYPOINT [&quot;/bin/project&quot;]</span><br><span class="line">CMD [&quot;--help&quot;]</span><br></pre></td></tr></table></figure><p><br></p><p><strong>不要安装不必要的包</strong></p><p>Don’t install unnecessary packages<br>为了减少复杂性、依赖性，文件大小和构建时间，避免安装额外的或不不必要的软件包。</p><p><br></p><p><strong>分离应用程序</strong></p><p>Decouple applications<br>每个容器应该只有一个问题。将应用程序分离到多个容器中可以更轻松地水平伸缩和重新使用容器。<br>例如，Web应用程序堆栈可能有三个独立的容器组成，每个容器都有其独特的镜像，以分离的方式管理Web应用程序、数据库和内存缓存。</p><p>将每个容器限制为一个进程是一个很好的经验法则，但不是硬性规定。(想想高可用和负载均衡)。</p><p>尽你最大的努力使容器干净和模块化。如果容器相互依赖，则可以使用Docker container network来确保容器间可进行通信。</p><p><br></p><p><strong>最小化层数</strong></p><p>Minimize the number of layers<br>在老版本的docker中，重要的是减少镜像的层数，以确保它们的性能。</p><p><br></p><p><strong>对多行参数排序</strong></p><p>Sort multi-line arguments<br>只要有可能，通过按字母数字排序多行参数来简化修改。这有助于避免软件包重复，并使列表更容易更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">  bzr \</span><br><span class="line">  cvs \</span><br><span class="line">  git \</span><br><span class="line">  mercurial \</span><br><span class="line">  subversion</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Leverage build cache</strong></p><p>在构建镜像时，Docker安装Dockerfile中的指令逐步执行，并按指定的顺序执行每个镜像。在检查每条指令时，docker会在其缓存中查找可重用的现有镜像，而不是创建新的(重复)镜像。</p><p>如果你不想使用缓存，可在<code>docker build</code>命令中使用<code>--no-cache=true</code>选项。如果让Docker使用了缓存，那么了解何时可以 找到/找不到 匹配的图像就很重要了。</p><p>Docker遵循的基本规则如下:</p><ul><li>从已经在缓存中的父镜像开始，将下一条指令与该基本镜像派生的所有子镜像进行比较，以查看是否使用完全相同的指令构建了其中的一条。否则，缓存失效。</li><li>大多数情况下，只需将Dockerfile中的指令与其中一个子镜像进行比较久够了。但是，某些说明需要更多的检查和解释。</li><li>对于<code>ADD</code>和<code>COPY</code>指令，将检查镜像文件中的内容，并为每个文件计算校验和。在缓存查找过程中，将检验和与现有镜像中的校验和进行比较，如果文件中由任何内容已更改，如内容和元数据，则缓存将失效。</li><li>除了<code>ADD</code>和<code>COPY</code>指令，缓存检查将不会查看容器中的文件已确定缓存。</li></ul><p>一旦缓存失效，所有后续的Dockerfile命令将生产新的镜像，并且不会使用缓存。</p><p><br></p><p><strong>Dockerfile instruction</strong></p><p>请参考: <a href="# Dockerfile">Dockerfile</a></p><p><br></p><h4 id="创建一个基镜像"><a href="#创建一个基镜像" class="headerlink" title="创建一个基镜像"></a>创建一个基镜像</h4><p>Create a base image</p><p>大多数Dockerfile从父镜像开始，如果需要完全控制镜像的内容，则可能需要创建基镜像(base image)。区别:</p><ul><li>父镜像是镜像的所基于的镜像</li><li>基镜像的Dockerfile中没有<code>FROM</code>行</li></ul><p><br></p><h4 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h4><p>Use multi-stage builds</p><p>多阶段构建需要Docker v17.05及以上版本。多阶段构建对于优化Dockerfile来说非常有用，同时让它易读和维护。</p><p><br></p><p><strong>构建之前</strong><br>构建镜像最具挑战的事情是保持镜像的大小。Dockerfile中的每条指令都会为镜像添加一层，在移动到下一层前清理不需要的任何构件。为了编写一个高效的Dockerfile，需要尽可能减小图层，并确保每个层都具有上一层需要的构件，而不是其它东西。</p><p><strong>使用多阶段构建</strong><br>使用多阶段构建，你可以在Dockerfile中使用多个<code>FROM</code>语句。每条<code>FROM</code>命令可以使用不同的基镜像，并且每个指令都可是构建的新阶段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go .</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=0 /go/src/github.com/alexellis/href-counter/app .</span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure><p><code>COPY --from=0</code>将前面构建的工作复制到这个新阶段。Go SDK和任何中间工作件都被留下，并未保存在最终镜像中</p><p><br></p><p><strong>命名你的构建阶段</strong><br>默认情况下，构建阶段没有命名。你可以通过它们的整数来引用它们，第一个指令<code>FROM</code>从0开始。但你可以命名它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3 as builder</span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go    .</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=builder /go/src/github.com/alexellis/href-counter/app .</span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure><p><br></p><p><strong>停止一个特定的构建阶段</strong><br>构建镜像时，不一定需要构建包含每个阶段的整个Dockerfile。<br>如下的栗子停在名为<code>builder</code>的阶段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --target builder -t alexellis2/href-counter:latest .</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用外部镜像用作一个阶段</strong><br>多阶段构架可使用<code>COPY --from</code>指令从单独的镜像中进行复制，可以使用本机镜像、远程Registry的镜像和标记的ID。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="使用Docker-Engine-SDKs和API进行开发"><a href="#使用Docker-Engine-SDKs和API进行开发" class="headerlink" title="使用Docker Engine SDKs和API进行开发"></a>使用Docker Engine SDKs和API进行开发</h2><p>Develop with Docker Engine SDKs and API</p><p><br></p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Docker提供了一个用于与Docker daemon(称为Docker Engine API)交互的API，以及用于Go和Python的SDK。</p><p>SDK允许你款速轻松地构建和扩展Docker APP。<br>如果Go或Python不适合你，你可以直接使用Docker Engine API——它是由HTTP客户端(curl, wget)访问的RESTful API，或者是大多数现代编程语言的一部分HTTP库。</p><p><br></p><h3 id="安装SDKs"><a href="#安装SDKs" class="headerlink" title="安装SDKs"></a>安装SDKs</h3><h4 id="Go-SDK"><a href="#Go-SDK" class="headerlink" title="Go SDK"></a>Go SDK</h4><ul><li>Go SDK参考：<a href="https://godoc.org/github.com/docker/docker/client" target="_blank" rel="noopener">https://godoc.org/github.com/docker/docker/client</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/docker/docker/client</span><br></pre></td></tr></table></figure><p><br></p><h4 id="Python-SDK"><a href="#Python-SDK" class="headerlink" title="Python SDK"></a>Python SDK</h4><ul><li>Python SDK参考: <a href="https://docker-py.readthedocs.io/en/stable/" target="_blank" rel="noopener">https://docker-py.readthedocs.io/en/stable/</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install docker</span><br></pre></td></tr></table></figure><p><br></p><h3 id="快速开始SDK和API"><a href="#快速开始SDK和API" class="headerlink" title="快速开始SDK和API"></a>快速开始SDK和API</h3><p>Python: 运行一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import docker</span><br><span class="line">client = docker.from_env()</span><br><span class="line">print (client.containers.run(&quot;alpine&quot;, [&quot;echo&quot;, &quot;hello&quot;, &quot;world&quot;]))</span><br></pre></td></tr></table></figure><p>HTTP:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ curl --unix-socket /var/run/docker.sock -H &quot;Content-Type: application/json&quot; \</span><br><span class="line">  -d &apos;&#123;&quot;Image&quot;: &quot;alpine&quot;, &quot;Cmd&quot;: [&quot;echo&quot;, &quot;hello world&quot;]&#125;&apos; \</span><br><span class="line">  -X POST http:/v1.24/containers/create</span><br><span class="line">&#123;&quot;Id&quot;:&quot;1c6594faf5&quot;,&quot;Warnings&quot;:null&#125;</span><br><span class="line"></span><br><span class="line">$ curl --unix-socket /var/run/docker.sock -X POST http:/v1.24/containers/1c6594faf5/start</span><br><span class="line"></span><br><span class="line">$ curl --unix-socket /var/run/docker.sock -X POST http:/v1.24/containers/1c6594faf5/wait</span><br><span class="line">&#123;&quot;StatusCode&quot;:0&#125;</span><br><span class="line"></span><br><span class="line">$ curl --unix-socket /var/run/docker.sock &quot;http:/v1.24/containers/1c6594faf5/logs?stdout=1&quot;</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="SDK和API栗子"><a href="#SDK和API栗子" class="headerlink" title="SDK和API栗子"></a>SDK和API栗子</h3><p>链接: <a href="https://docs.docker.com/develop/sdk/examples/" target="_blank" rel="noopener">https://docs.docker.com/develop/sdk/examples/</a></p><p><br></p><hr><p><br></p><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><p>Configure networking</p><h2 id="综述-1"><a href="#综述-1" class="headerlink" title="综述"></a>综述</h2><p>Docker容器和服务如此强大的原因之一是——你可以将它们连接在一起，或将它们连接到non-docker工作负载。Docker容器和服务甚至不需要知道它们是否部署在Docker上，或它们的对等端是否也是Docker工作负载。都可以使用Docker方式管理它们。</p><p><br></p><h3 id="网络驱动"><a href="#网络驱动" class="headerlink" title="网络驱动"></a>网络驱动</h3><p>Network drivers</p><p>使用驱动程序，Docker的网络子系统是可插拔的(pluggable)。</p><p>集中驱动程序:</p><ul><li><p>brige<br>默认网络驱动。桥接网络通常用于你的应用程序运行在需要通信的独立容器中。</p></li><li><p>host<br>对于独立容器，删除容器和Docker主机之间的网络隔离，并直接使用主机的网络。</p></li><li><p>overlay<br>overlay网络将多个docker daemon连接在一起，并使集群服务能够无相互通信。</p></li><li><p>macvlan<br>macvlan网络允许你为容器分配MAC地址，使其成为你网络上的物理设备。docker daemon通过其MAC地址将流量路由到容器。</p></li><li><p>none<br>对于此容器，禁用所有网络。</p></li><li><p>network plugins<br>你可在Docker上安装和使用第三方网络插件，从Docker Store获取: <a href="https://store.docker.com" target="_blank" rel="noopener">https://store.docker.com</a></p></li></ul><p><br></p><p><strong>网络驱动总结</strong></p><ul><li><p><strong>User-defined bridge networks</strong><br>当你需要多个容器在同一个Docker主机上进行通信时</p></li><li><p><strong>Host networks</strong><br>当网络堆栈不应与Docker主机隔离时，但希望容器的其它方面被隔离</p></li><li><p><strong>Overlay networks</strong><br>当你需要运行在不同Docker主机上的容器进行通信时，或多个应用程序使用集群服务进行工作时</p></li><li><p><strong>Macvlan networks</strong><br>当你从虚拟机迁移或需要你的容器看起来像物理主机时，每个都具有唯一的MAC地址</p></li><li><p><strong>Third-party network plugins</strong><br>允许你将Docker与专用网络堆栈集成</p></li></ul><p><br><br><br></p><h2 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h2><p>就网络而言，桥接网络是一种链路层设备，用于转发网段之间的流量。桥接可以是硬件设备，或在主机内核中运行的软件设备。<br>就Docker而言，桥接网络允许连接到统一桥接网络的容器进行通信，同时提供与未连接到桥接网络的容器的隔离。Docker桥接驱动程序自动在主机上安装桥接规则，以便于不同桥接网络上的容器不能直接相互通信。</p><p>桥接网络适用于在同一个Docker daemon上运行的容器之间的通信。</p><p>当你启动Docker时，除非另有定义，否则将自动创建默认桥接网络，并且新启动的容器将连接到它。<br>你也可以创建用户自定义的桥接网络。</p><p><br><br><br></p><h3 id="bridge与user-defined-bridges"><a href="#bridge与user-defined-bridges" class="headerlink" title="bridge与user-defined bridges"></a>bridge与user-defined bridges</h3><p>Differences between user-defined bridges and the default bridge</p><p>两者的差别：</p><ul><li><p>用户自定义的桥接在集装箱化的应用程序之间提供了更好的隔离和互操作性</p></li><li><p>用户自定义的桥接提供了容器之间的自动DNS解析</p></li><li><p>容器可以在运行中与用户定义的网络进行连接(attach)和分离(detach)</p></li><li><p>每个用户定义的网络会创建一个可配置的桥接网络</p></li><li><p>在默认桥接网络上链接的容器共享环境变量</p></li></ul><p><br><br><br></p><h3 id="管理user-defined-bridge"><a href="#管理user-defined-bridge" class="headerlink" title="管理user-defined bridge"></a>管理user-defined bridge</h3><p>Manage a user-defined bridge</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker network create --help</span><br><span class="line"></span><br><span class="line">#创建一个用户自定义桥接网络</span><br><span class="line">#你还可以指定子网，范围，网关...</span><br><span class="line">docker network creat $&#123;name&#125;</span><br><span class="line"></span><br><span class="line">docker network creat my-net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">docker network rm $&#123;name&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="连接到自定义桥接网络"><a href="#连接到自定义桥接网络" class="headerlink" title="连接到自定义桥接网络"></a>连接到自定义桥接网络</h3><p>Connect a container to a user-defined bridge</p><p>当你创建一个新的容器时，你可以指定一个或多个<code>--network</code>标志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#创建时</span><br><span class="line">docker create --name my-nginx \</span><br><span class="line">  --network my-net \</span><br><span class="line">  --publish 8080:80 \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#运行中的容器</span><br><span class="line">docker network connect my-net my-nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#断开连接</span><br><span class="line">docker network disconnect my-net my-nginx</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用IPv6"><a href="#使用IPv6" class="headerlink" title="使用IPv6"></a>使用IPv6</h3><p>需要修改docker daemon的配置项以支持使用IPv6，在创建自定义网络是指定<code>--ipv6</code>标志。<br>你不能有选择地禁用默认桥接网络上的IPv6支持。</p><p><br><br><br></p><h3 id="启用容器转发"><a href="#启用容器转发" class="headerlink" title="启用容器转发"></a>启用容器转发</h3><p>Enable forwarding from Docker containers to the outside world</p><p>默认情况下，使用默认桥接网络的连接的容器的流量不会转发到外部世界。启用操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#配置Linux内核</span><br><span class="line">sysctl net.ipv4.conf.all.forwarding=1</span><br><span class="line"></span><br><span class="line">#修改iptables FORWARD默认策略</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line"></span><br><span class="line">#重启后无效，请写入配置文件</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="默认桥接网络"><a href="#默认桥接网络" class="headerlink" title="默认桥接网络"></a>默认桥接网络</h3><p>Use the default bridge network</p><p>默认桥接网络被视为Docker的遗留细节，不建议用于生产环境。</p><p><br></p><p><strong>连接容器到默认桥接网络</strong><br>如果未指定网络，则默认使用默认桥接网络。</p><p><strong>配置默认桥接网络</strong><br>指定并配置<code>daemon.json</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bip&quot;: &quot;192.168.1.5/24&quot;,</span><br><span class="line">  &quot;fixed-cidr&quot;: &quot;192.168.1.5/25&quot;,</span><br><span class="line">  &quot;fixed-cidr-v6&quot;: &quot;2001:db8::/64&quot;,</span><br><span class="line">  &quot;mtu&quot;: 1500,</span><br><span class="line">  &quot;default-gateway&quot;: &quot;10.20.1.1&quot;,</span><br><span class="line">  &quot;default-gateway-v6&quot;: &quot;2001:db8:abcd::89&quot;,</span><br><span class="line">  &quot;dns&quot;: [&quot;10.20.1.2&quot;,&quot;10.20.1.3&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用IPv6</strong><br>修改配置文件以支持IPv6，则默认桥接网络自动支持IPv6。</p><p><br><br><br></p><h2 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h2><p>overlay网络驱动在多个docker daemon主机之间创建分布式网络。该网络位于特定主机网络之上，允许容器连接到此并安全地进行通信。</p><p>当初始化集群或将docker主机加入现有集群时，将在docker主机上创建两个新网络：</p><ul><li><p>称为<code>ingress</code>的overlay网络<br>处理与集群服务相关的控制和数据流量。<br>当你创建集群服务并且不将其连接到用户自定义的网络时，它默认连接到<code>ingress</code>网络。</p></li><li><p>称为<code>docker_gwbridge</code>的桥接网络<br>将单独的docker daemon连接到集群的其它docker daemon。</p></li></ul><p>与创建自定义桥接网络类似，你也可以使用<code>docker network create</code>来创建自动以的overlay网络。服务或容器一次可连接到多个网络，但只能通过连接的网络进行通信。</p><p>尽管可以将集群服务和独立容器连接到overlay网络，但默认行为和配置是不同的。</p><p><br><br><br></p><h3 id="所有overlay网络的操作"><a href="#所有overlay网络的操作" class="headerlink" title="所有overlay网络的操作"></a>所有overlay网络的操作</h3><p>Operations for all overlay networks</p><p><br></p><h4 id="创建overlay网络"><a href="#创建overlay网络" class="headerlink" title="创建overlay网络"></a>创建overlay网络</h4><p>Create an overlay network</p><p><strong>先决条件</strong></p><ul><li><p>使用overlay网络的docker daemon的防火墙规则</p><ul><li>2377(tcp): 集群通信管理</li><li>7946(tcp/udp)： 节点通信</li><li>4789(udp)： overlay网络流量</li></ul></li><li><p>创建overlay网络前，需要初始化docker daemon集群</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d overlay my-overlay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建可供集群服务或独立容器与其它docker daemon上的独立容器进行通信</span><br><span class="line">docker network create -d overlay --attachable my-attachable-overlay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#你可以指定IP地址范围，子网，网关...</span><br></pre></td></tr></table></figure><p><br></p><h4 id="加密overlay网络上的流量"><a href="#加密overlay网络上的流量" class="headerlink" title="加密overlay网络上的流量"></a>加密overlay网络上的流量</h4><p>Encrypt traffic on an overlay network</p><p><strong>Overlay network encryption is not supported on Windows！</strong></p><p>所有集群服务管理流量默认都是加密的，在GCM模式下使用AES算法。<br>要加密应用程序数据，在创建overlay网络时添加<code>--opt encrypted</code>。这种加密带来了不可忽视的性能问题，所以应该在生产环境使用前对其进行测试。<br>当启用overlay加密时，docker会在节点间创建IPsec tunnel，在这些节点上调度连接到overlay网络的服务的任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#SWARM MODE OVERLAY NETWORKS AND STANDALONE CONTAINERS</span><br><span class="line"> docker network create --opt encrypted --driver overlay --attachable my-attachable-multi-host-network</span><br></pre></td></tr></table></figure><p><br></p><h4 id="自定义默认ingress网络"><a href="#自定义默认ingress网络" class="headerlink" title="自定义默认ingress网络"></a>自定义默认ingress网络</h4><p>如果自动选择的子网与已存在的网络冲突，或需要自定义其它低级网络设置(如MTU)，这次功能非常有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#显示详细信息</span><br><span class="line">docker network inspect ingress</span><br><span class="line"></span><br><span class="line">#移除现有网络</span><br><span class="line">docker network rm ingress</span><br><span class="line"></span><br><span class="line">#创建新网络 --ingress</span><br><span class="line">docker network create \</span><br><span class="line">  --driver overlay \</span><br><span class="line">  --ingress \</span><br><span class="line">  --subnet=10.11.0.0/16 \</span><br><span class="line">  --gateway=10.11.0.2 \</span><br><span class="line">  --opt com.docker.network.driver.mtu=1200 \</span><br><span class="line">  my-ingress</span><br></pre></td></tr></table></figure><p><br></p><h4 id="自定义docker-gwbridge"><a href="#自定义docker-gwbridge" class="headerlink" title="自定义docker_gwbridge"></a>自定义docker_gwbridge</h4><p><code>docker_gwbridge</code>是一个虚拟桥接网络，它将overlay网路连接到单独的docker daemon的物理网络。当初始化集群或将主机加入集群时，docker会自动创建它，但它不是docker设备。啊存在于docker主机的内核之中。如果你需要自定义其设置，则必须在主机加入集群之前或将主机临时从集群中删除之后才执行此操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 停止docker</span><br><span class="line"></span><br><span class="line">2. 删除已存在的docker_gwbridge</span><br><span class="line">ip link set docker_gwbridge doen</span><br><span class="line">ip link del dev docker_gwbridge</span><br><span class="line"></span><br><span class="line">3. 启动docker，但不加入或初始化集群</span><br><span class="line"></span><br><span class="line">4. 创建docker_gwbridge</span><br><span class="line">docker network create \</span><br><span class="line">--subnet 10.11.0.0/16 \</span><br><span class="line">--opt com.docker.network.bridge.name=docker_gwbridge \</span><br><span class="line">--opt com.docker.network.bridge.enable_icc=false \</span><br><span class="line">--opt com.docker.network.bridge.enable_ip_masquerade=true \</span><br><span class="line">docker_gwbridge</span><br><span class="line"></span><br><span class="line">5. 集群初始化或加入集群</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="swarm服务的操作"><a href="#swarm服务的操作" class="headerlink" title="swarm服务的操作"></a>swarm服务的操作</h3><p>Operations for swarm services</p><h4 id="在overlay网络上发布端口"><a href="#在overlay网络上发布端口" class="headerlink" title="在overlay网络上发布端口"></a>在overlay网络上发布端口</h4><p>Publish ports on an overlay network</p><p>连接到同一overlay网络的集群服务可有效地将所有端口暴露给对方。要是端口可在服务外可访问，必须使用<code>-p</code>或<code>--publish</code>标志暴露此端口。</p><p>两种方法：</p><ul><li>传统的冒号<code>:</code>分隔语法</li><li>较新的逗号<code>,</code>分隔语法</li></ul><div class="table-container"><table><thead><tr><th>Flag value</th><th>Description</th></tr></thead><tbody><tr><td>-p 8080:80 or <br> -p published=8080,target=80</td><td>Map TCP port 80 on the service to port 8080 on the routing mesh</td></tr><tr><td>-p 8080:80/udp or <br> -p published=8080,target=80,protocol=udp</td><td>Map UDP port 80 on the service to port 8080 on the routing mesh</td></tr><tr><td>-p 8080:80/tcp -p 8080:80/udp or <br> -p published=8080,target=80,protocol=tcp -p published=8080,target=80,protocol=udp</td><td>Map TCP port 80 on the service to TCP port 8080 on the routing mesh, and map UDP port 80 on the service to UDP port 8080 on the routine mesh</td></tr></tbody></table></div><p><br></p><h4 id="绕过swarm的路由网格"><a href="#绕过swarm的路由网格" class="headerlink" title="绕过swarm的路由网格"></a>绕过swarm的路由网格</h4><p>Bypass the routing mesh for a swarm service</p><p>默认情况下，发布端口的集群服务使用路由网格来发布。当你连接到任何swarm节点上已发布的端口时，都会透明地将你重定向到正在运行服务的工作。实际上，docker充当集群服务的负载均衡器(Load-Balancer)。使用路由网格的服务以虚拟IP(vip)模式运行。即使在每个节点上运行服务也使用路由网格。使用路由网格时，不能保证那个docker node处理客户端请求。</p><p>要绕过路由网格，可使用DNS Round Robin(DNSRR)模式启动——<code>--endpoint-mode dnsrr</code>。你必须在服务前运行负载均衡器。docker主机上DNS查询服务名称会返回运行该服务的节点的IP地址列表。配置你的负载均衡器使用此列表并平衡各节点间的流量。</p><p><br></p><h4 id="分离控制流量和数据流量"><a href="#分离控制流量和数据流量" class="headerlink" title="分离控制流量和数据流量"></a>分离控制流量和数据流量</h4><p>默认情况下，尽管集群控制流量是加密的，但集群管理和应用程序之间的控制流量运行在同一个网络上。你可以配置docker来使用单独的网络接口来处理来种不同类型的流量。</p><p><br><br><br></p><h3 id="overlay网络上独立容器的操作"><a href="#overlay网络上独立容器的操作" class="headerlink" title="overlay网络上独立容器的操作"></a>overlay网络上独立容器的操作</h3><p>Operations for standalone containers on overlay networks</p><h4 id="将独立容器连接到overlay网络"><a href="#将独立容器连接到overlay网络" class="headerlink" title="将独立容器连接到overlay网络"></a>将独立容器连接到overlay网络</h4><p>Attach a standalone container to an overlay network</p><p>独立容器连接到<code>ingress</code>网络需添加<code>--attachable</code>标志。这使得运行在不同docker daemon上的独立容器能够进行通信，而无需在各个docker daemon主机上设置路由。</p><p><br></p><h4 id="发布端口"><a href="#发布端口" class="headerlink" title="发布端口"></a>发布端口</h4><p>Publish ports</p><div class="table-container"><table><thead><tr><th>Flag value</th><th>Desciption</th></tr></thead><tbody><tr><td>-p 8080:80</td><td>Map TCP port 80 in the container to port 8080 on the overlay network</td></tr><tr><td>-p 8080:80/udp</td><td>Map UDP port 80 in the container to port 8080 on the overlay network</td></tr><tr><td>-p 8080:80/sctp</td><td>Map SCTP port 80 in the container to port 8080 on the overlay network</td></tr><tr><td>-p 8080:80/tcp -p 8080:80/udp</td><td>Map TCP port 80 in the container to TCP port 8080 on the overlay network, and map UDP port 80 in the container to UDP port 8080 on the overlay network</td></tr></tbody></table></div><p><br></p><h4 id="容器发现"><a href="#容器发现" class="headerlink" title="容器发现"></a>容器发现</h4><p>Container discovery</p><p>对于大多数情况，应该连接到服务名称——它是负载均衡的，并支持服务的所有容器处理。要获取支持该服务的所有任务的列表，请执行DNS查找服务——<code>tasks.&lt;service-name&gt;</code>。</p><p><br><br><br></p><h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><p>如果你对容器使用host网络驱动，则该容器的网络堆栈将不与docker主机隔离。例如，如果运行一个绑定在80端口并使用host网络的容器，则该容器的应用程序将在主机IP地址的80端口上可用。</p><p>host网络驱动只能运行在Linux主机上。</p><p><br><br><br></p><h2 id="Macvlan"><a href="#Macvlan" class="headerlink" title="Macvlan"></a>Macvlan</h2><p>一些应用程序，尤其是需要监视网络流量的应用程序，希望连接到物理网络上。在这种情况下，你可以使用<code>macvlan</code>驱动为容器的虚拟网络接口分配MAC地址，使其看起来像是直接连接到物理网络的物理网络接口。在这种情况下，你需要指定Docker主机上的物理接口用于macvlan，以及macvlan的子网和网关。</p><p><br></p><h3 id="创建一个macvaln网络"><a href="#创建一个macvaln网络" class="headerlink" title="创建一个macvaln网络"></a>创建一个macvaln网络</h3><p>macvlan网络可处于 <strong>bridge mode</strong> 或 <strong>802.1q trunk mode</strong>:</p><ul><li><p>在桥接模式下，macvlan流量通过主机上的物理设备</p></li><li><p>在802.1q主干桥接模式下，流量通过Docker在运行中创建的802.1q子接口。<br>这使你可以更细粒度地控制路由和过滤。</p></li></ul><p><br></p><p><strong>bridge mode</strong></p><p>创建bridge macvlan:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker networkcreate --driver macvlan \</span><br><span class="line">  --subnet=172.16.86.0/24 \</span><br><span class="line">  --gateway=172.16.86.1  \</span><br><span class="line">  -o parent=eth0 pub_net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--aux-addresses排除IP地址</span><br><span class="line">docker networkcreate --driver macvlan \</span><br><span class="line">  --subnet=172.16.86.0/24 \</span><br><span class="line">  --gateway=172.16.86.1  \</span><br><span class="line">  --aux-address=&quot;my-router=192.168.32.129&quot; \</span><br><span class="line">  -o parent=eth0 pub_net</span><br></pre></td></tr></table></figure><p><br></p><p><strong>802.1q truk bridge mode</strong></p><p>如果你指定了包含点<code>.</code>的接口名——如<strong>eth0.50</strong>，则Docker将其解释为eth0的子接口，并自动创建子接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker network  create  --driver macvlan \</span><br><span class="line">  --subnet=192.168.50.0/24 \</span><br><span class="line">  --gateway=192.168.50.1 \</span><br><span class="line">  -o parent=eth0.50 macvlan50</span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用ipvlan替换macvlan</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d ipvlan \</span><br><span class="line">  --subnet=192.168.210.0/24 \</span><br><span class="line">  --subnet=192.168.212.0/24 \</span><br><span class="line">  --gateway=192.168.210.254  \</span><br><span class="line">  --gateway=192.168.212.254  \</span><br><span class="line">  -o ipvlan_mode=l2 ipvlan210</span><br></pre></td></tr></table></figure><p><br></p><p><strong>IPv6</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker network  create  -d macvlan \</span><br><span class="line">  --subnet=192.168.216.0/24 --subnet=192.168.218.0/24 \</span><br><span class="line">  --gateway=192.168.216.1  --gateway=192.168.218.1 \</span><br><span class="line">  --subnet=2001:db8:abc8::/64 --gateway=2001:db8:abc8::10 \</span><br><span class="line">  -o parent=eth0.218 \</span><br><span class="line">  -o macvlan_mode=bridge macvlan216</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="禁用容器网络"><a href="#禁用容器网络" class="headerlink" title="禁用容器网络"></a>禁用容器网络</h2><p>在启动容器时加上`—network none来禁用容器的网络堆栈，这样在容器内便仅仅创建loopback设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -dit \</span><br><span class="line">  --network none \</span><br><span class="line">  --name no-net-alpine \</span><br><span class="line">  alpine:latest \</span><br><span class="line">  ash</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="网络教程"><a href="#网络教程" class="headerlink" title="网络教程"></a>网络教程</h2><p>Networking tutorials</p><p><br></p><h3 id="bridge-network"><a href="#bridge-network" class="headerlink" title="bridge network"></a>bridge network</h3><ul><li>default bridge network</li><li>user-defined bridge network</li></ul><p><br></p><h4 id="default-bridge-network"><a href="#default-bridge-network" class="headerlink" title="default bridge network"></a>default bridge network</h4><ol><li>基本docker网络</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">8d3b84bfe5a0        bridge              bridge              local</span><br><span class="line">3579d63da633        host                host                local</span><br><span class="line">f766b990db47        none                null                local</span><br></pre></td></tr></table></figure><p>以上列出了默认的桥接网络，主机网络(启动直接连接到docker daemon的主机的网络堆栈的容器)，none(启动一个没有网络设备的容器)。</p><p><br></p><ol><li>启动一个容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name alpine1 alpine ash</span><br></pre></td></tr></table></figure><p>由于启动时没有指定网络，所以默认为桥接网络。</p><p><br></p><ol><li>Inspect the bridge network，以查看哪个容器连接到它</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;8d3b84bfe5a034c65d043af80976a1e6127011fc1ab312446252f562e221d351&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-05-24T18:38:35.538308064+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;893903129d869f384bd78d63a382f1c9527d6979be0a6cf3c13ea4f45a1554d6&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;hardcore_rosalind&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;515d1435470c9f72d3b07680515d9c503457b8eb5bcaaaa915bb53901eac9424&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><ol><li>连接到容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker attach alpine1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ # ip addr show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">506: eth0@if507: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP </span><br><span class="line">    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ # ping -c 2 www.baidu.com</span><br><span class="line">PING www.baidu.com (119.75.216.20): 56 data bytes</span><br><span class="line">64 bytes from 119.75.216.20: seq=0 ttl=55 time=46.521 ms</span><br><span class="line">64 bytes from 119.75.216.20: seq=1 ttl=55 time=45.189 ms</span><br></pre></td></tr></table></figure><p><br></p><ol><li>ping其它容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ # ping -c 2 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.125 ms</span><br><span class="line">64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.075 ms</span><br></pre></td></tr></table></figure><p><br></p><h4 id="user-defined-bridge-networks"><a href="#user-defined-bridge-networks" class="headerlink" title="user-defined bridge networks"></a>user-defined bridge networks</h4><ol><li>创建名为<code>apline-net</code>用户自定义网络<br>当然，你可以手动指定子网，网关这些。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge alpine-net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docket network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">810fb1e02000        alpine-net          bridge              local</span><br><span class="line">8d3b84bfe5a0        bridge              bridge              local</span><br><span class="line">3579d63da633        host                host                local</span><br><span class="line">f766b990db47        none                null                local</span><br></pre></td></tr></table></figure><p><br></p><ol><li>查看alpine-net网络详情<br>注意网关和子网发生了变化。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect alpine-net</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;alpine-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;810fb1e020008c7c6598f3b830ca25896dde638b1190d383ee6a5214d284e77d&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-06-14T15:45:19.43941906+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><ol><li>创建两种网络的容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#alpine-net</span><br><span class="line">docker run -dit --name alpine1 --network alpine-net alpine ash</span><br><span class="line"></span><br><span class="line">#default bridge</span><br><span class="line">docker run -dit --name alpine2 alpine ash</span><br></pre></td></tr></table></figure><p><br></p><ol><li>显示两种网络情况</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;8d3b84bfe5a034c65d043af80976a1e6127011fc1ab312446252f562e221d351&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-05-24T18:38:35.538308064+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;893903129d869f384bd78d63a382f1c9527d6979be0a6cf3c13ea4f45a1554d6&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;hardcore_rosalind&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;515d1435470c9f72d3b07680515d9c503457b8eb5bcaaaa915bb53901eac9424&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;e7472c3ddda5043bc03868f4bf7ed59562220f05772f02f57ff589d086630562&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;alpine2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;ba565a247e347feb59713c188eb38e184d781da0489ae80e26ecad6d24e165c2&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker network inspect alpine-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;alpine-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;810fb1e020008c7c6598f3b830ca25896dde638b1190d383ee6a5214d284e77d&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-06-14T15:45:19.43941906+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;264ccde8b1d5198551d689f0dd49ffbfb612255e0bf76c9543325d7c2e588acb&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;alpine1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;563c48cc6b936bcd9d3f57e9bb5e162a8cb52a23c8980346f288d42cc9b0a8fc&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><ol><li>连接到容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker container attach alpine1</span><br><span class="line"></span><br><span class="line">#网段内通</span><br><span class="line">/ # ping -c 2 172.18.0.3</span><br><span class="line">PING 172.18.0.1 (172.18.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.097 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.070 ms</span><br><span class="line"></span><br><span class="line">--- 172.18.0.1 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 0.070/0.083/0.097 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#网段外不通</span><br><span class="line">/ # ping -c 2 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.16.0.1): 56 data bytes</span><br><span class="line"></span><br><span class="line">--- 172.17.0.2 ping statistics ---</span><br><span class="line">2 packets transmitted, 0 packets received, 100% packet loss</span><br></pre></td></tr></table></figure><p><br></p><ol><li>使容器连接到default bridge<br>这样，此容器便连接到了两个网络中。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network connect bridge apline1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ # ping -c 2 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.102 ms</span><br><span class="line">64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.071 ms</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="host-network"><a href="#host-network" class="headerlink" title="host network"></a>host network</h3><p>host网络不存在隔离问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#默认主机上的80端口</span><br><span class="line">docker run -rm -dit --network host --name my_nginx nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#访问</span><br><span class="line">http://localhost:80</span><br><span class="line">Welcome to nginx!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker network inspect host</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;host&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;3579d63da633adcc497417d39b8b1d270cf329a68b9222f6a75fae72086509d6&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-04-27T11:31:17.900886126+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;host&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;f02a3b11fce7228ad6ee196771bd9cf0b64966bfc2aa7c27719bc120dbdc7189&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;my_nginx&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;4ee67fb4d0a0c1a357b5fdd141f856a70c205fad5c49b1cb6a4f5245df0318a8&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="overlay-network"><a href="#overlay-network" class="headerlink" title="overlay network"></a>overlay network</h3><ul><li>default overlay network</li><li>user-defined overlay network</li><li>overlay network for standalone containers</li><li>Communicate between a container and a swarm service</li></ul><p><br></p><h4 id="default-overlay"><a href="#default-overlay" class="headerlink" title="default overlay"></a>default overlay</h4><p><strong>依赖：</strong></p><ul><li>swarm集群</li><li>集群节点<ul><li>worker-1</li><li>worker-2</li><li>mananger</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">495c570066be        bridge              bridge              local</span><br><span class="line">961c6cae9945        docker_gwbridge     bridge              local</span><br><span class="line">ff35ceda3643        host                host                local</span><br><span class="line">trtnl4tqnc3n        ingress             overlay             swarm</span><br><span class="line">c8357deec9cb        none                null                local</span><br></pre></td></tr></table></figure><p><br></p><p>创建nginx-net的overlay的网络:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d overlay nginx-net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ docker service create \</span><br><span class="line">  --name my-nginx \</span><br><span class="line">  --publish target=80,published=80 \</span><br><span class="line">  --replicas=5 \</span><br><span class="line">  --network nginx-net \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure><p><br></p><h4 id="user-defined-overlay"><a href="#user-defined-overlay" class="headerlink" title="user-defined overlay"></a>user-defined overlay</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d overlay my-overlay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ docker service create \</span><br><span class="line">  --name my-nginx \</span><br><span class="line">  --network my-overlay \</span><br><span class="line">  --replicas 1 \</span><br><span class="line">  --publish published=8080,target=80 \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p><br></p><h4 id="overlay-network-for-standalone-containers"><a href="#overlay-network-for-standalone-containers" class="headerlink" title="overlay network for standalone containers"></a>overlay network for standalone containers</h4><p><br></p><h4 id="Communicate-between-a-container-and-a-swarm-service"><a href="#Communicate-between-a-container-and-a-swarm-service" class="headerlink" title="Communicate between a container and a swarm service"></a>Communicate between a container and a swarm service</h4><p><br><br><br></p><h3 id="macvalan-network"><a href="#macvalan-network" class="headerlink" title="macvalan network"></a>macvalan network</h3><p>假设主机网络接口为<code>eth0</code>。</p><p><br></p><h4 id="bridge-1"><a href="#bridge-1" class="headerlink" title="bridge"></a>bridge</h4><p>此模式下，流量通过eth0流动，docker使用其MAC地址就流量路由到容器。</p><ol><li>创建名为<code>my-macvlan-net</code>的macvlan网络</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d macvlan \</span><br><span class="line">  --subnet=172.16.86.0/24 \</span><br><span class="line">  --gateway=172.16.86.1 \</span><br><span class="line">  -o parent=eth0 \</span><br><span class="line">  my-macvlan-net</span><br></pre></td></tr></table></figure><p><br></p><ol><li>查看网络</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">810fb1e02000        alpine-net          bridge              local</span><br><span class="line">8d3b84bfe5a0        bridge              bridge              local</span><br><span class="line">3579d63da633        host                host                local</span><br><span class="line">6be80655739d        my-macvlan-net      macvlan             local</span><br><span class="line">f766b990db47        none                null                local</span><br></pre></td></tr></table></figure><p><br></p><ol><li>以此网络运行容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -itd \</span><br><span class="line">  --network my-macvlan-net \</span><br><span class="line">  --name my-macvlan-alpine \</span><br><span class="line">  alpine:latest \</span><br><span class="line">  ash</span><br></pre></td></tr></table></figure><p><br></p><ol><li>查看my-macvlan-net</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect my-macvlan-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;my-macvlan-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;6be80655739deffe204e087d098f97fc75072d95f9818e129cfd7d5667ed01f3&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-06-14T16:52:30.507647877+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;macvlan&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.16.86.0/24&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.16.86.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;8301b669b4b63afb20911b46243f11b70e5a9d0880beaafa922b52bcb8ab0477&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;my-macvlan-alpine&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;4f2971ba4bd92c34e2a299d301f739867d2b1b65d35566aef07d7a26b079662c&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:10:56:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.16.86.2/24&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;parent&quot;: &quot;ens160&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><ol><li>查看容器网卡和路由</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker exec my-macvlan-alpine ip addr show eth0</span><br><span class="line">517: eth0@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UNKNOWN</span><br><span class="line">    link/ether 02:42:ac:10:56:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.16.86.2/24 brd 172.16.86.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">docker exec my-macvlan-alpine ip route</span><br><span class="line">default via 172.16.86.1 dev eth0</span><br><span class="line">172.16.86.0/24 dev eth0 scope link  src 172.16.86.2</span><br></pre></td></tr></table></figure><p><br></p><h4 id="802-1q-trunked-bridge-network"><a href="#802-1q-trunked-bridge-network" class="headerlink" title="802.1q trunked bridge network"></a>802.1q trunked bridge network</h4><p>此模式下，流量流经eth0的子接口(eth0.10)，docker使用其MAC地址将流量路由到容器。</p><ol><li>创建名为<code>my-8021q-macvlan-net</code>的macvlan网络</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d macvlan \</span><br><span class="line">  --subnet=172.16.87.0/24 \</span><br><span class="line">  --gateway=172.16.87.1 \</span><br><span class="line">  -o parent=eth0.10 \</span><br><span class="line">  my-8021q-macvlan-net</span><br></pre></td></tr></table></figure><p><br></p><ol><li>查看此网络</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line">NETWORK ID          NAME                   DRIVER              SCOPE</span><br><span class="line">2aeafd44fd67        my-8021q-macvlan-net   macvlan             local</span><br><span class="line">6be80655739d        my-macvlan-net         macvlan             local</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ifconfig</span><br><span class="line">eth0.10: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::20c:29ff:feaa:7e75  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:aa:7e:75  txqueuelen 0  (Ethernet)</span><br></pre></td></tr></table></figure><p><br></p><ol><li>用此网络启动一个容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -itd \</span><br><span class="line">  --network my-8021q-macvlan-net \</span><br><span class="line">  --name my-second-macvlan-alpine \</span><br><span class="line">  alpine:latest \</span><br><span class="line">  ash</span><br></pre></td></tr></table></figure><p><br></p><ol><li>查看my-8021q-macvlan-net</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect my-8021q-macvlan-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;my-8021q-macvlan-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;2aeafd44fd67e6ee937c82788745b1d45fb291efd61f545537528eafdff94e3d&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-06-14T17:06:33.426800076+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;macvlan&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.16.87.0/24&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.16.87.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;90103673d94915c3c7fb572eec8bd97b2aee1c3dab877c598d0a62e6d797b06d&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;my-second-macvlan-alpine&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;5c93f2ea1d29150ee57f099d42fc8e04a571efd0d1273a4f6bed755dc34f2e54&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:10:57:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.16.87.2/24&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;parent&quot;: &quot;ens160.10&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><ol><li>查看容器网络接口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker exec my-second-macvlan-alpine ip addr show eth0</span><br><span class="line">519: eth0@if518: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UNKNOWN </span><br><span class="line">    link/ether 02:42:ac:10:57:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.16.87.2/24 brd 172.16.87.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker exec my-second-macvlan-alpine ip route</span><br><span class="line">default via 172.16.87.1 dev eth0</span><br><span class="line">172.16.87.0/24 dev eth0 scope link  src 172.16.87.2</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="配置守护进程和容器"><a href="#配置守护进程和容器" class="headerlink" title="配置守护进程和容器"></a>配置守护进程和容器</h2><h3 id="启用IPv6"><a href="#启用IPv6" class="headerlink" title="启用IPv6"></a>启用IPv6</h3><p>启用IPv6前，请确保支持IPv6.</p><p>给docker daemon启用IPv6:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;ipv6&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>所有Docker的<code>iptables</code>规则都被添加到<code>DOKCER chain</code>。不要手动操作此表。<br>如果你需要添加Docker规则，请将其添加到<code>DOCKER-USER chain</code></p><p>栗子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I DOCKER-USER -m iprange -i ext_if ! --src-range 192.168.1.1-192.168.1.3 -j DROP</span><br></pre></td></tr></table></figure><p><br></p><h3 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h3><p>容器使用的网络类型(无论是bridge，overlay，macvlan还是自定义网络)，在容器内都是透明的。从容器的角度来看，它有一个带有IP地址，网关，路由表，DNS服务和其它网络细节的网络接口。</p><p><strong>publish port</strong><br>默认情况下，创建容器时，它不会将任何端口发布的外部世界。要是端口可用于docker之外的服务，请使用<code>--publish</code>或<code>-p</code>标志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-p 8080:80</span><br><span class="line">-p 192.168.1.100:8080:80</span><br><span class="line">-p 8080:80/udp</span><br><span class="line">-p 8080:80/tcp -p 8080:80/udp</span><br></pre></td></tr></table></figure><p><br></p><p><strong>ip add and hostname</strong><br>默认情况下，容器会为其连接的每个docker网络分配一个IP地址。IP地址是从分配给网络的地址池中分配的，因此docker daemon有效地充当了每个容器的DHCP服务器。每个网络也有一个默认的子网掩码和网关。<br>同样，一个容器的主机名也有docker daemon指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#指定运行网络</span><br><span class="line">docker run xxx --network</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#运行的容器连接到其它网络</span><br><span class="line">docker network connect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--ip，指定IP地址</span><br><span class="line">docker network connect my-bridge --ip 172.18.0.111</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--hostname，指定主机名</span><br><span class="line">docker run xxx --network xxx --hostname container-01</span><br><span class="line"></span><br><span class="line">docker network connect my-bridge --hostname container-02</span><br></pre></td></tr></table></figure><p><br></p><p><strong>DNS</strong><br>默认情况下，容器会继承docker daemon的DNS设置，包括<code>/etc/hosts</code>和<code>/etc/resolv.conf</code>。你也可以基于每个容器覆盖这些默认设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#DNS server</span><br><span class="line">--dns</span><br><span class="line"></span><br><span class="line">#DNS搜索域</span><br><span class="line">--dns-search</span><br><span class="line"></span><br><span class="line">#表示DNS选项值的键值对</span><br><span class="line">--dns-opt</span><br><span class="line"></span><br><span class="line">--hostname</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Docker使用代理服务器"><a href="#Docker使用代理服务器" class="headerlink" title="Docker使用代理服务器"></a>Docker使用代理服务器</h3><p>在启动docker容器的用户主目录下创建此文件： <code>~/.docker/config.json</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;proxies&quot;:</span><br><span class="line"> &#123;</span><br><span class="line">   &quot;default&quot;:</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;httpProxy&quot;: &quot;http://127.0.0.1:3001&quot;,</span><br><span class="line">     &quot;noProxy&quot;: &quot;*.test.example.com,.example2.com&quot;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="应用程序数据"><a href="#应用程序数据" class="headerlink" title="应用程序数据"></a>应用程序数据</h1><p>Manage application data</p><p><br></p><h2 id="存储综述"><a href="#存储综述" class="headerlink" title="存储综述"></a>存储综述</h2><p>Manage data in Docker</p><p>默认情况下，容器内创建的所有文件都被存储容器的可写层上：</p><ul><li><p>当容器不在运行时，数据不是持续存在的。容器外的进程很难从容器中获取数据</p></li><li><p>容器的可写层与主机紧密耦合，你很难将数据移动到其他地方</p></li><li><p>向容器的可写入层写入数据，需要存储驱动(storage driver)管理文件系统才<br>存储驱动使用Linux kernel来提供一个union filesystem。与直接写入主机文件系统的数据卷相比，这种额外的抽象会降低性能。</p></li></ul><p><br></p><p>Docker容器有两种选项将文件存储到主机上，这样即使容器停止之后这些文件也会被保留:</p><ul><li>volumes</li><li>bind mounts</li><li>tmpfs mount(Docker on Linux)</li></ul><p><br></p><h3 id="选择正确的挂载方式"><a href="#选择正确的挂载方式" class="headerlink" title="选择正确的挂载方式"></a>选择正确的挂载方式</h3><p>Choose the right type of mount</p><p>无论你选用哪种挂载方式，数据在容器内看起来都是相同的。它被公开为容器文件系统中的目录或单个文件。</p><p>一个简单的方法——考虑数据在docker主机上的位置，可以看出<strong>volumes, bind mounts, temfs</strong>之间的差异：</p><ul><li><p>Volumes<br>volumes存储在由docker管理的主机文件系统的一部分中(如Linux上: <code>/var/lib/docker/volumes/</code>)。<br>non-docker进程不应该修改这部分文件系统。Volume是Docker中保存数据的最佳方式。</p></li><li><p>Bind mounts<br>bind mounts可存储在主机系统上的任何地方。它们可能是最要的系统文件或目录。<br>docker主机或docker容器上的non-docker进程可以随时修改它们。</p></li><li><p>tmpfs<br>仅存储在主机系统的内存中，不会写入主机系统的文件系统。</p></li></ul><p><img src="/images/Docker/types-of-mounts.png" alt></p><p><br></p><h4 id="volumes的好栗子"><a href="#volumes的好栗子" class="headerlink" title="volumes的好栗子"></a>volumes的好栗子</h4><p>Good use cases for volumes</p><p>Volemes是在docker容器和服务中持久化数据的首选方式:</p><ul><li><p>在多个运行容器之间共享数据。如果你没有明确创建它，会在第一次挂载到容器时创建volume。当容器停止或删除时，volume仍然存在。多个容器可以挂载相同的volume，无论是read-write还是read-only。只有在你手动删除volume时它才会被删除。</p></li><li><p>当docker主机不能保证具有给定的目录或文件结构时，volume帮助你将docker主机的配置与运行时的容器进行分离。</p></li><li><p>当你想要将容器的数据存储在远程主机而不是本地的时候。</p></li><li><p>当你需要备份、还原或将数据从一台docker主机迁移到另一台时，volume时更好的选择。</p></li></ul><p><br></p><h4 id="bind-mounts的好栗子"><a href="#bind-mounts的好栗子" class="headerlink" title="bind mounts的好栗子"></a>bind mounts的好栗子</h4><p>一般来说，你应该尽量使用volumes。bind mounts适合以下案例：</p><ul><li><p>从主机共享配置文件到容器<br>这就是默认情况下，通过将主机的/<code>etc/resolv.conf</code>挂载到每个容器中，Docker为每个容器提供DNS解析。</p></li><li><p>在docker主机/容器的开发环境上共享源码或构建工件</p></li><li><p>当docker主机的文件或目录结构保证与容器所需的bind mounts一致时</p></li></ul><p><br></p><h4 id="tmpfs-mounts的好栗子"><a href="#tmpfs-mounts的好栗子" class="headerlink" title="tmpfs mounts的好栗子"></a>tmpfs mounts的好栗子</h4><p>当你不希望数据在主机上或容器内持久存储时，tmpfs mounts最合适。<br>这可能处于安全原因，或在应用于程序需要编写大量非持久性状态数据时保护容器的性能。</p><p><br></p><h4 id="使用bind或volumes的提示"><a href="#使用bind或volumes的提示" class="headerlink" title="使用bind或volumes的提示"></a>使用bind或volumes的提示</h4><p>如果你要使用bind mounts 或 volumes，牢记以下事项：</p><ul><li><p>如果你挂载一个空卷(empty volume)到存在文件或目录的容器中的目录上，则会将这些文件或目录赋值到卷中。同样，如果你启动容器并制定了一个尚不存在的卷，则会为你创建一个空卷。</p></li><li><p>如果你挂载一个bind mount或non-empty volume到存在文件或目录的容器中的目录上，则这些文件或目录会被挂载所遮蔽。就像在Linux上挂载卷一样。</p></li></ul><p><br><br><br></p><h2 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h2><p>volumes是持久化Docker数据的首选机制，卷由docker完全管理。另外，由于卷不会增加使用它的容器的大小，并且该卷的内容存在于给定容器的周期之外，因此卷通产是比将容器的可写入层中的数据持久化更好的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-v/--volume</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#此选项更详细和简单</span><br><span class="line">#如果你需要指定volume driver，请使用此flag</span><br><span class="line">--mount</span><br><span class="line"></span><br><span class="line">docker service create \</span><br><span class="line">  --mount &apos;type=volume,src=&lt;VOLUME-NAME&gt;,dst=&lt;CONTAINER-PATH&gt;,volume-driver=local,volume-opt=type=nfs,volume-opt=device=&lt;nfs-server&gt;:&lt;nfs-path&gt;,&quot;volume-opt=o=addr=&lt;nfs-address&gt;,vers=4,soft,timeo=180,bg,tcp,rw&quot;&apos;</span><br><span class="line">  --name myservice \</span><br><span class="line">  &lt;IMAGE&gt;</span><br></pre></td></tr></table></figure><ul><li><code>--volume</code></li></ul><p>由三个由冒号<code>:</code>分割的字段组成。这些字段必须按照正确的顺序排列，每个字段的含义并不明显。<br>第一个字段是卷的名称，并且在给定主机上是唯一的。对于匿名卷，第一个字段被省略。<br>第二个字段是文件或目录在容器中的挂载路径。<br>第三个字段是可选的，是由一个逗号`,分隔的选项列表。</p><ul><li><code>--mount</code></li></ul><p>由多个键值对组成，以逗号<code>,</code>分隔。<code>--mount</code>的语法比<code>--volume</code>更冗长，但键的顺序并不重要，并且标志的值更易于理解。<br>挂载的类型(type)有<code>bind, volume, tmpfs</code>。<br>挂载的来源(source, src)为卷的名称，对于匿名卷该字段可被省略。<br>目的地(destination, dst, target)的值是安装在容器中的文件或目录的路径。<br>只读(readonly)选项将导致bind mount以只读方式挂载到容器中。<br><code>volume-opt</code>选项可以多次指定，它是由选项名称和值组成的键值对组成。</p><p><br></p><h3 id="创建和管理卷"><a href="#创建和管理卷" class="headerlink" title="创建和管理卷"></a>创建和管理卷</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my-vol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               my-vol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2018-06-15T17:19:02+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/opt/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker volume rm my-vol</span><br></pre></td></tr></table></figure><p><br></p><h3 id="启动用卷的容器"><a href="#启动用卷的容器" class="headerlink" title="启动用卷的容器"></a>启动用卷的容器</h3><p>Start a container with a volume</p><p>包括两种卷：</p><ul><li><p>已存在的卷</p></li><li><p>未存在的卷<br>会自动创建</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount source=myvol2,target=/app \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --volume myvol2:/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               my-vol</span><br><span class="line">local               myvol2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker inspect devtest</span><br><span class="line">#找到挂载</span><br><span class="line">        &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;myvol2&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/opt/docker/volumes/myvol2/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/app&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><p><br></p><h3 id="启动用卷的服务"><a href="#启动用卷的服务" class="headerlink" title="启动用卷的服务"></a>启动用卷的服务</h3><p>Start a service with volumes</p><p>docker服务不支持使用<code>--volume</code>标志，请使用<code>--mount</code>标志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service create -d \</span><br><span class="line">  --replicas=4 \</span><br><span class="line">  --name devtest-service \</span><br><span class="line">  --mount source=myvol2,target=/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p><br></p><h3 id="在机器间共享数据"><a href="#在机器间共享数据" class="headerlink" title="在机器间共享数据"></a>在机器间共享数据</h3><p>Share data among machines</p><p>在构建容错应用程序时，可能需要配置同一服务的多个副本能访问相同的文件，而这些副本可能分布于不同的节点上。</p><p><img src="/images/Docker/share_data_amon_machine.png" alt></p><p>卷驱动程序(volume driver)允许你从应用程序逻辑中抽象出底层存储系统。</p><p><br></p><h3 id="使用卷驱动"><a href="#使用卷驱动" class="headerlink" title="使用卷驱动"></a>使用卷驱动</h3><p>Use a volume driver</p><p>在创建卷或启动带卷的容器时，你可以指定卷驱动。如<code>vieux/sshfs</code>卷驱动程序。</p><ul><li>初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker plugin install --grant-all-permissions vieux/sshfs</span><br></pre></td></tr></table></figure><ul><li>使用卷驱动创建卷</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#操作node2</span><br><span class="line">docker volume create --driver vieux/sshfs \</span><br><span class="line">  -o sshcmd=test@node2:/home/test \</span><br><span class="line">  -o password=testpassword \</span><br><span class="line">  sshvolume</span><br></pre></td></tr></table></figure><ul><li>启动一个带用卷驱动程序创建的卷的容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name sshfs-container \</span><br><span class="line">  --volume-driver vieux/sshfs \</span><br><span class="line">  --mount src=sshvolume,target=/app,volume-opt=sshcmd=test@node2:/home/test,volume-opt=password=testpassword \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><ul><li>备份，还原或迁移数据卷</li></ul><p>使用<code>--volumes-from</code>标志创建一个挂载该卷的新容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#备份</span><br><span class="line">docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#从备份还原</span><br><span class="line">docker run -v /dbdata --name dbstore2 ubuntu /bin/bash</span><br><span class="line">docker run --rm --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c &quot;cd /dbdata &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="bind-mounts"><a href="#bind-mounts" class="headerlink" title="bind mounts"></a>bind mounts</h2><p>与volumes相比，bind mounts功能有限。当你使用bind mounts时，主机上的文件或目录(绝对路径或相对路径)被挂载到容器内。相比之下，当你使用volumes时，会在主机上的Docker存储目录中创建一个新目录，并且Docker会管理该目录的内容。<br>该文件或目录不需要已经存在于Docker主机上。如果它尚未存在，它会根据需求创建。bind mounts非常高效，但是它们依赖于具有特定目录结构的主机文件系统。如果你正在开发新的Docker Application，请考虑使用volumes。你不能使用Docker CLI直接管理bind mounts。</p><p>你可以使用<code>--volume</code>或<code>--mount</code>(语法更详细)flag。具体区别参考volumes的介绍。</p><p><br></p><h3 id="启动用bind-mount的容器"><a href="#启动用bind-mount的容器" class="headerlink" title="启动用bind mount的容器"></a>启动用bind mount的容器</h3><p>Start a container with a bind mount</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p><br></p><p><strong>挂载到容器内非空目录</strong><br>如果挂载在容器内非空目录上，则该目录的已有内容将被隐藏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name broken-container \</span><br><span class="line">  --mount type=bind,source=/tmp,target=/usr \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name broken-container \</span><br><span class="line">  -v /tmp:/usr \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p><br></p><h3 id="只读bind-mount"><a href="#只读bind-mount" class="headerlink" title="只读bind mount"></a>只读bind mount</h3><p>Use a read-only bind mount</p><p>某些时候，容器可能只需要只读权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app,readonly \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app:ro \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p><br></p><h3 id="bind-propagation"><a href="#bind-propagation" class="headerlink" title="bind propagation"></a>bind propagation</h3><p>对于bind mounts和volumes，bind propagation(传播)默认为<code>rprivate</code>。它只能对Linux主机上的bind mounts进行配置。它是一个高级话题，许多用户并不需要配置它。</p><p>bind propagation(传播)是指在给定的bind-mounts或named volume中创建的挂载是否可以传播(propagation)到该挂载(mount)的副本(replicas)。<br>考虑一个挂载点<code>/mnt</code>，挂载在<code>/tmp</code>上。传播设置控制<code>/tmp/a</code>上的挂载点是否也可用于<code>/mnt/a</code>。每个传播设置都有一个递归对应点。在递归的情况下，考虑<code>/tmp/a</code>也被挂载到<code>/foo</code>。传播设置控制是否存在<code>/mnt/a</code>和<code>/tmp/a</code>。</p><div class="table-container"><table><thead><tr><th>传播设置</th><th>描述</th></tr></thead><tbody><tr><td>shared</td><td>原始mount的sub-mount会暴露给replica mounts，并且replica mounts的sub-mount同样传播给原始mount。也就是双向</td></tr><tr><td>slave</td><td>类似于shared，但仅限于单方向。</td></tr><tr><td>private</td><td>私有挂载</td></tr><tr><td>rshared</td><td>与shared相同，但传播也扩展到嵌套在任何原始或副本挂载点内的挂载点</td></tr><tr><td>rslave</td><td>与slave相同，但传播也扩展到嵌套在任何原始或副本挂载点内的挂载点</td></tr><tr><td>rprivate</td><td>默认值。与private相同，这意味着原始或副本挂载点内的任何位置的挂载点都不会沿任一方向传播</td></tr></tbody></table></div><p>在设置bind propagation之前，主机文件系统需要已经支持bind propagatin: <a href="https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app \</span><br><span class="line">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app2,readonly,bind-propagation=rslave \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app2:ro,rslave \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p><br></p><h3 id="selinux-label"><a href="#selinux-label" class="headerlink" title="selinux label"></a>selinux label</h3><p>如果你使用selinux，你可以添加<code>z</code>或<code>Z</code>选项来修改挂载到容器内的主机文件或目录的selinux标签。这户影响主机本身的文件或目录，并可能导致Docker范围之外的后果。</p><ul><li><p><code>z</code><br>bind mount的内容在多个容器之间共享。</p></li><li><p><code>Z</code><br>bind mount的内容是私有和非共享的。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#不支持--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app:z \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="tmpfs-mounts"><a href="#tmpfs-mounts" class="headerlink" title="tmpfs mounts"></a>tmpfs mounts</h2><p>tmpfs: <a href="https://docs.docker.com/storage/tmpfs/#limitations-of-tmpfs-mounts" target="_blank" rel="noopener">https://docs.docker.com/storage/tmpfs/#limitations-of-tmpfs-mounts</a><br>tmpfs mounts只支持运行在Linux上的Docker。</p><p><br><br><br></p><h2 id="Troubleshoot"><a href="#Troubleshoot" class="headerlink" title="Troubleshoot"></a>Troubleshoot</h2><p>troubleshoot: <a href="https://docs.docker.com/storage/troubleshooting_volume_errors/" target="_blank" rel="noopener">https://docs.docker.com/storage/troubleshooting_volume_errors/</a></p><p><br><br><br></p><h2 id="将数据存储到容器内"><a href="#将数据存储到容器内" class="headerlink" title="将数据存储到容器内"></a>将数据存储到容器内</h2><p>Store data within containers</p><h3 id="关于存储驱动"><a href="#关于存储驱动" class="headerlink" title="关于存储驱动"></a>关于存储驱动</h3><p>为了有效地使用存储驱动(storage driver)，了解Docker如何构建和存储镜像，以及容器如何使用镜像是很重要的。你可以使用这些信息作出明智的选择，以便找到应用程序数据持久化的最佳方式，并避免出现性能问题。</p><p>存储驱动允许你在容器的可写入层创建数据。在容器停止后，这些文件将不会被保留，并且读写速度都很低。</p><p><br></p><h4 id="镜像和层"><a href="#镜像和层" class="headerlink" title="镜像和层"></a>镜像和层</h4><p>Images and layers</p><p>Docker镜像由一系列层(layer)构建而成。每个层代表镜像的Dockerfile中的指令，除最后一层外的每个层都是只读的。</p><p>考虑如下Dockerfile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:15.04</span><br><span class="line">COPY . /app</span><br><span class="line">RUN make /app</span><br><span class="line">CMD python /app/app.py</span><br></pre></td></tr></table></figure><p>此Dockerfile包含4个命令，每个命令创建一个层。<br>当你创建一个新容器时，你在底层之上添加了一个新的可写入层——它通常被称为<strong>容器层(container layer)</strong>。<br>对运行中的容器所做的所有更改(增删改文件)都会写入此可写容器层。</p><p><img src="/images/Docker/container-layers.jpg" alt="容器层"></p><p>存储驱动处理有关这些层相互交互的详细信息。有几个不同的驱动程序，在不同的情况下具有相应的优点和缺点。</p><p><br></p><h4 id="容器和层"><a href="#容器和层" class="headerlink" title="容器和层"></a>容器和层</h4><p>Container and layers</p><p>容器和镜像之间的主要区别是最高的可写入层。当容器删除时，可写入层也被删除。但底层镜像保持不变。</p><p>由于每个容器都有自己的可写入容器层，并且所有的更改都存储在此容器中，因此多个容器可以共享相同的基础镜像的访问权限，并拥有自己的数据状态。</p><p><img src="/images/Docker/sharing-layers.jpg" alt="容器和层"></p><p>Docker使用存储驱动来管理镜像层和可写入容器层的内容。每个存储驱动程序都已不同方式实现，但所有驱动程序都是用可堆叠(stackable)的镜像层和写入时复制(copy-on-write)策略。</p><p><br></p><h4 id="容器大小"><a href="#容器大小" class="headerlink" title="容器大小"></a>容器大小</h4><p>Container size on disk</p><p>使用<code>docker ps -s(--size)</code>命令查看正在运行的容器的大小。有两个大小:</p><ul><li><p><code>size</code><br>每个容器的可写入层的数据量(在磁盘上的)</p></li><li><p><code>virtual size</code><br>容器使用的只读镜像的数据量加上容器可写入层大小</p></li></ul><p><br><br><br></p><h4 id="写入时复制"><a href="#写入时复制" class="headerlink" title="写入时复制"></a>写入时复制</h4><p>The copy-on-write (CoW) strategy</p><p>写入时复制是一种共享和复制文件以实现最高效率的策略。如果文件或目录存在于镜像的较低层中，而另外的层(包括可写入层)需要对其进行读取访问，则它只是用已有文件。第一次需要修改文件时，该文件将被复制到该层并进行修改。这最大限度减少了每个后续层的I/O和大小。</p><p><strong>共享促进了较小的容器</strong><br>Sharing promotes smaller images</p><p>当你创建和拉取镜像时，它们通常存储于本机的<code>/var/lib/docker</code>下。每层都存储在主机存储区内的特定目录下<code>/var/lib/docker/&lt;storage-driver&gt;/layers</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls /var/lib/docker/aufs/layers</span><br><span class="line"></span><br><span class="line">1d6674ff835b10f76e354806e16b950f91a191d3b471236609ab13a930275e24</span><br><span class="line">5dbb0cbe0148cf447b9464a358c1587be586058d9a4c9ce079320265e2bb94e7</span><br><span class="line">bef7199f2ed8e86fa4ada1309cfad3089e0542fec8894690529e4c04a7ca2d73</span><br><span class="line">ebf814eccfe98f2704660ca1d844e4348db3b5ccc637eb905d4818fbfb00a06a</span><br></pre></td></tr></table></figure><p><br></p><p><strong>复制使容器高效</strong><br>Copying makes containers efficient</p><p>容器不会更改的任何文件都不会被复制到此可写入层中。这意味着可写入层尽可能小。</p><p>当容器中存在的文件被修改时，存储驱动之赐你个写入时复制操作(CoW)。涉及的具体步骤取决于具体的存储驱动。</p><p>aufs, overlay, overlay2存储驱动 遵循的基本顺序:</p><ul><li>通过镜像层搜索要更新的文件</li><li>对找到的文件的第一个副本执行<code>copy_up</code>操作，将文件复制到容器的可写入层</li><li>任何修改应用于此复制的文件，并且该容器不能看到存在于较低层中的文件的只读副本</li></ul><p><br><br><br></p><h3 id="选择存储驱动"><a href="#选择存储驱动" class="headerlink" title="选择存储驱动"></a>选择存储驱动</h3><p>Select a storage driver</p><p>理想情况下，将很少的数据写入容器的可写入层，并且使用Docker volume写入数据。但某些工作负载要求你能够写入容器的可写入层，这就是存储驱动进来的地方。</p><p>存储驱动控制镜像和容器在Docker主机上的存储和管理方式。</p><p>考虑三个高层次因素：</p><ul><li><p>如果你的Kernel支持多个存储驱动，在没有指定存储驱动的情况下，Docker会列出要使用拿个存储驱动程序的优先级列表</p><ul><li>如果可能，将使用配置最少的存储驱动。如<code>brrfs</code>, <code>zfs</code></li><li>否则，请尝试在最常见的情况下使用具有最佳整体性能和稳定性的存储驱动程序<ul><li><code>overlay2</code>是首选(Docker CE的默认选择)，其次是<code>overlay</code>。这些都不需要额外的配置。</li><li><code>devicemapper</code>居次，但需要<code>direc-lvm</code>用于生产环境，因为<code>loopback-lvm</code>的性能很差。</li></ul></li></ul></li><li><p>你的选择会受限于Docker版本、操作系统和发行版</p></li><li><p>某些存储驱动要求你为文件系统使用特定格式</p></li><li><p>你的选择还取决于工作负载和所需的稳定级别</p></li></ul><p><br></p><h4 id="Linux发行版支持的存储驱动"><a href="#Linux发行版支持的存储驱动" class="headerlink" title="Linux发行版支持的存储驱动"></a>Linux发行版支持的存储驱动</h4><p><strong>Docker CE</strong></p><div class="table-container"><table><thead><tr><th>Linux distribution</th><th>Recommended storage drivers</th></tr></thead><tbody><tr><td>Docker CE on Ubuntu</td><td>aufs, devicemapper, overlay2 (Ubuntu 14.04.4 or later, 16.04 or later), overlay, zfs, vfs</td></tr><tr><td>Docker CE on Debian</td><td>aufs, devicemapper, overlay2 (Debian Stretch), overlay, vfs</td></tr><tr><td>Docker CE on CentOS</td><td>devicemapper, vfs</td></tr><tr><td>Docker CE on Fedora</td><td>devicemapper, overlay2 (Fedora 26 or later, experimental), overlay (experimental), vfs</td></tr></tbody></table></div><p><br></p><h4 id="存储驱动支持的文件系统"><a href="#存储驱动支持的文件系统" class="headerlink" title="存储驱动支持的文件系统"></a>存储驱动支持的文件系统</h4><div class="table-container"><table><thead><tr><th>Storage driver</th><th>Supported backing filesystems</th></tr></thead><tbody><tr><td>overlay, overlay2</td><td>ext4, xfs</td></tr><tr><td>aufs</td><td>ext4, xfs</td></tr><tr><td>devicemapper</td><td>direct-lvm</td></tr><tr><td>btrfs</td><td>btrfs</td></tr><tr><td>zfs</td><td>zfs</td></tr></tbody></table></div><p><br></p><h4 id="查看存储驱动"><a href="#查看存储驱动" class="headerlink" title="查看存储驱动"></a>查看存储驱动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Version: 18.03.1-ce</span><br><span class="line">Storage Driver: overlay2</span><br></pre></td></tr></table></figure><p><br></p><h3 id="AUFS存储驱动"><a href="#AUFS存储驱动" class="headerlink" title="AUFS存储驱动"></a>AUFS存储驱动</h3><p>AUFS is a union filesystem.</p><p>aufs存储驱动用于管理Ubuntu上Docker的镜像和层。</p><p>我的发行版是Centos，此驱动针对Ubuntu。注意</p><p><br></p><h4 id="使用aufs存储驱动配置Docker"><a href="#使用aufs存储驱动配置Docker" class="headerlink" title="使用aufs存储驱动配置Docker"></a>使用aufs存储驱动配置Docker</h4><ul><li>判断kernel是否支持aufs</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep aufs /proc/filesystems</span><br></pre></td></tr></table></figure><ul><li>查看Docker存储驱动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><ul><li>配置存储驱动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">--storage-driver</span><br></pre></td></tr></table></figure><p><br></p><h4 id="aufs存储驱动如何工作"><a href="#aufs存储驱动如何工作" class="headerlink" title="aufs存储驱动如何工作"></a>aufs存储驱动如何工作</h4><p>AUFS是一个联合文件系统，这意味着它在单个Linux主机上对多个目录进行分层并将它们呈现为单个目录。这些目录在AUFS术语中称为分支，在Docker术语中称为层。统一过程被称为联合安装。</p><p><img src="/images/Docker/aufs_layers.jpg" alt></p><p><br></p><h4 id="容器如何使用aufs进行读写"><a href="#容器如何使用aufs进行读写" class="headerlink" title="容器如何使用aufs进行读写"></a>容器如何使用aufs进行读写</h4><p><strong>读取文件</strong></p><p><br></p><h3 id="Btrfs存储驱动"><a href="#Btrfs存储驱动" class="headerlink" title="Btrfs存储驱动"></a>Btrfs存储驱动</h3><p>Use the BTRFS storage driver</p><p><br></p><h3 id="Device-Mapper存储驱动"><a href="#Device-Mapper存储驱动" class="headerlink" title="Device Mapper存储驱动"></a>Device Mapper存储驱动</h3><p>Use the Device Mapper storage driver</p><p>Device Mapper是基于kernel的框架，支持Linux上的许多高级卷管理技术。Docker的<code>devicemapper</code>存储驱动利用此框架的精简配置和快照功能进行镜像和容器管理。</p><p>对于支持它的系统，<code>devicemapper</code>支持包含在Linux内核中。但是，需要特定配置才能将其用于Docker。<code>devicemapper</code>驱动使用专用于Docker的块设备，并在块级(block level)而不是文件级(file level)运行。这些设备可通过在Docker主机添加物理设备来扩展，并且它们比咋子操作系统级别使用文件系统更好。</p><p><br></p><p><strong>依赖</strong></p><ul><li>Docker EE</li><li>Docker CE</li><li>更改存储驱动会使已创建的容器在本地系统上都无法访问</li></ul><p><br></p><p><strong>配置devicemapper存储驱动</strong></p><ul><li>loop-lvm</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#loop-lvm模式</span><br><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;storage-driver&quot;: &quot;devicemapper&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><ul><li>direct-lvm<br>生产环境的devicemapper存储驱动必须使用direct-lvm模式。此模式使用块设备创建精简池。这比使用loopback设备更快，更高效地使用系统资源，并且块设备可以根据需求进行扩展。</li></ul><p><br></p><div class="table-container"><table><thead><tr><th>Option</th><th>Description</th><th>Required</th><th>Default</th><th>Example</th></tr></thead><tbody><tr><td>dm.directlvm_device</td><td>The path to the block device to configure for direct-lvm.</td><td>Yes</td><td>-</td><td>dm.directlvm_device=”/dev/xvdf”</td></tr><tr><td>dm.thinp_percent</td><td>The percentage of space to use for storage from the passed in block device.</td><td>No</td><td>95</td><td>dm.thinp_percent=95</td></tr><tr><td>dm.thinp_metapercent</td><td>The percentage of space to for metadata storage from the passed-in block device.</td><td>No</td><td>1</td><td>dm.thinp_metapercent=1</td></tr><tr><td>dm.thinp_autoextend_threshold</td><td>The threshold for when lvm should automatically extend the thin pool as a percentage of the total storage space.</td><td>No</td><td>80</td><td>dm.thinp_autoextend_threshold=80</td></tr><tr><td>dm.thinp_autoextend_percent</td><td>The percentage to increase the thin pool by when an autoextend is triggered.</td><td>No</td><td>20</td><td>dm.thinp_autoextend_percent=20</td></tr><tr><td>dm.directlvm_device_force</td><td>Whether to format the block device even if a filesystem already exists on it. If set to false and a filesystem is present, an error is logged and the filesystem is left intact.</td><td>No</td><td>false</td><td>dm.directlvm_device_force=true</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#安装依赖</span><br><span class="line">RHEL / CentOS: device-mapper-persistent-data, lvm2, and all dependencies</span><br><span class="line">Ubuntu / Debian: thin-provisioning-tools, lvm2, and all dependencies</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建物理卷(physical volume)</span><br><span class="line">pvcreate /dev/cvdf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建卷组(volume group)</span><br><span class="line">vgcreat docker /dev/xvdf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建逻辑卷(logical volume)</span><br><span class="line">lvcreate --wipesignatures y -n thinpool docker -l 95%VG</span><br><span class="line">lvcreate --wipesignatures y -n thinpoolmeta docker -l 1%VG</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#转换卷为精简池</span><br><span class="line">lvconvert -y \</span><br><span class="line">--zero n \</span><br><span class="line">-c 512K \</span><br><span class="line">--thinpool docker/thinpool \</span><br><span class="line">--poolmetadata docker/thinpoolmeta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#配置lvm配置文件精简池自动扩展</span><br><span class="line">/etc/lvm/profile/docker-thinpool.profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定thin_pool_autoextend_threshold 和 thin_pool_autoextend_percent的值</span><br><span class="line">activation &#123;</span><br><span class="line">  thin_pool_autoextend_threshold=80</span><br><span class="line">  thin_pool_autoextend_percent=20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#应用LVM profile</span><br><span class="line">lvchange --metadataprofile docker-thinpool docker/thinpool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启用监控LV</span><br><span class="line">lvs -o+seg_monitor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#配置devicemapper存储驱动</span><br><span class="line">/etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;storage-driver&quot;: &quot;devicemapper&quot;,</span><br><span class="line">    &quot;storage-opts&quot;: [</span><br><span class="line">    &quot;dm.thinpooldev=/dev/mapper/docker-thinpool&quot;,</span><br><span class="line">    &quot;dm.use_deferred_removal=true&quot;,</span><br><span class="line">    &quot;dm.use_deferred_deletion=true&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><p><br></p><h4 id="管理devicemapper"><a href="#管理devicemapper" class="headerlink" title="管理devicemapper"></a>管理devicemapper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查看LVM logs</span><br><span class="line">journalctl -fu dm-event.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pvdisplay</span><br><span class="line">vgdisplay/vgextend</span><br><span class="line">lvdisplay/lvextend/lvchange</span><br></pre></td></tr></table></figure><p><br></p><h3 id="OverlayFS存储驱动"><a href="#OverlayFS存储驱动" class="headerlink" title="OverlayFS存储驱动"></a>OverlayFS存储驱动</h3><p>Use the OverlayFS storage driver</p><p><br></p><h3 id="ZFS存储驱动"><a href="#ZFS存储驱动" class="headerlink" title="ZFS存储驱动"></a>ZFS存储驱动</h3><p>Use the ZFS storage driver</p><p><br></p><h3 id="VFS存储驱动"><a href="#VFS存储驱动" class="headerlink" title="VFS存储驱动"></a>VFS存储驱动</h3><p>Use the VFS storage driver</p><p>VFS存储驱动不是联合文件系统，相反，每层都是磁盘上的一个目录，它不支持CoW。要创建一个新层，先前的层会进行<strong>深层复制(deep copy)</strong>。与其它驱动相比，这导致磁盘性能下降和占用更多磁盘空间。但是，它强大，稳定，适用于各种环境。</p><p><strong>配置VFS存储驱动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;storage-driver&quot;: &quot;vfs&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#控制大小</span><br><span class="line">&#123;</span><br><span class="line">  &quot;storage-opts&quot;: [&quot;size=256M&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="在生产环境运行应用程序"><a href="#在生产环境运行应用程序" class="headerlink" title="在生产环境运行应用程序"></a>在生产环境运行应用程序</h1><p>Run your app in production</p><p><br></p><h2 id="配置对象"><a href="#配置对象" class="headerlink" title="配置对象"></a>配置对象</h2><p>Configure all objects</p><p><br></p><h3 id="自定义原数据"><a href="#自定义原数据" class="headerlink" title="自定义原数据"></a>自定义原数据</h3><p>Apply custom metadata to objects</p><p><strong>Docker object label</strong><br>标签(label)是一种将原数据(metadata)应用于docker object的机制，包含:</p><ul><li>image</li><li>container</li><li>local daemon</li><li>volume</li><li>network</li><li>node</li><li>service</li></ul><p><br></p><h4 id="label-key-and-value"><a href="#label-key-and-value" class="headerlink" title="label key and value"></a>label key and value</h4><p>标签是一组键值对，以字符串形式存储。可以为对象指定多个标签，但每个键值对必须唯一。如果一个键有多个值，则最新写入的值会覆盖以前的值。</p><p><strong>key格式建议</strong><br>label key是可能包含字母，数字，<code>.</code>，<code>-</code>组成的字符串。</p><ul><li>第三方工具的作者给每个label key加上前缀域，如<code>com.example.some-label</code></li><li>未经允许，不得使用他人域</li><li><code>com.docker.*</code>, <code>io.docker.*</code>, <code>org.dockerproject.*</code>命名空间保留给Docker内部使用</li><li>以小写字母开头和结尾</li><li>用<code>.</code>分割命令空间字段</li></ul><p><br></p><p><strong>value 指南</strong><br>label value可以包含任何可表示为字符串的数据类型，包括JSON, XML, CSV, YAML…唯一的要求是，首先使用特定于结构类型的机制将该值序列化为字符串。</p><p><br><br><br></p><h3 id="清理未使用的对象"><a href="#清理未使用的对象" class="headerlink" title="清理未使用的对象"></a>清理未使用的对象</h3><p>Prune unused Docker objects</p><p>Docker采取保守的方法来清理未使用的对象(通常称为垃圾回收)，通常它不会删除这些对象，除非你明确要求Docker这样做。对于每个类型的对象，docker提供了<code>prune</code>命令。你也可以使用<code>docker system prune</code>命令一次清理多种类型的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#prune image</span><br><span class="line">docker image prune</span><br><span class="line"> docker image prune -a --filter &quot;until=24h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#prune container</span><br><span class="line">docker container prune</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#prune volume</span><br><span class="line">docker volume prune</span><br><span class="line">docker volume prune --filter &quot;label!=keep&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#prune everything</span><br><span class="line">docker system prune</span><br><span class="line">docker system prune --volumes</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>Format command and log output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#join</span><br><span class="line">docker inspect --format &apos;&#123;&#123;join .Args &quot; , &quot;&#125;&#125;&apos; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#json</span><br><span class="line">docker inspect --format &apos;&#123;&#123;json .Mounts&#125;&#125;&apos; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#lower</span><br><span class="line">docker inspect --format &quot;&#123;&#123;lower .Name&#125;&#125;&quot; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#split</span><br><span class="line">docker inspect --format &apos;&#123;&#123;split .Image &quot;:&quot;&#125;&#125;&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#title</span><br><span class="line">docker inspect --format &quot;&#123;&#123;title .Name&#125;&#125;&quot; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#upper</span><br><span class="line">docker inspect --format &quot;&#123;&#123;upper .Name&#125;&#125;&quot; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#printIn</span><br><span class="line">docker inspect --format=&apos;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;println .IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&apos; container</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="配置daemon"><a href="#配置daemon" class="headerlink" title="配置daemon"></a>配置daemon</h2><p>Configure the daemon</p><p><br></p><h3 id="配置和运行Docker"><a href="#配置和运行Docker" class="headerlink" title="配置和运行Docker"></a>配置和运行Docker</h3><p><strong>配置docker daemon</strong></p><ul><li>使用json配置文件</li><li>使用<code>dockerd --flag</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;debug&quot;: true,</span><br><span class="line">  &quot;tls&quot;: true,</span><br><span class="line">  &quot;tlscert&quot;: &quot;/var/docker/server.pem&quot;,</span><br><span class="line">  &quot;tlskey&quot;: &quot;/var/docker/serverkey.pem&quot;,</span><br><span class="line">  &quot;hosts&quot;: [&quot;tcp://192.168.59.3:2376&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">dockerd --debug \</span><br><span class="line">  --tls=true \</span><br><span class="line">  --tlscert=/var/docker/server.pem \</span><br><span class="line">  --tlskey=/var/docker/serverkey.pem \</span><br><span class="line">  --host tcp://192.168.59.3:2376</span><br></pre></td></tr></table></figure><p><br></p><p><strong>docker daemon目录</strong><br>docker daemon将所有数据保存在一个目录中。你可以手动修改它。</p><p>默认目录:</p><ul><li>Linux： <code>/var/lib/docker</code></li><li>Windows: <code>C:\ProgramData\docker</code></li></ul><p><br><br><br></p><h3 id="使用systemd控制docker"><a href="#使用systemd控制docker" class="headerlink" title="使用systemd控制docker"></a>使用systemd控制docker</h3><p>Control Docker with systemd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/lib/systemd/system/docker.service</span><br><span class="line">#or</span><br><span class="line">cat /etc/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl enable/start/stop/status docker</span><br></pre></td></tr></table></figure><p><br></p><p><strong>自定义docker daemon选项</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;data-root&quot;: &quot;/mnt/docker-data&quot;,</span><br><span class="line">    &quot;storage-driver&quot;: &quot;overlay&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>http/https proxy</strong><br>Docker daemon使用<code>HTTP_PROXY</code>，<code>HTTPS_PROXY</code>和<code>NO_PROXY</code>环境变量来配置代理行为。无法使用<code>daemon.json</code>文件来配置环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#/etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot;</span><br><span class="line"></span><br><span class="line">#/etc/systemd/system/docker.service.d/https-proxy.conf</span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTPS_PROXY=https://proxy.example.com:443/&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl show --property=Environment docker</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="收集Docker指标"><a href="#收集Docker指标" class="headerlink" title="收集Docker指标"></a>收集Docker指标</h3><p>Collect Docker metrics with Prometheus</p><p>Promethus: <a href="https://prometheus.io/" target="_blank" rel="noopener">https://prometheus.io/</a><br>Prometheus是一个开源的系统监控和报警工具包。你可以将Docker配置为Prometheus target。设置Prometheus作为Docker容器运行，并使用Prometheus监控Docker实例。</p><p><strong>配置Docker</strong><br>配置docker daemon作为Prometheus target，你需要指定<code>metrics-address</code>。最佳方式是通过<code>daemon.json</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;metrics-addr&quot; : &quot;127.0.0.1:9323&quot;,</span><br><span class="line">  &quot;experimental&quot; : true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置和运行Prometheus</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/tmp/prometheus.yml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># my global config</span><br><span class="line">global:</span><br><span class="line">  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br><span class="line">  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.</span><br><span class="line">  # scrape_timeout is set to the global default (10s).</span><br><span class="line"></span><br><span class="line">  # Attach these labels to any time series or alerts when communicating with</span><br><span class="line">  # external systems (federation, remote storage, Alertmanager).</span><br><span class="line">  external_labels:</span><br><span class="line">      monitor: &apos;codelab-monitor&apos;</span><br><span class="line"></span><br><span class="line"># Load rules once and periodically evaluate them according to the global &apos;evaluation_interval&apos;.</span><br><span class="line">rule_files:</span><br><span class="line">  # - &quot;first.rules&quot;</span><br><span class="line">  # - &quot;second.rules&quot;</span><br><span class="line"></span><br><span class="line"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class="line"># Here it&apos;s Prometheus itself.</span><br><span class="line">scrape_configs:</span><br><span class="line">  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br><span class="line">  - job_name: &apos;prometheus&apos;</span><br><span class="line"></span><br><span class="line">    # metrics_path defaults to &apos;/metrics&apos;</span><br><span class="line">    # scheme defaults to &apos;http&apos;.</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&apos;localhost:9090&apos;]</span><br><span class="line"></span><br><span class="line">  - job_name: &apos;docker&apos;</span><br><span class="line">         # metrics_path defaults to &apos;/metrics&apos;</span><br><span class="line">         # scheme defaults to &apos;http&apos;.</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&apos;localhost:9323&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service create --replicas 1 --name my-prometheus \</span><br><span class="line">    --mount type=bind,source=/tmp/prometheus.yml,destination=/etc/prometheus/prometheus.yml \</span><br><span class="line">    --publish published=9090,target=9090,protocol=tcp \</span><br><span class="line">    prom/prometheus</span><br></pre></td></tr></table></figure><p>访问: <a href="http://localhost:9090/targets/" target="_blank" rel="noopener">http://localhost:9090/targets/</a></p><p><br><br><br></p><h2 id="配置容器"><a href="#配置容器" class="headerlink" title="配置容器"></a>配置容器</h2><p>Configure containers</p><h3 id="自动启动容器"><a href="#自动启动容器" class="headerlink" title="自动启动容器"></a>自动启动容器</h3><p>Start containers automatically</p><p>Docker提供了重启策略，以控制容器在退出或重启时自动启动。重启策略可确保链接的容器以正确的书序启动。Docker建议你使用重启策略，并避免使用进程管理器(如supervisor)来启动容器。<br>重启策略与<code>docker xxx --live-restart</code>标志不同，后者可以让你在Docker upgrage期间保持容器运行。</p><p><br></p><p><strong>重启策略</strong><br>使用<code>docker run xxx --restart</code>标志来配置重启策略，<code>--restart</code>的值如下：</p><div class="table-container"><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>no</td><td>不要自动重启容器(默认值)</td></tr><tr><td>on-failure</td><td>如果容器由于错误(非零退出码)退出，则重启容器</td></tr><tr><td>unless-stopped</td><td>除非明确停止或docker本身停止或重启，则重启容器</td></tr><tr><td>always</td><td>如果停止，则始终重启容器</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#栗子</span><br><span class="line">docker run -dit --restart unless-stopped redis</span><br></pre></td></tr></table></figure><p><br></p><p><strong>重启策略注意事项</strong></p><ul><li><p>重启策略尽在容器成功启动后才生效——这意味着容器已启动至少10s，并且Docker已开始监视它。<br>这可以防止根本不启动的容器进入重启循环。</p></li><li><p>如果你手动停止容器(状态码为0)，则在重启Docker daemon或手动启动容器之前，其重启策略将会被忽略。<br>这是另一个防止重启循环的尝试。</p></li><li><p>重启策略仅适用于容器。集群服务的重启策略与此不同。</p></li></ul><p><br><br><br></p><h3 id="在daemon停机期间保持容器活着"><a href="#在daemon停机期间保持容器活着" class="headerlink" title="在daemon停机期间保持容器活着"></a>在daemon停机期间保持容器活着</h3><p>Keep containers alive during daemon downtime</p><p>默认情况下，当Docker daemon终止时，它会关闭正在运行的容器。从Docker Engine 1.12开始，你可配置守护进程，以便在守护进程不可用时容器保持运行。这个功能被称为<strong>实时恢复(live restore)</strong>。<br>它不支持Windows container。</p><p><br></p><p><strong>实时恢复</strong><br>有两种方式来启用live restore，只启用其中一个就好。<br>实时恢复仅适用于独立容器，不适用于集群服务。</p><ul><li>修改配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>--live-restore</code>标志<br>不推荐</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockerd xxx --live-restore</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="在一个容器中运行多个服务"><a href="#在一个容器中运行多个服务" class="headerlink" title="在一个容器中运行多个服务"></a>在一个容器中运行多个服务</h3><p>Run multiple services in a container</p><p>容器的主要运行进程是Dockerfile末尾的<code>ENTRYPOINT</code>或<code>CMD</code>指令。通常建议你通过每个容器运行一项服务来分割关注区域。这些服务可能会分成多个进程(如Nginx的worker processe)。你可以使用用户定义的network和shared volumes来连接多个容器。</p><p>容器的主进程负责管理它启动的所有进程。在某些情况下，主进程设计不好，在容器退出时无法正常处理<strong>停止</strong>子进程。如果你的进程属于这个类别，你可在容器运行时使用<code>--init</code>选型。<code>--init</code>标志将一个微小的<code>inti-process</code>作为主进程插入到容器中，并在容器退出时处理所有进程的停止。以这种方式处理这些进程优于使用完整的初始化进程。</p><p><br></p><p>如果你需要在一个容器中运行多个服务，则可通过几种不同方式来完成此操作。</p><ul><li>将所有命令封装进一个脚本中，并附带测试和调试信息。以封装脚本作为你的CMD</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vim my_wrapper.sh</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">xxxxx</span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim Dockerfile</span><br><span class="line"></span><br><span class="line">FROM ubuntu:latest</span><br><span class="line">COPY my_first_process my_first_process</span><br><span class="line">COPY my_second_process my_second_process</span><br><span class="line">COPY my_wrapper_script.sh my_wrapper_script.sh</span><br><span class="line">CMD ./my_wrapper_script.sh</span><br></pre></td></tr></table></figure><ul><li>使用如<code>supervisord</code>这样的进程管理器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y supervisor</span><br><span class="line">RUN mkdir -p /var/log/supervisor</span><br><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br><span class="line">COPY my_first_process my_first_process</span><br><span class="line">COPY my_second_process my_second_process</span><br><span class="line">CMD [&quot;/usr/bin/supervisord&quot;]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="容器运行指标"><a href="#容器运行指标" class="headerlink" title="容器运行指标"></a>容器运行指标</h3><p>Container runtime metrics</p><p><strong>docker stats</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker stats redis1 redis2</span><br><span class="line"></span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O</span><br><span class="line">redis1              0.07%               796 KB / 64 MB        1.21%               788 B / 648 B       3.568 MB / 512 KB</span><br><span class="line">redis2              0.07%               2.746 MB / 64 MB      4.29%               1.266 KB / 648 B    12.4 MB / 0 B</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Control groups</strong></p><p>Linux Container依赖于<code>control group</code>，这些组不仅跟踪进程组，还公开有关CPU，mem，block I/O的使用情况和度量标准。你可以访问这些指标并判断容器运行状况。<br>control group通过为文件系统(pseudo-fs)公开，你应该可在<code>/proc/fs/cgroup</code>中找到它。</p><p>查看cgroup子系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">grep cgroup /proc/mounts</span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">mount -l | grep cgroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#进程</span><br><span class="line">/proc/&lt;pid&gt;/cgroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#/表示进程尚未分配给group</span><br><span class="line">cat /proc/1/cgroup</span><br><span class="line">11:devices:/</span><br><span class="line">10:cpuset:/</span><br><span class="line">9:hugetlb:/</span><br><span class="line">8:memory:/</span><br><span class="line">7:blkio:/</span><br><span class="line">6:net_prio,net_cls:/</span><br><span class="line">5:pids:/</span><br><span class="line">4:perf_event:/</span><br><span class="line">3:cpuacct,cpu:/</span><br><span class="line">2:freezer:/</span><br><span class="line">1:name=systemd:/</span><br></pre></td></tr></table></figure><p><br></p><p><strong>查找给定容器的cgroup</strong><br>对于每个容器，每个层次结构中创建一个cgroup。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/sys/fs/cgroup/memory/docker/&lt;docker-longid&gt;/</span><br><span class="line"></span><br><span class="line">cd /sys/fs/cgroup/memory/docker/893903129d869f384bd78d63a382f1c9527d6979be0a6cf3c13ea4f45a1554d6</span><br><span class="line">cat memory.stat</span><br><span class="line"></span><br><span class="line">cache 36282368</span><br><span class="line">rss 196608</span><br><span class="line">rss_huge 0</span><br><span class="line">mapped_file 1077248</span><br><span class="line">swap 0</span><br><span class="line">pgpgin 212904</span><br><span class="line">pgpgout 205531</span><br><span class="line">pgfault 314692</span><br><span class="line">pgmajfault 204</span><br><span class="line">inactive_anon 131072</span><br><span class="line">active_anon 65536</span><br><span class="line">inactive_file 18223104</span><br><span class="line">active_file 18059264</span><br><span class="line">unevictable 0</span><br><span class="line">hierarchical_memory_limit 9223372036854771712</span><br><span class="line">hierarchical_memsw_limit 9223372036854771712</span><br><span class="line">total_cache 36282368</span><br><span class="line">total_rss 196608</span><br><span class="line">total_rss_huge 0</span><br><span class="line">total_mapped_file 1077248</span><br><span class="line">total_swap 0</span><br><span class="line">total_pgpgin 212904</span><br><span class="line">total_pgpgout 205531</span><br><span class="line">total_pgfault 314692</span><br><span class="line">total_pgmajfault 204</span><br><span class="line">total_inactive_anon 131072</span><br><span class="line">total_active_anon 65536</span><br><span class="line">total_inactive_file 18223104</span><br><span class="line">total_active_file 18059264</span><br><span class="line">total_unevictable 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#其它信息类似</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="限制容器的资源"><a href="#限制容器的资源" class="headerlink" title="限制容器的资源"></a>限制容器的资源</h3><p>Limit a container’s resources</p><p>默认情况下，容器没有资源限制，可以使用主机内核调度程序允许给定的资源。Docker提供了一些方法来控制容器可以使用的CPU、memory、block I/O。</p><p>许多这些功能需要内核的支持。使用<code>docker info</code>命令检查是否支持。如果内核禁用了某功能，则可能会有如下警告: <strong>WARNING: No swap limit support</strong></p><p><br></p><h4 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h4><p><strong>你需要了解内存耗尽(out of memory)的风险</strong><br>不要让正在运行的容器消耗太多的主机内存，这很重要。在Linux主机上，如果内核检测到没有足够的内存来执行重要的系统功能，它会抛出一个<strong>OOME(out of memory exception)</strong>，并开始killing process以释放进程。任何进程都会是killing objects，包括Docker和其它重要应用程序。</p><p>docker尝试通过调整docker daemon的OOM优先级来降低这些风险，从而使其比系统上的其它进程更小(less)可能的被killing。容器的OOM优先级不进行调整，这使得单个容器被killing的可能性要大于docker或其它进程。你不应该给docker daemon的<code>--oom-score-adj</code>或container的<code>--oom-kill-disable</code>标志来绕过这些安全措施。</p><p>你可以通过以下方式减轻由OOM引起的系统不稳定的风险:</p><ul><li>在上线之前，进行测试以了解应用程序的内存需求</li><li>确保应用程序仅在拥有足够资源的主机上运行</li><li>限制容器可使用的内存量</li><li>在主机上配置swap时请注意。swap比内存更慢，性能更低，但可以提供缓冲区以防系统内存耗尽</li><li>考虑将容器转换为服务，并使用服务级别约束和节点标签来确保应用程序仅在具有足够内存的主机上运行</li></ul><p><br></p><p><strong>限制容器对内存的</strong><br>Limit a container’s access to memory</p><p>Docker可以强制<code>hard limit</code>，允许容器使用不超过给定数量的用户/系统内存，或<code>soft limit</code>。这允许容器使用尽可能多的内存。</p><p>如下这些选项具有这样一些效果，注意内存单位<code>b, k, m, g</code>：</p><div class="table-container"><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-m/--memory=</code></td><td>容器可使用的最大内存量。如果你设置此选项，则允许的最小值为4m</td></tr><tr><td><code>--memory-swap</code></td><td>容器允许使用的swap量。只有在<code>--momery</code>设置时才有意义</td></tr><tr><td><code>--memory-swappiness</code></td><td>默认情况下，容器可使用的主机内核可交换的匿名页面的百分比<0-100></0-100></td></tr><tr><td><code>--memory-reservation</code></td><td>允许你指定一个小于<code>--memory</code>的soft limit。当docker检测到内存不足时，此会被激活</td></tr><tr><td><code>--kernel-memory</code></td><td>容器可以使用的最大kernel memory。内核内存不能够被swap out，因此内核内存不足的容器可能会阻塞主机资源，这会对主机和其它容器产生副作用</td></tr><tr><td><code>--oom-kill-disable</code></td><td>默认情况下，如果发生内存溢出(OOM)，内核会杀死容器中的进程。使用此选项改变此行为</td></tr></tbody></table></div><p><br></p><h4 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h4><p>默认情况下，每个容器对主机CPU周期的访问是无限制的。你可以设置各种约束来限制给定容器访问主机的CPU周期。</p><p><strong>CFS scheduler</strong><br>CFS是用于普通Linux进程的Linux kernel CPU调度器，一些运行时标志用于配置容器的CPU资源访问量。</p><div class="table-container"><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>--cpu=&lt;value&gt;</code></td><td>指定容器可以使用的CPU资源，如<code>--cpu=&quot;1.6&quot;</code></td></tr><tr><td><code>--cpu-period=&lt;value&gt;</code></td><td>指定CFS调度器周期，它与<code>--cpu-quota</code>一起使用。默认100ms。Docker1.13以后，使用<code>--cpus</code>替代</td></tr><tr><td><code>--cpu-quota=&lt;value&gt;</code></td><td>在容器上条件CFS配额。在Docker1.13以后，使用<code>--cpus</code>替代</td></tr><tr><td><code>--cpuset-cpus</code></td><td>限制容器可以使用的特定CPU或CORE。如果有多个CPU，请使用逗号<code>,</code>分割。如<code>0,2</code></td></tr><tr><td><code>--cpu-shares</code></td><td>将此标志设置为大于/小于1024(默认值)的值，以增加或减少容器的重量，并使其能够访问更大或更小比例的主机CPU周期。这仅在CPU周期受到限制时才会执行。</td></tr></tbody></table></div><p>如果你只有1 CPU，如下命令可保证容器每秒最多有50%的CPU——<code>docker run -it --cpus=&quot;.5&quot; xxx</code></p><p><br></p><p><strong>realtime scheduler</strong></p><p>在Docker1.13及更高版本，对于无法使用CFS的任务，你可以使用realtime scheduler。<br>在你配置docker daemon和container之前，请正确地配置主机内核。</p><p><strong>注意： CPU调度和优先级是高级内核功能。大多数用户不需要修改它。错误地设置将导致主机系统不稳定或不可用。</strong></p><ul><li><p>配置主机内核<br>通过运行<code>zcat /proc/config.gz | grep CONFIG_RT_GROUP_SCHED</code>或检查<code>/sys/fs/cgroup/cpu.rt_runtime_us</code>来验证内核是否启用了<code>CONFIG_RT_GROUP_SCHED</code>。有关配置内核实时调度器的指导，请参考相关文档。</p></li><li><p>配置docker daemon<br>运行docker daemon时使用<code>--cpu-rt-runtime</code>标志设置每个运行时间段的实时任务保留的最大微秒数。可使用systemd的docker.service进行配置。</p></li><li><p>配置独立容器<br>当使用<code>docker run</code>启动容器时，可以传递多个标志来控制容器CPU的优先级。</p></li></ul><div class="table-container"><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>--cap-add=sys_nice</code></td><td>授予容器<code>CAP_SYS_NICE</code>功能，允许容器提升进程的nice值，设置实时调度策略，设置CPU关联和其它操作</td></tr><tr><td><code>--cpu-rt-runtime=&lt;value&gt;</code></td><td>Docker实时调度器期间，容器可以以实时优先级运行的最大微秒数。需要<code>--cap-add=sys_nice</code>标志</td></tr><tr><td><code>--ulimit rtprio=&lt;value&gt;</code></td><td>容器允许的最大实时优先级，需要<code>--cap-add=sys_nice</code>标志</td></tr></tbody></table></div><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --it --cpu-rt-runtime=950000 \</span><br><span class="line">                  --ulimit rtprio=99 \</span><br><span class="line">                  --cap-add=sys_nice \</span><br><span class="line">                  debian:jessie</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><h4 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h4><p>记录的信息和日志格式取决于容器的端点命令。<br><code>docker logs</code>命令显示正在运行的容器记录的信息。<br><code>docker service logs</code>命令显示参与服务的所有容器记录的信息。在swarm模式下。</p><p>在某些情况下，<code>docker logs</code>可能不会显示有用的信息，除非你采取其它措施。</p><ul><li>如果将日志发送到文件、主机、数据库或其它日志驱动程序，则<code>docker logs</code>可能不会显示有用的信息</li><li>如果你的镜像运行non-interactive进程(如数据库)，则该应用程序可能会将output发送到日志文件而不是stdout/stderr</li></ul><p><br></p><h4 id="配置日志驱动"><a href="#配置日志驱动" class="headerlink" title="配置日志驱动"></a>配置日志驱动</h4><p>Configure logging drivers</p><p>docker提供了多种日志记录机制(logging mechanisms)来帮助你从运行的容器和服务中获取信息。这些机制被称为日志驱动(logging driver)。<br>每个docker daemon都有一个默认日志驱动，每个容器也默认使用该驱动。除非你给容器配置了其它日志驱动。<br>除了使用docker附带日志驱动，在Docker v17.05之后，你还可以使用日志驱动插件(logging driver plugin)。</p><p><br></p><p><strong>配置默认日志驱动</strong><br>默认的日志驱动是<code>json-flie</code>。<br>可在<code>daemon.json</code>文件里通过<code>log-driver</code>选项匹配置日志驱动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">#设置为syslog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;syslog&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果日志驱动存在可配置选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;labels&quot;: &quot;production_status&quot;,</span><br><span class="line">    &quot;env&quot;: &quot;os,customer&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">docker info | grep &apos;Loggin Driver&apos;</span><br><span class="line">Logging Driver: json-file</span><br></pre></td></tr></table></figure><p><br></p><p><strong>为容器配置日志驱动</strong><br>启动容器时，可使用<code>--log-driver</code>标志为其配置不同于docker daemon的日志驱动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --log-driver none alpine ash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看容器日志驱动</span><br><span class="line">docker inspect -f &apos;&#123;&#123;.HostConfig.LogConfig.Type&#125;&#125;&apos; &lt;CONTAINER&gt;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置从容器到日志驱动的log message的交付模式</strong><br>Docker为从容器到日志驱动的日志消息提供了两种交付(delivery）模式：</p><ul><li><p>直接阻塞(blocking)从容器到驱动的交付(默认)</p></li><li><p>非阻塞交付(non-blocking)，将日志消息存储在中间每个容器的环形缓冲区中供驱动使用<br>非阻塞消息交付模式可防止应用程序因日志反压而被阻塞。当STDERR或STDOUT流阻塞时，应用程序可能会以意想不到的方式失败。</p></li></ul><p><strong>注意：当缓冲区已满且新消息排入队列时，内存中最早的消息将被丢弃。丢弃消息通常首选阻止应用程序的日志写入过程。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --log-opt mode=non-blocking --log-opt max-buffer-size=4m alpine ping 127.0.0.1</span><br></pre></td></tr></table></figure><p><br></p><p><strong>日志驱动使用环境变量或label</strong><br>一些日志驱动将容器的<code>--env/-e</code>或<code>--label</code>标签的值添加到容器的日志中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --label production_status=testing -e os=ubuntu alpine sh</span><br></pre></td></tr></table></figure><p><br></p><p><strong>支持的日志驱动</strong><br>如下是受支持的日志驱动。</p><div class="table-container"><table><thead><tr><th>驱动</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>No logs are available for the container and docker logs does not return any output.</td></tr><tr><td>json-file</td><td>The logs are formatted as JSON. The default logging driver for Docker.</td></tr><tr><td>syslog</td><td>Writes logging messages to the syslog facility. The syslog daemon must be running on the host machine.</td></tr><tr><td>journald</td><td>Writes log messages to journald. The journald daemon must be running on the host machine.</td></tr><tr><td>gelf</td><td>Writes log messages to a Graylog Extended Log Format (GELF) endpoint such as Graylog or Logstash.</td></tr><tr><td>fluentd</td><td>Writes log messages to fluentd (forward input). The fluentd daemon must be running on the host machine.</td></tr><tr><td>splunk</td><td>Writes log messages to splunk using the HTTP Event Collector.</td></tr><tr><td>logentries</td><td>Writes log messages to Rapid7 Logentries.</td></tr><tr><td>云日志系统</td><td>各类云服务商提供的云日志系统</td></tr></tbody></table></div><p><code>docker logs</code>命令不适用于除<code>json-file</code>和<code>journald</code>之外的其它日志驱动。</p><p><br></p><h4 id="日志驱动插件"><a href="#日志驱动插件" class="headerlink" title="日志驱动插件"></a>日志驱动插件</h4><p>日志驱动插件允许你扩展和定制docker的日志记录功能，超越了内置的日志驱动的功能。</p><ul><li>安装日志驱动插件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker plugin install &lt;org/image&gt;</span><br><span class="line"></span><br><span class="line">docker plugin ls</span><br></pre></td></tr></table></figure><ul><li>将插件配置为docker daemon默认日志驱动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.josn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">--loggin-driver</span><br></pre></td></tr></table></figure><ul><li>将插件配置为容器日志驱动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run xxx --log-driver</span><br></pre></td></tr></table></figure><p><br></p><h4 id="定制日志驱动输出"><a href="#定制日志驱动输出" class="headerlink" title="定制日志驱动输出"></a>定制日志驱动输出</h4><p>Customize log driver output</p><p>日志选项<code>tag</code>指定如何格式化表示容器日志消息。默认情况下，系统使用容器ID的前12个字符。你可以指定<code>tag</code>选项来覆盖此行为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">log</span>-driver=fluentd \</span><br><span class="line">  --<span class="built_in">log</span>-opt fluentd-address=myhost.local:24224 \</span><br><span class="line">  --<span class="built_in">log</span>-opt tag=<span class="string">"mailer"</span></span><br></pre></td></tr></table></figure><p>在指定<code>tag</code>时，Docker支持的一些特殊模板标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;.ID&#125;&#125;</span><br><span class="line">The first 12 characters of the container ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.FullID&#125;&#125;</span><br><span class="line">The full container ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.Name&#125;&#125;</span><br><span class="line">The container name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.ImageID&#125;&#125;</span><br><span class="line">The first 12 characters of the container’s image ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.ImageFullID&#125;&#125;</span><br><span class="line">The container’s full image ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.ImageName&#125;&#125;</span><br><span class="line">The name of the image used by the container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.DaemonName&#125;&#125;</span><br><span class="line">The name of the docker program (docker)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--log-opt tag=&quot;&#123;&#123;.ImageName&#125;&#125;/&#123;&#123;.Name&#125;&#125;/&#123;&#123;.ID&#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line">Aug  7 18:33:19 HOSTNAME hello-world/foobar/5790672ab6a0[9103]: Hello from Docker.</span><br></pre></td></tr></table></figure><p><br></p><h4 id="日志驱动"><a href="#日志驱动" class="headerlink" title="日志驱动"></a>日志驱动</h4><p>介绍如下日志驱动！</p><h5 id="Logentries"><a href="#Logentries" class="headerlink" title="Logentries"></a>Logentries</h5><p>Logentries日志驱动将容器日志发送到Logentries server。</p><p><code>--log-opt</code>:</p><ul><li><code>logentries-token</code>: 指定Logentries log设置的token</li><li><code>line-only</code>: 仅发送原始有效载荷</li></ul><p>docker daemon:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dockerd --log-driver=logentries</span><br><span class="line"></span><br><span class="line">#可在docker.service中设置</span><br></pre></td></tr></table></figure><p>docker container:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --log-driver=logentries ...</span><br></pre></td></tr></table></figure><p>在使用此日志驱动之前，你需要在Logentries web界面中创建一个新的日志集，并将该日志集的令牌传递给docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --log-driver=logentries --log-opt logentries-token=abcd1234-12ab-34cd-5678-0123456789ab</span><br></pre></td></tr></table></figure><p><br></p><h5 id="json-file"><a href="#json-file" class="headerlink" title="json file"></a>json file</h5><p>默认情况下，docker捕获所有容器的STDOUT和STDERR，并使用json格式将它们写入文件。每个文件包含仅包含一个容器的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;10m&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">docker run \</span><br><span class="line">      --log-driver json-file --log-opt max-size=10m \</span><br><span class="line">      alpine echo hello world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子</span><br><span class="line">docker run -it --log-opt max-size=10m --log-opt max-file=3 alpine ash</span><br></pre></td></tr></table></figure><p>json-file支持的日志选项：</p><div class="table-container"><table><thead><tr><th>选项</th><th>描述</th><th>栗子</th></tr></thead><tbody><tr><td>max-size</td><td>The maximum size of the log before it is rolled. A positive integer plus a modifier representing the unit of measure (k, m, or g). Defaults to -1 (unlimited).</td><td>—log-opt max-size=10m</td></tr><tr><td>max-file</td><td>The maximum number of log files that can be present. If rolling the logs creates excess files, the oldest file is removed. Only effective when max-size is also set. A positive integer. Defaults to 1.</td><td>—log-opt max-file=3</td></tr><tr><td>labels</td><td>Applies when starting the Docker daemon. A comma-separated list of logging-related labels this daemon accepts. Used for advanced log tag options.</td><td>—log-opt labels=production_status,geo</td></tr><tr><td>env</td><td>Applies when starting the Docker daemon. A comma-separated list of logging-related environment variables this daemon accepts. Used for advanced log tag options.</td><td>—log-opt env=os,customer</td></tr><tr><td>env-regex</td><td>Similar to and compatible with env. A regular expression to match logging-related environment variables. Used for advanced log tag options.</td><td>—log-opt env-regex=^(os或customer).</td></tr></tbody></table></div><p><br></p><h5 id="Graylog-Extended-Format-gelf"><a href="#Graylog-Extended-Format-gelf" class="headerlink" title="Graylog Extended Format(gelf)"></a>Graylog Extended Format(gelf)</h5><p><code>gelf</code>日志驱动是一种方便的格式，可被Graylog, Logstash, Fluentd等工具所理解。许多工具使用这种格式。</p><p>在GELF中，每条日志消息都是带有一下字段的字典：</p><ul><li>version</li><li>host</li><li>timestamp</li><li>short and long version of the message</li><li>自定义的字段</li></ul><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;gelf&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;gelf-address&quot;: &quot;udp://1.2.3.4:12201&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">dockerd --log-driver gelf –-log-opt gelf-address=udp://1.2.3.4:12201</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#容器</span><br><span class="line">docker run \</span><br><span class="line">      --log-driver gelf –-log-opt gelf-address=udp://1.2.3.4:12201 \</span><br><span class="line">      alpine echo hello world</span><br></pre></td></tr></table></figure><p><br></p><p>GELF选项：</p><div class="table-container"><table><thead><tr><th>Option</th><th>Required</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td><code>gelf-address</code></td><td>required</td><td>GELF服务器地址(tcp/udp)</td><td><code>--log-opt gelf-address=udp://192.168.0.42:12201</code></td></tr><tr><td><code>gelf-compression-type</code></td><td>optional</td><td>仅限于UDP。类型有gzip(default),zlib,none</td><td><code>--log-opt gelf-compression-type=gzip</code></td></tr><tr><td><code>gelf-compression-level</code></td><td>optional</td><td><code>-1/0 - 9</code>,<code>-1/0</code>(禁用压缩)，1(BestSpeed)，9(BestCompress)</td><td><code>--log-opt gelf-compression-level=2</code></td></tr><tr><td><code>gelf-tcp-max-reconnect</code></td><td>optional</td><td>仅TCP，连接断开尝试的最大重连次数，默认3</td><td><code>--log-opt gelf-tcp-max-reconnect=3</code></td></tr><tr><td><code>gelf-tcp-reconnect-delay</code></td><td>optinal</td><td>仅TCP，重连等待的秒数，默认1s</td><td><code>--log-opt gelf-tcp-reconnect-delay=1</code></td></tr><tr><td><code>tag</code></td><td>optional</td><td>默认使用Docker容器ID的前12位</td><td><code>--log-opt tag=mailer</code></td></tr><tr><td><code>labels</code></td><td>optional</td><td>以逗号分隔的日志相关标签</td><td><code>--log-opt labels=production_status,geo</code></td></tr><tr><td><code>env</code></td><td>optional</td><td>以逗号分隔的日志相关的环境变量</td><td><code>--log-opt env=os,customer</code></td></tr><tr><td><code>evn-regex</code></td><td>optional</td><td>匹配日志相关环境变量的正则表达式</td><td><code>--log-opt env-regex=^(os l customer)</code></td></tr></tbody></table></div><p><br></p><h5 id="Syslog"><a href="#Syslog" class="headerlink" title="Syslog"></a>Syslog</h5><p>syslog日志驱动将日志路由到系统日志服务器。系统日志必须以特定方式格式化才能生效。从有效的消息中，接收者可以提取以下消息：</p><ul><li><p>priority<br>日志级别，debug, info, warning, error…</p></li><li><p>timestamp</p></li><li>hostname</li><li><p>facility<br>记录消息的子系统</p></li><li><p>process name</p></li><li>pid</li></ul><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;syslog&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;syslog-address&quot;: &quot;udp://1.2.3.4:1111&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">#syslog-address支持tcp和udp</span><br><span class="line">docker run \</span><br><span class="line">      -–log-driver syslog –-log-opt syslog-address=udp://1.2.3.4:1111 \</span><br><span class="line">      alpine echo hello world</span><br></pre></td></tr></table></figure><p><br></p><p>syslog日志驱动选项：</p><div class="table-container"><table><thead><tr><th>选项</th><th>描述</th><th>栗子</th></tr></thead><tbody><tr><td><code>syslog-address</code></td><td><code>[tcp l udp l tcp+tls]:host:port</code>, <code>unixgram://path</code>, <code>unix://path</code></td><td><code>--log-opt syslog-address=tcp+tls://192.168.1.3:514</code>, <code>--log-opt syslog-address=unix:///tmp/syslog.sock</code></td></tr><tr><td><code>syslog-facility</code></td><td>子系统</td><td><code>--log-opt syslog-facility=daemon</code></td></tr><tr><td><code>syslog-tls-ca-cert</code></td><td>CA</td><td><code>--log-opt syslog-tls-ca-cert=/etc/ca-certificates/custom/ca.pem</code></td></tr><tr><td><code>syslog-tls-cert</code></td><td>TLS certificate</td><td><code>--log-opt syslog-tls-key=/etc/ca-certificates/custom/key.pem</code></td></tr><tr><td><code>syslog-tls-skip-verify</code></td><td>跳过tls验证</td><td><code>--log-opt syslog-tls-skip-verify=true</code></td></tr><tr><td><code>tag</code></td><td>如前</td><td>如前</td></tr><tr><td><code>syslog-format</code></td><td>日志格式</td><td><code>--log-opt syslog-format=rfc5424micro</code></td></tr><tr><td><code>lables</code></td><td>如前</td><td>如前</td></tr><tr><td><code>env</code></td><td>如前</td><td>如前</td></tr><tr><td><code>env-regex</code></td><td>如前</td><td>如前</td></tr></tbody></table></div><p><br></p><h5 id="ETW"><a href="#ETW" class="headerlink" title="ETW"></a>ETW</h5><p>ETW日志驱动将容器日志转发为ETW事件。每个ETW时间都包含一条日志及其上下文信息的消息，然后客户端可以创建一个ETW监听器来监听这些事件。</p><p><br></p><h5 id="Fluentd"><a href="#Fluentd" class="headerlink" title="Fluentd"></a>Fluentd</h5><p>fluentd日志驱动将容器日志作为结构化日志数据发送到fluentd收集器。接着，用户便可以使用任意一种Fluentd output plugin将这些日志写入不同的目的地。</p><p>fluentd发送一下这些元数据：</p><div class="table-container"><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td><code>container_id</code></td><td>完整的64位容器ID</td></tr><tr><td><code>container_ame</code></td><td>启动时的容器名</td></tr><tr><td>source</td><td>stdout or stderr</td></tr><tr><td>log</td><td>容器日志</td></tr></tbody></table></div><p><code>docker logs</code>命令不可用于此日志驱动。</p><p><br></p><ul><li><p><code>fluentd-address</code><br>指定fluentd daemon地址</p></li><li><p>tag</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   &quot;log-driver&quot;: &quot;fluentd&quot;,</span><br><span class="line">   &quot;log-opts&quot;: &#123;</span><br><span class="line">     &quot;fluentd-address&quot;: &quot;fluentdhost:24224&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">docker run --log-driver=fluentd --log-opt fluentd-address=fluentdhost:24224</span><br><span class="line">docker run --log-driver=fluentd --log-opt fluentd-address=tcp://fluentdhost:24224</span><br><span class="line">docker run --log-driver=fluentd --log-opt fluentd-address=unix:///path/to/fluentd.sock</span><br></pre></td></tr></table></figure><p><br></p><h5 id="Journald"><a href="#Journald" class="headerlink" title="Journald"></a>Journald</h5><p>journald 日志驱动将容器日志发送给 systemd journal。可以通过<code>journalctl</code>命令，<code>journal</code> API，<code>docker logs</code>来检索日志条目。</p><p>journald日志驱动还提供如下元数据：</p><ul><li><code>CONTAINER_ID</code></li><li><code>CONTAINER_ID_FULL</code></li><li><code>CONTAINER_NAME</code></li><li><code>CONTAINER_TAG</code></li><li><code>CONTAINER_PARTIAL_MESSAGE</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;journald&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">docker run --log-driver=journald ...</span><br></pre></td></tr></table></figure><p><br></p><p>几个选项：</p><ul><li>tag</li><li>label</li><li>env</li><li>env-regex</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --log-driver=journald \</span><br><span class="line">    --log-opt labels=location \</span><br><span class="line">    --log-opt env=TEST \</span><br><span class="line">    --env &quot;TEST=false&quot; \</span><br><span class="line">    --label location=west \</span><br><span class="line">    your/application</span><br></pre></td></tr></table></figure><p><br></p><p>使用<code>journalctl</code>命令查看日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">journalctl CONTAINER_NAME=webserver</span><br><span class="line">journalctl -o json CONTAINER_NAME=webserver</span><br></pre></td></tr></table></figure><p>使用journal API：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> systemd.journal</span><br><span class="line"></span><br><span class="line">reader = systemd.journal.Reader()</span><br><span class="line">reader.add_match(<span class="string">'CONTAINER_NAME=web'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> reader:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'&#123;CONTAINER_ID_FULL&#125;: &#123;MESSAGE&#125;'</span>.format(**msg)</span><br></pre></td></tr></table></figure><p><br></p><h5 id="Splunk"><a href="#Splunk" class="headerlink" title="Splunk"></a>Splunk</h5><p>splunk日志驱动将容器日志发送到Splunk Enterprise和Splunk Clound的HTTP Event Collector。</p><p><br><br><br></p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p><br><br><br></p><hr><p><br><br><br></p><h1 id="CGroup"><a href="#CGroup" class="headerlink" title="CGroup"></a>CGroup</h1><p>参考:</p><ul><li><a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">wiki</a></li><li><a href="https://coolshell.cn/articles/17049.html" target="_blank" rel="noopener">DOCKER基础技术：LINUX CGROUP</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html" target="_blank" rel="noopener">CGroup 介绍、应用实例及原理描述</a></li><li><a href="https://cizixs.com/2017/08/25/linux-cgroup/" target="_blank" rel="noopener">linux cgroup 简介</a></li><li><a href="https://tech.meituan.com/2015/03/31/cgroups.html" target="_blank" rel="noopener">Linux资源管理之cgroups简介</a></li></ul><p><br><br><br></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CGroup(Linux Control Groups)，是Linux内核的一个功能，用来限制、控制与分离一个进程组群的资源(CPU, Mem, Disk I/O…)。你可以监控你配置的CGroup，拒绝CGroup访问某些资源，甚至在运行的系统中动态配置CGroup。</p><p>CGroup的一个设计目标是为不同的应用情况提供统一的结构，从控制单一进程(nice)到操作系统层虚拟化(OpenVZ, Linux-VServer, LXC)。CGroup提供:</p><ul><li><strong>资源限制(Resource limitation)</strong>：限制资源使用；</li><li><strong>优先级(Prioritization)</strong>：控制优先级；</li><li><strong>结算(Accounting)</strong>：用来衡量系统确实把多少资源用到适合的目的上；</li><li><strong>控制(Control)</strong>：冻结组或检查点和重启动。</li></ul><p><br></p><p><img src="/images/Docker/Linux_kernel_unified_hierarchy_cgroups_and_systemd.png" alt></p><p><br></p><p>使用CGroup，系统管理员可更具体地控制对系统资源的分配、优化顺序、拒绝、管理和监控。可更好地根据任务和用户分配硬件资源，提高总体效率。</p><p><br><br><br><br><br></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>CGroup需要考虑如何抽象<strong>进程</strong>和<strong>资源</strong>这两种概念，同时如何组织自己的结构。它有几个非常重要的核心概念:</p><ul><li><strong>任务(task)</strong>：系统中运行的实体，一般指进程；</li><li><strong>子系统(subsystem)</strong>：具体的资源控制器，控制某个特定的资源使用；<ul><li><strong>blkio(Block IO)</strong>：限制块设备的I/O速率；</li><li><strong>cpu</strong>：限制调度器分配的CPU使用率；</li><li><strong>cpuacct(CPU Accounting)</strong>：生成cgroup中任务使用CPU的报告；</li><li><strong>cpuset(CPU Set)</strong>：为cgroup中的进程分配单独的cpu节点或者内存节点，也就是哪些CPU和MEM上；</li><li><strong>devices</strong>：允许或者拒绝cgroup中任务对设备的访问；</li><li><strong>freezer</strong>：挂起或者恢复cgroup中的任务；</li><li><strong>hugetlb</strong>：主要针对于HugeTLB系统进行限制，这是一个大页文件系统；</li><li><strong>memory</strong>：限制cgroup中任务使用内存的量，并自动生成任务当前内存的使用情况报告；</li><li><strong>net_cls(Network Classifier)</strong>：为cgroup中的报文设置特定的classid标志，这样Linux流量控制(traffic control)程序可对其数据包进行控制；</li><li><strong>ns(namespace)</strong>：可使不同cgroups下面的进程使用不同的 namespace；</li><li><strong>net_prio(Network Priority)</strong>：对每个网络接口设置报文的优先级；</li><li><strong>perf_event</strong>：识别任务的 cgroup 成员，可以用来做性能分析；</li></ul></li><li><strong>控制组(CGroup)</strong>：一组任务和子系统的关联关系，表示对这些任务进行怎样的资源管理策略。</li><li><strong>层级(hierarchy)</strong>：一系列CGroup组成的树形结构。每个节点都是一个CGroup，CGroup可以有多个子节点，子节点默认会继承父节点的属性。</li></ul><p><br></p><p>相互关系:</p><ul><li>每次在系统中创建新层级时，该系统中的所有任务都是那个层级的默认cgroup(称为根(root))的初始成员；</li><li>一个子系统最多只能附加到一个层级；</li><li>一个层级可以附加到多个子系统；</li><li>一个任务可以是多个CGroup的成员，但是这些CGroup必须在不同的层级；</li><li>系统中的进程(任务)创建子进程(任务)时，该子任务自动成为其父进程所在CGroup的程序，也就是继承。</li></ul><p><img src="/images/Docker/CGroup_Hierrchy.png" alt></p><p><br><br><br><br><br></p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>Linux使用了多种数据结构在内核中实现了CGroup的配置，关联了进程和CGroups节点。CGroup提供了一个CGroup虚拟文件系统(VFS, Virtual File System)，作为进行分组管理和各子系统设置的用户接口。要使用CGroup，必须挂载CGroup文件系统。这时通过挂载选项指定使用哪个子系统。</p><p>VFS通用文件模型中包含的四中元数据结构:</p><ul><li><strong>超级块对象(superblock object)</strong>：用于存放已经注册的文件系统的信息。比如ext2，ext3等这些基础的磁盘文件系统，还有用于读写socket的socket文件系统，以及当前的用于读写cgroups配置信息的 cgroups 文件系统等；</li><li><strong>索引节点对象(inode object)</strong>：用于存放具体文件的信息。对于一般的磁盘文件系统而言，inode 节点中一般会存放文件在硬盘中的存储块等信息；对于socket文件系统，inode会存放socket的相关属性，而对于cgroups这样的特殊文件系统，inode会存放与 cgroup 节点相关的属性信息。这里面比较重要的一个部分是一个叫做 inode_operations 的结构体，这个结构体定义了在具体文件系统中创建文件，删除文件等的具体实现；</li><li><strong>文件对象(file object)</strong>：一个文件对象表示进程内打开的一个文件，文件对象是存放在进程的文件描述符表里面的。同样这个文件中比较重要的部分是一个叫 file_operations 的结构体，这个结构体描述了具体的文件系统的读写实现。当进程在某一个文件描述符上调用读写操作时，实际调用的是 file_operations 中定义的方法。 对于普通的磁盘文件系统，file_operations 中定义的就是普通的块设备读写操作；对于socket文件系统，file_operations 中定义的就是 socket 对应的 send/recv 等操作；而对于cgroups这样的特殊文件系统，file_operations中定义的就是操作 cgroup 结构体等具体的实现；</li><li><strong>目录项对象(dentry object)</strong>：在每个文件系统中，内核在查找某一个路径中的文件时，会为内核路径上的每一个分量都生成一个目录项对象，通过目录项对象能够找到对应的 inode 对象，目录项对象一般会被缓存，从而提高内核查找速度。</li></ul><p><br></p><p>CGroup支持的文件类型:</p><div class="table-container"><table><thead><tr><th>文件</th><th>R/W</th><th>用途</th></tr></thead><tbody><tr><td>Release_agent</td><td>RW</td><td>删除分组时执行的命令，这个文件只存在于根分组</td></tr><tr><td>Notify_on_release</td><td>RW</td><td>设置是否执行release_agent，为1时执行</td></tr><tr><td>Tasks</td><td>RW</td><td>属于分组的线程TID列表</td></tr><tr><td>Cgroup.procs</td><td>R</td><td>属于分组的进程PID列表</td></tr><tr><td>Cgroup.event_control</td><td>RW</td><td>监视状态变化和分组删除事件的配置文件</td></tr></tbody></table></div><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h1><p>参考:</p><ul><li><a href="https://cizixs.com/2017/08/29/linux-namespace/" target="_blank" rel="noopener">docker 容器基础技术：linux namespace 简介</a></li><li><a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">DOCKER基础技术：LINUX NAMESPACE</a></li></ul><p><br><br><br></p><h2 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Linux Namespace</strong>是Linux提供的一种内核级别环境(资源)隔离机制，用来让运行在同一个操作系统上的进程互相不会干扰。</p><p>Namespace的目的就是隔离。某个Namespace里面的进程就只能看到该Namespace的信息，无法看到该Namespace之外的信息，无法看到其它Namespace里面的信息。各个Namespace中的进程根本感觉不到对方的存在。</p><p>Linux内核提供的Namespace:</p><div class="table-container"><table><thead><tr><th>Namespace</th><th><code>clone()</code>使用的flag</th><th>隔离的资源</th></tr></thead><tbody><tr><td>CGroup</td><td><code>CLONE_NEWCGROUP</code></td><td>CGroup根目录</td></tr><tr><td>IPC</td><td><code>CLONE_NEWIPC</code></td><td>System V IPC，POSIX 消息队列</td></tr><tr><td>Network</td><td><code>CLONE_NEWNET</code></td><td>网络设备、协议栈、端口等</td></tr><tr><td>Mount</td><td><code>CLONE_NEWNS</code></td><td>挂载点</td></tr><tr><td>PID</td><td><code>CLONE_NEWPID</code></td><td>进程 ID</td></tr><tr><td>User</td><td><code>CLONE_NEWUSER</code></td><td>用户和组 ID</td></tr><tr><td>UTS</td><td><code>CLONE_NEWUTS</code></td><td>主机名和域名</td></tr></tbody></table></div><p><br></p><p>主要是三个子系统调用:</p><ul><li><code>clone()</code>：实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。</li><li><code>unshare()</code>：使某进程脱离某个namespace</li><li><code>setns()</code>：把某进程加入到某个namespace</li></ul><p><br></p><p>每个进程都有一个<code>/proc/${pid}/ns</code>目录，里面保存了该进程所在对应Namespace的链接。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo ls -l /proc/8734/ns</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx. 1 root root 0 4月  24 10:49 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 4月  24 10:49 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 4月  24 10:49 net -&gt; net:[4026531956]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 4月  24 10:49 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 4月  24 10:49 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 4月  24 10:49 uts -&gt; uts:[4026531838]</span><br></pre></td></tr></table></figure><p>每个文件对应于Namespace的文件描述符，方括号里的值是Namespace的inode。如果两个进程所在的Namespace一样，那么它们列出来的inode也是一样的。</p><p><strong>inode</strong>是指在许多Unix-Like系统中的一种数据结构。每个inode保存了文件系统中的一个文件系统对象（包括文件、目录、设备文件、socket、管道, 等等）的元信息数据，但不包括数据内容或者文件名。<br>inode这个命名的来源可能是文件系统的存储组织为一个扁平数组，分层目录信息使用一个数作为文件系统这个扁平数组的索引值（index）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker文档:  &lt;a href=&quot;https://docs.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/sD7O95O/article/details/78623697&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/sD7O95O/article/details/78623697&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/22969309/answer/34030581&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/22969309/answer/34030581&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7x86_64&lt;/li&gt;
&lt;li&gt;Docker v18.03&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Docker" scheme="https://zhang21.github.io/tags/Docker/"/>
    
  </entry>
  
</feed>
