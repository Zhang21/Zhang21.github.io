<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风继续吹</title>
  
  <subtitle>Yesterday, you said tomorrow!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhang21.github.io/"/>
  <updated>2018-04-15T06:59:36.611Z</updated>
  <id>https://zhang21.github.io/</id>
  
  <author>
    <name>Zhang21</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用ELK搭建日志分析系统</title>
    <link href="https://zhang21.github.io/2018/04/15/%E4%BD%BF%E7%94%A8ELK%E6%90%AD%E5%BB%BA%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://zhang21.github.io/2018/04/15/使用ELK搭建日志分析系统/</id>
    <published>2018-04-15T14:08:11.000Z</published>
    <updated>2018-04-15T06:59:36.611Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>elastci指南: <a href="https://www.elastic.co/guide/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/index.html</a></li><li>Elasticsearch文档: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></li><li>Logstash文档: <a href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/index.html</a></li><li>Kibana文档: <a href="https://www.elastic.co/guide/en/kibana/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/kibana/current/index.html</a></li></ul><p>环境：</p><ul><li>CentOS7.x86_64</li><li>Elastcisearch v6.2.3</li><li>Kibana v6.2.3</li><li>Logstash v6.2.3</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><h1 id="ELK综述"><a href="#ELK综述" class="headerlink" title="ELK综述"></a>ELK综述</h1><p>开源的 Elastic Stack:<br>能够安全可靠地获取任何来源、任何格式的数据，并且能够实时地对数据进行搜索、分析和可视化。</p><p><br></p><p><img src="/images/ELK/ELK.jpg" alt="ELK流程图"></p><p><img src="/images/ELK/elk.png" alt="ELK流程图"></p><p><br></p><p>ELK指的是<a href="https://www.elastic.co" target="_blank" rel="noopener">elastic</a>公司下的三款产品：</p><ul><li>Elasticsearch</li><li>Logstash</li><li>Kibana</li></ul><p>其它产品：</p><ul><li>Beats</li><li>X-Pack</li></ul><p><br><br><br></p><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ul><li>开放源码且自由使用</li><li>License: Apache License 2.0</li><li>GitHub: <a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch</a></li><li>Doc: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></li></ul><p><br></p><p>搜索、分析和存储您的数据。<br>Elasticsearch 是基于 JSON 的分布式搜索和分析引擎，专为实现水平扩展、高可用和管理便捷性而设计。<br>Elasticsearch 是一个分布式的 RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p><p>基于Lucene。Lucene是一套用于全文检索和搜寻的开放源码程式库，由Apache软件基金会支持和提供。<br>Lucene提供了一个简单却强大的应用程式介面，能够做全文索引和搜寻，在Java开发环境里Lucene是一个成熟的免费开放原始码工具；就其本身而论，Lucene是现在并且是这几年，最受欢迎的免费Java资讯检索程式库。</p><p><br><br><br></p><h2 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h2><ul><li>开放源码且自由使用</li><li>GitHub: <a href="https://github.com/elastic/logstash" target="_blank" rel="noopener">https://github.com/elastic/logstash</a></li><li>Doc: <a href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/index.html</a></li></ul><p><br></p><p>集中、转换和存储数据<br>Logstash 是动态数据收集管道，拥有可扩展的插件生态系统，能够与 Elasticsearch 产生强大的协同作用。<br>Logstash 是开源的服务器端数据处理管道，能够同时 从多个来源采集数据、转换数据，然后将数据发送到您最喜欢的 “存储库” 中。（我们的存储库当然是 Elasticsearch。）</p><p><br><br><br></p><h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><ul><li>开放源码且自由使用</li><li>GitHub: <a href="https://github.com/elastic/kibana" target="_blank" rel="noopener">https://github.com/elastic/kibana</a></li><li>Doc: <a href="https://www.elastic.co/guide/en/kibana/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/kibana/current/index.html</a></li></ul><p><br></p><p>实现数据可视化<br>Kibana 让您能够可视化 Elasticsearch 中的数据并操作 Elastic Stack，因此您可以在这里解开任何疑问：例如，为何会在凌晨 2:00 被传呼，雨水会对季度数据造成怎样的影响。</p><p><br><br><br></p><h2 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h2><ul><li>开放源码且自由使用</li><li>GitHub: <a href="https://github.com/elastic/beats" target="_blank" rel="noopener">https://github.com/elastic/beats</a></li><li>Doc: <a href="https://www.elastic.co/guide/en/beats/libbeat/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/libbeat/current/index.html</a></li></ul><p><br></p><p>Beats 是轻量型采集器的平台，从边缘机器向 Logstash 和 Elasticsearch 发送数据。<br>Beats 平台集合了多种单一用途数据采集器。这些采集器安装后可用作轻量型代理，从成百上千或成千上万台机器向 Logstash 或 Elasticsearch 发送数据。</p><p><br><br><br></p><h2 id="X-Pack"><a href="#X-Pack" class="headerlink" title="X-Pack"></a>X-Pack</h2><ul><li>Doc: <a href="https://www.elastic.co/guide/en/x-pack/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/x-pack/current/index.html</a></li></ul><p><br></p><p>一个程序包，带来丰富的可能性<br>单就其自身而言，Elastic Stack 就是一款值得考虑的强大工具。X-Pack 将诸多强大功能集合到一个单独的程序包中，更将它带上了一个新的层次。<br>X-Pack 是集成了多种便捷功能的单个插件 — security、alerting、monitoring、reporting、graph 探索和 machine learning — 您可以在 Elastic Stack 中放心地使用这些功能。</p><p><br><br><br></p><hr><p><br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装步骤：</p><ul><li>Elasticsearch</li><li>Kibana</li><li>Logstash</li><li>Install X-Pack into Elasticsearch</li><li>Install X-Pack into Kibana</li></ul><p><br></p><h2 id="安装ELK"><a href="#安装ELK" class="headerlink" title="安装ELK"></a>安装ELK</h2><p>需要以来JDK（java），请先安装。</p><p>我是直接使用的RPM包安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#安装Java</div><div class="line">yum install java-1.8.0-openjdk-headless-1.8.0.161-0.b14.el7_4.x86_64 -y</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#编写repo</div><div class="line">vim /etc/yum.repo.d/elk.repo</div><div class="line"></div><div class="line"></div><div class="line">[elasticsearch-6.x]</div><div class="line">name=Elasticsearch repository for 6.x packages</div><div class="line">baseurl=https://artifacts.elastic.co/packages/6.x/yum</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch</div><div class="line">enabled=1</div><div class="line">autorefresh=1</div><div class="line">type=rpm-md</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#安装</div><div class="line">yum install -y elasticsearch logstash kibana</div></pre></td></tr></table></figure><p><br></p><p>由于elk默认将软件安装到<code>/usr/share/</code>下，因此我把它们的路径加入PATH。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div><div class="line"></div><div class="line"></div><div class="line">PATH=$PATH::/usr/share/elasticsearch/bin:/usr/share/kibana/bin:/usr/share/logstash/bin:/usr/share/elasticsearch/bin/x-pack</div><div class="line"></div><div class="line"></div><div class="line">source /etc/profile</div></pre></td></tr></table></figure><p><br></p><p>ELK使用RPM安装的布局说明：</p><ul><li>主目录<ul><li><code>/usr/share/elasticsearch</code></li><li><code>/usr/share/kibana</code></li><li><code>/usr/share/logstash</code></li></ul></li><li>二进制文件<ul><li><code>/usr/share/elasticsearch/bin</code></li><li><code>/usr/share/kibana/bin</code></li><li><code>/usr/share/logstash/bin</code></li></ul></li><li>配置文件<ul><li><code>/etc/elastcisearch</code></li><li><code>/etc/kibana</code></li><li><code>/etc/logstash</code></li></ul></li><li>环境变量<ul><li><code>/etc/sysconfig/elasticsearch</code></li></ul></li><li>插件<ul><li><code>/usr/share/elastcisearch/plugins</code></li><li><code>/usr/share/kibana/plugins</code></li></ul></li></ul><p><strong>记得把ELK的bin目录加入PATH</strong></p><p><br><br><br></p><h2 id="安装X-Pack"><a href="#安装X-Pack" class="headerlink" title="安装X-Pack"></a>安装X-Pack</h2><p>安装X-Pack前，请先安装ELK。<br>请安装匹配版本的X-Pack。</p><ul><li>Install X-Pack on Elasticsearch</li><li>Install X-Pack on Kibana</li><li>Install X-Pack on Logstash</li></ul><p><br></p><p><img src="/images/ELK/InstallationFlow.jpg" alt="安装流程图"></p><p><br></p><p><strong>启用或禁用X-Pack功能</strong></p><p>所有功能默认启。<br>在一下文件中配置它们：</p><ul><li><code>elasticsearch.yml</code></li><li><code>kibana.yml</code></li><li><code>logstash.yml</code></li></ul><p>配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">xpack.graph.enabled</div><div class="line">#false</div><div class="line"></div><div class="line">xpack.ml.enabled</div><div class="line">#false</div><div class="line"></div><div class="line">xpack.monitoring.enabled</div><div class="line">#false</div><div class="line"></div><div class="line">xpack.reporting.enabled</div><div class="line">#false</div><div class="line"></div><div class="line">xpack.security</div><div class="line">#false</div><div class="line"></div><div class="line">xpack.watch.enabled</div><div class="line">#false</div></pre></td></tr></table></figure><p><br></p><p>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#Elastcisearch安装X-Pack</div><div class="line">elasticsearch-plugin install x-pack</div><div class="line"></div><div class="line"></div><div class="line">#启动</div><div class="line">#9200, 9300端口</div><div class="line">elasticsearch</div><div class="line"></div><div class="line"></div><div class="line">#生成默认用户密码，此密码针对elastic和kibana用户</div><div class="line">#/usr/share/elasticsearch/bin/x-pack</div><div class="line">#将此加入PATH</div><div class="line">setup-passwords auto</div><div class="line"></div><div class="line">#或手动输入密码</div><div class="line">setup-passwords interactive</div><div class="line">elastic</div><div class="line">#elastic</div><div class="line">kibana</div><div class="line">#kibana</div><div class="line">logstash_system</div><div class="line">#logstash</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#Kibana安装X-Pack</div><div class="line">kibana-plugin install x-pack</div><div class="line"></div><div class="line"></div><div class="line">#对kibana.yml添加用户和密码</div><div class="line">#此密码是前面默认生成的</div><div class="line">vim /etc/kibana/kibana.yml`</div><div class="line"></div><div class="line">elasticsearch.username: &quot;kibana&quot;</div><div class="line">elasticsearch.password:  &quot;kibana&quot;</div><div class="line">#修改监听地址</div><div class="line">server.host: &quot;0.0.0.0&quot;</div><div class="line"></div><div class="line">logging.dest: /var/log/kibana/kibana.log</div><div class="line">#kibana日志默认是stdout</div><div class="line">#修改为/var/log/kibana/kibana.log</div><div class="line">mkdir /var/log/kibana</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#启动kibana</div><div class="line">#5601端口</div><div class="line">#kibana可用root启动</div><div class="line">kibana</div></pre></td></tr></table></figure><p><br></p><p><strong>启动时可能遇到的问题</strong></p><ol><li><p>can not run elasticsearch as root</p><ul><li>专门建立一个管理ELK的用户，切换到此用户后运行，注意修改ELK相关目录权限</li><li>或者修改ELK各自用户的/etc/passwd，切换到对应用户后运行。注意权限 – <code>su elasticsearch &amp;&amp; elasticsearch</code></li></ul></li><li><p>elasticsearch process is too low, increase to at least [65536]</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vim /etc/security/limits.conf</div><div class="line"></div><div class="line"></div><div class="line">* soft nofile 655350</div><div class="line">* hard nofile 655350</div><div class="line"></div><div class="line"></div><div class="line">ulimit -a</div></pre></td></tr></table></figure><p><br></p><p><strong>访问elasticsearch</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ip:9200</div><div class="line">#此处访问是需要用户名和密码的</div><div class="line">#使用前面X-Pack生成的默认用户名和密码</div><div class="line"></div><div class="line">elastic elastic</div><div class="line">#登录之后便可看到node，cluster相关信息</div></pre></td></tr></table></figure><p><img src="/images/ELK/9200auth.png" alt="认证后相关信息"></p><p><br></p><p><strong>访问kibana</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#5601端口</div><div class="line">http://0.0.0.0:5601</div></pre></td></tr></table></figure><p><img src="/images/ELK/5601kibana.png" alt=""></p><p><br><br><br></p><hr><p><br></p><h1 id="与Nginx结合使用"><a href="#与Nginx结合使用" class="headerlink" title="与Nginx结合使用"></a>与Nginx结合使用</h1><p>将Kibana展现到Nginx上的话，便可以不对Kibana开发外网访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#安装Nginx</div><div class="line"></div><div class="line">vim /etc/yum.repo.d/nginx.repo</div><div class="line"></div><div class="line"></div><div class="line">[nginx]</div><div class="line">name=nginx repo</div><div class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</div><div class="line">gpgcheck=0</div><div class="line">enabled=1</div><div class="line"></div><div class="line"></div><div class="line">yum install -y nginx  nginx-mod-stream</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#配置</div><div class="line">vim /etc/nginx/conf.d/kibana.conf</div><div class="line"></div><div class="line"></div><div class="line">#可把IP换成kibana相应的域名</div><div class="line">#再将域名解析到此IP</div><div class="line">server &#123;</div><div class="line"></div><div class="line">    listen 80;</div><div class="line">    server_name 172.16.129.150;</div><div class="line"></div><div class="line">#Kibana</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://127.0.0.1:5601;</div><div class="line">        proxy_set_header Upgrade $http_upgrade;</div><div class="line">        proxy_set_header Connection &apos;upgrade&apos;;</div><div class="line">        proxy_set_header Host $host;</div><div class="line">        proxy_cache_bypass $http_upgrade;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><br></p><p><strong>可能会遇到的问题</strong></p><ul><li>Nignx错误日志: Permission denied) while connecting to upstream</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">sudo cat /var/log/audit/audit.log | grep nginx | grep denied</div><div class="line"></div><div class="line">#后来判断是SELinux的问题</div><div class="line">getenforce</div><div class="line">setenforce 0</div><div class="line"></div><div class="line"></div><div class="line">#修改SELinux</div><div class="line">vim /etc/selinux/config</div><div class="line"></div><div class="line">SELINUX=disabled</div></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="使用Logstash处理日志"><a href="#使用Logstash处理日志" class="headerlink" title="使用Logstash处理日志"></a>使用Logstash处理日志</h1><p><img src="/images/ELK/basic_logstash_pipeline.png" alt="logstash流程图"></p><p><br></p><p>Logstash的pipeline有两个必须的元素：</p><ul><li>input<ul><li>消耗来自source的数据</li></ul></li><li>output<ul><li>将修改后的数据写入destination</li></ul></li></ul><p>以及一个可选元素：</p><ul><li>filter<ul><li>根据你的定义来修改数据</li></ul></li></ul><p><br><br><br></p><h2 id="Stash-First-Event"><a href="#Stash-First-Event" class="headerlink" title="Stash First Event"></a>Stash First Event</h2><p><strong>测试Logstash和运行一个基本的pipeline</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">logstash -e &apos;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&apos;</div><div class="line"></div><div class="line">#等待启动，输入hello world</div><div class="line">#Logstash将时间戳和主机名添加到message</div><div class="line">#2018-04-13T08:17:51.702Z zhang22 helloworld</div></pre></td></tr></table></figure><p><br></p><p>启动logstsh时的一个问题： <code>WARNING: Could not find logstash.yml which is typically located in $LS_HOME/config or /etc/logstash</code></p><p>虽然通过RPM安装Logstash存在<code>/etc/logstash</code>文件，但是还是会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /usr/share/logstash/bin</div><div class="line"></div><div class="line">ln -s /etc/logstash ./config</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="通过Logstash解析Logs"><a href="#通过Logstash解析Logs" class="headerlink" title="通过Logstash解析Logs"></a>通过Logstash解析Logs</h2><p>前面我们创建了一个基本的Logstash pipeline来测试Logstash，但真正处理logs的Logstash pipeline不会这么简单，它可能会有多个input, filter, output。</p><p>本节利用一个Filebeat，将Nginx Web Logs作为Logstash pipeline的input，解析这些logs中创建的特定命名字段，并将解析的数据写入Elasticsearch集群。</p><p><br></p><p><strong>添加一个Logstash配置文件，将Nginx的访问日志作为input，解析后输出到Elasticsearch中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#pipe配置</div><div class="line">/etc/logstash/pipe.yml</div><div class="line"></div><div class="line">cd /etc/logstash/conf.d</div><div class="line"></div><div class="line">vim pipe_nginx.conf</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;elastci指南: &lt;a href=&quot;https://www.elastic.co/guide/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.elastic.co/guide/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Elasticsearch文档: &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Logstash文档: &lt;a href=&quot;https://www.elastic.co/guide/en/logstash/current/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.elastic.co/guide/en/logstash/current/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kibana文档: &lt;a href=&quot;https://www.elastic.co/guide/en/kibana/current/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.elastic.co/guide/en/kibana/current/index.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7.x86_64&lt;/li&gt;
&lt;li&gt;Elastcisearch v6.2.3&lt;/li&gt;
&lt;li&gt;Kibana v6.2.3&lt;/li&gt;
&lt;li&gt;Logstash v6.2.3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="elasticsearch" scheme="https://zhang21.github.io/tags/elasticsearch/"/>
    
      <category term="logstash" scheme="https://zhang21.github.io/tags/logstash/"/>
    
      <category term="kibana" scheme="https://zhang21.github.io/tags/kibana/"/>
    
  </entry>
  
  <entry>
    <title>Beanstalkd</title>
    <link href="https://zhang21.github.io/2018/04/10/Beanstalkd/"/>
    <id>https://zhang21.github.io/2018/04/10/Beanstalkd/</id>
    <published>2018-04-10T08:08:11.000Z</published>
    <updated>2018-04-15T07:20:21.907Z</updated>
    
    <content type="html"><![CDATA[<p>环境：</p><ul><li>CentOS7.x86_64</li><li>Beanstalkd v1.10</li></ul><p><br><br><br></p><a id="more"></a><p><br></p><h1 id="Beanstalkd介绍"><a href="#Beanstalkd介绍" class="headerlink" title="Beanstalkd介绍"></a>Beanstalkd介绍</h1><p>Beanstalk，一个高性能、轻量级的分布式内存队列系统。<br>高性能离不开异步，异步离不开队列，而其内部都是Producer-Comsumer模式的原理。</p><p><br><br><br></p><h2 id="Beanstalkd核心概念："><a href="#Beanstalkd核心概念：" class="headerlink" title="Beanstalkd核心概念："></a>Beanstalkd核心概念：</h2><ul><li><p>job(任务)<br>一个需要异步处理的任务，是beanstalkd中的基本单元，需要放在一个tube中。</p></li><li><p>tube(管道)<br>一个有名的任务队列，用来存储同一类型的job。是producer和consumer操作的对象。</p></li><li><p>producer(生产者)<br>job的生产者，通过<code>put</code>命令将一个job放到一个tube中。</p></li><li><p>consumer(消费者)<br>job的消费者，通过<code>reserve</code>/<code>release</code>/<code>bury</code>/<code>delete</code>命令来获取或改变job的状态。</p></li></ul><p><br></p><p>beanstalkd官方状态图：</p><p><img src="/images/beanstalkd.png" alt=""></p><p><br><br><br></p><h2 id="Beanstalkd特性"><a href="#Beanstalkd特性" class="headerlink" title="Beanstalkd特性"></a>Beanstalkd特性</h2><ul><li><p>优先级<br>支持0-2^32的优先级。值越小，优先级越高，默认是1024。</p></li><li><p>持久化<br>可通过<strong>binlog</strong>将job及其状态记录到文件里面。在Beanstalkd下次启动时，可通过读取binlog来恢复之前的job及状态。</p></li><li><p>分布式容错<br>分布式设计和Memcached类似，beanstalkd个server之间并不知道彼此的存在，都是通过client来实现分布式以及根据tube名称到特定server获取job。</p></li><li><p>超时控制<br>为了防止某个consumer长时间占用任务但不能处理的情况，beanstalkd为<code>reserve</code>操作设置了timeout。如果该consumer不能在指定时间内完成job，job将被迁移会READY状态，供其它consumer执行。</p></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="安装Beanstalkd"><a href="#安装Beanstalkd" class="headerlink" title="安装Beanstalkd"></a>安装Beanstalkd</h1><p>由于epel源可直接安装beanstalkd，So:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">yum install -y beanstalkd</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#配置文件</span></div><div class="line">/etc/sysconfig/beanstalkd</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#启动</span></div><div class="line">systemctl start beanstalkd</div><div class="line"></div><div class="line"><span class="comment">#等同于</span></div><div class="line"><span class="comment">#/usr/bin/beanstalkd -l 0.0.0.0 -p 11300 -u beanstalkd</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Beanstalk的客户端和管理端"><a href="#Beanstalk的客户端和管理端" class="headerlink" title="Beanstalk的客户端和管理端"></a>Beanstalk的客户端和管理端</h2><p>官方没有推出客户端和管理端，GitHub上有一些第三方插件，请自己选择使用。</p><p><br></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li>pheanstalkd:  <a href="https://github.com/pda/pheanstalk/" target="_blank" rel="noopener">https://github.com/pda/pheanstalk/</a></li></ul><p>pheanstalk是一个在PHP中操作beanstalkd的客户端。<br>具体使用方法参考README。</p><p><br></p><h3 id="管理端"><a href="#管理端" class="headerlink" title="管理端"></a>管理端</h3><ul><li><p>beanstalk_console： <a href="https://github.com/ptrofimov/beanstalk_console" target="_blank" rel="noopener">https://github.com/ptrofimov/beanstalk_console</a></p></li><li><p>aurora: <a href="https://github.com/xuri/aurora" target="_blank" rel="noopener">https://github.com/xuri/aurora</a><br>aurora 是一个基于 Web 的 Beanstalk 消息队列服务器管理工具，单文件无需依赖其他组件，支持管理本地和远程多个队列服务器。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7.x86_64&lt;/li&gt;
&lt;li&gt;Beanstalkd v1.10&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Beanstalkd" scheme="https://zhang21.github.io/tags/Beanstalkd/"/>
    
  </entry>
  
  <entry>
    <title>Supervisor</title>
    <link href="https://zhang21.github.io/2018/04/08/Supervisor/"/>
    <id>https://zhang21.github.io/2018/04/08/Supervisor/</id>
    <published>2018-04-08T02:38:33.000Z</published>
    <updated>2018-04-10T01:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="http://www.supervisord.org" target="_blank" rel="noopener">http://www.supervisord.org</a></li></ul><p>环境：</p><ul><li>Supervisor 3.3.4</li><li>CentOS7.x86_64</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><br></p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Supervisor是一个C/S系统，允许用户在Unix-Like操作系统上控制许多进程。它受如下启发：</p><ul><li>Convenience</li><li>Accuracy</li><li>Delegation</li><li>Process Group</li></ul><p><br><br><br></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>Simple</li><li>Centralized(统一)</li><li>Efficient</li><li>Extensible</li><li>Compatible</li><li>Proven(久经考验)</li></ul><p><br><br><br></p><h2 id="Supervisor组件"><a href="#Supervisor组件" class="headerlink" title="Supervisor组件"></a>Supervisor组件</h2><ul><li>supervisord<ul><li>Supervisor的服务器部分被命名为<code>supervisord</code>。负责启动子进程，响应客户端的子进程，重启奔溃或退出的子进程，记录其<code>stderr</code>和<code>stdout</code>，以及生成对应的事件</li><li>默认使用的配置文件为<code>/etc/supervisord.conf</code>——Windows-INI格式的文件，由于它包含了未加密的username和password，请保证它安全</li></ul></li><li>supervisorctl<ul><li>Supervisor的客户端部分被命名为<code>supervisorctl</code>。用户可连接到不同的supervisord，status/stop/start子进程，获取supervisord中正在运行的进程列表</li><li>通过Unix domain socket或TCP socket与server通信，客户端在执行命令前应该先提供认证。客户端和服务端使用同一个配置文件</li></ul></li><li>Web server<ul><li>Web界面，可通过它查看或控制进程状态</li></ul></li><li>XML-RPC接口<ul><li>用于询问和控制管理程序及其运行的程序</li></ul></li></ul><p><br><br><br></p><h2 id="平台要求"><a href="#平台要求" class="headerlink" title="平台要求"></a>平台要求</h2><ul><li>在Unix-Like系统上运行良好</li><li>不支持Windows系统</li><li>Supervisor运行在Python2.4或之后的版本，不支持Python3</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装方法取决于你的操作系统。</p><p><br></p><h2 id="通过网络安装"><a href="#通过网络安装" class="headerlink" title="通过网络安装"></a>通过网络安装</h2><ul><li>推荐使用setuptools的<code>easy_install</code></li><li>下载Supervisor包并调用一个命令</li></ul><p><br></p><h3 id="使用Setuptools的网络安装"><a href="#使用Setuptools的网络安装" class="headerlink" title="使用Setuptools的网络安装"></a>使用Setuptools的网络安装</h3><p>如果Python解释器安装了Setuptools:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">easy_install supervisor</div></pre></td></tr></table></figure><p><br></p><h2 id="不使用Setuptools的网络安装"><a href="#不使用Setuptools的网络安装" class="headerlink" title="不使用Setuptools的网络安装"></a>不使用Setuptools的网络安装</h2><p>如果系统上未安装Setuptools，那么你需要手动去下载Supervisor发行套件和安装它。</p><p>PYPI： <a href="https://pypi.python.org/pypi/supervisor" target="_blank" rel="noopener">https://pypi.python.org/pypi/supervisor</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wget https://pypi.python.org/pypi/supervisor/xxx.tar.gz</div><div class="line"></div><div class="line">tar -xzf xxx.tar.gz</div><div class="line"></div><div class="line">python setup.py install</div><div class="line">#它会自动通过网络下载依赖</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="安装一个分发包"><a href="#安装一个分发包" class="headerlink" title="安装一个分发包"></a>安装一个分发包</h2><p>一些Linux发行版提供了可通过系统包管理工具安装Supervisor。这些包由第三方制作，包含了对特定发行版的一些修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">yum info supervisor</div><div class="line">yum search supervisor</div><div class="line"></div><div class="line">yum install -y supervisor</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="通过pip安装"><a href="#通过pip安装" class="headerlink" title="通过pip安装"></a>通过pip安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install supervisor</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="创建一个配置文件"><a href="#创建一个配置文件" class="headerlink" title="创建一个配置文件"></a>创建一个配置文件</h2><p>由于我是通过<code>yum</code>安装，所以<code>supervisor</code>配置文件自动在<code>/etc</code>下自动生成：</p><ul><li>默认配置文件： <code>/etc/supervisord.conf</code></li><li>目录： <code>/etc/supervisord.d</code></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="运行Supervisor"><a href="#运行Supervisor" class="headerlink" title="运行Supervisor"></a>运行Supervisor</h1><p><br></p><h2 id="添加一个程序"><a href="#添加一个程序" class="headerlink" title="添加一个程序"></a>添加一个程序</h2><p>在<code>supervisord</code>为你做任何有用的事情之前，你至少需要在配置文件中添加一个程序部分。<strong>program</strong>部分将定义在调用supervisord命令时如何运行和管理一个程序。</p><p>一个最简单的栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[program:foo]</div><div class="line">command=/bin/cat</div></pre></td></tr></table></figure><p>上面的栗子只命名了一个命令，还有很多其它关于程序部分的设置。</p><p><br><br><br></p><h2 id="运行supervisord"><a href="#运行supervisord" class="headerlink" title="运行supervisord"></a>运行supervisord</h2><p>使用<code>supervisord</code>命令启动supervisord，进程将自我守护，并从终端分离。并将操作日志默认放于<code>$CWD/supervisor.log</code>。<br>你可传递<code>-n/--nodaemon</code>标志来将进程放置于前台，这样对于debug很有帮助。</p><p>要更改supervisord控制的程序集，请编辑配置文件并<code>kill- HUP</code>，或以其它方式重新启动supervisord进程。</p><p><code>supervisord</code>命令接受许多命令行选项。这些命令行选项中的每一个都会覆盖配置文件中的任何等效值。</p><p>详细选项： <a href="http://www.supervisord.org/running.html#supervisord-command-line-options" target="_blank" rel="noopener">http://www.supervisord.org/running.html#supervisord-command-line-options</a></p><p><br><br><br></p><h2 id="运行supervisorctl"><a href="#运行supervisorctl" class="headerlink" title="运行supervisorctl"></a>运行supervisorctl</h2><p>使用<code>supervisorclt</code>命令启动supervisorctl客户端。如果需要验证supervisord调用，则系统会要求您提供验证凭据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">supervisorctl status all</div><div class="line"></div><div class="line">supervisorctl stop all</div></pre></td></tr></table></figure><p><br></p><h3 id="supervisorctl-Actions"><a href="#supervisorctl-Actions" class="headerlink" title="supervisorctl Actions"></a>supervisorctl Actions</h3><p>如果在命令行中指定了<code>-i</code>或未指定任何操作(action)，则将启动交互式输入的shell解释操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">supervisorctl help</div><div class="line">#查看可操作的action</div><div class="line"></div><div class="line"></div><div class="line">default commands (type help &lt;topic&gt;):</div><div class="line">=====================================</div><div class="line">add    clear  fg        open  quit    remove  restart   start   stop  update</div><div class="line">avail  exit   maintail  pid   reload  reread  shutdown  status  tail  version</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h2><p>supervisord程序可能会发送某些actions，让它在运行时执行某些操作。你可将这些信号发送到一个单一的supervisord的PID。</p><p><br></p><h3 id="信号处理程序"><a href="#信号处理程序" class="headerlink" title="信号处理程序"></a>信号处理程序</h3><ul><li><code>SIGTERM</code><ul><li>supervisord及其所有子进程都将关闭</li></ul></li><li><code>SIGINT</code><ul><li>supervisord及其所有子进程都将关闭</li></ul></li><li><code>SIGQUIT</code><ul><li>supervisord及其所有子进程都将关闭</li></ul></li><li><code>SIGHUP</code><ul><li>supervisord将关闭所有进程，重新载入配置文件并启动所有进程</li></ul></li><li><code>SIGUSR2</code><ul><li>supervisord将关闭并重新打开主要活动日志和所有子日志文件</li></ul></li></ul><p><br><br><br></p><h2 id="运行安全"><a href="#运行安全" class="headerlink" title="运行安全"></a>运行安全</h2><p>开发人员尽力确保以root身份运行的supervisord进程不会导致意外的权限升级。但supervisord允许在其配置文件中的任意路径规范写入数据，允许任意路径选择可能会造成符号链接工具的漏洞。<br>确保supervisord配置文件的权限安全，除此之外，确保Python PATH和标准库都有足够的文件权限保护。</p><p><br><br><br></p><h2 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h2><p>由于我是<code>yum</code>安装，所以能够直接使用系统服务管理来设置开机自启。</p><p><br><br><br></p><hr><p><br></p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>Supervisor的配置文件通常命名为<code>supervisord.conf</code>。如果没有指定<code>-c</code>配置文件，应用程序会从以下位置去寻找配置文件：</p><ul><li>$CWD/supervisord.conf</li><li>$CWD/etc/supervisord.conf</li><li>/etc/supervisord.conf</li><li>/etc/supervisor/supervisord.conf (since Supervisor 3.3.0)</li><li>../etc/supervisord.conf (Relative to the executable)</li><li>../supervisord.conf (Relative to the executable)</li></ul><p><br><br><br></p><h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p><code>supervisord.conf</code> is a Windows-INI-style (Python ConfigParser) file.<br>它包含section（[header]）和section中的key/value对。</p><p><br></p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>使用Python字符串表达式语法<code>%(ENV_X)%</code>，可以在配置文件中使用环境中存在的环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[program:example]</div><div class="line">command=/usr/bin/example --loglevel=%(ENV_LOGLEVEL)s</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="unix-http-server"><a href="#unix-http-server" class="headerlink" title="[unix_http_server]"></a>[unix_http_server]</h2><p>在此section中应该插入在Unix domain socket上监听的HTTP server的配置参数。<br>如果没有配置此section，则Unix domain socket HTTP server将不会启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[unix_http_server]</div><div class="line"></div><div class="line"></div><div class="line">#supervisor监听HTTP/XML-RPC请求的Unix domain socket的路径</div><div class="line">file</div><div class="line"></div><div class="line"></div><div class="line">#socket文件的权限模式</div><div class="line">chmod</div><div class="line"></div><div class="line"></div><div class="line">#socket的用户和组</div><div class="line">chown</div><div class="line"></div><div class="line"></div><div class="line">#访问HTTP server需要的认证</div><div class="line">username</div><div class="line"></div><div class="line"></div><div class="line">#密码可以是明文，或使用SHA加密的字符串</div><div class="line">password</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="inet-http-server"><a href="#inet-http-server" class="headerlink" title="[inet_http_server]"></a>[inet_http_server]</h2><p>监听TCP(internet) socket 的HTTP server的配置参数。<br>如果此section未配置，inet HTTP server将不会启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#tcp host:port，supervisor监听HTTP/XML-RPC请求的地址</div><div class="line">port</div><div class="line"></div><div class="line"></div><div class="line">#HTTP server认证</div><div class="line">username</div><div class="line"></div><div class="line"></div><div class="line">#密码可以是明文，或SHA加密</div><div class="line">passwd</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="supervisord"><a href="#supervisord" class="headerlink" title="[supervisord]"></a>[supervisord]</h2><p>与supervisord进程有关的全局设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">logfile</div><div class="line"></div><div class="line">logfile_maxbytes</div><div class="line"></div><div class="line">logfile_backps</div><div class="line"></div><div class="line">#critical, error, warn, info, debug, trace</div><div class="line">logevel</div><div class="line"></div><div class="line">pidfile</div><div class="line"></div><div class="line">umask</div><div class="line"></div><div class="line">nodaemon</div><div class="line"></div><div class="line">minfds</div><div class="line"></div><div class="line">minprocs</div><div class="line"></div><div class="line">#防止supervisord在启动时清除任何现有子日志文件</div><div class="line">nocleanup</div><div class="line"></div><div class="line">childlogdir</div><div class="line"></div><div class="line">user</div><div class="line"></div><div class="line">directory</div><div class="line"></div><div class="line">strip_ansi</div><div class="line"></div><div class="line">enviroment</div><div class="line"></div><div class="line">identifier</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="supervisorctl"><a href="#supervisorctl" class="headerlink" title="[supervisorctl]"></a>[supervisorctl]</h2><p><code>supervisorctl</code>交互式shell程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">serverurl</div><div class="line"></div><div class="line">#与前面设置的验证账户一致</div><div class="line">username</div><div class="line">password</div><div class="line"></div><div class="line">prompt</div><div class="line"></div><div class="line">history_file</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="program-x"><a href="#program-x" class="headerlink" title="[program:x]"></a>[program:x]</h2><p>supervisord知道的应该启动和控制的程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">command</div><div class="line"></div><div class="line">process_name</div><div class="line"></div><div class="line">numproc</div><div class="line"></div><div class="line">numprocs_start</div><div class="line"></div><div class="line">priority</div><div class="line"></div><div class="line">autostart</div><div class="line"></div><div class="line">startsecs</div><div class="line"></div><div class="line">startretries</div><div class="line"></div><div class="line">autorestart</div><div class="line"></div><div class="line">exitcodes</div><div class="line"></div><div class="line">stopsignal</div><div class="line"></div><div class="line">stopwaitsecs</div><div class="line"></div><div class="line">stopagroup</div><div class="line"></div><div class="line">killasgroup</div><div class="line"></div><div class="line">user</div><div class="line"></div><div class="line">redirect_stderr</div><div class="line"></div><div class="line">stdout_logfile</div><div class="line">stdout_logfile_maxbytes</div><div class="line">stdout_logfile_backups</div><div class="line">stdout_capture_maxbytes</div><div class="line">stdout_events_enabled</div><div class="line"></div><div class="line">stderr_logfile</div><div class="line">stderr_logfile_maxbytes</div><div class="line">stderr_logfile_backups</div><div class="line">stderr_capture_maxbytes</div><div class="line">stderr_events_enabled</div><div class="line"></div><div class="line">environment</div><div class="line"></div><div class="line">directory</div><div class="line"></div><div class="line">umask</div><div class="line"></div><div class="line">serverurl</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="include"><a href="#include" class="headerlink" title="[include]"></a>[include]</h2><p>如果配置文件包含<code>[include]</code>部分，则它必须包含一个名为<code>files</code>的key。该key中的值包含了其它配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#文件空间的空格分隔序列，路径可以是相对或绝对。</div><div class="line">files</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="group-x"><a href="#group-x" class="headerlink" title="[group:x]"></a>[group:x]</h2><p>将同质进程组组合成一个异质进程组通常很有用，所以它们可以作为supervisor各种控制器接口的一个单元进行控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#程序的逗号分隔列表</div><div class="line">programs</div><div class="line"></div><div class="line">#优先级</div><div class="line">priority</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="fcgi-program-x"><a href="#fcgi-program-x" class="headerlink" title="[fcgi-program:x]"></a>[fcgi-program:x]</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#程序的fastCGI socket或TCP或Unix domain socket</div><div class="line">socket</div><div class="line"></div><div class="line"></div><div class="line">#为socket指定特定user或group</div><div class="line">socket_owner</div><div class="line"></div><div class="line"></div><div class="line">#指定permission模式</div><div class="line">socket_mode</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="eventlistener-x"><a href="#eventlistener-x" class="headerlink" title="[eventlistener:x]"></a>[eventlistener:x]</h2><p>supervisor允许在配置文件中定义专门的同质进程组(event listener pools)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">buffer_size</div><div class="line"></div><div class="line">events</div><div class="line"></div><div class="line">result_handler</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="rpcinterface-x"><a href="#rpcinterface-x" class="headerlink" title="[rpcinterface:x]"></a>[rpcinterface:x]</h2><p><code>[rpcinterface:x]</code>适用于希望通过自定义行为扩展supervisor的人们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.supervisord.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.supervisord.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Supervisor 3.3.4&lt;/li&gt;
&lt;li&gt;CentOS7.x86_64&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Supervisor" scheme="https://zhang21.github.io/tags/Supervisor/"/>
    
  </entry>
  
  <entry>
    <title>Consul</title>
    <link href="https://zhang21.github.io/2018/04/05/Consul/"/>
    <id>https://zhang21.github.io/2018/04/05/Consul/</id>
    <published>2018-04-05T14:08:11.000Z</published>
    <updated>2018-04-11T07:19:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://www.consul.io/intro/index.html" target="_blank" rel="noopener">https://www.consul.io/intro/index.html</a></li><li><a href="https://www.consul.io/docs/" target="_blank" rel="noopener">https://www.consul.io/docs/</a></li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><h1 id="Consule简介"><a href="#Consule简介" class="headerlink" title="Consule简介"></a>Consule简介</h1><p>将介绍consul是什么，它可以解决哪些问题，以及如何开始使用它。</p><p><br></p><h2 id="Consul是什么"><a href="#Consul是什么" class="headerlink" title="Consul是什么"></a>Consul是什么</h2><p>Consule有多个组件，但总体而言，它是发现(discovery)和配置(config)基础架构(infrastructure)服务的工具。它提供几个关键特点：</p><ul><li>服务发现(service discovery)<ul><li>Consul客户端可提供一个服务，如API或mysql，其它客户端能够使用Consul来发现给定服务的提供者。使用DNS或HTTP，应用程序可以轻松找到他们所依赖的服务</li></ul></li><li>健康检查(health checking)<ul><li>Consul可以提供任何数量的健康检查，既可以与给定服务相关联(webserver return 200)，也可与本地节点(内存使用率小于90%)相关联。操作人员可用此信息来监视集群运行状况，服务发现组件使用此信息将流量(traffic)从不健康的主机中引导出去</li></ul></li><li>KV store<ul><li>应用程序可将Consul的分层Key/Value用于存储任何目的，包括动态配置(dynamic configuration)、功能标记(feature flagging)、协调(coordination)、领导选举(leader election)…简单的HTTP API使其易于使用</li></ul></li><li>多数据中心(Multi Datacenter)<ul><li>Consul支持多数据中心，这意味着Consul的用户不必担心构建额外的抽象层以扩展到多个区域</li></ul></li></ul><p>Consul旨在与DevOps和应用程序开发者保持友好，使其成为现代化 ，弹性基础架构的完美选择。</p><p><br><br><br></p><h2 id="Consul基础架构"><a href="#Consul基础架构" class="headerlink" title="Consul基础架构"></a>Consul基础架构</h2><p>Consul是一个分布式、高可用的系统。</p><p>每一个向Consul提供服务的节点都运行一个Consul agent。运行agent对于服务发现或get/set Key/Value不是必需的。agent负责健康检查节点上的服务和节点自身。</p><p>agent可与一个或多个Consul server交流。Consul server是数据存储和复制集所在之地。server之间选出一个leader。虽然Consul可以使用一台服务器，但推荐使用3-5台以避免数据丢失的故障情况。对每一个数据中心都推荐使用Consul server cluster。</p><p>需要发现其它服务或节点的基础架构组件 可以查询任何Consul server或Consul agent。agent自动将查询发送到server。</p><p>每个数据中心运行一组consul server cluster。当发生cross-datacenter服务发现或配置请求时，本地consul server将请求转发给远程数据中心并返回结果。</p><p><br><br><br></p><hr><p><br></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="安装Consul"><a href="#安装Consul" class="headerlink" title="安装Consul"></a>安装Consul</h2><ul><li>二进制包: <a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">https://www.consul.io/downloads.html</a><ul><li>解压缩，得到一个consul二进制可执行文件，可将其放入系统路径</li></ul></li><li>验证安装: <code>consul</code></li></ul><p><br><br><br></p><h2 id="运行consul-agent"><a href="#运行consul-agent" class="headerlink" title="运行consul-agent"></a>运行consul-agent</h2><p>安装consul后请务必运行agent，agent可运行在server或client模式。每个datacenter必须至少有一台server，推荐3-5台做一个集群。单一server部署非常不安全，在故障情况下数据丢失就不可避免了。</p><p>所有其它agents都以client模式运行。client是一个非常轻量化的进程——它注册服务、运行健康检查、转发查询给server。agent必须运行在集群的每个节点上。</p><p><br></p><h3 id="启动agent"><a href="#启动agent" class="headerlink" title="启动agent"></a>启动agent</h3><p>测试consul development模式，不建议在生产环境使用此方法，此处做测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">consul agent -dev</div><div class="line"></div><div class="line">netstat -nltp</div><div class="line"></div><div class="line">#可根据日志看出agent已成为server，并成为集群leader</div></pre></td></tr></table></figure><p><br></p><h3 id="Consul成员"><a href="#Consul成员" class="headerlink" title="Consul成员"></a>Consul成员</h3><p><code>members</code>命令基于<code>gossip protocol</code>并最终保持一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">consul members</div><div class="line"></div><div class="line">#节点名称、监听地址、健康状态、集群角色、版本信息</div><div class="line">Node     Address         Status  Type    Build  Protocol  DC   Segment</div><div class="line">zhang22  127.0.0.1:8301  alive   server  1.0.6  2         dc1  &lt;all&gt;</div><div class="line"></div><div class="line"></div><div class="line">#使用HTTP API将请求转发给server以获取一致的view of world</div><div class="line">culr localhost:8500/v1/catalog/nodes</div><div class="line"></div><div class="line"></div><div class="line">#DNS interface也可以查询节点，默认端口8600</div><div class="line">dig @127.0.0.1 -p 8600 zhang22.node.consul</div></pre></td></tr></table></figure><p><br></p><h3 id="停止agent"><a href="#停止agent" class="headerlink" title="停止agent"></a>停止agent</h3><p>可使用<code>Ctrl + C</code>优雅地终止agent，你可以看到它离开集群并关闭。</p><p>优雅关闭，Consul会通知集群其它节点此节点的离开。如果你强制kill agent，则集群的其它节点将检测该节点失败。<br>当成员离开时，其服务和健康检查将从catalog中移除。当成员失败时，其健康状态被标记为critical，但不会从catalog中移除。<br>Consul会自动尝试重连失败的节点，允许它从当前网络条件中修复，知道离开的节点不在联系。</p><p>此外，如果agent正作为server在运行，那么优雅地离开对避免造成严重的影响有帮助。</p><p><br><br><br></p><h2 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h2><p>注册(register)服务并查询(query)服务。</p><p><br></p><h3 id="定义一个服务"><a href="#定义一个服务" class="headerlink" title="定义一个服务"></a>定义一个服务</h3><p>服务可以通过以下两种方法注册：</p><ul><li>服务定义(service definition)</li><li>调用HTTP API</li></ul><p>服务定义是注册服务最常见的方式，我们将构建前面agent的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#创建一个consul配置目录</div><div class="line">mkdir /etc/consul.d</div><div class="line"></div><div class="line"></div><div class="line">#编写服务定义配置文件</div><div class="line">#假设有一个web服务运行在80端口，添加一个便于query的tag</div><div class="line">echo &apos;&#123;&quot;service&quot;: &#123;&quot;name: &quot;web&quot;, &quot;tag&quot;: [&quot;rails&quot;], &quot;port&quot;: 80 &#125;&#125;&apos; | tee /etc/consul.d/web.json</div><div class="line"></div><div class="line"></div><div class="line">#重启agent，指定配置目录</div><div class="line">consul agent -dev -config-dir=/etc/consul.d</div></pre></td></tr></table></figure><p>如果你想注册多个服务，你可以在配置目录下创建多个服务定义文件。</p><p><br></p><h3 id="查询服务"><a href="#查询服务" class="headerlink" title="查询服务"></a>查询服务</h3><p>一旦agent启动并且服务已同步，我们可通过HTTP API或DNS查询(query)服务。</p><p><br></p><p><strong>DNS API</strong><br>使用DNS API查询服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#DNS name(默认) -- NAME.service.consul</div><div class="line"></div><div class="line">#只有IP</div><div class="line">dig @127.0.0.1 -p 8600 web.service.consul</div><div class="line"></div><div class="line"></div><div class="line">#返回IP/Port</div><div class="line">dig @127.0.0.1 -p 8600 web.service.consul SRV</div></pre></td></tr></table></figure><p>我们还可以用DNS API按tag来过滤service。基于标签的查询格式为<code>tag.name.service.consul</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dig @127.0.0.1 -p 8600 rails.web.service.consul</div></pre></td></tr></table></figure><p><br></p><p><strong>HTTP API</strong><br>除了DNS API，HTTP API同样可用于查询服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#前面定义了web这个service</div><div class="line">curl http://localhost:8500/v1/catalog/service/web</div></pre></td></tr></table></figure><p>catalog API提供了给定服务的所有节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#仅仅健康实例的查询</div><div class="line"> curl &apos;http://localhost:8500/v1/health/service/web?passing&apos;</div></pre></td></tr></table></figure><p><br></p><h3 id="更新服务"><a href="#更新服务" class="headerlink" title="更新服务"></a>更新服务</h3><p>服务定义可以通过更改配置文件并向agent发送SIGHUP来更新。这使得更新服务不会出现任何停机或查询服务不可达的情况。</p><p>另外，HTTP API能够用来动态地添加、移除、修改服务。</p><p><br><br><br></p><h2 id="Consul集群"><a href="#Consul集群" class="headerlink" title="Consul集群"></a>Consul集群</h2><p>具有多个成员的consul集群。</p><p>当consul节点启动时，它不知道任何其它节点，它是一个孤立的集群。为了了解到集群中的其它成员，agent必须要加入一个存在的集群。要加入一个现有的集群，只需知道一个现有成员。当加入集群后，agent将于其此成员闲聊，并迅速发现集群中的其它成员。一个agent可以加入任何其它agent，而不仅仅是server模式的agent。</p><p><br></p><h3 id="启动agents"><a href="#启动agents" class="headerlink" title="启动agents"></a>启动agents</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#node1</div><div class="line">consul agent -server -bootstrap-expect=1 \</div><div class="line">    -data-dir=/tmp/consul -node=agent-one -bind=ip1 \</div><div class="line">    -enable-script-checks=true -config-dir=/etc/consul.d</div><div class="line"></div><div class="line">#node2</div><div class="line">consul agent -data-dir=/tmp/consul -node=agent-two \</div><div class="line">    -bind=ip2 -enable-script-checks=true -config-dir=/etc/consul.d</div><div class="line"></div><div class="line"></div><div class="line">#两个独立的node</div><div class="line"></div><div class="line">#现在，我们有两个agent在运行中：一个server，一个client。但是他们两者并不知道对方，并仍然是一个单一节点的集群。</div><div class="line">#查看节点</div><div class="line">consul member</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="加入集群"><a href="#加入集群" class="headerlink" title="加入集群"></a>加入集群</h2><p>由于我们在启动agent的时候便已指定server，所以从哪个节点加入都一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">consul join ip</div><div class="line">#Successfully joined cluster by contacting 1 nodes.</div><div class="line"></div><div class="line">consul members</div><div class="line"></div><div class="line">Node       Address              Status  Type    Build  Protocol  DC   Segment</div><div class="line">agent-one  172.16.129.141:8301  alive   server  1.0.6  2         dc1  &lt;all&gt;</div><div class="line">agent-two  172.16.129.150:8301  alive   client  1.0.6  2         dc1  &lt;default&gt;</div></pre></td></tr></table></figure><p><br></p><h3 id="在启动时自动加入集群"><a href="#在启动时自动加入集群" class="headerlink" title="在启动时自动加入集群"></a>在启动时自动加入集群</h3><p>理想情况下，每当一个新节点出现在数据中心时，它应该自动加入集群而不需要人工干预。</p><p><br><br><br></p><h3 id="查询节点"><a href="#查询节点" class="headerlink" title="查询节点"></a>查询节点</h3><p>就像查询服务，consul有一个API用于查询节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#NAME.node.consul或NAME.node.DATACENTER.conosul</div><div class="line">dig @localhost -p 8600 agent-one.node.consul</div><div class="line">dig @127.0.0.1 -p 8600 agent-two.node.consul</div></pre></td></tr></table></figure><p><br></p><h3 id="离开集群"><a href="#离开集群" class="headerlink" title="离开集群"></a>离开集群</h3><ul><li>优雅的退出: <code>Ctrl+C</code></li><li>强制<code>kill</code></li></ul><p><br><br><br></p><h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>对节点和服务添加健康检查(health check)。<br>健康检查是服务发现的关键组件，可以防止使用不健康的服务。</p><p><br></p><h3 id="定义检查"><a href="#定义检查" class="headerlink" title="定义检查"></a>定义检查</h3><p>与服务类似，一个检查能够通过定义检查或适当调用HTTP API来两种方式来注册。</p><p>定义<strong>检查</strong>是一个最基本和推荐的方法。</p><p>在consul配置目录中创建检查定义文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#在基于脚本的健康检查上，它与consul进程使用同样的用户</div><div class="line">#如果命令以非0状态码退出，则该节点会被标记为unhealthy</div><div class="line"></div><div class="line">echo &apos;&#123;&quot;check&quot;: &#123;&quot;name&quot;: &quot;ping&quot;, &quot;args&quot;: [&quot;ping&quot;, &quot;-c1&quot;, &quot;baidu.com&quot;], &quot;interval&quot;: &quot;30s&quot;&#125;&#125;&apos; &gt;/etc/consul.d/ping.json</div><div class="line"></div><div class="line">echo &apos;&#123;&quot;service&quot;: &#123;&quot;name&quot;: &quot;web&quot;, &quot;tags&quot;: [&quot;rails&quot;], &quot;port&quot;: 80, &quot;check&quot;: &#123;&quot;args&quot;: [&quot;curl&quot;, &quot;localhost&quot;], &quot;interval&quot;: &quot;10s&quot;&#125;&#125;&#125;&apos; &gt;/etc/consul.d/web.json</div><div class="line"></div><div class="line"></div><div class="line">consul reload</div></pre></td></tr></table></figure><p><br></p><h2 id="检查健康状态"><a href="#检查健康状态" class="headerlink" title="检查健康状态"></a>检查健康状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl http://localhost:8500/v1/health/state/critical</div><div class="line"></div><div class="line">dig @127.0.0.1 -p 8600 web.service.consul</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="KV数据"><a href="#KV数据" class="headerlink" title="KV数据"></a>KV数据</h2><p>Consul提供了一个易于使用的KV存储。这可以用来保存动态配置，协助服务协调，构建leader选举，并启用开发人员可以考虑构建的任何其它内容。</p><p><br></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>有两种方法与Consul K/V交互的方式：</p><ul><li>HTTP API</li><li>Consul KV CLI</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#CLI</div><div class="line">consul kv --help</div><div class="line"></div><div class="line">consul kv put name zhang</div><div class="line">consul kv get name</div><div class="line">#zhang</div><div class="line"></div><div class="line">consul kv get -detailed name</div><div class="line"></div><div class="line">consul kv puut -flags=42 who zhang21</div><div class="line">#所有key都支持设置一个64位的整数标志值</div><div class="line"></div><div class="line"></div><div class="line">#列出所有kv</div><div class="line">consul kv get -recurse</div><div class="line"></div><div class="line"></div><div class="line">#删除</div><div class="line">consul kv delete name</div><div class="line"></div><div class="line"></div><div class="line">#使用 Check-And-Set 进行原子更新</div><div class="line">consul kv put -cas -modify-index=112 NAME zhang</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#导出与导入</div><div class="line">consul kv export &gt; xxx.json</div><div class="line"></div><div class="line">consul kv import $xxx.json</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Consul-Web界面"><a href="#Consul-Web界面" class="headerlink" title="Consul Web界面"></a>Consul Web界面</h2><p>Consul支持美观的Web界面。用户界面可以查看所有的服务和节点，查看所有健康检查和当前状态，读取和设置kv数据，并自动支持多数据中心。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">consul agent -ui</div><div class="line"></div><div class="line">#localhost:8500/ui</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.consul.io/intro/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.consul.io/intro/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.consul.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.consul.io/docs/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Consul" scheme="https://zhang21.github.io/tags/Consul/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://zhang21.github.io/2018/03/27/Docker/"/>
    <id>https://zhang21.github.io/2018/03/27/Docker/</id>
    <published>2018-03-27T00:38:33.000Z</published>
    <updated>2018-04-08T02:11:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>Docker官方文档 <a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></li></ul><p>环境：</p><ul><li>CentOS7. x86_64</li><li>Docker v18.03</li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><h1 id="Docker综述"><a href="#Docker综述" class="headerlink" title="Docker综述"></a>Docker综述</h1><p>Docker是一个开发、shipping、运行应用程序的开放平台。Docker使你能够将应用程序与基础架构(infrastructure)分离开，从而可以快速交付软件。借助Docker，你可以像管理应用程序一样管理基础架构。利用Docker的方法快速进行运输、测试和部署代码，可以显著缩短编写代码和在生存环境中运行代码之间的延迟。</p><p><br></p><h2 id="Docker平台"><a href="#Docker平台" class="headerlink" title="Docker平台"></a>Docker平台</h2><p>Docker提供了在称为容器的松散隔离(isolated)环境中 打包和运行应用程序的能力。隔离性和安全性允许你在给定的主机上同时运行多个容器。容器是轻量级(lightweight)的，因为它们不需要hypervisor的额外负载，而是直接使用主机的内核运行。这意味着，与使用虚拟机相比，你可以在给定的硬件组合上运行更多的容器。你甚至可以在虚拟主机中运行Docker容器。</p><p>Docker提供了工具和平台来管理容器的生命周期(lifecycle)：</p><ul><li>使用容器开发应用程序及其支持组件</li><li>容器成为分发和测试你应用程序的单元</li><li>准备好后，将你的应用程序部署到生产环境中，作为容器协调服</li></ul><p><br></p><h2 id="Docker引擎"><a href="#Docker引擎" class="headerlink" title="Docker引擎"></a>Docker引擎</h2><p>Docker引擎是一个包含如下部件的client-server应用程序：</p><ul><li>Server是称为守护进程的dockerd</li><li>REST API是指定程序可用于与守护进程进行通信并指示其执行操作的接口</li><li>Client是command line interface(CLI)</li></ul><p><img src="/images/Docker/engine-components-flow.png" alt=""></p><p>Docker的开源许可协议是Apache2.0</p><p><br></p><h2 id="能用Docker做什么"><a href="#能用Docker做什么" class="headerlink" title="能用Docker做什么"></a>能用Docker做什么</h2><p><strong>快速、一致的交付应用程序</strong></p><p>通过允许开发人员在 提供应用程序和服务的本地容器 的标准化环境 下工作，Docker简化了开发生命周期。容器非常适合<strong>持续集成(continuous intergration,CI)和持续交付(continuous deliver,CD)</strong>工作流程。</p><p>考虑如下示例场景：</p><ul><li>开发者在本地编写代码，并使用Docker容器分享工作给他们的同事</li><li>使用Docker将应用程序push到测试环境，并自动执行和手动测试</li><li>当开发人员发现bug，他们能在开发环境中修复bug，并重新部署应用程序到测试环境进行测试和验证</li><li>测试完成后，向客户提供修补的应用程序 与将更新的image push到生产环境一样简单</li></ul><p><br></p><p><strong>响应式部署和伸缩</strong></p><ul><li>Docker的基于容器的品台支持高度可移植的工作负载。Docker container可以运行在笔记本、物理机、虚拟机、云平台…</li><li>Docker的可移植性和轻量化特性也使得动态管理工作负载非常容易，可以近乎实时地按业务需求扩展或拆分应用程序和服务</li></ul><p><br></p><p><strong>在同一硬件上运行更多的工作负载</strong></p><p>Docker轻量且快速。它为基于hypersior的虚拟机提供了一种可行、经济高效的替代方案，因此你可以使用更多计算容量来实现业务目标。Docker是高密度环境和中小型部署的理想选择，你需要用更小的资源做更多的事情。</p><p><br></p><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><p>Docker使用了client-server的体系架构。客户端向守护进程发送消息，守护进程负责构建、运行和分发 Docker容器。客户端和守护进程可以在同一系统上运行，也可将客户端连接到远程的Docker守护进程。客户端和守护进程使用REST API，通过Unix socket或network interface进程通信。</p><p><img src="/images/Docker/architecture.png" alt="Docker架构图"></p><p><br></p><h3 id="Docker-daemon"><a href="#Docker-daemon" class="headerlink" title="Docker daemon"></a>Docker daemon</h3><p>Docker daemon(<code>dockerd</code>)，监听Docker API请求并管理Docker对象——image、container、network、volume。<br>docker daemon还可与其它docker daemon通信来管理docker service。</p><p><br></p><h3 id="Docker-client"><a href="#Docker-client" class="headerlink" title="Docker client"></a>Docker client</h3><p>Docker client(<code>docker</code>)是许多Docker用户与Docker进行交互的主要方式。客户端将命令发送给守护进程，守护进程执行命令。<br>Docker命令使用Docker API，Docker客户端可与多个守护进程进行通信。</p><p><br></p><h3 id="Docker-registry"><a href="#Docker-registry" class="headerlink" title="Docker registry"></a>Docker registry</h3><p>Docker registry存储Docker image。Docker Hub和Docker Cloud是任何人都可使用的public registry，你可以创建private registry。</p><p><code>docker pull</code>或<code>docker run</code>需要的image便是从配置的registry中提取。<code>docker push</code>推送image到你配置的registry。</p><p><br></p><h2 id="Docker-objects"><a href="#Docker-objects" class="headerlink" title="Docker objects"></a>Docker objects</h2><p>当你使用Docker时，你会创建和使用 image、container、network、volume、plugin和其它对象。</p><p><br></p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>镜像是一个只读模板，带有创建Docker容器的说明。通常，镜像基于其它镜像，并具有一些额外的自定义功能。<br>例如，你可构建基于Ubuntu镜像的镜像，但会按照ApacheWeb服务器和应用程序，以及应用程序所需的配置。</p><p>你可能创建自己的镜像，或使用由别人创建并推送到registry上的镜像。构建自己的镜像，需要使用简单的语法创建一个Dockerfile，以定义创建镜像并运行它所需的步骤。</p><p><br></p><h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><p>容器是镜像的可运行实例。可将容器连接到一个或多个网络，将存储器连接到它，还可根据当前状态创建新镜像。</p><p>默认情况下，容器与其它容器以及主机是相对隔离的。你可以控制容器的网络、存储、其它底层子系统与其它容器或主机的隔离程度。</p><p>容器由镜像定义，以及你在创建或启动时提供给它的任何配置选项。当一个容器被移除时，其未被存储在永久存储器中的状态会消失。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#运行一个Ubuntu镜像，交互地连接到本地命令会话</div><div class="line"></div><div class="line">docker run -i -t ubuntu /bin/bash</div></pre></td></tr></table></figure><p>以上命令会发生如下步骤:</p><ol><li>如果本地没有Ubuntu镜像，docker会从registry拉取，就好像你手动运行 <code>docker pull ubuntu</code></li><li>Docker创建一个新容器，就好像你手动执行<code>docker container create</code></li><li>Docker分配一个读写文件系统给容器，作为它的最后一层</li><li>如果你没有指定任何网络选项，Docker会创建一个网络接口将容器连接到默认网络。</li><li>Docker开启容器并执行/bin/bash</li><li>发送<code>exit</code>到<code>/bin/bash</code>，容器停止但并未被移除</li></ol><p><br></p><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>服务允许你伸缩多个Docker守护进程的容器，这些守护进程可以作为一个swarm与多个manager和worker一起工作。默认情况下，该服务在所有node之间进行负载均衡。</p><p><br></p><h3 id="底层技术"><a href="#底层技术" class="headerlink" title="底层技术"></a>底层技术</h3><p>Docker使用GO编写，利用Linux内核的几个特性来提供其功能。</p><p><br></p><p><strong>namespace</strong></p><p>Docker使用一个称为<code>namespace</code>的技术来提供称为容器的独立工作空间。当你运行一个容器时，Docker会为该容器创建一组命名空间。<br>命名空间提供了一个隔离层。容器的每个方面都在单独<code>namespace</code>中运行，并且其访问权限仅限于该单独的<code>namespace</code>。</p><p>Docker引擎在Linux上使用如下<code>namespace</code>：</p><ul><li><code>pid</code> namespace： 进程隔离</li><li><code>net</code> namespace： 管理网络接口</li><li><code>pid</code> namespace： 管理对IPC(InterProcess Communication)资源的访问</li><li><code>mnt</code> namespace： 管理文件系统挂载点</li><li><code>ust</code> namespace： 隔离内核和版本标识符(Unix Timesharing System)</li></ul><p><br></p><p><strong>control groups</strong></p><p>Linux上的Docker Engine也依赖与另一种称为控制组(cgroups)的技术。cgroup将应用程序限制为一组特定的资源。控制组允许Docker引擎将可用的硬件资源共享给容器，并可选地强制实施限制和约束。<br>例如，你可限制特定容器的内存是CPU使用率等。</p><p><br></p><p><strong>union file systems</strong></p><p>union file systems(UnionFS)，是通过创建layer进行操作的文件系统，使得它们非常轻量和快速。Docker引擎使用UnioFS为容器提供构建block。Docker引擎可以使用多种UnionFS变体，包括AUFS, brrfs, vfs, DeviceMapper…</p><p><br></p><p><strong>container format</strong></p><p>Docker引擎将namespace、cgroup、UnionFS组合成一个名为容器格式的包装器。默认的容器格式为<code>libcontainer</code>。</p><p><br><br><br></p><hr><p><br></p><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p>Docker有两个可获取的版本：</p><ul><li>Community Edition(CE)<ul><li>适合开始使用Docker并尝试基于容器的应用程序的开发人员和小型团队</li></ul></li><li>Enterprise Edition(EE)<ul><li>专为企业开发和IT团队而设计，可以在生产规模上构建，发布和运行关键业务应用程序</li></ul></li></ul><p><br><br><br></p><h2 id="为CentOS7安装Docker-CE"><a href="#为CentOS7安装Docker-CE" class="headerlink" title="为CentOS7安装Docker CE"></a>为CentOS7安装Docker CE</h2><h3 id="OS要求"><a href="#OS要求" class="headerlink" title="OS要求"></a>OS要求</h3><ul><li>CentOS7.x</li><li><code>centos-extras</code> repository</li><li>推荐使用<code>overlay2</code>存储驱动</li><li>安装新版本Docker需卸载老版本Docker</li><li>Docker CE包被称为<code>docker-ce</code></li></ul><p><br></p><h3 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h3><ul><li><a href="https://download.docker.com/" target="_blank" rel="noopener">https://download.docker.com/</a></li></ul><p>多种安装方法：</p><ul><li>Docker’s repository</li><li>RPM package</li><li>scripts</li></ul><p><br></p><p><strong>使用repository安装：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#安装依赖</span></div><div class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#设置repository</span></div><div class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#安装Docker CE</span></div><div class="line">yum install -y docker-ce</div><div class="line"></div><div class="line"><span class="comment">#Docker安装但未启动，docker group会被创建，但没有用户添加到组中</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#在生产环境中，你可能需要安装特定版本的Docker CE，而不是最新版</span></div><div class="line">yum list docker-ce --showduplicates | sort -r</div><div class="line">yum search docker-ce --showduplicates</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#开启docker</span></div><div class="line">systemctl start docker</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#测试docker</span></div><div class="line">docker run hello-world</div><div class="line"></div><div class="line"><span class="comment">#此命令下载一个测试image并将其运行到container中</span></div><div class="line"><span class="comment">#Hello from Docker!</span></div></pre></td></tr></table></figure><p><br></p><p><strong>使用package安装：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#下载rpm包</span></div><div class="line">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#安装</span></div><div class="line">yum install -y /path/docker-cexxx.rpm</div><div class="line"></div><div class="line"></div><div class="line">systemctl start docker</div><div class="line"></div><div class="line">docker run hello-world</div></pre></td></tr></table></figure><p><br></p><p><strong>使用scripts安装：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">curl -fsSL get.docker.com -o get-docker.sh</div><div class="line"></div><div class="line">sh get-docker.sh</div><div class="line"></div><div class="line"><span class="comment">#手动添加group合user</span></div><div class="line">usermod -aG docker your-user</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="卸载Docker-CE"><a href="#卸载Docker-CE" class="headerlink" title="卸载Docker CE"></a>卸载Docker CE</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">yum remove docker-ce</div><div class="line"></div><div class="line"><span class="comment">#默认文件</span></div><div class="line">rm -rf /var/lib/docker</div><div class="line"></div><div class="line"><span class="comment">#你还需要手动删除其它配置文件</span></div></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p><br><br><br></p><h2 id="关于Docker"><a href="#关于Docker" class="headerlink" title="关于Docker"></a>关于Docker</h2><p>Docker文档会有如下讲解：</p><ul><li>设置你的Docker环境</li><li>在一个容器(container)中构建并运行一个镜像</li><li>延伸你的APP以便在多个容器中运行</li><li>在整个集群中分配你的APP</li><li>通过添加后端数据库来堆栈服务</li><li>将应用部署到生产</li></ul><p><br></p><h3 id="Docker的概念"><a href="#Docker的概念" class="headerlink" title="Docker的概念"></a>Docker的概念</h3><p>Docker是开发人员，系统管理员使用容器来开发、部署和运行APP的平台。使用Linux容器来部署APP被称为<strong>集装箱化(containerzation)</strong></p><p><img src="/images/Docker/laurel-docker-containers.png" alt=""></p><p>集装箱受欢迎的几点原因：</p><ul><li>灵活(flexible)</li><li>轻量(lightweight)</li><li>通用(Interchangeable)</li><li>可移植(portable)</li><li>延伸(scalable)</li><li>堆栈(stackable)</li></ul><p><br></p><h3 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h3><p>通过运行镜像(image)启动容器(container)。镜像是一个可执行包，包含运行APP所需的所有内容：代码，库，环境变量，配置文件…</p><p>容器是镜像的运行时(runtime)实例。在Linux上使用<code>docker ps</code>命令查看运行的容器列表。</p><p><br></p><h3 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h3><p>容器在Linux本地上运行，并与其它容器共享主机Kernel。它是一个独立的进程，不占其它可执行文件内存，使其轻量化。</p><p>虚拟机(VM)运行一个完整的访客操作系统，通过虚拟机管理程序访问主机资源。一般来说，虚拟机比大多数应用程序需要的资源更多。</p><p><img src="/images/Docker/docker002.png" alt=""></p><p><br><br><br></p><h3 id="准备Docker环境"><a href="#准备Docker环境" class="headerlink" title="准备Docker环境"></a>准备Docker环境</h3><p>Docker版本：</p><ul><li>CE: Docker Community Edition</li><li>EE: Docker Enterprise Edition</li></ul><p><a href="#安装Docker">Install Docker</a></p><p><br></p><h2 id="测试Docker"><a href="#测试Docker" class="headerlink" title="测试Docker"></a>测试Docker</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">docker --version</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看详细信息</span></div><div class="line">docker info</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#测试安装工作是否正常</span></div><div class="line">docker run hello-world</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看镜像</span></div><div class="line">docker image ls</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#列出容器</span></div><div class="line">docker container ls -all</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#docker命令</span></div><div class="line">docker</div><div class="line">docker container --<span class="built_in">help</span></div></pre></td></tr></table></figure><p><br></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>集装箱化使得<strong>CI/CD</strong>无缝：</p><ul><li>持续集成(Continuous integration, CI)</li><li>持续部署(continuous deployment, CD)</li><li>APP无系统依赖</li><li>更新能够推送到分布式APP的任何部分</li><li>资源密度可以被优化</li></ul><p>使用Docker，扩展APP的过程就是启动新的可执行文件，而不是运行繁重的VM主机。</p><p><br><br><br></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Container</p><p><br></p><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run hello-world</div></pre></td></tr></table></figure><p><br></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>是时候使用Docker方式来构建一个APP了。</p><ul><li>从应用程序的层次结构底部开始，这是一个容器(container)</li><li>在此级别之上，是一个服务(service)，它定义了容器在生产中的表现</li><li>最后，顶层是堆栈(stack)，定义所有服务的交互(interaction)</li></ul><p>Like this:</p><ul><li>Stack</li><li>Service</li><li>Container</li></ul><p><br></p><h3 id="新开发环境"><a href="#新开发环境" class="headerlink" title="新开发环境"></a>新开发环境</h3><p>在过去，如果你要开始编写一个Python APP，你的第一要务是在你的机器运行时安装Python。但是，这会造成你的计算机上的环境，需要如预期般完美适合你的APP，并且还需要与你的生产环境相匹配。</p><p>使用Docker，你可以将一个可移植的Python运行时作为一个image，无需安装。接着，你的构建可以将基础Python image与APP代码一起包含在内，确保你的APP，依赖项…都构建一起。</p><p><br></p><h3 id="使用Dockerfile定义一个容器"><a href="#使用Dockerfile定义一个容器" class="headerlink" title="使用Dockerfile定义一个容器"></a>使用<code>Dockerfile</code>定义一个容器</h3><p><code>Dockerfile</code>定义了容器内环境中发生的事情。访问的网络接口(network interface)和磁盘驱动(disk driver)等资源是在此环境中虚拟化的(virtualized)，与系统其余部分隔离。因此你需要将端口映射(map port)到外部世界，并明确指定要将哪些文件<strong>复制</strong>到此环境中。但是，在完成这些后，你完全可以将它们看做一致 —— 在<code>Dockerfile</code>中定义的构建的APP的行为与它运行时的行为完全相同。</p><p><strong>Dockerfile</strong></p><p>创建一个空目录，并创建一个名叫<code>Dockerfile</code>的文件，复制以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># Use an official Python runtime as a parent image</div><div class="line">FROM python:2.7-slim</div><div class="line"></div><div class="line"># Set the working directory to /app</div><div class="line">WORKDIR /app</div><div class="line"></div><div class="line"># Copy the current directory contents into the container at /app</div><div class="line">ADD . /app</div><div class="line"></div><div class="line"># Install any needed packages specified in requirements.txt</div><div class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</div><div class="line"></div><div class="line"># Make port 80 available to the world outside this container</div><div class="line">EXPOSE 80</div><div class="line"></div><div class="line"># Define environment variable</div><div class="line">ENV NAME World</div><div class="line"></div><div class="line"># Run app.py when the container launches</div><div class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</div></pre></td></tr></table></figure><p>注意代理服务器会阻断你与APP的连接！</p><p>这个<code>Dockerfile</code>引用了一些我们还没有创建的文件，分别是<code>app.py</code>和<code>requirements.txt</code>。接下来创建它们。</p><p><br></p><h3 id="APP自身"><a href="#APP自身" class="headerlink" title="APP自身"></a>APP自身</h3><p>创建另外的文件，如上面的<code>app.py</code>和<code>requirements.txt</code>，并将它们与<code>Dockerfile</code>放置于同一目录下。这就完成了我们的APP，这看起来非常简单。当这个<code>Dockerfile</code>被构建成一个image时，由于<code>Dockerfile</code>的<code>ADD</code>命令，<code>app.py</code>和<code>requirements.txt</code>仍然存在，而且由于使用了EXPOSE命令，<code>app.py</code>的输出仍可以通过HTTP访问。</p><p><strong>requirements.txt: </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Flask</div><div class="line">Redis</div></pre></td></tr></table></figure><p><strong>app.py: </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line">from redis import Redis, RedisError</div><div class="line">import os</div><div class="line">import socket</div><div class="line"></div><div class="line"># Connect to Redis</div><div class="line">redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line">@app.route(&quot;/&quot;)</div><div class="line">def hello():</div><div class="line">    try:</div><div class="line">        visits = redis.incr(&quot;counter&quot;)</div><div class="line">    except RedisError:</div><div class="line">        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</div><div class="line"></div><div class="line">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</div><div class="line">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</div><div class="line">           &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</div><div class="line">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    app.run(host=&apos;0.0.0.0&apos;, port=80)</div></pre></td></tr></table></figure><blockquote><p>在容器内访问主机的名称将检索容器ID，这进程ID类似。</p></blockquote><p>仅此而已，在你的系统中，你不需要任何Python或requirements.txt文件，也不需要在你的系统上安装 构建或运行的image。看起来你并没有真正用Python和Flask建立一个环境，但是你确实已经拥有了。</p><p><br></p><h3 id="构建APP"><a href="#构建APP" class="headerlink" title="构建APP"></a>构建APP</h3><p>我们准备去构建(build)APP。确保你仍在目录的顶层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">#查看是否还在顶层</div><div class="line">ls</div><div class="line"></div><div class="line">Dockerfileapp.pyrequirements.txt</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#在此目录运行build命令，这将创建一个Docker image，用 -t 命名</div><div class="line">docker build -t friendlyhello .</div><div class="line"></div><div class="line"></div><div class="line">#查看你build的image</div><div class="line">docker image ls</div><div class="line"></div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">friendlyhello       latest              b24e21d7645f        13 minutes ago      150MB</div><div class="line"></div><div class="line"></div><div class="line">#运行APP</div><div class="line">docker run -p 4000:80 friendlyhello</div><div class="line"></div><div class="line"></div><div class="line">#测试</div><div class="line">curl http://localhost:4000</div><div class="line">links http://localhost:4000</div><div class="line"></div><div class="line"></div><div class="line">#在后台运行</div><div class="line">docker run -d -p 4000:80 friendlyhello</div><div class="line"></div><div class="line"></div><div class="line">#查看容器</div><div class="line">docker container ls</div><div class="line"></div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES</div><div class="line">146662dca737        friendlyhello       &quot;python app.py&quot;     16 seconds ago      Up 16 seconds       0.0.0.0:4000-&gt;80/tcp   goofy_chaplygin</div><div class="line"></div><div class="line"></div><div class="line">#停止</div><div class="line">Ctrl + C</div><div class="line">docker container stop docker-ID</div><div class="line">docker container stop 146662dca737</div></pre></td></tr></table></figure><p><img src="/images/Docker/docker003.png" alt="效果图"></p><p><br></p><p>端口重映射<code>4000:80</code>是为了证明Dockerfile中的EXPOSE与使用<code>docker run -p</code>发布的内容之间的区别。<br>在后续步骤中，我们只需将主机的80端口映射到容器的80端口就好。</p><p><br></p><h3 id="分享你的image"><a href="#分享你的image" class="headerlink" title="分享你的image"></a>分享你的image</h3><p>为了演示刚才创建的image的可移植性(portability)，让我们上传build的image并在其它地方run它。毕竟，当你需要将container部署到生产环境时，你需要知道如何push注册。</p><p>注册表(registry)是一个repository的集合，而repository是image的集合——有点类似于GitHub repository，但代码是已经构建了的。<br>注册表上的账户可以创建许多repository。docker CLI 默认使用Docker’s public registry。你也可以选择其它注册表，或创建自己的注册表。</p><p><br></p><p><strong>使用Docker ID登录：</strong></p><p>如果没有Docker账户，请先注册 <cloud.docker.com>。</cloud.docker.com></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker login</div><div class="line"></div><div class="line">docker login -u zhang21</div></pre></td></tr></table></figure><p><br></p><p><strong>标记image：</strong></p><p>使用<code>username/repository:tag</code>将本地image与registry中的repository相关联。tag是可选的，但推荐使用tag。因为它是注册管理机构用于为Docker image提供版本的机制。为该内容提供一个有意义的repository和tag，例如<code>get-started:part2</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">docker tag image username/repository:tag</div><div class="line"></div><div class="line">#例子</div><div class="line">docker tag friendlyhello zhang/test:tag-test</div><div class="line"></div><div class="line"></div><div class="line">#查看tag</div><div class="line">docker images ls</div></pre></td></tr></table></figure><p><br></p><p><strong>发布image：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#上传你标记了的image到repository</div><div class="line">docker push username/repository:tag</div><div class="line"></div><div class="line">docker push zhang21/test:tag-test</div><div class="line"></div><div class="line">#完成后，此image便可以公开获取</div></pre></td></tr></table></figure><p><br></p><p><strong>从远处repository拉取并运行image：</strong></p><p>无论在哪里执行<code>docker run</code>，它都会将你的image以及Python和所有依赖关系一起拉取下来，并运行你的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run -p 4000:80 username/repository:tag</div><div class="line"></div><div class="line">docker run -p 80:80 zhang21/test:tag-test</div></pre></td></tr></table></figure><p><br></p><h3 id="本节基础命令"><a href="#本节基础命令" class="headerlink" title="本节基础命令"></a>本节基础命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#从Dockerfile创建image</span></div><div class="line">docker build -t image-name .</div><div class="line"></div><div class="line"><span class="comment">#运行image</span></div><div class="line">docker run -p 4000:80 image-name</div><div class="line"></div><div class="line"><span class="comment">#后台运行</span></div><div class="line">docker run -d -p 4000:80 image-name</div><div class="line"></div><div class="line"><span class="comment">#列出运行的容器</span></div><div class="line">docker container ls</div><div class="line"><span class="comment">#列出所有容器，包括未运行</span></div><div class="line">docker container ls -a</div><div class="line"></div><div class="line"><span class="comment">#优雅停止容器</span></div><div class="line">docker container stop 容器ID</div><div class="line"><span class="comment">#强制停止</span></div><div class="line">docker container <span class="built_in">kill</span> 容器ID</div><div class="line"></div><div class="line"><span class="comment">#删除容器</span></div><div class="line">docker container rm 容器ID</div><div class="line"><span class="comment">#删除所有容器</span></div><div class="line">docker container rm $(docker container ls -a -q)</div><div class="line"></div><div class="line"><span class="comment">#列出镜像</span></div><div class="line">docker image ls</div><div class="line"><span class="comment">#列出所有镜像</span></div><div class="line">docker image ls -a</div><div class="line"></div><div class="line"><span class="comment">#删除镜像</span></div><div class="line">docker image rm 镜像ID</div><div class="line"><span class="comment">#删除所有镜像</span></div><div class="line">docker image rm $(docker image ls -a -q)</div><div class="line"></div><div class="line"><span class="comment">#登录</span></div><div class="line">docker login</div><div class="line"></div><div class="line"><span class="comment">#标记</span></div><div class="line">docker tag 镜像 username/repository:tag</div><div class="line"></div><div class="line"><span class="comment">#上传到注册表</span></div><div class="line">docker push username/repository:tag</div><div class="line"></div><div class="line"><span class="comment">#从注册表拉取</span></div><div class="line">docker run username/repository:tag</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>service</p><p><br></p><h3 id="先决条件-1"><a href="#先决条件-1" class="headerlink" title="先决条件"></a>先决条件</h3><ul><li>安装Docker</li><li>获取Docker Compose</li><li>阅读Orientation</li><li>阅读Container</li><li>确保已发布friendlyhello image到你的registry</li><li>确保你的image工作为一个部署的container。<code>docker run -p 80:80 username/repo:tag</code></li></ul><p><br></p><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>在此，我们<strong>扩展(scale)</strong>APP并启用<strong>负载均衡(load balancing)</strong>。要做到这样，我们必须在分布式(distributed)应用程序的层次结构中升一级: 服务</p><ul><li>Stack</li><li>Service</li><li>Container</li></ul><p><br></p><h3 id="关于服务"><a href="#关于服务" class="headerlink" title="关于服务"></a>关于服务</h3><p>在分布式应用程序中，应用程序的不同部分称为服务(service)。</p><p>例如，一个视频共享站点。那么它可能包含：</p><ul><li>用于将应用程序数据 存储到数据库中的服务</li><li>用户上传后的视频转码服务</li><li>前端服务</li><li>…</li></ul><p>服务是真正的生产环境中的容器。一个service只运行一个image，但它可修改image的运行方式 —— 哪个端口、容器应该运行多少个副本以便于服务所需的容量等.<br>伸缩服务会更改运行该软件的容器实例数量，从而为进程中的服务分配更多的计算资源。</p><p>在Docker平台上定义、运行和伸缩服务都是很简单的 —— 只需修改<code>docker-compose.yml</code>文件。</p><p><br></p><h3 id="你的第一个docker-compose-yml文件"><a href="#你的第一个docker-compose-yml文件" class="headerlink" title="你的第一个docker-compose.yml文件"></a>你的第一个<code>docker-compose.yml</code>文件</h3><p><code>docker-compose.yml</code>是一个YAML文件，它定义了Docker container在生产中的行为方式。</p><p><strong>docker-compose.yml：</strong></p><p>将如下信息保存为<code>docker-compose.yml</code>，确保你已经<code>pushed the image</code>到registry，并通过修改<code>.yml</code>文件的image detail来替换<code>username/repo:tag</code>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="attr">version:</span> <span class="string">"3"</span></div><div class="line"><span class="attr">services:</span></div><div class="line"><span class="attr">  web:</span></div><div class="line">    <span class="comment"># replace username/repo:tag with your name and image details</span></div><div class="line"><span class="attr">    image:</span> <span class="string">username/repo:tag</span></div><div class="line"><span class="attr">    deploy:</span></div><div class="line"><span class="attr">      replicas:</span> <span class="number">5</span></div><div class="line"><span class="attr">      resources:</span></div><div class="line"><span class="attr">        limits:</span></div><div class="line"><span class="attr">          cpus:</span> <span class="string">"0.1"</span></div><div class="line"><span class="attr">          memory:</span> <span class="number">50</span><span class="string">M</span></div><div class="line"><span class="attr">      restart_policy:</span></div><div class="line"><span class="attr">        condition:</span> <span class="string">on-failure</span></div><div class="line"><span class="attr">    ports:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"80:80"</span></div><div class="line"><span class="attr">    networks:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">webnet</span></div><div class="line"><span class="attr">networks:</span></div><div class="line"><span class="attr">  webnet:</span></div></pre></td></tr></table></figure><p><br></p><p><code>docker-compose.yml</code>文件告诉Docker之下如下操作：</p><ul><li>pull the image</li><li>Run 5 instances of that image as a service called <code>web</code></li><li>限制每个实例最多使用10%的CPU和50MB的RAM</li><li>如果一个失败，马上重启container</li><li>映射主机的80端口到web的80端口</li><li>指示web container通过称为<code>webnet</code>的负载均衡网络共享80端口</li><li>使用默认设置定义<code>webnet</code>网络</li></ul><p><br></p><h3 id="运行你的负载均衡APP"><a href="#运行你的负载均衡APP" class="headerlink" title="运行你的负载均衡APP"></a>运行你的负载均衡APP</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">docker swarm init</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#运行并设置APP名字</span></div><div class="line">docker stack -c docker-compose.yml app-name</div><div class="line"></div><div class="line">docker stack -c docker-compose.yml LoadBalance</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#在一个主机上，单个服务栈通过部署的image运行5个container instance</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#获取service ID</span></div><div class="line">docker service ls</div><div class="line"></div><div class="line">ID                  NAME                MODE                REPLICAS            IMAGE                   PORTS</div><div class="line">3d1a48yse0t4        LoabBalance_web     replicated          5/5                 zhang21/<span class="built_in">test</span>:tag-test   *:80-&gt;80/tcp</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看服务中的任务</span></div><div class="line">docker service ps app-name_web</div><div class="line"></div><div class="line"></div><div class="line">docker container ls -q</div><div class="line"></div><div class="line"><span class="comment">#5个容器ID</span></div><div class="line">c7ce0075890e</div><div class="line">52ba026bf28c</div><div class="line">6d4381be438f</div><div class="line">bd297a42e89d</div><div class="line">357b05cc38eb</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#访问的时候容器ID会在此5个负载中变化</span></div></pre></td></tr></table></figure><p>在服务中运行的单个container称为任务(task)。任务是具有数字增量的唯一ID，最大数量是在<code>docker-compose.yml</code>中定义的副本数量。</p><p><br></p><h3 id="伸缩APP"><a href="#伸缩APP" class="headerlink" title="伸缩APP"></a>伸缩APP</h3><p>通过修改<code>docker-compose.yml</code>中<code>replicas</code>的值，并重新运行<code>docker stack deploy -c xxx app-name</code>来伸缩APP。</p><p>Docker执行就地更新，不需要stack down或kill any containers.</p><p><strong>卸下APP和swarm：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#app</span></div><div class="line">docker stack rm app-name</div><div class="line"></div><div class="line">docker stack rm LoadBalance</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#swarm</span></div><div class="line">docker swarm leave --force</div></pre></td></tr></table></figure><p>使用Docker扩展APP非常简单。</p><p><br></p><h3 id="本节命令"><a href="#本节命令" class="headerlink" title="本节命令"></a>本节命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#列出栈或APP</span></div><div class="line">docker stack ls</div><div class="line"></div><div class="line"><span class="comment">#运行指定配置文件</span></div><div class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;</div><div class="line"></div><div class="line"><span class="comment">#列出与APP相关联的服务</span></div><div class="line">docker service ls</div><div class="line"></div><div class="line"><span class="comment">#列出与APP相关联的任务</span></div><div class="line">docker service ps &lt;service&gt;</div><div class="line"></div><div class="line"><span class="comment">#检查任务</span></div><div class="line">docker inspect &lt;task or container&gt;</div><div class="line"></div><div class="line"><span class="comment">#列出容器ID</span></div><div class="line">docker container ls -q</div><div class="line"></div><div class="line"><span class="comment">#除掉APP</span></div><div class="line">docker stack rm &lt;appname&gt;</div><div class="line"></div><div class="line"><span class="comment">#从管理中除掉一个单一节点swarm</span></div><div class="line">docker swarm leave --force</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="swarm"><a href="#swarm" class="headerlink" title="swarm"></a>swarm</h2><p><br></p><h3 id="先决条件-2"><a href="#先决条件-2" class="headerlink" title="先决条件"></a>先决条件</h3><ul><li>前面几个小节的内容</li></ul><p><br></p><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>前面你将一个服务运行在生产环境，并扩展为5个副本进程。</p><p>在此，你将APP部署到到集群上，并在多台机器上运行它。通过将多台主机连接到成为<strong>swarm</strong>的<strong>Dockerized</strong>集群，使得多容器、多主机应用成为可能。</p><p><br></p><h3 id="理解swarm集群"><a href="#理解swarm集群" class="headerlink" title="理解swarm集群"></a>理解swarm集群</h3><p>swarm是一组运行Docker并加入到集群中的机器。这样以后，你可以在集群的swarm manager上执行Docker命令。swarm中的机器可以是物理的或虚拟的，当他们加入swarm后，他们便被成为node。</p><p>swarm manager可以使用多种策略来运行容器，你可在compose file中指定相应的策略。</p><p>swarm manager是swarm中唯一可以执行命令、授权其他机器作为工作者加入swarm的机器。工作者(worker)只能在那提供能力(capacity)，并没有权力告诉任何机器能够做什么。</p><p>但目前为止，你已经在本机机器上以单主机(single host)模式使用Docker。但Docker也可以切换为swarm(集群)模式，这就是使用swarm的原因。立即启用swarm模式使得当前机器成为swarm manager。从此，Docker将运行在你管理的swarm上执行命令，而不仅仅是在当前机器上执行。</p><p><br></p><h3 id="建立swarm"><a href="#建立swarm" class="headerlink" title="建立swarm"></a>建立swarm</h3><p>一个swarm由多个节点组成，不管它是虚拟机还是物理机。</p><ul><li>基本概念很简单，运行<code>docker swarm init</code>来开启swarm模式并使得当前机器成为swarm manager</li><li>在其它机器上运行<code>docker swarm join</code>使他们作为worker加入swarm</li></ul><p><br></p><p><strong>栗子：</strong><br>使用VM快速创建两台机器的集群，并将其变为swarm。</p><p>使用<code>docker-machine</code>创建一对VM:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#CentOS7</span></div><div class="line"></div><div class="line"><span class="comment">#安装VirtualBox</span></div><div class="line">wget https://download.virtualbox.org/virtualbox/5.2.8/VirtualBox-5.2-5.2.8_121009_el7-1.x86_64.rpm &amp;&amp; yum install -y Virtual.xx.rpm</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#安装docker-machine</span></div><div class="line"> curl -L https://github.com/docker/machine/releases/download/v0.14.0/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp; install /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#在BIOS中开启虚拟化支持</span></div><div class="line"></div><div class="line"><span class="comment">#在VMware中开启虚拟化支持(如果是VM)</span></div><div class="line"></div><div class="line"></div><div class="line">docker-machine create --driver virtual myvm1</div><div class="line">docker-machine create --driver virtual myvm2</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#列出虚拟机</span></div><div class="line">docker-machine ls</div></pre></td></tr></table></figure><p><br></p><p><strong>初始化swarm并添加node</strong></p><p>第一台机器作为swarm manager，执行命令和join认证，后面的机器作为worker。</p><p>你可以使用<code>docker-machine ssh</code>发送命令到VM。在<code>swarm mananger</code>上执行<code>docker swarm init</code>初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">docker-machine ssh &lt;swarm manager&gt; &quot;docker swarm init --advertise-assr &lt;mananger-IP&gt;&quot;</div><div class="line"></div><div class="line">#add worker</div><div class="line">docker swarm jion --toker &lt;token&gt; &lt;wroker-ip&gt;:&lt;port&gt;</div><div class="line"></div><div class="line"></div><div class="line">#添加manager</div><div class="line">docker swarm join-token manaer</div></pre></td></tr></table></figure><p><strong>由于我的虚拟的无法使用VT，因此我用的两台机器两个Docker来做swarm。</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#初始化这台机器默认为manager</span></div><div class="line">docker swarm init</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#作为worker加入，ip是manager的</span></div><div class="line"><span class="comment">#以下信息会在manager初始化时生成</span></div><div class="line"><span class="comment">#注意防火墙，可能会阻碍加入</span></div><div class="line"></div><div class="line">docker swarm join --toker &lt;toker&gt; &lt;ip:port&gt;</div><div class="line">docker swarm join --token SWMTKN-1-3vrbnuneu0hyu41evxlhbn5fp04ad5jvg9v5rzvdaedg2bghkt-e24mjnni3hu7782t3gkz0ny39 172.16.129.150:2377</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看swarm</span></div><div class="line">docker node ls</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#离开swarm</span></div><div class="line">docker swarm leave</div></pre></td></tr></table></figure><p><br></p><h3 id="在swarm集群上部署APP"><a href="#在swarm集群上部署APP" class="headerlink" title="在swarm集群上部署APP"></a>在swarm集群上部署APP</h3><p>主需要记住，只有swarm manager才能执行docker命令，worker仅仅是容量(capacity)。</p><p>在swarm manager上使用<code>docker-composr.yml</code>和<code>docker stack deploy</code>命令来部署APP。使用<code>docker  service ps &lt;service name&gt;</code>来验证部署。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#在manager部署</div><div class="line">docker stack deploy -c ./docker-compose.yml LoadBalance</div><div class="line"></div><div class="line"></div><div class="line">docker service ls</div><div class="line"></div><div class="line">docker stack ls</div><div class="line"></div><div class="line"></div><div class="line">#注意node名</div><div class="line">docker stack ps LoadBalance</div><div class="line"></div><div class="line">ID                  NAME                IMAGE                   NODE                DESIRED STATE       CURRENT STATE             ERROR               PORTS</div><div class="line">6nrn4mwc6pvt        LoadBalance_web.1   zhang21/test:tag-test   zhang22             Running             Preparing 2 minutes ago</div><div class="line">bpssrnzesl7n        LoadBalance_web.2   zhang21/test:tag-test   zhang22             Running             Preparing 2 minutes ago</div><div class="line">kmhd8p5wkc12        LoadBalance_web.3   zhang21/test:tag-test   zhang21             Running             Running 2 minutes ago</div><div class="line">i0pkf4foms87        LoadBalance_web.4   zhang21/test:tag-test   zhang22             Running             Preparing 2 minutes ago</div><div class="line">rvtpjk781frn        LoadBalance_web.5   zhang21/test:tag-test   zhang21             Running             Running 2 minutes ago</div><div class="line"></div><div class="line"></div><div class="line">#分别访问个主机的IP</div><div class="line">#创建的网络在它们之间共享并负载均衡</div><div class="line">links ip1</div><div class="line">links ip2</div></pre></td></tr></table></figure><p>两个IP地址工作的原因是集群中的节点参与入口(ingress)路由网络(routing mesh)。这可以确保部署在swarm中某个端口的服务始终将该端口保留给自己，而不管实际运行容器的节点是什么。</p><p><img src="/images/Docker/ingress-routing-mesh.png" alt="入口路由"></p><p><br></p><h3 id="清理并重启"><a href="#清理并重启" class="headerlink" title="清理并重启"></a>清理并重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stack rm LoadBalance</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>先决条件，已完成前面的步骤。</p><p><br></p><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>你已到达分布式应用程序层次结构的顶端——stack。堆栈是一组相互关联的服务，它们可以共享依赖关系，并可以进行协调和缩放。单个堆栈能够定义和协调整个应用程序的功能(尽管非常复杂的应用程序可能需要使用多个堆栈)。</p><p>在前面使用的<code>docker deploy</code>——是运行在单主机上的单个服务堆栈，这通常不会发生在生产环境中。在这里，你会使用学到的东西使多个服务相互关联，并在多台机器上运行它们。</p><p><br></p><h3 id="添加一个新服务并部署"><a href="#添加一个新服务并部署" class="headerlink" title="添加一个新服务并部署"></a>添加一个新服务并部署</h3><p>docker-compose2.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line">services:</div><div class="line">  web:</div><div class="line">    # replace username/repo:tag with your name and image details</div><div class="line">    image: username/repo:tag</div><div class="line">    deploy:</div><div class="line">      replicas: 5</div><div class="line">      restart_policy:</div><div class="line">        condition: on-failure</div><div class="line">      resources:</div><div class="line">        limits:</div><div class="line">          cpus: &quot;0.1&quot;</div><div class="line">          memory: 50M</div><div class="line">    ports:</div><div class="line">      - &quot;80:80&quot;</div><div class="line">    networks:</div><div class="line">      - webnet</div><div class="line">  #可视化</div><div class="line">  visualizer:</div><div class="line">    image: dockersamples/visualizer:stable</div><div class="line">    ports:</div><div class="line">      - &quot;8080:8080&quot;</div><div class="line">    volumes:</div><div class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</div><div class="line">    deploy:</div><div class="line">      placement:</div><div class="line">        constraints: [node.role == manager]</div><div class="line">    networks:</div><div class="line">      - webnet</div><div class="line">networks:</div><div class="line">  webnet:</div></pre></td></tr></table></figure><p>新增的东西使web对等服务，称为visualizer。注意两个事：</p><ul><li>volumes: 给予visualizer访问主机Docker的socket文件</li><li>placement： 确保服务运行在manager而不是worker上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">docker stack deploy -c ./docker-compose2.yml stack-test</div><div class="line"></div><div class="line">Creating network stack-test_webnet</div><div class="line">Creating service stack-test_visualizer</div><div class="line">Creating service stack-test_web</div><div class="line"></div><div class="line"></div><div class="line">#查看visualizer，要等一会才能正常访问，别着急</div><div class="line">访问 IP:8080</div></pre></td></tr></table></figure><p><img src="/images/Docker/visualizer.png" alt=""></p><p><br></p><h3 id="持久化数据"><a href="#持久化数据" class="headerlink" title="持久化数据"></a>持久化数据</h3><p>让我们再次通过相同的工作流程来添加用于存储应用程序数据的Redis数据库。</p><p>docker-compose3.yml，添加一个Redis服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line">services:</div><div class="line">  web:</div><div class="line">    # replace username/repo:tag with your name and image details</div><div class="line">    image: username/repo:tag</div><div class="line">    deploy:</div><div class="line">      replicas: 5</div><div class="line">      restart_policy:</div><div class="line">        condition: on-failure</div><div class="line">      resources:</div><div class="line">        limits:</div><div class="line">          cpus: &quot;0.1&quot;</div><div class="line">          memory: 50M</div><div class="line">    ports:</div><div class="line">      - &quot;80:80&quot;</div><div class="line">    networks:</div><div class="line">      - webnet</div><div class="line">  visualizer:</div><div class="line">    image: dockersamples/visualizer:stable</div><div class="line">    ports:</div><div class="line">      - &quot;8080:8080&quot;</div><div class="line">    volumes:</div><div class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</div><div class="line">    deploy:</div><div class="line">      placement:</div><div class="line">        constraints: [node.role == manager]</div><div class="line">    networks:</div><div class="line">      - webnet</div><div class="line">  redis:</div><div class="line">    image: redis</div><div class="line">    ports:</div><div class="line">      - &quot;6379:6379&quot;</div><div class="line">    volumes:</div><div class="line">      - &quot;/home/docker/data:/data&quot;</div><div class="line">    deploy:</div><div class="line">      placement:</div><div class="line">        constraints: [node.role == manager]</div><div class="line">    command: redis-server --appendonly yes</div><div class="line">    networks:</div><div class="line">      - webnet</div><div class="line">networks:</div><div class="line">  webnet:</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#部署</div><div class="line">docker stack deploy -c docker-compose3.yml redis-test</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#测试</div><div class="line">访问 IP:port</div></pre></td></tr></table></figure><p>Redis是一个Docker library中的官方image，并被授予redis镜像名称。</p><p>redis规范中有几件事使数据在这个堆栈的部署之间持续存在：</p><ul><li>redis运行在manager，所以它总是使用相同的文件系统</li><li>redis将数据存储在上面的目录</li><li>确保redis服务始终使用相同的主机</li><li>确保存储的数据的连续性</li></ul><p>如果没有创建，redis会将数据存储在容器文件系统的/data中，如果该容器被重新部署，则数据将被清除。</p><p><br><br><br></p><h2 id="部署APP"><a href="#部署APP" class="headerlink" title="部署APP"></a>部署APP</h2><p>先决条件为前面的操作步骤。</p><p><br></p><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>compose file在生产环境中的效果与在您的计算机上的效果相同。</p><p><br></p><h3 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a>选择版本</h3><p>我安装的是社区版(ce)。如果你在生产环境中使用docker-ce，则可以使用Docker Cloud帮助管理你的应用程序，如AWS、Aliyun、腾讯云。<br>docker云： <cloud.docker.com>，可注册后建立、上传、管理自己的repo。</cloud.docker.com></p><p>设置和部署：</p><ul><li>连接Docker Cloud并授权它自动为你配置Dockerize VM</li><li>使用Docker Cloud创建你的计算资源和swarm</li><li>部署应用程序</li></ul><p><br></p><h3 id="连接DockerCloud"><a href="#连接DockerCloud" class="headerlink" title="连接DockerCloud"></a>连接DockerCloud</h3><p>你可以标准模式或swarm模式运行Docker Cloud。</p><ul><li>AWS配置指南</li><li>Aliyun配置指南</li><li>腾讯云配置指南</li></ul><p><br></p><h3 id="创建swarm"><a href="#创建swarm" class="headerlink" title="创建swarm"></a>创建swarm</h3><p>你可在Docker Cloud UI创建你的node，或<code>docker swarm init|join</code>命令。</p><p><br></p><h3 id="在云提供商上部署应用程序"><a href="#在云提供商上部署应用程序" class="headerlink" title="在云提供商上部署应用程序"></a>在云提供商上部署应用程序</h3><p><img src="/images/Docker/dockercloud.png" alt="栗子"></p><p>我觉得阿里云和腾讯云也有对应的平台。</p><p>运行部署命令: <code>docker stack deploy -c xxx.yml &lt;cus_appname&gt;</code>，现在你的APP就运行在云提供商上。</p><p><strong>运行swarm命令来验证部署</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker node ls</div><div class="line"></div><div class="line">docker service ls</div><div class="line"></div><div class="line">docker service ps &lt;service&gt;</div></pre></td></tr></table></figure><p><strong>在云提供商开放端口</strong></p><table><thead><tr><th>service</th><th>type</th><th>protocol</th><th>port</th></tr></thead><tbody><tr><td>web</td><td>http</td><td>tcp</td><td>80</td></tr><tr><td>visualizer</td><td>http</td><td>tcp</td><td>8080</td></tr><tr><td>redis</td><td>tcp</td><td>tcp</td><td>6379</td></tr></tbody></table><p>具体操作参见各云提供商。</p><p><br></p><h3 id="迭代和清理"><a href="#迭代和清理" class="headerlink" title="迭代和清理"></a>迭代和清理</h3><ul><li>改变<code>*.yml</code>文件伸缩应用程序</li><li>使用<code>docker stack deploy</code>部署应用程序</li><li>push和pull image</li><li>使用<code>docker stack rm &lt;name&gt;</code>清除stack</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="Dockerfile详解"><a href="#Dockerfile详解" class="headerlink" title="Dockerfile详解"></a>Dockerfile详解</h1><p>参考:</p><ul><li><a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a></li></ul><p><br></p><p>将镜像每一层的修改、安装、配置、操作的命令写入Dockerfile，并用它来构建、定制镜像，那么镜像构建透明性问题便会得到解决。</p><p>Dockerfile是一个文本文件，包含了一条条指令(instrction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p><br><br><br></p><h2 id="使用Dockerfile定制镜像"><a href="#使用Dockerfile定制镜像" class="headerlink" title="使用Dockerfile定制镜像"></a>使用Dockerfile定制镜像</h2><p>在一个Dockerfile里不能有多个基础镜像。即不能使用如下方式构建<code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FROM image1</div><div class="line">FROM image2</div><div class="line"></div><div class="line"></div><div class="line">#只能使用一个FROM</div></pre></td></tr></table></figure><p><br></p><h3 id="FROM指定基础镜像"><a href="#FROM指定基础镜像" class="headerlink" title="FROM指定基础镜像"></a>FROM指定基础镜像</h3><p>所谓定制镜像，就是以一个镜像为基础，在其上进行定制。基础镜像必须指定，而<code>FROM</code>就是指定<strong>基础镜像</strong>，因此一个<code>Dockerfile</code>中<code>FROM</code>是必备的指令，并且必须是第一条指令。</p><p>Docker Hub中有很多常用的官方镜像——常用软件、常用语言和常用系统镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FROM nginx</div><div class="line"></div><div class="line"></div><div class="line">#特殊镜像，scratch，空白镜像</div><div class="line">FROM scratch</div></pre></td></tr></table></figure><p><br></p><h3 id="RUN执行命令"><a href="#RUN执行命令" class="headerlink" title="RUN执行命令"></a>RUN执行命令</h3><p><code>RUN</code>指令是用来执行命令行命令的。有两种格式：</p><ul><li><code>shell</code>格式<ul><li><code>RUN &lt;CMD&gt;</code>，就像直接在命令行中输入命令一样</li></ul></li><li><code>exec</code>格式<ul><li><code>RUN [&quot;可执行文件&quot;, &quot;参数&quot;]</code>，这更像函数调用中的格式</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line"></div><div class="line">RUN apt-get update</div><div class="line">RUN apt-get install -y gcc libc6-dev make</div><div class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</div><div class="line">RUN mkdir -p /usr/src/redis</div><div class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</div><div class="line">RUN make -C /usr/src/redis</div><div class="line">RUN make -C /usr/src/redis install</div></pre></td></tr></table></figure><p>Dockerfile中的每一个指令都会建立一层，<code>RUN</code>也不例外。每一个<code>RUN</code>的行为，就和手工建立镜像的过程一样 —— 新建立一层，在其上执行这些命令，执行结束后，<code>commit</code>这一层的修改，构成新的镜像。</p><p>上面这种写法，创建了7层镜像，这是完全没有意义的，而且很多运行时不需要的东西都被装进了镜像里，比如编译环境和更新的软件包等。结果就会产生非常臃肿、非常多层的镜像，不仅增加了构建部署的时间，也容易出错。这是很多初学Docker的人常犯的一个错误。</p><p>UnionFS是Linux、FreeBSD的文件系统服务，UnionFS是有最大层数限制的。</p><p>修改后的Dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">FROM debian:jessie</div><div class="line"></div><div class="line">RUN buildDeps=&apos;gcc libc6-dev make&apos; \</div><div class="line">    &amp;&amp; apt-get update \</div><div class="line">    &amp;&amp; apt-get install -y $buildDeps \</div><div class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \</div><div class="line">    &amp;&amp; mkdir -p /usr/src/redis \</div><div class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</div><div class="line">    &amp;&amp; make -C /usr/src/redis \</div><div class="line">    &amp;&amp; make -C /usr/src/redis install \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</div><div class="line">    &amp;&amp; rm redis.tar.gz \</div><div class="line">    &amp;&amp; rm -r /usr/src/redis \</div><div class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</div></pre></td></tr></table></figure><p>仅仅使用一个<code>RUN</code>指令，并使用<code>&amp;&amp;</code>将各指令串联起来。将之前的7层简化为1层。在编写<code>Dockerfile</code>时，要经常提醒自己，这并不是在写shell脚本，而是在定义每一层该如何构建。</p><p><code>Dockerfile</code>支持shell类的换行<code>\</code>、注释<code>#</code>等格式，良好的格式，如换行、缩进、注释等，会让维护、排障更为容易，这也是一个好习惯。</p><p>此外，还可看到命令最后添加了清理工作的命令，删除了为编译构建所需要的软件，清理了所有下载文件。这很重要，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随镜像。<br>因此，构建镜像时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。<br>很多人初学docker制作出了很臃肿的镜像，原因之一就是顽疾了每一层构建的最后一定要清理无关文件。</p><p><br></p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在<code>Dockerfile</code>目录下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#docker build [OPTIONS] PATH | URL | - [flags]</div><div class="line">#Build an image from a Dockerfile</div><div class="line"></div><div class="line"></div><div class="line">#-t指定镜像名称</div><div class="line">#.指的是上下文目录</div><div class="line">docker build -t nginx:test .</div></pre></td></tr></table></figure><p><br></p><p><strong>构建上下文(content)</strong></p><p>上面的<code>.</code>是在指定<strong>上下文路径</strong>。</p><p>当我们在进行镜像构建的时候，并非所有的定制都会通过<code>RUN</code>指令完成，经常会需要一些本地文件复制进镜像，比如通过<code>COPY</code>, <code>ADD</code>指令。而<code>docker build</code>命令并非是在本地构建镜像，而是在服务端，也就是Docker引擎<code>dockerd</code>中构建的。那么在这种C/S架构中，如何才能让服务端获得本地文件呢？</p><p>这就引进了上下文的概念。当构建的时候，用户会指定构建镜像的上下文的路径，<code>docker build</code>命令得知这个路径后，会将路径下的所有内容打包，然后上传给Docker引擎。这样Docker引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#复制上下文目录下的package.json</div><div class="line">COPY ./package.json /app/</div></pre></td></tr></table></figure><p>因此<code>COPY</code>这类指令中的源文件的路径都是相对路径，因为绝对路径已经超出了上下文的范围，Docker引擎无法获取这些位置的文件。如果真需要这些文件，请将它们复制到上下文目录中去。</p><p>理解构建上下文对于镜像构建很重要，避免犯一些不应该的错误。</p><p>一般来说，应将<code>Dockerfile</code>置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，则应该把所需文件复制一份过来。如果目录下有些东西不希望构建时传给Docker引擎，可以写一个<code>.dockerignore</code>文件，用于剔除不需要作为上下文传递给Docker引擎的。</p><p>实际上，<code>Dockerfile</code>的文件名并不要求必须为<code>Dockerfile</code>，也并不要求必须位于上下文目录中。可使用<code>-f</code>指定某个文件为<code>Dockerfile</code>。</p><p><br></p><p><strong>其它<code>docker build</code>的用法</strong></p><ol><li>直接使用Git repo进行构建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#docker build URL</div><div class="line"></div><div class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14</div><div class="line">#docker会自己去clone、切换分支、并进入指定目录开始构建</div></pre></td></tr></table></figure><p><br></p><ol><li>使用给定tar压缩包构建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker build http://server/context.tar.gz</div><div class="line"></div><div class="line">#自动下载/解压缩 压缩包，以其作为上下文，开始构建</div></pre></td></tr></table></figure><p><br></p><ol><li>从标准输入中读取Dockerfile进行构建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">docker build - &lt; Dockerfile</div><div class="line"></div><div class="line"></div><div class="line">cat Dockerfile | docker build -</div><div class="line"></div><div class="line"></div><div class="line">docker build - &lt; context.tar.gz</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><p><code>Dockerfile</code>提供了十多个指令供我们操作。</p><p><br></p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p><code>COPY</code>,复制文件。<br>从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置。</p><blockquote><p>源路径可以是多个，或通配符(需满足Go的规则)<br>目标路径可是容器内的绝对路径，也可是相对于工作目录(<code>WORKDIR</code>)的相对路径。目标路径不需要事先创建。<br>使用COPY指令，源文件的各种元数据都会保留 —— 如读、写、执行权限、文件变更时间…</p></blockquote><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">COPY  &lt;sourch&gt;  &lt;destination&gt;</div><div class="line"></div><div class="line">#或</div><div class="line">COPY  [&quot;&lt;source1&gt;&quot;, ... &quot;&lt;destination&gt;&quot;]</div><div class="line"></div><div class="line"></div><div class="line">#栗子</div><div class="line">COPY package.json /usr/src/app/</div><div class="line">COPY hom* /mydir/</div><div class="line">COPY hom?.txt /mydir/</div></pre></td></tr></table></figure><p><br></p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p><code>ADD</code>,更高级的复制文件。<br><code>ADD</code>和<code>COPY</code>的格式和性质基本一致，但增加了一些功能。<br>尽可能的使用<code>COPY</code>，因为<code>COPY</code>的语义很明确，就是复制文件而已，而<code>ADD</code>则包含了更复杂的功能，其行为也不一定很清晰。<br>最适合<code>ADD</code>的场合，就是所提及的需要自动解压缩的场合。</p><p>因此在<code>COPY</code>和<code>ADD</code>指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用<code>COPY</code>指令，仅在需要自动解压缩的场合使用<code>ADD</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FROM scratch</div><div class="line"></div><div class="line">ADD abc.tar.gz /</div></pre></td></tr></table></figure><p><br></p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>CMD</code>，容器启动命令。</p><p>也有两个格式：</p><ul><li><code>shell</code>格式： <code>CMD &lt;command&gt;</code></li></ul><p><code>shell</code>格式，在实际中会被包装成<code>sh -c</code>的参数形式进行执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CMD echo $HOME</div><div class="line"></div><div class="line">#转变为</div><div class="line">CMD[&quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot;]</div><div class="line"></div><div class="line">#-c string If  the  -c option is present, then commands are read from string.</div><div class="line"></div><div class="line"></div><div class="line">#这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理</div></pre></td></tr></table></figure><p><br></p><ul><li><code>exec</code>格式： <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot; ...]</code></li></ul><p>Docker不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code>指令就是用于指定默认的容器主进程的启动命令的。<br>``</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p><p><br></p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p><code>ENTRYPOINT</code>，入口点。指令格式同样分为<code>shell</code>格式和<code>exec</code>两种。</p><p><code>ENTRYPOINT</code>和<code>CMD</code>一样，都是在指定容器启动程序及参数。<br>当指定了<code>ENTRYPOINT</code>后，<code>CMD</code>的含义就发生了改变，不再是直接的运行其命令，而是将<code>CMD</code>的内容作为参数传给<code>ENTRYPOINT</code>指令。即变为如下模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</div></pre></td></tr></table></figure><p><br></p><p>有几大好处：</p><ul><li><strong>让镜像变成像命令一样使用</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#可以从腾讯上拉取，快一些</div><div class="line">#ccr.ccs.tencentyun.com/qcloud/ubuntu</div><div class="line"></div><div class="line">FROM ubuntu:16.04</div><div class="line">RUN apt-get update \</div><div class="line">    &amp;&amp; apt-get install -y curl \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</div><div class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ]</div><div class="line"></div><div class="line"></div><div class="line">docker build -t myip</div><div class="line">docker run myip</div><div class="line">#当前 IP：182.150.x.xx 来自：四川省成都市 电信</div></pre></td></tr></table></figure><p>不过命令总有参数，例如我想查看HTTP header，使用<code>-i</code>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">docker run myip -i</div><div class="line">#这样会报错，-i替换了CMD命令，而不是-s参数，然而-i并不是命令</div><div class="line"></div><div class="line"></div><div class="line">#重新完整输入命令</div><div class="line">docker run myip curl -s http://ip.cn -i</div><div class="line">#这样又太麻烦</div></pre></td></tr></table></figure><p>这时便可以使用<code>ENTRYPOINT</code>解决这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">FROM ubuntu:16.04</div><div class="line">RUN apt-get update \</div><div class="line">    &amp;&amp; apt-get install -y curl \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</div><div class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ]</div><div class="line"></div><div class="line"></div><div class="line">docker build it myip</div><div class="line">docker run myip</div><div class="line">#当前 IP：182.150.x.xx 来自：四川省成都市 电信</div><div class="line"></div><div class="line"></div><div class="line">docker run myip -i</div><div class="line">#成功</div></pre></td></tr></table></figure><p>当存在<code>ENTRYPOINT</code>后，<code>CMD</code>的内容将作为参数传递给<code>ENTRYPOINT</code>，而<code>-i</code>就是新的<code>CMD</code>，因此会作为参数传递给<code>curl</code>，从而达到预期效果。</p><p><br></p><ul><li><strong>应用运行前的准备工作</strong></li></ul><p>有时，在启动前需要做一些准备工作。</p><ul><li>如MySQL，需要一些配置文件、初始化工作，这些工作需要在MySQL server运行前解决</li><li>避免使用root用户去启动服务，从而提高安全性</li><li>这些准备工作和<code>CMD</code>无关</li></ul><p><br></p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p><code>ENV</code>，设置环境变量<br>这个指令很简单，就是设置环境变量而已。</p><p>两种格式：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ENV PATH $PATH:/root/bin \</div><div class="line">EMAIL abc@zhang21.cn \</div><div class="line">NAME=&quot;Zhang21&quot;</div></pre></td></tr></table></figure><p>下列指令可以支持环境变量展开： <code>ADD</code>, <code>COPY</code>, <code>ENV</code>, <code>EXPOSE</code>, <code>LABEL</code>, <code>USER</code>, <code>WORKDIR</code>, <code>VOLUME</code>, <code>STOPGIGNAL</code>, <code>ONBUILD</code>。</p><p>通过环境变量，我们可以让一份<code>Dockerfile</code>制作更多的镜像，只需使用不同的环境变量即可。</p><p><br></p><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p><code>ARG</code>，构建参数</p><p>格式：</p><ul><li><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></li></ul><p><br></p><p>构建参数和<code>ENV</code>的效果一样，都是设置环境变量。所不同的是，<code>ARG</code>所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。</p><p><br></p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><code>VOLUME</code>，定义匿名卷</p><p>格式：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p><br></p><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。<br>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在<code>Dockerfile</code>中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会像容器存储层写入大量数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#在运行时自动挂载为匿名卷</div><div class="line">VOLUME /data</div><div class="line"></div><div class="line"></div><div class="line">#覆盖挂载</div><div class="line">docker run -d -v mydata:/data xxx</div></pre></td></tr></table></figure><p><br></p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><code>EXPOSE</code>，声明端口</p><p>格式：</p><ul><li><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></li></ul><p><code>EXPOSE</code>指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。<br>在<code>Dockerfile</code>中写入这个声明有两个好处：</p><ul><li>一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便映射</li><li>另一个用处则是在运行时使用随机端口映射(未定义时)</li></ul><p>要将<code>EXPOSE</code>和在运行时使用<code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code>区分开。<code>EXPOSE</code>仅仅声明容器打算使用哪些端口，并未包含端口映射。</p><p><br></p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p><code>WORKDIR</code>，指定工作目录<br>使用<code>WORKDIR</code>指令可以来指定工作目录，以后各层的当前目录就被改为指定的目录，如目录不存在，<code>WORKDIR</code>会帮你建立目录。<br>如果需要改变<code>Dockerfile</code>各层的工作目录的位置，那么应该使用<code>WORKDIR</code>指令。</p><p>格式：</p><ul><li><code>WORKDIR &lt;工作目录&gt;</code></li></ul><p><br></p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p><code>USER</code>，指定当前用户<br><code>USER</code>和<code>WORKDIR</code>相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code>是改变工作目录，<code>USER</code>则是改变之后的层执行<code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>这类命令的身份。这个用户必须存在。</p><p>格式：</p><ul><li><code>USER &lt;用户名&gt;</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">USER redis</div><div class="line">RUN [&quot;redis-server&quot;]</div></pre></td></tr></table></figure><p><br></p><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p><code>HEALTHCHECK</code>，健康检查<br><code>HEALTHCHECK</code>指令告诉docker应该如何进行判断容器的状态是否正常。</p><p>格式：</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>， 设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>， 如果基础镜像有健康检查，使用这行可以屏蔽其健康检查指令</li></ul><p>当在一个镜像指定了<code>HEALTHCHECK</code>指令后，用其启动容器，初始状态会为<code>starting</code>，在<code>HEALTHCHECK</code>指令检查成功后变为<code>healthy</code>，如果连续一定次数失败，则会变为<code>unhealthy</code>。<br>和<code>CMD</code>, <code>ENTRYPOINT</code>一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p><p><br></p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p><code>ONBUILD</code>，为他人做嫁衣<br><code>ONBUILD</code>是一个特殊的指令，它后面跟的是其它指令。而这些指令，在当前镜像构建时不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。<br><code>Dockerfile</code>中的其它指令都是为了定制当前镜像而准备的，唯有<code>ONBUILD</code>是为了帮助别人定制自己而准备的。</p><p>格式：</p><ul><li><code>ONBUILD &lt;其它指令&gt;</code></li></ul><p><br><br><br></p><h2 id="Dockerfile多阶段构建"><a href="#Dockerfile多阶段构建" class="headerlink" title="Dockerfile多阶段构建"></a>Dockerfile多阶段构建</h2><p><strong>全部放入一个Dockerfile</strong></p><p>将所有的构建过程包含在一个<code>Dockerfile</code>中，包括项目及其依赖库的编译、测试、打包等流程。<br>这可能会带来一些问题：</p><ul><li><code>Dockerfile</code>特别长，可维护性降低</li><li>镜像层次多，镜像体积较大，部署时间变长</li><li>源代码存在泄漏的风险</li></ul><p><br></p><p><strong>分散到多个Dockerfile</strong></p><p>事先在一个<code>Dockerfile</code>将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中。这种方式需要编写两个<code>Dockerfile</code>和一些编译脚本才能将两个阶段自动整合起来。这种方式虽然可以很好避免全部写入一个Dockerfile的风险，但明显部署过程较复杂。</p><p><br></p><p><strong>多阶段构建</strong></p><p>使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个<code>Dockerfile</code>。</p><p><br><br><br></p><h2 id="Dockerfile最佳实践"><a href="#Dockerfile最佳实践" class="headerlink" title="Dockerfile最佳实践"></a>Dockerfile最佳实践</h2><ul><li>一般性建议<ul><li>容器应该是短暂的</li><li>使用<code>.dockerignore</code>文件</li><li>使用多阶段构建减少镜像大小</li><li>避免安装不必要的包</li><li>一个镜像只运行一个进程</li><li>镜像层数尽可能少</li><li>将多行参数排序</li><li>构建缓存</li></ul></li><li>Dockerfile指令<ul><li><code>FROM</code></li><li><code>LABEL</code></li><li><code>RUN</code></li><li><code>CMD</code></li><li><code>EXPOSE</code></li><li><code>ENV</code></li><li><code>ADD</code></li><li><code>COPY</code></li><li><code>ENTRYPOINT</code></li><li><code>VOLUME</code></li><li><code>USER</code></li><li><code>WORKDIR</code></li></ul></li></ul><p><br><br><br></p><hr><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker官方文档 &lt;a href=&quot;https://docs.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7. x86_64&lt;/li&gt;
&lt;li&gt;Docker v18.03&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://zhang21.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>《网站运维》读书笔记</title>
    <link href="https://zhang21.github.io/2018/03/05/%E7%BD%91%E7%AB%99%E8%BF%90%E7%BB%B4/"/>
    <id>https://zhang21.github.io/2018/03/05/网站运维/</id>
    <published>2018-03-05T14:34:49.000Z</published>
    <updated>2018-03-25T03:53:52.761Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>《网站运维：保持数据实时的秘籍》(Web Operations: Keeping the Data on Time)</li></ul><p><br><br><br></p><a id="more"></a><p><br></p><h1 id="作为职业的运维"><a href="#作为职业的运维" class="headerlink" title="作为职业的运维"></a>作为职业的运维</h1><p>互联网变化如此之快，以至于几乎没有时间认真思考一下我们在做什么，以及为什么做。我们奋力拼搏，才避免被淘汰出局，哪里还敢谈论什么引领潮流呢！这种高压、过度刺激的环境使得所有努力都只是为了一份工作，而没有职业的概念了。</p><p>职业是指占去你人生大部分时光的事业，并能够逐步晋升。工作只是拿钱干活儿，换句话说，工作就只是工作而已。</p><p><br></p><h2 id="为什么运维如此艰难"><a href="#为什么运维如此艰难" class="headerlink" title="为什么运维如此艰难"></a>为什么运维如此艰难</h2><p>运维对如下领域都有深入的理解：<strong>网络、路由、交换、防火墙、负载均衡、高可用性、灾难恢复、TCP与UDP服务、网络运维中心管理、硬件规范、各种Unix、各种Web服务器技术、高速缓存技术、数据库技术、存储基础架构、密码学、算法、趋势分析、容量规划…</strong></p><p>运维要求广博，可以说几乎是不可接受的。</p><p>运维领域成为一个合格的人选，需要具备三点素质：<strong>扎实的计算背景、娴熟的决断力、沉稳的性格</strong>。</p><p><br></p><h3 id="扎实的计算背景"><a href="#扎实的计算背景" class="headerlink" title="扎实的计算背景"></a>扎实的计算背景</h3><p>运维要求理解架构中的各个组成部分，在理解计算系统的来龙去脉时，扎实的计算背景对你会有莫大的帮助。具有扎实的基础，对于理解为什么及如何架构解决方案，以及识别出问题所在，是非常重要的。毕竟，计算是架构我们的智能系统的基础。此外，工程师的思维方式和对物理定律的基本理解，也是一个很大的优势。</p><p>运维会经常遇到随意的、不切实际的期望。<br>运维，就是理解理论和实践在哪里发生冲突，并发明适当的方法，以便在发生事故时减少损失。</p><p><br></p><h3 id="娴熟的决断力"><a href="#娴熟的决断力" class="headerlink" title="娴熟的决断力"></a>娴熟的决断力</h3><p>虽然优柔寡断在任何领域都不算是一个优点，但在运维中却几乎不能容忍。</p><p><br></p><h3 id="沉稳的性格"><a href="#沉稳的性格" class="headerlink" title="沉稳的性格"></a>沉稳的性格</h3><p>一个沉稳与可控的思维过程是非常关键的，需要保持自己是清醒的一方。</p><p>在运维领域，目标很简单，使所有事情在所有时间正常运转。一个简单的定义，但却是一个不可能的期望。或许在这个领域成为一名工程师的更大挑战是组织内的同事对你的不切实际的期望。</p><p><br><br><br></p><h2 id="从学徒到师傅"><a href="#从学徒到师傅" class="headerlink" title="从学徒到师傅"></a>从学徒到师傅</h2><p>掌握任何知识领域都需要四项基本要求：<strong>知识、工具、经验和纪律</strong>。</p><p><br></p><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p>互联网行业的一个独特之处就是几乎所有的东西都是公开的，事实上，有专有权的东西也是极少的，而更为独特的是，几乎所有规范文档都是免费的。</p><p>在你走在从从学徒到师傅的路途中，尽可能多滴占有信息是你的职责，这样你的大脑才能将那些细微之处进行排序、过滤、关联，使其成为一幅简明、精确的图画，从而有助于你的决策——不管是长期的架构设计的关键决策，还是临时的排除故障的决策。</p><p><br></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>虽然工具各有优缺点，然而人们使用这些工具都取得了成功。制造和使用工具使我们人类的本性。<br>所有的工具归根结底都只是人类肢体和感觉器官的延长。</p><p>师傅不适用工具炼成的。在互联网应用的环境中，你会看得更清楚，五花八门的语言、平台、技术都能够成功地结合在一起，将这些成功地构建为一个架构的，不是Java或PHP，而是设计与实现它的工程师——那些师傅们。</p><p>工具上的一个真理是，不管在用的工具是什么，要了解你的工具，这是在这个行业登堂入室的前提。灵巧地运用工具的能力，比工具本身的质量要重要的多。话虽如此，有经验的工程师还是应该手边备一件合适的高质量的工具。</p><p><br></p><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><p>从最本质的意义上来说，经验意味着良好的判断力，而良好的判断力却是从很多失败中取得的。</p><p>经验与知识是紧密相关的，知识可以认为是他人经验的总结。<br>经验既是一个名词，也是一个动词。获得经验与应用经验，同样容易也同样困难。</p><p>一名资深工程师最大的特点是其一致与可靠的良好判断力。很显然，这要在需要做出判断的场合经受锻炼。</p><p>对进入运维这个领域而没有什么经验的工程师，我的忠告是：<strong>耐心</strong>。</p><p><br></p><h3 id="纪律"><a href="#纪律" class="headerlink" title="纪律"></a>纪律</h3><p>通过尽可能正确而高效地做事，从而为解决同样问题，而尽可能地少做工作。</p><p><br><br><br></p><hr><p><br></p><h1 id="如何应用云计算-Elastic-Compute"><a href="#如何应用云计算-Elastic-Compute" class="headerlink" title="如何应用云计算(Elastic Compute)"></a>如何应用云计算(Elastic Compute)</h1><p>云服务器(ECS, Elastic Compute Service)</p><p><br></p><h2 id="什么地方适合云计算"><a href="#什么地方适合云计算" class="headerlink" title="什么地方适合云计算"></a>什么地方适合云计算</h2><p>灵活性和一定程度上的自由是云服务器的特点，当然，本地服务器同样有这个特点。</p><p><br></p><h3 id="混合计算"><a href="#混合计算" class="headerlink" title="混合计算"></a>混合计算</h3><p>混合计算=云计算+本地计算</p><p><br></p><h2 id="什么地方不适合云计算"><a href="#什么地方不适合云计算" class="headerlink" title="什么地方不适合云计算"></a>什么地方不适合云计算</h2><p>当然，最先考虑的肯定是经济层面。</p><p>服务层与数据库是紧密耦合的，所以使它们之间的网络延迟最小化是很重要的。这意味着它们要么全在云里，要么全在云外。</p><p><br></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>尽管有大量广告吹嘘完整托管在云里，但从运维角度来说，混合应用架构模式或许是最有趣的。有些事情在云里做的不一定好。脚踏两只船，你才会游刃有余。</p><p>混合应用还强调一点，就是传统运维中的最佳时间仍然是成功的公司的云应用所必须的。</p><p><br><br><br></p><hr><p><br></p><h1 id="基础架构与应用程序测量"><a href="#基础架构与应用程序测量" class="headerlink" title="基础架构与应用程序测量"></a>基础架构与应用程序测量</h1><p>任何规模的运维，采集测量数据就像将服务器连接到网络上一样重要，对于一个规模不断增长的基础架构来说，或许更加重要。</p><p>我们不光讨论你要采集并监视的测量数据的种类，还要讨论为了应对各种情况，你能利用这些数据做些什么。</p><p>测量数据的采集和带有报警(alerting)功能的监控有明显的区别。</p><p><br><br><br></p><h2 id="时间刷新率和存留时间的考虑"><a href="#时间刷新率和存留时间的考虑" class="headerlink" title="时间刷新率和存留时间的考虑"></a>时间刷新率和存留时间的考虑</h2><p>随着采集的数据不断增长，确保这些数据能够一直可查询和移动，这是很明智的。</p><p>如Zabbix中——获取数据的时间刷新率和数据保存时间。历史数据保留时长和趋势数据存储时间。<br>比如有的数据要30s获取一次，而有的信息只需要1h获取一次。</p><p>测量数据真正出彩的地方：</p><ul><li>对于某个特定的资源，每天的峰值是哪些？每周的峰值日是哪些？每年的峰值月是哪些？</li><li>有季节性模式吗？<ul><li>如夏时日和节假日会高一些</li></ul></li><li>最大(波峰)值与最小(波谷)值比较起来怎么样？</li><li>在用户分布广泛的情况下，波峰与波谷是否发生变化？</li></ul><p><br><br><br></p><h2 id="测量数据采集与存储的地点"><a href="#测量数据采集与存储的地点" class="headerlink" title="测量数据采集与存储的地点"></a>测量数据采集与存储的地点</h2><p>无论使用什么采集工具，易于采集和便于得出结果都是必须要考虑的。</p><p><br><br><br></p><h2 id="测量数据的层次"><a href="#测量数据的层次" class="headerlink" title="测量数据的层次"></a>测量数据的层次</h2><p>不同层次的数据存储在不同的数据库中。</p><p><br></p><h3 id="高层业务或功能特定的测量数据"><a href="#高层业务或功能特定的测量数据" class="headerlink" title="高层业务或功能特定的测量数据"></a>高层业务或功能特定的测量数据</h3><p>有了这些高层数据之后，面向产品的那些人对这些数据也抱有极大的兴趣，你一点都不用感到惊讶。</p><p>对于应用层面的数据，最有用的是能够跟踪用户的交互情况。</p><p><br></p><h3 id="系统及服务层面的测量数据"><a href="#系统及服务层面的测量数据" class="headerlink" title="系统及服务层面的测量数据"></a>系统及服务层面的测量数据</h3><p>这些是在运维工程师电脑上以图形方式显示的数据。</p><p><br></p><p>测量数据的层次：</p><table><thead><tr><th>-</th><th>例子</th><th>测量项目</th></tr></thead><tbody><tr><td>应用层</td><td>网页或API</td><td>故障：类型、延迟、发生率…</td></tr><tr><td>服务层</td><td>Nginx, MySQL, MongoDB…</td><td>Nginx: 请求频率、响应时间、忙碌的工作进程… <br> MySQL/MongoDB：导致故障的查询类型、慢查询、连接数…</td></tr><tr><td>物理层</td><td>CPU、内存、网络、硬盘</td><td>内存：繁忙程度 <br> 内存：空闲内存 <br> 硬盘：可用空间，I/O速率 <br> 网络：网络I/O带宽情况</td></tr></tbody></table><p>有了这些数据，就能够回答如下问题：</p><ul><li>平均的Web请求时间</li><li>CPU时间</li><li>调用最多的数据库查询</li><li>数据库慢查询</li><li>文件系统缓存</li><li>最大的页面响应</li><li>…</li></ul><p><br><br><br></p><h2 id="为异常检测和报警提供环境"><a href="#为异常检测和报警提供环境" class="headerlink" title="为异常检测和报警提供环境"></a>为异常检测和报警提供环境</h2><p>在本地采集的测量数据的主要理由，就像油表一样，有了这些数据，就可以明白基础架构正在发生什么，以及正在驶向何方。<br>知道哪里的资源在增长或缩减，能够进行预测。使用预测对基础架构的容量需求进行预报，称为容量规划。<br>观察网站运行是否有异常时，测量数据就派上用场了。</p><p>发生异常是，测量数据回味报警提供相关信息。报警的信息要尽量简明，告知检测到了什么，以及何时检测到。而测量数据会告诉你报警都发生了什么。</p><p><br><br><br></p><h2 id="日志记录也是测量数据"><a href="#日志记录也是测量数据" class="headerlink" title="日志记录也是测量数据"></a>日志记录也是测量数据</h2><p>应用程序的日志文件也提供了测量数据和使用情况的信息。这些信息用于追踪过去发生的事件。</p><p><br><br><br></p><h2 id="将变化管理和事件的时间线建立关联"><a href="#将变化管理和事件的时间线建立关联" class="headerlink" title="将变化管理和事件的时间线建立关联"></a>将变化管理和事件的时间线建立关联</h2><p>更新生产系统会带来风险。<br>记录更新发生的时间，从而保留更新的踪迹，这在发生问题需要进行追踪时是非常有价值的。</p><p><br><br><br></p><h2 id="给测量数据加入报警机制"><a href="#给测量数据加入报警机制" class="headerlink" title="给测量数据加入报警机制"></a>给测量数据加入报警机制</h2><p>Zabbix、Nagios等就是一个测量数据采集系统配合使用的监控/报警工具。</p><p><br><br><br></p><h2 id="使用测量数据建立加载-反馈机制"><a href="#使用测量数据建立加载-反馈机制" class="headerlink" title="使用测量数据建立加载-反馈机制"></a>使用测量数据建立加载-反馈机制</h2><p>采集时序数据的另一个好处，就是能够通过编程使你的应用生成测量数据，从而可以建立安全、精密的反馈循环。</p><p><br><br><br></p><h2 id="结语-1"><a href="#结语-1" class="headerlink" title="结语"></a>结语</h2><p>测量数据的采集、存储、显示，可以认为是web基础架构的关键部分。不论是及时排查错误，预测容量、规划产品的发布，还是建立应用的反馈机制，如果没有正确的测量数据为你提供一个基础架构运行的全景图的话，你会损失惨重。</p><p>设计数据如何经过系统时，要考虑安全问题，而且数据要易于导出到其它应用。一旦运维部门采集了测量数据，你会发现，追踪数据是一件多么有趣的事情，同时也能使工作更加轻松。</p><p><br><br><br></p><hr><p><br></p><h1 id="连续部署"><a href="#连续部署" class="headerlink" title="连续部署"></a>连续部署</h1><p>软件应该以小批量的方式进行设计、编写和部署。</p><p>批量大小是产品在开发过程的各个阶段转移的单位。对于软件而言，最容易看到的批量是代码。每次工程师检入代码，都是在提交一定量的工作。有很多技术用来控制这些批量，从连续部署所需的最小批量到更为传统的分支开发，在分支开发中，多个开发者工作数周或数月产生的所有代码将被成批处理，并集中到一起。</p><p>结果证明，以远小于传统做法的建议的批量工作，有极大的好处。</p><p><br><br><br></p><h2 id="小批量意味着更快的反馈"><a href="#小批量意味着更快的反馈" class="headerlink" title="小批量意味着更快的反馈"></a>小批量意味着更快的反馈</h2><p>工作转移到下一阶段越快，则也就能越快地发现下一个阶段是如何接纳你的工作的。</p><p><br><br><br></p><h2 id="小批量意味着问题即刻被本地化"><a href="#小批量意味着问题即刻被本地化" class="headerlink" title="小批量意味着问题即刻被本地化"></a>小批量意味着问题即刻被本地化</h2><p>问题发现得越快，则解决的也越快。</p><p>每次部署，都只有少量代码有变化，所以导致回归或料想不到的性能问题的任何变化，都能够快速识别出来，并进行改正。当然，由于需要改正或回滚的变化数量不仅是确定的，也是很小的，所以解决问题的平均时间也就很低了。</p><p><br><br><br></p><h2 id="小批量能够减少风险"><a href="#小批量能够减少风险" class="headerlink" title="小批量能够减少风险"></a>小批量能够减少风险</h2><p><br><br><br></p><h2 id="小批量可以降低总开销"><a href="#小批量可以降低总开销" class="headerlink" title="小批量可以降低总开销"></a>小批量可以降低总开销</h2><p>大多数机构都会降低自己的批量大小，以降低总的开销。<br>大批量导致的瓶颈经常是隐含的，是这些隐含的瓶颈显现出来，是需要开销的，甚至要投入更多的工作才能修正这些瓶颈。</p><p>连续部署的目标，是在减小批量的同时，帮助开发团队清除开发过程中的垃圾，加快工作步伐。这样就能使各个团队处于持续的流动状态，这种状态使得团队的创新、试验变得非常容易，从而形成可持续发展的良性循环。</p><p><br><br><br></p><h2 id="质量卫士的挽歌"><a href="#质量卫士的挽歌" class="headerlink" title="质量卫士的挽歌"></a>质量卫士的挽歌</h2><p>产生开发过程中的垃圾的一个很大原因是重复检查。</p><p>连续集成，有助于加快缺陷反馈流程；故事卡和看板，用于降低批量大小；日站，有助于加快步伐；连续部署也是这样的技术，有能力是开发团队更有活力。</p><p><br></p><h3 id="为什么连续部署能行"><a href="#为什么连续部署能行" class="headerlink" title="为什么连续部署能行"></a>为什么连续部署能行</h3><p>连续部署区分了发布的两种不同的定义：</p><ul><li>一个是工程师使用的，指的是将代码完全集成到生产环境中的过程；</li><li>另一个是市场部门使用的，指的是客户看到的东西</li></ul><p>使用连续部署，代码一旦写完，就在去往生产环境的路上了。<br>连续部署也起着速度调节器的作用。</p><p>这种速度调节，对于习惯于通过个体效率来度量其进步的团队来说，是一种技巧性的调整。在这种团队中，每个工程师的头等大事就是保持忙碌。不幸的是，这种观点忽略了团队的整体生产能力。对于有些情形，大家坐下来讨论，找出协调方法，从而不需要做重复工作，这时候才是有效率的。</p><p><br><br><br></p><h2 id="让我们开始吧"><a href="#让我们开始吧" class="headerlink" title="让我们开始吧"></a>让我们开始吧</h2><h3 id="步骤1：连续集成服务器"><a href="#步骤1：连续集成服务器" class="headerlink" title="步骤1：连续集成服务器"></a>步骤1：连续集成服务器</h3><p>这是连续部署的脊梁。我们需要一个中心服务器，运行所有的自动化测试，并监控每一次的提交。</p><p><br></p><h3 id="步骤2：源代码控制提交检查"><a href="#步骤2：源代码控制提交检查" class="headerlink" title="步骤2：源代码控制提交检查"></a>步骤2：源代码控制提交检查</h3><p>下一个需要的基础框架是源代码控制服务器，并带有能进行提交检查的甲苯。如CVS、SVN、Git等。</p><p>作为一个团队，我们的目标是在能够可靠地生产高质量代码的前提下，尽可能快地工作，但不要过快。</p><p><br></p><h3 id="步骤3：简单的部署脚本"><a href="#步骤3：简单的部署脚本" class="headerlink" title="步骤3：简单的部署脚本"></a>步骤3：简单的部署脚本</h3><p>建立一个关键的部署脚本，用于逐台机器进行增量备份，与此同时，监控集群和业务的运行情况。这样一旦出现异常，就可以快速恢复。</p><p><br></p><h3 id="步骤4：实时报警"><a href="#步骤4：实时报警" class="headerlink" title="步骤4：实时报警"></a>步骤4：实时报警</h3><p>无论部署过程多么完美，缺陷仍然会通过部署而进入生产环境。需要一个监控平台，以便事情一旦偏离正常，能够进行提醒，并找到人来调试。</p><p><br></p><h3 id="步骤5：根本原因分析"><a href="#步骤5：根本原因分析" class="headerlink" title="步骤5：根本原因分析"></a>步骤5：根本原因分析</h3><p>无论问题多小，都要做些投资，而且各个级别都要做。<br>小的改进，经过经年累月，非常像复利。</p><p><br><br><br></p><h2 id="连续部署用于关键应用"><a href="#连续部署用于关键应用" class="headerlink" title="连续部署用于关键应用"></a>连续部署用于关键应用</h2><p>连续部署要求的第一个心态转移是：如果一个更新假设是无副作用的，马上发布。不要再等着与其它相关的更新捆绑在一起，否则，一旦发生副作用，就很难确定到底是哪个更新产生的。</p><p>第二个是心态转移是把市场发布的概念和工程发布的概念区分开。</p><p><br></p><ul><li>更快更好的反馈</li><li>更多的自动化</li><li>对真实环境测量数据的监控</li><li>更好地处理间歇性错误</li><li>更小的批量</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="作为代码的基础架构"><a href="#作为代码的基础架构" class="headerlink" title="作为代码的基础架构"></a>作为代码的基础架构</h1><p><strong>只需要源代码库、应用程序数据备份、硬件裸机就能够把整个业务重建起来。</strong></p><p>理想情况下，重组业务的最大制约是还原应用程序数据所需要的时间，应用程序数据是真正的业务价值所在。</p><p><br><br><br></p><h2 id="面向服务体系结构"><a href="#面向服务体系结构" class="headerlink" title="面向服务体系结构"></a>面向服务体系结构</h2><p>将系统的每个组件都分解为可通过网络访问的服务，这些服务集成在一起就构成了一个功能性应用程序。</p><p>通过将每个基本组件都呈现为服务、应用开发者可自由组装的新的应用，结果就是重用更为容易、封装更为清洁、错误排查更为简单。</p><ul><li><p>应该是模块化的</p><ul><li>做一件事，并且做好<br>在SOA中，每个服务都很小——只做一件事，并允许其它服务调用。每个服务都很简单，但应用程序员要做很多集成工作。每个服务都专注于自己的狭小领域，则管理、开发、测试都会很容易。<br>基础架构服务也是一样的，缩小每个服务的操作范围，就可以降低复杂性，从而他人也就易于理解其行为。</li></ul></li><li><p>应该是协作的</p><ul><li>让我们团结起来<br>在构建通过网络API呈现的基本服务时，要鼓励别人和你协作，而不是重复实现相同的功能。每个服务都要设计成与其它服务协作的，尽量少假设服务的使用方式。<br>服务的协作本性决定了用的人越多，则服务本身就越有用。对于基础架构服务而言，这种本性是至关重要的——随着基础架构的每个部分都成为可集成的服务，服务之间相互协作的方式会呈指数增长。</li></ul></li><li><p>应该是可组合的</p><ul><li>应该一切准备就绪<br>理想情况下，每个服务都应该通过易于访问的网络API呈现自己的配置和功能，实际情况是：大部分都没有。</li></ul></li></ul><p><br></p><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>配置管理是一种管理活动，从技术和管理两个方面作用于产品和生命周期、配置项，以及相关的产品配置信息。</p><p>配置管理是指对所有那些事情的跟踪，那些事情是把一个系统从<strong>裸机(baremetal)</strong>转变成<strong>做自己的事</strong>时必须要做的。系统管理员手工配置系统，并将笔记贴到wiki上时，他就是在实践着最基本的配置管理。软件开发者写了一个脚本来自动部署自己的应用程序，她就是在实践着自动化的配置管理。</p><p><br></p><h3 id="配置管理是策略驱动的"><a href="#配置管理是策略驱动的" class="headerlink" title="配置管理是策略驱动的"></a>配置管理是策略驱动的</h3><ol><li>把问题和解决方案的最终结果记入文档(设立策略)；</li><li>写出在策略中要执行的代码(执行策略)；</li><li>确认最终结果是正确的(审计策略)；</li><li>重复这个过程，确保以后呢能够可靠的执行(测试策略)</li></ol><p><br></p><h3 id="系统自动化就是用代码实现配置管理策略"><a href="#系统自动化就是用代码实现配置管理策略" class="headerlink" title="系统自动化就是用代码实现配置管理策略"></a>系统自动化就是用代码实现配置管理策略</h3><p>自动化几乎总是使用高级语言，自动化方式展现了三个原则：</p><ul><li>应该是灵活的<ul><li>无论需要什么，都应该有能力做</li></ul></li><li>应该是可扩展的<ul><li>遇到新情况时，要易于扩展</li></ul></li><li>应该是可重复的<ul><li>不管重复做了多少次，结果都一样</li></ul></li></ul><p><br></p><h3 id="系统管理中的配置管理"><a href="#系统管理中的配置管理" class="headerlink" title="系统管理中的配置管理"></a>系统管理中的配置管理</h3><p>配置管理工具应该有如下思想：</p><ul><li>描述的<ul><li>说明做什么，而不是怎么做</li></ul></li><li>抽象的<ul><li>让工具为你操心细节</li></ul></li><li>幂等的<ul><li>旨在需要时才采取行动</li></ul></li><li>聚合的<ul><li>只关心自己，并信赖其他服务亦然</li></ul></li></ul><p><br></p><h3 id="系统集成"><a href="#系统集成" class="headerlink" title="系统集成"></a>系统集成</h3><p>系统集成是指将各个组件整合为一个功能正常的、完全自动化的系统。系统集成侧重于广度，能否成功则依赖于对两个方面的理解：</p><ul><li>系统中的每个组件是如何工作的</li><li>这些组件是如何相关的</li></ul><p>应该遵循这两个步骤将基础架构构建为代码，这两个恰好也是系统集成阶段使用的步骤。系统集成就是将所有的东西整合在一起。</p><p><br></p><p><strong>将基础架构分解为可重用的，可通过网络访问的服务</strong></p><p>良好基础架构的十大核心原则：</p><ul><li>应该是模块化的<ul><li>启动过程将只处理这样的任务：使资源成为网络可访问</li></ul></li><li>应该是协作的<ul><li>启动服务应该能够将启动后的工作传给其他服务</li></ul></li><li>应该是可组合的<ul><li>能够从不同的服务中调用启动服务</li></ul></li><li>应该是灵活的<ul><li>足够灵活以应付不同类型的物理系统</li></ul></li><li>应该是可扩展的<ul><li>易于扩展，义启动新的资源类型</li></ul></li><li>应该是可重复的<ul><li>每次启动，都要生产相同的系统</li></ul></li><li>应该是描述的<ul><li>应该描述需要的系统类型，而不是如何安装和构建这些系统的细节</li></ul></li><li>应该是抽象的<ul><li>应该隐藏底层机制</li></ul></li><li>应该是幂等的</li><li>应该是聚合的<ul><li>应该尽快将每个系统都启动起来，并为随后的操作系统做好准备，而不用担心其他系统的状态</li></ul></li></ul><p><br></p><p><strong>将服务集成在一起</strong></p><p>现在，你已经创建了一个如何引导和配置系统的策略，你知道接收标准是什么、能够列出实现步骤、能够对策略进行测试。这种做系统集成的方式类似于做一个多层蛋糕：每一层都建立在前一层的美味基础上，使得整个蛋糕更为诱人。</p><p><br><br><br></p><hr><p><br></p><h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><p>我以前假定服务器资源是无限的，实际情况却是服务器正在为获得必要的内存而努力挣扎着。操作系统开始进行交换，CPU开始过载，从而响应时间开始变糟。</p><p>技术人员的观点和最终用户/业务的观点并不一致。</p><p>监控并不是设置一个系统，它是用来支持业务运转的，是用来保证系统中各个部分都在各司其职地工作着。能够正常工作也可以表述为保持网站的可用性。</p><p>可用性(A)可表述为：<br>A = Uptime/(Uptime + Downtime)</p><p>网站可用性受如下4个参数的影响：</p><ul><li><strong>MTTD(平均故障诊断时间)</strong><ul><li>诊断该问题所花费的平均时间</li></ul></li><li><strong>MTTR(平均修复时间)</strong><ul><li>用于修复问题所花费的平均时间</li></ul></li><li><strong>MTTF(平均无故障时间)</strong><ul><li>正常运行的平均时间</li></ul></li><li><strong>MTBF(平均故障间隔时间)</strong><ul><li>两次故障间隔的平均时间</li></ul></li></ul><p>A = MTTF/MTBF = MTTF/(MTTF+MTTD+MTTR)</p><p>并不是说你的业务需要接近90%或更高的可用性，业务要求的可能性只是一种期望值，如果宕机发生在周末，即使发生在工作日，只要还能工作，用户也不会说什么。你的目标是应该通过降低MTTD和MTTR，以及增加MTTF来增加可用性。</p><p><br><br><br></p><h2 id="理解你在监控什么"><a href="#理解你在监控什么" class="headerlink" title="理解你在监控什么"></a>理解你在监控什么</h2><p><strong>技术组件的依赖项：</strong></p><table><thead><tr><th>组件</th><th>依赖关系</th></tr></thead><tbody><tr><td>应用程序</td><td>应用程序服务器、Web服务器、邮件服务器、缓存服务器、队列服务器</td></tr><tr><td>Mail服务器</td><td>Mail服务进程、网络、主机、存储</td></tr><tr><td>DNS服务器</td><td>DNS服务进程、网络、主机、存储</td></tr><tr><td>应用程序服务</td><td>应用程序服务进程、网络、主机、存储</td></tr><tr><td>Web服务器</td><td>Web服务器进程、网络、主机、存储</td></tr><tr><td>数据库</td><td>数据库服务进程、网络、主机、存储</td></tr><tr><td>主机</td><td>设备、OS设备进程</td></tr><tr><td>网络</td><td>设备、网络设备进程</td></tr><tr><td>存储</td><td>设备、磁盘、RAID控制器、接口</td></tr><tr><td>通用设备</td><td>磁盘、内存、CPU、接口、房屋</td></tr><tr><td>房屋</td><td>UPS、电源、温度</td></tr></tbody></table><p>依赖项常常不受你控制，相反，它是由公司内不同的组管理的。从你自己的筒子里走出来，到其他部门获取相关信息，并不是很容易。正是因为你依赖于他们，所以更好地理解他们的就很关键了。这样你就不用在讯早问题的原因上浪费时间，在用户访问服务所依赖的那些组件上也就不会存在盲点。</p><p><br></p><p><strong>不同部门之间的边界：</strong></p><table><thead><tr><th>企业部门</th><th>依赖项</th></tr></thead><tbody><tr><td>支援部门</td><td>能影响浏览器、桌面设置、防病毒/间谍软件</td></tr><tr><td>开发组</td><td>专注于应用程序更新</td></tr><tr><td>中间件组</td><td>经常运行数据库、Web服务器、应用程序服务器、邮件服务器、缓存服务器队列服务器</td></tr><tr><td>系统组</td><td>操作系统、DNS、DHCP、虚拟化、集群</td></tr><tr><td>网络组</td><td>交换机、路由器、VPN、代理服务器</td></tr><tr><td>存储组</td><td>SAN、NAS、备份、恢复</td></tr><tr><td>数据中心组</td><td>电缆、电力、UPS</td></tr><tr><td>安全小组</td><td>防火墙、安全策略</td></tr></tbody></table><p>这样划分责任，在不清楚问题的真正原因时，会显著增加修复问题的时间。大量精力会花在努力证明自己部门的清白上面，从而延长了解决问题的时间。这份额外时间称为平均清白时间(Mean Time to Innocence)。<br>为了减少这种相互推诿的时间，良好的合作与协调很重要。持续的知识共享有助于增加这种共同应对问题的责任感。</p><p>组织边界到防火墙哪里就停止了，但Internet服务比内部控制的服务有更多的依赖项，这些外部依赖项有ISP、广告商、RSS信息、Internet邮件、DNS服务器、ISP连接等，内部依赖项和外部依赖项的主要区别在于，对于外部依赖项，你不知道这些服务是如何提供的。即使如此，也不能在监控这些服务上止步不前，毕竟它们仍然是你的服务的依赖项。</p><p>在无冗余的系统中，一个组件失效，整个服务就会失效。当一个组件的失效会影响整个服务时，这种失效就称为单点故障。这种影响既指服务完全中断，也指对服务质量的影响。<br>为了避免单点故障，通常是在架构中的多个位置增加冗余，这些冗余是你的环境的安全卫士，而不是对问题的某种补偿方式。通常，增加冗余会增加复杂性，所以不要掉进过度设计的陷阱。</p><p><strong>一些冗余机制：</strong></p><table><thead><tr><th>服务/组件</th><th>冗余机制</th></tr></thead><tbody><tr><td>应用程序</td><td>负载均衡器、状态复制</td></tr><tr><td>Mail服务器</td><td>一个域名多条MX记录</td></tr><tr><td>DNS服务器</td><td>一个域名多条NS记录</td></tr><tr><td>应用程序服务器</td><td>会话复制、多实例安装</td></tr><tr><td>Web服务器</td><td>Web服务器服务进程</td></tr><tr><td>数据库</td><td>集群服务、水平区分</td></tr><tr><td>主机</td><td>虚拟化、集群</td></tr><tr><td>网络</td><td>多网关、BGP、VRRP、多ISP</td></tr><tr><td>存储</td><td>RAID、镜像、多重路径技术</td></tr><tr><td>通用设备</td><td>多网卡、CPU、内存</td></tr><tr><td>数据中心</td><td>BGP任播、GSLB</td></tr></tbody></table><p><br></p><p>不要忘了检查监控服务的依赖项，如果监控都挂了，那还监控什么呢。</p><p><strong>各种检查：</strong></p><table><thead><tr><th>检查种类</th><th>例子</th></tr></thead><tbody><tr><td>可用性</td><td>能访问80端口吗？HTTP进程在运行吗？数据库能访问吗？</td></tr><tr><td>功能/既时</td><td>应用程序在请求数据库，OS在进行DNS查询，控制器在进行磁盘写入，负载均衡器在请求Web服务器</td></tr><tr><td>功能/模拟</td><td>模拟HTTP请求、DNS请求、发送邮件</td></tr><tr><td>质量/利用</td><td>CPU、内存、磁盘等硬件信息使用情况，可以知道机器是否有足够的处理能力</td></tr><tr><td>质量/效率</td><td>Squid缓存命中率</td></tr><tr><td>质量/吞吐</td><td>订阅数、登录数、请求数、进/出请求数，用户数，数据库连接数，活动连接数，实例数</td></tr><tr><td>环境</td><td>配置监控，安全监控，备份监控</td></tr><tr><td>可信性</td><td>邮件域的垃圾邮件防范级别，SSL证书</td></tr></tbody></table><p><br></p><p><strong>不同层级的检查：</strong></p><table><thead><tr><th>层级</th><th>例子</th></tr></thead><tbody><tr><td>业务</td><td>内部网管理站点</td></tr><tr><td>交易</td><td>登录、增加文档、分享链接、注销</td></tr><tr><td>服务</td><td>Mail、DNS、Web服务器、数据库、路由、防火墙</td></tr><tr><td>机器</td><td>服务器、CPU、内存、交换机</td></tr></tbody></table><p><br><br><br></p><h2 id="理解正常行为"><a href="#理解正常行为" class="headerlink" title="理解正常行为"></a>理解正常行为</h2><p><strong>即使你了解所有依赖项，但设计一个好的监控解决方案仍是要花时间的。需要根据业务实际需求和变化对监控实施改变。</strong></p><blockquote><p><strong>一些监控中的主要问题：</strong><br>如果多次报警基于同一个原因，应该只发送一次报警；<br>夜间，备份可能会在生产网络上产生很高的负载，这样由于响应时间的变慢而导致多个ping失败和其它可能的误报，从而产生起起伏伏的报警；<br>如果我们想要随时待命的支持人员，必须尽可能降低报警和误报的次数。</p></blockquote><p><br></p><p>加入的检查越多，消耗的生产系统的资源也就越多，这些资源可以是传送数据的带宽、计算结果的CPU…<br>你需要找到正确的平衡：监控太多只会浪费资源，从而降低对整个状况的了解；监控不足将导致不能及时报警。越靠近业务层的检查越有机会检测出问题，而越底层的检查越能够对发生的问题进行定位。</p><p>监控被认为是运维环境的一部分，通常是由系统或网络管理员来管理的。开始时是一个很小的系统，在后台运行。随着监控环境的扩大，需要执行更多的配置和定制。虽然运维人员常常是第一个对要部署的新软件进行仔细检查的人，他们的标准却往往并不应用到自己的监控系统上。监控系统是你的关键应用之一，请一视同仁。</p><p><br></p><p><strong>监控的最佳实践：</strong></p><table><thead><tr><th>实践</th><th>说明</th></tr></thead><tbody><tr><td>版本</td><td>对你的检查进行版本华，并把他们放入版本控制库中</td></tr><tr><td>不同环境</td><td>使用不同环境开发、测试新的检查</td></tr><tr><td>测试</td><td>将检查作为通常代码对待，在代码功能中加入测试</td></tr><tr><td>可使用性</td><td>创建一个所有组件及其关系的可视化总览图，指出失效和组件的关系对工程师很有帮助，只需要看一下仪表板就能明白问题出在哪里</td></tr><tr><td>信息架构</td><td>使用不同的数据表示法，将数据组织为层次结构以便于导航，同时还要避免信息过载</td></tr><tr><td>代码重用</td><td>如果能够重用所监控的应用程序中的业务逻辑，就不要自己写</td></tr><tr><td>无硬编码</td><td>避免将参数编码在脚本中，使用配置文件，这也易于脚本在不同环境中的迁移</td></tr><tr><td>部署</td><td>要易于部署和分发新的检查</td></tr><tr><td>备份/还原</td><td>备份监控数据，并了解在什么情况下需要还原</td></tr><tr><td>监控</td><td>监控你的监控系统</td></tr><tr><td>冗余</td><td>在监控上，使用高可用性的功能做维护工作</td></tr><tr><td>应用的安全规则</td><td>监控账号与其它事务账号分开 <br> 是用最小特权级 <br> 不要将密码保存为明文 <br> 限制对系统的访问，不要将其用于其它的测试 <br> 将监控系统用防火墙或代理系统保护起来，避免来自易受攻击的主机的访问</td></tr></tbody></table><p>所有信息一旦采集和存储，接下来做的就是分析检查结果。服务或系统的状态有<strong>可用(Up)</strong>和<strong>不可用(Down)</strong>，某些监控系统还增加了两个状态，一个用于<strong>系统不可达(Unreachable)</strong>，一个用于<strong>系统/服务尚未检查(Pending)</strong>。</p><p>有的时候，在位新服务建立环境时，预先定义的阈值很困难——实际使用可能会超过预期，或者相反。所以，对阈值进行不断的调优就有意义了。先根据理论上的假设定义一组阈值，然后在测试环境中模拟预期的行为，并翻译为技术化的组件使用情况。因为系统及使用情况的复杂性，对系统、应用程序、用户行为建立精确的模型是很困难的。所以，对阈值只能持续不断地研究与改进。趋势分析确实有助于定义阈值，大部分监控软件都可以让你对监控的值做趋势分析，而不产生报警，根据历史数据得出阈值之后，再启动报警设置。</p><p>管理报警并不仅仅是状态变化时发出报警信息。所有报警如果一直打开着的话，工程师将无法安心做系统支持，因为报警信息太多了，可能要被报警轰炸。同样，如果有太多假设报警，也会导致同样的问题，这可以看成是你的监控系统存在技术缺陷。<br>警报应该产生行动。如果一条警报可以忽略或不需要人工干预，这条报警就是一种浪费。然而，消除噪音却是真正的挑战。警报太多会导致<strong>狼来了</strong>效应，由于警报过载而忽略了正在重要的警报。</p><p>为了使网站可以忍受而限制报警是好的，但假如与业务需求不一致的话，就不行了。反之也是对的，如果业务不需要的话，为了显示网站运行正常而发送很多报警信息，也是毫无意义的。使监控保持正确的平衡，这很重要。</p><p><br><br><br></p><h2 id="有备而学"><a href="#有备而学" class="headerlink" title="有备而学"></a>有备而学</h2><p>一个人不可能在每个方面都是专家，有一个清晰定义的升级路径，从而把问题提交给更为专业的人员去处理是明智的。<br>对紧急报警进行跟踪和趋势分析，有助于提出架构和过程的改进建议。</p><p>故障时间本身并不仅仅有功能失效引起的，也可能是由于维护活动产生的。维护活动产生的故障时间被描述为维护窗口。在这种情况下，业务部门是认可默写故障时间的。为了避免不必要的报警，监控系统可能会在这段时间关闭报警。这会导致丢失一些与此次维护无关的系统/服务故障。所以，应该只关掉与维护相关的报警，而不是整个报警系统。然后，一旦服务运行稳定了，就要打开报警。</p><p><br><br><br></p><h2 id="结语-2"><a href="#结语-2" class="headerlink" title="结语"></a>结语</h2><p>监控并不是要保持服务器运行正常，也要保持业务运行正常。理解了技术组件和业务行为，你就会有相当的把握减少和修复问题上的时间。错误总是会发生的，但要为此做好准备。万一系统失效，一定要将反馈信息发送给每一个希望听到的人，并对事情做出改进，避免再发生新的错误。愿监控的力量与你同在。</p><p><br><br><br></p><hr><p><br></p><h1 id="复杂系统是如何失败的"><a href="#复杂系统是如何失败的" class="headerlink" title="复杂系统是如何失败的"></a>复杂系统是如何失败的</h1><p>所有复杂系统失败时，都有共同点。Web运维就是这样一个领域。</p><p><br><br><br></p><h2 id="复杂系统是如何失效的"><a href="#复杂系统是如何失效的" class="headerlink" title="复杂系统是如何失效的"></a>复杂系统是如何失效的</h2><ul><li>复杂系统本质上都是灾难系统</li><li>复杂系统都被重重地然而也是成功地防护着</li><li>灾难要求多点失效——单点失效是不够的</li><li>复杂系统包含潜藏在其中的缺陷的变化混合物</li><li>复杂系统以降级模式运行</li><li>灾难随时会发生</li><li>事后归结为”根本原因“是错误的</li><li>幕后认识对人类行为的时候评估存在偏见</li><li>人类操作员有双重角色：作为生产者，以及作为失效防护者</li><li>所有操作者的行为都是赌博</li><li>最为困难的行动解决了所有的模糊性</li><li>人类操作者是复杂系统的可调整因素</li><li>复杂系统中人类专门处理知识处于不断变化中</li><li>变化会引入新的失效</li><li>“原因”观点限制了对未来事件的有效防护</li><li>安全是系统的特性，而不是系统的组件</li><li>持续创造安全的是人</li><li>无事故的运维需要经历事故的历练</li></ul><p><br></p><p><strong>针对Web运维而言：</strong></p><ul><li>了解系统失效很困难</li><li>了解哪部分失效很困难</li><li>有意义的响应会被延迟</li><li>沟通会产生紧张，而脾气会冒火</li><li>维护会成为新的失效的主要源头</li><li>从备份中恢复本身就很困难，而且还有潜在的危险</li><li>创建测试过程，一线人员用来验证系统状态</li><li>对运维进行例行的每日管理</li><li>控制维护</li><li>定期对性能进行评估</li><li>要成为(独一无二)的用户</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="社区管理与Web运维"><a href="#社区管理与Web运维" class="headerlink" title="社区管理与Web运维"></a>社区管理与Web运维</h1><p>运行一个大型且广为人知的网站，意味着会有大批人依赖于网站快速而稳定的服务。这些人会形成一个社区，以各种有趣新颖的方式进行交流，并彼此关照。</p><p>社区起着一个交流、沟通、反馈的渠道作用。</p><p><br><br><br></p><hr><p><br></p><h1 id="处理非预期的访问量激增"><a href="#处理非预期的访问量激增" class="headerlink" title="处理非预期的访问量激增"></a>处理非预期的访问量激增</h1><p>有些时候，因为某种原因，Web的访问量会急剧增加(是正常用户访问而不是遭受攻击)，我们的服务器就会遭受严重的考验。</p><p><br><br><br></p><h2 id="一切是如何开始的"><a href="#一切是如何开始的" class="headerlink" title="一切是如何开始的"></a>一切是如何开始的</h2><p>开能由于某个原因，导致Web流量激增，而我们服务器却无法应付这么高的并发和流量，所以导致Web瘫痪。</p><p><br><br><br></p><h2 id="警报连连"><a href="#警报连连" class="headerlink" title="警报连连"></a>警报连连</h2><p>监控软件(如nagios, zabbix)警报连连。Web请求太多导致响应很慢或奔溃。</p><p><br><br><br></p><h2 id="扑灭烈火"><a href="#扑灭烈火" class="headerlink" title="扑灭烈火"></a>扑灭烈火</h2><p>查找是哪些环节导致Web响应很慢或奔溃，对之做相应的优化。</p><p><br><br><br></p><h2 id="未雨绸缪"><a href="#未雨绸缪" class="headerlink" title="未雨绸缪"></a>未雨绸缪</h2><p>当我们经历了非预期的流量激增，并处理优化之后，下一步就需要对整个基础架构进行加固，或转向新的架构。</p><p><br><br><br></p><h2 id="救命稻草CDN"><a href="#救命稻草CDN" class="headerlink" title="救命稻草CDN"></a>救命稻草CDN</h2><p>解决带宽问题要靠内容分发网络(CDN)——在多个地点存储文件，为客户提供最近最快的响应。<br>大部分静态资源适合移动到CDN上，以减轻原始服务器的负担。</p><p>但CDN也有一些不足。对于移动到CDN上的数据，你就失去了控制。对于短时间的静态内容，CDN的效果并不好。</p><p><br><br><br></p><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>代理服务器处于我们系统的最前沿，尽可能让代理服务器转发请求，而不使用任何其它资源。</p><p><br><br><br></p><h2 id="围剿踩踏"><a href="#围剿踩踏" class="headerlink" title="围剿踩踏"></a>围剿踩踏</h2><p>如何避免缓存踩踏？</p><ul><li>一个是对数据库进行优化</li><li>一个是搭建数据库集群</li></ul><p><br><br><br></p><h2 id="将代码基流水化"><a href="#将代码基流水化" class="headerlink" title="将代码基流水化"></a>将代码基流水化</h2><p><br><br><br></p><h2 id="怎么知道它能否工作"><a href="#怎么知道它能否工作" class="headerlink" title="怎么知道它能否工作"></a>怎么知道它能否工作</h2><p>确保系统能够处理负载的唯一途径是在流量汹涌而来时，对其进行现场测试。</p><p><br><br><br></p><h2 id="真实测试"><a href="#真实测试" class="headerlink" title="真实测试"></a>真实测试</h2><p>必须要在真实的生产环境中查看其负载效果，才能确保其能正常工作。</p><p><br><br><br></p><h2 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h2><p>总要为未来几年做一个规划——问问你自己：“当前的架构方案能够用于未来几年吗？”</p><p>要测试生产环境，经过适当的测试规划，很多问题是可以避免的。</p><p>当一个架构方案已经明显不能工作的时候，必须要有重新考虑整个方案的勇气。<br>重新思考代码、硬件、网络、数据库模式，为可见的未来创建一个伸缩性更好的系统。</p><p><br><br><br></p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>针对遭受的问题，之后对系统的改进。</p><p><br><br><br></p><hr><p><br></p><h1 id="开发者与运维者的协调与合作"><a href="#开发者与运维者的协调与合作" class="headerlink" title="开发者与运维者的协调与合作"></a>开发者与运维者的协调与合作</h1><p>很多网站都将其开发和运维分为两个独立的团队，开发负责开发新功能和对现有功能进行改进，运维负责网站的正常运行。<br>两个团队有不同的目标，工作方式的要求也是迥然有别。</p><p>这种设置很常见，但也是保证网站稳定性或及时推出新功能的最糟糕的设置。</p><p>这在种情形下，开发人员没有动力将网站做得更易于运维支持，开发团队交付的代码通常是一个黑盒子，一旦发生意外，运维团队没有办法及时去修复问题。这种结构也抑制了新的功能的开发、构建和部署网站的新版本，不仅耗时，成本高，还涉及很多不同团队之间的协调。对运维来说，部署是存在风险的，而且也是造成很多宕机事故的原因。</p><p>传统的运维和开发，两者之间存在着很多对彼此很有用的信息。对很多网站来说，性能瓶颈都出在应用程序代码上：开发团队最适合修正这些问题，但运维团队有测量数据，要想找出问题出在哪，是需要这些数据的。关于什么地方可能会出问题，以及如何修复，开发团队有很多很好的想法，但这些却很少会记录在文档里面。</p><p>所以，重新评估运维跟开发之间的关系！</p><p><br><br><br></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>以合适的方式进行移交，则不同团队之间就能更好地共同工作，而改变过程这是困难的，需要协助以及每个人的认可。</p><p>一项服务之所以受人欢迎，频繁部署也是重要原因之一。小批量代码更新。</p><p>用户报告问题后，极短时间内就得到修复，这一做法会彻底征服用户。有了这种响应凡是，则将来有了问题，用户也会很乐意报告给你，这样产品就会越做越好，特别是你能够一直这样快速反应的话。对关键的数据损失或安全缺陷能够在短时间内而不是几周响应的话，用户的数据就会安全得多。</p><p>然而最重要的是，频繁部署并不比周部署或月部署风险更大。很多小的更新，每个都单独测试和检查过，比起一次大的更新来说，导致严重宕机的事故的可能性要小很多。</p><p>这是因为小更新的影响能够提前单独进行复审和测试，从而错误造成的影响也易于量化及应对。定位代码中的缺陷，复审10行的更新比起10000行来，会容易得多，而且只测试那些受更新影响的功能，比起测试整个系统，也要快得多。而且能够确保每次部署都只是更新一个区域，从而避免同时更新的两个组件之间发生预料不到的交互作用。小部署意味着更容易预言更新对基础架构的影响，而这也就意味着未雨绸缪更加有的放矢。</p><p>如果只是部署30行代码，缺陷通常是自明的。如果缺陷不自明，其影响也会非常小，即使回滚也非常容易。</p><p><br></p><p>只有在遵循以下三条规则的情形下，频繁的小更新才起作用：</p><ul><li>构建与部署系统必须能够完全重复且自动地工作</li><li>具有几近完美的预演环境</li><li>部署必须尽可能快，理想情况是小于5min</li></ul><p>大多数构建和部署系统在某种程度上都是自动化的，少数团队走得更远，把构建和部署做成了一键操作。</p><p><br><br><br></p><h2 id="共享、开放的基础架构"><a href="#共享、开放的基础架构" class="headerlink" title="共享、开放的基础架构"></a>共享、开放的基础架构</h2><p>很多情形下，运维和工程都分为不同的小组，你会发现支持的基础架构也会一分为二。</p><p>共享基础架构是在团队之间进行协作的最容易的方式。</p><p>为了有效地工作，你需要了解系统的其它方面目前是如何运转的。为了建立信任，你需要使你的工作变得透明。</p><p><br><br><br></p><h2 id="信任"><a href="#信任" class="headerlink" title="信任"></a>信任</h2><p>信任是开发和运维之间最常见的紧张关系之一。多数运维团队对开发团队多少都有点怀疑，开发人员通常也好不到哪去。团队之间的不信任是不健康的，也是不合适的。</p><p>信任最终是建立在一种尊敬的感觉之上的。如果你尊敬某人，就很容易信任此人能够做好他的事情。反之，如此人交往便会带有偏见、不满等情绪。</p><p>运维和开发之间的许多问题都是由于对两个团队不同角色的重要性认识不同而造成的。</p><p>充分尊重你的同事，而不是事后指责他们。</p><p><br><br><br></p><h2 id="随叫随到的开发人员"><a href="#随叫随到的开发人员" class="headerlink" title="随叫随到的开发人员"></a>随叫随到的开发人员</h2><p>只有在开发人员对修正生产系统代码中的问题肩负起责任的情况下，才是有意义的，而这就意味着开发人员随叫随到。</p><p><br></p><h3 id="现场调试工具"><a href="#现场调试工具" class="headerlink" title="现场调试工具"></a>现场调试工具</h3><p>很多代码对于运维团队来说都是黑盒子。</p><p>要想办法在运行时调用额外的调试信息，技术团队的每个人在用管理账号登录系统之后，都可以开启额外的调试信息。</p><p><br></p><h3 id="功能标识"><a href="#功能标识" class="headerlink" title="功能标识"></a>功能标识</h3><p>禁掉某些依赖于问题架构的功能，而保持网站的其他部分正常运行，功能标识能够实现这一点。</p><ul><li>单个标识，用来禁掉每个非核心的基础架构</li><li>只要这些服务出现问题，我们都可以暂时并优雅地禁止掉这些功能</li><li>如果生产系统出现新的错误场景，也可增加新的标识</li></ul><p><br><br><br></p><h2 id="避免职责"><a href="#避免职责" class="headerlink" title="避免职责"></a>避免职责</h2><p>在很多团队中，没有人愿意成为搞坏所有事情的傻瓜。发生问题时，人们都会将责任推卸给别人。</p><p>每个人都有貌似合理的理由将指责转嫁给别人，却没有挺身而出，实实在在地修复问题，组织良好的团队深切地了解，在将问题修复之前，争论到底是谁的责任是没有意义的，为保护自己而浪费的每一分钟，由于问题没有修复，都会成为给用户带来损失的一分钟。用户会尝试各种可能性，知道他们发现系统出问题了。</p><p>多数生产环境都有足够的冗余，也足够复杂，任何问题都不太可能存在单一的根本问题。很多问题都是由两个或多个系统发生意料之外的交互作用而引起的。</p><p><br><br><br></p><h2 id="结语-3"><a href="#结语-3" class="headerlink" title="结语"></a>结语</h2><p>网站的稳定性是每一个人的责任，而不仅仅是某种应该交给运维团队去处理的东西。</p><p>让人人都拥有对网站的主人翁感觉，确实意味着能够减轻运维团队的工作负担。他们不用再花费大量时间呼吁采取防护性措施，一旦发生问题，也能够花更小的时间修复。这非常了不起，因为这意味着网站的宕机时间会减少很多。这也释放了运维团队，让他们能够把精力放在更为重要的任务上，即对基础架构的长期增长进行管理。</p><p><br><br><br></p><hr><p><br></p><h1 id="你的访问者感觉怎么样：面向用户的测量"><a href="#你的访问者感觉怎么样：面向用户的测量" class="headerlink" title="你的访问者感觉怎么样：面向用户的测量"></a>你的访问者感觉怎么样：面向用户的测量</h1><p>对于网站的成功而言，终端用户的测量也就变得和后台测量一样至关重要。</p><p><br><br><br></p><h2 id="为何要采集面向用户的测量数据"><a href="#为何要采集面向用户的测量数据" class="headerlink" title="为何要采集面向用户的测量数据"></a>为何要采集面向用户的测量数据</h2><p>采集数据，从而就可以对业务的健康状况进行分析。</p><p>如：</p><ul><li>每秒请求数/发布数</li><li>带宽</li><li>响应时间</li><li>HTTP错误率</li><li>记入日志的异常数</li><li>进程重启次数</li><li>队列大小</li><li>服务器的平均负载和进程数</li><li>数据库负载</li><li>内存</li></ul><p><br></p><h3 id="成功的创业公司所学到的以及必须适应的"><a href="#成功的创业公司所学到的以及必须适应的" class="headerlink" title="成功的创业公司所学到的以及必须适应的"></a>成功的创业公司所学到的以及必须适应的</h3><p>创业公司的一大优势就是敏捷，即快速反应的能力。要真正做到敏捷，创业公司需要了解终端用户真正体验到的是什么。</p><p>任何网站想要成功，就必须向用户学习，而且必须适应用户的需求。很多Internet巨头，它们现在的业务，都与其当初设定的相比有很大的不同。</p><p><br></p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>响应越快的应用程序越好！</p><p>响应级别：</p><ul><li>加入事情的响应时间在10ms内，我们的大脑就会认为这是真实的<ul><li>如点击桌面系统上的按钮</li></ul></li><li>如果谈话有100ms左右的延迟，我们不会感觉到这种延迟<ul><li>如国际长途电话</li></ul></li><li>如果应用程序的响应时间在1s之内，我们的感觉就是仍然在与应用程序互动，仍然在工作</li><li>应用程序的响应时间要是明显长于1s的话，我们就会抓狂</li></ul><p><br></p><h3 id="研究量化了这种关系"><a href="#研究量化了这种关系" class="headerlink" title="研究量化了这种关系"></a>研究量化了这种关系</h3><p>Web应用的速度越快，其Web业务员的优势就越明显！</p><p>如果你的网站很慢，你将得到：</p><ul><li>更少的用户搜索</li><li>更少的精度搜索</li><li>更少的每访客收入</li><li>更少的点击，更低的满意度</li><li>更少的每日搜索</li><li>等待访客点击的时间更长</li><li>更低的搜索引擎排名</li><li>更差的用户体验</li></ul><p><br><br><br></p><h2 id="是什么使网站变得很慢"><a href="#是什么使网站变得很慢" class="headerlink" title="是什么使网站变得很慢"></a>是什么使网站变得很慢</h2><p>简单来说，由以下三点原因造成：</p><ul><li>服务器花在处理用户请求上的时间</li><li>网络花在传输请求和响应上的时间</li><li>用户花在组装并显示结果内容上的时间</li></ul><p><br></p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>开始访问网站，用户都需要先找到服务器。</p><p>对于带有很多组件的网站——这是一个日渐普遍的模式——都会迫使用户去解析很多网站，并且页面加载的时间也延长了。</p><p><br></p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>网络再快，用户与服务器之间的往返也是需要时间的。</p><p>请求包含的内容越多，则网络用来传输的时间就越长。加入是一个安全页面的话，还会有另外的延迟，用来在客户与服务器之间进行加密协商。</p><p><br></p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>请求到达服务器之后，另一个导致延迟的罪魁祸首就登场了——主机。不论是从内存中检索静态对象，还是利用后台的第三方服务来完成一个复杂的请求，主机延迟都会对性能造成影响。</p><p><br></p><h3 id="发送响应"><a href="#发送响应" class="headerlink" title="发送响应"></a>发送响应</h3><p>响应内容一旦准备就绪，服务器就可以通过HTTP协议发送这些请求对象——大多数页面包含多个对象(如html,css,js,gif,png,jpg…)，正是这些对象的发送造成了访客体验到的延迟。</p><p><br></p><h3 id="异步通信与刷新"><a href="#异步通信与刷新" class="headerlink" title="异步通信与刷新"></a>异步通信与刷新</h3><p>某些应用包括一些客户与服务器之间的通信，这些通信是独立于页面进行的。<br>包含某种异步更新或刷新的应用，有不同的延迟测量指标。</p><p><br></p><h3 id="渲染时间"><a href="#渲染时间" class="headerlink" title="渲染时间"></a>渲染时间</h3><p>随着客户端越来越复杂，浏览器做的也就越来越多。有可能是启动富互联网应用(RIA)，这些RIAs都是构建在Flash、Flex、HTML5、Java、JS…之上的，也可能是运行QuickTime或Windows媒体播放器等这样的插件，甚至决定如何对复杂页面进行布局也是需要花费时间的。<br>所以，对于大量依赖客户端进行渲染的网站，就必须考虑这种延迟。</p><p><br><br><br></p><h2 id="测量延迟"><a href="#测量延迟" class="headerlink" title="测量延迟"></a>测量延迟</h2><p>有两种测量方法：</p><ul><li>综合监控</li><li>实际用户监控(RUM)</li></ul><p><br></p><h3 id="综合监控"><a href="#综合监控" class="headerlink" title="综合监控"></a>综合监控</h3><p>综合监控是通过从多个地点对网站进行一系列正规的校本化测试，对网站的性能进行监控。</p><p><strong>要记住，综合测试也是要消耗服务器资源的。</strong></p><p><br></p><h3 id="真实用户监控"><a href="#真实用户监控" class="headerlink" title="真实用户监控"></a>真实用户监控</h3><p>RUM的工作名副其实：它观察的是网站的真实访客，记录访客打开页面的速度，然后生成报表。</p><p>从这点来看，RUM会告诉你系统是否出问题了，因为你可以通过RUM发现问题以及速度变慢的情况，这些情况你没有进行测试，从而也就不知道是否存在。</p><p><br><br><br></p><h2 id="编写SLA"><a href="#编写SLA" class="headerlink" title="编写SLA"></a>编写SLA</h2><p>Web运维收集终端用户的数据的一个主要理由就是用来编写SLA，哪怕与客户之间没有正式的SLA，但对于正常工作时间及页面延迟，也应该有内部的目标，因为网站速度对用户体验有直接的影响。</p><p><br><br><br></p><h2 id="访客结果：分析"><a href="#访客结果：分析" class="headerlink" title="访客结果：分析"></a>访客结果：分析</h2><p>对于成功的Web运维来说，监控就是了解存在哪些不利因素。而当进入Web业务时，这些测量就要让位于Web分析了。</p><p><br></p><h3 id="市场营销如何定义成功"><a href="#市场营销如何定义成功" class="headerlink" title="市场营销如何定义成功"></a>市场营销如何定义成功</h3><p>对市场营销的最好描述——“更经常、更有效地卖出更多的东西给更多的人，从而得到更多的钱。”<br>或许应该将成功的在线营销更精确地定义为“让人们有效地去做你要他们做的事情。”</p><p><br></p><h3 id="网站的四种类型"><a href="#网站的四种类型" class="headerlink" title="网站的四种类型"></a>网站的四种类型</h3><ul><li>交易性网站</li><li>协作型网站</li><li>作为服务(saas)网站</li><li>媒体网站</li></ul><p>很多流行网站都是上述模式的混合。</p><p>网站分析就是对每种类型网站的成功因素进行追踪，从中识别出使这些因素得以增长的背后动因——不管是广告活动、性能的提升、社会网络上的关注、特殊的定价模式还是某个引人注目的内容。</p><p><br></p><h3 id="分析一个简单的模型"><a href="#分析一个简单的模型" class="headerlink" title="分析一个简单的模型"></a>分析一个简单的模型</h3><p>有一个简单方式来考虑网站分析，就是做一次访问。</p><p>网站分析的目标，就是通过优化网站，将访客的转变最大化，通常是对网站进行试验，并针对各种内部和外部区段，对这些试验结果进行分析。</p><p><br><br><br></p><h2 id="市场营销关心的其他测量数据"><a href="#市场营销关心的其他测量数据" class="headerlink" title="市场营销关心的其他测量数据"></a>市场营销关心的其他测量数据</h2><h3 id="Web交互分析"><a href="#Web交互分析" class="headerlink" title="Web交互分析"></a>Web交互分析</h3><p>分析查看的是用户对多个页面的整体访问情况，Web交互分析集中在单个页面的可用性交互上。</p><p><br></p><h3 id="用户之声"><a href="#用户之声" class="headerlink" title="用户之声"></a>用户之声</h3><p>用户之声工具用来询问客户在想什么。这些工具从网站的访问性中征求反馈，通过请求客户参与调查，或者在页面上提供一个反馈按钮。</p><p><br><br><br></p><h2 id="用户体验如何影响Web运维"><a href="#用户体验如何影响Web运维" class="headerlink" title="用户体验如何影响Web运维"></a>用户体验如何影响Web运维</h2><p>随着新建公司对终端用户体验的关注，Web运维的角色正在发生变化。对线上事务的兴趣越来越浓，而且通过追踪分析，网站的所有事情都能够和业绩联系起来。</p><p><br></p><h3 id="将监控作为生命周期的一部分"><a href="#将监控作为生命周期的一部分" class="headerlink" title="将监控作为生命周期的一部分"></a>将监控作为生命周期的一部分</h3><p>网站现在已经有了很大的变化，随着敏捷和精简产品开发的流行，监控也需要跟上。所以来的综合监控脚本以及RUM配置也需如此。</p><p><br></p><h2 id="Web监控的未来"><a href="#Web监控的未来" class="headerlink" title="Web监控的未来"></a>Web监控的未来</h2><p>终端用户体验的监控正在兴起，变化很快。这是业务中最能进行分析、量化的部分，每周都能涌现出新的技术。</p><ul><li>从系统转向用户</li><li>以服务为中心的架构</li><li>云与监控</li><li>APIs与RSS消息</li></ul><p><br><br><br></p><hr><p><br></p><h1 id="将关系数据库用于Web的战略战术"><a href="#将关系数据库用于Web的战略战术" class="headerlink" title="将关系数据库用于Web的战略战术"></a>将关系数据库用于Web的战略战术</h1><p>如何为产品或应用程序设计一个良好的关系数据库架构，如何构建良好的互联网数据库架构？</p><p><br><br><br></p><h2 id="Web数据库需求"><a href="#Web数据库需求" class="headerlink" title="Web数据库需求"></a>Web数据库需求</h2><p>其实，大多数网站，相对而言，都只是小型数据库。<br>一些大型公司，可能才是一个大型数据库。</p><p><br></p><h3 id="一直在线"><a href="#一直在线" class="headerlink" title="一直在线"></a>一直在线</h3><p>数据库通常要7x24小时运行。<br>一直在线意味着维护和运维任务是很难做的，你不能简单地等到人们回家了然后将服务器卸下来，给硬件升级或备份。必须在不停机的情况下做这些事，而且很多情况下还不能给应用程序增加额外的负载。</p><p>话虽这么说，还是极少看到没有峰值时间的数据库。所以，还是有很好的机会，在数据库活动的间歇期来做备份或对数据库产生干扰工作。</p><p><br></p><h3 id="事务最多的工作负载"><a href="#事务最多的工作负载" class="headerlink" title="事务最多的工作负载"></a>事务最多的工作负载</h3><p>很多互联网应用都匹配以下模式：</p><ul><li>应用程序读远大于写</li><li>一次读一行和一次读多行是混合出现的</li><li>一般，写每次只影响一行</li></ul><p>这就是称之为的<strong>事务型负荷</strong>。</p><p><br></p><h3 id="简单数据，简单查询"><a href="#简单数据，简单查询" class="headerlink" title="简单数据，简单查询"></a>简单数据，简单查询</h3><p>网站的流量很大程度上决定了数据库的流量。</p><p>查询通常会满足下面的模式：</p><ul><li>读写用户表，一次一行</li><li>以区域或集合方式读取用户自己的数据</li><li>以区域或集合方式读取其他用户的数据</li><li>从该用户到其他用户的关联表中读取区域行</li><li>对该用户和其他用户的数据进行汇总与计数</li></ul><p>特别低，很多数据可以分区存储的事实说明了为什么<strong>分片(sharded)</strong>架构是可能的。</p><p><br></p><h3 id="可用性胜过一致性"><a href="#可用性胜过一致性" class="headerlink" title="可用性胜过一致性"></a>可用性胜过一致性</h3><p>从业务的角度看，最重要的事情是应用程序对用户的可用性。</p><p><br></p><h3 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h3><p>传统应用极少以天或周为周期构建和部署，但对于大量Web应用来说却是常态，这些Web应用是永远的Beta版。</p><p><br></p><h3 id="在线部署"><a href="#在线部署" class="headerlink" title="在线部署"></a>在线部署</h3><p>模式和数据的更新都做成代码形式，而且也有这样的框架，部署这些代码或将其回滚都很容易。</p><p><br></p><h3 id="由开发人员构建"><a href="#由开发人员构建" class="headerlink" title="由开发人员构建"></a>由开发人员构建</h3><p>大量的应用程序都是由开发人员做的，都没有一个高水平的DBA。</p><p><br><br><br></p><h2 id="典型的Web数据库是如何增长的"><a href="#典型的Web数据库是如何增长的" class="headerlink" title="典型的Web数据库是如何增长的"></a>典型的Web数据库是如何增长的</h2><p>大多数Web数据库的增长，都经历了一些列的架构变动。这些架构变动，在应用程序的整个生命周期中，相对而言都是可预知的。</p><p><br></p><h3 id="单台服务器"><a href="#单台服务器" class="headerlink" title="单台服务器"></a>单台服务器</h3><p>一般应用程序都是从单台服务器开始起步的。使用单台服务器有很多好处：</p><ul><li>数据只有一份拷贝，不存在你的数据是否正确或不同的问题</li><li>易于配置</li><li>便宜</li></ul><p>当然，缺点就是只有一台服务器！假如发生问题，没有冗余机器做故障转移。性能也会受影响。</p><p><br></p><h3 id="主服务器与单复制从服务器"><a href="#主服务器与单复制从服务器" class="headerlink" title="主服务器与单复制从服务器"></a>主服务器与单复制从服务器</h3><p>各数据库的复制技术都不一样，但一般而言，发生在主服务器上的数据修改，都要在从服务器上重复一遍，所以从服务器是主服务器数据的只读拷贝。依赖于数据库、系统负载以及执行的查询类型，从服务器不一定时刻与主服务器的数据完全一致(异步复制)。</p><p>增加一个复制从服务器有很多好处。数据库读请求可以在主、从指间分担，这称为读写分离。可以在从服务器上执行那些效率不高的查询、备份以及其它有可能对网站造成破坏的任务。</p><p><br></p><h3 id="主服务器与多复制从服务器"><a href="#主服务器与多复制从服务器" class="headerlink" title="主服务器与多复制从服务器"></a>主服务器与多复制从服务器</h3><p>大多数复制技术对两台或多台从服务器都没问题。<br>这样确实不错，而且随着从服务器越来越多，系统的数据库读取能力也越来越强。但这种增长不是无限制的，在很多层面上都会遇到收益递减的拐点。</p><ul><li>第一个层面就是应用程序中读对写的比例</li><li>第二个方式表示主服务器的写操作有多忙，其中你会看到收益递减的情况</li><li>第三个限制是操作成本和复杂性<ul><li>管理一群服务器，比管理单台服务器，要难得多也昂贵得多</li></ul></li><li>最后一个不足是应用的复杂性<ul><li>从单一数据源走向两个数据源，对于大多数应用程序而言，都是一个重大转移。应用程序不得不连接多个位置来进行查询。连接池、负载均衡器以及类似技术会在一定程度上保护你不受这种复杂性的困扰，但最终应用程序仍然要面对某种程度的复杂性</li></ul></li></ul><p>复杂性的一个最大来源是异步复制。异步意味着写操作先在主服务器上完成，随后送往从服务器执行。结果就是，从服务器总是拖后于主服务器某段时间，即时这段时间很短，但由此而造成的问题却很大。这可能会导致用户体验的不一致到数据完整性等一系列问题。</p><p>一般而言，不存在修复这个问题的神奇方法，应用程序必须自己处理这种延迟复制。<br>一种不错的简单技术是基于会话的分裂。用户做了更新之后，一段时间之内，该用户的所有查询都导向到主服务器。认为能够安全地查询从服务器所需的时间戳通常都存储在会话里。</p><p><br></p><h3 id="功能分区"><a href="#功能分区" class="headerlink" title="功能分区"></a>功能分区</h3><p>复制只对读有伸缩，对写没有。随着应用的规模越来越大，写操作的负载最终会大到系统无法处理。</p><p>功能分区(functional partitioning)，假如将某些部分与其余部分分开，则这些部分可以独立增长。<br>如，对于博客服务，可将评论功能分离到它自己的服务器中。</p><p>从运维角度来看，不同部分处在不同位置，则应用程序的功能也就能够单独对待。比起网站宕机，将评论改为只读模式，用户的反感可能要小得多。</p><p>这种做法的不利之处是增加了复杂性。应用程序需要从多个位置获取数据，而运维团队必须保持这些服务器正常运行。</p><p><br></p><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>分片(sharding)，是将单一逻辑数据划分为多个片段并发布在多台服务器上的一种方式。所有的片段在逻辑上和功能上都是相同的，虽然这些片段分别包含数据的不同子集。</p><p>分片架构的主要设计目标和优势都是双重的。第一是允许写伸缩，因为负值无法实现写伸缩，假如应用程序的写操作草果了任何单台服务器能承受的程度，就必须要分片以减少写操作的负载，写操作的负载必须分担到完全隔离的服务器上，对一个分片的服务器的写操作不能复制到另一个分片服务器上。第二个目标和优势是，随着数据集的增长，能够增加更多容量的能力。</p><p>在分片架构中，许多查询也变得困难或不可能了。例如，需要访问所有客户数据的查询，通常都要在每个分片上分别执行，然后在应用程序代码中在聚合在一起。</p><p>分片架构还存在很多其他的不足和复杂性。</p><p><br></p><h3 id="缓存层"><a href="#缓存层" class="headerlink" title="缓存层"></a>缓存层</h3><p>缓存层的目的是阻止查询到达数据库。<br>标准的例子是：memcached，redis</p><p>缓存层的主要优势是极为容易，并且简单。</p><p>从运维的立场来看，需要考虑缓存服务器的冗余和可用性，就像为其他服务器所做的一样。</p><p><br><br><br></p><h2 id="对集群的渴望"><a href="#对集群的渴望" class="headerlink" title="对集群的渴望"></a>对集群的渴望</h2><p>在应用程序出现某种问题，或关于可用性或伸缩性的困难问题来的时候，人们的思想就会转向集群(cluster)，就像年轻人的思想转向春天和爱情一样。</p><p><br></p><h3 id="CAP定理以及ACID和BASE"><a href="#CAP定理以及ACID和BASE" class="headerlink" title="CAP定理以及ACID和BASE"></a>CAP定理以及ACID和BASE</h3><p>CAP原理： 一致性(Consistency)、可用性(Availability)、分区容错性(Partition Tolerance)。你可以具有两者，但不能三者皆具备。</p><p>ACID： 原子性(Atomicity)、一致性(Consisitency)、分离性(Isolation)、持续性(Durability)。</p><p>BASE: 根本可用性(basically available)、软状态(soft state)、最终一致性(eventual consistency)。</p><p><br></p><h3 id="MySQL集群的状态"><a href="#MySQL集群的状态" class="headerlink" title="MySQL集群的状态"></a>MySQL集群的状态</h3><p>MySQL Cluster是将MySQL服务器作为一个完全不相干的、称为NDB的软件的前端。NDB的意思是网络数据库，这是一个极快、分布式、无共享、高可用的数据库。</p><p><br></p><h4 id="DRDB和Heartbeat"><a href="#DRDB和Heartbeat" class="headerlink" title="DRDB和Heartbeat"></a>DRDB和Heartbeat</h4><p>DRDB在服务器之间对块设备进行复制，将修改的块通过网络复制给备机。如果主服务器失效了，则Heartbear激活备机。</p><p>从运维的角度来说，DRDB非常棒，装上就能工作，但却不能满足在线用户的需求。它不是为满足典型Web应用的高可用性而设计的。相反，它非常适合用户保证你不丢失数据的情况，也就是说，它关注的焦点是一致性而不是可用性。</p><p>另一个问题就是基于DRDB的集群不能改进性能。Web应用需要的是正常工作时间和性能，而基于DRDB的集群是以性能为代价来提供一致性，而一旦失效，宕机时间就会很长。</p><p><br></p><h4 id="主服务器到主服务器的复制管理器-MMM"><a href="#主服务器到主服务器的复制管理器-MMM" class="headerlink" title="主服务器到主服务器的复制管理器(MMM)"></a>主服务器到主服务器的复制管理器(MMM)</h4><p>MMM是一系列的Perl脚本，管理复制和虚拟IP地址，从而为MySQL提供一个伪集群(pseudocluster)。</p><p>应用程序连接到虚拟IP而不是服务器的真实IP。服务器发生问题时，MMM将该服务器的虚拟IP移动到另外的可用服务器上。它也可以将复制从服务器从失效的主服务器移动到正常的主服务器上。MMM允许手工将服务器离线执行维护任务。</p><p><br></p><h4 id="带复制的Heartbeat"><a href="#带复制的Heartbeat" class="headerlink" title="带复制的Heartbeat"></a>带复制的Heartbeat</h4><p>如果MMM无法完美地管理复制和虚拟IP地址，heartbeat考虑以下？</p><p>不管怎么说，复制延迟仍然是一个复杂的问题。必须在应用程序层解决这一部分问题。</p><p><br></p><h4 id="基于代理的解决方案"><a href="#基于代理的解决方案" class="headerlink" title="基于代理的解决方案"></a>基于代理的解决方案</h4><p>有一种可供选择的方案，基于代理(proxy)，需要人工介入，MySQL Proxy位于前端。HAProxy是另一个流行的方案。</p><ul><li>MySQL Proxy，事实上能够理解MySQL的协议，并且拦截、解释以及传递消息</li><li>HAProxy，只是传递TCP流，并不对内部进行窥探</li></ul><p>基于代理的解决方案仍然没有入人们所愿的那样解决复制延迟问题，而且还引入了单点故障，并且影响性能。</p><p><br></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>前面讨论这么多，简而言之，就是没有一个完美的、万能的答案。</p><p>最好的数据库架构是为了应用而建的，期待集群所承担的指责分布在数据库、网络以及应用程序上，有运维的适度介入，以及起粘合作用的软件，就能把各部分整合在一起。</p><p><br><br><br></p><h2 id="数据库战略"><a href="#数据库战略" class="headerlink" title="数据库战略"></a>数据库战略</h2><p>如何选择一个对于大量的互联网架构来说都能够运转良好的架构。</p><p><br></p><h3 id="架构需求"><a href="#架构需求" class="headerlink" title="架构需求"></a>架构需求</h3><p>最好定义你的需求，特别是，把那些超出你的范围从而成为别人的问题的内容写成文档。</p><p><br></p><h3 id="有把握的架构"><a href="#有把握的架构" class="headerlink" title="有把握的架构"></a>有把握的架构</h3><p>以下数据库架构，是比较有把握的。</p><p><br></p><ul><li><p><strong>单主服务器，多从服务器</strong><br>这种主-从架构很难自动实现主服务器的故障转移，因为主服务器和从服务器的配置是不一样的，所以，一旦主服务器失效，则必须手动进行失效转移。</p></li><li><p><strong>主服务器-主服务器复制，外加从服务器</strong><br>这种方式实际上与一台主服务器加多台从服务器的架构一样，但有时候主服务器本身也成为从服务器。这种架构的优点是，在协同的主服务器之间更容易实现失效转移和失效转回。缺点是，向两台主服务器进行写入存在风险，会导致数据库存在某种不一致性，也很难解决。</p></li><li><p><strong>功能分区</strong><br>随着应用的增长，将应用中某些部分转移到特定的服务器或特定集群上。</p></li><li><p><strong>失效转移和负载均衡</strong><br>使用负载均衡器，或者浮动的虚拟IP地址。</p></li><li><p><strong>ACID仍然是有意义的</strong><br>高可用性要求快速而可靠的灾难恢复。</p></li><li><p><strong>使用正确的工具</strong><br>不要使数据库处于关键路径上，不要讲应用程序的静态信息放入数据库中。数据库应该存储数据，而非应用程序本身。将数据库简单化，因为这是最难于伸缩，也是最昂贵的资源。但是，对于Web应用，还是应该分离应用程序和数据库，将数据库仅用来存储和检索数据。</p></li></ul><p><br></p><h3 id="有风险的架构"><a href="#有风险的架构" class="headerlink" title="有风险的架构"></a>有风险的架构</h3><p>建议不要使用这些架构</p><p><br></p><ul><li><p><strong>分片</strong><br>除非不得已，不要分片。<br>对于一个中等规模的应用，将其构建在数百台低档机器的分片架构上，试图提供无线伸缩能力，是非常愚蠢的。其实，只需购买几台足够好的机器，在工程上多做一些考虑就足够了。<br>分片架构比你预想要昂贵的多，甚至在短期内也是如此，长期则一定如此<br>分片问题设计过度设计的风险</p></li><li><p><strong>写入多台主服务器</strong><br>不要将多台服务器配置为可写，这会造成数据一致性问题。非常麻烦。</p></li><li><p><strong>多级复制</strong><br>尽量不要使用多级复制。<br>使用一主多从而不是从的从的从服务器，要简单的多。孙子辈的从服务器和重孙辈的从服务器很难管理。</p></li><li><p><strong>环形复制</strong><br>避免使用环形复制，其失效情形，不管是数量还是复杂度，都打得超乎想象。</p></li><li><p><strong>依赖于DNS</strong><br>DNS很脆弱，依赖DNS最终会自食苦果。</p></li></ul><p><br><br><br></p><h2 id="数据库战术"><a href="#数据库战术" class="headerlink" title="数据库战术"></a>数据库战术</h2><p>数据库战术，即为保持数据库基础架构的可靠性而做的日常运维任务。</p><p><br></p><h3 id="在从服务器上做备份"><a href="#在从服务器上做备份" class="headerlink" title="在从服务器上做备份"></a>在从服务器上做备份</h3><p>一些小提示：</p><ul><li>在备份上不要拖延，做备份其实并不难</li><li>做事不要追求完美，而要追求可恢复</li><li>至少对于可接受的数据损失、可接受的宕机时间、数据持续策略以及安全需求要形成文档</li><li>对恢复过程要进行练习并形成文档，恢复比备份要重要的多</li><li>对于备份成功与否，要进行外部验证，不要依赖于作业自身对你的提示</li></ul><p>可以专门配置一台复制(备份)从服务器，将复制延迟一段时间——如30min，以避免主服务器上的某些误操作——如<code>DROP table</code>。</p><p><br></p><h3 id="在线模式修改"><a href="#在线模式修改" class="headerlink" title="在线模式修改"></a>在线模式修改</h3><p>将表做的小一点是很有好处的。</p><p>一般的想法是设置主-主复制对，但只有一台服务器可写。在只读上执行更新，但不要复制到可写服务器上。更新一旦完成，则用正常方式使应用程序实现失效转移。这样，读和写便实现了角色转换。然后在另一台服务器上重复执行风险。这就实现了对应用程序隐含宕机时间的目的。</p><p><br></p><h3 id="监控和图示"><a href="#监控和图示" class="headerlink" title="监控和图示"></a>监控和图示</h3><p>构建用于测量和监控的系统是很值得做的事情，这些系统是基础架构非常重要的核心内容。</p><p><br></p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>一般步骤是，在产生麻烦的时间内手机详细的诊断数据，消除掉可能的原因，集中在问题的现象上。<br>问题往往是服务器产生大量负载，而这通常是由于糟糕的查询产生的。</p><p>MySQL所谓的慢查询日志(slow query log)可以回答这个问题，不仅是因为日志收集了慢查询的信息，而且对于每个查询还有时间信息。</p><p>加入性能问题不是查询引起的，则需要对MySQL本身进行性能测试。</p><p><br></p><h3 id="归档和删除数据"><a href="#归档和删除数据" class="headerlink" title="归档和删除数据"></a>归档和删除数据</h3><p>从一开始就要规划归档和删除不活动或不需要的数据，这样有助于减小“工作集”的大小。</p><ul><li>将极不活跃的用户数据移动到慢速服务器，或仅仅将用户设置为过期。当用户登录或重新激活时，在倒回到正常表中</li><li>另外一类可归档或删除的数据是陈旧的历史数据，或将历史数据移到另外的服务器上</li></ul><p><br><br><br></p><h2 id="结语-4"><a href="#结语-4" class="headerlink" title="结语"></a>结语</h2><p>尽最大可能将数据库架构建立在逻辑的基础上，而不是做一些看起来很酷的事情。</p><p>努力使系统保持小巧，不要大——而当不得不变大时，也要保持在能够掌控的范围内。要确定应用程序的真正需求，尽可能满足这些需求。要尽早及经常做缓存，但不要尽早及经常做分片。</p><p>最重要的，请记住：<strong>做备份</strong>。</p><p><br><br><br></p><hr><p><br></p><h1 id="如何优雅地失败：事后处理的艺术与科学"><a href="#如何优雅地失败：事后处理的艺术与科学" class="headerlink" title="如何优雅地失败：事后处理的艺术与科学"></a>如何优雅地失败：事后处理的艺术与科学</h1><p>宕机意味着实际的金钱损失。<br>客户才不会管这些故障，他们要的就是可靠性。互联网已经变得非常重要，宕机成本也越来越高。</p><p>但正如一个刚毕业的年轻人一样，只是知道你需要成长，但并没有告诉你如何去成长。我们需要将失败转化为学习经验。</p><p>保证网站稳定的首要事情，就是建立一个系统化的事后分析过程。通过阻止事故的重现以及改进处理事故的方法，使得系统稳定之后，事后分析能够让你全面地理解事故的本性。</p><p>例行的时候分析，是对运维的复杂问题进行科学分析的最贴近的方法。通过收集实际证据，可将有限的资源集中于解决产生问题的实际原因上。</p><p><br><br><br></p><h2 id="什么是事后分析"><a href="#什么是事后分析" class="headerlink" title="什么是事后分析"></a>什么是事后分析</h2><p>事后分析至少要包含这些内容：</p><ul><li>事故描述</li><li>根本原因描述</li><li>事件是如何修复的</li><li>用于解决事故的行动的时间表</li><li>事故是如何影响用户的</li><li>纠正或改正动作</li></ul><p>事后分析时，与事故明显有关的人员都要同时到场，对事故的真实情况作出共同的描述，从而正确地采取行动。</p><p>减少事故的修复时间，就跟消除事故本身一样重要。</p><p>对问题赋予严重级别，将帮助你按照轻重缓急来处理纠正项，而且对于活跃事件的评估也是有用的。</p><p>事故严重级别：</p><ul><li>严重影响大批用户</li><li>网站降级运行、性能问题或很难应对的功能故障</li><li>对客户影响不大或易于应对</li></ul><p><br><br><br></p><h2 id="什么时候引入事后分析"><a href="#什么时候引入事后分析" class="headerlink" title="什么时候引入事后分析"></a>什么时候引入事后分析</h2><p>在事故处理完成之后，就应该进行事故分析。事后分析过程应该最终使用户获益，而不应该在恢复服务的过程中进行。</p><p><br><br><br></p><h2 id="进行事后分析"><a href="#进行事后分析" class="headerlink" title="进行事后分析"></a>进行事后分析</h2><p>开始事后分析时，要明确基本规则，要明确告知参与事后分析的相关各方，事后分析不是指责谁(人们害怕这样的会议变成政治迫害)，主要目的是为了使类似事件不在重复发生。问题不可避免，重要的是我们能够从错误中学到教训。<br>事情一旦清楚之后，就可以开始讨论为了使类似事情不在发生，需要做些什么。确保相关各方对各自领域都能得出补救的办法。但切记不可矫枉过正！</p><p>一旦有了一套纠正措施，要将其记录在案，包括执行人员和完成日期。</p><p><br><br><br></p><h2 id="事后分析的后续工作"><a href="#事后分析的后续工作" class="headerlink" title="事后分析的后续工作"></a>事后分析的后续工作</h2><p>对纠正措施必须进行追踪，直到执行完成。</p><p>一些网站可操作性：</p><ul><li>消除单点故障</li><li>容量规划</li><li>监控</li><li>发布管理</li><li>运维架构复审</li><li>配置管理</li><li>随时待命和提升过程</li><li>不稳定的组件</li></ul><p><br><br><br></p><h2 id="结语-5"><a href="#结语-5" class="headerlink" title="结语"></a>结语</h2><p>最后，对于避免事故的发生，事后分析是最有用的方法。在一个快速变化的环境中，发生问题时可以理解的，但问题重复发生却是不能原谅的。花些时间高清楚问题的实质，从而确定、记录以及实施高强度的纠正措施，就可以避免事故的重复发生。</p><p><br><br><br></p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>数据是一项最重要、不可替代的商业资产。</p><p><br></p><h2 id="数据资产的库存"><a href="#数据资产的库存" class="headerlink" title="数据资产的库存"></a>数据资产的库存</h2><p>在开始一项新的存储工作时，首要的事情是要知道数据存在哪里。<br>对于不了解的数据，你是无法进行保护的。</p><p><br><br><br></p><h2 id="数据的保护"><a href="#数据的保护" class="headerlink" title="数据的保护"></a>数据的保护</h2><p>数据保护对所有系统都是很重要的。<br>良好的数据保护实践有助于处理范围广泛的情形，从还原被用户偶然删除的文件，到从灾难事件中恢复。</p><p>为了对数据中心问题提供完全的防护，重要的是将关键数据复制到不同的地点。</p><p>如今大多数的存储系统都有某种类型的复制技术。复制通常有两种形式：同步和异步。</p><p><br><br><br></p><h2 id="容量规划"><a href="#容量规划" class="headerlink" title="容量规划"></a>容量规划</h2><p>在确保有效的的数据保护之后，作为一名存储专业人员，容量规划就是第二项最重要的职责。<br>规划在前，确保应用和服务有足够的资源来运行和成长，不至于碰到天花板，这是必须的。</p><p>总是确保有足够的空间以应对突然的爆炸性增长，以及软件开发方面出现的延迟。</p><p><br><br><br></p><h2 id="存储大小的变化"><a href="#存储大小的变化" class="headerlink" title="存储大小的变化"></a>存储大小的变化</h2><p>存储是很昂贵的，这是现代基础框架中成本最高的组件。正是由于这个原因，对于存储上的开支进行明智地规划是很重要的。</p><p>存储需求要点：</p><ul><li>应用是什么</li><li>应用位于哪里</li><li>存储的是什么类型的数据</li><li>需要共享存储吗</li><li>是否需要特殊的访问协议</li><li>典型的文件大小是多少</li><li>数据是压缩的吗</li><li>如果描述工作负载</li><li>需要批处理操作吗</li><li>工作负荷是大部分用于读、写、读写</li><li>工作负荷是大部分顺序、还是大部分随机、还是两者</li><li>快照是怎么安排的</li><li>快照的一致性问题</li><li>存储容量在6个月、12个月、18个月的计划是什么</li><li>工作负荷在6个月、12个月、18个月的计划是什么</li><li>复制策略是什么</li><li>业务连续性规划是什么</li><li>可用性需求是什么</li><li>备份的频度是什么</li><li>备份保持的计划是什么样的</li><li>归档策略是什么</li><li>综合性需求是什么</li><li>加密需求是什么</li><li>…</li></ul><p><br><br><br></p><h2 id="结语-6"><a href="#结语-6" class="headerlink" title="结语"></a>结语</h2><p>数据是最宝贵的业务资产，且是不可替换的。</p><p><br><br><br></p><hr><p><br></p><h1 id="非关系数据库"><a href="#非关系数据库" class="headerlink" title="非关系数据库"></a>非关系数据库</h1><p>应用的数据存储层的伸缩是很难的。不管用的是什么数据库技术，随着数据量和事务数量的增长，就需要做出改变以适应新的负荷。</p><p>SQL数据库的可伸缩性通常归结为四件事：<strong>缓存、查询优化、购买新硬件、数据库分片。</strong></p><p><br><br><br></p><h2 id="NoSQL数据库概览"><a href="#NoSQL数据库概览" class="headerlink" title="NoSQL数据库概览"></a>NoSQL数据库概览</h2><p>NoSQL共生系统，可将数据库划分为5大类：</p><ul><li>纯粹的键值</li><li>数据结构</li><li>图</li><li>面向文档</li><li>高度分布</li></ul><p>每种类别的数据库都面向不同的应用情况，每个类别也都做了不同的这种。</p><p><br><br><br></p><h3 id="纯粹的键值"><a href="#纯粹的键值" class="headerlink" title="纯粹的键值"></a>纯粹的键值</h3><p>如： Tokyo Cabinet、 Kyoto Cabinet、MemcacheDB</p><p>正是它们的简单性定义了这组数据库。向数据库存入一个键和一个值，然后用同一个键查询数据库，则会得到相同的值。没有结构或类型系统——通常所处理的只是字节或字符串。因为这种简单性，这些数据库的开销极小，所以非常块。事实上，这些数据库通常都是实现为磁盘上的B树或哈希表。</p><p><br><br><br></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构数据库对键值数据库做了些修改，数据结构数据库将其存储为特定的数据结构，如<strong>列表、集合、哈希表等。</strong>有了这些附加的结构，就可以对值执行一些原子操作。可以对数据库执行在应用程序中对数据结构进行的各种操作。</p><p>Redis默认是在内存中(in memory)存储其全部内容，只是周期性地将内容的快照存储到磁盘。这使得Redis出奇的快，但假如数据库奔溃了，就会对数据造成一些损失，同时也意味着必须有足够的RAM存储这个数据库。</p><p><br><br><br></p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图数据库几乎就是数据结构数据库的一个特定实现，因为图本就是一种数据库。区别是图数据库不再是基于键值，数据是作为图的节点和边存储的。图数据库不是用键来查询值，而是给出根节点的句柄，然后就可以遍历整个图以找到需要的节点或边。</p><p>图数据库的优势：存储图或树形的数据。如一个社交图(social graph)。</p><p>常见图数据库包含：<strong>Neo4j、HyperGraphDB、InfoGrid、VertexDB。</strong></p><p><br><br><br></p><h2 id="面向文档"><a href="#面向文档" class="headerlink" title="面向文档"></a>面向文档</h2><p>面向文档的数据库又类似于键值数据库，但值不再是字节、字符串、列表、集合，而是<strong>文档</strong>。<br>文档作为JSON(BSON)对象存储，本质上是一种哈希表或字典。这些值都想相同的结构，意味着可以用查询来探测这种结构，并只返回所需要的文档。这种查询能力是建立在通过键来查找文档的能力之上的。</p><p>常见面向文档数据库： <strong>MongoDB、CouchDB</strong>。</p><p><br><br><br></p><h3 id="高度分布"><a href="#高度分布" class="headerlink" title="高度分布"></a>高度分布</h3><p>高度分布的数据库多少有些不同——有些本质上更接近于键值存储，其它则像大型的多维哈希图。</p><p><strong>HBase、Cassandra</strong>是高度分布式数据库。</p><p><br><br><br></p><h2 id="某些细节"><a href="#某些细节" class="headerlink" title="某些细节"></a>某些细节</h2><p>注意这些数据库之间的一些相似性，以及所做决策是如何影响系统可操作性的。</p><p><br><br><br></p><h3 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h3><p>Cassandra是一个高度分布数据库。</p><p>它有一些关键概念：</p><ul><li>认为写比读更难于伸缩，所以它专门为写操作做了大量优化</li><li>认为不应该存在单一故障点<br>任何数据可以写入到集群内的任何一个节点，而且读也一样。任何接收到请求的节点都可以，并且将会吧请求转发到合适的节点。</li></ul><p><br><br><br></p><h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><p>HBase选择一致性和可用性作为自己的核心价值。这样的结果，导致了在某些网段、集群无法实现优雅的恢复。作为这种牺牲的补偿，HBase有很强的一致性，保证写入一结束，写入的值就立即可以读取。</p><p><br><br><br></p><h3 id="Riak"><a href="#Riak" class="headerlink" title="Riak"></a>Riak</h3><p>Riak实现了向量时钟(vector clocks)，一些高度分布的数据库都没有实现——这些数据库选择了依赖于更为简单的基于时间戳的技术。</p><p>向量时钟是一种分布式系统中的机制，用于生成偏序事件。使用向量时钟，解决发生在两个独立的不同节点中的相同值的冲突就变得非常简单。从Riak客户端的角度来看，每个客户实例在Riak集群中执行一个动作时，都应该有一个唯一的标识(token)(连同其接收到的向量时钟一起)。然后，客户读取数据时，就可以看到向量时钟和数据值，使用包含的信息连接两个结果，从而将正确的版本写会数据库。</p><p>Riak也不存在单一故障点。</p><p><br><br><br></p><h3 id="CouchDB"><a href="#CouchDB" class="headerlink" title="CouchDB"></a>CouchDB</h3><p>CouchDB对世界的看法是一致的：所有东西都是文档，而且都通过RESTful HTTP来访问。<br>CouchDB可以在数据库中直接存储静态媒体，它实际上是允许将整个应用程序都存储在数据库中的。<br>CouchDB的数据模型很新颖，即数据以一种只附加的B树进行存储。</p><p><br><br><br></p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>MongoDB是一个面向文档的数据库，文档格式使用BSON——一种类似于JSON对象的二进制规范。MongoDB是用C++写的，因而有很高的性能。</p><p>所有能用SQL做的事情也能用MongoDB查询表达式来做。<br>MongoDB与以SQL数据库相同的方式支持索引，同时这些索引也强制了唯一性。</p><p>MongoDB有一个<code>mongostat</code>命令来查看数据库状态。</p><p>有好几种MongoDB备份方式：</p><ul><li>停掉数据库，复制数据文件</li><li>锁定数据库写入，复制数据文件，解除锁定</li><li>使用<code>mongodump</code>，将数据库转存到一个二进制文件中</li><li>可以设置一个从服务器，在从服务器上进行备份，而不是主服务器上</li></ul><p><br><br><br></p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis(remote dictionary server)，远程字典服务器。通过<code>INFO</code>可查看相关信息。</p><p>不管你将Redis运行在快照模式(rdb)还是只附加模式(aof)上，都可以简单地调用<code>rsync</code>实现备份。</p><p><br><br><br></p><hr><p><br></p><h1 id="如何高枕无忧"><a href="#如何高枕无忧" class="headerlink" title="如何高枕无忧"></a>如何高枕无忧</h1><p>企业持续规划(Business Continuity Planning)BCP。<br>BCP简单最简单来说，就是<strong>什么都是两份</strong>。当然，两套设备间的失效转移必须完全自动化。</p><p><br><br><br></p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>集中于BCP计划的高可用部分：保证站点正常工作。即使在高可用性领域，也有各种各样的技术，从<strong>热/热(Hot/Hot)、热/暖(Hot/Warm)、热/冷(Hot/Cold)到灾难恢复</strong>。</p><ul><li>热/热是高可用性的最高级别。用户可以从任意的数据中心使用全部的应用程序。读和写可以发生在任何地方。折让自动的故障转移变得非常简单，但它不是万能的。你想必须思考如何处理数据一致性的问题。</li><li>热/暖是一种很好的方式，如果你不能容忍数据的不一致性的话。很多应用有大量的读操作，仅偶尔写一下(但很重要)。在这种情况下，区别处理这两种操作是有意义的。</li><li>热/冷让我害怕。这种架构将读写流量送到单一地点，而让另一个相同的部署在遥远的地平线上闲置。它容易建立，但价值很低。</li><li>灾难恢复是最差的技术，本质上是雾件(vaporware)。它的本意不是在平常的时候保护你，而是在大的灾难发生时给你提供重建的选项。</li></ul><p><br><br><br></p><h2 id="影响持续时间对事件持续时间"><a href="#影响持续时间对事件持续时间" class="headerlink" title="影响持续时间对事件持续时间"></a>影响持续时间对事件持续时间</h2><p>当灾难来袭时，所有你需要考虑的是将用户流量以最快速度转移，离开问题区域。你需要立即降低影响。不要过于担心根源问题的修复，一旦将影响制止住，会有很多时间来解决这次事故。</p><p>怎样才能将流量从问题站点转出呢？通常方案是使用<strong>全局负载均衡(Global Server Load Balancing)GSLB</strong>。这实际是一个动态的授权DNS服务器，他能够根据相关因素对同一域名给出不同的IP地址。</p><p><br><br><br></p><h2 id="数据中心数量"><a href="#数据中心数量" class="headerlink" title="数据中心数量"></a>数据中心数量</h2><p>我们知道数据中心会失效，所以你至少需要两个。这就够了吗？三个或更多是不是会好一些？这取决于三个因素，<strong>成本、复杂性和性能</strong>。</p><p><br><br><br></p><h2 id="逐渐失效"><a href="#逐渐失效" class="headerlink" title="逐渐失效"></a>逐渐失效</h2><p>当数据中心出现局部问题(partial problem)时，不要等它解决从而希望你不需要撤离，立即导出复制数据！</p><p><br><br><br></p><h2 id="不信赖任何人"><a href="#不信赖任何人" class="headerlink" title="不信赖任何人"></a>不信赖任何人</h2><p>正如最可靠的数据中心也会时不时宕机，你可以预期即使最好的第三方供应商，偶尔也会有问题。就是你不能完全信赖一个服务提供商。</p><p><br><br><br></p><h2 id="故障测试转移"><a href="#故障测试转移" class="headerlink" title="故障测试转移"></a>故障测试转移</h2><p>通过早期和经常的测试，获取经验，以便当灾难袭来时，不会手忙脚乱，而是立即做出正确的事情。</p><p><br><br><br></p><h2 id="监控和历史模式"><a href="#监控和历史模式" class="headerlink" title="监控和历史模式"></a>监控和历史模式</h2><p>你要知道日、周、月的流量模式。如果清楚正常流量中的不寻常处，你就不会在切换、迁移或升级时感到惊讶。确保监控包括周对周的图形和趋势。</p><p><br><br><br></p><h2 id="高枕无忧"><a href="#高枕无忧" class="headerlink" title="高枕无忧"></a>高枕无忧</h2><p>如果你能够事先有计划，能够解决大的问题，并且在日常工作中操练故障转移，则平台任何部分的失效将会变成容易处理的事件，而不是危机。</p><p><br><br><br></p><hr><p><br></p><p>March 25, 2018 11:32 AM</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《网站运维：保持数据实时的秘籍》(Web Operations: Keeping the Data on Time)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Database" scheme="https://zhang21.github.io/tags/Database/"/>
    
      <category term="Operations" scheme="https://zhang21.github.io/tags/Operations/"/>
    
  </entry>
  
  <entry>
    <title>《经济学原理》读书笔记</title>
    <link href="https://zhang21.github.io/2018/02/23/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://zhang21.github.io/2018/02/23/经济学原理读书笔记/</id>
    <published>2018-02-23T08:13:58.000Z</published>
    <updated>2018-02-25T11:24:49.684Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>《经济学原理-微观/宏观》，曼昆： <a href="https://book.douban.com/subject/26435630/" target="_blank" rel="noopener">https://book.douban.com/subject/26435630/</a></li></ul><p><br><br><br></p><a id="more"></a><hr><p><br></p><h1 id="微观经济学"><a href="#微观经济学" class="headerlink" title="微观经济学"></a>微观经济学</h1><p>阿尔弗雷德·马歇尔在《经济学原理》中写道<strong>经济学是一门研究人类一般生活事务的学问</strong>。</p><p>应当学习经济学的原因如下：</p><ul><li>有助于你理解你所生活在其中的世界</li><li>使你更加精明的参与经济</li><li>使你更好地理解经济政策的潜力与局限性</li><li>经济学原理可以运用到生活中的方方面面</li></ul><p><br></p><p>经济学领域的伟大洞见，如亚当·斯密的<strong>看不见的手</strong>的概念、大卫·李嘉图的<strong>比较优势原理</strong>，以及约翰·梅纳德·凯恩斯的<strong>总需求理论</strong></p><p><br><br><br></p><hr><p><br></p><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p><br></p><h3 id="经济学十大原理"><a href="#经济学十大原理" class="headerlink" title="经济学十大原理"></a>经济学十大原理</h3><p><strong>经济(economy)</strong>这个词来源于希腊语oikonomos，意思是“管理一个家庭的人”。</p><p>一个家庭面临着许多决策，同样，一个社会也面临着许多决策。</p><p><br></p><p>由于资源是稀缺的，社会资源的管理就尤为重要。</p><ul><li><strong>稀缺性(scarcity):</strong><ul><li>社会资源的有限性</li></ul></li><li><strong>经济学(economics):</strong><ul><li>研究社会如何管理自己的稀缺资源</li></ul></li></ul><p><br></p><h4 id="人们如何做出决策"><a href="#人们如何做出决策" class="headerlink" title="人们如何做出决策"></a>人们如何做出决策</h4><p>由于一个经济的行为反映了组成这个经济的个人的行为，所以个人就需要做出决策。</p><p><br></p><h5 id="人们面临权衡取舍"><a href="#人们面临权衡取舍" class="headerlink" title="人们面临权衡取舍"></a>人们面临权衡取舍</h5><ul><li><strong>效率(efficiency):</strong><ul><li>社会能从其稀缺资源中得到最大利益的特性</li></ul></li><li><strong>平等(equlity):</strong><ul><li>经济成果在社会成员中平均分配的特性</li></ul></li></ul><p><br></p><p>作出决策就是要求我们在一个目标与另一个目标之间进行权衡取舍。</p><p>当人们组成社会时，他们会面临不同的权衡取舍。经典的权衡取舍是在<strong>大炮与黄油</strong>之间。</p><p>社会面临的另一种权衡取舍是在效率与平等之间。</p><p>然而，认识到人们面临权衡取舍本身并没有告诉我们人们将会或应该做出什么决策。</p><p><br></p><h5 id="某种东西的成本是为了得到这种东西所放弃的东西"><a href="#某种东西的成本是为了得到这种东西所放弃的东西" class="headerlink" title="某种东西的成本是为了得到这种东西所放弃的东西"></a>某种东西的成本是为了得到这种东西所放弃的东西</h5><ul><li><strong>机会成本(opportunity cost):</strong><ul><li>为了得到某种东西所必须放弃的东西</li></ul></li></ul><p><br></p><p>由于人们面临着权衡取舍，所以做决策就需要比较可供选择的行动方案的成本与收益。</p><p><br></p><h5 id="理性人考虑边际量"><a href="#理性人考虑边际量" class="headerlink" title="理性人考虑边际量"></a>理性人考虑边际量</h5><ul><li><strong>理性人(rational people):</strong><ul><li>系统而有目的地尽最大努力实现其目标的人</li></ul></li><li><strong>边际变动(marginal change):</strong><ul><li>对行动计划的微小增量调整</li></ul></li><li><strong>边际成本(marginal cose):</strong><ul><li>对行动计划调整所带来的成本</li></ul></li><li><strong>边际收益(marginal benefit):</strong><ul><li>对行动计划调整所带来的的收益</li></ul></li><li><strong>边际决策(marginal decision):</strong><ul><li>选择哪种决策</li></ul></li></ul><p><br></p><h5 id="人们会对激励做出反应"><a href="#人们会对激励做出反应" class="headerlink" title="人们会对激励做出反应"></a>人们会对激励做出反应</h5><ul><li><strong>激励(incentive):</strong><ul><li>引起一个人做出某种行为的某种东西</li></ul></li></ul><p><br></p><p>在经济学研究中，激励起着中心作用。</p><p>市场上的高价格提供了买者少消费而卖者多生产的激励。<br>价格对消费者和生产者行为的影响对于市场经济如何配置稀缺资源是至关重要的。</p><p>政府决策者决不能忘记激励，因为许多政策改变了人们面临的成本或收益，从而也改变了人们的行为。</p><p>在分析任何一种政策时，我们不仅应该考虑它的直接影响，而且还应该考虑它通过激励产生的不太明显的间接影响。如果政策改变了激励，那就会使人们改变自己的行为。</p><p><br></p><h4 id="人们如何互相影响"><a href="#人们如何互相影响" class="headerlink" title="人们如何互相影响"></a>人们如何互相影响</h4><p>我们的许多决策不仅影响了我们自己，还会影响其他人。</p><p><br></p><h5 id="贸易可以使每个人的状况都变得更好"><a href="#贸易可以使每个人的状况都变得更好" class="headerlink" title="贸易可以使每个人的状况都变得更好"></a>贸易可以使每个人的状况都变得更好</h5><p>思考国家之间的竞争的想法很容易产生误导。美国与中国之间的贸易并不像体育比赛一样，一方赢而另一方输。实际上，事实正好相反：两国之间的贸易可以使两个国家的状况都变得更好。</p><p>贸易使每个人都可以专门从事自己最擅长的活动，无论它是耕种、做衣服还是盖房子。通过与其他人的贸易，人们可以以较低的成本获得各种各样的物品和服务。</p><p>国家和家庭一样，也能从相互贸易中获益。贸易可以使各国可以专门从事自己最擅长的活动，并享有种类更多的物品与服务。美国人和英国人、法国人一样，在世界经济中既是我们的竞争对手，又是我们的伙伴。</p><p><br></p><h5 id="市场通常是组织经济活动的一种好方法"><a href="#市场通常是组织经济活动的一种好方法" class="headerlink" title="市场通常是组织经济活动的一种好方法"></a>市场通常是组织经济活动的一种好方法</h5><ul><li><strong>市场经济(market economy):</strong><ul><li>当许多企业和家庭在物品与服务市场上相互交易时，通过他们的分散决策配置资源的经济</li></ul></li><li><p><strong>看不见的手(invisible hand):</strong></p></li><li><p><strong>利己心(self-interest):</strong></p></li></ul><p><br></p><p>中央计划经济国家运行的前提假设是，政府官员能够最佳地配置经济中稀缺资源。这些中央计划者决定，生产什么物品与服务、生产多少，以及谁生产和消费这些物品与服务。支撑中央计划经济的理论是，只有政府才能以促进整个社会经济福利的方式组织经济活动。</p><p>大部分曾经是中央计划经济的国家已经放弃了这个制度，代之以发展市场经济。在市场经济中，中央计划者的决策被数千百万企业和家庭的决策所取代。</p><p><br></p><p>在市场经济中，没有一个人追求整个社会的经济福利。自由市场包括大量物品与服务的许多买者与卖者，而所有的人都主要关心自己的福利。</p><p>经济学家亚当·斯密在《国富论》中提出了全部经济学中最著名的观察结果：“家庭和企业在市场上相互交易，他们仿佛被一只<strong>看不见的手</strong>所指引，并导致了合意的市场结果。”</p><p>价格就是看不见的手用来指引经济活动的工具。作为买者与卖者决策的结果，市场价格既反映了一种物品的社会价值，也反映了生产该物品的社会成本。斯密的重要洞察是，价格会自发调整，指引这些单个买者和卖者达到某种结果，该结果在大多数情况下会实现整个社会福利的最大化。</p><p>斯密的观点有一个重要的推论：当政府阻止价格根据供求状况自发调整时，它就限制了看不见的手对组成经济的千百万家庭和企业的决策进行协调的能力。这个推论解释了为什么税收对资源配置有不利的影响：由于税收扭曲了价格，从而也扭曲了家庭和企业的决策。这个推论还解释了像租金控制这类直接控制价格的政策所引起的巨大危害。而且，这个推论解释了中央计划经济的失败。在中央计划经济国家，价格并不是在市场上决定的，而是由中央计划者规定的。这些计划者缺乏关于消费者爱好和生产者成本的必要信息，而在市场经济中这些信息都反映在价格上。中央计划者之所以失败，是因为他们在管理经济时把市场这只看不见的手绑起来了。</p><p>亚当·斯密描述了市场经济中人们如何相互影响：</p><blockquote><p>人类几乎随时随地都需要同胞的协助，要想仅仅依赖他人的恩惠，那是绝对不行的。他如果能够刺激他人的利己心，使其有利于他，并告诉其他人，给他做事是对他们自己有利的，那么他要达到目的就容易得多了。··· ···请给我们我所要的东西吧，同时，你也可以获得你所要的东西：这句话是交易的通义。我们所需要的相互帮助，大部分是依照这个方法取得的。<br>我们每天所需的食物和饮料，不是出自屠户、酿酒师或面包师的恩惠，而是出自他们利己的打算。我们不说唤起他们利他心的话，而说唤起他们利己心得话。我们不说自己有需要，而说对他们有利。社会上，除乞丐外，没有一个人愿意全然靠别人的恩惠过活… …<br>每一个人··· ···既不打算促进公共的利益，也不知道自己是在何种程度上促进那种利益··· ···他所盘算的也只是他自己的利益。在这种场合下，像在其他许多场合一样，他受着一只看不见的手的引导，去尽力达到一个并非他本意想要达到的目的。也并不因为不是出于本意，就对社会有害。他追求自己的利益，往往使他能比在真正处于本意的情况下更有效地促进社会的利益。</p></blockquote><p>斯密是说，经济参与者受利己心所驱动，而市场上这只看不见的手指引这种利己心去促进总体的经济福利。</p><p><br></p><h5 id="政府有时可以改善市场结果"><a href="#政府有时可以改善市场结果" class="headerlink" title="政府有时可以改善市场结果"></a>政府有时可以改善市场结果</h5><ul><li><strong>产权(property rights):</strong><ul><li>个人拥有并控制稀缺资源的能力</li></ul></li><li><strong>市场失灵(market failure):</strong><ul><li>市场本身不能有效的配置资源的情况</li></ul></li><li><strong>外部性(externality):</strong><ul><li>一个人的行为对旁观者福利的影响</li><li>外部性的经典例子是污染</li></ul></li><li><strong>市场势力(market power):</strong><ul><li>单个经济活动者(或某个经济活动小群体)对市场价格有显著影响的能力</li></ul></li></ul><p><br></p><p>我们需要政府的原因之一是：只有在政府实施规则并维持对市场经济至关重要的制度时，看不见的手才能施展其魔力。最重要的是，市场经济需要实施产权制度，以便个人可以拥有和控制稀缺资源。<br>我们都依靠政府提供的警察和法律来实施我们对自己生产出来的东西的权利——而看不见的手依靠我们实施自己权利的能力。</p><p>然而，我们需要政府的另一个原因是：看不见的手是强有力的，但并不是无所不能的。政府干预经济并改变人们自己选择的资源配置的原因有两类：<strong>促进效率</strong>和<strong>促进公平</strong>。这就是说，大多数政策的目标要么是把经济蛋糕做大，要么是改变这个蛋糕的分割方式。</p><p>在存在外部性或市场势力的情况下，设计良好的公共政策可以提高经济效率。</p><p>即使看不见的手带来了有效率的产出，他也不能消除经济福利上巨大的不对称。根据某种政治哲学，这种不平等要求政府进行干预。实际上，许多公共政策，例如所得税和福利制度的目标就是要实现更平等的经济福利分配。</p><p>我们说政府有时可以改善市场结果并不意味着它总会这样。公共政策并不是天使制定的，而是由不完善的政治程序制定的。有时所设计的政策只是为了有利于政治上有权势的人；有时政策是由动机良好但信息不充分的领导人制定的。</p><p><br></p><h4 id="整体经济如何运行"><a href="#整体经济如何运行" class="headerlink" title="整体经济如何运行"></a>整体经济如何运行</h4><p>决策和相互影响共同组成了<strong>经济</strong>。</p><p><br></p><h5 id="一国的生活水平取决于它生产物品与服务的能力"><a href="#一国的生活水平取决于它生产物品与服务的能力" class="headerlink" title="一国的生活水平取决于它生产物品与服务的能力"></a>一国的生活水平取决于它生产物品与服务的能力</h5><ul><li><strong>生产率(productivity):</strong><ul><li>每单位劳动投入所生产的物品与服务数量</li></ul></li></ul><p><br></p><p>世界各国生活水平的差别是惊人的。<br>随着时间的推移，生活水平的变化也是巨大的。</p><p><strong>几乎所有的生活水平的差别都可以归因于各国生产率的差别。</strong></p><p>生产率和生活水平之间的基本关系是简单的，但它的意义却是深远的。如果生产率是生活水平的首要决定因素，那么，其他因素就应该是次要的。</p><p><br></p><h5 id="当政府发行了过多货币时，物价上升"><a href="#当政府发行了过多货币时，物价上升" class="headerlink" title="当政府发行了过多货币时，物价上升"></a>当政府发行了过多货币时，物价上升</h5><ul><li><strong>通货膨胀(inflation):</strong><ul><li>经济中物价总水平的上升</li></ul></li></ul><p><strong>在大多数严重或持续通货膨胀的情况下，罪魁祸首是货币量的增长。</strong></p><p>当一国政府发行了大量本国货币时，货币的价值就下降了。</p><p>由于高通货膨胀会让社会付出各种成本，所以世界各国的经济政策制定者都把保持低通货膨胀作为目标之一。</p><p><br></p><h5 id="社会面临通货膨胀与失业之间的短期权衡取舍"><a href="#社会面临通货膨胀与失业之间的短期权衡取舍" class="headerlink" title="社会面临通货膨胀与失业之间的短期权衡取舍"></a>社会面临通货膨胀与失业之间的短期权衡取舍</h5><ul><li><strong>经济周期(business cycle):</strong><ul><li>就业和经济生产的波动</li></ul></li></ul><p><br></p><p>虽然在长期中，物价水平上升主要是货币增加的结果，但短期中，问题就变得更为复杂更具争议性。</p><p>大多数经济学家这样描述货币注入的短期效应：</p><ul><li>经济中货币量增加刺激了社会的整体支出水平，从而增加了对物品与服务的需求</li><li>需求的增量随着时间的推移，会引起企业提高物价，但同时，它也鼓励企业雇佣更多的工人，并生产更多的产品与服务</li><li>服用更多的工人意味着更少的失业</li></ul><p>你知道，支出链将以乘数扩大，并带来更高的收入和就业。人们看到了发生了的活动，但他们没有看到本来会发生的活动。</p><p><br></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><strong>经济学十大原理：</strong></p><ul><li>人们如何做出决策<ul><li>人们面临权衡取舍</li><li>某种东西的成本是为了得到它所放弃的东西</li><li>理性人考虑边际量</li><li>人们会对激励做出反应</li></ul></li><li>人们如何相互影响<ul><li>贸易可以使每个人的状况都变得更好</li><li>市场通常是组织经济活动的一种好方法</li><li>政府有时可以改善市场结果</li></ul></li><li>整体经济如何运行<ul><li>一国的生活水平取决于它生产物品与服务的能力</li><li>当政府发行了过多的货币时，物价上升</li><li>社会面临通货膨胀与失业之间的短期权衡取舍</li></ul></li></ul><p><br><br><br></p><hr><p><br></p><h3 id="像经济学家一样思考"><a href="#像经济学家一样思考" class="headerlink" title="像经济学家一样思考"></a>像经济学家一样思考</h3><p>每个研究领域都有自己的语言和思考方式。经济学家也一样。<br>供给、需求、弹性、比较优势、消费者剩余和无谓损失——这些术语也是经济学家语言的一部分。</p><p><br></p><h4 id="作为科学家的经济学家"><a href="#作为科学家的经济学家" class="headerlink" title="作为科学家的经济学家"></a>作为科学家的经济学家</h4><p>先提出理论，再收集数据，然后分析数据，以努力证明或否定他们的理论。</p><p><br></p><h5 id="科学方法：观察、理论和进一步观察"><a href="#科学方法：观察、理论和进一步观察" class="headerlink" title="科学方法：观察、理论和进一步观察"></a>科学方法：观察、理论和进一步观察</h5><p>在经济学研究中，进行实验往往是不可能的。通常不得不使用这个世界向他们提供的数据。</p><p>为了寻找实验室实验的替代品，经济学家十分关注历史所提供的自然实验。</p><p><br></p><h5 id="假设的作用"><a href="#假设的作用" class="headerlink" title="假设的作用"></a>假设的作用</h5><p>当我们在研究政策变动在长短不同时间中的影响时，就会做出不同的假设。</p><p><br></p><h5 id="经济模型"><a href="#经济模型" class="headerlink" title="经济模型"></a>经济模型</h5><p>经济学家也用模型来了解世界，但不是塑料模型，而通常是由图形和方程组成的模型。</p><p><br></p><h5 id="第一个模型：循环流量图"><a href="#第一个模型：循环流量图" class="headerlink" title="第一个模型：循环流量图"></a>第一个模型：循环流量图</h5><ul><li><strong>循环流量图(circular-flow diagram):</strong><ul><li>一个说明货币如何通过市场在家庭与企业之间流动的直观经济模型</li></ul></li><li><strong>生产要素(production factors):</strong><ul><li>劳动、土地、资本等投入品被称为生产要素</li></ul></li></ul><p><br></p><p>企业用生产要素来生产产品和服务，家庭则拥有生产要素并消费企业生产的物品与服务。家庭与企业之间相互交易。</p><p><br></p><h5 id="第二个模型：生产可能性边界"><a href="#第二个模型：生产可能性边界" class="headerlink" title="第二个模型：生产可能性边界"></a>第二个模型：生产可能性边界</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《经济学原理-微观/宏观》，曼昆： &lt;a href=&quot;https://book.douban.com/subject/26435630/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://book.douban.com/subject/26435630/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Economics" scheme="https://zhang21.github.io/categories/Economics/"/>
    
    
      <category term="Economics" scheme="https://zhang21.github.io/tags/Economics/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://zhang21.github.io/2018/02/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://zhang21.github.io/2018/02/08/正则表达式/</id>
    <published>2018-02-08T03:33:16.000Z</published>
    <updated>2018-02-24T10:43:37.352Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>《鸟哥的Linux私房菜》</li><li><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">正则表达式维基百科</a></li></ul><p><br><br><br></p><a id="more"></a><p><br></p><h1 id="正则表达式介绍"><a href="#正则表达式介绍" class="headerlink" title="正则表达式介绍"></a>正则表达式介绍</h1><p>正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法(Regular Expression, 在代码中常简写为regex、regexp或RE）。<br>是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p><p><br></p><p>正则表达式的POSIX规范，分为两大流派：</p><ul><li>基本型正则表达式（Basic Regular Expression，BRE）<ul><li><code>grep</code>、<code>vi</code>、<code>sed</code>都属于BRE，是历史最早的正则表达式，因此元字符必须转译之后才具有特殊含义</li></ul></li><li>扩展型正则表达式（Extended Regular Express，ERE）<ul><li><code>egrep</code>、<code>awk</code>则属于ERE，元字符不用转译</li></ul></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="正则表达式基本语法"><a href="#正则表达式基本语法" class="headerlink" title="正则表达式基本语法"></a>正则表达式基本语法</h1><p>一个正则表达式通常被称为一个模式（pattern），用来描述或者匹配一系列匹配某个句法规则的字符串。</p><p><br></p><p>大部分正则表达式有如下结构：</p><ul><li><strong>选择</strong><ul><li><code>|</code>竖线符代表选择(或)，具有最低优先级</li></ul></li><li><strong>数量限定</strong><ul><li>字符后的数量限定符用来限定前面这个字符允许出现的个数</li><li>不加数量限定则代表仅出现一次</li><li>常见的数量限定符包括 <strong>+</strong>、<strong>?</strong>、<strong>*</strong><ul><li><code>+</code>加号代表前面的字符必须至少出现一次 ( $$$&gt;=1$$$ )</li><li><code>?</code>问号代表前面的字符最多只可出现一次 ( $$$1&gt;=?&gt;=0$$$ )</li><li><code>*</code>星号代表前面的字符可不出现，也可出现一次或多次 ($$$&gt;=0$$$)</li></ul></li></ul></li><li><strong>匹配</strong><ul><li><code>()</code>圆括号可以定义操作符的范围和优先度</li></ul></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="PCRE表达式全集"><a href="#PCRE表达式全集" class="headerlink" title="PCRE表达式全集"></a>PCRE表达式全集</h1><p>正则表达式有多种不同的风格。<br>PCRE（Perl兼容正则表达式，Perl Compatible Regular Expression）。适用于Perl或者Python编程语言（grep或者egrep的正则表达式文法是PCRE的子集）</p><p><br></p><p><strong>基础正则表达式</strong></p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>转义字符</td></tr><tr><td>zhang</td><td>匹配文本字符串值<code>zhang</code></td></tr><tr><td>.</td><td>匹配除<code>\r</code>,<code>\n</code>之外的任何单个字符</td></tr><tr><td>竖线l</td><td>匹配竖线两边某一个</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次</td></tr><tr><td>{n}</td><td>n是一个非负整数。匹配n次</td></tr><tr><td>{n,}</td><td>n是一个非负整数。至少匹配n次</td></tr><tr><td>{n,m}</td><td>m和n均为非负整数，匹配n-m次</td></tr><tr><td>[xyz]</td><td>字符集合（character class）。匹配所包含的任意一个字符</td></tr><tr><td>[^xyz]</td><td>排除型字符集合（negated character classes）。匹配未列出的任意字符</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符</td></tr><tr><td>[^a-z]</td><td>排除型的字符范围。匹配任何不在指定范围内的任意字符</td></tr><tr><td>[:name:]</td><td>增加命名字符类（named character class）</td></tr><tr><td>[=elt=]</td><td>增加当前locale下排序（collate）等价于字符“elt”的元素</td></tr><tr><td>[.elt.]</td><td>增加排序元素（collation element）elt到表达式中。这是因为某些排序元素由多个字符组成</td></tr></tbody></table><p><br></p><p><strong>元字符</strong><br>元字符(meta character)，是一种Perl风格的正则表达式，只有一部分文本处理工具支持它。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置</td></tr><tr><td>\B</td><td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”</td></tr><tr><td>\cx</td><td>匹配由x指明的控制字符</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于[0-9]。注意Unicode正则表达式会匹配全角数字字符</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于[^0-9]</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于\x0c和\cL</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于\x0a和\cJ</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于\x0d和\cM</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于[^ \f\n\r\t\v]</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于\x09和\cI</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于\x0b和\cK</td></tr><tr><td>\w</td><td>匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。注意Unicode正则表达式会匹配中文字符</td></tr><tr><td>\W</td><td>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”</td></tr><tr><td>\ck</td><td>匹配控制转义字符。k代表一个字符。等价于“Ctrl-k”。用于ECMA语法</td></tr><tr><td>\xnn</td><td>十六进制转义字符序列。匹配两个十六进制数字nn表示的字符</td></tr><tr><td>\num</td><td>向后引用（back-reference）一个子字符串（substring），该子字符串与正则表达式的第num个用括号围起来的捕捉群（capture group）子表达式（subexpression）匹配。其中num是从1开始的十进制正整数，其上限可能是9[注 2]、31、[注 3]99甚至无限。[注 4]例如：“(.)\1”匹配两个连续的相同字符</td></tr><tr><td>\n</td><td>标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值</td></tr><tr><td>\nm</td><td>3位八进制数字，标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm</td></tr><tr><td>\nml</td><td>如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml</td></tr><tr><td>\un</td><td>Unicode转义字符序列。其中n是一个用四个十六进制数字表示的Unicode字符</td></tr></tbody></table><p><br></p><p><strong>扩展正则表达式</strong></p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>?</td><td>非贪心量化（Non-greedy quantifiers）：当该字符紧跟在任何一个其他重复修饰符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串</td></tr><tr><td>(pattern)</td><td>匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”</td></tr><tr><td>(?:pattern)</td><td>匹配pattern但不获取匹配的子字符串（shy groups)，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用</td></tr><tr><td>(?=pattern)</td><td>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用</td></tr><tr><td>(?!pattern)</td><td>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用</td></tr><tr><td>(?&lt;=pattern)</td><td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反</td></tr><tr><td>(?&lt;!pattern)</td><td>反向否定预查，与正向否定预查类似，只是方向相反</td></tr></tbody></table><p><br><br><br></p><hr><p><br></p><h1 id="POSIX字符组"><a href="#POSIX字符组" class="headerlink" title="POSIX字符组"></a>POSIX字符组</h1><p>POSIX字符类(POSIX character class),是一个形如[:…:]的特殊元序列，它用于匹配特定的字符范围。</p><table><thead><tr><th>POSIX字符组</th><th>说明</th><th>ASCII环境</th><th>Unicode环境</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>字母字符和数字字符</td><td>[a-zA-Z0-9]</td><td>[\p{L&amp;}\p{Nd}]</td></tr><tr><td>[:alpha:]</td><td>字母</td><td>[a-zA-Z]</td><td>\p{L&amp;}</td></tr><tr><td>[:ascii:]</td><td>ASCII字符</td><td>[\x00-\x7F]</td><td>\p{InBasicLatin}</td></tr><tr><td>[:blank:]</td><td>空格字符和制表符</td><td>[ \t]</td><td>[\p{Zs}\t]</td></tr><tr><td>[:cntrl:]</td><td>控制字符</td><td>[\x00-\x1F\x7F]</td><td>\p{Cc}</td></tr><tr><td>[:digit:]</td><td>数字字符</td><td>[0-9]</td><td>\p{Nd}</td></tr><tr><td>[:graph:]</td><td>空白字符之外的字符</td><td>[\x21-\x7E]</td><td>[^\p{Z}\p{C}]</td></tr><tr><td>[:lower:]</td><td>小写字母字符</td><td>[a-z]</td><td>\p{Ll}</td></tr><tr><td>[:print:]</td><td>类似[:graph:]，但包括空白字符</td><td>[\x20-\x7E]</td><td>\P{C}</td></tr><tr><td>[:punct:]</td><td>标点符号</td><td>}~-]</td><td>[\p{P}\p{S}]</td></tr><tr><td>[:space:]</td><td>空白字符</td><td>[ \t\r\n\v\f]</td><td>[\p{Z}\t\r\n\v\f]</td></tr><tr><td>[:upper:]</td><td>大写字母字符</td><td>[A-Z]</td><td>\p{Lu}</td></tr><tr><td>[:word:]</td><td>字母字符</td><td>[A-Za-z0-9_]</td><td>[\p{L}\p{N}\p{Pc}]</td></tr><tr><td>[:xdigit:]</td><td>十六进制字符</td><td>[A-Fa-f0-9]</td><td>[A-Fa-f0-9]</td></tr></tbody></table><p><br><br><br></p><hr><p><br></p><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><table><thead><tr><th>优先权</th><th>符号</th></tr></thead><tbody><tr><td>最高</td><td>\</td></tr><tr><td>高</td><td>( )、(?: )、(?= )、[ ]</td></tr><tr><td>中</td><td>*、+、?、{n}、{n,}、{m,n}</td></tr><tr><td>低</td><td>^、$、中介字符</td></tr><tr><td>次最低</td><td>串接，即相邻字符连接在一起</td></tr><tr><td>最低</td><td>l</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《鸟哥的Linux私房菜》&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;正则表达式维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="RegularExpression" scheme="https://zhang21.github.io/tags/RegularExpression/"/>
    
      <category term="正则表达式" scheme="https://zhang21.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://zhang21.github.io/2018/02/05/Redis/"/>
    <id>https://zhang21.github.io/2018/02/05/Redis/</id>
    <published>2018-02-05T09:20:28.000Z</published>
    <updated>2018-02-25T13:25:59.216Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>《Redis官方文档》: <a href="http://www.redis.cn/documentation.html" target="_blank" rel="noopener">http://www.redis.cn/documentation.html</a></li><li>《Redis命令大全》: <a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">http://www.redis.cn/commands.html</a></li></ul><p><br></p><p>环境:</p><ul><li>CentOS7x86_64</li><li>Redis 3.2</li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p><br></p><h2 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h2><p>Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的、非关系型,键值对存储数据库。<br>Redis是一个开源(BSD许可)的,内存中的数据结构存储系统,它可以用作数据库、缓存和消息中间件。</p><p>毫无疑问,Redis开创了一种新的数据存储思路,使用Redis,我们不用在面对功能单调的数据库时,把精力放在如何把大象放进冰箱这样的问题上,而是利用Redis灵活多变的数据结构和数据操作,为不同的大象构建不同的冰箱。希望你喜欢这个比喻。</p><p>Remote Dictionary Server(Redis)是由一个Salvatore Sanfilippo写的key-value储存系统。Redis提供了一些丰富的数据结构,包括lists,sets,ordered sets,hashes,当然还有和Memcached一样的string结构,所以常被称为是一款数据结构服务器(data structure server)。Redis当然还包括了对这些数据结构的丰富操作。</p><p>你可以在这些类型上面运行原子操作,例如,追加字符串,增加哈希中的值,加入一个元素到列表,计算集合的交集、并集和差集,或者是从有序集合中获取最高排名的元素。</p><p><br><br><br></p><h2 id="Redis的优点"><a href="#Redis的优点" class="headerlink" title="Redis的优点"></a>Redis的优点</h2><p>为了满足性能,Redis采用内存(in-memory)数据集(dataset)。根据你的使用场景,你可以通过每隔一段时间转储数据集到磁盘,或者追加每条命令到日志来持久化。持久化也可以被禁用,如果你只是需要一个功能丰富,网络化的内存缓存。</p><ul><li>性能极高,Redis能支持超过100K+每秒的读写频率</li><li>丰富的数据类型,Redis支持二进制案例的Strings,Lists,Hashes,Sets及Ordered Sets数据类型操作</li><li>原子,Redis的所有操作都是原子性的,同时Redis还支持对几个操作全并后的原子性执行</li><li>丰富的特性,Redis还支持publish/sucscribe,通知,key过期等特性</li><li>Redis还支持主从异步复制,非常快的非阻塞初次同步、网络断开时自动重连局部重同步</li></ul><p><br></p><hr><p><br></p><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><p>直接通过<code>yum</code>安装:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y redis</div></pre></td></tr></table></figure><p><br></p><p>启动redis-server的两种方式:</p><ul><li>redis-server: standalone模式</li><li>systemctl redis start: daemon模式<ul><li>需要在配置文件中开启daemonize</li></ul></li></ul><p>启动redis-cli:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis-cli</div><div class="line">redis-cli -a passwd</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h1><p>redis配置文件(/etc/redis.conf)常用参数:</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>daemonize</td><td>以守护进程启动,放置于后台</td></tr><tr><td>bind</td><td>监听地址,建议只对本地127.0.0.1开放</td></tr><tr><td>protect-mode</td><td>redis的保护模式</td></tr><tr><td>requirepass</td><td>设置密码</td></tr><tr><td>timeout</td><td>超时</td></tr><tr><td>tcp-keepalive</td><td>在Linux上,指定值(秒)用于发送ACKs的时间,关闭连接需要双倍的时间,默认为0</td></tr><tr><td>loglevle</td><td>指定日志记录的级别。有四个级别:debug(记录很多信息,用于开发测试)、notice(常用于生产环境)、warning(严重的信息)、verbose(有用的信息)</td></tr><tr><td>logfile</td><td>日志文件,默认为stdout</td></tr><tr><td>databases</td><td>可用数据库,范围在0-(database-1)</td></tr><tr><td>save</td><td>保存数据到磁盘(.rdb)</td></tr><tr><td>stop-writes-on-bgsave-error</td><td>后台储存错误停止写</td></tr><tr><td>rdbcompression</td><td>储存到本地数据库时(持久化到rdb文件)是否压缩</td></tr><tr><td>dbfilename</td><td>本地持久化数据库文件名,默认dump.rdb</td></tr><tr><td>dir</td><td>数据库文件路径,是目录</td></tr><tr><td>salveof</td><td>设置从库</td></tr><tr><td>masterauth</td><td>设置主库认证的密码</td></tr><tr><td>slave-read-only</td><td>设置slave是否只读</td></tr><tr><td>slave-serve-stale-data</td><td>从库同主库失去连接或复制正在进行时,从库是否继续响应客户端请求</td></tr><tr><td>repl-disable-tcp-nodelay</td><td>tcp-nodelay</td></tr><tr><td>slave-priority</td><td>slave优先级,master不能工作后,从众多slave中选出优先值最小的slave提升为master,优先值为0表示不能为master</td></tr><tr><td>appendonly</td><td>是否开启AOF数据备份,redis会把所接收到的每一次写操作请求都追加到appendonly.aof文件,当此文件很大</td></tr><tr><td>appendsync</td><td>AOF文件同步策略,后台会进行大量I/O</td></tr><tr><td>no-appendfsync-on-rewrite</td><td>-</td></tr><tr><td>auto-aof-rewrite-percentage</td><td>aof自动重写</td></tr><tr><td>auto-aof-rewrite-min-size</td><td>指定最小大小用于aof重写</td></tr><tr><td>slowlog-log-slower-than</td><td>慢日志,记录超过特定执行时间的命令,不包括I/o</td></tr><tr><td>slowlog-max-len</td><td>慢日志记录的长度,超过大小,最先进入队列的记录会被踢出</td></tr><tr><td>hash-max-zipmap-entries</td><td>hash将以一种特殊的编码方式(大大减少内存使用)来储存,这是其中一个临界值</td></tr><tr><td>hash-max-zipmap-value</td><td>另一个临界值</td></tr><tr><td>list-max-ziplist-entries</td><td>多个list以特定的方式编码来节省空间</td></tr><tr><td>activerehashing</td><td>Redis将在每100ms时使用1ms的CPU时间来对redis的hash表进行重新hash,可降低内存的使用</td></tr><tr><td>hz</td><td>不是所有任务都以相同的频率执行,但redis按照指定的“hz”值执行检查任务</td></tr><tr><td>aof-rewrite-incremental-fsync</td><td>当一个子节点重写AOF文件时,则文件每生产32m数据进行同步</td></tr></tbody></table><p><br></p><p>官方文档对VM的使用建议:</p><ul><li>当KEY很小而VALUE很大时,使用VM的效果会比较好,因为这样节约内存比较大</li><li>当key不小时,可以考虑使用一些非常方法将很大的key变成value,比如将key,value组合成一个新的value</li></ul><p><br></p><hr><p><br></p><h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><p>Redis不仅仅是简单的key-value存储器,同时也是一种data structure server。传统的key-value是指支持使用一个key字符串来索引value字符串的储存。而Redis中,value不仅仅支持字符串,还支持更多的复杂结构,包括列表、集合、哈希表等。Redis采用二进制安全,这就意味着你可以使用任何二进制序列作为重点。</p><p><br></p><h2 id="字符串-strings"><a href="#字符串-strings" class="headerlink" title="字符串(strings)"></a>字符串(strings)</h2><p>字符串 是一种最基本的Redis值类型。Redis字符串是二进制安全的,这意味着一个Redis字符串能包含任意类型的数据。</p><p>只关心二进制化的字符串,不关心具体格式。只会严格的按照二进制的数据存取。不会妄图已某种特殊格式解析数据。</p><p><br></p><h2 id="列表-lists"><a href="#列表-lists" class="headerlink" title="列表(lists)"></a>列表(lists)</h2><p>Redis列表是简单的字符串列表,按照插入顺序序列,你可以添加一个或多个元素到列表的头部或者尾部。</p><p><br></p><h2 id="散列-hash"><a href="#散列-hash" class="headerlink" title="散列(hash)"></a>散列(hash)</h2><p>Redis Hashes是字符串字段和字符串值之间的映射,因此他们是展现对象的完美数据类型。如一个有姓、名、年龄等属性的用户。一个带有一些字段的hash仅仅需要一块很小的空间储存,因此你可以储存数以百万计的对象在一个小的Redis实例中。</p><p>哈希主要用来表现对象,他们有能力储存很多对象,因此你可以将哈希用于许多其他的任务。</p><p><br></p><h2 id="无序集合-unorder-set"><a href="#无序集合-unorder-set" class="headerlink" title="无序集合(unorder set)"></a>无序集合(unorder set)</h2><p>Redis集合(Set)是一个无序的字符串集合。可以用O(1)的时间复杂度(无论集合中有多少元素时间复杂度都是常量)完成添加、删除、测试元素是否存在。</p><p>Redis集合拥有令人满意的不允许包含相同成员的属性。多次添加相同的元素,最终在集合里只会有一个元素。实际上就是添加元素时无序检测元素是否存在。</p><p>一个Redis集合有趣的事情是它支持一些服务端的命令从现有的集合出发去进行集合运算,因此你可以在非常短的时间内进行合并(unions)、交集(intersections)、找出不同的元素(difference of sets)。</p><p><br></p><h2 id="有序集合-order-set"><a href="#有序集合-order-set" class="headerlink" title="有序集合(order set)"></a>有序集合(order set)</h2><p>Redis有序集合与普通集合非常相似,也是一个没有重复项的字符串集合。不同之处是有序集合的每一个成员都关联了一个评分,这个评分被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的,但是评分可以是重复了。</p><p>使用有序集合可以以非常快的速度(O(log(N)))添加,删除和更新元素。可以很快根据评分(score)或者次序(position)来获取一个范围的元素。访问有序集合的中间元素也是很快的,因此能够使用有序集合作为一个没有重复成员的智能列表。在有序集合中,你可以很快捷的访问一切你需要的东西。</p><p>简而言之,使用有序的集合你可以做完许多对性能有极端要求的任务,而那些任务使用其他类型的数据库真的是很难完成。</p><p><br></p><hr><p><br></p><h1 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h1><p><br></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">exists key    <span class="comment">#判断一个key是否存在</span></div><div class="line"></div><div class="line">del key    <span class="comment">#删除某个或一系列key</span></div><div class="line"></div><div class="line"><span class="built_in">type</span> key    <span class="comment">#返回某个key元素的数据类型,key不存在返回空</span></div><div class="line"></div><div class="line">keys key-pattern    <span class="comment">#返回匹配的key列表</span></div><div class="line"></div><div class="line">randomkey    <span class="comment">#随机获取一个已经存在的key</span></div><div class="line"></div><div class="line">rename oldname newname<span class="comment">#改key的名字,如果存在将会覆盖</span></div><div class="line"></div><div class="line">dbsize    <span class="comment">#返回当前数据库的key的总和</span></div><div class="line"></div><div class="line">expire key time   <span class="comment">#设置某个key的过期时间(秒),到期后自动删除</span></div><div class="line"></div><div class="line">ttl    <span class="comment">#查询key剩余存活时间</span></div><div class="line"></div><div class="line">flushdb    <span class="comment">#清空当前数据库中的所有键</span></div><div class="line"></div><div class="line">flushall    <span class="comment">#清空所有数据库中的键</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="设置相关"><a href="#设置相关" class="headerlink" title="设置相关"></a>设置相关</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">config get    <span class="comment">#用来读取Redis服务器的配置参数</span></div><div class="line"></div><div class="line">config <span class="built_in">set</span>    <span class="comment">#用于更改运行Redis服务器的配置参数</span></div><div class="line"></div><div class="line">config resetstat    <span class="comment">#重置数据统计报告,通常返回OK</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">quit<span class="comment">#关闭连接</span></div><div class="line"></div><div class="line">auth<span class="comment">#密码认证</span></div><div class="line"></div><div class="line"><span class="built_in">help</span> <span class="built_in">command</span><span class="comment">#帮助</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">save<span class="comment">#将数据同步保存到磁盘</span></div><div class="line"></div><div class="line"></div><div class="line">bgsave<span class="comment">#将数据异步保存到磁盘</span></div><div class="line"></div><div class="line"></div><div class="line">lastsave<span class="comment">#返回上次成功将数据保存到磁盘的Unix时戳</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="远程服务"><a href="#远程服务" class="headerlink" title="远程服务"></a>远程服务</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">info<span class="comment">#服务器信息统计,基本所有信息</span></div><div class="line"></div><div class="line">monitor<span class="comment">#实时转储收到的请求</span></div><div class="line"></div><div class="line">slaveof<span class="comment">#改变复制策略</span></div><div class="line"></div><div class="line">shutdown<span class="comment">#将数据同步保存到磁盘,然后关闭服务</span></div><div class="line"></div><div class="line">server<span class="comment">#Redis server的常规信息</span></div><div class="line"></div><div class="line">clients<span class="comment">#Client的连接选项</span></div><div class="line"></div><div class="line">memory<span class="comment">#存储占用相关信息</span></div><div class="line"></div><div class="line">persistence<span class="comment">#RDB and AOF 相关信息</span></div><div class="line"></div><div class="line">stats<span class="comment">#常规统计</span></div><div class="line"></div><div class="line">replication<span class="comment">#Master/slave请求信息</span></div><div class="line"></div><div class="line">cpu<span class="comment">#CPU占用信息统计</span></div><div class="line"></div><div class="line">cluster<span class="comment">#Redis 集群信息</span></div><div class="line"></div><div class="line">keyspace<span class="comment">#数据库信息统计</span></div><div class="line"></div><div class="line">all<span class="comment">#返回所有信息</span></div><div class="line"></div><div class="line">default<span class="comment">#返回常规设置信息</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="值-value-操作"><a href="#值-value-操作" class="headerlink" title="值(value)操作"></a>值(value)操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">exists key<span class="comment">#判断一个key是否存在</span></div><div class="line"></div><div class="line">del key<span class="comment">#删除一个key</span></div><div class="line"></div><div class="line"><span class="built_in">type</span> key<span class="comment">#返回值的类型</span></div><div class="line"></div><div class="line">keys pattern<span class="comment">#返回满足给定模式的所有key</span></div><div class="line"></div><div class="line">randomkey<span class="comment">#随机返回key空间的一个</span></div><div class="line"></div><div class="line">rename oldname newname<span class="comment">#改key的名字,如果存在将会覆盖</span></div><div class="line"></div><div class="line">dbsize<span class="comment">#返回当前数据库中key的数目</span></div><div class="line"></div><div class="line">expire<span class="comment">#设定一个key的活动时间(s)</span></div><div class="line"></div><div class="line">ttl<span class="comment">#获得一个key的活动时间</span></div><div class="line"></div><div class="line">select index<span class="comment">#按索引查询</span></div><div class="line"></div><div class="line">move key dbindex<span class="comment">#移动当前数据库中的key到dbindex数据库</span></div><div class="line"></div><div class="line">flushdb<span class="comment">#删除当前选择的数据库中的所有key</span></div><div class="line"></div><div class="line">flushall<span class="comment">#删除所有数据库中的所有key</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="字符串-string-操作"><a href="#字符串-string-操作" class="headerlink" title="字符串(string)操作"></a>字符串(string)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">set key value           #给数据库中名称为key的string赋值value</div><div class="line"></div><div class="line">get key                         #返回数据库中名为key的string的value</div><div class="line"></div><div class="line">getset key value                #给名称为key的string赋予上一次的value</div><div class="line"></div><div class="line">mget key1 key2 ... key N                #返回库中多个string的value</div><div class="line"></div><div class="line">setnx key value         #添加string 名称为key 值为value</div><div class="line"></div><div class="line">setex key time value            #向库中添加string 设定过期时间time</div><div class="line"></div><div class="line">mset key 1 value 1 ... key N value N            #批量设置多个string的值</div><div class="line"></div><div class="line">msetnx key 1 value 1 ... key N value N          #如果所有名称为 key N的string都不存在 则向库中添加string 名称为 key N赋值value N</div><div class="line"></div><div class="line">incr key                #名称为key的string加 1 操作</div><div class="line"></div><div class="line">incrby key integer              #名称为key的string增减integer</div><div class="line"></div><div class="line">decr key                #名称为key的string减1操作</div><div class="line"></div><div class="line">decrby key integer              #名称为key的string的值附加value</div><div class="line"></div><div class="line">append key value                #名称为key的值附加value</div><div class="line"></div><div class="line">substr key start end            #返回名称为key的string的value的子串</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="列表-list-操作"><a href="#列表-list-操作" class="headerlink" title="列表(list)操作"></a>列表(list)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">rpush key value                 #在名称为key的list尾部添加一个值为value的元素</div><div class="line"></div><div class="line">lpush key value                 #在名称为key的list首部添加一个值为value的元素</div><div class="line"></div><div class="line">llen key                #返回名称为key的list的长度</div><div class="line"></div><div class="line">lrange key start end            #返回名称为key的list中start至end之间的元素 下表从0开始</div><div class="line"></div><div class="line">ltrim key start end             #截取名称为key的list 保留start至end之间的元素</div><div class="line"></div><div class="line">lindex key index                #返回名称为key的list中index位置的元素</div><div class="line"></div><div class="line">lset key index value            #给名称为key的list中index位置的元素赋值value</div><div class="line"></div><div class="line">lrem key count value            #删除count个名称为key的list中值为value的元素</div><div class="line"></div><div class="line">brpop key1 key2 ... keyN               #rpop的block版本</div><div class="line"></div><div class="line">rpoplpush srckey dstkey                 #返回并删除名为srckey的list尾元素 并将该元素添加到名为dstkey的list的头部</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="集合-set-操作"><a href="#集合-set-操作" class="headerlink" title="集合(set)操作"></a>集合(set)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">sadd key member                 #向名为key的set中添加元素member</div><div class="line"></div><div class="line">srem key member                 #删除名为key的set中元素的member</div><div class="line"></div><div class="line">spop key                #随机返回并删除名为key的set中的一个元素</div><div class="line"></div><div class="line">smove srckey dstkey member              #将member元素从名为srckey的集合移动到名为dstkey的集合</div><div class="line"></div><div class="line">scard key               #返回名为key的set的基数</div><div class="line"></div><div class="line">sismember key member            #测试member是否是名称为key的set的集合</div><div class="line"></div><div class="line">sinter key1 key2 ... key N              #求交集</div><div class="line"></div><div class="line">sinterstore dstkey key1 ... key N               #求交集并将交集保存到dstkey的集合</div><div class="line"></div><div class="line">sunion key1 ... key N           #求并集</div><div class="line"></div><div class="line">sunionstore dstkey key 1 ... key N              #求并集并将并集保存到dstkey的集合</div><div class="line"></div><div class="line">sdiff key1 ... key N            #求差集</div><div class="line"></div><div class="line">sdiffstore dstkey key 1 ... key N               #求差集并将差集保存到dstkey的集合</div><div class="line"></div><div class="line">smembers key            #返回名为key的set的所有元素</div><div class="line"></div><div class="line">srandmember key                 #随机返回名为key的set的一个元素</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="有序集合-sorted-set-操作"><a href="#有序集合-sorted-set-操作" class="headerlink" title="有序集合(sorted set)操作"></a>有序集合(sorted set)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">zadd key score member           #向名为key的zset中添加元素member score用于排序 如果该元素已经存在 则根据</div><div class="line">score更新该元素的顺序</div><div class="line"></div><div class="line">zrem key member                 #删除名为key的zset中的元素member</div><div class="line"></div><div class="line">zincrby key increment member            #如果在名为key的zset中已经存在元素member 则该元素的score增加increment 否则向集合中添加该元素 其score的值为increment</div><div class="line"></div><div class="line">zrank key member                #返回名为key的zset 顺序</div><div class="line"></div><div class="line">zrevrank key member             #返回名为key的zset 倒序</div><div class="line"></div><div class="line">zrange key start end            #返回名为key的zset score顺序按index从start到end返回所有元素</div><div class="line"></div><div class="line">zrevrange key start end                 #返回名为key的zset score倒序按index从start到end返回所有元素</div><div class="line"></div><div class="line">zrangebyscore key min max               #返回名为key的zset中score大于等于min 小于等于max的所有元</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="hash操作"><a href="#hash操作" class="headerlink" title="hash操作"></a>hash操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">hset key field value            #向名为key的hash中添加元素filed----value</div><div class="line"></div><div class="line">hget key field          #返回名为key的hash中field对应的value</div><div class="line"></div><div class="line">hmset key field1 value1 ... field N value N             #向名为key的hash中添加元素field----value</div><div class="line"></div><div class="line">hmget key field1 ... field N            #返回名为key的hash中filed对应的value</div><div class="line"></div><div class="line">hincrby key field integer               #将名为key的hash中field的value增加integer</div><div class="line"></div><div class="line">hexists key field               #名为key的hash中是否存在键为field的域</div><div class="line"></div><div class="line">hdel key field          #删除名为key的hash中键为field的域</div><div class="line"></div><div class="line">hlen key                #返回名为key的hash中元素个数</div><div class="line"></div><div class="line">hkeys key               #返回名为key的hash中所有键</div><div class="line"></div><div class="line">hvals key               #返回名为key的hash中所有键对应的value</div><div class="line"></div><div class="line">hgetall key     #返回名为key的hash中所有的键 field 及其对应的value</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="Redis高级应用"><a href="#Redis高级应用" class="headerlink" title="Redis高级应用"></a>Redis高级应用</h1><p>Redis高级应用包括<strong>安全性设置、主从复制、事务处理、持久化机制和虚拟内存的使用</strong>。</p><p><br><br><br></p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>由于redis速度相当快，一秒钟可以150K次密码尝试，所以需要设置一个密码强度很强大的密码。</p><p>设置密码的两种方法：</p><ul><li><code>config set requirepass &quot;passwd&quot;</code>，通过命令设置密码</li><li>直接在配置文件中<code>requirepass</code>属性后加上密码</li></ul><p>认证登录的两种方式：</p><ul><li><code>redis-cli -a passwd</code></li><li><code>redi-cli</code> –&gt; <code>auth passwd</code></li></ul><p><br><br><br></p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>Redis的主从复制的配置和使用都比较简单。</p><ul><li>master server</li><li>slave server</li></ul><p>Redis主从复制特点：</p><ul><li>一主多从</li><li>当master宕机后，优先级值小的那台slave server自动转变为master</li><li>主从复制不同阻塞master，在同步数据时master可以继续处理client的请求</li><li>提高了系统的可伸缩性</li></ul><p>Redis主从复制过程：</p><ul><li>slave与master建立连接，发送sync同步命令</li><li>master会启动一个后台进程，将数据库快照保存到文件中，同时master主进程会开始收集新的写命令并缓存</li><li>后台完成保存后，就将此文件发送给slave</li><li>slave将文件保存在磁盘上</li></ul><p><br></p><h3 id="主从复制栗子"><a href="#主从复制栗子" class="headerlink" title="主从复制栗子"></a>主从复制栗子</h3><p>Redis主从配置，一主多从。<br>注意：由于redis吃内存，可能会由于内存过小而无法正常启动redis，可查看<code>/var/log/message</code>。</p><p><br></p><p><strong>配置master</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">vim /etc/redis_master.conf</div><div class="line"></div><div class="line"></div><div class="line">daemon yes</div><div class="line">bind 127.0.0.1 ip1</div><div class="line">port 6379</div><div class="line">requirepass fuza_mima</div><div class="line">protect-mode yes</div><div class="line">datebases 100</div><div class="line">logfile /var/log/redis/redis_master.log</div><div class="line">dir /var/lib/redis_master</div><div class="line"></div><div class="line"></div><div class="line">mkdir /var/lib/redis_master</div><div class="line">chown redis:redis /var/lib/redis_master</div><div class="line"></div><div class="line"></div><div class="line">systemctl start redis</div></pre></td></tr></table></figure><p><strong>配置slave</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">vim /etc/redis_slave.conf</div><div class="line"></div><div class="line"></div><div class="line">daemon yes</div><div class="line">bind 127.0.0.1</div><div class="line">port 6379</div><div class="line">protect-mode yes</div><div class="line">logfile /var/log/redis/redis_slave.log</div><div class="line">dir /var/lib/redis_slave</div><div class="line"></div><div class="line"></div><div class="line">slaveof &lt;master-ip&gt; &lt;master-port&gt;</div><div class="line">masterauth &lt;master-passwd&gt;</div><div class="line">slave-read-only yes</div><div class="line">slave-priority 100</div><div class="line"></div><div class="line">#master挂掉后，从slave中选出优先级最小的作为master</div><div class="line"></div><div class="line">······</div><div class="line">#其他具体主从参数自己配置</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">mkdir /var/lib/redis_slave</div><div class="line">chown redis:redis /var/lib/redis_slave</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">systemctl start redis</div></pre></td></tr></table></figure><p><br></p><p><strong>测试master</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis-cli -a xxx</div><div class="line"></div><div class="line">set name zhang</div><div class="line">get zhang</div></pre></td></tr></table></figure><p><strong>测试slave</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis-cli</div><div class="line">auth(&apos;passwd&apos;)</div><div class="line"></div><div class="line"></div><div class="line">key *</div><div class="line">get zhang</div></pre></td></tr></table></figure><p><br></p><p><strong>注意</strong>：</p><p>由于Redis只是主从，并不像MongoDB的集群功能。当Redis master挂掉以后，虽然优先级较小的slave成为了master，但从库是无法更新数据的。这点也可以从Redis从的配置文件中看出，连接到Redis主的IP：PORT，并通过主的密码来认证。</p><p><br><br><br></p><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>Redis的事务处理比较简单。只能保证client发起的事务中的命令可以连续的执行，而且不会插入其他的client命令。</p><p>当一个client在连接中发出multi命令时，这个连接就进入一个事务的上下文，该连接后续的命令不会执行，而是存放在一个队列中，当执行exec命令时，redis会顺序的执行队列中的所有命令。如果其中执行出现错误，执行正确的不会回滚，不同于关系型数据库的事务。</p><p><br><br><br></p><h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>持久化就是把数据从内存保存到硬盘。</p><p>Redis是一个支持持久化的内存数据库，Redis需要经常将内存中的数据同步到磁盘来保证持久化。</p><p>Redis支持两种持久化方式：</p><ol><li>snapshotting(快照)<ul><li>将数据存放到文件里，默认方式。默认写入dump.rdb二进制文件中</li><li>可配置redis在n秒内超过m个key被修改就自动做快照</li><li>save 500 10 –&gt; 500s内超过10个key被修改，则保存快照</li></ul></li></ol><p>由于快照方式在一定间隔时间做一次保存， 如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。<br>AOF比快照方式有更好的持久化性，是由于使用aof时，redis会将每一个收到的写命令都通过write函数写入到文件中当redis启动时会通过重新执行文件中保存的写命令在内存中重新建立整个数据库的内容。</p><ol><li>appendonly file(AOF)<ul><li>aof方式redis会将每一次的函数都追加到文件中，当redis重启时会重新执行文件中保存的命令</li></ul></li></ol><p><br></p><p>配置文件参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#启用aof持久化方式</span></div><div class="line">appendonly yes</div><div class="line"></div><div class="line"><span class="comment">#每秒写入磁盘一次，在性能和持久化方面做了很好的折中</span></div><div class="line">appendonly everysc</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#将数据写入磁盘</span></div><div class="line">save 900 1</div><div class="line">save 300 10</div><div class="line">save 60 10000</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>Redis的虚拟内存是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出内存空间用于其它的访问数据。<br>对于redis这样的内存数据库，内存总是不够用的。</p><p>在配置文件(/etc/redis.conf)中配置VM:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#开启vm功能</span></div><div class="line">vm-enableyes</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#交换出来的value保存的文件路径</span></div><div class="line">vm-swap-file    /tmp/redis.swap</div><div class="line"></div><div class="line"><span class="comment">#redis使用的最大内存上线</span></div><div class="line">vm-max-memory 10000000</div><div class="line"></div><div class="line"><span class="comment">#每个页面的大小32字节</span></div><div class="line">vm-page-size 32</div><div class="line"></div><div class="line"><span class="comment">#最多使用多少个页面</span></div><div class="line">vm-pages 123217729</div><div class="line"></div><div class="line"><span class="comment">#用于执行value对象换入的工作线程数量</span></div><div class="line">vm-max-threads 4</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>Redis监听地址<code>bind： x.x.x.x</code>，强烈建议只对本地<code>127.0.0.1</code>开放。不建议对外网开放，有安全隐患</li><li>防火墙，最简单就是关闭防火墙，另一个就是开放redis的监听端口</li><li>开启守护进程，让redis可以在后台运行而不必通过<code>redis-server</code>的方式来启动，将配置文件里的<code>deamonize no</code>改为<code>yes</code></li><li>关闭redis的保护模式(protect-mode)，这里的保护模式是指是否允许其他IP的设备访问redis。如果开启的话就只能允许本机访问。如果是生产开发的实际运行环境，请一定开启保护模式</li><li>设置redis数据库密码！不仅仅是redis，任何数据库都应该设置密码，否则对外网开放的数据库就成了活靶子。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Redis官方文档》: &lt;a href=&quot;http://www.redis.cn/documentation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.redis.cn/documentation.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Redis命令大全》: &lt;a href=&quot;http://www.redis.cn/commands.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.redis.cn/commands.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7x86_64&lt;/li&gt;
&lt;li&gt;Redis 3.2&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="https://zhang21.github.io/categories/Database/"/>
    
    
      <category term="Redis" scheme="https://zhang21.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>计算机集群</title>
    <link href="https://zhang21.github.io/2018/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4/"/>
    <id>https://zhang21.github.io/2018/02/03/计算机集群/</id>
    <published>2018-02-03T05:56:45.000Z</published>
    <updated>2018-02-24T10:47:08.777Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>《老男孩Linux运维》</li><li>《服务器集群系统各概念》: <a href="https://segmentfault.com/a/1190000009923581" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009923581</a></li><li>《WEB的负载均衡、集群、高可用解决方案》： <a href="https://zhuanlan.zhihu.com/p/23826048" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23826048</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4" target="_blank" rel="noopener">计算机集群维基百科</a></li></ul><p><br></p><a id="more"></a><hr><p><br></p><h1 id="计算机集群"><a href="#计算机集群" class="headerlink" title="计算机集群"></a>计算机集群</h1><p>计算机集群简称<strong>集群</strong>(Clusters)，是一种计算机系统。它通过一组散列集成的软件或硬件 连接起来高度紧密地协作完成计算工作。在某种意义上，他们可以被看做是一台计算机。</p><p>集群就是指一组（若干）相互独立的计算机，利用高速通信网络组成的一个较大的计算机服务系统，每个集群结点都是运行各自服务的独立服务器。这些服务器之间可以彼此通信，协同向用户提供应用程序、系统资源和数据，并以单一系统的模式加以管理。</p><p>当客户机请求集群系统时，集群给用户的感觉就是一个单一独立的服务器，而实际上用户请求的是一组集群服务器。</p><p>集群系统中的单个计算机通常称为节点，通常通过内网连接，但也有其它的可能连接方式。集群计算机通常用来改进单个计算机的计算速度和可靠性。</p><p><br><br><br></p><h2 id="服务器集群概念"><a href="#服务器集群概念" class="headerlink" title="服务器集群概念"></a>服务器集群概念</h2><p>集群、冗余、负载均衡、主从复制、读写分离、分布式、分布式计算、分布式计算平台、并行计算……</p><p>实际生产环境中常有的问题：</p><ul><li>当数据库性能遇到问题时，是否能够横向扩展，通过添加服务器的方式达到更高的吞吐量，从而充分利用现有的硬件实现更好的投资回报率;</li><li>是否拥有实时同步的副本，当数据库面临灾难时，可以短时间内通过故障转移的方式保证数据库的可用性。此外，当数据丢失或损坏时，能否通过所谓的实时副本（热备）实现数据的零损失;</li><li>数据库的横向扩展是都对应用程序透明，如果数据库的横向扩展需要应用程序端进行大量修改，则所带来的后果不仅仅是高昂的开发成本，同时也会带来很多潜在和非潜在的风险.</li></ul><p><br></p><h3 id="集群和冗余"><a href="#集群和冗余" class="headerlink" title="集群和冗余"></a>集群和冗余</h3><p>集群和冗余并不对立，多台服务器做集群（不是主从），本身就有冗余和负载均衡的效果。<br>狭义上来说，集群就是把多台服务器虚拟成一台服务器，而冗余的每台服务器都是独立的。</p><ul><li>集群的侧重点在于协同，多台服务器系统分担工作，提升效率；</li><li>冗余的侧重点在于防止单点故障，一主多备的架构，也就是主从复制；</li></ul><blockquote><p>数据冗余==高可用性==主从</p></blockquote><ul><li>主从一定程度上起到了负载均衡的作用，但主要目的还是为了保证数据冗余和高可用性</li><li>主从只提供一种成本较低的数据备份方案加上不完美的灾难和负载均衡，由于复制存在时间差，不能同步读，所以只是不完善的负载均衡和有损灾备</li><li>主从显然达不到集群的严格度，不论是 HA 还是 AA（多活并行集群），主从都达不到数据一致性的集群要求</li></ul><p><br><br><br></p><h2 id="为什么要使用集群"><a href="#为什么要使用集群" class="headerlink" title="为什么要使用集群"></a>为什么要使用集群</h2><ul><li>高性能（Performance）<br>  大型网站谷歌、淘宝、百度等，都不是几台大型机可以构建的，都是上万台服务器组成的高性能集群，分布于不同的地点。<br>  只有当并发或总请求数量超过单台服务器的承受能力时，服务器集群的优势才会体现出来。</li><li>价格有效性（Cost-effectiveness）<br>  在达到同样性能的需求下，采用计算机集群架构比采用同等运算能力的大型计算机具有更高的性价比。</li><li>可伸缩性（Scalability）<br>  当服务负载、压力增长时，针对集群系统进行较简单的扩展即可满足需求，且不会降低服务质量。</li><li>高可用（Availability）<br>  单一计算机发生故障时，就无法正常提供服务；而集群架构技术可以是得系统在若干硬件设备发生故障时仍可以继续工作。<br>  集群系统在提高系统可靠性的同时，也大大减小了系统故障带来的业务损失，目前几乎100%的网站都要求7x24h提供服务。</li><li>透明性（Transparency）<br>  多个独立计算机组成的耦合集群系统构成一个虚拟服务器。用户访问集群系统时，就像访问一台高性能、高可用的服务器一样，集群中一部分服务器的上线、下线不会中断整个系统服务，这对用户也是透明的。</li><li>可管理性（Manageability）<br>  这个系统可能在物理上很大，但其实很容易管理，就像管理一个单一映像系统一样。</li><li>可编程性（Programmability）<br>  在集群系统上，容易开发及修改各类应用程序。</li></ul><p><br></p><hr><p><br></p><h1 id="集群分类"><a href="#集群分类" class="headerlink" title="集群分类"></a>集群分类</h1><p>集群分为同构和异构，他们区别在于 “组成集群系统的计算机之间的体系结构是否相同”。</p><p>集群计算机按功能和结构可以分为以下几类：</p><ul><li>均衡集群（Load balancing clusters）</li><li>用性集群（High-availability clusters）</li><li>能计算集群（High-performance cluster）</li><li>计算集群（Grid computing）</li></ul><blockquote><p>负载均衡集群（LB）和高可用性集群（HA）是互联网行业常用的集群架构模式</p></blockquote><p><br><br><br></p><h2 id="负载均衡集群"><a href="#负载均衡集群" class="headerlink" title="负载均衡集群"></a>负载均衡集群</h2><p><strong>负载均衡集群用于抗并发。</strong></p><blockquote><p>负载均衡集群典型的开源软件包括：LVS、Nginx、Haproxy 等。</p></blockquote><p><br></p><p>负载均衡集群可以把很多客户集中的访问请求负载压力尽可能平均分摊在计算机集群中处理。<br>集群中每个节点都可以一定的访问请求负载压力，并且可以实现访问请求在各节点之间动态分配，以实现负载均衡。<br>负载均衡集群运行时，一般是通过一个或多个前端负载均衡器（Director）将客户访问请求分发到后端的一组服务器上，从而达到整个系统的高性能和高可用性。<br>一般高可用性集群和负载均衡集群会使用类似的技术，或同时具有高可用性与负载均衡的特点。</p><p>Linux虚拟服务器（LVS）项目 在Linux操作系统上提供最常用的负载均衡软件。</p><p><br></p><p>负载均衡的作用：</p><ul><li>用户访问请求及数据流量（负载均衡）</li><li>业务连续性，即7x24h服务（高可用）</li><li>于Web业务及数据库从库等服务器的业务</li></ul><p><br><br><br></p><h2 id="高可用性集群"><a href="#高可用性集群" class="headerlink" title="高可用性集群"></a>高可用性集群</h2><p><strong>高可用性集群用于避免单点故障。</strong></p><blockquote><p>高可用性集群常用开源软件包括：Keepalived、Heartbeat 等。</p></blockquote><p><br></p><p>一般是指集群中任意一个节点失效的情况下，该节点上的所有任务会自动转移到其他正常的节点上。此过程不会影响整个集群的运行。</p><p>当集群中的一个节点系统发生故障时，运行着的集群服务器会迅速做出反应，将该系统的服务分配到集群中其他正在工作的系统上运行。考虑到计算机硬件和软件的容错性，高可用性集群的主要目的是使局群的整体服务尽可能可用。<br>如果高可用集群中的主节点发生了故障，那么这段时间内将由备节点代替它。备节点通常是主节点的镜像。当它代替主节点时，它可以完全接管主节点（包括Ip和其他资源）提供服务，因此，使集群系统环境对系统环境来说是一致的，既不会影响用户的访问。</p><p>高可用性集群使服务器系统的运行速度和响应速度会尽可能的快。它们经常利用在多台机器上运行的冗余节点和服务来相互跟踪。<br>如果某个节点失败，它的替补者将在几秒钟或更多时间内接管它的职责。因此，对于用户来说，集群里的任意一台机器宕机，业务都不会受影响。</p><p>高可用性集群的作用：</p><ul><li>当一台机器宕机后，另外一台机器接管宕机的机器的Ip资源和服务资源，提供服务；</li><li>常用于不易实现负载均衡的应用，如负载均衡器、主数据库、主存储对之间；</li></ul><p><br><br><br></p><h2 id="高性能计算集群"><a href="#高性能计算集群" class="headerlink" title="高性能计算集群"></a>高性能计算集群</h2><p>高性能计算集群也称并行计算。通常，高性能计算集群涉及为集群开发的并行应用程序，以解决复杂的科学问题。</p><p>高性能计算集群对外就好像一个超级计算机，这种超级计算机内部由数万个独立服务器组成，并且在公共消息传递层上进行通信以运行并行应用程序。</p><p><br><br><br></p><h2 id="高可用与负载均衡有什么区别"><a href="#高可用与负载均衡有什么区别" class="headerlink" title="高可用与负载均衡有什么区别"></a>高可用与负载均衡有什么区别</h2><ul><li>HA偏重于备用资源，切机时会有业务的断开的，保证了数据的安全，但造成资源的浪费；</li><li>LB侧重于资源的充分应用，没有主备的概念，只有资源的最大限度的加权平均应用，基本不会业务的中断；</li><li>HA的目的是不中断服务，LB的目的是为了提高接入能力。虽然经常放一起用，但确实是两个不同的领域；</li><li>HA在一条路不通的时候提供另一条路可走，而 LB 就类似于是春运时的多个窗口；</li></ul><p><br></p><hr><p><br></p><h1 id="集群软硬件"><a href="#集群软硬件" class="headerlink" title="集群软硬件"></a>集群软硬件</h1><p><br></p><p>企业运维中常见集群产品：</p><ul><li>开源集群软件：<pre><code>+ Nginx, LVS, Haproxy, Keepalived, Heartbear...</code></pre></li><li>商业集群硬件：<pre><code>+ F5， Netscaler,Radware, A10...</code></pre></li></ul><p>如何选择开源集群软件：</p><ul><li>网站在并发访问和总访问量不是很大的情况下，建议首选Nginx负载均衡，Nginx配置简单使用方便安全稳定。 另一个实现负载均衡的产品为Haproxy</li><li>如果要考虑Nginx负载均衡的高可用功能，建议首选Keepalived软件，因为安装配置简单方便稳定。类似高可用软件还有Heartbeat，但比较复杂</li><li>如果是大型企业，负载均衡可以使用 LVS+Keepalived 在前端做四层转发，后端使用Nginx或Haproxy做七层转发，再后面是应用服务器。如果是数据库与存储的负载均衡和高可用，可选用<code>LVS+Heartbeat</code></li></ul><p><img src="/images/Zabbix/cluster.png" alt=""></p><p><br></p><hr><p><br></p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>所谓负载均衡，就是把大访问量分发给不同的服务器，也就是分流请求。</p><p><br></p><h2 id="HTTP重定向协议实现负载均衡"><a href="#HTTP重定向协议实现负载均衡" class="headerlink" title="HTTP重定向协议实现负载均衡"></a>HTTP重定向协议实现负载均衡</h2><p>HTTP 重定向就是应用层的请求转发，用户的请求其实已经到了HTTP重定向负载均衡服务器，服务器根据算法要求用户重定向，用户收到重定向请求后，再次请求真正的集群.</p><ul><li>优点：简单</li><li>缺点：性能较差</li></ul><p><br><br><br></p><h2 id="DNS域名解析负载均衡"><a href="#DNS域名解析负载均衡" class="headerlink" title="DNS域名解析负载均衡"></a>DNS域名解析负载均衡</h2><p>DNS域名解析负载均衡就是在用户请求DNS服务器，获取域名对应的IP地址时，DNS服务器直接给出负载均衡后的服务器IP。</p><ul><li>优点：交给DNS，不用我们去维护负载均衡服务器</li><li>缺点：当一个应用服务器挂了，不能及时通知DNS，而且DNS负载均衡的控制权在域名服务商那里，网站无法做更多的改善和更强大的管理</li></ul><p><br><br><br></p><h2 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h2><p>在用户的请求到达方向代理服务器时（已到达网站机房），由于反向代理服务器根据算法转发到具体的服务器，常用的Apache，Nginx都可以充当反向代理服务器。</p><ul><li>优点：部署简单</li><li>缺点：代理服务器可能成为性能的瓶颈，特别是一次上传大文件</li></ul><p><br><br><br></p><h2 id="IP负载均衡-LVS-NAT"><a href="#IP负载均衡-LVS-NAT" class="headerlink" title="IP负载均衡(LVS-NAT)"></a>IP负载均衡(LVS-NAT)</h2><p>LVS集群中实现的三种IP负载均衡技术。</p><p><br></p><p>在请求到达负载均衡器后，负载均衡器通过修改请求的目的IP地址，从而实现请求的转发，做到负载均衡。</p><ul><li>优点：性能更好</li><li>缺点：负载均衡器的带宽称为瓶颈</li></ul><p><br><br><br></p><h2 id="直接路由负载均衡-LVS-DR"><a href="#直接路由负载均衡-LVS-DR" class="headerlink" title="直接路由负载均衡(LVS-DR)"></a>直接路由负载均衡(LVS-DR)</h2><p>数据链路层负载均衡，在请求到达负载均衡器后，负载均衡器通过修改请求的Mac地址，从而做到负载均衡，与IP负载均衡不一样的是，当请求访问完服务器之后，直接返回客户，而无需在经过负载均衡器。</p><p><br><br><br></p><h3 id="IP隧道负载均衡-LVS-TUN"><a href="#IP隧道负载均衡-LVS-TUN" class="headerlink" title="IP隧道负载均衡(LVS-TUN)"></a>IP隧道负载均衡(LVS-TUN)</h3><p><br></p><hr><p><br></p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主从是一种用于数据容错和灾备的高可用解决方案，而不是一种处理高并发压力的解决方案（负载均衡是用来抗并发的）。</p><blockquote><p>如MySQL主从复制，MongoDB主从复制(副本集)</p></blockquote><ul><li>主机负责查询，从机负责增删改</li><li>可以在从机上执行备份，以避免备份期间影响主机的服务</li><li>主从复制后，也可以在从机上查询，以降低主机的访问压力。但是，只有更新不频繁的数据或者对实时性要求不高的数据可以通过从服务器查询，实时性要求高的数据仍需在主服务器查询（因为主从复制有同步延迟，所以不能保证强数据一致性）</li></ul><p><br><br><br></p><h2 id="主从复制和读写分离"><a href="#主从复制和读写分离" class="headerlink" title="主从复制和读写分离"></a>主从复制和读写分离</h2><ul><li>主从复制是实现读写分离的技术之一，也是实现读写分离的前提条件</li><li>做读写分离时最重要的就是确保 读库 和 写库 的数据统一，而主从复制是实现数据统一最简单的方法（并不能够保证强数据的一致性）</li><li>读写分离，顾名思义，就是一个表只负责向前台页面展示数据，而后台管理人员对表的增删改在另一个表中，把两个表分开，就是读写分离</li><li>主从复制则是一个表数据 增删改 之后会及时更新到另一个表中，保证两个表的数据一致</li></ul><p><br><br><br></p><h2 id="主从类型"><a href="#主从类型" class="headerlink" title="主从类型"></a>主从类型</h2><ul><li>双机热备=主机+备机</li><li>主要应用运行在主机，备机即备用机器。备机不工作，主机出现故障时备机接管主机的所有工作</li><li>双机互备=主机（备机） + 备机（主机）</li><li>互为主备，部分应用运行于主机，部分应用运行于备机，主机备机同时工作</li><li>双机双工=主机+主机</li><li>两台主机同时运行应用，主机备机同时工作</li></ul><p><br></p><hr><p><br></p><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><ul><li>广义上的分布式是指，将不同的服务分布在不同的服务器上</li><li>集群是指，将几台服务器集中在一起，实现同一业务</li><li>分布式中的每一个节点都可以做集群，而集群并不一定是分布式的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《老男孩Linux运维》&lt;/li&gt;
&lt;li&gt;《服务器集群系统各概念》: &lt;a href=&quot;https://segmentfault.com/a/1190000009923581&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000009923581&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《WEB的负载均衡、集群、高可用解决方案》： &lt;a href=&quot;https://zhuanlan.zhihu.com/p/23826048&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/23826048&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计算机集群维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://zhang21.github.io/tags/Nginx/"/>
    
      <category term="Cluster" scheme="https://zhang21.github.io/tags/Cluster/"/>
    
  </entry>
  
  <entry>
    <title>不成熟的小想法</title>
    <link href="https://zhang21.github.io/2018/01/21/%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E5%B0%8F%E6%83%B3%E6%B3%95/"/>
    <id>https://zhang21.github.io/2018/01/21/不成熟的小想法/</id>
    <published>2018-01-21T14:11:16.000Z</published>
    <updated>2018-03-18T12:19:12.500Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ynwa.png" alt="YNWA"></p><a id="more"></a><p><br><br><br></p><blockquote><p>你在大学奋斗四年和你进入工作岗位后奋斗四年，这两者的质量是完全不同的。前者是一个人一生的黄金时代，他有绝对的选择权来决定自己要成为什么样子；而后者则不同，吃饱饭才是这些已经步入社会的人需要考虑的第一要务。</p></blockquote><p><br></p><blockquote><p>我想不明白，为什么非要把成都建设成为2/3个四川？(或许西部省份都是这样，省会便是这个省)2017年成都市GDP约为13800亿人民币，而第二名的绵阳，却连2000亿都不到。<br>后来别人对我讲，资本都是逐利的。也许将壹万亿拆分成小蛋糕到各个地级市能使得各个地级市经济都得到一定的发展，但肯定没有将全部蛋糕投在成都的利润更好。这让我想起了滚雪球效应，相比滚出许多小雪球，所带来的的直观效应也没有大雪球突出，雪球越滚越大，给人的映像也就越来越明显。还有就是为政者都是需要政绩来突出自己，这是升迁的重要依据。GDP才是衡量你当政的重要依据，其它因素虽然也重要，但也比不过它。</p></blockquote><p><br></p><blockquote><p>我喜欢苹果，你却给了我一车梨，然后告诉全世界你花光了所有的钱给我买了一车梨。可是我却没有一点点感动，你说我是一个铁石心肠的人，可是我只是喜欢苹果而已。</p></blockquote><p><br></p><blockquote><p>任何人不是要你来教他如何做人的！</p></blockquote><p><br></p><blockquote><p>难道真如马尔克斯所说——“上了年纪的人不是按照已经活了多少岁来衡量年龄的，而是通过距离死亡还有多远来衡量！”</p></blockquote><p><br></p><blockquote><p>我刚开上本田的时候，也是宋总这心情，把骑自行车的人贬个贼死，而且心里就会骂出口，大屁股晃什么晃，开个玛萨拉蒂得瑟呀，我那时就像我买得起玛萨拉蒂一样。哈哈，就是个工具，先上手再说。<br>原来人都有这种心态，哈哈哈。</p></blockquote><p><br></p><blockquote><p>看着老一辈的逐渐老去，小一辈的逐渐长大，感叹时光过得真快呀！</p><p>过年回家，任何人都会谈及一个字——“钱”。</p><p>全家人都想出去挣钱，关于老人赡养问题，儿子和女儿又该如何担责？</p><p>儿媳妇也是一个严重的问题！我在想一个问题，儿媳妇在对待男方父母的时候，有没有想过如果以后她的儿媳也这样对待她，她作何感想？</p><p>现在的亲戚关系如果隔代的话，基本上过年就只有上一辈的人才走动了，下一辈子女基本都不会去。想想我们这些娃儿，上辈是亲兄弟姐妹、堂兄弟姐妹或表兄弟姐妹，我们这些小辈娃儿从小一起玩耍长大，小时候的关系好的不得了，用俗话说就是“穿一条裤子”。可是长大以后、结婚成家以后关系就淡泊了，哎！<br>可能我们这一辈情况以后会好一点，因为由于国家的计划生育政策，我们这一辈基本上都是独生子女。以后亲戚就这些，可能关系会好点，逢年过节走动会更频繁一点。其实计划生育使得我们这一辈人挺孤单的，长得后没什么亲戚、兄弟姊妹。以后我们的孩子也没有了舅舅、姨、叔伯、嬢嬢。所以可能以后非直系亲戚间的关系也会更紧密一些。现在国家放开了二胎其实挺好的，孩子们能有个哥哥姐姐弟弟妹妹真的挺好的。</p><p>过年回家经典问答：毕业了没有呀？毕业了，微笑；多少岁了呀？xxx岁了，微笑；在哪上班呀？在外上班，微笑；在成都哪个地方呀？南边，微笑；在哪个公司呀？小公司，微笑；是做啥子的呀？计算机，微笑；工资多少呀？不多不少，微笑；有没有女朋友呀？没有，微笑……<br>我知道这些长辈本没有恶意，只是出于不知道说什么而问点问题。但是，你们就不能动动脑子吗，我的长辈些。</p></blockquote><p><br></p><blockquote><p>我只是一个农村里出来的怯弱书生，一定要找准自己的定位。上辈给不了我什么东西，这点和城里的孩子已经差了一步，所以只有靠自己好好努力奋斗。争取给小一辈创造一个好一点的环境。</p><p>人人都是有利己心，人人都是自私的，表面和内心就如同硬币的正反两面。底层人民毫不讲理的一套，做事情完全不看原则和对错，完全是斗谁的声音高谁的脾气大才是理。看见斗不过有立马哭闹装楞。农村人民并不是那么淳良朴实，一点点鸡毛蒜皮的事情都要争。</p></blockquote><p><br></p><blockquote><p>任何人际关系都需要维持的！</p></blockquote><p><br></p><blockquote><p>我发觉我有一个问题。<br>人对一个人、一件物、一件事产生一个误解(或称之为成见的东西)，是很难改变的，以后会一直存在于我们的潜意识里面。我们的潜意识会主动隔阂某人某事某物，几遍某人某物某事是对的，这样一个长期效应便是对于我们潜意识里面的思维，我们会主动用我们的成见来隔阂。不知道能不能用“一朝被蛇咬十年怕井绳”来表述。<br>其实人与人、人与事是需要相互了解的，有了成见以后人就不愿意了解对方，而用自己潜意识的成见来判断人事物。这样隔阂也就难以消除而会一直延续小区。<br>所以，对人对事，不能带着老旧的成见去看到。——“士别三日当刮目相待，已非吴下阿蒙”。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/ynwa.png&quot; alt=&quot;YNWA&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Zhang" scheme="https://zhang21.github.io/categories/Zhang/"/>
    
    
      <category term="Zhang" scheme="https://zhang21.github.io/tags/Zhang/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://zhang21.github.io/2018/01/16/MySQL/"/>
    <id>https://zhang21.github.io/2018/01/16/MySQL/</id>
    <published>2018-01-16T02:47:12.000Z</published>
    <updated>2018-03-02T10:00:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>MySQL5.7参考文档： <a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/</a></li></ul><p><br></p><p>环境：</p><ul><li>CentOS7.x86_64</li><li>MySQL5.7</li></ul><a id="more"></a><p><br><br><br></p><hr><p><br></p><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>MySQL官网： <a href="https://www.mysql.com/" target="_blank" rel="noopener">https://www.mysql.com/</a></p><p>由于MySQL5.7和以前版本之间的许多功能和其他差异，因此此手册不太适用于之前的老版本。之前的版本请参考MySQL相关版本的手册。</p><p><br></p><p><img src="/images/Mysql/MySQL.png" alt="MySQL"></p><p><br><br><br></p><hr><p><br></p><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>General information</p><p>MySQL™ software提供了一个快速、多线程、多任务和健壮的SQL(结构化查询语言)的数据库服务器。MySQL server是为关键服务(mission-critical)、重负荷(heavy-load)生产系统以及嵌入式(embedding)大规模部署的软件而设计。<br>MySQL是Oracle Corporation的商标(trademark)。</p><p>MySQL software是双重许可的(dual license)：</p><ol><li>Open Source product of the GNU General Public License</li><li>A Standard commercial License from Oracle</li></ol><p><br><br><br></p><h2 id="关于此手册"><a href="#关于此手册" class="headerlink" title="关于此手册"></a>关于此手册</h2><ul><li>该手册作为一个参考，它不提供关于SQL或关系型数据库概念的一般指令；</li><li>MySQL Database Software正在不断发展，所以参考手册也经常更新。可在此 &lt; <a href="http://dev.mysql.com/doc/&gt;" target="_blank" rel="noopener">http://dev.mysql.com/doc/&gt;</a> 获取最新版的手册；</li><li>参考手册(Reference Manual)的源文件使用DocBook XML格式书写的，其他版本(如HTML)等是自动生成的；</li><li>如果在使用过程中有任何问题或建议，请发邮件给我们；</li><li>手册由MySQL Documentation Team维护。</li></ul><p><br><br><br></p><h2 id="MySQL数据库管理系统"><a href="#MySQL数据库管理系统" class="headerlink" title="MySQL数据库管理系统"></a>MySQL数据库管理系统</h2><p>MySQL Database Management System</p><p><br></p><h3 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a>MySQL介绍</h3><p>MySQL是最流行的开源的SQL数据库管理系统，由Oracle Corporation开发、分发和支持。</p><p><br></p><ul><li><p>MySQL is a database management system<br>数据库是一个结构化的数据集合。它可能是从简单的购物清单到图片库，或是公司网络中的大量信息。若要添加、访问和处理存储在计算机数据库中的数据，你需要一个像MySQL Server这样的数据库管理系统。由于计算机非常擅长处理大量的数据，数据库管理系统在计算机中扮演这一个重要的角色。</p></li><li><p>MySQL databases are relational<br>关系型数据库将数据存储在单独的表(table)中，而不是将所有数据放入一个大的库房中。数据库结构被组织成针对速度优化的物理文件。具有数据库(database)，表(table)，视图(view)，行(row)，列(column)等物理对象的逻辑模型提供了灵活的编程环境。你设置了管理不同数据字段之间关系的规则，如一对一，一对多，唯一，必须和可选关系，以及不同表之间的指针(pointer)。数据库强制执行这些规则，这样在设计良好的数据库中，应用程序就不会看到不一致、重复、孤立、过时或丢失的数据。</p></li></ul><p>MySQL也是代表SQL(Structure Query Language)的一部分。SQL是访问数据库最常用的标准化语言。你可以直接使用SQL语句，或者将SQL语法隐藏到语言特定的API中。</p><p>-MySQL software is Open Source<br>MySQL software使用GPL(GNU General Public License)，开源意味着任何人都可以下载、转发、使用和修改软件，而不需要支付任何费用。</p><ul><li><p>MySQL database server is very fast,reliable,scalabe and easy to use</p></li><li><p>MySQL server works in Client/Server or embedded system<br>MySQL Database Server是一个由多线程(multi-threaded)SQL Server组成的客户/服务器系统。它支持不同的后端，多个不同的客户程序和库、管理工具和广泛的APIs。<br>还提供MySQL Server作为一个嵌入式多线程库以便链接到你的产品，以获得一个更小，更快，更容易管理的独立产品。</p></li><li><p>A large amount of contributed MySQL software is available</p></li></ul><p><br><br><br></p><h3 id="MySQL主要特点"><a href="#MySQL主要特点" class="headerlink" title="MySQL主要特点"></a>MySQL主要特点</h3><h4 id="Internals-and-Portability"><a href="#Internals-and-Portability" class="headerlink" title="Internals and Portability"></a>Internals and Portability</h4><ul><li>由C和C++写成</li><li>适用于许多不同的平台</li><li>为了可移植性，使用<code>CMake</code></li><li>采用独立(independent)模块的多层(layer)服务器设计</li><li>设计为使用内核线程的完全多线程，如果有多核CPU，能够轻松使用它们</li><li>提供了事务性(transactional)和非事务性(notransactional)存储引擎</li><li>使用非常快速的带有索引压缩的B-tree磁盘表</li><li>添加其他存储引擎相对容易</li><li>使用非常快速的基于线程的内存分配系统</li><li>使用优化的嵌套循环(nested-loop)连接执行非常快的联结</li><li>实现内存中的hash table，这些表用作临时表</li><li>使用高度优化的类库实现SQL函数</li></ul><p><br></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>1,2,3,4和8byte的有无符号(signed/unsigned)的整数(integers)</li><li>FLOAT</li><li>DOUBLE</li><li>CHAR, VARCHAR</li><li>BINARY, VARBINARY</li><li>TEXT</li><li>BLOB</li><li>DATE, TIME, DATETIME</li><li>TIMESTAMP</li><li>YEAR</li><li>SET</li><li>ENUM</li><li>OpenGIS</li></ul><p><br></p><h4 id="状态和功能"><a href="#状态和功能" class="headerlink" title="状态和功能"></a>状态和功能</h4><p>statement and function</p><ul><li><code>SELECT</code>和<code>WHERT</code>中包含了所有支持的操作符和函数</li><li>SQL中的<code>GROUP BY</code>和<code>ORDER BY</code>也全部支持</li><li>GROUP functions(<code>COUNT()</code>, <code>AVG()</code>, <code>STD()</code>, <code>SUM()</code>, <code>MAX()</code>, <code>MIN()</code>, <code>GROUP_CONCAT()</code>)</li><li>支持<code>LEFT OUTER JOIN</code>和<code>ROGHT OUTER JOIN</code></li><li>按照SQL标准支持table和columns的别名</li><li>支持<code>DELETE</code>,<code>INSERT</code>,<code>REPLACE</code>,<code>UPDATE</code>，以返回受影响的行数</li><li>支持MySQL特定的<code>SHOW</code>显示语句</li><li>一个<code>EXPLAIN</code>语句显示优化器如何解析查询</li></ul><p><br></p><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>security</p><ul><li>权限(privilege)和密码系统，非常灵活和安全，并且支持基于主机的验证</li><li>当连接到Server时，通过加密(encryption)所有密码通信量来确保密码安全</li></ul><p><br></p><h4 id="扩展性和限制"><a href="#扩展性和限制" class="headerlink" title="扩展性和限制"></a>扩展性和限制</h4><p>Scalability and Limits</p><ul><li>支持大型数据库。包含五千万条记录，二十万个表，五十亿行</li><li>每个表最多支持64个索引，每个索引可以由1到16个列组成</li></ul><p><br></p><p>####　连通性</p><p>Conectivity</p><ul><li>客户端使用如下几种协议连接到MySQL Server<ul><li>TCP/IP sockets</li><li>–enable-named-pipe on Windows</li><li>Unix domain socket files on UNIX</li></ul></li><li>MySQL客户端可用多种语言编写</li><li>APIs对于多数语言是可用的</li></ul><p><br></p><h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>Localization</p><ul><li>Server可以向多种语言的客户端提供错误信息</li><li>完全支持几个不同的字符集(character sets)</li><li>所有数据都被保存在选取的字符集(chracter set)</li><li>排序和比较是根据默认的字符集和排序规则完成</li><li>服务器时区(time zone)可动态更改，个客户端也可修改自己的时区</li></ul><p><br></p><h4 id="客户端和工具"><a href="#客户端和工具" class="headerlink" title="客户端和工具"></a>客户端和工具</h4><p>Clients and Tools</p><ul><li>MySQL包含几个客户机和使用程序<ul><li>command-line： <code>mysqldump</code>, <code>mysqladmin</code></li><li>graphical: MySQL Workbench</li></ul></li><li>MySQL Server内置了对SQL语句的支持来检查、优化和修复表</li><li>MySQL程序可使用<code>--help</code>或<code>-?</code>来获取帮助</li></ul><p><br><br><br></p><h3 id="MySQL历史"><a href="#MySQL历史" class="headerlink" title="MySQL历史"></a>MySQL历史</h3><p>History of MySQL</p><ul><li>MySQL is named after co-founder Monty Widenius’s daughter, My.</li><li>The name of the MySQL Dolphin (our logo) is “Sakila,” which was chosen from a huge list of names suggested by users in our “Name the Dolphin” contest.</li></ul><p><br><br><br></p><h2 id="MySQL5-7新特色"><a href="#MySQL5-7新特色" class="headerlink" title="MySQL5.7新特色"></a>MySQL5.7新特色</h2><p>What Is New in MySQL 5.7</p><p><br></p><h3 id="MySQL5-7新功能"><a href="#MySQL5-7新功能" class="headerlink" title="MySQL5.7新功能"></a>MySQL5.7新功能</h3><p>Features Added in MySQL 5.7</p><p><br><br><br></p><h3 id="MySQL5-7中过期的功能"><a href="#MySQL5-7中过期的功能" class="headerlink" title="MySQL5.7中过期的功能"></a>MySQL5.7中过期的功能</h3><p>Features Deprecated in MySQL 5.7</p><p><br><br><br></p><h3 id="MySQL5-7中移除的功能"><a href="#MySQL5-7中移除的功能" class="headerlink" title="MySQL5.7中移除的功能"></a>MySQL5.7中移除的功能</h3><p>Features Removed in MySQL 5.7</p><p><br><br><br></p><h2 id="Server-and-Status-Variables-and-Options-Added-Deprecated-or-Removed-in-MySQL-5-7"><a href="#Server-and-Status-Variables-and-Options-Added-Deprecated-or-Removed-in-MySQL-5-7" class="headerlink" title="Server and Status Variables and Options Added, Deprecated, or Removed in MySQL 5.7"></a>Server and Status Variables and Options Added, Deprecated, or Removed in MySQL 5.7</h2><p><br><br><br></p><h2 id="MySQL信息源"><a href="#MySQL信息源" class="headerlink" title="MySQL信息源"></a>MySQL信息源</h2><p>MySQL Information Sources</p><p>本章节将列出有关MySQL的帮助信息。</p><p><br></p><h3 id="MySQL站点"><a href="#MySQL站点" class="headerlink" title="MySQL站点"></a>MySQL站点</h3><p>MySQL Websites</p><p>MySQL Documentation is <a href="https://dev.mysql.com/doc" target="_blank" rel="noopener">https://dev.mysql.com/doc</a></p><p><br><br><br></p><hr><p><br></p><h1 id="安装和升级MySQL"><a href="#安装和升级MySQL" class="headerlink" title="安装和升级MySQL"></a>安装和升级MySQL</h1><ul><li>mysql-repo: <a href="http://repo.mysql.com/" target="_blank" rel="noopener">http://repo.mysql.com/</a></li><li>yum-repo: <a href="http://repo.mysql.com/yum/" target="_blank" rel="noopener">http://repo.mysql.com/yum/</a></li></ul><p><br></p><p>安装MySQL一般遵循以下步骤：</p><ul><li>确定MySQL是否支持你的平台(platform)<ul><li>Unix、Linux、FreeBSD</li><li>Windows</li><li>OS X</li></ul></li><li>选择要安装的发行版(distribution)</li><li>下载你想要安装的发行版</li><li>安装发行版</li><li>执行任何必要的安装后设置</li></ul><p><br><br><br></p><h2 id="通用安装指南"><a href="#通用安装指南" class="headerlink" title="通用安装指南"></a>通用安装指南</h2><p>General Installation Guidance</p><p><br><br><br></p><h3 id="安装哪个发行版和MySQL版本"><a href="#安装哪个发行版和MySQL版本" class="headerlink" title="安装哪个发行版和MySQL版本"></a>安装哪个发行版和MySQL版本</h3><p>Which MySQL Version and Distribution to Install</p><p><br></p><p>在准备安装MySQL时，请决定使用哪种版本(version)和发行(distribution)格式(binary or source)</p><p>首先，决定安装开发版还是稳定版。</p><ul><li>Development release<ul><li>具有新功能，但不推荐用于生产环境</li></ul></li><li>General Availability(GA) release<ul><li>也称为稳定版(stable release)，推荐为生产环境使用</li></ul></li></ul><p>MySQL命名方案(naming scheme)， 例如MySQL5.7.1：</p><ul><li>5为主版本号(major)</li><li>7为次版本号(minor)</li><li>1为发行(release)系列版本号<ul><li>系列号描述了稳定的功能集。对于每个新的修补程序，这都会增加。</li></ul></li></ul><p>在选择要安装的MySQL版本之后，决定要为操作系统安装哪个发行版格式。</p><ul><li>二进制(binary)<ul><li>RPM, DMG</li></ul></li><li>源码(source)<ul><li>tar, zip</li></ul></li></ul><p>在某些情况下，最好使用源码安装MySQL：</p><ul><li>想在某个明确的位置安装MySQL</li><li>希望使用二进制发行版中未包含的特性配置mysqld</li><li>希望配置mysqld，而不需要二进制发行版中包含的一些功能</li><li>你希望读取或修改组成MySQL的C、C++源代码</li><li>源码发行版比二进制发行版包含更多的测试和示例</li></ul><p><br><br><br></p><h3 id="如何获取MySQL"><a href="#如何获取MySQL" class="headerlink" title="如何获取MySQL"></a>如何获取MySQL</h3><p>How to Get MySQL</p><p><br></p><ul><li>MySQL当前版本下载页： <a href="https://dev.mysql.com/downloads/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/</a></li><li>完整的MySQL镜像： <a href="https://dev.mysql.com/downloads/mirrors/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mirrors/</a></li><li>基于RPM的Linux平台，MySQL Yum Repository： <a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a></li><li>基于Debian的Linux平台，MySQL APT Repository： <a href="https://dev.mysql.com/downloads/repo/apt/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/apt/</a></li><li>SUSE Linux平台，MySQL SUSE Repository： <a href="https://dev.mysql.com/downloads/repo/suse/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/suse/</a></li></ul><p><br><br><br></p><h3 id="使用MD5校验和或GnuPG验证程序完整性"><a href="#使用MD5校验和或GnuPG验证程序完整性" class="headerlink" title="使用MD5校验和或GnuPG验证程序完整性"></a>使用MD5校验和或GnuPG验证程序完整性</h3><p>Verifying Package Integrity Using MD5 Checksums or GnuPG</p><p><br></p><p>下载好MySQL包并在安装它之前，请确保它是完整的并未被篡改。有如下三种方法：</p><ul><li>MD5 checksums</li><li>Cryptographic signatures using GnuPG, the GNU Privacy Guard</li><li>For RPM packages, the built-in RPM integrity verification mechanism</li></ul><p><br><br><br></p><h4 id="验证MD5校验和"><a href="#验证MD5校验和" class="headerlink" title="验证MD5校验和"></a>验证MD5校验和</h4><p>Verifying the MD5 Checksum</p><p><br></p><p>应确保下载的MySQL包的MD5校验和与MySQL官方提供的校验和相匹配。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">md5sum mysql-standard-5.7.22-linux-i686.tar.gz</div><div class="line"><span class="comment">#aaab65abbec64d5e907dcd41b8699945  mysql-standard-5.7.22-linux-i686.tar.gz</span></div></pre></td></tr></table></figure><p><br></p><h4 id="使用GnuPG进行签名检查"><a href="#使用GnuPG进行签名检查" class="headerlink" title="使用GnuPG进行签名检查"></a>使用GnuPG进行签名检查</h4><p>Signature Checking Using GnuPG</p><p><br></p><p>要验证软件包的签名，首先需要我们的公共GPG密钥的副本。可从<a href="http://pgp.mit.edu/" target="_blank" rel="noopener">http://pgp.mit.edu/</a>下载。<br>你想要获得的密钥名为<strong>mysql-build@oss.oracle.com</strong>，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-----BEGIN PGP PUBLIC KEY BLOCK-----</div><div class="line">Version: GnuPG v1.4.5 (GNU/Linux)</div><div class="line"></div><div class="line">mQGiBD4+owwRBAC14GIfUfCyEDSIePvEW3SAFUdJBtoQHH/nJKZyQT7h9bPlUWC3</div><div class="line">RODjQReyCITRrdwyrKUGku2FmeVGwn2u2WmDMNABLnpprWPkBdCk96+OmSLN9brZ</div><div class="line">fw2vOUgCmYv2hW0hyDHuvYlQA/BThQoADgj8AW6/0Lo7V1W9/8VuHP0gQwCgvzV3</div><div class="line">BqOx后面还有很多，省略</div><div class="line">-----END PGP PUBLIC KEY BLOCK-----</div></pre></td></tr></table></figure><p>使用<code>gpg --import</code>将密钥导入到个人公共GPG密钥环中。如公共密钥为<code>mysql_pubkey.asc</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gpg --import ./mysql_pubkey.asc</div><div class="line"></div><div class="line"></div><div class="line">#或使用public key id下载公共密钥</div><div class="line">gpg --recv-keys $pub-key-id</div></pre></td></tr></table></figure><p>在rpm包中验证:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm --import ./mysql_pubkey.asc</div></pre></td></tr></table></figure><p>确保两个文件都放置于同一目录下，然后运行命令验证签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gpg --verify package_name.asc</div><div class="line"></div><div class="line">gpg --verify mysql-standard-5.7.22-linux-i686.tar.gz.asc</div><div class="line">gpg: Signature made Tue 01 Feb 2011 02:38:30 AM CST using DSA key ID 5072E1F5</div><div class="line">gpg: Good signature from &quot;MySQL Release Engineering &lt;mysql-build@oss.oracle.com&gt;&quot;</div></pre></td></tr></table></figure><p><br></p><h4 id="使用RPM进行签名检查"><a href="#使用RPM进行签名检查" class="headerlink" title="使用RPM进行签名检查"></a>使用RPM进行签名检查</h4><p>Signature Checking Using RPM</p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rpm --checksig package_name.rpm</div><div class="line"></div><div class="line">[zhang@zabbix ~]$ rpm --checksig mysql-community-server-5.7.20-1.el7.x86_64.rpm</div><div class="line">mysql-community-server-5.7.20-1.el7.x86_64.rpm: (sha1) dsa sha1 md5 gpg OK</div></pre></td></tr></table></figure><p>rpm还支持从URL加载密钥:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm --import http://dev.mysql.com/doc/refman/5.7/en/checking-gpg-signature.html</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="安装布局"><a href="#安装布局" class="headerlink" title="安装布局"></a>安装布局</h3><p>Installation Layouts</p><p><br></p><p>不同的安装类型(native packages, binary tarballs, and source tarballs)有不同的安装布局，这样可能会导致混淆。</p><p><br><br><br></p><h2 id="在Unix-Linux上使用通用二进制文件安装MySQL"><a href="#在Unix-Linux上使用通用二进制文件安装MySQL" class="headerlink" title="在Unix/Linux上使用通用二进制文件安装MySQL"></a>在Unix/Linux上使用通用二进制文件安装MySQL</h2><p>Installing MySQL on Unix/Linux Using Generic Binaries</p><p><br></p><p>包括以压缩的tar文件形式的通用二进制发行版，以及针对特定平台封装格式的二进制文件。</p><p>MySQL压缩tar文件二进制发行版具有<strong> mysql-VERSION-OS.tar.gz</strong>的文件格式。</p><p>MySQL依赖于<code>libaio</code> Library：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y libaio</div></pre></td></tr></table></figure><p><br></p><p>默认地，tar文件二进制发行版，解压后安装于<code>/usr/local/mysql</code>目录。会在目录下生产 通用Unix/Linux二进制包的MySQL安装布局目录</p><table><thead><tr><th>目录</th><th>内容</th></tr></thead><tbody><tr><td>bin</td><td>mysqld server, client and utility programs</td></tr><tr><td>docs</td><td>MySQL manual in Info format</td></tr><tr><td>man</td><td>Unix manual pages</td></tr><tr><td>include</td><td>Include (header) files</td></tr><tr><td>lib</td><td>Libraries</td></tr><tr><td>share</td><td>Error messages, dictionary, and SQL for database installation</td></tr><tr><td>support-files</td><td>Miscellaneous support files</td></tr></tbody></table><p>大致命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">shell&gt; groupadd mysql</div><div class="line">shell&gt; useradd -r -g mysql -s /bin/false mysql</div><div class="line">shell&gt; cd /usr/local</div><div class="line">shell&gt; tar zxvf /path/to/mysql-VERSION-OS.tar.gz</div><div class="line">shell&gt; ln -s full-path-to-mysql-VERSION-OS mysql</div><div class="line">shell&gt; cd mysql</div><div class="line">shell&gt; mkdir mysql-files</div><div class="line">shell&gt; chown mysql:mysql mysql-files</div><div class="line">shell&gt; chmod 750 mysql-files</div><div class="line">shell&gt; bin/mysqld --initialize --user=mysql</div><div class="line">shell&gt; bin/mysql_ssl_rsa_setup</div><div class="line">shell&gt; bin/mysqld_safe --user=mysql &amp;</div><div class="line"># Next command is optional</div><div class="line">shell&gt; cp support-files/mysql.server /etc/init.d/mysql.server</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#添加环境变量</div><div class="line">export PATH=$PATH:/usr/local/mysql/bin</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="在Linux上安装MySQL"><a href="#在Linux上安装MySQL" class="headerlink" title="在Linux上安装MySQL"></a>在Linux上安装MySQL</h2><p>Installing MySQL on Linux</p><p><br></p><p>Linux支持多种方法来安装MySQL。建议使用Oracle提供的一个发行版：</p><ul><li>Apt</li><li>Yum</li><li>Zypper</li><li>RPM</li><li>DEB</li><li>Generic</li><li>Source</li><li>Docker</li><li>Oracle Unbreakable Linux Network</li></ul><p>作为一个选择，你可以使用系统中的包管理工具自动下载和安装MySQL。</p><p><br><br><br></p><h3 id="在Linux上使用Yum-Repository安装MySQL"><a href="#在Linux上使用Yum-Repository安装MySQL" class="headerlink" title="在Linux上使用Yum Repository安装MySQL"></a>在Linux上使用Yum Repository安装MySQL</h3><p>Installing MySQL on Linux Using the MySQL Yum Repository</p><p><br></p><p><strong>安装一个全新的MySQL的步骤：</strong></p><ul><li>添加MySQL Yum Repository<ul><li>首先，添加MySQL Yum repository到你的系统仓库列表</li><li>选择和下载对应平台的release 或者 手动添加repository文件</li><li>安装release package</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#yum localinstall platform-and-version-specific-package-name.rpm</span></div><div class="line">yun install http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql57-community-release-el7-10.noarch.rpm</div><div class="line"></div><div class="line"></div><div class="line">yum repolist enabled | grep <span class="string">"mysql.*-community.*"</span></div></pre></td></tr></table></figure><ul><li>选择一个release series</li></ul><p>默认是最新的GA series，当前最新是MySQL5.7。</p><p>查看所有的MySQL Yum repository: <code>yum repolist all | grep mysql</code></p><p>安装最新MySQL不需要配置，而安装先前的版本则需要指定GA series。disable最新的GA series并且enable需要的GA series。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum-config-manager --disable mysql57-community</div><div class="line"></div><div class="line">yum-config-manager --enable mysql56-community</div></pre></td></tr></table></figure><p><strong>或者手动创建repo，可直接定义版本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[mysql57-community]</div><div class="line">name=MySQL 5.7 Community Server</div><div class="line">baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/7/$basearch/</div><div class="line">enabled=1</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</div></pre></td></tr></table></figure><ul><li>安装MySQL</li></ul><p>在安装MySQL过程中出现错误，请务必查看日志文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum install -y mysql-community-server mysql-community-client</div><div class="line"></div><div class="line">#也可不安装客户端</div></pre></td></tr></table></figure><ul><li>开启MySQL Server</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">service mysqld start</div><div class="line">#Starting mysqld:[ OK ]</div><div class="line"></div><div class="line">service mysqld status</div></pre></td></tr></table></figure><p><strong>在服务器初始启动时，如果服务器的数据目录为空，则会发生一下情况：</strong></p><ul><li>服务器已初始化</li><li>SSL certificate and key files 在数据目录中生成</li><li>validate_password已安装并启用</li><li>超级用户账户’root’@’localhost’被创建，超级用户密码被设置并被存储在error log files<ul><li>这一点和以前版本有很大区别，我被坑惨了</li></ul></li></ul><p><strong>注意：</strong></p><blockquote><p>ValidPassword的默认密码策略要求包含大写字母、小写字母、数字和特殊字符，并且密码长度至少为8个字符</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#查看初始密码</div><div class="line">grep &apos;temporary password&apos; /var/log/mysqld.log</div><div class="line"></div><div class="line"></div><div class="line">#无法使用mysqladmin修改密码，需要登录mysql后修改</div><div class="line"></div><div class="line">mysql -uroot -p</div><div class="line"></div><div class="line"></div><div class="line">#重置密码</div><div class="line">ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;NewPass4!;</div><div class="line"></div><div class="line"></div><div class="line">#如果找不到初始密码</div><div class="line">vim /etc/my.cnf</div><div class="line"></div><div class="line">#在[mysqld]最后行加上skip-grant-tables实现无认证登录</div><div class="line">#重启MySQL</div><div class="line">UPDATE  mysql.user  SET  authentication_string =PASSWORD(&apos;新密码&apos;)  WHERE  USER=&apos;xxx&apos;;</div><div class="line"></div><div class="line"></div><div class="line">#修改默认密码策略</div><div class="line">#更改密码强度</div><div class="line">set global validate_password_policy=0;</div><div class="line"></div><div class="line">#设置密码最小长度</div><div class="line">set global validate_password_length=4;</div></pre></td></tr></table></figure><p><br></p><p><strong>使用Yum安装额外的MySQL产品和组件</strong></p><p>你可使用Yum安装和管理MySQL的个别组件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">yum --disablerepo=\* --enablerepo=<span class="string">'mysql*-community*'</span> list available</div><div class="line"></div><div class="line">yum install package-name</div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">yum install mysql-community-libs</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="在Linux上使用Oracle提供的RPM包安装MySQL"><a href="#在Linux上使用Oracle提供的RPM包安装MySQL" class="headerlink" title="在Linux上使用Oracle提供的RPM包安装MySQL"></a>在Linux上使用Oracle提供的RPM包安装MySQL</h3><p>Installing MySQL on Linux Using RPM Packages from Oracle</p><p><br></p><p>MySQL Community Edition的rpm包如下：</p><table><thead><tr><th>包名</th><th>描述</th></tr></thead><tbody><tr><td>mysql-community-server</td><td>Database server and related tools</td></tr><tr><td>mysql-community-client</td><td>MySQL client applications and tools</td></tr><tr><td>mysql-community-common</td><td>Common files for server and client libraries</td></tr><tr><td>mysql-community-server-minimal</td><td>Minimal installation of the database server and related tools</td></tr><tr><td>mysql-community-devel</td><td>Development header files and libraries for MySQL database client applications</td></tr><tr><td>mysql-community-libs</td><td>Shared libraries for MySQL database client applications</td></tr><tr><td>mysql-community-libs-compat</td><td>Shared compatibility libraries for previous MySQL installations</td></tr><tr><td>mysql-community-embedded</td><td>MySQL embedded library</td></tr><tr><td>mysql-community-embedded-devel</td><td>Development header files and libraries for MySQL as an embeddable library</td></tr><tr><td>mysql-community-test</td><td>Test suite for the MySQL server</td></tr></tbody></table><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#rpm -qpl mysql-community-server-version-distribution-arch.rpm</div><div class="line"></div><div class="line">#yum install mysql-community-&#123;server,client,common,libs&#125;-*</div><div class="line"></div><div class="line"></div><div class="line">wget http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql-community-server-5.7.20-1.el7.x86_64.rpm</div><div class="line">wget http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql-community-client-5.7.20-1.el7.x86_64.rpm</div><div class="line"></div><div class="line">yum install -y mysql-community-server-5.7.20-1.el7.x86_64.rpm mysql-community-client-5.7.20-1.el7.x86_64.rpm</div></pre></td></tr></table></figure><p><br></p><p><strong>Linux RPM包MySQL开发区的安装布局：</strong></p><table><thead><tr><th>文件或资源</th><th>位置</th></tr></thead><tbody><tr><td>Client programs and scripts</td><td>/usr/bin</td></tr><tr><td>mysqld server</td><td>/usr/sbin</td></tr><tr><td>configuration file</td><td>/etc/my.cnf</td></tr><tr><td>data directory</td><td>/var/lib/mysql</td></tr><tr><td>error log file</td><td>/var/log/mysqld.log</td></tr><tr><td>Value of secure_file_priv</td><td>/var/lib/mysql-files</td></tr><tr><td>System V init script</td><td>/etc/init.d/mysqld</td></tr><tr><td>Systemd service</td><td>mysqld</td></tr><tr><td>pid file</td><td>/var/run/mysql/mysqld.pid</td></tr><tr><td>socket</td><td>/var/lib/mysql/mysql.sock</td></tr><tr><td>Keyring directory</td><td>/var/lib/mysql-keyring</td></tr><tr><td>Unix manual pages</td><td>/usr/share/man</td></tr><tr><td>include (header) files</td><td>/usr/include/mysql</td></tr><tr><td>Libraries</td><td>/usr/lib/mysql</td></tr><tr><td>Miscellaneous support files (for example, error messages, and character set files)</td><td>/usr/share/mysql</td></tr></tbody></table><p><br></p><p>The installation also creates a user named mysql and a group named mysql on the system.</p><blockquote><p><strong>注意</strong><br>安装MySQL会在系统上生成一个名为mysql的用户和群组<br>安装以前的MySQL版本可能会创建<code>my.cnf</code>配置文件。强烈建议先将<code>my.cnf</code>进行迁移，然后删除它。之后才安装MySQL</p></blockquote><p><br><br><br></p><h3 id="用systemd管理MySQL-Server"><a href="#用systemd管理MySQL-Server" class="headerlink" title="用systemd管理MySQL Server"></a>用systemd管理MySQL Server</h3><p>Managing MySQL Server with systemd</p><p><br></p><h4 id="systemd综述"><a href="#systemd综述" class="headerlink" title="systemd综述"></a>systemd综述</h4><p>Overview of systemd</p><p><br></p><p><code>systemd</code>提供了MySQL Server的自动开启和关闭，使用<code>systemctl</code>命令进行管理。</p><p>或者，使用<code>system V</code>系统兼容的<code>service</code>命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">systemctl &#123;start|stop|restart|status&#125; mysqld</div><div class="line"></div><div class="line">service mysqld &#123;start|stop|restart|status&#125;</div></pre></td></tr></table></figure><p>对systemd的支持包括这些文佳：</p><ul><li>mysqld.service<ul><li>systemd服务单元配置文件，以及有关MySQL服务的详细信息</li></ul></li><li>mysqld@.service<ul><li>用于管理多个MySQL实例</li></ul></li><li>mysqld.tmpfiles.d<ul><li>包含支持临时文件功能的信息</li></ul></li><li>mysqld_pre_systemd<ul><li>支持单元文件的脚本</li></ul></li></ul><p><br></p><h4 id="为MySQL配置systemd"><a href="#为MySQL配置systemd" class="headerlink" title="为MySQL配置systemd"></a>为MySQL配置systemd</h4><p>Configuring systemd for MySQL</p><p><br></p><p>为MySQL添加或修改systemd选项，参考如下方法：</p><ul><li>使用一个本地化的systemd配置文件</li><li>安排systemd为MySQL Server进程设置环境变量</li><li>设置MYSQLD_OPTS systemd变量</li></ul><p>创建<code>/etc/systemd/system/mysqld.service</code>本地化systemd配置文件，这里讨论的是将此文件名作为<code>override.conf</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[Service]</div><div class="line">LimitNOFILE=max_open_files</div><div class="line">PIDFile=/path/to/pid/file</div><div class="line">Nice=nice_level</div><div class="line">LimitCore=core_file_limit</div><div class="line">Environment=<span class="string">"LD_PRELOAD=/path/to/malloc/library"</span></div><div class="line">Environment=<span class="string">"TZ=time_zone_setting"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#LimitNOFILE: 文件描述符数量</span></div><div class="line"><span class="comment">#LimitCore: 最大核心文件大小</span></div><div class="line"><span class="comment">#Nice: 优先级</span></div><div class="line"><span class="comment">#LD_PRELOAD: 特定内存分配库</span></div><div class="line"><span class="comment">#TZ: 指定时区</span></div></pre></td></tr></table></figure><p>修改mysqld:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl edit mysqld</div></pre></td></tr></table></figure><p>重新加载systemd配置，然后重启MySQL service：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">systemctl daemon-reload</div><div class="line"></div><div class="line">systemctl restart mysqld</div></pre></td></tr></table></figure><p>可在<code>override.conf</code>中设置如下参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[Service]</div><div class="line">PIDFile=/var/run/mysqld/mysqld-custom.pid</div><div class="line">ExecStart=</div><div class="line">ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld-custom.pid <span class="variable">$MYSQLD_OPTS</span></div></pre></td></tr></table></figure><p>在<code>/etc/sysconfig/mysql</code>下指定值：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LD_PRELOAD=/path/to/malloc/library</div><div class="line">TZ=time_zone_setting</div><div class="line"></div><div class="line"></div><div class="line">systemctl restart mysqld</div></pre></td></tr></table></figure><p><br></p><h4 id="使用systemd配置多个MySQL实例"><a href="#使用systemd配置多个MySQL实例" class="headerlink" title="使用systemd配置多个MySQL实例"></a>使用systemd配置多个MySQL实例</h4><p>Configuring Multiple MySQL Instances Using systemd</p><p><br></p><p>由于systemd具有在平台上管理多个MySQL实例的能力，而不必须需要<code>mysqld_multi</code>和<code>mysqld_multi.server</code>。</p><p>若要使用多实例(multiple-instance)功能，请修改<code>/etc/my.cnf</code>文件以包含每个实例的关键选项配置。<br>例如，管理replication01和replication02两个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">vim /etc/my.cnf</div><div class="line"></div><div class="line"></div><div class="line">[mysqld@replica01]</div><div class="line">datadir=/var/lib/mysql-replica01</div><div class="line">socket=/var/lib/mysql-replica01/mysql.sock</div><div class="line">port=3307</div><div class="line">log-error=/var/log/mysqld-replica01.log</div><div class="line"></div><div class="line"></div><div class="line">[mysqld@replica02]</div><div class="line">datadir=/var/lib/mysql-replica02</div><div class="line">socket=/var/lib/mysql-replica02/mysql.sock</div><div class="line">port=3308</div><div class="line">log-error=/var/log/mysqld-replica02.log</div></pre></td></tr></table></figure><p><strong>这里的名称使用<code>@</code>作为分隔符(delimiter)，因为这个是<code>systemd</code>支持的唯一分隔符。</strong></p><p>管理两个实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">systemctl start mysqld@replica01</div><div class="line">systemctl start mysqld@replica02</div><div class="line"></div><div class="line"></div><div class="line">systemctl enable mysqld@replica01</div><div class="line">systemctl enable mysqld@replica02</div><div class="line"></div><div class="line"></div><div class="line">#使用通配符</div><div class="line">systemctl status &apos;mysqld@replica*&apos;</div><div class="line"></div><div class="line"></div><div class="line">systemctl stop mysqld@replica0&#123;1,2&#125;</div></pre></td></tr></table></figure><p>对于同一个机器上的不同MySQL实例，systemd自动使用不同的单元文件。<br>在unit file中，<code>%I</code>和<code>%i</code>用于<code>@</code>标记后传入参数，用于管理特定实例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#像这样</span></div><div class="line">mysqld --defaults-group-suffix=@%I ...</div><div class="line"></div><div class="line"></div><div class="line">systemctl status mysqld@replica01</div><div class="line"></div><div class="line"><span class="comment"># mysqld@replica01.service - MySQL Server</span></div><div class="line"><span class="comment">#  Loaded: loaded (/usr/lib/systemd/system/mysqld@.service; disabled; vendor preset: disabled)</span></div><div class="line"><span class="comment">#  Active: active (running) since Tue 2018-02-27 12:18:34 CST; 1min 6s ago</span></div><div class="line"><span class="comment">#    Docs: man:mysqld(8)</span></div><div class="line"><span class="comment">#          http://dev.mysql.com/doc/refman/en/using-systemd.html</span></div><div class="line"><span class="comment"># Process: 3927 ExecStart=/usr/sbin/mysqld --defaults-group-suffix=@%I --daemonize --pid-file=/var/run/mysqld/mysqld-%i.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS)</span></div><div class="line"><span class="comment"># Process: 3845 ExecStartPre=/usr/bin/mysqld_pre_systemd %I (code=exited, status=0/SUCCESS)</span></div><div class="line"><span class="comment">#Main PID: 3930 (mysqld)</span></div><div class="line"><span class="comment">#  CGroup: /system.slice/system-mysqld.slice/mysqld@replica01.service</span></div><div class="line"><span class="comment">#          `-3930 /usr/sbin/mysqld --defaults-group-suffix=@replica01 --daemonize --pid-file=/var/run/mysqld/mysqld-replica01.pid</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#eb 27 12:18:27 zabbix.me systemd[1]: Starting MySQL Server...</span></div><div class="line"><span class="comment">#eb 27 12:18:34 zabbix.me systemd[1]: Started MySQL Server.</span></div></pre></td></tr></table></figure><p><br></p><h4 id="从mysqld-safe迁移到systemd"><a href="#从mysqld-safe迁移到systemd" class="headerlink" title="从mysqld_safe迁移到systemd"></a>从mysqld_safe迁移到systemd</h4><p>Migrating from mysqld_safe to systemd</p><p><br></p><p>因为<code>mysqld_safe</code>没有安装在使用<code>systemd</code>管理MySQL的平台上，所以以前需要为该程序指定选项：<code>[mysqld_safe]</code></p><ul><li>一些<code>[mysqld_safe]</code>的选项也能被<code>[mysqld]</code>支持</li><li>一些<code>[mysqld_safe]</code>的选项类似于<code>[mysqld]</code>选项</li></ul><p><br><br><br></p><h2 id="从源码安装MySQL"><a href="#从源码安装MySQL" class="headerlink" title="从源码安装MySQL"></a>从源码安装MySQL</h2><p>Installing MySQL from Source</p><p><br></p><p>从源代码构建MySQL使我们能够自定义构建参数(parameter)、编译器优化(compiler optimization)和安装位置(installation location)。</p><p>在使用源码安装前，请检查Oracle是否为你的平台生成预编译的二进制发行版，以及是否适合你。Oracle付出了很多努力确保提供的二进制文件具有最佳的性能选择。</p><p><strong>源码安装系统需求：</strong><br>使用源码安装MySQL需要多种开发工具。</p><p>使用源码安装MySQL，必须满足一下系统需求：</p><ul><li>CMake, which is used as the build framework on all platforms</li><li>A good make program</li><li>A working ANSI C++ compiler</li><li>The Boost C++ libraries are required to build MySQL</li><li>The ncurses library</li><li>Sufficient free memory</li><li>Perl is needed if you intend to run test scripts</li></ul><p>使用standard source distribution安装MySQL，需要以下工具来unpack分发文件：</p><ul><li>For a .tar.gz compressed tar file: <code>tar</code></li><li>For a .zip Zip archive: <code>zip</code></li><li>For an .rpm RPM package: <code>rpmbuild</code></li></ul><p><br><br><br></p><h3 id="用于源码安装的MySQL布局"><a href="#用于源码安装的MySQL布局" class="headerlink" title="用于源码安装的MySQL布局"></a>用于源码安装的MySQL布局</h3><p>MySQL Layout for Source Installation</p><p><br></p><p>默认地，再从源码编译后安装MySQL时，安装步骤会将文件安装在<code>/usr/local/mysql</code>下。</p><p><br><br><br></p><h3 id="使用标准源码发行版安装MySQL"><a href="#使用标准源码发行版安装MySQL" class="headerlink" title="使用标准源码发行版安装MySQL"></a>使用标准源码发行版安装MySQL</h3><p>Installing MySQL Using a Standard Source Distribution</p><p><br></p><p>从一个标准源码发行版安装MySQL：</p><ol><li>确保系统满足工具需求</li><li>获取发行文件</li><li>配置、构建和安装</li><li>执行安装后程序</li></ol><p><br></p><p>如果是source RPM:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpmbuild --rebuild --clean MySQL-VERSION.src.rpm</div></pre></td></tr></table></figure><p><br></p><p>如果是compressed tar file 或 zip archive source:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Preconfiguration setup</span></div><div class="line">shell&gt; groupadd mysql</div><div class="line">shell&gt; useradd -r -g mysql -s /bin/<span class="literal">false</span> mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Beginning of source-build specific instructions</span></div><div class="line">shell&gt; tar zxvf mysql-VERSION.tar.gz</div><div class="line">shell&gt; <span class="built_in">cd</span> mysql-VERSION</div><div class="line">shell&gt; mkdir bld</div><div class="line">shell&gt; <span class="built_in">cd</span> bld</div><div class="line">shell&gt; cmake ..</div><div class="line">shell&gt; make</div><div class="line">shell&gt; make install</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># End of source-build specific instructions</span></div><div class="line"><span class="comment"># Postinstallation setup</span></div><div class="line">shell&gt; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</div><div class="line">shell&gt; mkdir mysql-files</div><div class="line">shell&gt; chown mysql:mysql mysql-files</div><div class="line">shell&gt; chmod 750 mysql-files</div><div class="line">shell&gt; bin/mysqld --initialize --user=mysql</div><div class="line">shell&gt; bin/mysql_ssl_rsa_setup</div><div class="line">shell&gt; bin/mysqld_safe --user=mysql &amp;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Next command is optional</span></div><div class="line">shell&gt; cp support-files/mysql.server /etc/init.d/mysql.server</div></pre></td></tr></table></figure><p><strong>/sbin/nologin和/bin/false的区别</strong></p><ul><li>/bin/false是最严格的禁止login选项，一切服务都不能用<ul><li><code>mongod:x:996:994:mongod:/var/lib/mongo:/bin/false</code></li></ul></li><li>/sbin/nologin只是不允许系统login，可以使用其他服务<ul><li><code>ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</code></li></ul></li></ul><p><br></p><p><strong>执行预配置(preconfiguration)设置</strong></p><p>在Unix上，设置MySQL用户和组，用于运行和执行MySQL服务器和数据库目录。</p><p><br></p><p><strong>获得和解包distribution</strong></p><p>选择要解压分发的目录，并将位置更改到其中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tar zxvf mysql-VERSION.tar.gz</div><div class="line"></div><div class="line"><span class="comment">#gunzip &lt; mysql-VERSION.tar.gz | tar xvf -</span></div><div class="line"><span class="comment">#cmake -E tar zxvf mysql-VERSION.tar.gz</span></div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用开发源码树安装MySQL"><a href="#使用开发源码树安装MySQL" class="headerlink" title="使用开发源码树安装MySQL"></a>使用开发源码树安装MySQL</h3><p>Installing MySQL Using a Development Source Tree</p><p><br></p><p>install MySQL from the latest development source codew hich is hosted on GitHub: <a href="https://github.com/mysql/mysql-server" target="_blank" rel="noopener">https://github.com/mysql/mysql-server</a></p><p><strong>设置一个MySQL git repository</strong></p><ol><li>克隆MySQL git repository到本机</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/mysql/mysql-server.git</div></pre></td></tr></table></figure><ol><li>查看</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mysql-server</div></pre></td></tr></table></figure><ol><li>使用<code>git branch -r</code>查看远程MySQL分支</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mysql-server</div><div class="line"></div><div class="line">git branch -r</div></pre></td></tr></table></figure><ol><li>查看分支</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mysql-server</div><div class="line"></div><div class="line">git branch</div></pre></td></tr></table></figure><ol><li>切换分支</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mysql-server</div><div class="line"></div><div class="line">git checkout 5.7</div></pre></td></tr></table></figure><ol><li>获取远程MySQL git repository更新</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mysql-server</div><div class="line"></div><div class="line">git pull</div></pre></td></tr></table></figure><ol><li>检查提交历史</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> mysql-server</div><div class="line"></div><div class="line">git <span class="built_in">log</span></div><div class="line"></div><div class="line"><span class="comment">#也可在MySQL GitHub上查看commit history</span></div></pre></td></tr></table></figure><ol><li>在克隆MySQL git repository并切换到需要的分支后，便可以从源代码构建MySQL Server。</li></ol><p>在生产机器上从分发源码树安装构件时要小心，安装命令可能会覆盖您的实时发行版安装。</p><p><br><br><br></p><h3 id="MySQL源码配置选项"><a href="#MySQL源码配置选项" class="headerlink" title="MySQL源码配置选项"></a>MySQL源码配置选项</h3><p>MySQL Source-Configuration Options</p><p><br></p><p>CMake程序提供了一个强大的如何配置MySQL源码发行版的控制。</p><p>具体链接参考: <a href="https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html</a></p><p><br><br><br></p><h3 id="处理MySQL编译问题"><a href="#处理MySQL编译问题" class="headerlink" title="处理MySQL编译问题"></a>处理MySQL编译问题</h3><p>Dealing with Problems Compiling MySQL</p><p><br></p><ul><li>如果CMake先前已经运行过，那么现在运行的CMake可能使用先前的调用过程中收集到的信息。这些信息存储在 CMakeCache.txt。在CMake启动时，它会寻找和读取此文件。</li><li>每次运行<code>CMake</code>，必须再次运行<code>make</code>才能重新编译。</li></ul><p>防止使用old object file或配置文件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make clean</div><div class="line">rm CMakeCache.txt</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="安装之后的设置和测试"><a href="#安装之后的设置和测试" class="headerlink" title="安装之后的设置和测试"></a>安装之后的设置和测试</h2><p>Postinstallation Setup and Testing</p><p><br></p><p>在安装MySQL后你应该做的事：</p><ul><li>如有必要，初始化数据目录并创建MySQL授权表</li><li>开启Server并确保它可以正常访问</li><li>将密码分配给授权表中的root用户</li><li>可选地，设置Server自启动</li><li>可选地，填写时区表，以便识别时区</li></ul><p><br></p><h3 id="初始化数据目录"><a href="#初始化数据目录" class="headerlink" title="初始化数据目录"></a>初始化数据目录</h3><p>Initializing the Data Directory</p><p><br></p><p>安装MySQL之后，必须初始化数据目录，包括mysql系统数据库中的表。有些安装方法会自动初始化，有些则需要手动初始化。<br>当然，如果修改了默认数据目录位置，那么也是需要手动初始化的。</p><p>初始化数据库目录，主要是包含了初始MySQL授权表(grant table)的MySQL服务器，这些表确定了如何允许用户连接到服务器。<br>但是，初始化数据目录是不会覆盖(overwrite)任何现有权限表，因此在任何情况下运行都是安全的。</p><p>数据目录初始化会在MySQL数据库汇总创建time zone，但不会填充它，所以它是空的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</div><div class="line"></div><div class="line">mkdir mysql-files</div><div class="line"></div><div class="line">chown mysql:mysql ./mysql-files</div><div class="line">chmod 750 ./mysql-files</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--user</span></div><div class="line"><span class="comment">#使数据库目录文件属于mysql用户，以确保Server有读取权限</span></div><div class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqld --initialize --user=mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#开启安全连接</span></div><div class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysql_ssl_rsa_setup</div></pre></td></tr></table></figure><p><br></p><h4 id="使用mysqld手动初始化数据目录"><a href="#使用mysqld手动初始化数据目录" class="headerlink" title="使用mysqld手动初始化数据目录"></a>使用mysqld手动初始化数据目录</h4><p>Initializing the Data Directory Manually Using mysqld</p><p><br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql/bin</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#使数据库目录文件属于mysql用户，以确保Server有读取权限</span></div><div class="line"><span class="comment">#默认是secure，会生成root初始密码</span></div><div class="line">./mysqld --initialize --user=mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#不生成root初始密码</span></div><div class="line">./bin/mysqld --initialize-insecure --user=mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定目录</span></div><div class="line">--basedir=/usr/<span class="built_in">local</span>/mysql</div><div class="line">--datadir=/var/lib/mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#或者将其写入配置文件</span></div><div class="line">vim /etc/my.cnf</div><div class="line"></div><div class="line">[mysqld]</div><div class="line">basedir=/usr/<span class="built_in">local</span>/mysql</div><div class="line">datadir=/var/lib/mysql</div><div class="line"></div><div class="line"><span class="comment">#指定配置文件初始化</span></div><div class="line">./mysqld --defaults-file=/etc/mysql.cnf --initialize --user=mysql</div></pre></td></tr></table></figure><p><br></p><h4 id="使用mysql-install-db初始化数据目录"><a href="#使用mysql-install-db初始化数据目录" class="headerlink" title="使用mysql_install_db初始化数据目录"></a>使用mysql_install_db初始化数据目录</h4><p>Initializing the Data Directory Manually Using mysql_install_db</p><p><br></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql/bin</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#mysql_install_db命令会创建数据目录，并在数据目录下创建mysql数据库和授权表</span></div><div class="line">./mysql_install_db --user=mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定目录是必须的</span></div><div class="line">--basedir=/usr/<span class="built_in">local</span>/mysql</div><div class="line">--datadir=/var/lib/mysql</div><div class="line"></div><div class="line">./mysqld_safe --user=mysql &amp;</div><div class="line"><span class="comment">#systemctl start mysqld</span></div><div class="line"></div><div class="line">mysql -u root -p xxx</div><div class="line"></div><div class="line">mysql&gt;SET PASSWORD FOR <span class="string">'root'</span>@<span class="string">'localhost'</span> = PASSWORD(<span class="string">'new_password'</span>);</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Starting-the-Server"><a href="#Starting-the-Server" class="headerlink" title="Starting the Server"></a>Starting the Server</h3><ul><li>Start the MySQL server like this if your installation includes mysqld_safe<ul><li><code>/usr/local/mysql/binmysqld_safe --user=mysql &amp;</code></li></ul></li><li>Start the server like this if your installation includes systemd support<ul><li><code>systemctl start mysqld</code></li></ul></li><li>使用non-root用户运行MySQL服务很重要</li><li>如有错误请查看日志</li></ul><p><br><br><br></p><h3 id="Testing-the-Server"><a href="#Testing-the-Server" class="headerlink" title="Testing the Server"></a>Testing the Server</h3><p>执行一些简单测试以保证Server正常工作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#使用mysqladmin验证Server正在运行</span></div><div class="line">mysqladmin --<span class="built_in">help</span></div><div class="line"></div><div class="line">mysqladmin -uuser -ppasswd version</div><div class="line"></div><div class="line">mysqladmin -uuser -ppasswd variables</div><div class="line"></div><div class="line">mysqladmin -user -ppasswd shutdown</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 使用mysqlshow查看数据库</span></div><div class="line">mysqlshow -uuser -ppasswd</div><div class="line"></div><div class="line"><span class="comment">#查看指定数据库信息</span></div><div class="line">mysqlshow -uuser -ppasswd mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#读取信息</span></div><div class="line"><span class="comment">#-e,Execute command and quit</span></div><div class="line">mysql -uuser -ppasswd -e <span class="string">"SELECT user, host from mysql.user"</span></div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="保护初始化MySQL账户"><a href="#保护初始化MySQL账户" class="headerlink" title="保护初始化MySQL账户"></a>保护初始化MySQL账户</h3><p>Securing the Initial MySQL Accounts</p><p><br></p><p>在安装MySQL后，root账户密码可能已经被分配。</p><p><code>mysql.user</code>授权表定义了初始化MySQL用户账户和它们的访问权限。<br>MySQL5.7只创建了一个<code>&#39;root&#39;@&#39;localhost&#39;</code>账户，但早期的版本可能有多个用户。</p><p>请务必为每一个MySQL账户创建密码。</p><p>查看用户：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#存储在authentication_string列中的密码可能包含无法正常显示的二进制数据</span></div><div class="line"><span class="comment">#所以将其转换为十六进制</span></div><div class="line">mysql&gt; SELECT user, host, hex(authentication_string) FROM mysql.user;</div><div class="line">mysql&gt; SELECT user, host, authentication_string FROM mysql.user;</div><div class="line"></div><div class="line"><span class="comment">#或</span></div><div class="line">mysql -uuser -ppasswd -e <span class="string">"SELECT user, host, hex(authentication_string) FROM mysql.user;"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#5.7以前的版本</span></div><div class="line">mysql&gt; mysql&gt; SELECT user, host, password FROM mysql.user;</div><div class="line"></div><div class="line"><span class="comment">#或</span></div><div class="line">mysql -uuser -ppasswd -e <span class="string">"SELECT user, host, password FROM mysql.user;"</span></div></pre></td></tr></table></figure><p><br></p><p><strong>为root账户分配密码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#5.7.6</div><div class="line">mysql&gt; ALTER USER user IDENTIFIED BY &apos;new_passwd&apos;;</div><div class="line"></div><div class="line">mysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;new_passwd&apos;;</div><div class="line"></div><div class="line"></div><div class="line">#5.7.6前</div><div class="line">mysql&gt; SET PASSWORD FOR username = PASSWORD(&apos;new_passwd&apos;);</div><div class="line"></div><div class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;new_passwd&apos;);</div></pre></td></tr></table></figure><p><br></p><p><strong>给anonymous账户分配密码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SET PASSWORD FOR &apos;&apos;@&apos;localhost&apos; = PASSWORD(&apos;new_passwd&apos;);</div></pre></td></tr></table></figure><p><br></p><p><strong>移除匿名账户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; DROP USER &apos;&apos;@&apos;localhost&apos;;</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="升级或降级MySQL"><a href="#升级或降级MySQL" class="headerlink" title="升级或降级MySQL"></a>升级或降级MySQL</h2><p>Upgrading or Downgrading MySQL</p><p><br></p><ul><li>升级是一个常见的过程。请在测试系统上确保运行正常后再实施到生产环境</li><li>降级不太常见。一般是由于新版本在生产环境上发生某些兼容性或性能问题，并且是在测试环境中没有发现的情况下，从而需要降级。请现在测试系统上运行正常后再实施到生产环境。</li></ul><p><br><br><br></p><h3 id="升级MySQL"><a href="#升级MySQL" class="headerlink" title="升级MySQL"></a>升级MySQL</h3><p>请使用有管理权限的MySQL账户执行升级相关命令。(如root账户)</p><p><br></p><h4 id="MySQL升级策略"><a href="#MySQL升级策略" class="headerlink" title="MySQL升级策略"></a>MySQL升级策略</h4><p>MySQL Upgrade Strategies</p><p><br></p><p><strong>升级方法</strong></p><ul><li>直接升级(In-Place Upgrade)<ul><li>包含关闭旧版MySQL，替换为新的MySQL版本，在现有数据目录上重启MySQL，运行<code>mysql_upgrade</code></li></ul></li><li>逻辑升级(Logical Upgrade)<ul><li>包含使用<code>mysqldump</code>导出现有数据文件，安装新版MySQL，导入数据文件到新版MySQL，运行<code>mysql_upgrade</code></li></ul></li></ul><p><br></p><p><strong>升级路径</strong></p><ul><li>只支持GA release之间</li><li>这是一个发行系列的升级<ul><li>如5.6.x到5.6.y</li></ul></li><li>升级到下一个版本之前，建议先升级到最新版本<ul><li>如先升级到5.6最新版，再升级到5.7</li></ul></li><li>不支持跳版本升级<ul><li>如5.5到5.7</li></ul></li></ul><p><br></p><p><strong>升级之前</strong></p><ul><li>升级之前，请一定备份数据</li><li>查看新版本的Release Note<ul><li>删除和增加了什么功能</li></ul></li><li>新版本依赖什么</li><li>如果在InnoDB中使用XA事务，则在升级之前运行XA恢复以检查未提交的XA事务</li><li>如果MySQL数据量很大，就地升级以后可能需要很长的时间才能进行转换<ul><li>你可能会发现创建一个”dummy”数据库实例是很有用的，以及评估可能需要哪些转换以及执行这些转换所涉及的工作</li></ul></li><li>无论在你安装或升级到一个MySQL新版本，建议重建和重装MySQL language interface<ul><li>如PHP MySQL扩展</li></ul></li></ul><p><br></p><p><strong>直接升级</strong></p><ul><li>配置MySQL执行slow shutdown</li></ul><p>innoDB在关闭前执行一个完整的清除和更改缓冲区合并，这确保数据文件在不同的版本的文件格式做好充分准备。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u root -p --execute=<span class="string">"SET GLOBAL innodb_fast_shutdown=0"</span></div></pre></td></tr></table></figure><ul><li>关闭MySQL Server</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -uroot -p shutdown</div></pre></td></tr></table></figure><ul><li><p>升级MySQL</p></li><li><p>开启新版MySQL</p></li><li><p>运行mysql_upgrade</p></li></ul><p><code>mysql_upgrade</code>检查所有数据库中的所有表与当前版本MySQL的不兼容性。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql_upgrade -uroot -p</div><div class="line"></div><div class="line"><span class="comment">#Upgrade process completed successfully.</span></div><div class="line"><span class="comment">#Checking if update is needed.</span></div></pre></td></tr></table></figure><ul><li>关闭和重启MySQL Server来确保改变生效</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysqladmin -uroot -p shutdown</div><div class="line"></div><div class="line">systemctl start mysqld</div></pre></td></tr></table></figure><p><br></p><p><strong>逻辑升级</strong></p><ul><li>导出所有数据</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysqldump -uroot -p  --all-databases --force &gt; mysqldb_backup.sql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-f, --force         Continue even if we get an SQL error</span></div><div class="line"><span class="comment">#Use the --routines and --events options if your databases include stored programs</span></div><div class="line"><span class="comment">#--add-drop-database Add a DROP DATABASE before each create.</span></div><div class="line">mysqldump -uroot -p --add-drop-table --routines --events --all-databases --force &gt; mysqldb_backup.sql</div></pre></td></tr></table></figure><ul><li>关闭MySQL Server</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqladmin -uroot -p shutdown</div></pre></td></tr></table></figure><ul><li><p>安装新版MySQL</p></li><li><p>初始化MySQL并启动</p></li><li><p>载入数据文件</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -uroot -p --force &lt; ./mysqldb_backup.sql</div></pre></td></tr></table></figure><ul><li>运行mysql_upgrade</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql_upgrade -uroot -p</div><div class="line"></div><div class="line"><span class="comment">#Upgrade process completed successfully.</span></div><div class="line"><span class="comment">#Checking if update is needed.</span></div></pre></td></tr></table></figure><ul><li>关闭并重启MySQL Server以确保更改生效</li></ul><p><br></p><h4 id="通过MySQL-Yum-Repository进行升级"><a href="#通过MySQL-Yum-Repository进行升级" class="headerlink" title="通过MySQL Yum Repository进行升级"></a>通过MySQL Yum Repository进行升级</h4><p>Upgrading MySQL with the MySQL Yum Repository</p><p><br></p><p><strong>选择一个target series</strong></p><p>默认情况下，MySQL Yum Repository会将MySQL升级到该release系列的最新版本。如5.7.1升级到5.7.10。</p><p>如果要升级到其他release(如5.6到5.7)，就必须要先禁用此subrepository，并选择和启用新的subrepository。</p><p>As a general rule, to upgrade from one release series to another, go to the next series rather than skipping a series.</p><p><br></p><p><strong>升级MySQL</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum update mysql-server mysql-client</div></pre></td></tr></table></figure><p><br></p><p><strong>重启MySQL</strong></p><p>MySQL Server总是在Yum更新之后重启，一旦重启，请运行<code>mysql_upgrade</code>来检查旧数据与升级软件之间的任何不兼容问题。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mysql_upgrade -uroot -p</div><div class="line"></div><div class="line"><span class="comment">#Upgrade process completed successfully.</span></div><div class="line"><span class="comment">#Checking if update is needed.</span></div></pre></td></tr></table></figure><p><br></p><p><strong>升级Shared Client Libraries</strong></p><p>所以说，用yum repository安装软件是很方便的。不管是在管理还是升级等方面…</p><p><br></p><h4 id="通过直接下载RPM包升级MySQL"><a href="#通过直接下载RPM包升级MySQL" class="headerlink" title="通过直接下载RPM包升级MySQL"></a>通过直接下载RPM包升级MySQL</h4><p>直接下载mysql相应组件的rpm进行升级。<br>建议备份好配置文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql-community-server-5.7.20-1.el7.x86_64.rpm</div><div class="line">wget http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql-community-client-5.7.20-1.el7.x86_64.rpm</div><div class="line"></div><div class="line"></div><div class="line">yum install mysql-community-server-5.7.20-1.el7.x86_64.rpm mysql-community-client-5.7.20-1.el7.x86_64.rpm</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="mysql降级"><a href="#mysql降级" class="headerlink" title="mysql降级"></a>mysql降级</h3><p>MySQL降级类似于MySQL升级。也包含有直接降级和逻辑降级。</p><p><br><br><br></p><h3 id="重建或修复表或索引"><a href="#重建或修复表或索引" class="headerlink" title="重建或修复表或索引"></a>重建或修复表或索引</h3><p>Rebuilding or Repairing Tables or Indexes</p><p><br></p><ul><li>MySQL处理数据类型和字符集的方式的更改</li><li>表维修或升级(mysqlcheck, mysql_upgrade)</li></ul><p>重建表的方法：</p><ul><li>Dump and Reload</li><li>ALTER TABLE</li><li>REPAIR TABLE</li></ul><p><br></p><p><strong>Dump and Reload Method</strong></p><p>由于MySQL升级/降级之后，不同版本的MySQL无法处理这些表，则需要转储和重载的方法来重建表。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysqldump -uroot -p --all-databases --force &gt; mysql_backdb.sql</div><div class="line">mysql -uroot -p --force &lt; mysql_backdb.sql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#某个库或表</span></div><div class="line">mysqldump -uroot -p --databases <span class="built_in">test</span> --force &gt; db_test.sql</div><div class="line">mysql -uroot -p <span class="built_in">test</span> &lt; db_test.sql</div><div class="line"></div><div class="line">mysqldump -uroot -p --databases <span class="built_in">test</span> --tables table222 &gt; table222.sql</div><div class="line">mysql -uroot -p <span class="built_in">test</span>  &lt; table222.sql</div></pre></td></tr></table></figure><p><br></p><p><strong>ALTER TABLE Method</strong></p><p>更改表以使用它已经拥有的存储引擎。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE test ENGINE = InnoDB;</div></pre></td></tr></table></figure><p><br></p><p><strong>REPAIR TABLE Method</strong></p><p><code>REPAIR TABLE</code>仅适用于MyISAM， ARCHIVE和 csv 表。</p><p><code>mysqlcheck --repair</code>提供了对<code>REPAIR TABLE</code>的命令行访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">REPAIR TABLE t1;</div><div class="line"></div><div class="line"></div><div class="line">mysqlcheck --repair --databases db_name ...</div><div class="line">mysqlcheck --repair --all-databases</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="复制MySQL数据库到其他机器"><a href="#复制MySQL数据库到其他机器" class="headerlink" title="复制MySQL数据库到其他机器"></a>复制MySQL数据库到其他机器</h3><p>Copying MySQL Databases to Another Machine</p><p><br></p><p>在需要为不同体系架构之间传输MySQL数据库时，可使用<code>mysqldump</code>创建包含SQL语句的<code>.sql</code>文件，然后复制到另外的计算机上，将其作为输入提供给MySQL客户端。</p><p>不要忘记复制mysql数据库，因为这个存储授权表的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysqldump --host &apos;remote-host&apos; -uxxx -p --compress --all-databases | mysql -uxxx -p</div><div class="line"></div><div class="line">mysqldump --host &apos;remote-host&apos; -uxxx -p --compress db_name | mysql -uxxx -p db_name</div><div class="line"></div><div class="line"></div><div class="line">mysqladmin -uxxx -p flush-privileges</div></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h1><p>如何使用MySQL client程序来创建和使用数据库。</p><p><br></p><h2 id="连接和断开服务器"><a href="#连接和断开服务器" class="headerlink" title="连接和断开服务器"></a>连接和断开服务器</h2><p>Connecting to and Disconnecting from the Server</p><p><br></p><p>Like this:</p><ul><li>不建议把密码直接写在命令行上</li><li>host表示了MySQL Server运行在的机器</li><li>某些MySQL允许匿名用户连接</li><li><code>-ppassword, not as -p password</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql --host host --user username -p</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#maybe not default port</span></div><div class="line">mysql --host host --user username -p  --port port</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#匿名用户连接</span></div><div class="line">mysql</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#退出</span></div><div class="line">mysql&gt; QUIT</div><div class="line"><span class="comment">#Unix</span></div><div class="line">mysql&gt; Ctrl+D</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="输入查询"><a href="#输入查询" class="headerlink" title="输入查询"></a>输入查询</h2><p>Entering Queries</p><p><br></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#简单查询</div><div class="line">mysql&gt; SELECT VERSION(), CURRENT_DATE;</div><div class="line"></div><div class="line"></div><div class="line">#简单计算</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">SIN</span>(<span class="keyword">PI</span>()/<span class="number">2</span>), (<span class="number">4</span>+<span class="number">1</span>)*<span class="number">5</span>;</div><div class="line"></div><div class="line"></div><div class="line">#一行中输入多个语句</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>(); <span class="keyword">SELECT</span> <span class="keyword">NOW</span>();</div><div class="line"></div><div class="line"></div><div class="line">#多行输入一个命令</div><div class="line">mysql&gt; SELECT</div><div class="line">    -&gt; USER()</div><div class="line">    -&gt; ,</div><div class="line">    -&gt; CURRENT_DATE;</div></pre></td></tr></table></figure><p><img src="/images/MySQL/20180301101009.jpg" alt="MySQL简单查询"></p><p><br></p><p>这QUERY说明了有关MySQL的几件事：</p><ul><li>MySQL查询通常由一个<code>SQL statement</code>和<code>;</code>组成</li><li>MySQL将查询发送给服务器并返回结果，然后打印下一个<code>mysql&gt;</code>提示</li><li>MySQL以表格形式(rows and columns)显示查询输出</li><li>MySQL显示返回多少行，以及执行查询花费了多长时间</li><li>MySQL查询不区分大小写，但建议使用大写</li><li>MySQL支持在一行中输入多个语句</li><li>MySQL支持一个命令多行输入</li></ul><p><br></p><p><strong>MySQL提示符：</strong></p><table><thead><tr><th>Prompt</th><th>Meaning</th></tr></thead><tbody><tr><td><code>mysql&gt;</code></td><td>准备新查询</td></tr><tr><td><code>-&gt;</code></td><td>等待多行查询的下一行</td></tr><tr><td><code>&#39;&gt;</code></td><td>等待下一行，等待单引号开头的字符串的完成</td></tr><tr><td><code>&quot;&gt;</code></td><td>等待下一行，等待双引号字开头的字符串的完成</td></tr><tr><td><code>\</code>&gt;`</td><td>等待下一行，等待以反引号开始的标识符的完成</td></tr><tr><td><code>/*&gt;</code></td><td>等待下一行，等待以<code>/*</code>开头的注释的完成–&gt;<code>/*comments*/</code></td></tr></tbody></table><p><br><br><br></p><h2 id="创建和使用数据库"><a href="#创建和使用数据库" class="headerlink" title="创建和使用数据库"></a>创建和使用数据库</h2><p>Creating and Using a Database</p><p><br></p><p>大致操作：</p><ul><li>Create a database</li><li>Create a table</li><li>Load data into the table</li><li>Retrieve data from the table in various ways</li><li>Use multiple tables</li></ul><p><br></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#显示数据库</div><div class="line">#不能显示你没有权限的数据库</div><div class="line">mysql&gt; SHOW DATABASES;</div><div class="line"></div><div class="line">#mysql数据库描述用户访问权限</div><div class="line">#test数据库通常作为用户尝试使用工作区</div><div class="line"></div><div class="line"></div><div class="line">#访问数据库</div><div class="line">mysql&gt; USE test;</div><div class="line"></div><div class="line">#USE和QUIT一样可以不使用分号，使用也无妨</div><div class="line">#USE只能是一个单行</div><div class="line"></div><div class="line"></div><div class="line">#授权</div><div class="line">#GRANT ALL ON da_name.table TO 'username'@'host';</div><div class="line">mysql&gt; GRANT ALL ON test.* TO 'test'@'127.0.0.1';</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="创建和选择数据库"><a href="#创建和选择数据库" class="headerlink" title="创建和选择数据库"></a>创建和选择数据库</h3><p>Creating and Selecting a Database</p><p><br></p><p><strong>Unix是区分大小写的(case-sensitive)，这与SQL keyword不一致。请注意。</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysql&gt; CREATE DATABASE db01;</div><div class="line"></div><div class="line">mysql&gt; USE db01;</div><div class="line"></div><div class="line">#也可在mysql连接时直接指定数据库</div><div class="line">mysql -u username -p db01</div><div class="line"></div><div class="line"></div><div class="line">#查看当前选择的数据库</div><div class="line">mysql&gt; SELECT DATABASE();</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>Creating a Table</p><p><br></p><p><strong>困难的部分是决定数据库的结构应该是什么： 你需要哪些表以及每个表中应该包含哪些列。</strong></p><p><code>VARCHAR</code>对于name，owner，species来说是一个不错的选择，因为column值的长度有所不同。<br><code>DATE</code>对于出生和死亡column来说很不错。<br>如果以后你发现你需要更长的字段，MySQL提供了一个<code>ALTER TABLE</code>语句来修改。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#创建一个宠物表</div><div class="line">mysql&gt; CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),</div><div class="line">    -&gt; species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SHOW TABLES;</div><div class="line"></div><div class="line"></div><div class="line">#验证表格</div><div class="line">#如果你忘记了表中列的名称或类型，使用DESCRIBE</div><div class="line">mysql&gt; DECRIBE pet;</div><div class="line">+<span class="comment">---------+-------------+------+-----+---------+-------+</span></div><div class="line">| Field   | Type        | Null | Key | Default | Extra |</div><div class="line">+<span class="comment">---------+-------------+------+-----+---------+-------+</span></div><div class="line">| name    | varchar(20) | YES  |     | NULL    |       |</div><div class="line">| owner   | varchar(20) | YES  |     | NULL    |       |</div><div class="line">| species | varchar(20) | YES  |     | NULL    |       |</div><div class="line">| sex     | char(1)     | YES  |     | NULL    |       |</div><div class="line">| birth   | date        | YES  |     | NULL    |       |</div><div class="line">| death   | date        | YES  |     | NULL    |       |</div><div class="line">+<span class="comment">---------+-------------+------+-----+---------+-------+</span></div><div class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="将数据载入表格"><a href="#将数据载入表格" class="headerlink" title="将数据载入表格"></a>将数据载入表格</h3><p>Loading Data into a Table</p><p><br></p><p>假设pet表信息如下：</p><table><thead><tr><th>name</th><th>owner</th><th>species</th><th>sex</th><th>birth</th><th>death</th></tr></thead><tbody><tr><td>PetA</td><td>Aa</td><td>cat</td><td>f</td><td>1993-02-04</td><td></td></tr><tr><td>PetB</td><td>Bb</td><td>cat</td><td>m</td><td>1994-03-17</td><td></td></tr><tr><td>PetC</td><td>Cc</td><td>dog</td><td>f</td><td>1989-05-13</td><td></td></tr><tr><td>PetD</td><td>Aa</td><td>dog</td><td>m</td><td>1979-08-25</td><td>1995-02-21</td></tr><tr><td>PetE</td><td>Cc</td><td>bird</td><td></td><td>1991-02-17</td><td></td></tr></tbody></table><p><br></p><p>你可以创建一个<code>pet.txt</code>文本文件，每行包含一个记录，值由制表符分割，并按照<code>CREATE TABLE</code>语句中列出的顺序给出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vim pet.txt</div><div class="line"></div><div class="line"></div><div class="line">PetA    Aa     cat    f      1993-02-04    \N</div><div class="line">PetB    Bb     cat    m      1994-03-17    \N</div><div class="line">PetC    Cc     dog    f      1989-05-13    \N</div><div class="line">PetD    Aa     dog    m      1979-08-25    1995-02-21</div><div class="line">PetE    Cc     bird  \N      1991-02-17    \N</div></pre></td></tr></table></figure><p>将<code>pet.txt</code>载入<code>pet</code>表中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">mysql&gt; LOAD DATA LOCAL INFILE '/path/file.txt' INTO TABLE table_name;</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; LOAD DATA LOCAL INFILE '/home/zhang/pet.txt' INTO TABLE pet;</div><div class="line">Query OK, 5 rows affected, 0 warnings (0.00 sec)</div><div class="line">Records: 5  Deleted: 0  Skipped: 0  Warnings: 0</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM pet;</div><div class="line">+<span class="comment">-------+-------+---------+------+------------+------------+</span></div><div class="line">| name  | owner | species | sex  | birth      | death      |</div><div class="line">+<span class="comment">-------+-------+---------+------+------------+------------+</span></div><div class="line">| PetA  |  Aa   |  cat    | f    | 1993-02-04 | NULL       |</div><div class="line">| PetB  |  Bb   |  cat    | m    | 1994-03-17 | NULL       |</div><div class="line">| PetC  |  Cc   |  dog    | f    | 1989-05-13 | NULL       |</div><div class="line">| PetD  |  Aa   |  dog    | m    | 1979-08-25 | 1995-02-21 |</div><div class="line">| PetE  |  Cc   |  bird   | NULL | 1991-02-17 | NULL       |</div><div class="line">+<span class="comment">-------+-------+---------+------+------------+------------+</span></div><div class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#通过命令行载入</div><div class="line">mysql&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> pet</div><div class="line">    -&gt; <span class="keyword">VALUES</span> (<span class="string">'PetF'</span>, <span class="string">'Ff'</span>, <span class="string">'hamster'</span>, <span class="string">'f'</span>, <span class="string">'1999-03-21'</span>, <span class="literal">NULL</span>)</div><div class="line">    -&gt; ;</div><div class="line">Query OK, 1 row affected (0.00 sec)</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="从表中检索信息"><a href="#从表中检索信息" class="headerlink" title="从表中检索信息"></a>从表中检索信息</h3><p>Retrieving Information from a Table</p><p><br></p><p><code>SELECT</code>语句用于从表中提取信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> what_to_select</div><div class="line"><span class="keyword">FROM</span> which_table</div><div class="line"><span class="keyword">WHERE</span> condition;</div></pre></td></tr></table></figure><p><br></p><h4 id="查询所有数据"><a href="#查询所有数据" class="headerlink" title="查询所有数据"></a>查询所有数据</h4><p>Selecting All Data</p><p><br></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM pet;</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; DELETE FROM pet;</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; UPDATE pet SET birth = '1989-06-17' WHERE name = 'PetC';</div></pre></td></tr></table></figure><p><br></p><h4 id="查询特定行"><a href="#查询特定行" class="headerlink" title="查询特定行"></a>查询特定行</h4><p>Selecting Particular Rows</p><p><br></p><p>当一个表很大时，你通常不想看到整个表。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#条件查询</div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM pet WHERE name = 'PetA';</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM pet WHERE owner = 'Cc';</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM pet WHERE birth &gt;= '1990-01-01';</div><div class="line"></div><div class="line"></div><div class="line">#AND</div><div class="line">mysql&gt; SELECT * FROM pet WHERE species = 'dog' AND sex = 'f';</div><div class="line"></div><div class="line"></div><div class="line">#OR</div><div class="line">mysql&gt; SELECT * FROM pet WHERE species = 'dog' OR species = 'bird';</div><div class="line"></div><div class="line"></div><div class="line">#AND和OR也可以混合使用</div><div class="line">mysql&gt; SELECT * FROM pet WHERE (species = 'cat' AND sex = 'm') OR (species = 'dog' AND sex='f');</div></pre></td></tr></table></figure><p><br></p><h4 id="查询特定列"><a href="#查询特定列" class="headerlink" title="查询特定列"></a>查询特定列</h4><p>Selecting Particular Columns</p><p><br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT name FROM pet;</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SELECT name, species FROM pet;</div><div class="line"></div><div class="line"></div><div class="line">#获取唯一结果</div><div class="line">mysql&gt; SELECT DISTINCT species FROM pet;</div><div class="line">+<span class="comment">---------+</span></div><div class="line">| species |</div><div class="line">+<span class="comment">---------+</span></div><div class="line">| cat     |</div><div class="line">| dog     |</div><div class="line">| bird    |</div><div class="line">+<span class="comment">---------+</span></div><div class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, species, birth <span class="keyword">FROM</span> pet <span class="keyword">WHERE</span> species = <span class="string">'dog'</span> <span class="keyword">OR</span> species = <span class="string">'cat'</span>;</div></pre></td></tr></table></figure><p><br></p><h4 id="行排序"><a href="#行排序" class="headerlink" title="行排序"></a>行排序</h4><p>Sorting Rows</p><p><br></p><p>使用<code>ORDER BY</code>语句对结果进行排序。默认排序顺序是升序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT name, birth FROM pet ORDER BY birth;</div><div class="line">+<span class="comment">------+------------+</span></div><div class="line">| name | birth      |</div><div class="line">+<span class="comment">------+------------+</span></div><div class="line">| PetD | 1979-08-25 |</div><div class="line">| PetC | 1989-06-17 |</div><div class="line">| PetE | 1991-02-17 |</div><div class="line">| PetA | 1993-02-04 |</div><div class="line">| PetB | 1994-03-17 |</div><div class="line">+<span class="comment">------+------------+</span></div><div class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div><div class="line"></div><div class="line"></div><div class="line">#倒序</div><div class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, birth <span class="keyword">FROM</span> pet <span class="keyword">ORDER</span> <span class="keyword">BY</span> birth <span class="keyword">DESC</span>;</div></pre></td></tr></table></figure><p>可对多列进行排序，也可按不同的方向对不同的列进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT name, species, birth FROM pet</div><div class="line">    -&gt; ORDER BY species, birth DESC;</div><div class="line">+<span class="comment">------+---------+------------+</span></div><div class="line">| name | species | birth      |</div><div class="line">+<span class="comment">------+---------+------------+</span></div><div class="line">| PetE | bird    | 1991-02-17 |</div><div class="line">| PetB | cat     | 1994-03-17 |</div><div class="line">| PetA | cat     | 1993-02-04 |</div><div class="line">| PetC | dog     | 1989-06-17 |</div><div class="line">| PetD | dog     | 1979-08-25 |</div><div class="line">+<span class="comment">------+---------+------------+</span></div><div class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, species, birth <span class="keyword">FROM</span> pet</div><div class="line">    -&gt; <span class="keyword">ORDER</span> <span class="keyword">BY</span> species <span class="keyword">DESC</span>, birth <span class="keyword">DESC</span></div></pre></td></tr></table></figure><p><br></p><h4 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h4><p>Date Calculations</p><p><br></p><p>MySQL提供了几个函数用于日期计算。如计算年龄或提取日期一部分等。</p><p><br></p><ul><li><code>TIMESTAMPDIFF()</code><ul><li>使用<code>TIMESTAMPDIFF()</code>函数计算pet的年龄。它的两个参数为两个相隔的日期</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT name, species, birth, CURDATE(),</div><div class="line">    -&gt; TIMESTAMPDIFF(YEAR, birth, CURDATE()) AS age</div><div class="line">    -&gt; FROM pet</div><div class="line">    -&gt; ORDER BY age DESC;</div><div class="line">+<span class="comment">------+---------+------------+------------+------+</span></div><div class="line">| name | species | birth      | CURDATE()  | age  |</div><div class="line">+<span class="comment">------+---------+------------+------------+------+</span></div><div class="line">| PetD | dog     | 1979-08-25 | 2018-03-01 |   38 |</div><div class="line">| PetC | dog     | 1989-06-17 | 2018-03-01 |   28 |</div><div class="line">| PetE | bird    | 1991-02-17 | 2018-03-01 |   27 |</div><div class="line">| PetA | cat     | 1993-02-04 | 2018-03-01 |   25 |</div><div class="line">| PetB | cat     | 1994-03-17 | 2018-03-01 |   23 |</div><div class="line">+<span class="comment">------+---------+------------+------------+------+</span></div><div class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div><div class="line"></div><div class="line"></div><div class="line">#死去的pet的age</div><div class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, species, birth, death,</div><div class="line">    -&gt; <span class="keyword">TIMESTAMPDIFF</span>(<span class="keyword">YEAR</span>, birth, death) <span class="keyword">AS</span> age</div><div class="line">    -&gt; <span class="keyword">FROM</span> pet</div><div class="line">    -&gt; <span class="keyword">WHERE</span> death <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">    -&gt; <span class="keyword">ORDER</span> <span class="keyword">BY</span> age;</div><div class="line">+<span class="comment">------+---------+------------+------------+------+</span></div><div class="line">| name | species | birth      | death      | age  |</div><div class="line">+<span class="comment">------+---------+------------+------------+------+</span></div><div class="line">| PetD | dog     | 1979-08-25 | 1995-02-21 |   15 |</div><div class="line">+<span class="comment">------+---------+------------+------------+------+</span></div><div class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure><p><br></p><ul><li><code>YEAR()</code><ul><li>年</li></ul></li><li><code>MONTH()</code><ul><li>月</li></ul></li><li><code>DAYOFMONTH()</code><ul><li>日</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT name, birth,</div><div class="line">    -&gt; YEAR(birth) AS bir_year,</div><div class="line">    -&gt; MONTH(birth) AS bir_month,</div><div class="line">    -&gt; DAYOFMONTH(birth) AS bir_day</div><div class="line">    -&gt; FROM pet;</div><div class="line">+<span class="comment">------+------------+----------+-----------+---------+</span></div><div class="line">| name | birth      | bir_year | bir_month | bir_day |</div><div class="line">+<span class="comment">------+------------+----------+-----------+---------+</span></div><div class="line">| PetA | 1993-02-04 |     1993 |         2 |       4 |</div><div class="line">| PetB | 1994-03-17 |     1994 |         3 |      17 |</div><div class="line">| PetC | 1989-06-17 |     1989 |         6 |      17 |</div><div class="line">| PetD | 1979-08-25 |     1979 |         8 |      25 |</div><div class="line">| PetE | 1991-02-17 |     1991 |         2 |      17 |</div><div class="line">+<span class="comment">------+------------+----------+-----------+---------+</span></div><div class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#查找生日是<span class="number">2</span>月的pet</div><div class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">name</span>, birth <span class="keyword">FROM</span> pet <span class="keyword">WHERE</span> <span class="keyword">MONTH</span>(birth) =<span class="number">2</span>;</div><div class="line">+<span class="comment">------+------------+</span></div><div class="line">| name | birth      |</div><div class="line">+<span class="comment">------+------------+</span></div><div class="line">| PetA | 1993-02-04 |</div><div class="line">| PetE | 1991-02-17 |</div><div class="line">+<span class="comment">------+------------+</span></div></pre></td></tr></table></figure><p><br></p><ul><li><code>DATE_ADD()</code><ul><li>将日期间隔添加到给定日期</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT name, birth FROM pet</div><div class="line">    -&gt; WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(), INTERVAL 1 MONTH));</div></pre></td></tr></table></figure><p><br></p><h4 id="使用NULL值"><a href="#使用NULL值" class="headerlink" title="使用NULL值"></a>使用NULL值</h4><p>Working with NULL Values</p><p><br></p><p>从概念上讲，NULL value意味着<strong>一个缺失的未知值</strong>，它与其它值在某种程度上是不同的。</p><ul><li>使用<code>IS NULL</code>和<code>IS NOT NULL</code>操作符</li><li>不能对NULL value使用算术运算符(arithmetic cpmparison operators)<ul><li>如：<code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;&gt;</code></li><li>任何对NULL value的算术运算符的结果也是NULL value，所以无法得到有意义的结果</li></ul></li><li>在MySQL中，0或NULL表示false，其他任何值都意味着true</li><li>两个NULL在<code>GROUP BY</code>中被认为是相等的</li><li>NULL在<code>ORDER BY</code>正向排序中首先显示。反之，最后显示</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT 1 IS NULL, 1 IS NOT NULL;</div><div class="line">+<span class="comment">-----------+---------------+</span></div><div class="line">| 1 IS NULL | 1 IS NOT NULL |</div><div class="line">+<span class="comment">-----------+---------------+</span></div><div class="line">|         0 |             1 |</div><div class="line">+<span class="comment">-----------+---------------+</span></div></pre></td></tr></table></figure><p>因此，完全可以将一个<strong>zero</strong>或<strong>empty string</strong>插入到一个<strong>NOT NULL</strong>的column中，因为这些值NOT NULL。</p><p><br></p><h4 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h4><p>Pattern Matching</p><p><br></p><p>MySQL提供标准的SQL模式匹配以及基于扩展正则表达式的模式匹配形式。类似于Unix实用程序(vi, grep, sed…)</p><p>SQL模式匹配允许:</p><ul><li>使用<code>_</code>来匹配可以使用的任意单字符(single character)</li><li>使用<code>%</code>来匹配可以使用的任意数目的字符(arbitrary number of characters)</li><li>SQL模式不区分大小写</li><li>使用<code>LIKE</code>或<code>NOT LIKE</code>而不是<code>=</code>或<code>&lt;&gt;</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM pet WHERE name LIKE '%b';</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| name | owner | species | sex  | birth      | death |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| PetB | Bb    | cat     | m    | 1994-03-17 | NULL  |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM pet WHERE name LIkE '___A' or name LIKE '___C';</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| name | owner | species | sex  | birth      | death |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| PetA | Aa    | cat     | f    | 1993-02-04 | NULL  |</div><div class="line">| PetC | Cc    | dog     | f    | 1989-06-17 | NULL  |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div></pre></td></tr></table></figure><p><br></p><p>MySQL提供的其它类型的模式匹配使用扩展的正则表达式：</p><ul><li><code>REGEXP</code> 或 <code>RLIKE</code></li><li><code>NOT REGEXP</code> 或 <code>NOT RLIKE</code></li><li>了解正则表达式知识</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE '^pet[AB]';</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| name | owner | species | sex  | birth      | death |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| PetA | Aa    | cat     | f    | 1993-02-04 | NULL  |</div><div class="line">| PetB | Bb    | cat     | m    | 1994-03-17 | NULL  |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM pet WHERE owner RLIKE 'c$';</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| name | owner | species | sex  | birth      | death |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| PetC | Cc    | dog     | f    | 1989-06-17 | NULL  |</div><div class="line">| PetE | Cc    | bird    | NULL | 1991-02-17 | NULL  |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#包含某个字符</div><div class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE 'ete';</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| name | owner | species | sex  | birth      | death |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line">| PetE | Cc    | bird    | NULL | 1991-02-17 | NULL  |</div><div class="line">+<span class="comment">------+-------+---------+------+------------+-------+</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#匹配字符个数</div><div class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE '^....$';</div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE '^.&#123;4&#125;$';</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#强制区分大小写</div><div class="line">mysql&gt; SELECT * FROM pet WHERE name RLIKE BINARY '^Pet[AB]';</div></pre></td></tr></table></figure><p><br></p><h4 id="行数计算"><a href="#行数计算" class="headerlink" title="行数计算"></a>行数计算</h4><p>Counting Rows</p><p><br></p><ul><li>使用<code>COUNT()</code>计算行数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#总行数</div><div class="line">mysql&gt; SELECT COUNT(*) AS count FROM pet;</div><div class="line">+<span class="comment">-------+</span></div><div class="line">| count |</div><div class="line">+<span class="comment">-------+</span></div><div class="line">|     5 |</div><div class="line">+<span class="comment">-------+</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#针对某个统计行数</div><div class="line">mysql&gt; SELECT owner, COUNT(*) FROM pet GROUP BY owner;</div><div class="line">+<span class="comment">-------+----------+</span></div><div class="line">| owner | COUNT(*) |</div><div class="line">+<span class="comment">-------+----------+</span></div><div class="line">| Aa    |        2 |</div><div class="line">| Bb    |        1 |</div><div class="line">| Cc    |        2 |</div><div class="line">+<span class="comment">-------+----------+</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#多个条件</div><div class="line">mysql&gt; SELECT species, sex, COUNT(*) FROM pet GROUP BY species, sex;</div><div class="line">+<span class="comment">---------+------+----------+</span></div><div class="line">| species | sex  | COUNT(*) |</div><div class="line">+<span class="comment">---------+------+----------+</span></div><div class="line">| bird    | NULL |        1 |</div><div class="line">| cat     | f    |        1 |</div><div class="line">| cat     | m    |        1 |</div><div class="line">| dog     | f    |        1 |</div><div class="line">| dog     | m    |        1 |</div><div class="line">+<span class="comment">---------+------+----------+</span></div></pre></td></tr></table></figure><p><br></p><h4 id="使用多个表"><a href="#使用多个表" class="headerlink" title="使用多个表"></a>使用多个表</h4><p>Using More Than one Table</p><p><br></p><p>创建一个额外的宠物信息表：</p><table><thead><tr><th>name</th><th>date</th><th>type</th><th>remark</th></tr></thead><tbody><tr><td>Fluffy</td><td>1995-05-15</td><td>litter</td><td>4 kittens, 3 female, 1 male</td></tr><tr><td>Buffy</td><td>1993-06-23</td><td>litter</td><td>5 puppies, 2 female, 3 male</td></tr><tr><td>Buffy</td><td>1994-06-19</td><td>litter</td><td>3 puppies, 3 female</td></tr><tr><td>Chirpy</td><td>1999-03-21</td><td>vet</td><td>needed beak straightened</td></tr><tr><td>Slim</td><td>1997-08-03</td><td>vet</td><td>broken rib</td></tr><tr><td>Bowser</td><td>1991-10-12</td><td>kennel</td><td></td></tr><tr><td>Fang</td><td>1991-10-12</td><td>kennel</td><td></td></tr><tr><td>Fang</td><td>1998-08-28</td><td>birthday</td><td>Gave him a new chew toy</td></tr><tr><td>Claws</td><td>1998-03-17</td><td>birthday</td><td>Gave him a new flea collar</td></tr><tr><td>Whistler</td><td>1998-12-09</td><td>birthday</td><td>First birthday</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mysql&gt; CREATE TABLE event ( name VARCHAR(20), date DATE,</div><div class="line">    -&gt; type VARCHAR(15), remark VARCHAR(255) );</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; LOAD DATA INFILE '/path/event.txt' INTO TABLE event;</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="获取数据库和表的信息"><a href="#获取数据库和表的信息" class="headerlink" title="获取数据库和表的信息"></a>获取数据库和表的信息</h2><p>Getting Information About Databases and Tables</p><p><br></p><ul><li>查看当前数据库<ul><li><code>mysql&gt; SELECT DATABASE();</code></li></ul></li><li>查看当前数据库下的表<ul><li><code>mysql&gt; SHOW TABLES;</code></li></ul></li><li>查看表的结构<ul><li><code>mysql&gt; DESCRIBE pet;</code></li></ul></li><li>创建数据库<ul><li><code>mysql&gt; CREATE DATABASE db_01;</code></li></ul></li><li>创建表<ul><li><code>mysql&gt; CREATE TABLE table_01 {c1 VARCHAR(10), c2 INT, ...};</code></li></ul></li><li>查看索引(如果存在)<ul><li><code>SHOW INDEX FROM table_01;</code></li></ul></li></ul><p><br><br><br></p><h2 id="在批处理下使用mysql"><a href="#在批处理下使用mysql" class="headerlink" title="在批处理下使用mysql"></a>在批处理下使用mysql</h2><p>Using mysql in Batch Mode</p><p><br></p><p>在前面，我们都是使用MySQL交互式(interactively)输入命令并查看结果。但还可在批处理模式下运行MySQL。<br>我们可以创建一个脚本文件，然后以这种方式执行脚本文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql &lt; batch-file</div><div class="line"></div><div class="line">msyql -h host -u user -p &lt; /path/batch-file</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#出现错误也继续运行</span></div><div class="line">msyql -h host -u user -p --force &lt; /path/batch-file</div></pre></td></tr></table></figure><p><br></p><p>为什么要使用脚本：</p><ul><li>如果需要反复(repeat)执行查询，将其写入脚本以避免每次执行时重新输入查询</li><li>通过复制和修改脚本文件从现有查询中生成新的查询</li><li>批处理模型在开发查询时也很有用，特别是对于多行语句。写错了直接修改脚本就好，而不必重新输入</li><li>如果查询产生大量输出，可通过传呼机而不是翻滚到屏幕的最上方<ul><li><code>mysql &lt; batch-file | more</code></li></ul></li><li>可以把输出捕获到一个文件中<ul><li><code>mysql &lt; batch-file &gt; mysql.out</code></li></ul></li><li>可将脚本文件分发给其他人</li><li>批处理模式下的MySQL输出更简洁<ul><li>可使用<code>mysql -t</code>获得交互式数据格式</li><li>使用<code>mysql -v</code>将执行语句回显</li></ul></li><li>在mysql命令行中载入脚本<ul><li><code>mysql&gt; source filename;</code></li><li>或’mysql&gt; . filename;</li></ul></li></ul><p><br><br><br></p><h2 id="常见查询"><a href="#常见查询" class="headerlink" title="常见查询"></a>常见查询</h2><p>Examples of Common Queries</p><p><br></p><ul><li>在命令行使用mysql并选择数据库</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql db_name -u user -p</div></pre></td></tr></table></figure><ul><li>创建和填充表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shop (</div><div class="line">    article <span class="built_in">INT</span>(<span class="number">4</span>) <span class="keyword">UNSIGNED</span> ZEROFILL <span class="keyword">DEFAULT</span> <span class="string">'0000'</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    dealer  <span class="built_in">CHAR</span>(<span class="number">20</span>)                 <span class="keyword">DEFAULT</span> <span class="string">''</span>     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    price   <span class="keyword">DOUBLE</span>(<span class="number">16</span>,<span class="number">2</span>)             <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    PRIMARY <span class="keyword">KEY</span>(article, dealer));</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shop <span class="keyword">VALUES</span></div><div class="line">    (<span class="number">1</span>,<span class="string">'A'</span>,<span class="number">3.45</span>),(<span class="number">1</span>,<span class="string">'B'</span>,<span class="number">3.99</span>),(<span class="number">2</span>,<span class="string">'A'</span>,<span class="number">10.99</span>),(<span class="number">3</span>,<span class="string">'B'</span>,<span class="number">1.45</span>),</div><div class="line">    (<span class="number">3</span>,<span class="string">'C'</span>,<span class="number">1.69</span>),(<span class="number">3</span>,<span class="string">'D'</span>,<span class="number">1.25</span>),(<span class="number">4</span>,<span class="string">'D'</span>,<span class="number">19.95</span>);</div></pre></td></tr></table></figure><ul><li>查看表内容</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> shop;</div></pre></td></tr></table></figure><ul><li>列的最大值(maximum)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(article) <span class="keyword">AS</span> article <span class="keyword">FROM</span> shop;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> article, <span class="keyword">MAX</span>(price) <span class="keyword">AS</span> price</div><div class="line"><span class="keyword">FROM</span>   shop</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> article;</div></pre></td></tr></table></figure><ul><li>使用用户定义的变量(user-defined variables)</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT @min_price:=MIN(price),@max_price:=MAX(price) FROM shop;</div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM shop WHERE price=@min_price OR price=@max_price;</div></pre></td></tr></table></figure><ul><li>使用外键(Foreign Keys)</li></ul><p>在MySQL中，InnoDB表支持检查外键约束。<br>外键约束不仅仅需要连接两个表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">SMALLINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">    <span class="keyword">name</span> <span class="built_in">CHAR</span>(<span class="number">60</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</div><div class="line">);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shirt (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">SMALLINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">    <span class="keyword">style</span> ENUM(<span class="string">'t-shirt'</span>, <span class="string">'polo'</span>, <span class="string">'dress'</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    color ENUM(<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'orange'</span>, <span class="string">'white'</span>, <span class="string">'black'</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    owner <span class="built_in">SMALLINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">REFERENCES</span> person(<span class="keyword">id</span>),</div><div class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</div><div class="line">);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person <span class="keyword">VALUES</span> (<span class="literal">NULL</span>, <span class="string">'Antonio Paz'</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> @<span class="keyword">last</span> := <span class="keyword">LAST_INSERT_ID</span>();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shirt <span class="keyword">VALUES</span></div><div class="line">(<span class="literal">NULL</span>, <span class="string">'polo'</span>, <span class="string">'blue'</span>, @<span class="keyword">last</span>),</div><div class="line">(<span class="literal">NULL</span>, <span class="string">'dress'</span>, <span class="string">'white'</span>, @<span class="keyword">last</span>),</div><div class="line">(<span class="literal">NULL</span>, <span class="string">'t-shirt'</span>, <span class="string">'blue'</span>, @<span class="keyword">last</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person <span class="keyword">VALUES</span> (<span class="literal">NULL</span>, <span class="string">'Lilliana Angelovska'</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> @<span class="keyword">last</span> := <span class="keyword">LAST_INSERT_ID</span>();</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> shirt <span class="keyword">VALUES</span></div><div class="line">(<span class="literal">NULL</span>, <span class="string">'dress'</span>, <span class="string">'orange'</span>, @<span class="keyword">last</span>),</div><div class="line">(<span class="literal">NULL</span>, <span class="string">'polo'</span>, <span class="string">'red'</span>, @<span class="keyword">last</span>),</div><div class="line">(<span class="literal">NULL</span>, <span class="string">'dress'</span>, <span class="string">'blue'</span>, @<span class="keyword">last</span>),</div><div class="line">(<span class="literal">NULL</span>, <span class="string">'t-shirt'</span>, <span class="string">'white'</span>, @<span class="keyword">last</span>);</div></pre></td></tr></table></figure><ul><li>在两个键上查找(Searching on Two Keys)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> field1_index, field2_index <span class="keyword">FROM</span> test_table</div><div class="line"><span class="keyword">WHERE</span> field1_index = <span class="string">'1'</span> <span class="keyword">OR</span>  field2_index = <span class="string">'1'</span></div></pre></td></tr></table></figure><ul><li>使用自动增量</li></ul><p><code>AUTO_INCREMENT</code>属性能够为新行生成一个唯一的标识符。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> animals (</div><div class="line">     <span class="keyword">id</span> MEDIUMINT <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">     <span class="keyword">name</span> <span class="built_in">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">     PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</div><div class="line">);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> animals (<span class="keyword">name</span>) <span class="keyword">VALUES</span></div><div class="line">    (<span class="string">'dog'</span>),(<span class="string">'cat'</span>),(<span class="string">'penguin'</span>),</div><div class="line">    (<span class="string">'lax'</span>),(<span class="string">'whale'</span>),(<span class="string">'ostrich'</span>);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#设置指定增量开始值</div><div class="line">mysql&gt; ALTER TABLE tbl AUTO_INCREMENT = 100;</div></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br></p><h1 id="MySQL-Programs"><a href="#MySQL-Programs" class="headerlink" title="MySQL Programs"></a>MySQL Programs</h1><p><br></p><h2 id="MySQL程序概述"><a href="#MySQL程序概述" class="headerlink" title="MySQL程序概述"></a>MySQL程序概述</h2><p>Overview of MySQL Programs</p><p><br></p><p><strong>MySQL安装中有多个不同的程序：</strong></p><ul><li><strong>mysqld</strong><ul><li>SQL daemon, MySQL Server, <strong>mysqld</strong>是执行大部分工作的主要程序</li></ul></li><li><strong>mysqld_safe</strong><ul><li>服务器启动脚本</li><li>mysqld_safe尝试去启动mysqld</li></ul></li><li><strong>mysql.server</strong><ul><li>服务器启动脚本</li><li>此脚本用于System V系统，包含启动特定运行级别的系统服务脚本</li><li>它调用mysqld_safe来启动MySQL Server</li></ul></li><li><strong>mysql_multi</strong><ul><li>可启动和关闭安装在系统上的多个服务器的启动脚本</li></ul></li><li><strong>comp_err</strong><ul><li>在MySQL build/installation过程中使用</li><li>从错误源文件中编译错误消息文件</li></ul></li><li><strong>mysql_install_db</strong><ul><li>初始化MySQL(数据目录，授权表，并设置InnoDB系统表空间)</li><li>通常用于首次安装MySQL时</li></ul></li><li><strong>mysql_plugin</strong><ul><li>配置MySQL Server插件</li></ul></li><li><strong>mysql_secure_installation</strong><ul><li>能够提高MySQL安装的安全性</li></ul></li><li><strong>mysql_ssl_rsa_setup</strong><ul><li>如果这些文佳丢失，改程序会创建支持安全连接所需的SSL证书和密钥文件以及RSA密钥对文件</li></ul></li><li><strong>mysql_tzinfo_to_sql</strong><ul><li>从mysql数据库中加载时区表</li></ul></li><li><strong>mysql_upgrade</strong><ul><li>在MySQL升级操作后使用</li><li>它检查表的不兼容性并在必要时修复它们，并用更新版的MySQL的任何更改来更新授权表</li></ul></li><li><strong>mysql</strong><ul><li>交互式输入SQL语句的命令行工具</li><li>或执行一个批处理模式的文件</li></ul></li><li><strong>mysqladmin</strong><ul><li>执行管理操作的客户端</li><li>如创建或删除数据库，重新加载授权表，刷新表的磁盘…</li><li>也可用获取服务器版本、状态、进程信息</li></ul></li><li><strong>mysqlcheck</strong><ul><li>表格客户端</li><li>用于检查、修复、分析和优化表格</li></ul></li><li><strong>mysqldump</strong><ul><li>将MySQL数据库转储为SQL、文本或XML文件的客户端</li></ul></li><li><strong>mysqlimport</strong><ul><li>使用<code>LOAD DATA INFILE</code>将文本文件导入各自表格的客户端</li></ul></li><li><strong>mysqlpump</strong><ul><li>将MySQL数据库转转储为SQL文件的客户端</li></ul></li><li><strong>mysqlsh</strong><ul><li>用于MySQL Server的高级命令行客户端和代码编辑器</li><li>除了SQL外，MySQL Shell还为JS和Python提供了脚本功能</li></ul></li><li><strong>mysqlshow</strong><ul><li>显示有关数据库、表、列和索引的信息的客户端</li></ul></li><li><strong>mysqlslap</strong><ul><li>用于模拟MySQL Server的客户端负载并报告每个阶段的时间</li></ul></li></ul><p><br></p><p><strong>MySQL管理和实用程序：</strong></p><ul><li><strong>innochecksum</strong><ul><li>InnoDB脱机文件校验和程序</li></ul></li><li><strong>myisam_ftdump</strong><ul><li>在MyISAM表中显示有关全文索信息</li></ul></li><li><strong>myisamchk</strong><ul><li>描述，检查，优化和修复MyISAM表</li></ul></li><li><strong>myisamlog</strong><ul><li>处理MyISAM日志文件</li></ul></li><li><strong>myisampack</strong><ul><li>压缩MyISAM表以生成更小的只读表</li></ul></li><li><strong>mysql_config_editor</strong><ul><li>能够将认证凭证存储在名为安全的加密登录路径文件中</li></ul></li><li><strong>mysqlbinlog</strong><ul><li>从二进制日志中读取语句</li></ul></li><li><strong>mysqldumpslow</strong><ul><li>读取和总结慢查询日志内容</li></ul></li></ul><p><br></p><p><strong>MySQL程序开发实用程序：</strong></p><ul><li><strong>mysql_config</strong><ul><li>一个shell脚本，用于在编译MySQL程序是生产所需的选项值</li></ul></li><li><strong>my_print_defaults：</strong><ul><li>显示选项文件的选项组中存在哪些选项</li></ul></li><li><strong>resolve_stack_dump</strong><ul><li>将数值堆栈跟踪转储解析为符号</li></ul></li></ul><p><br></p><p><strong>杂项(Miscellaneous)工具：</strong></p><ul><li><strong>lz4_decompress</strong><ul><li>解压缩使用LZ4压缩格式的mysqldump输出</li></ul></li><li><strong>perror</strong><ul><li>显示系统或MySQL错误代码含义</li></ul></li><li><strong>replace</strong><ul><li>再输入文本中执行字符串替换</li></ul></li><li><strong>resolveip</strong><ul><li>将主机名解析为IP地址，反之亦然</li></ul></li><li><strong>zlib_decompress</strong><ul><li>解压缩使用ZLIB压缩格式的mysqldump输出</li></ul></li></ul><p><br></p><p>Oracle公司还提供了MySQL Workbench GUI工具，用于管理、创建、知悉和评估查询，以及从其它关系数据库管理系统迁移到MySQL系统。</p><p>MySQL Client和Server间的通信使用如下环境变量：</p><table><thead><tr><th>Environment Variable</th><th>Meaning</th></tr></thead><tbody><tr><td>MYSQL_UNIX_PORT</td><td>The default Unix socket file; used for connections to localhost</td></tr><tr><td>MYSQL_TCP_PORT</td><td>The default port number; used for TCP/IP connections</td></tr><tr><td>MYSQL_PWD</td><td>The default password, insecure</td></tr><tr><td>MYSQL_DEBUG</td><td>Debug trace options when debugging</td></tr><tr><td>TMPDIR</td><td>The directory where temporary tables and files are created</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL5.7参考文档： &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7.x86_64&lt;/li&gt;
&lt;li&gt;MySQL5.7&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="https://zhang21.github.io/categories/Database/"/>
    
    
      <category term="MySQL" scheme="https://zhang21.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>2018小计划</title>
    <link href="https://zhang21.github.io/2018/01/15/2018%E5%B0%8F%E8%AE%A1%E5%88%92/"/>
    <id>https://zhang21.github.io/2018/01/15/2018小计划/</id>
    <published>2018-01-15T03:08:11.000Z</published>
    <updated>2018-04-05T15:16:47.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><ul><li style="list-style: none"><input type="checkbox" checked> 《MongoDB官方文档》： <a href="https://docs.mongodb.com" target="_blank" rel="noopener">https://docs.mongodb.com</a></li><li style="list-style: none"><input type="checkbox"> 《SatlStack官方文档》： <a href="https://docs.saltstack.com" target="_blank" rel="noopener">https://docs.saltstack.com</a></li><li style="list-style: none"><input type="checkbox"> 《MySQL官方文档》： <a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">https://dev.mysql.com/doc/</a></li><li style="list-style: none"><input type="checkbox"> 《TCP/IP协议族》： <a href="https://book.douban.com/subject/5386194/" target="_blank" rel="noopener">https://book.douban.com/subject/5386194/</a></li><li style="list-style: none"><input type="checkbox"> 《Linux性能调优指南》： <a href="https://lihz1990.gitbooks.io/transoflptg/content/" target="_blank" rel="noopener">https://lihz1990.gitbooks.io/transoflptg/content/</a></li><li style="list-style: none"><input type="checkbox"> 《Docker官方文档》： <a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></li><li style="list-style: none"><input type="checkbox"> 《Consul官方文档》： <a href="https://www.consul.io/docs/index.html" target="_blank" rel="noopener">https://www.consul.io/docs/index.html</a></li><li style="list-style: none"><input type="checkbox"> 《Python工作自动化》： <a href="https://book.douban.com/subject/26836700/" target="_blank" rel="noopener">https://book.douban.com/subject/26836700/</a></li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h1><ul><li style="list-style: none"><input type="checkbox"> 《资本论》： <a href="https://book.douban.com/subject/1150503/" target="_blank" rel="noopener">https://book.douban.com/subject/1150503/</a></li><li style="list-style: none"><input type="checkbox"> 《灵飞经小楷》： <a href="https://book.douban.com/subject/1115916/" target="_blank" rel="noopener">https://book.douban.com/subject/1115916/</a></li><li style="list-style: none"><input type="checkbox"> 《经济学原理》： <a href="https://book.douban.com/subject/26435630/" target="_blank" rel="noopener">https://book.douban.com/subject/26435630/</a></li></ul><p><br></p><hr><p><br></p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><ul><li style="list-style: none"><input type="checkbox"> 沉得住气</li><li style="list-style: none"><input type="checkbox"> 培养一门兴趣爱好</li><li style="list-style: none"><input type="checkbox"> 找寻另一半</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h1&gt;&lt;ul&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot; checked&gt; 《MongoDB官方文档》： &lt;a href=&quot;https://docs.mongodb.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.mongodb.com&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《SatlStack官方文档》： &lt;a href=&quot;https://docs.saltstack.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.saltstack.com&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《MySQL官方文档》： &lt;a href=&quot;https://dev.mysql.com/doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《TCP/IP协议族》： &lt;a href=&quot;https://book.douban.com/subject/5386194/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://book.douban.com/subject/5386194/&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《Linux性能调优指南》： &lt;a href=&quot;https://lihz1990.gitbooks.io/transoflptg/content/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://lihz1990.gitbooks.io/transoflptg/content/&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《Docker官方文档》： &lt;a href=&quot;https://docs.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《Consul官方文档》： &lt;a href=&quot;https://www.consul.io/docs/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.consul.io/docs/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《Python工作自动化》： &lt;a href=&quot;https://book.douban.com/subject/26836700/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://book.douban.com/subject/26836700/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Zhang" scheme="https://zhang21.github.io/categories/Zhang/"/>
    
    
      <category term="2018" scheme="https://zhang21.github.io/tags/2018/"/>
    
  </entry>
  
  <entry>
    <title>海明威的《老人与海》</title>
    <link href="https://zhang21.github.io/2018/01/13/%E6%B5%B7%E6%98%8E%E5%A8%81%E7%9A%84%E3%80%8A%E8%80%81%E4%BA%BA%E4%B8%8E%E6%B5%B7%E3%80%8B/"/>
    <id>https://zhang21.github.io/2018/01/13/海明威的《老人与海》/</id>
    <published>2018-01-13T01:49:53.000Z</published>
    <updated>2018-01-15T02:06:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>我不相信人会有所谓的“命运”，但是我相信对于任何人来说，“限度”总是存在的。再聪明再强悍的人，能够做到的事情也总是有限度的。老人桑地亚哥不是无能之辈，然而，尽管他是最好的渔夫，也不能让那些鱼来上他的钩。他遇到他的限度了，就象最好的农民遇上了大旱，最好的猎手久久碰不到猎物一般。每一个人都会遇到这样的限度，仿佛是命运在向你发出停止前行的命令。</p><a id="more"></a><p><br></p><p>可是老人没有沮丧，没有倦怠，他继续出海，向限度挑战。他终于钓到了一条鱼。如同那老人是人中的英雄一样，这条鱼也是鱼中的英雄。鱼把他拖到海上去，把他拖到远离陆地的地方，在海上与老人决战。在这场鱼与人的恶战中，鱼也有获胜的机会。鱼在水下坚持了几天几夜，使老人不能休息，穷于应付，它用酷刑来折磨老人，把他弄得血肉模糊。这时，只要老人割断钓绳，就能使自己摆脱困境，得到解放，但这也就意味着宣告自己是失败者。老人没有作这样得选择，甚至没有产生过放弃战斗的念头。他把那条鲨鱼当作一个可与之交战的敌手，一次又一次地做着限度之外的战斗，他战胜了。</p><p><br></p><p>老人载着他的鱼回家去，鲨鱼在路上抢劫他的猎物。他杀死了一条来袭的鲨鱼，但是折断了他的鱼叉。于是他用刀子绑在棍子上做武器。到刀子又折断的时候，似乎这场战斗已经结束了。他失去了继续战斗的武器，他又遇到了他的限度。这是，他又进行了限度之外的战斗：当夜幕降临，更多的鲨鱼包围了他的小船，他用木棍、用桨、甚至用舵和鲨鱼搏斗，直到他要保卫的东西失去了保卫的价值，直到这场搏斗已经变得毫无意义的时候他才住手。</p><p><br></p><p>老人回到岸边，只带回了一条白骨，只带回了残破不堪的小船和耗尽了精力的躯体。人们怎样看待这场斗争呢？</p><p>有人说老人桑地亚哥是一个失败了得英雄。尽管他是条硬汉，但还是失败了。</p><p>什么叫失败？也许可以说，人去做一件事情，没有达到预期得目的，这就是失败。</p><p><br></p><p>但是，那些与命运斗争的人，那些做接近自己限度的斗争的人，却天生地接近这种失败。老人到海上去，不能期望天天有鱼来咬他的钩，于是他常常失败。一个常常在进行着接近自己限度的斗争的人总是会常常失败的，一个想探索自然奥秘的人也常常会失败，一个想改革社会的人更是会常常失败。只有那些安于自己限度之内的生活的人才总是“胜利”，这种“胜利者”之所以常胜不败，只是因为他的对手是早已降伏的，或者说，他根本没有投入斗争。</p><p><br></p><p>在人生的道路上，“失败“这个词还有另外的含义，即是指人失去了继续斗争的信心，放下了手中的武器。人类向限度屈服，这才是真正的失败。而没有放下手中武器，还在继续斗争，继续向限度挑战的人并没有失败。如此看来，老人没有失败，老人从未放下武器，只不过是丧失了武器。老人没有失去信心，因此不应当说他是“失败了的英雄”。</p><p><br></p><p>那么，什么也没有得到的老人竟是胜利的么？我确是这样看的。我认为，胜利就是战斗到最后的时刻。老人总怀着无比的勇气走向莫测的大海，他的信心是不可战胜的。</p><p>他和其他许多人一样，是强悍的人类的一员。我喜欢这样的人，也喜欢这样的人性。我发现，人们常常把这样的事情当作人性最可贵的表露：七尺男子汉坐在厨房里和三姑六婆磨嘴皮子，或者衣装笔挺的男女们坐在海滨，谈论着高尚的、别人不能理解的感情。我不喜欢人们像这样沉溺在人性软弱的部分之中，更不喜欢人们总是这样描写人性。</p><p><br></p><p>正像老人每天走向大海一样，很多人每天也走向与他们的限度斗争的战场，仿佛他们要与命运一比高低似的。他们是人中的强者。</p><p>人类本身也有自己的限度，但是当人们一再把手伸到限度之外，这个限度就一天一天地扩大了。人类在与限度的斗争中成长。他们把飞船送上太空，他们也用简陋的渔具在加勒比海捕捉巨大的马林鱼。这些事情是同样伟大的。做这样不可思议的事情的人都是英雄。而那些永远不肯或不能越出自己限度的人是平庸的人。</p><p><br></p><p>在人类前进的道路上，强者与弱者的命运是不同的。弱者不羡慕强者的命运，强者也讨厌弱者的命运。强者带有人性中强悍的一面，弱者带有人性中软弱的一面。强者为弱者开辟道路，但是强者往往为弱者所奴役，就像老人是为大腹便便的游客打鱼一样。</p><p><br></p><p>《老人与海》讲了一个老渔夫的故事，但是在这个故事里却揭示了人类共同的命运。我佩服老人的勇气，佩服他不屈不饶的斗争精神，也佩服海明威。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我不相信人会有所谓的“命运”，但是我相信对于任何人来说，“限度”总是存在的。再聪明再强悍的人，能够做到的事情也总是有限度的。老人桑地亚哥不是无能之辈，然而，尽管他是最好的渔夫，也不能让那些鱼来上他的钩。他遇到他的限度了，就象最好的农民遇上了大旱，最好的猎手久久碰不到猎物一般。每一个人都会遇到这样的限度，仿佛是命运在向你发出停止前行的命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="王小波" scheme="https://zhang21.github.io/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>sysctl,ulimit以及/proc</title>
    <link href="https://zhang21.github.io/2018/01/09/sysctl%E3%80%81ulimit%E5%92%8Cproc/"/>
    <id>https://zhang21.github.io/2018/01/09/sysctl、ulimit和proc/</id>
    <published>2018-01-09T09:22:48.000Z</published>
    <updated>2018-01-10T02:44:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="http://man.linuxde.net/sysctl" target="_blank" rel="noopener">sysctl命令</a></li><li><a href="http://man.linuxde.net/ulimit" target="_blank" rel="noopener">ulimit命令</a></li><li><a href="http://www.jianshu.com/p/20a2dd80cbad" target="_blank" rel="noopener">ulimit、limits.conf、sysctl和proc文件系统</a></li><li><a href="http://www.jianshu.com/p/9a8e383b5b49" target="_blank" rel="noopener">sysctl.conf学习和调优</a></li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h1><p><code>sysctl</code> 命令被用于在内核运行时动态地修改内核的运行参数，可用的内核参数在目录 <code>/proc/sys</code> 中。它包含一些<code>Tcp/Ip</code>堆栈和虚拟内存系统的高级选项，可以通过修改某些值来提高系统性能。</p><p><code>sysctl</code>可以读取和设置超过五百个系统变量。<br><code>sysctl</code>变量的设置通常是<strong>字符串、数字或布尔型</strong>（布尔型用1表示yes，0表示no）。</p><p><code>sysctl</code> - configure kernel parameters at runtime.</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#sysctl [options] [variable[=value]] [...]</div><div class="line"></div><div class="line">sysctl -w net.ipv4.tcp_syncookies=1</div></pre></td></tr></table></figure><p><br></p><p>可以通过<code>sysctl</code>命令修改系统变量，也可以通过编辑<code>sysctl.conf</code>配置文件来修改系统变量。</p><p><code>sysctl.conf</code> - sysctl preload/configuration file.</p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysct.conf</div><div class="line"></div><div class="line"></div><div class="line"># Controls source route verification</div><div class="line"># Default should work for all interfaces net.ipv4.conf.default.rp_filter = 1</div><div class="line"># net.ipv4.conf.all.rp_filter = 1</div><div class="line"># net.ipv4.conf.lo.rp_filter = 1</div><div class="line"># net.ipv4.conf.eth0.rp_filter = 1</div><div class="line"></div><div class="line"></div><div class="line"># Disables IP source routing</div><div class="line"># Default should work for all interfaces net.ipv4.conf.default.accept_source_route = 0</div><div class="line"># net.ipv4.conf.all.accept_source_route = 0</div><div class="line"># net.ipv4.conf.lo.accept_source_route = 0</div><div class="line"># net.ipv4.conf.eth0.accept_source_route = 0</div><div class="line"></div><div class="line"></div><div class="line"># Controls the System Request debugging functionality of the kernel</div><div class="line">kernel.sysrq = 0</div><div class="line"></div><div class="line"></div><div class="line"># Controls whether core dumps will append the PID to the core filename</div><div class="line"># Useful for debugging multi-threaded applications</div><div class="line">kernel.core_uses_pid = 1</div><div class="line"></div><div class="line"></div><div class="line"># Increase maximum amount of memory allocated to shm</div><div class="line"># Only uncomment if needed</div><div class="line"># kernel.shmmax = 67108864</div><div class="line"></div><div class="line"></div><div class="line"># Disable ICMP Redirect Acceptance</div><div class="line"># Default should work for all interfaces</div><div class="line">net.ipv4.conf.default.accept_redirects = 0</div><div class="line"># net.ipv4.conf.all.accept_redirects = 0</div><div class="line"># net.ipv4.conf.lo.accept_redirects = 0</div><div class="line"># net.ipv4.conf.eth0.accept_redirects = 0</div><div class="line"></div><div class="line"></div><div class="line"># enable Log Spoofed Packets, Source Routed Packets, Redirect Packets</div><div class="line"># Default should work for all interfaces</div><div class="line">net.ipv4.conf.default.log_martians = 1</div><div class="line">#net.ipv4.conf.all.log_martians = 1</div><div class="line"># net.ipv4.conf.lo.log_martians = 1</div><div class="line"># net.ipv4.conf.eth0.log_martians = 1</div><div class="line"></div><div class="line"></div><div class="line"># Decrease the time default value for tcp_fin_timeout connection</div><div class="line">net.ipv4.tcp_fin_timeout = 25</div><div class="line"></div><div class="line"></div><div class="line"># Decrease the time default value for tcp_keepalive_time connection</div><div class="line">net.ipv4.tcp_keepalive_time = 1200</div><div class="line"></div><div class="line"></div><div class="line"># Turn on the tcp_window_scaling</div><div class="line">net.ipv4.tcp_window_scaling = 1</div><div class="line"></div><div class="line"></div><div class="line"># Turn on the tcp_sack</div><div class="line">net.ipv4.tcp_sack = 1</div><div class="line"></div><div class="line"></div><div class="line"># tcp_fack should be on because of sack</div><div class="line">net.ipv4.tcp_fack = 1</div><div class="line"></div><div class="line"></div><div class="line"># Turn on the tcp_timestamps</div><div class="line">net.ipv4.tcp_timestamps = 1</div><div class="line"></div><div class="line"></div><div class="line"># Enable TCP SYN Cookie Protection</div><div class="line">net.ipv4.tcp_syncookies = 1</div><div class="line"></div><div class="line"></div><div class="line"># Enable ignoring broadcasts request</div><div class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</div><div class="line"></div><div class="line"></div><div class="line"># Disable ping requests</div><div class="line">net.ipv4.icmp_echo_ignore_all = 1</div><div class="line"></div><div class="line"></div><div class="line"># Enable bad error message Protection</div><div class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</div><div class="line"></div><div class="line"></div><div class="line"># make more local ports available</div><div class="line"># net.ipv4.ip_local_port_range = 1024 65000</div><div class="line"></div><div class="line"></div><div class="line"># set TCP Re-Ordering value in kernel to 5</div><div class="line">net.ipv4.tcp_reordering = 5</div><div class="line"></div><div class="line"></div><div class="line"># Lower syn retry rates</div><div class="line">net.ipv4.tcp_synack_retries = 2</div><div class="line">net.ipv4.tcp_syn_retries = 3</div><div class="line"></div><div class="line"></div><div class="line"># Set Max SYN Backlog to 2048</div><div class="line">net.ipv4.tcp_max_syn_backlog = 2048</div><div class="line"></div><div class="line"></div><div class="line"># Various Settings</div><div class="line">net.core.netdev_max_backlog = 1024</div><div class="line"></div><div class="line"></div><div class="line"># Increase the maximum number of skb-heads to be cached</div><div class="line">net.core.hot_list_length = 256</div><div class="line"></div><div class="line"></div><div class="line"># Increase the tcp-time-wait buckets pool size</div><div class="line">net.ipv4.tcp_max_tw_buckets = 360000</div><div class="line"></div><div class="line"></div><div class="line"># This will increase the amount of memory available for socket input/output queues</div><div class="line">net.core.rmem_default = 65535</div><div class="line">net.core.rmem_max = 8388608</div><div class="line">net.ipv4.tcp_rmem = 4096 87380 8388608 net.core.wmem_default = 65535</div><div class="line">net.core.wmem_max = 8388608</div><div class="line">net.ipv4.tcp_wmem = 4096 65535 8388608</div><div class="line">net.ipv4.tcp_mem = 8388608 8388608 8388608</div><div class="line">net.core.optmem_max = 40960</div></pre></td></tr></table></figure><p>重新加载内核参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-p, read values from file</span></div><div class="line">sysctl -p</div><div class="line"></div><div class="line"><span class="comment">#-a, display all variables</span></div><div class="line">sysctl -a</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h1><p>大多Unix-Like系统，都提供了限制每个进程和每个基本用户使用线程，文件和网络连接等系统资源的一些方法。</p><p>假设有这样一种情况，当一台Linux主机上同时登陆了10人，在资源无限制的情况下，这10个用户同时打开了500个文件。假设每个文件的大小有10M，这是系统的内存资源就会收到巨大挑战。<br>但是任何一台主机的资源都不可能是无限的。所以，资源的合理配置和分配，不仅仅是保证系统可用性的必要条件，也与系统上软件运行的性能有着密不可分的联系。</p><p><code>ulimit</code>是指每个user使用各种资源的限制值。<code>ulimit</code> 命令用来限制系统用户对shell资源的访问，它是一种简单并且有效的实现资源限制的方式。</p><ul><li><code>ulimit</code>的设置值是 per-process的，也就是说，每个进程都有自己的limits值；</li><li>使用<code>ulimit</code>进行修改，是立即生效的；</li><li><code>ulimit</code>只影响shell进程及其子进程，用户登出后失效；</li><li>修改<code>ulimit</code>设置之后，要重启程序修改值才会有效。可通过<code>/proc</code>文件系统查看运行进程当前的限制值;</li><li>使用<code>ulimit</code>对系统限制的改变在系统重启后都会恢复到默认值;</li><li>可以在<code>profile</code>中加入<code>ulimit</code>的设置，便能做到永久生效。</li></ul><p><br></p><p><strong>ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：</strong></p><ul><li>所创建的内核文件的大小；</li><li>进程数据块的大小；</li><li>Shell进程创建文件的大小；</li><li>内存锁住的大小；</li><li>常驻内存集的大小；</li><li>打开文件描述符的数量；</li><li>分配堆栈的最大大小；</li><li>CPU时间；</li><li>单个用户的最大线程数；</li><li>Shell进程所能使用的最大虚拟内存；</li><li>它支持硬资源(hard)和软资源(soft)的限制。</li></ul><p><br></p><p><strong>sort和hard</strong></p><ul><li>hard：是指用户在任何时候都可以活动的进程的最大数量，这是上限。没有任何non-root进程能够增加hard ulimit；</li><li>soft：是对会话或进程实际执行的限制，但任何进程都可以将其增加到hard ulimit的最大值。</li></ul><p><br></p><h2 id="设置ulimit"><a href="#设置ulimit" class="headerlink" title="设置ulimit"></a>设置ulimit</h2><p>可以在以下位置进行ulimit的设置：</p><ul><li><code>/etc/profile</code>，所有用户有效，永久生效；</li><li><code>~/.bash_profile</code>,当前用户有效，永久生效；</li><li>直接在控制台修改，当前用户有效，临时生效；</li></ul><p><br></p><p>永久生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div><div class="line"></div><div class="line">vim ~/.bash_profile</div></pre></td></tr></table></figure><p>临时生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">ulimit</span> -a</div><div class="line"></div><div class="line"></div><div class="line">core file size          (blocks, -c) 0</div><div class="line">data seg size           (kbytes, -d) unlimited</div><div class="line">scheduling priority             (-e) 0</div><div class="line">file size               (blocks, -f) unlimited</div><div class="line">pending signals                 (-i) 7170</div><div class="line">max locked memory       (kbytes, -l) 64</div><div class="line">max memory size         (kbytes, -m) unlimited</div><div class="line">open files                      (-n) 1024</div><div class="line">pipe size            (512 bytes, -p) 8</div><div class="line">POSIX message queues     (bytes, -q) 819200</div><div class="line">real-time priority              (-r) 0</div><div class="line">stack size              (kbytes, -s) 8192</div><div class="line">cpu time               (seconds, -t) unlimited</div><div class="line">max user processes              (-u) 7170</div><div class="line">virtual memory          (kbytes, -v) unlimited</div><div class="line">file locks                      (-x) unlimited</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#修改限定值</span></div><div class="line"><span class="built_in">ulimit</span> -n 201400</div><div class="line"><span class="built_in">ulimit</span> -t ulimited</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="limits-conf"><a href="#limits-conf" class="headerlink" title="limits.conf"></a>limits.conf</h1><p><code>limits.conf</code> - configuration file for the pam_limits module</p><p><code>limits.conf</code>是<code>pam_limits.so</code>的配置文件，Linux PAM(Pluggable Authentication Modules，插入式认证模块)。突破系统默认限制，对系统资源有一定保护作用。</p><p><strong>pam_limits模块</strong>对用户的会话进行资源限制，然后<code>/etc/pam.d/</code>下的应用程序调用<code>pam_***.so</code>模块。</p><p><br></p><p><strong><code>limits.conf</code>是针对用户，而<code>sysctl.conf</code>是针对整个系统参数配置。</strong></p><ul><li>一个shell的初始limits就是由pam_limits设定的，用户登录后，pam_limits会给用户的shell设定在limits.conf定义的值；</li><li>pam_limits的设定值也是per-process；</li><li>pam_limits的设置是 永久生效的。</li></ul><p><br></p><p>配置limits.conf：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/security/limits.conf</div></pre></td></tr></table></figure><p><br></p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#&lt;domain&gt;      &lt;type&gt;  &lt;item&gt;         &lt;value&gt;</div><div class="line"></div><div class="line">#*               soft    core            0</div><div class="line">#*               hard    rss             10000</div><div class="line">#@student        hard    nproc           20</div><div class="line">#@faculty        soft    nproc           20</div><div class="line">#@faculty        hard    nproc           50</div><div class="line">#ftp             hard    nproc           0</div><div class="line">#@student        -       maxlogins       4</div></pre></td></tr></table></figure><p>domain：</p><ul><li>username</li><li>@groupname</li></ul><p>type：</p><ul><li>soft</li><li>hard</li><li>-</li></ul><p>item：</p><ul><li>core，限制内核文件的大小</li><li>date，最大数据大小</li><li>fsize，最大文件大小</li><li>memlock，最大锁定内存地址空间</li><li>nofile，打开文件的最大数目</li><li>rss，最大持久设置大小</li><li>stack，最大栈大小</li><li>cpu，以分钟为单位的最多CPU时间</li><li>nproc，进程的最大数目</li><li>as，地址空间限制</li><li>maxlogins，此用户允许登录的最大数目</li></ul><p>value：</p><ul><li>item值的大小</li></ul><p><br></p><hr><p><br></p><h1 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h1><h2 id="什么是-proc文件系统"><a href="#什么是-proc文件系统" class="headerlink" title="什么是/proc文件系统"></a>什么是/proc文件系统</h2><p>Linux内核提供了一种通过<code>/proc</code>文件系统，在运行时访问内核内部数据结构，改变内核设置的机制。</p><p>proc文件系统是一个伪文件系统，它只存在内存当中，不占用外部空间。它以文件系统的方式为访问系统内核数据的操作提供接口。</p><p>对<code>/proc</code>中内核文件的修改，针对的是<strong>整个系统</strong>的<strong>内核参数</strong>，修改后<strong>立即生效</strong>，但修改是 <strong>临时的</strong>，重启后失效。</p><p><br></p><h2 id="proc与sysctl-conf的对应关系"><a href="#proc与sysctl-conf的对应关系" class="headerlink" title="/proc与sysctl.conf的对应关系"></a>/proc与sysctl.conf的对应关系</h2><p>修改<code>/proc</code>文件系统中的参数是临时的，但修改<code>sysctl.conf</code>的参数确是永久有效的。</p><p>配置文件<code>sysctl.conf</code>变量在<code>/proc/sys</code>下，其对应关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#将文件名的 . 变为 /</div><div class="line"></div><div class="line">#/proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line">#net.ipv4.icmp_echo_ignore_all</div><div class="line"></div><div class="line">echo 0 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line"></div><div class="line">vim /etc/sysctl.conf</div><div class="line">net.ipv4.icmp_echo_ignore_all = 0</div></pre></td></tr></table></figure><p><br></p><h2 id="proc文件系统几个常用的内核文件"><a href="#proc文件系统几个常用的内核文件" class="headerlink" title="/proc文件系统几个常用的内核文件"></a>/proc文件系统几个常用的内核文件</h2><ul><li>/proc/meminfo    #内存信息</li><li>/proc/cpuinfo    #CPU信息</li><li>/proc/sys/fs/file-max    #文件打开数</li><li>/proc/sys/fs/file-nr    #整个系统目前使用的文件句柄数量</li></ul><p><br></p><h2 id="proc文件系统中文件的权限"><a href="#proc文件系统中文件的权限" class="headerlink" title="/proc文件系统中文件的权限"></a>/proc文件系统中文件的权限</h2><p>proc中的每个文件都有一组分配给它的非常特殊的文件许可权，并且每个文件属于特定的用户标识。</p><ul><li>只读：任何用户都不能更改该文件，它用于表示系统信息</li><li>root写</li><li>root读</li></ul><p><br></p><h2 id="对-proc进行读写"><a href="#对-proc进行读写" class="headerlink" title="对/proc进行读写"></a>对/proc进行读写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cat /proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line">#0</div><div class="line"></div><div class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line"></div><div class="line">#当然,也可是用sysctl来配置</div></pre></td></tr></table></figure><p><br></p><h2 id="proc内核文件详解"><a href="#proc内核文件详解" class="headerlink" title="/proc内核文件详解"></a>/proc内核文件详解</h2><ul><li>/proc/buddyinfo 每个内存区中的每个order有多少块可用，和内存碎片问题有关</li><li>/proc/cmdline 启动时传递给kernel的参数信息</li><li>/proc/cpuinfo cpu的信息</li><li>/proc/crypto 内核使用的所有已安装的加密密码及细节</li><li>/proc/devices 已经加载的设备并分类</li><li>/proc/dma 已注册使用的ISA DMA频道列表</li><li>/proc/execdomains Linux内核当前支持的execution domains</li><li>/proc/fb 帧缓冲设备列表，包括数量和控制它的驱动</li><li>/proc/filesystems 内核当前支持的文件系统类型</li><li>/proc/interrupts x86架构中的每个IRQ中断数</li><li>/proc/iomem 每个物理设备当前在系统内存中的映射</li><li>/proc/ioports 一个设备的输入输出所使用的注册端口范围</li><li>/proc/kcore 代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于RAM大小加上4kb</li><li>/proc/kmsg 记录内核生成的信息，可以通过/sbin/klogd或/bin/dmesg来处理</li><li>/proc/loadavg 根据过去一段时间内CPU和IO的状态得出的负载状态，与uptime命令有关</li><li>/proc/locks 内核锁住的文件列表</li><li>/proc/mdstat 多硬盘，RAID配置信息(md=multiple disks)</li><li>/proc/meminfo RAM使用的相关信息</li><li>/proc/misc 其他的主要设备(设备号为10)上注册的驱动</li><li>/proc/modules 所有加载到内核的模块列表</li><li>/proc/mounts 系统中使用的所有挂载</li><li>/proc/mtrr 系统使用的Memory Type Range Registers (MTRRs)</li><li>/proc/partitions 分区中的块分配信息</li><li>/proc/pci 系统中的PCI设备列表</li><li>/proc/slabinfo 系统中所有活动的 slab 缓存信息</li><li>/proc/stat 所有的CPU活动信息</li><li>/proc/sysrq-trigger 使用echo命令来写这个文件的时候，远程root用户可以执行大多数的系统请求关键命令，就好- 像在本地终端执行一样。要写入这个文件，需要把/proc/sys/kernel/sysrq不能设置为0。这个文件对root也是不可- 读的</li><li>/proc/uptime 系统已经运行了多久</li><li>/proc/swaps 交换空间的使用情况</li><li>/proc/version Linux内核版本和gcc版本</li><li>/proc/bus 系统总线(Bus)信息，例如pci/usb等</li><li>/proc/driver 驱动信息</li><li>/proc/fs 文件系统信息</li><li>/proc/ide ide设备信息</li><li>/proc/irq 中断请求设备信息</li><li>/proc/net 网卡设备信息</li><li>/proc/scsi scsi设备信息</li><li>/proc/tty tty设备信息</li><li>/proc/net/dev 显示网络适配器及统计信息</li><li>/proc/vmstat 虚拟内存统计信息</li><li>/proc/vmcore 内核panic时的内存映像</li><li>/proc/diskstats 取得磁盘信息</li><li>/proc/schedstat kernel调度器的统计信息</li><li>/proc/zoneinfo 显示内存空间的统计信息，对分析虚拟内存行为很有用</li></ul><p><br></p><p><strong>以下是/proc目录中进程N的信息：</strong></p><ul><li>/proc/N pid为N的进程信息</li><li>/proc/N/cmdline 进程启动命令</li><li>/proc/N/cwd 链接到进程当前工作目录</li><li>/proc/N/environ 进程环境变量列表</li><li>/proc/N/exe 链接到进程的执行命令文件</li><li>/proc/N/fd 包含进程相关的所有的文件描述符</li><li>/proc/N/maps 与进程相关的内存映射信息</li><li>/proc/N/mem 指代进程持有的内存，不可读</li><li>/proc/N/root 链接到进程的根目录</li><li>/proc/N/stat 进程的状态</li><li>/proc/N/statm 进程使用的内存的状态</li><li>/proc/N/status 进程状态信息，比stat/statm更具可读性</li><li>/proc/self 链接到当前正在运行的进程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://man.linuxde.net/sysctl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sysctl命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://man.linuxde.net/ulimit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ulimit命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/20a2dd80cbad&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ulimit、limits.conf、sysctl和proc文件系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/9a8e383b5b49&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sysctl.conf学习和调优&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="系统优化" scheme="https://zhang21.github.io/tags/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>开源许可协议</title>
    <link href="https://zhang21.github.io/2018/01/09/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
    <id>https://zhang21.github.io/2018/01/09/开源许可协议/</id>
    <published>2018-01-09T03:50:27.000Z</published>
    <updated>2018-01-09T05:55:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你为你的产品签发许可，你就是在出让自己的权利。不过，你仍拥有版权和专利（如果申请了专利）。许可的目的，是向使用你产品的人提供一定的权利。</p><p>不管产品是免费分发，还是出售，指定一份许可协议都非常有用。否则，对于免费，你相当于放弃了自己的所有权利，任何人都没有义务表明你的原始作者身份。对于出售，你将不得不花费比开发更多的精力用来处理授权问题。</p><p>而开源许可协议是这些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的身份，使你至少获得认可。开源许可协议还可以阻止其它人将某个产品据为己有。</p><p><br><br><a id="more"></a></p><p><img src="/images/opensourcelicence.png" alt="开源许可协议区别"></p><p><br></p><p><img src="/images/opensourcelicence.jpg" alt="开源许可协议区别"></p><p><br></p><hr><p><br></p><h1 id="几大开源许可协议"><a href="#几大开源许可协议" class="headerlink" title="几大开源许可协议"></a>几大开源许可协议</h1><p><br><br><br></p><h2 id="GNU-Project"><a href="#GNU-Project" class="headerlink" title="GNU Project"></a>GNU Project</h2><ul><li>GNU是“GNU’s Not Unix”的递归缩写，发音为 /‘gnu:’/；</li><li>GNU Project，是一个由自由软件集体协作项目，它的目标是创建一套完全自由的操作系统，称为GNU；</li><li>GNU是一个自由操作系统，其内容软件完全以 GPL 方式发布，它的设计类似于Unix，但它不包含具有著作权的Unix代码。</li></ul><p><br></p><h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GNU(General Public Licence)，GNU通用许可协议(简称GPL)是广泛使用的免费软件许可证，也称为 copyleft，与copyright相对应。<br>GPL保证了所有开发者的权利，同时为使用者提供了足够的复制、分发、修改的权利。</p><p>需要注意的是，分发的时候，需要明确提供源代码和二进制文件。</p><ul><li><strong>可自由复制：</strong> 你可以将软件复制到你的电脑或任何地方，复制份数没有限制；</li><li><strong>可自由分发：</strong> 可下载后拷贝分发；</li><li><strong>可以用来盈利：</strong> 你可以在分发软件的时候收费，但必须在收费前向你的客户提供该软件的 GNU GPL许可协议，以便让他们知道，他们可以从别的渠道免费得到这份软件以及你收费的理由；</li><li><strong>可自由修改：</strong> 你过你想添加或删除某个功能，没问题。如果你想在别的项目中使用部分代码，也没问题，唯一要求是使用了这段代码的项目也必须使用 GPL协议。</li></ul><p><br></p><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>GNU还有另外一种协议，叫做LGPL（Lesser General Public License），它对产品所保留的权利比GPL少。<br>总的来说，LGPL适合那些用于非GPL或非开源产品的开源类库或框架。因为GPL要求，使用了GPL代码的产品也必须使用GPL协议，开发者不允许将GPL代码用于商业产品。LGPL绕过了这一限制。</p><p>GPL和LGPL都属于GNU计划里面的许可证。</p><p><br></p><hr><p><br></p><h2 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h2><p>伯克利软件套件（Berkeley Software Distribution，缩写BSD），也被称为伯克利Unix，是一个操作系统的名称，衍生自Unix，也被用来代表一整套软件发行版。</p><p>BSD许可证（Berkeley Software Distribution License），是自由软件中使用广泛的许可证。BSD软件就是遵照这个许可证来发布，该许可证也因此而得名。</p><p>BSD在软件分发方面的限制比别的开源协议要少，且和GPL兼容，并为开源组织所认可。</p><p><br></p><hr><p><br></p><h2 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h2><p>MIT（Massachusetts Institute of Technology），麻省理工学院。<br>MIT许可协议（The MIT License）是许多软件授权条款中，被广泛使用的其中一种。与其他常见的软件许可协议相比，MIT是相对宽松的软件许可协议，除了必须包含许可声明外，再无任何限制。</p><p>MIT许可协议核心条款：</p><ul><li>该软件及其相关文档对所有人免费，可以任意处置，包括使用、复制、修改、合并、发表、分发、再授权或销售；</li><li>唯一的限制，软件中必须包含上述版权和许可证。</li></ul><p><br></p><hr><p><br></p><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>Apache许可证（Apache License），是一个由Apache软件基金会发布的自由软件许可证。Apache许可证要求被授权者保留版权和放弃权利的声明，但它不是一个反版权的许可证。兼容与GPL。</p><p>除了为用户提供版权许可之外，还有专利许可，对于那些涉及专利内容的开发者而言，该协议最适合。</p><ul><li>永久权利：一旦被授权，永久拥有；</li><li>全球范围的权利：在一个国家获得授权，适用于所有国家；</li><li>授权免费，且无版税：前后期均无任何费用；</li><li>授权不可撤销：一旦获得授权，没有任何人可以取消。</li></ul><p>分发代码方面，要在声明中对参与开发的人给予认可并包含一份许可协议原文。</p><p><br></p><hr><p><br></p><h2 id="MPL"><a href="#MPL" class="headerlink" title="MPL"></a>MPL</h2><p>MPL是The Mozilla[mɔzilə] Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。<br>MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。</p><p>同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA 认定的开源软件许可证）。</p><p>MPL几个特点：</p><ul><li>MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL 许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口；</li><li>MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序；</li><li>对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利；</li><li>对源代码的定义，MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。</li></ul><p><br></p><hr><p><br></p><h2 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h2><p>知识共享许可协议(Creative Commons License，简称CC)，并非严格意义上的开源许可，是一种公共版权许可协议。它主要用于设计，其允许分发受版权保护的作品。</p><p>CC协议主要包含4种基本形式：</p><ul><li>署名权：必须为原始作业署名，然后才可以修改、分发、复制；</li><li>保持一致：作品同样可以在CC协议的基础上修改、分发、复制；</li><li>非商业：不能用于商业用途；</li><li>不能衍生新作品：你可以复制、分发、但不能修改，也不能以此为基础创作自己的作品。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你为你的产品签发许可，你就是在出让自己的权利。不过，你仍拥有版权和专利（如果申请了专利）。许可的目的，是向使用你产品的人提供一定的权利。&lt;/p&gt;
&lt;p&gt;不管产品是免费分发，还是出售，指定一份许可协议都非常有用。否则，对于免费，你相当于放弃了自己的所有权利，任何人都没有义务表明你的原始作者身份。对于出售，你将不得不花费比开发更多的精力用来处理授权问题。&lt;/p&gt;
&lt;p&gt;而开源许可协议是这些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的身份，使你至少获得认可。开源许可协议还可以阻止其它人将某个产品据为己有。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="开源许可协议" scheme="https://zhang21.github.io/tags/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Yum源</title>
    <link href="https://zhang21.github.io/2018/01/09/Yum%E6%BA%90/"/>
    <id>https://zhang21.github.io/2018/01/09/Yum源/</id>
    <published>2018-01-09T03:46:21.000Z</published>
    <updated>2018-03-11T08:32:42.636Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="http://blog.csdn.net/leshami/article/details/78133716" target="_blank" rel="noopener">CentOS 7下配置本地yum源及yum客户端</a></li><li><a href="http://blog.csdn.net/conling_/article/details/70399694" target="_blank" rel="noopener">Centos7 配置本地源+阿里yum源/epel-yum+修改优先级</a></li><li><a href="http://blog.csdn.net/kingfox/article/details/51233153" target="_blank" rel="noopener">调整CentOS 7中yum仓库的优先级</a></li><li><a href="https://segmentfault.com/a/1190000000375848" target="_blank" rel="noopener">国内开源站点</a></li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="国内开源镜像站点"><a href="#国内开源镜像站点" class="headerlink" title="国内开源镜像站点"></a>国内开源镜像站点</h1><ul><li>网易开源镜像站：<a href="http://mirrors.163.com/" target="_blank" rel="noopener">http://mirrors.163.com/</a></li><li>阿里云开源镜像站：<a href="http://mirrors.aliyun.com" target="_blank" rel="noopener">http://mirrors.aliyun.com</a></li><li>清华大学开源镜像站：<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a></li><li>浙江大学开源镜像站： <a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/</a></li><li>中国科技大学开源镜像站：<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a></li></ul><p><br></p><hr><p><br></p><h1 id="CentOS自带源"><a href="#CentOS自带源" class="headerlink" title="CentOS自带源"></a>CentOS自带源</h1><p>rpm包管理方式，对于安装、升级、卸载却难以处理包之间的依赖关系。而yum作为一个rpm包前端管理工具，可以自动处理依赖性，并支持在线现在、安装、升级、卸载rpm软件包。</p><p>CentOS默认自带<code>CentOS-Base.repo</code>源，但官方源在国外，连接速度令人心痛。并且有很多软件在默认源里面是找不到的。</p><h2 id="配置网络yun源"><a href="#配置网络yun源" class="headerlink" title="配置网络yun源"></a>配置网络yun源</h2><p><strong>配置aliyun.repo：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#先备份默认源</div><div class="line">mv CentOS-Base.repo&#123;,.bak&#125;</div><div class="line"></div><div class="line">#下载阿里云源替换默认源</div><div class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</div><div class="line"></div><div class="line">yum clean all</div><div class="line">yum makecache    #重构yum缓存</div><div class="line"></div><div class="line">yum repolist    #查看yum仓库</div></pre></td></tr></table></figure><p><br></p><h2 id="配置本地yum源"><a href="#配置本地yum源" class="headerlink" title="配置本地yum源"></a>配置本地yum源</h2><p><strong>配置本地yum源，考虑到优先使用本地安装包，所以会涉及到一个优先级的概念。</strong></p><p>安装完毕后，就可以在yum源中添加一个优先级<code>priority</code>。</p><p><strong>安装yum优先级插件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">yum install -y yum-plugin-priorities</div><div class="line"></div><div class="line">#检查安装完成后配置</div><div class="line">vim /etc/yum/pluginconf.d/priorities.conf</div><div class="line"></div><div class="line">enable=1</div><div class="line">#enable=0</div></pre></td></tr></table></figure><p><br></p><p><strong>创建本地yum源：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">mv /etc/yum.repos.d/CentOS-Base.repo&#123;,.bak&#125;</div><div class="line"></div><div class="line">vim /etc/yum.repos.d/CentOS-Local.repo</div><div class="line"></div><div class="line">[base-Local]</div><div class="line">name=Centos- Local</div><div class="line">baseurl=file:///mnt/xxx</div><div class="line">gpgcheck=0</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line">priority=1    #优先级为1</div><div class="line"></div><div class="line">[updates-Local]</div><div class="line">name=CentOS- Local</div><div class="line">gpgcheck=0</div><div class="line">baseurl=file:///dir/path/</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line">priority=1</div><div class="line"></div><div class="line">······</div><div class="line">#具体可参考CentOS-Base.repo</div><div class="line">#可将aliyun源优先级写成2</div><div class="line"></div><div class="line">yum clean all</div><div class="line">yum makecache</div></pre></td></tr></table></figure><p><br></p><h2 id="配置ftp方式源"><a href="#配置ftp方式源" class="headerlink" title="配置ftp方式源"></a>配置ftp方式源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">vim /etc/yum.repos.d/ftp.repo</div><div class="line"></div><div class="line">[ftp-media]</div><div class="line">name=name=CentOS-$releasever - media</div><div class="line">baseurl=ftp://ip</div><div class="line">gpgcheck=0</div><div class="line">enable=1</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line"></div><div class="line">yum clean all</div><div class="line">yum makecache</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="其他常见YUM源"><a href="#其他常见YUM源" class="headerlink" title="其他常见YUM源"></a>其他常见YUM源</h1><p>官方的默认<code>yum源</code>提供的软件包往往是很滞后的，(可能为了服务器版本的稳定性和安全性)。并且官方默认源提供的RPM包也不够丰富。</p><p><br></p><h2 id="EPEL源"><a href="#EPEL源" class="headerlink" title="EPEL源"></a>EPEL源</h2><p>EPEL的全称叫 <code>Extra Packages for Enterprise Linux</code> 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。</p><p><code>EPEL源</code>为服务器提供了大量的rpm包(这些包可能有很多在默认源中没有)，并且绝大多数rpm包比官方默认源版本要新。</p><p><strong>添加epel源：</strong><br>epel下载地址：<a href="http://download.fedora.redhat.com/pub/epel/" target="_blank" rel="noopener">http://download.fedora.redhat.com/pub/epel/</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpm -vih http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</div><div class="line"></div><div class="line"><span class="comment">#yum install -y epel-release</span></div></pre></td></tr></table></figure></p><p><br></p><h2 id="remi源"><a href="#remi源" class="headerlink" title="remi源"></a>remi源</h2><p>Remi源大家或许很少听说，不过Remi源GoFace强烈推荐，尤其对于不想编译最新版的linux使用者，因为Remi源中的软件几乎都是最新稳定版。<br>或许您会怀疑稳定不？<br>放心，这些都是Linux骨灰级的玩家编译好放进源里的，他们对于系统环境和软件编译参数的熟悉程度毋庸置疑。</p><p><strong>添加remi源：</strong><br>Remi下载地址：<a href="http://rpms.famillecollet.com" target="_blank" rel="noopener">http://rpms.famillecollet.com</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</div><div class="line"></div><div class="line"><span class="comment">#yum install -y  http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</span></div></pre></td></tr></table></figure></p><p><br></p><h2 id="RPMForge源"><a href="#RPMForge源" class="headerlink" title="RPMForge源"></a>RPMForge源</h2><p><code>RPMForge</code>是<code>CentOS</code>系统下的软件仓库，拥有4000多种的软件包, 被CentOS社区认为是最安全也是最稳定的一个软件仓库。</p><p><strong>添加RPMForge源：</strong><br>RPMForge下载地址：<a href="http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/" target="_blank" rel="noopener">http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/</a><br>GitHub:<a href="https://github.com/repoforge" target="_blank" rel="noopener">https://github.com/repoforge</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpm -ivh http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm</div><div class="line"></div><div class="line">#yum localinstall --nogpgcheckhttp://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/leshami/article/details/78133716&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CentOS 7下配置本地yum源及yum客户端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/conling_/article/details/70399694&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Centos7 配置本地源+阿里yum源/epel-yum+修改优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/kingfox/article/details/51233153&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;调整CentOS 7中yum仓库的优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000375848&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;国内开源站点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Yum" scheme="https://zhang21.github.io/tags/Yum/"/>
    
  </entry>
  
  <entry>
    <title>写给2017</title>
    <link href="https://zhang21.github.io/2018/01/01/%E5%86%99%E7%BB%992017/"/>
    <id>https://zhang21.github.io/2018/01/01/写给2017/</id>
    <published>2018-01-01T02:25:20.000Z</published>
    <updated>2018-01-09T05:42:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2018.jpg" alt="2018"></p><p><br><br><a id="more"></a></p><h1 id="2017大事件"><a href="#2017大事件" class="headerlink" title="2017大事件"></a>2017大事件</h1><ul><li>Feb.27.2017，开始工作；</li><li>May.27.2017，工作转正；</li><li>Jun.25.2017，大学毕业；</li><li>Aug.27.2017，工作半年；</li><li>Aug.30.2017，搭建博客。</li></ul><p>记得大四下期的时候，在学校实在是想出来工作，以为这样就可以有工资有点钱可以实现财务自由。Naive x3!</p><p>记得刚去面试的时候，公司的HR问我期待的薪资是多少。我这个老实人也不敢往高了说，以为能解决温饱就不错。这就导致后面日子过得紧巴巴，生活基本上处于没钱不敢消费不敢出去的惨状。Naive x3!</p><p>记得那天是星期四，从学校收拾了一箱子的衣物加上自己的笔记本就来了成都。还要感谢<strong>强</strong>对我的帮助，在他那借宿了两天。这两天跑到公司附近找房子，这打个电话，那去看看…结果看了看自己兜里不到三千，再看看房租，还是算了吧！后来由于周一就要开始去公司报道了，实在没办法，硬着头皮找了一个750的单间。我现在觉得，人在生活面前真的没有办法。借用张主任的一句话——“是生活，生活强奸了所有人。”一个套三的屋子，硬是被房主改造成了七间房，住了11人。我想各位住户都迫于无奈吧，有谁想和别人挤在一起了，况且还要忍受上厕所的艰难时光。<br>还是说说我住的那间房屋吧。是客厅使用木板隔得房间，手指随便敲几下都铛铛作响，况且隔壁还住了一对情侣。一张床，一个烂小衣柜，一张摆放电脑的桌子。客厅的后面有一个阳台，所以就会有一个大窗户间隔阳台。然而这个阳台是和隔壁公用的，也就是说，这个大窗户是可以互通的。哎！阳台风大，还好我只住到了夏天。<br>五月二十号，和我强一起搬到了中和。也是没有做好十足打算，说搬就搬了。虽说住宿条件好了一些，可这面修路是真的堵，公家车是真的挤，真的是挤得怀疑人生的那种，还是走路吧。由于搬过来中和，房租和其他开支多了一些，刚开始没什么钱的时候，自己带饭去公司。我都佩服自己，那么挤得车上还能坚持带饭几个月，看来还是穷吧。冬天到了，太冷了就没有带饭到公司了。但公司楼下吃饭真的好贵，吃不起吃不起。由于住宿条件好了一些，晚上回来可以自己做饭，还是不错。并且晚上基本有两个小时干干工作之外的事情，看看小说、看看电视、发发呆什么也挺好的！</p><p>记得才开始工作的时候，好像每天都很闲，没有事做。心里担忧的不行，这样怎么有提升呢？每天都急躁不安，这不会那不会，又腼腆害羞…后来慢慢理解，任何事情都不能操之过急，不能带着情绪上班。不喜欢某个同事也不能表现出来，更不能带到工作上。工作是工作，生活是生活，一定要分开。被骂也没有办法，骂吧，你骂高兴。任何人都不会听你的理由，理由对于别人来说只是你没有完成的狡辩。踏踏实实上班，做好自己的事情才是正解！千万不要好为人师，人都是有嫉妒心得，不要太招摇！也不要羡慕别人工作轻松之类，那是人家的工作，和你没有半毛钱关系。上班好好上班，不要搞东搞西。我个人比较看重效率，怀着为了加班而加班的目的真的没有必要。那时由于住单间，条件差，愿意在公司多呆一会，多学习知识。越到后面，觉得自己越得努力学习新知识，需要了解的知识就在那，就等我把它们一个个打上勾，撸起袖子加油干。</p><p><br></p><p><strong>自我批评:</strong></p><ul><li>心胸不够宽广，容易嫉妒别人；</li><li>害羞爱面子，拉不下面子做事情；</li><li>由于自卑心理导致的不敢说不敢争。</li></ul><p>以前我以为自己是讨厌某种方式、讨厌别人炫耀、讨厌别人秀恩爱，现在才知道是由于自己没有，就用自己的不屑和厌恶来突出自己，让自己心安理得。说白了还不是自己嫉妒人家，嫉妒人家比我好，有女票。这点是真的要改，一定要改。千万别用别人的缺点来突出自己，这很SB，切记切记。如同小波所说：“人的一切痛苦，本质都是对于自己无能的愤怒。”</p><p>在学校总幻想自己能成为英雄，总想做一番事业，像历史上的英雄那般。不屑考个老师公务员职位，以为一辈子就那样，混吃等死的咸鱼。其实其它工作不也同样是这样吗。混吃等死的不是任何工作岗位，而是人！任何岗位都可以有所成就。自己也不过只是凡人一个。不过凡人却也可以有自己的一片天地。就像小波说的：“井底之蛙也能拥有自己的一片天地。”</p><p>工作没有高低贵贱之分，不要带着要面子的心情而不愿意做些打杂的活。没有基础的积累，哪来平地起的万丈高楼。不要看不起自己也不要看不起他人。三十年河东三十年河西，此一时彼一时。</p><p>”中国的君子独善其身，这样就没有了尊严。这是因为尊严是属于个人的、不可压缩的空间，这块空间要靠自己来捍卫——捍卫的意思是指敢争、敢打官司、敢动手（勇斗歹徒）。我觉得人还是有点尊严的好，假如个人连个待的地方都没有，就无法为人做事，更不要说做别人的典范。“这句话同样适合我，该说该争该做的时候就应该大胆站出来，有一个男子汉的样子。要敢于亮剑！</p><p>我现在还不太明白我的人生目标是什么，名利？我不知道。我只想做一个懂点道理的人。上班以后感觉也变得世俗化了，不经意间都会主动被动地谈及任何关于钱的话题。我对钱有一些兴趣，但不愿为之受罪。我不想把自己的下半生绑在房子上，虽然我也买不起。找不到人同我谈谈诗歌、文学、历史、足球，谈谈理想和爱情。但正如小波所言：”和我志趣相投的人总不会一个人都没有吧。“我也不顾影自怜了。</p><p><br><br><br></p><h1 id="展望2018"><a href="#展望2018" class="headerlink" title="展望2018"></a>展望2018</h1><ul><li>最重要的事情当然是涨工资啦，哈哈。加油加油，为了涨工资可得好好奋斗；</li><li>如果能找一个离家近一点的工作当然是最好；</li><li>一个人总是孤独寂寞的，能找到一个能相互扶持的人当然最好；</li><li>改善自己的不同，提升自己的优点。扬长避短，向优秀的人多学习。</li></ul><p><br><br><br></p><h1 id="不成熟的想法"><a href="#不成熟的想法" class="headerlink" title="不成熟的想法"></a>不成熟的想法</h1><ul><li>成都这地方什么都要争，连坐个公交地铁也得积极地抢位置，哎；</li><li>人太多，太拥挤，随便去哪都是拥挤的要命。但另一方面却是人越多机会越多；</li><li>原来工作才是一生的主题。但到底图个啥——名？利？</li><li>上班以后认识的人也变少了，圈子也基本没什么了。曾经的同学们也各奔东西了；</li><li>我发觉任何一件事都是矛盾的。正面想是这样，反面想却又是那样，但都有道理。让我想起了一个故事，“一个农夫和一个老板在海边的对话。问：这么努力工作干嘛？答：为了以后能过更轻松的日子。那你看我现在不是挺轻松自在的吗？”</li><li>现在的自媒体为了流量真的是无所不用其极。各种大噱头的标题，完全不负责任的报道，只为吸引流量。到最后都不知道该相信谁，会不会被带节奏…；</li><li>一天24小时。8小时睡觉，8小时上班，3小时上下班，2小时吃饭及其他。It means that I only have 3 hours a day without Rest Day;</li><li>一个人只拥有此生此世是不够的，他还应该拥有诗意的世界。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2018.jpg&quot; alt=&quot;2018&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Zhang" scheme="https://zhang21.github.io/categories/Zhang/"/>
    
    
      <category term="2017" scheme="https://zhang21.github.io/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>君子的尊严</title>
    <link href="https://zhang21.github.io/2017/12/28/%E5%90%9B%E5%AD%90%E7%9A%84%E5%B0%8A%E4%B8%A5/"/>
    <id>https://zhang21.github.io/2017/12/28/君子的尊严/</id>
    <published>2017-12-28T01:58:32.000Z</published>
    <updated>2017-12-28T02:00:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者是个学究，待人也算谦和有礼，自以为算个君子——当然，实际上是不是，还要别人来评判。总的来说，君子是有文化有道德的人，是士人或称知识分子。按照中国的传统，君子是做人的典范。君子不言利。君子忍让不争。君子动口不动手。君子独善其身。这都是老辈子传下来的规矩，时至今日，以君子自居的人还是如此行事。我是宁做君子不做小人的，但我还是以为，君子身上有些缺点，不配作为人的典范；因为他太文弱、太窝囊、太受人欺。</p><a id="more"></a><p><br></p><p>君子既不肯与人争利，就要安于清贫。但有时不是钱的问题，是尊严的问题。前些时候在电视上看到北京的一位人大代表发言，说儿童医院的挂号费是一毛钱，公厕的收费是两毛钱。很显然，这样的收费标准有损医务工作的尊严。当然，发言的结尾是呼吁有关领导注意这个问题，有关领导也点点头说：是呀是呀，这个问题要重视。我总觉得这位代表太君子，没把话讲清楚——直截了当的说法是：我们要收两块钱。别人要是觉得太贵，那你就还个价来——这样三下五除二就切入了正题。这样说话比较能解决问题。</p><p><br></p><p>君子不与人争，就要受气。举例来说，我乘地铁时排队购票，总有些不三不四的人到前面加塞。说实在的，我有很多话要说：我排队，你为什么不排队？你忙，难道我就没有事？但是碍于君子的规范，讲不出口来。话憋在肚子里，难免要生气。有时气不过，就嚷嚷几句：排队，排队啊。这种表达方式不够清晰，人家也不知是在说他。正确的方式是：指住加塞者的鼻子，口齿清楚地说道：先生，大家都在排队，请你也排队。但这样一来，就陷入与人争论的境地，肯定不是君子了。</p><p><br></p><p>常在报纸上看到这样的消息：流氓横行不法，围观者如堵，无人上前制止。我敢断定，围观的都是君子，也很想制止，但怎么制止呢？难道上前和他打架吗？须知君子动口不动手啊。我知道英国有句俗话：绅士动拳头，小人动刀子。假如在场的是英国绅士，就可以上前用拳头打流氓了。</p><p><br></p><p>既然扯到了绅士，就可以多说几句。从前有个英国人到澳大利亚去旅行，过海关时，当地官员问他是干什么的。他答道：我是一个绅士。因为历史的原因，澳大利亚人不喜欢听到这句话，尤其不喜欢听到这句话从一个英国人嘴里说出来。那官员又问：我问你的职业是什么？英国人答道：职业就是绅士。难道你们这里没有绅士吗？这下澳大利亚人可火了，差点揍他，幸亏有人拉开了。在英美，说某人不是绅士，就是句骂人话。当然，在我们这里说谁不是君子，等于说他是小人，也是句骂人话。但君子和绅士不是一个概念。从字面上看，绅士（gentleman）是指温文有礼之人，其实远不止此。绅士要保持个人的荣誉和尊严，甚至可以说是这方面的专业户。坦白地说，他们有点狂傲自大。但也有一种好处：真正的绅士决不在危险面前止步。大战期间，英国绅士大批开赴前线为国捐躯，甚至死在了一般人前面。君子的标准里就不包括这一条。</p><p><br></p><p>中国的君子独善其身，这样就没有了尊严。这是因为尊严是属于个人的、不可压缩的空间，这块空间要靠自己来捍卫——捍卫的意思是指敢争、敢打官司、敢动手（勇斗歹徒）。我觉得人还是有点尊严的好，假如个人连个待的地方都没有，就无法为人做事，更不要说做别人的典范。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者是个学究，待人也算谦和有礼，自以为算个君子——当然，实际上是不是，还要别人来评判。总的来说，君子是有文化有道德的人，是士人或称知识分子。按照中国的传统，君子是做人的典范。君子不言利。君子忍让不争。君子动口不动手。君子独善其身。这都是老辈子传下来的规矩，时至今日，以君子自居的人还是如此行事。我是宁做君子不做小人的，但我还是以为，君子身上有些缺点，不配作为人的典范；因为他太文弱、太窝囊、太受人欺。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="王小波" scheme="https://zhang21.github.io/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>个人尊严</title>
    <link href="https://zhang21.github.io/2017/12/28/%E4%B8%AA%E4%BA%BA%E5%B0%8A%E4%B8%A5/"/>
    <id>https://zhang21.github.io/2017/12/28/个人尊严/</id>
    <published>2017-12-28T01:54:39.000Z</published>
    <updated>2017-12-28T01:56:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>在国外时看到，人们对时事做出价值评判时，总是从两个独立的方面来进行：一个方面是国家或者社会的尊严，这像是时事的经线；另一个方面是个人的尊严，这像是时事的纬线。回到国内，一条纬线就像是没有，连尊严这个字眼也感到陌生了。提到尊严这个概念，我首先想到的英文词＂dignity＂，然后才想到相应的中文词。在英文中，这个词不仅有尊严之义，还有体面、身份的意思。尊严不但指人受到尊重，它还是人价值之所在。从上古到现代，数以亿万计的中国人里，没有几个人有过属于个人的尊严。举个大点的例子，中国历史上有过皇上对大臣施廷杖的事，无论是多大的官，一言不和，就可能受到如此当众羞辱，高官尚且如此，遑论百姓。除了皇上一人，没有一个人能有尊严。有一件最怪的事是，按照传统道德，挨皇帝的板子倒是一种光荣，文死谏嘛。说白了就是：无尊严就是有尊严。此话如有任何古怪之处，罪不在我。到了现代以后，人与人的关系、个人与集体的关系，仍有这种遗风──我们就不必细说文革中、文革前都发生过什么样的事情。到了现在，已经不用见官下跪，也不会在屁股上挨板子，但还是缺少个人的尊严。环境就是这样，公共场所的秩序就是这样，人对人的态度就是这样，不容你有任何自尊。</p><a id="more"></a><p><br></p><p>举个小点的例子，每到春运高潮，大家就会在传媒上看到一辆硬座车厢里挤了三四百人，厕所里也挤了十几人。谈到这件事，大家会说国家的铁路需要建设，说到铁路工人的工作难做，提到安全问题，提到所有的方面，就是不提这些民工这样挤在一起，好像一个团，完全没有了个人的尊严──仿佛这件事很不重要似的。当然，只要民工都在过年时回家，火车总是要挤的；谁也想不出好办法。但个人的尊严毕竟大受损害；这件事总该有人提一提才对。另一件事现在已是老生常谈，人走在街上感到内急，就不得不上公共厕所。一进去就觉得自己的尊严一点都没了。现在北京的公厕正在改观，这是因为外国人到了中国也会内急，所以北京的公厕已经臭名远扬。假如外国人不来，厕所就要臭下去；而且大街上改了，小胡同里还没有改。我认识的一位美国留学生说，有一次他在小胡同里内急，走进公厕撒了一泡尿，出来以后，猛然想到自己刚才满眼都对黄白之物，居然能站住了不倒，觉得自己很了不起，就急忙来告诉我。北京的某些街道很脏很乱，总要到某个国际会议时才能改观，这叫借某某会的东风。不光老百姓这样讲，领导上也这样讲。这话听起来很有点不对味。不雅的景象外人看了丢脸，没有外人时，自己住在里面也不体面──这后一点总是被人忘掉。</p><p><br></p><p>作为一个知识分子，我发现自己曾有一种特别的虚伪之处，虽然一句话说不清，但可以举些例子来说明。假如我看到火车上特别挤，就感慨一声道：这种事居然可以发生在中华人民共和国的土地上！假如我看到厕所特脏，又长叹一声：唉！北京市这是怎么搞的嘛！这其中有点幽默的成份，也有点当真。我的确觉得国家和政府的尊严受到了损失，并为此焦虑着。当然，我自己也想要点个人尊严，但以个人名义提出就过于直露，不够体面──言必称天下，不以个人面目出现，是知识分子的尊严所在。当然，现在我把这做为虚伪提出，已经自外于知识分子。但也有种好处，我找到了自己的个人面目。有关尊严问题，不必引经据典，我个人就是这么看。但中国忽视个人尊严，却不是我的新发现。从大智者到通俗作家，有不少人注意到一个有中国特色的现象：罗素说，中国文化里只重家族内的私德，不重社会的公德公益，这一点造成了很要命的景象；费孝通说，中国社会里有所谓＂差序格局＂，与己关系近的就关心，关系远的就不关心或少关心；结果有些事从来就没人关心。龙应台为这类事而愤怒过，三毛也大发过一通感慨。读者可能注意到了，所有指出这个现象的人，或则是外国人，或则曾在国外生活过，又回到了国内。没有这层关系的中国人，对此浑然不觉。笔者自己曾在外国居住四年，假如没有这种经历，恐怕也发不出这种议论──但这一点并不让我感到开心。环境脏乱的问题，火车拥挤的问题，社会秩序的问题，人们倒是看到了。但总从总体方面提出问题，讲国家的尊严、民族的尊严。其实这些事就发生在我们身边，削我们每个人的面子──对此能够浑然无觉，倒是咄咄怪事。</p><p><br></p><p>人有无尊严，有一个简单的判据，是看他被当作一个人还是一个东西来对待。这件事有点两重性，其一是别人把你当做人还是东西，是你尊严之所在。其二是你把自己看成人还是东西，也是你的尊严所在。挤火车和上公共厕所时，人只被当身体来看待。这里既有其一的成份，也有其二的成份；而且归根结蒂，和我们的文化传统有关。</p><p><br></p><p>说来也奇怪，中华礼仪之邦，一切尊严，都从整体和人与人的关系上定义，就是没有个人的位置。一个人不在单位里、不在家里，不代表国家、民族，单独存在时，居然不算一个人，就算是一块肉。这种算法当然是有问题。我的算法是：一个人独处荒岛而且谁也不代表，就像鲁滨孙那样，也有尊严，可以很好的活着。这就是说，个人是尊严的基本单位。知道了这一点，火车上太挤了之后，我就不会再挤进去而且浑然无觉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在国外时看到，人们对时事做出价值评判时，总是从两个独立的方面来进行：一个方面是国家或者社会的尊严，这像是时事的经线；另一个方面是个人的尊严，这像是时事的纬线。回到国内，一条纬线就像是没有，连尊严这个字眼也感到陌生了。提到尊严这个概念，我首先想到的英文词＂dignity＂，然后才想到相应的中文词。在英文中，这个词不仅有尊严之义，还有体面、身份的意思。尊严不但指人受到尊重，它还是人价值之所在。从上古到现代，数以亿万计的中国人里，没有几个人有过属于个人的尊严。举个大点的例子，中国历史上有过皇上对大臣施廷杖的事，无论是多大的官，一言不和，就可能受到如此当众羞辱，高官尚且如此，遑论百姓。除了皇上一人，没有一个人能有尊严。有一件最怪的事是，按照传统道德，挨皇帝的板子倒是一种光荣，文死谏嘛。说白了就是：无尊严就是有尊严。此话如有任何古怪之处，罪不在我。到了现代以后，人与人的关系、个人与集体的关系，仍有这种遗风──我们就不必细说文革中、文革前都发生过什么样的事情。到了现在，已经不用见官下跪，也不会在屁股上挨板子，但还是缺少个人的尊严。环境就是这样，公共场所的秩序就是这样，人对人的态度就是这样，不容你有任何自尊。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="王小波" scheme="https://zhang21.github.io/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
</feed>
