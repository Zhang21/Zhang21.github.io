<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风继续吹</title>
  <subtitle>Yesterday, you said tomorrow!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhang21.github.io/"/>
  <updated>2018-01-18T04:00:58.848Z</updated>
  <id>https://zhang21.github.io/</id>
  
  <author>
    <name>Zhang21</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL</title>
    <link href="https://zhang21.github.io/2018/01/16/MySQL/"/>
    <id>https://zhang21.github.io/2018/01/16/MySQL/</id>
    <published>2018-01-16T02:47:12.000Z</published>
    <updated>2018-01-18T04:00:58.848Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p>
<ul>
<li>MySQL5.7参考文档： <a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.7/en/</a></li>
</ul>
<p><br></p>
<p>环境：</p>
<ul>
<li>CentOS7.x86_64</li>
<li>MySQL5.7</li>
</ul>
<a id="more"></a>
<p><br></p>
<hr>
<p><br></p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>MySQL官网： <a href="https://www.mysql.com/" target="_blank" rel="external">https://www.mysql.com/</a></p>
<p>由于MySQL5.7和以前版本之间的许多功能和其他差异，因此此手册不太适用于之前的老版本。之前的版本请参考MySQL相关版本的手册。</p>
<p><br></p>
<p><img src="/images/Mysql/MySQL.png" alt="MySQL"></p>
<p><br></p>
<hr>
<p><br></p>
<h1 id="综述-General-information"><a href="#综述-General-information" class="headerlink" title="综述(General information)"></a>综述(General information)</h1><p>MySQL™ software提供了一个快速、多线程、多任务和健壮的SQL(结构化查询语言)的数据库服务器。MySQL server是为关键服务(mission-critical)、重负荷(heavy-load)生产系统以及嵌入式(embedding)大规模部署的软件而设计。<br>MySQL是Oracle Corporation的商标(trademark)。</p>
<p>MySQL software是双重许可的(dual license)：</p>
<ol>
<li>Open Source product of the GNU General Public License</li>
<li>A Standard commercial License from Oracle</li>
</ol>
<p><br><br><br></p>
<h2 id="关于此手册"><a href="#关于此手册" class="headerlink" title="关于此手册"></a>关于此手册</h2><ul>
<li>该手册作为一个参考，它不提供关于SQL或关系型数据库概念的一般指令；</li>
<li>MySQL Database Software正在不断发展，所以参考手册也经常更新。可在此 &lt; <a href="http://dev.mysql.com/doc/&gt;" target="_blank" rel="external">http://dev.mysql.com/doc/&gt;</a> 获取最新版的手册；</li>
<li>参考手册(Reference Manual)的源文件使用DocBook XML格式书写的，其他版本(如HTML)等是自动生成的；</li>
<li>如果在使用过程中有任何问题或建议，请发邮件给我们；</li>
<li>手册由MySQL Documentation Team维护。</li>
</ul>
<p><br><br><br></p>
<h2 id="MySQL-Database-Management-System"><a href="#MySQL-Database-Management-System" class="headerlink" title="MySQL Database Management System"></a>MySQL Database Management System</h2><p><br></p>
<h3 id="What-is-MySQL"><a href="#What-is-MySQL" class="headerlink" title="What is MySQL"></a>What is MySQL</h3><p>MySQL是最流行的开源的SQL数据库管理系统，由Oracle Corporation开发、分发和支持。</p>
<p><br></p>
<ul>
<li><p>MySQL is a database management system<br>数据库是一个结构化的数据集合。它可能是从简单的购物清单到图片库，或是公司网络中的大量信息。若要添加、访问和处理存储在计算机数据库中的数据，你需要一个像MySQL Server这样的数据库管理系统。由于计算机非常擅长处理大量的数据，数据库管理系统在计算机中扮演这一个重要的角色。</p>
</li>
<li><p>MySQL databases are relational<br>关系型数据库将数据存储在单独的表(table)中，而不是将所有数据放入一个大的库房中。数据库结构被组织成针对速度优化的物理文件。具有数据库(database)，表(table)，视图(view)，行(row)，列(column)等物理对象的逻辑模型提供了灵活的编程环境。你设置了管理不同数据字段之间关系的规则，如一对一，一对多，唯一，必须和可选关系，以及不同表之间的指针(pointer)。数据库强制执行这些规则，这样在设计良好的数据库中，应用程序就不会看到不一致、重复、孤立、过时或丢失的数据。</p>
</li>
</ul>
<p>MySQL也是代表SQL(Structure Query Language)的一部分。SQL是访问数据库最常用的标准化语言。你可以直接使用SQL语句，或者将SQL语法隐藏到语言特定的API中。</p>
<p>-MySQL software is Open Source<br>MySQL software使用GPL(GNU General Public License)，开源意味着任何人都可以下载、转发、使用和修改软件，而不需要支付任何费用。</p>
<ul>
<li><p>MySQL database server is very fast,reliable,scalabe and easy to use</p>
</li>
<li><p>MySQL server works in Client/Server or embedded system<br>MySQL Database Server是一个由多线程(multi-threaded)SQL Server组成的客户/服务器系统。它支持不同的后端，多个不同的客户程序和库、管理工具和广泛的APIs。<br>还提供MySQL Server作为一个嵌入式多线程库以便链接到你的产品，以获得一个更小，更快，更容易管理的独立产品。</p>
</li>
<li><p>A large amount of contributed MySQL software is available</p>
</li>
</ul>
<p><br><br><br></p>
<h3 id="The-Main-Features-of-MySQL"><a href="#The-Main-Features-of-MySQL" class="headerlink" title="The Main Features of MySQL"></a>The Main Features of MySQL</h3><h4 id="Internals-and-Portability"><a href="#Internals-and-Portability" class="headerlink" title="Internals and Portability"></a>Internals and Portability</h4><ul>
<li>由C和C++写成</li>
<li>适用于许多不同的平台</li>
<li>为了可移植性，使用<code>CMake</code></li>
<li>采用独立(independent)模块的多层(layer)服务器设计</li>
<li>设计为使用内核线程的完全多线程，如果有多核CPU，能够轻松使用它们</li>
<li>提供了事务性(transactional)和非事务性(notransactional)存储引擎</li>
<li>使用非常快速的带有索引压缩的B-tree磁盘表</li>
<li>添加其他存储引擎相对容易</li>
<li>使用非常快速的基于线程的内存分配系统</li>
<li>使用优化的嵌套循环(nested-loop)连接执行非常快的联结</li>
<li>实现内存中的hash table，这些表用作临时表</li>
<li>使用高度优化的类库实现SQL函数</li>
</ul>
<p><br></p>
<h4 id="Data-Type"><a href="#Data-Type" class="headerlink" title="Data Type"></a>Data Type</h4><ul>
<li>1,2,3,4和8byte的有无符号(signed/unsigned)的整数(integers)</li>
<li>FLOAT</li>
<li>DOUBLE</li>
<li>CHAR, VARCHAR</li>
<li>BINARY, VARBINARY</li>
<li>TEXT</li>
<li>BLOB</li>
<li>DATE, TIME, DATETIME</li>
<li>TIMESTAMP</li>
<li>YEAR</li>
<li>SET</li>
<li>ENUM</li>
<li>OpenGIS</li>
</ul>
<p><br></p>
<h4 id="Statements-and-Functions"><a href="#Statements-and-Functions" class="headerlink" title="Statements and Functions"></a>Statements and Functions</h4><ul>
<li><code>SELECT</code>和<code>WHERT</code>中包含了所有支持的操作符和函数</li>
<li>SQL中的<code>GROUP BY</code>和<code>ORDER BY</code>也全部支持</li>
<li>GROUP functions(<code>COUNT()</code>, <code>AVG()</code>, <code>STD()</code>, <code>SUM()</code>, <code>MAX()</code>, <code>MIN()</code>, <code>GROUP_CONCAT()</code>)</li>
<li>支持<code>LEFT OUTER JOIN</code>和<code>ROGHT OUTER JOIN</code></li>
<li>按照SQL标准支持table和columns的别名</li>
<li>支持<code>DELETE</code>,<code>INSERT</code>,<code>REPLACE</code>,<code>UPDATE</code>，以返回受影响的行数</li>
<li>支持MySQL特定的<code>SHOW</code>显示语句</li>
<li>一个<code>EXPLAIN</code>语句显示优化器如何解析查询</li>
</ul>
<p><br></p>
<h4 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h4><ul>
<li>权限(privilege)和密码系统，非常灵活和安全，并且支持基于主机的验证</li>
<li>当连接到Server时，通过加密(encryption)所有密码通信量来确保密码安全</li>
</ul>
<p><br></p>
<h4 id="Scalability-and-Limits"><a href="#Scalability-and-Limits" class="headerlink" title="Scalability and Limits"></a>Scalability and Limits</h4><ul>
<li>支持大型数据库。包含五千万条记录，二十万个表，五十亿行</li>
<li>每个表最多支持64个索引，每个索引可以由1到16个列组成</li>
</ul>
<p><br></p>
<p>####　Conectivity</p>
<ul>
<li>客户端使用如下几种协议连接到MySQL Server<ul>
<li>TCP/IP sockets</li>
<li>–enable-named-pipe on Windows</li>
<li>Unix domain socket files on UNIX</li>
</ul>
</li>
<li>MySQL客户端可用多种语言编写</li>
<li>APIs对于多数语言是可用的</li>
</ul>
<p><br></p>
<h4 id="Localization"><a href="#Localization" class="headerlink" title="Localization"></a>Localization</h4><ul>
<li>Server可以向多种语言的客户端提供错误信息</li>
<li>完全支持几个不同的字符集(character sets)</li>
<li>所有数据都被保存在选取的字符集(chracter set)</li>
<li>排序和比较是根据默认的字符集和排序规则完成</li>
<li>服务器时区(time zone)可动态更改，个客户端也可修改自己的时区</li>
</ul>
<p><br></p>
<h4 id="Clients-and-Tools"><a href="#Clients-and-Tools" class="headerlink" title="Clients and Tools"></a>Clients and Tools</h4><ul>
<li>MySQL包含几个客户机和使用程序<ul>
<li>command-line： <code>mysqldump</code>, <code>mysqladmin</code></li>
<li>graphical: MySQL Workbench</li>
</ul>
</li>
<li>MySQL Server内置了对SQL语句的支持来检查、优化和修复表</li>
<li>MySQL程序可使用<code>--help</code>或<code>-?</code>来获取帮助</li>
</ul>
<p><br><br><br></p>
<h3 id="History-of-MySQL"><a href="#History-of-MySQL" class="headerlink" title="History of MySQL"></a>History of MySQL</h3><ul>
<li>MySQL is named after co-founder Monty Widenius’s daughter, My.</li>
<li>The name of the MySQL Dolphin (our logo) is “Sakila,” which was chosen from a huge list of names suggested by users in our “Name the Dolphin” contest.</li>
</ul>
<p><br><br><br></p>
<h2 id="What-Is-New-in-MySQL-5-7"><a href="#What-Is-New-in-MySQL-5-7" class="headerlink" title="What Is New in MySQL 5.7"></a>What Is New in MySQL 5.7</h2><p><br></p>
<h3 id="Features-Added-in-MySQL-5-7"><a href="#Features-Added-in-MySQL-5-7" class="headerlink" title="Features Added in MySQL 5.7"></a>Features Added in MySQL 5.7</h3><p><br><br><br></p>
<h3 id="Features-Deprecated-in-MySQL-5-7"><a href="#Features-Deprecated-in-MySQL-5-7" class="headerlink" title="Features Deprecated in MySQL 5.7"></a>Features Deprecated in MySQL 5.7</h3><p><br><br><br></p>
<h3 id="Features-Removed-in-MySQL-5-7"><a href="#Features-Removed-in-MySQL-5-7" class="headerlink" title="Features Removed in MySQL 5.7"></a>Features Removed in MySQL 5.7</h3><p><br><br><br></p>
<h2 id="Server-and-Status-Variables-and-Options-Added-Deprecated-or-Removed-in-MySQL-5-7"><a href="#Server-and-Status-Variables-and-Options-Added-Deprecated-or-Removed-in-MySQL-5-7" class="headerlink" title="Server and Status Variables and Options Added, Deprecated, or Removed in MySQL 5.7"></a>Server and Status Variables and Options Added, Deprecated, or Removed in MySQL 5.7</h2><p><br><br><br></p>
<h2 id="MySQL-Information-Sources"><a href="#MySQL-Information-Sources" class="headerlink" title="MySQL Information Sources"></a>MySQL Information Sources</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL5.7参考文档： &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7.x86_64&lt;/li&gt;
&lt;li&gt;MySQL5.7&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="https://zhang21.github.io/categories/Database/"/>
    
    
      <category term="MySQL" scheme="https://zhang21.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>2018小计划</title>
    <link href="https://zhang21.github.io/2018/01/15/2018%E5%B0%8F%E8%AE%A1%E5%88%92/"/>
    <id>https://zhang21.github.io/2018/01/15/2018小计划/</id>
    <published>2018-01-15T03:08:11.000Z</published>
    <updated>2018-01-19T03:56:09.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><ul>
<li><p>[ ] 《MongoDB官方文档》： <a href="https://docs.mongodb.com" target="_blank" rel="external">https://docs.mongodb.com</a></p>
</li>
<li><p>[ ] 《SatlStack官方文档》： <a href="https://docs.saltstack.com" target="_blank" rel="external">https://docs.saltstack.com</a></p>
</li>
<li><p>[ ] 《MySQL官方文档》： <a href="https://dev.mysql.com/doc/" target="_blank" rel="external">https://dev.mysql.com/doc/</a></p>
</li>
<li><p>[ ] 《TCP/IP协议族》： <a href="https://book.douban.com/subject/5386194/" target="_blank" rel="external">https://book.douban.com/subject/5386194/</a></p>
</li>
<li><p>[ ] 《Linux性能调优指南》： <a href="https://lihz1990.gitbooks.io/transoflptg/content/" target="_blank" rel="external">https://lihz1990.gitbooks.io/transoflptg/content/</a></p>
</li>
</ul>
<a id="more"></a>
<p><br></p>
<hr>
<p><br></p>
<h1 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h1><ul>
<li><p>[ ] 《资本论》： <a href="https://book.douban.com/subject/1150503/" target="_blank" rel="external">https://book.douban.com/subject/1150503/</a></p>
</li>
<li><p>[ ] 《灵飞经小楷》： <a href="https://book.douban.com/subject/1115916/" target="_blank" rel="external">https://book.douban.com/subject/1115916/</a></p>
</li>
</ul>
<p><br></p>
<hr>
<p><br></p>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><ul>
<li style="list-style: none"><input type="checkbox"> 沉得住气；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;[ ] 《MongoDB官方文档》： &lt;a href=&quot;https://docs.mongodb.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://docs.mongodb.com&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[ ] 《SatlStack官方文档》： &lt;a href=&quot;https://docs.saltstack.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://docs.saltstack.com&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[ ] 《MySQL官方文档》： &lt;a href=&quot;https://dev.mysql.com/doc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://dev.mysql.com/doc/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[ ] 《TCP/IP协议族》： &lt;a href=&quot;https://book.douban.com/subject/5386194/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://book.douban.com/subject/5386194/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[ ] 《Linux性能调优指南》： &lt;a href=&quot;https://lihz1990.gitbooks.io/transoflptg/content/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://lihz1990.gitbooks.io/transoflptg/content/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Zhang" scheme="https://zhang21.github.io/categories/Zhang/"/>
    
    
      <category term="2018" scheme="https://zhang21.github.io/tags/2018/"/>
    
  </entry>
  
  <entry>
    <title>海明威的《老人与海》</title>
    <link href="https://zhang21.github.io/2018/01/13/%E6%B5%B7%E6%98%8E%E5%A8%81%E7%9A%84%E3%80%8A%E8%80%81%E4%BA%BA%E4%B8%8E%E6%B5%B7%E3%80%8B/"/>
    <id>https://zhang21.github.io/2018/01/13/海明威的《老人与海》/</id>
    <published>2018-01-13T01:49:53.000Z</published>
    <updated>2018-01-15T02:06:45.715Z</updated>
    
    <content type="html"><![CDATA[<p>我不相信人会有所谓的“命运”，但是我相信对于任何人来说，“限度”总是存在的。再聪明再强悍的人，能够做到的事情也总是有限度的。老人桑地亚哥不是无能之辈，然而，尽管他是最好的渔夫，也不能让那些鱼来上他的钩。他遇到他的限度了，就象最好的农民遇上了大旱，最好的猎手久久碰不到猎物一般。每一个人都会遇到这样的限度，仿佛是命运在向你发出停止前行的命令。</p>
<a id="more"></a>
<p><br></p>
<p>可是老人没有沮丧，没有倦怠，他继续出海，向限度挑战。他终于钓到了一条鱼。如同那老人是人中的英雄一样，这条鱼也是鱼中的英雄。鱼把他拖到海上去，把他拖到远离陆地的地方，在海上与老人决战。在这场鱼与人的恶战中，鱼也有获胜的机会。鱼在水下坚持了几天几夜，使老人不能休息，穷于应付，它用酷刑来折磨老人，把他弄得血肉模糊。这时，只要老人割断钓绳，就能使自己摆脱困境，得到解放，但这也就意味着宣告自己是失败者。老人没有作这样得选择，甚至没有产生过放弃战斗的念头。他把那条鲨鱼当作一个可与之交战的敌手，一次又一次地做着限度之外的战斗，他战胜了。</p>
<p><br></p>
<p>老人载着他的鱼回家去，鲨鱼在路上抢劫他的猎物。他杀死了一条来袭的鲨鱼，但是折断了他的鱼叉。于是他用刀子绑在棍子上做武器。到刀子又折断的时候，似乎这场战斗已经结束了。他失去了继续战斗的武器，他又遇到了他的限度。这是，他又进行了限度之外的战斗：当夜幕降临，更多的鲨鱼包围了他的小船，他用木棍、用桨、甚至用舵和鲨鱼搏斗，直到他要保卫的东西失去了保卫的价值，直到这场搏斗已经变得毫无意义的时候他才住手。</p>
<p><br></p>
<p>老人回到岸边，只带回了一条白骨，只带回了残破不堪的小船和耗尽了精力的躯体。人们怎样看待这场斗争呢？</p>
<p>有人说老人桑地亚哥是一个失败了得英雄。尽管他是条硬汉，但还是失败了。</p>
<p>什么叫失败？也许可以说，人去做一件事情，没有达到预期得目的，这就是失败。</p>
<p><br></p>
<p>但是，那些与命运斗争的人，那些做接近自己限度的斗争的人，却天生地接近这种失败。老人到海上去，不能期望天天有鱼来咬他的钩，于是他常常失败。一个常常在进行着接近自己限度的斗争的人总是会常常失败的，一个想探索自然奥秘的人也常常会失败，一个想改革社会的人更是会常常失败。只有那些安于自己限度之内的生活的人才总是“胜利”，这种“胜利者”之所以常胜不败，只是因为他的对手是早已降伏的，或者说，他根本没有投入斗争。</p>
<p><br></p>
<p>在人生的道路上，“失败“这个词还有另外的含义，即是指人失去了继续斗争的信心，放下了手中的武器。人类向限度屈服，这才是真正的失败。而没有放下手中武器，还在继续斗争，继续向限度挑战的人并没有失败。如此看来，老人没有失败，老人从未放下武器，只不过是丧失了武器。老人没有失去信心，因此不应当说他是“失败了的英雄”。</p>
<p><br></p>
<p>那么，什么也没有得到的老人竟是胜利的么？我确是这样看的。我认为，胜利就是战斗到最后的时刻。老人总怀着无比的勇气走向莫测的大海，他的信心是不可战胜的。</p>
<p>他和其他许多人一样，是强悍的人类的一员。我喜欢这样的人，也喜欢这样的人性。我发现，人们常常把这样的事情当作人性最可贵的表露：七尺男子汉坐在厨房里和三姑六婆磨嘴皮子，或者衣装笔挺的男女们坐在海滨，谈论着高尚的、别人不能理解的感情。我不喜欢人们像这样沉溺在人性软弱的部分之中，更不喜欢人们总是这样描写人性。</p>
<p><br></p>
<p>正像老人每天走向大海一样，很多人每天也走向与他们的限度斗争的战场，仿佛他们要与命运一比高低似的。他们是人中的强者。</p>
<p>人类本身也有自己的限度，但是当人们一再把手伸到限度之外，这个限度就一天一天地扩大了。人类在与限度的斗争中成长。他们把飞船送上太空，他们也用简陋的渔具在加勒比海捕捉巨大的马林鱼。这些事情是同样伟大的。做这样不可思议的事情的人都是英雄。而那些永远不肯或不能越出自己限度的人是平庸的人。</p>
<p><br></p>
<p>在人类前进的道路上，强者与弱者的命运是不同的。弱者不羡慕强者的命运，强者也讨厌弱者的命运。强者带有人性中强悍的一面，弱者带有人性中软弱的一面。强者为弱者开辟道路，但是强者往往为弱者所奴役，就像老人是为大腹便便的游客打鱼一样。</p>
<p><br></p>
<p>《老人与海》讲了一个老渔夫的故事，但是在这个故事里却揭示了人类共同的命运。我佩服老人的勇气，佩服他不屈不饶的斗争精神，也佩服海明威。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我不相信人会有所谓的“命运”，但是我相信对于任何人来说，“限度”总是存在的。再聪明再强悍的人，能够做到的事情也总是有限度的。老人桑地亚哥不是无能之辈，然而，尽管他是最好的渔夫，也不能让那些鱼来上他的钩。他遇到他的限度了，就象最好的农民遇上了大旱，最好的猎手久久碰不到猎物一般。每一个人都会遇到这样的限度，仿佛是命运在向你发出停止前行的命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="王小波" scheme="https://zhang21.github.io/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>sysctl,ulimit以及/proc</title>
    <link href="https://zhang21.github.io/2018/01/09/sysctl%E3%80%81ulimit%E5%92%8Cproc/"/>
    <id>https://zhang21.github.io/2018/01/09/sysctl、ulimit和proc/</id>
    <published>2018-01-09T09:22:48.000Z</published>
    <updated>2018-01-10T02:44:10.858Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p>
<ul>
<li><a href="http://man.linuxde.net/sysctl" target="_blank" rel="external">sysctl命令</a></li>
<li><a href="http://man.linuxde.net/ulimit" target="_blank" rel="external">ulimit命令</a></li>
<li><a href="http://www.jianshu.com/p/20a2dd80cbad" target="_blank" rel="external">ulimit、limits.conf、sysctl和proc文件系统</a></li>
<li><a href="http://www.jianshu.com/p/9a8e383b5b49" target="_blank" rel="external">sysctl.conf学习和调优</a></li>
</ul>
<a id="more"></a>
<p><br></p>
<hr>
<p><br></p>
<h1 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h1><p><code>sysctl</code> 命令被用于在内核运行时动态地修改内核的运行参数，可用的内核参数在目录 <code>/proc/sys</code> 中。它包含一些<code>Tcp/Ip</code>堆栈和虚拟内存系统的高级选项，可以通过修改某些值来提高系统性能。</p>
<p><code>sysctl</code>可以读取和设置超过五百个系统变量。<br><code>sysctl</code>变量的设置通常是<strong>字符串、数字或布尔型</strong>（布尔型用1表示yes，0表示no）。</p>
<p><code>sysctl</code> - configure kernel parameters at runtime.</p>
<p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#sysctl [options] [variable[=value]] [...]</div><div class="line"></div><div class="line">sysctl -w net.ipv4.tcp_syncookies=1</div></pre></td></tr></table></figure>
<p><br></p>
<p>可以通过<code>sysctl</code>命令修改系统变量，也可以通过编辑<code>sysctl.conf</code>配置文件来修改系统变量。</p>
<p><code>sysctl.conf</code> - sysctl preload/configuration file.</p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysct.conf</div><div class="line"></div><div class="line"></div><div class="line"># Controls source route verification</div><div class="line"># Default should work for all interfaces net.ipv4.conf.default.rp_filter = 1</div><div class="line"># net.ipv4.conf.all.rp_filter = 1</div><div class="line"># net.ipv4.conf.lo.rp_filter = 1</div><div class="line"># net.ipv4.conf.eth0.rp_filter = 1</div><div class="line"></div><div class="line"></div><div class="line"># Disables IP source routing</div><div class="line"># Default should work for all interfaces net.ipv4.conf.default.accept_source_route = 0</div><div class="line"># net.ipv4.conf.all.accept_source_route = 0</div><div class="line"># net.ipv4.conf.lo.accept_source_route = 0</div><div class="line"># net.ipv4.conf.eth0.accept_source_route = 0</div><div class="line"></div><div class="line"></div><div class="line"># Controls the System Request debugging functionality of the kernel</div><div class="line">kernel.sysrq = 0</div><div class="line"></div><div class="line"></div><div class="line"># Controls whether core dumps will append the PID to the core filename</div><div class="line"># Useful for debugging multi-threaded applications</div><div class="line">kernel.core_uses_pid = 1</div><div class="line"></div><div class="line"></div><div class="line"># Increase maximum amount of memory allocated to shm</div><div class="line"># Only uncomment if needed</div><div class="line"># kernel.shmmax = 67108864</div><div class="line"></div><div class="line"></div><div class="line"># Disable ICMP Redirect Acceptance</div><div class="line"># Default should work for all interfaces</div><div class="line">net.ipv4.conf.default.accept_redirects = 0</div><div class="line"># net.ipv4.conf.all.accept_redirects = 0</div><div class="line"># net.ipv4.conf.lo.accept_redirects = 0</div><div class="line"># net.ipv4.conf.eth0.accept_redirects = 0</div><div class="line"></div><div class="line"></div><div class="line"># enable Log Spoofed Packets, Source Routed Packets, Redirect Packets</div><div class="line"># Default should work for all interfaces</div><div class="line">net.ipv4.conf.default.log_martians = 1</div><div class="line">#net.ipv4.conf.all.log_martians = 1</div><div class="line"># net.ipv4.conf.lo.log_martians = 1</div><div class="line"># net.ipv4.conf.eth0.log_martians = 1</div><div class="line"></div><div class="line"></div><div class="line"># Decrease the time default value for tcp_fin_timeout connection</div><div class="line">net.ipv4.tcp_fin_timeout = 25</div><div class="line"></div><div class="line"></div><div class="line"># Decrease the time default value for tcp_keepalive_time connection</div><div class="line">net.ipv4.tcp_keepalive_time = 1200</div><div class="line"></div><div class="line"></div><div class="line"># Turn on the tcp_window_scaling</div><div class="line">net.ipv4.tcp_window_scaling = 1</div><div class="line"></div><div class="line"></div><div class="line"># Turn on the tcp_sack</div><div class="line">net.ipv4.tcp_sack = 1</div><div class="line"></div><div class="line"></div><div class="line"># tcp_fack should be on because of sack</div><div class="line">net.ipv4.tcp_fack = 1</div><div class="line"></div><div class="line"></div><div class="line"># Turn on the tcp_timestamps</div><div class="line">net.ipv4.tcp_timestamps = 1</div><div class="line"></div><div class="line"></div><div class="line"># Enable TCP SYN Cookie Protection</div><div class="line">net.ipv4.tcp_syncookies = 1</div><div class="line"></div><div class="line"></div><div class="line"># Enable ignoring broadcasts request</div><div class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</div><div class="line"></div><div class="line"></div><div class="line"># Disable ping requests</div><div class="line">net.ipv4.icmp_echo_ignore_all = 1</div><div class="line"></div><div class="line"></div><div class="line"># Enable bad error message Protection</div><div class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</div><div class="line"></div><div class="line"></div><div class="line"># make more local ports available</div><div class="line"># net.ipv4.ip_local_port_range = 1024 65000</div><div class="line"></div><div class="line"></div><div class="line"># set TCP Re-Ordering value in kernel to 5</div><div class="line">net.ipv4.tcp_reordering = 5</div><div class="line"></div><div class="line"></div><div class="line"># Lower syn retry rates</div><div class="line">net.ipv4.tcp_synack_retries = 2</div><div class="line">net.ipv4.tcp_syn_retries = 3</div><div class="line"></div><div class="line"></div><div class="line"># Set Max SYN Backlog to 2048</div><div class="line">net.ipv4.tcp_max_syn_backlog = 2048</div><div class="line"></div><div class="line"></div><div class="line"># Various Settings</div><div class="line">net.core.netdev_max_backlog = 1024</div><div class="line"></div><div class="line"></div><div class="line"># Increase the maximum number of skb-heads to be cached</div><div class="line">net.core.hot_list_length = 256</div><div class="line"></div><div class="line"></div><div class="line"># Increase the tcp-time-wait buckets pool size</div><div class="line">net.ipv4.tcp_max_tw_buckets = 360000</div><div class="line"></div><div class="line"></div><div class="line"># This will increase the amount of memory available for socket input/output queues</div><div class="line">net.core.rmem_default = 65535</div><div class="line">net.core.rmem_max = 8388608</div><div class="line">net.ipv4.tcp_rmem = 4096 87380 8388608 net.core.wmem_default = 65535</div><div class="line">net.core.wmem_max = 8388608</div><div class="line">net.ipv4.tcp_wmem = 4096 65535 8388608</div><div class="line">net.ipv4.tcp_mem = 8388608 8388608 8388608</div><div class="line">net.core.optmem_max = 40960</div></pre></td></tr></table></figure>
<p>重新加载内核参数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-p, read values from file</span></div><div class="line">sysctl -p</div><div class="line"></div><div class="line"><span class="comment">#-a, display all variables</span></div><div class="line">sysctl -a</div></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h1 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h1><p>大多Unix-Like系统，都提供了限制每个进程和每个基本用户使用线程，文件和网络连接等系统资源的一些方法。</p>
<p>假设有这样一种情况，当一台Linux主机上同时登陆了10人，在资源无限制的情况下，这10个用户同时打开了500个文件。假设每个文件的大小有10M，这是系统的内存资源就会收到巨大挑战。<br>但是任何一台主机的资源都不可能是无限的。所以，资源的合理配置和分配，不仅仅是保证系统可用性的必要条件，也与系统上软件运行的性能有着密不可分的联系。</p>
<p><code>ulimit</code>是指每个user使用各种资源的限制值。<code>ulimit</code> 命令用来限制系统用户对shell资源的访问，它是一种简单并且有效的实现资源限制的方式。</p>
<ul>
<li><code>ulimit</code>的设置值是 per-process的，也就是说，每个进程都有自己的limits值；</li>
<li>使用<code>ulimit</code>进行修改，是立即生效的；</li>
<li><code>ulimit</code>只影响shell进程及其子进程，用户登出后失效；</li>
<li>修改<code>ulimit</code>设置之后，要重启程序修改值才会有效。可通过<code>/proc</code>文件系统查看运行进程当前的限制值;</li>
<li>使用<code>ulimit</code>对系统限制的改变在系统重启后都会恢复到默认值;</li>
<li>可以在<code>profile</code>中加入<code>ulimit</code>的设置，便能做到永久生效。</li>
</ul>
<p><br></p>
<p><strong>ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：</strong></p>
<ul>
<li>所创建的内核文件的大小；</li>
<li>进程数据块的大小；</li>
<li>Shell进程创建文件的大小；</li>
<li>内存锁住的大小；</li>
<li>常驻内存集的大小；</li>
<li>打开文件描述符的数量；</li>
<li>分配堆栈的最大大小；</li>
<li>CPU时间；</li>
<li>单个用户的最大线程数；</li>
<li>Shell进程所能使用的最大虚拟内存；</li>
<li>它支持硬资源(hard)和软资源(soft)的限制。</li>
</ul>
<p><br></p>
<p><strong>sort和hard</strong></p>
<ul>
<li>hard：是指用户在任何时候都可以活动的进程的最大数量，这是上限。没有任何non-root进程能够增加hard ulimit；</li>
<li>soft：是对会话或进程实际执行的限制，但任何进程都可以将其增加到hard ulimit的最大值。</li>
</ul>
<p><br></p>
<h2 id="设置ulimit"><a href="#设置ulimit" class="headerlink" title="设置ulimit"></a>设置ulimit</h2><p>可以在以下位置进行ulimit的设置：</p>
<ul>
<li><code>/etc/profile</code>，所有用户有效，永久生效；</li>
<li><code>~/.bash_profile</code>,当前用户有效，永久生效；</li>
<li>直接在控制台修改，当前用户有效，临时生效；</li>
</ul>
<p><br></p>
<p>永久生效：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div><div class="line"></div><div class="line">vim ~/.bash_profile</div></pre></td></tr></table></figure>
<p>临时生效：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">ulimit</span> -a</div><div class="line"></div><div class="line"></div><div class="line">core file size          (blocks, -c) 0</div><div class="line">data seg size           (kbytes, -d) unlimited</div><div class="line">scheduling priority             (-e) 0</div><div class="line">file size               (blocks, -f) unlimited</div><div class="line">pending signals                 (-i) 7170</div><div class="line">max locked memory       (kbytes, -l) 64</div><div class="line">max memory size         (kbytes, -m) unlimited</div><div class="line">open files                      (-n) 1024</div><div class="line">pipe size            (512 bytes, -p) 8</div><div class="line">POSIX message queues     (bytes, -q) 819200</div><div class="line">real-time priority              (-r) 0</div><div class="line">stack size              (kbytes, -s) 8192</div><div class="line">cpu time               (seconds, -t) unlimited</div><div class="line">max user processes              (-u) 7170</div><div class="line">virtual memory          (kbytes, -v) unlimited</div><div class="line">file locks                      (-x) unlimited</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#修改限定值</span></div><div class="line"><span class="built_in">ulimit</span> -n 201400</div><div class="line"><span class="built_in">ulimit</span> -t ulimited</div></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h1 id="limits-conf"><a href="#limits-conf" class="headerlink" title="limits.conf"></a>limits.conf</h1><p><code>limits.conf</code> - configuration file for the pam_limits module</p>
<p><code>limits.conf</code>是<code>pam_limits.so</code>的配置文件，Linux PAM(Pluggable Authentication Modules，插入式认证模块)。突破系统默认限制，对系统资源有一定保护作用。</p>
<p><strong>pam_limits模块</strong>对用户的会话进行资源限制，然后<code>/etc/pam.d/</code>下的应用程序调用<code>pam_***.so</code>模块。</p>
<p><br></p>
<p><strong><code>limits.conf</code>是针对用户，而<code>sysctl.conf</code>是针对整个系统参数配置。</strong></p>
<ul>
<li>一个shell的初始limits就是由pam_limits设定的，用户登录后，pam_limits会给用户的shell设定在limits.conf定义的值；</li>
<li>pam_limits的设定值也是per-process；</li>
<li>pam_limits的设置是 永久生效的。</li>
</ul>
<p><br></p>
<p>配置limits.conf：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/security/limits.conf</div></pre></td></tr></table></figure>
<p><br></p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#&lt;domain&gt;      &lt;type&gt;  &lt;item&gt;         &lt;value&gt;</div><div class="line"></div><div class="line">#*               soft    core            0</div><div class="line">#*               hard    rss             10000</div><div class="line">#@student        hard    nproc           20</div><div class="line">#@faculty        soft    nproc           20</div><div class="line">#@faculty        hard    nproc           50</div><div class="line">#ftp             hard    nproc           0</div><div class="line">#@student        -       maxlogins       4</div></pre></td></tr></table></figure>
<p>domain：</p>
<ul>
<li>username</li>
<li>@groupname</li>
</ul>
<p>type：</p>
<ul>
<li>soft</li>
<li>hard</li>
<li>-</li>
</ul>
<p>item：</p>
<ul>
<li>core，限制内核文件的大小</li>
<li>date，最大数据大小</li>
<li>fsize，最大文件大小</li>
<li>memlock，最大锁定内存地址空间</li>
<li>nofile，打开文件的最大数目</li>
<li>rss，最大持久设置大小</li>
<li>stack，最大栈大小</li>
<li>cpu，以分钟为单位的最多CPU时间</li>
<li>nproc，进程的最大数目</li>
<li>as，地址空间限制</li>
<li>maxlogins，此用户允许登录的最大数目</li>
</ul>
<p>value：</p>
<ul>
<li>item值的大小</li>
</ul>
<p><br></p>
<hr>
<p><br></p>
<h1 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h1><h2 id="什么是-proc文件系统"><a href="#什么是-proc文件系统" class="headerlink" title="什么是/proc文件系统"></a>什么是/proc文件系统</h2><p>Linux内核提供了一种通过<code>/proc</code>文件系统，在运行时访问内核内部数据结构，改变内核设置的机制。</p>
<p>proc文件系统是一个伪文件系统，它只存在内存当中，不占用外部空间。它以文件系统的方式为访问系统内核数据的操作提供接口。</p>
<p>对<code>/proc</code>中内核文件的修改，针对的是<strong>整个系统</strong>的<strong>内核参数</strong>，修改后<strong>立即生效</strong>，但修改是 <strong>临时的</strong>，重启后失效。</p>
<p><br></p>
<h2 id="proc与sysctl-conf的对应关系"><a href="#proc与sysctl-conf的对应关系" class="headerlink" title="/proc与sysctl.conf的对应关系"></a>/proc与sysctl.conf的对应关系</h2><p>修改<code>/proc</code>文件系统中的参数是临时的，但修改<code>sysctl.conf</code>的参数确是永久有效的。</p>
<p>配置文件<code>sysctl.conf</code>变量在<code>/proc/sys</code>下，其对应关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#将文件名的 . 变为 /</div><div class="line"></div><div class="line">#/proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line">#net.ipv4.icmp_echo_ignore_all</div><div class="line"></div><div class="line">echo 0 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line"></div><div class="line">vim /etc/sysctl.conf</div><div class="line">net.ipv4.icmp_echo_ignore_all = 0</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="proc文件系统几个常用的内核文件"><a href="#proc文件系统几个常用的内核文件" class="headerlink" title="/proc文件系统几个常用的内核文件"></a>/proc文件系统几个常用的内核文件</h2><ul>
<li>/proc/meminfo    #内存信息</li>
<li>/proc/cpuinfo    #CPU信息</li>
<li>/proc/sys/fs/file-max    #文件打开数</li>
<li>/proc/sys/fs/file-nr    #整个系统目前使用的文件句柄数量</li>
</ul>
<p><br></p>
<h2 id="proc文件系统中文件的权限"><a href="#proc文件系统中文件的权限" class="headerlink" title="/proc文件系统中文件的权限"></a>/proc文件系统中文件的权限</h2><p>proc中的每个文件都有一组分配给它的非常特殊的文件许可权，并且每个文件属于特定的用户标识。</p>
<ul>
<li>只读：任何用户都不能更改该文件，它用于表示系统信息</li>
<li>root写</li>
<li>root读</li>
</ul>
<p><br></p>
<h2 id="对-proc进行读写"><a href="#对-proc进行读写" class="headerlink" title="对/proc进行读写"></a>对/proc进行读写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cat /proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line">#0</div><div class="line"></div><div class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line"></div><div class="line">#当然,也可是用sysctl来配置</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="proc内核文件详解"><a href="#proc内核文件详解" class="headerlink" title="/proc内核文件详解"></a>/proc内核文件详解</h2><ul>
<li>/proc/buddyinfo 每个内存区中的每个order有多少块可用，和内存碎片问题有关</li>
<li>/proc/cmdline 启动时传递给kernel的参数信息</li>
<li>/proc/cpuinfo cpu的信息</li>
<li>/proc/crypto 内核使用的所有已安装的加密密码及细节</li>
<li>/proc/devices 已经加载的设备并分类</li>
<li>/proc/dma 已注册使用的ISA DMA频道列表</li>
<li>/proc/execdomains Linux内核当前支持的execution domains</li>
<li>/proc/fb 帧缓冲设备列表，包括数量和控制它的驱动</li>
<li>/proc/filesystems 内核当前支持的文件系统类型</li>
<li>/proc/interrupts x86架构中的每个IRQ中断数</li>
<li>/proc/iomem 每个物理设备当前在系统内存中的映射</li>
<li>/proc/ioports 一个设备的输入输出所使用的注册端口范围</li>
<li>/proc/kcore 代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于RAM大小加上4kb</li>
<li>/proc/kmsg 记录内核生成的信息，可以通过/sbin/klogd或/bin/dmesg来处理</li>
<li>/proc/loadavg 根据过去一段时间内CPU和IO的状态得出的负载状态，与uptime命令有关</li>
<li>/proc/locks 内核锁住的文件列表</li>
<li>/proc/mdstat 多硬盘，RAID配置信息(md=multiple disks)</li>
<li>/proc/meminfo RAM使用的相关信息</li>
<li>/proc/misc 其他的主要设备(设备号为10)上注册的驱动</li>
<li>/proc/modules 所有加载到内核的模块列表</li>
<li>/proc/mounts 系统中使用的所有挂载</li>
<li>/proc/mtrr 系统使用的Memory Type Range Registers (MTRRs)</li>
<li>/proc/partitions 分区中的块分配信息</li>
<li>/proc/pci 系统中的PCI设备列表</li>
<li>/proc/slabinfo 系统中所有活动的 slab 缓存信息</li>
<li>/proc/stat 所有的CPU活动信息</li>
<li>/proc/sysrq-trigger 使用echo命令来写这个文件的时候，远程root用户可以执行大多数的系统请求关键命令，就好- 像在本地终端执行一样。要写入这个文件，需要把/proc/sys/kernel/sysrq不能设置为0。这个文件对root也是不可- 读的</li>
<li>/proc/uptime 系统已经运行了多久</li>
<li>/proc/swaps 交换空间的使用情况</li>
<li>/proc/version Linux内核版本和gcc版本</li>
<li>/proc/bus 系统总线(Bus)信息，例如pci/usb等</li>
<li>/proc/driver 驱动信息</li>
<li>/proc/fs 文件系统信息</li>
<li>/proc/ide ide设备信息</li>
<li>/proc/irq 中断请求设备信息</li>
<li>/proc/net 网卡设备信息</li>
<li>/proc/scsi scsi设备信息</li>
<li>/proc/tty tty设备信息</li>
<li>/proc/net/dev 显示网络适配器及统计信息</li>
<li>/proc/vmstat 虚拟内存统计信息</li>
<li>/proc/vmcore 内核panic时的内存映像</li>
<li>/proc/diskstats 取得磁盘信息</li>
<li>/proc/schedstat kernel调度器的统计信息</li>
<li>/proc/zoneinfo 显示内存空间的统计信息，对分析虚拟内存行为很有用</li>
</ul>
<p><br></p>
<p><strong>以下是/proc目录中进程N的信息：</strong></p>
<ul>
<li>/proc/N pid为N的进程信息</li>
<li>/proc/N/cmdline 进程启动命令</li>
<li>/proc/N/cwd 链接到进程当前工作目录</li>
<li>/proc/N/environ 进程环境变量列表</li>
<li>/proc/N/exe 链接到进程的执行命令文件</li>
<li>/proc/N/fd 包含进程相关的所有的文件描述符</li>
<li>/proc/N/maps 与进程相关的内存映射信息</li>
<li>/proc/N/mem 指代进程持有的内存，不可读</li>
<li>/proc/N/root 链接到进程的根目录</li>
<li>/proc/N/stat 进程的状态</li>
<li>/proc/N/statm 进程使用的内存的状态</li>
<li>/proc/N/status 进程状态信息，比stat/statm更具可读性</li>
<li>/proc/self 链接到当前正在运行的进程</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://man.linuxde.net/sysctl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;sysctl命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://man.linuxde.net/ulimit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ulimit命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/20a2dd80cbad&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ulimit、limits.conf、sysctl和proc文件系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/9a8e383b5b49&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;sysctl.conf学习和调优&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="系统优化" scheme="https://zhang21.github.io/tags/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>开源许可协议</title>
    <link href="https://zhang21.github.io/2018/01/09/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
    <id>https://zhang21.github.io/2018/01/09/开源许可协议/</id>
    <published>2018-01-09T03:50:27.000Z</published>
    <updated>2018-01-09T05:55:22.617Z</updated>
    
    <content type="html"><![CDATA[<p>当你为你的产品签发许可，你就是在出让自己的权利。不过，你仍拥有版权和专利（如果申请了专利）。许可的目的，是向使用你产品的人提供一定的权利。</p>
<p>不管产品是免费分发，还是出售，指定一份许可协议都非常有用。否则，对于免费，你相当于放弃了自己的所有权利，任何人都没有义务表明你的原始作者身份。对于出售，你将不得不花费比开发更多的精力用来处理授权问题。</p>
<p>而开源许可协议是这些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的身份，使你至少获得认可。开源许可协议还可以阻止其它人将某个产品据为己有。</p>
<p><br><br><a id="more"></a></p>
<p><img src="/images/opensourcelicence.png" alt="开源许可协议区别"></p>
<p><br></p>
<p><img src="/images/opensourcelicence.jpg" alt="开源许可协议区别"></p>
<p><br></p>
<hr>
<p><br></p>
<h1 id="几大开源许可协议"><a href="#几大开源许可协议" class="headerlink" title="几大开源许可协议"></a>几大开源许可协议</h1><p><br><br><br></p>
<h2 id="GNU-Project"><a href="#GNU-Project" class="headerlink" title="GNU Project"></a>GNU Project</h2><ul>
<li>GNU是“GNU’s Not Unix”的递归缩写，发音为 /‘gnu:’/；</li>
<li>GNU Project，是一个由自由软件集体协作项目，它的目标是创建一套完全自由的操作系统，称为GNU；</li>
<li>GNU是一个自由操作系统，其内容软件完全以 GPL 方式发布，它的设计类似于Unix，但它不包含具有著作权的Unix代码。</li>
</ul>
<p><br></p>
<h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GNU(General Public Licence)，GNU通用许可协议(简称GPL)是广泛使用的免费软件许可证，也称为 copyleft，与copyright相对应。<br>GPL保证了所有开发者的权利，同时为使用者提供了足够的复制、分发、修改的权利。</p>
<p>需要注意的是，分发的时候，需要明确提供源代码和二进制文件。</p>
<ul>
<li><strong>可自由复制：</strong> 你可以将软件复制到你的电脑或任何地方，复制份数没有限制；</li>
<li><strong>可自由分发：</strong> 可下载后拷贝分发；</li>
<li><strong>可以用来盈利：</strong> 你可以在分发软件的时候收费，但必须在收费前向你的客户提供该软件的 GNU GPL许可协议，以便让他们知道，他们可以从别的渠道免费得到这份软件以及你收费的理由；</li>
<li><strong>可自由修改：</strong> 你过你想添加或删除某个功能，没问题。如果你想在别的项目中使用部分代码，也没问题，唯一要求是使用了这段代码的项目也必须使用 GPL协议。</li>
</ul>
<p><br></p>
<h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>GNU还有另外一种协议，叫做LGPL（Lesser General Public License），它对产品所保留的权利比GPL少。<br>总的来说，LGPL适合那些用于非GPL或非开源产品的开源类库或框架。因为GPL要求，使用了GPL代码的产品也必须使用GPL协议，开发者不允许将GPL代码用于商业产品。LGPL绕过了这一限制。</p>
<p>GPL和LGPL都属于GNU计划里面的许可证。</p>
<p><br></p>
<hr>
<p><br></p>
<h2 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h2><p>伯克利软件套件（Berkeley Software Distribution，缩写BSD），也被称为伯克利Unix，是一个操作系统的名称，衍生自Unix，也被用来代表一整套软件发行版。</p>
<p>BSD许可证（Berkeley Software Distribution License），是自由软件中使用广泛的许可证。BSD软件就是遵照这个许可证来发布，该许可证也因此而得名。</p>
<p>BSD在软件分发方面的限制比别的开源协议要少，且和GPL兼容，并为开源组织所认可。</p>
<p><br></p>
<hr>
<p><br></p>
<h2 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h2><p>MIT（Massachusetts Institute of Technology），麻省理工学院。<br>MIT许可协议（The MIT License）是许多软件授权条款中，被广泛使用的其中一种。与其他常见的软件许可协议相比，MIT是相对宽松的软件许可协议，除了必须包含许可声明外，再无任何限制。</p>
<p>MIT许可协议核心条款：</p>
<ul>
<li>该软件及其相关文档对所有人免费，可以任意处置，包括使用、复制、修改、合并、发表、分发、再授权或销售；</li>
<li>唯一的限制，软件中必须包含上述版权和许可证。</li>
</ul>
<p><br></p>
<hr>
<p><br></p>
<h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>Apache许可证（Apache License），是一个由Apache软件基金会发布的自由软件许可证。Apache许可证要求被授权者保留版权和放弃权利的声明，但它不是一个反版权的许可证。兼容与GPL。</p>
<p>除了为用户提供版权许可之外，还有专利许可，对于那些涉及专利内容的开发者而言，该协议最适合。</p>
<ul>
<li>永久权利：一旦被授权，永久拥有；</li>
<li>全球范围的权利：在一个国家获得授权，适用于所有国家；</li>
<li>授权免费，且无版税：前后期均无任何费用；</li>
<li>授权不可撤销：一旦获得授权，没有任何人可以取消。</li>
</ul>
<p>分发代码方面，要在声明中对参与开发的人给予认可并包含一份许可协议原文。</p>
<p><br></p>
<hr>
<p><br></p>
<h2 id="MPL"><a href="#MPL" class="headerlink" title="MPL"></a>MPL</h2><p>MPL是The Mozilla[mɔzilə] Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。<br>MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。</p>
<p>同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA 认定的开源软件许可证）。</p>
<p>MPL几个特点：</p>
<ul>
<li>MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL 许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口；</li>
<li>MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序；</li>
<li>对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利；</li>
<li>对源代码的定义，MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。</li>
</ul>
<p><br></p>
<hr>
<p><br></p>
<h2 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h2><p>知识共享许可协议(Creative Commons License，简称CC)，并非严格意义上的开源许可，是一种公共版权许可协议。它主要用于设计，其允许分发受版权保护的作品。</p>
<p>CC协议主要包含4种基本形式：</p>
<ul>
<li>署名权：必须为原始作业署名，然后才可以修改、分发、复制；</li>
<li>保持一致：作品同样可以在CC协议的基础上修改、分发、复制；</li>
<li>非商业：不能用于商业用途；</li>
<li>不能衍生新作品：你可以复制、分发、但不能修改，也不能以此为基础创作自己的作品。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你为你的产品签发许可，你就是在出让自己的权利。不过，你仍拥有版权和专利（如果申请了专利）。许可的目的，是向使用你产品的人提供一定的权利。&lt;/p&gt;
&lt;p&gt;不管产品是免费分发，还是出售，指定一份许可协议都非常有用。否则，对于免费，你相当于放弃了自己的所有权利，任何人都没有义务表明你的原始作者身份。对于出售，你将不得不花费比开发更多的精力用来处理授权问题。&lt;/p&gt;
&lt;p&gt;而开源许可协议是这些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的身份，使你至少获得认可。开源许可协议还可以阻止其它人将某个产品据为己有。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="开源许可协议" scheme="https://zhang21.github.io/tags/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Yum源</title>
    <link href="https://zhang21.github.io/2018/01/09/Yum%E6%BA%90/"/>
    <id>https://zhang21.github.io/2018/01/09/Yum源/</id>
    <published>2018-01-09T03:46:21.000Z</published>
    <updated>2018-01-09T04:48:12.418Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p>
<ul>
<li><a href="http://blog.csdn.net/leshami/article/details/78133716" target="_blank" rel="external">CentOS 7下配置本地yum源及yum客户端</a></li>
<li><a href="http://blog.csdn.net/conling_/article/details/70399694" target="_blank" rel="external">Centos7 配置本地源+阿里yum源/epel-yum+修改优先级</a></li>
<li><a href="http://blog.csdn.net/kingfox/article/details/51233153" target="_blank" rel="external">调整CentOS 7中yum仓库的优先级</a></li>
<li><a href="https://segmentfault.com/a/1190000000375848" target="_blank" rel="external">国内开源站点</a></li>
</ul>
<a id="more"></a>
<p><br></p>
<hr>
<p><br></p>
<h1 id="国内开源镜像站点"><a href="#国内开源镜像站点" class="headerlink" title="国内开源镜像站点"></a>国内开源镜像站点</h1><ul>
<li>网易开源镜像站：<a href="http://mirrors.163.com/" target="_blank" rel="external">http://mirrors.163.com/</a></li>
<li>阿里云开源镜像站：<a href="http://mirrors.aliyun.com" target="_blank" rel="external">http://mirrors.aliyun.com</a></li>
<li>清华大学开源镜像站：<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/</a></li>
<li>浙江大学开源镜像站： <a href="http://mirrors.zju.edu.cn/" target="_blank" rel="external">http://mirrors.zju.edu.cn/</a></li>
<li>中国科技大学开源镜像站：<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="external">http://mirrors.ustc.edu.cn/</a></li>
</ul>
<p><br></p>
<hr>
<p><br></p>
<h1 id="CentOS自带源"><a href="#CentOS自带源" class="headerlink" title="CentOS自带源"></a>CentOS自带源</h1><p>rpm包管理方式，对于安装、升级、卸载却难以处理包之间的依赖关系。而yum作为一个rpm包前端管理工具，可以自动处理依赖性，并支持在线现在、安装、升级、卸载rpm软件包。</p>
<p>CentOS默认自带<code>CentOS-Base.repo</code>源，但官方源在国外，连接速度令人心痛。并且有很多软件在默认源里面是找不到的。</p>
<h2 id="配置网络yun源"><a href="#配置网络yun源" class="headerlink" title="配置网络yun源"></a>配置网络yun源</h2><p><strong>配置aliyun.repo：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#先备份默认源</div><div class="line">mv CentOS-Base.repo&#123;,.bak&#125;</div><div class="line"></div><div class="line">#下载阿里云源替换默认源</div><div class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</div><div class="line"></div><div class="line">yum clean all</div><div class="line">yum makecache    #重构yum缓存</div><div class="line"></div><div class="line">yum repolist    #查看yum仓库</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="配置本地yum源"><a href="#配置本地yum源" class="headerlink" title="配置本地yum源"></a>配置本地yum源</h2><p><strong>配置本地yum源，考虑到优先使用本地安装包，所以会涉及到一个优先级的概念。</strong></p>
<p>安装完毕后，就可以在yum源中添加一个优先级<code>priority</code>。</p>
<p><strong>安装yum优先级插件：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">yum install -y yum-plugin-priorities</div><div class="line"></div><div class="line">#检查安装完成后配置</div><div class="line">vim /etc/yum/pluginconf.d/priorities.conf</div><div class="line"></div><div class="line">enable=1</div><div class="line">#enable=0</div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>创建本地yum源：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">mv /etc/yum.repos.d/CentOS-Base.repo&#123;,.bak&#125;</div><div class="line"></div><div class="line">vim /etc/yum.repos.d/CentOS-Local.repo</div><div class="line"></div><div class="line">[base-Local]</div><div class="line">name=Centos- Local</div><div class="line">baseurl=file:///mnt/xxx</div><div class="line">gpgcheck=0</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line">priority=1    #优先级为1</div><div class="line"></div><div class="line">[updates-Local]</div><div class="line">name=CentOS- Local</div><div class="line">gpgcheck=0</div><div class="line">baseurl=file:///dir/path/</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line">priority=1</div><div class="line"></div><div class="line">······</div><div class="line">#具体可参考CentOS-Base.repo</div><div class="line">#可将aliyun源优先级写成2</div><div class="line"></div><div class="line">yum clean all</div><div class="line">yum makecache</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="配置ftp方式源"><a href="#配置ftp方式源" class="headerlink" title="配置ftp方式源"></a>配置ftp方式源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">vim /etc/yum.repos.d/ftp.repo</div><div class="line"></div><div class="line">[ftp-media]</div><div class="line">name=name=CentOS-$releasever - media</div><div class="line">baseurl=ftp://ip</div><div class="line">gpgcheck=0</div><div class="line">enable=1</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line"></div><div class="line">yum clean all</div><div class="line">yum makecache</div></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h1 id="其他常见YUM源"><a href="#其他常见YUM源" class="headerlink" title="其他常见YUM源"></a>其他常见YUM源</h1><p>官方的默认<code>yum源</code>提供的软件包往往是很滞后的，(可能为了服务器版本的稳定性和安全性)。并且官方默认源提供的RPM包也不够丰富。</p>
<p><br></p>
<h2 id="EPEL源"><a href="#EPEL源" class="headerlink" title="EPEL源"></a>EPEL源</h2><p>EPEL的全称叫 <code>Extra Packages for Enterprise Linux</code> 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。</p>
<p><code>EPEL源</code>为服务器提供了大量的rpm包(这些包可能有很多在默认源中没有)，并且绝大多数rpm包比官方默认源版本要新。</p>
<p><strong>添加epel源：</strong><br>epel下载地址：<a href="http://download.fedora.redhat.com/pub/epel/" target="_blank" rel="external">http://download.fedora.redhat.com/pub/epel/</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpm -vih http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</div><div class="line"></div><div class="line"><span class="comment">#yum install -y epel-release</span></div></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="remi源"><a href="#remi源" class="headerlink" title="remi源"></a>remi源</h2><p>Remi源大家或许很少听说，不过Remi源GoFace强烈推荐，尤其对于不想编译最新版的linux使用者，因为Remi源中的软件几乎都是最新稳定版。<br>或许您会怀疑稳定不？<br>放心，这些都是Linux骨灰级的玩家编译好放进源里的，他们对于系统环境和软件编译参数的熟悉程度毋庸置疑。</p>
<p><strong>添加remi源：</strong><br>Remi下载地址：<a href="http://rpms.famillecollet.com" target="_blank" rel="external">http://rpms.famillecollet.com</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</div><div class="line"></div><div class="line"><span class="comment">#yum install -y  http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</span></div></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="RPMForge源"><a href="#RPMForge源" class="headerlink" title="RPMForge源"></a>RPMForge源</h2><p><code>RPMForge</code>是<code>CentOS</code>系统下的软件仓库，拥有4000多种的软件包, 被CentOS社区认为是最安全也是最稳定的一个软件仓库。</p>
<p><strong>添加RPMForge源：</strong><br>RPMForge下载地址：<a href="http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/" target="_blank" rel="external">http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/</a><br>GitHub:<a href="https://github.com/repoforge" target="_blank" rel="external">https://github.com/repoforge</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpm -ivh http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm</div><div class="line"></div><div class="line">#yum localinstall --nogpgcheckhttp://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/leshami/article/details/78133716&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CentOS 7下配置本地yum源及yum客户端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/conling_/article/details/70399694&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Centos7 配置本地源+阿里yum源/epel-yum+修改优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/kingfox/article/details/51233153&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;调整CentOS 7中yum仓库的优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000375848&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;国内开源站点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Yum" scheme="https://zhang21.github.io/tags/Yum/"/>
    
  </entry>
  
  <entry>
    <title>写给2017</title>
    <link href="https://zhang21.github.io/2018/01/01/%E5%86%99%E7%BB%992017/"/>
    <id>https://zhang21.github.io/2018/01/01/写给2017/</id>
    <published>2018-01-01T02:25:20.000Z</published>
    <updated>2018-01-09T05:42:35.492Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2018.jpg" alt="2018"></p>
<p><br><br><a id="more"></a></p>
<h1 id="2017大事件"><a href="#2017大事件" class="headerlink" title="2017大事件"></a>2017大事件</h1><ul>
<li>Feb.27.2017，开始工作；</li>
<li>May.27.2017，工作转正；</li>
<li>Jun.25.2017，大学毕业；</li>
<li>Aug.27.2017，工作半年；</li>
<li>Aug.30.2017，搭建博客。</li>
</ul>
<p>记得大四下期的时候，在学校实在是想出来工作，以为这样就可以有工资有点钱可以实现财务自由。Naive x3!</p>
<p>记得刚去面试的时候，公司的HR问我期待的薪资是多少。我这个老实人也不敢往高了说，以为能解决温饱就不错。这就导致后面日子过得紧巴巴，生活基本上处于没钱不敢消费不敢出去的惨状。Naive x3!</p>
<p>记得那天是星期四，从学校收拾了一箱子的衣物加上自己的笔记本就来了成都。还要感谢<strong>强</strong>对我的帮助，在他那借宿了两天。这两天跑到公司附近找房子，这打个电话，那去看看…结果看了看自己兜里不到三千，再看看房租，还是算了吧！后来由于周一就要开始去公司报道了，实在没办法，硬着头皮找了一个750的单间。我现在觉得，人在生活面前真的没有办法。借用张主任的一句话——“是生活，生活强奸了所有人。”一个套三的屋子，硬是被房主改造成了七间房，住了11人。我想各位住户都迫于无奈吧，有谁想和别人挤在一起了，况且还要忍受上厕所的艰难时光。<br>还是说说我住的那间房屋吧。是客厅使用木板隔得房间，手指随便敲几下都铛铛作响，况且隔壁还住了一对情侣。一张床，一个烂小衣柜，一张摆放电脑的桌子。客厅的后面有一个阳台，所以就会有一个大窗户间隔阳台。然而这个阳台是和隔壁公用的，也就是说，这个大窗户是可以互通的。哎！阳台风大，还好我只住到了夏天。<br>五月二十号，和我强一起搬到了中和。也是没有做好十足打算，说搬就搬了。虽说住宿条件好了一些，可这面修路是真的堵，公家车是真的挤，真的是挤得怀疑人生的那种，还是走路吧。由于搬过来中和，房租和其他开支多了一些，刚开始没什么钱的时候，自己带饭去公司。我都佩服自己，那么挤得车上还能坚持带饭几个月，看来还是穷吧。冬天到了，太冷了就没有带饭到公司了。但公司楼下吃饭真的好贵，吃不起吃不起。由于住宿条件好了一些，晚上回来可以自己做饭，还是不错。并且晚上基本有两个小时干干工作之外的事情，看看小说、看看电视、发发呆什么也挺好的！</p>
<p>记得才开始工作的时候，好像每天都很闲，没有事做。心里担忧的不行，这样怎么有提升呢？每天都急躁不安，这不会那不会，又腼腆害羞…后来慢慢理解，任何事情都不能操之过急，不能带着情绪上班。不喜欢某个同事也不能表现出来，更不能带到工作上。工作是工作，生活是生活，一定要分开。被骂也没有办法，骂吧，你骂高兴。任何人都不会听你的理由，理由对于别人来说只是你没有完成的狡辩。踏踏实实上班，做好自己的事情才是正解！千万不要好为人师，人都是有嫉妒心得，不要太招摇！也不要羡慕别人工作轻松之类，那是人家的工作，和你没有半毛钱关系。上班好好上班，不要搞东搞西。我个人比较看重效率，怀着为了加班而加班的目的真的没有必要。那时由于住单间，条件差，愿意在公司多呆一会，多学习知识。越到后面，觉得自己越得努力学习新知识，需要了解的知识就在那，就等我把它们一个个打上勾，撸起袖子加油干。</p>
<p><br></p>
<p><strong>自我批评:</strong></p>
<ul>
<li>心胸不够宽广，容易嫉妒别人；</li>
<li>害羞爱面子，拉不下面子做事情；</li>
<li>由于自卑心理导致的不敢说不敢争。</li>
</ul>
<p>以前我以为自己是讨厌某种方式、讨厌别人炫耀、讨厌别人秀恩爱，现在才知道是由于自己没有，就用自己的不屑和厌恶来突出自己，让自己心安理得。说白了还不是自己嫉妒人家，嫉妒人家比我好，有女票。这点是真的要改，一定要改。千万别用别人的缺点来突出自己，这很SB，切记切记。如同小波所说：“人的一切痛苦，本质都是对于自己无能的愤怒。”</p>
<p>在学校总幻想自己能成为英雄，总想做一番事业，像历史上的英雄那般。不屑考个老师公务员职位，以为一辈子就那样，混吃等死的咸鱼。其实其它工作不也同样是这样吗。混吃等死的不是任何工作岗位，而是人！任何岗位都可以有所成就。自己也不过只是凡人一个。不过凡人却也可以有自己的一片天地。就像小波说的：“井底之蛙也能拥有自己的一片天地。”</p>
<p>工作没有高低贵贱之分，不要带着要面子的心情而不愿意做些打杂的活。没有基础的积累，哪来平地起的万丈高楼。不要看不起自己也不要看不起他人。三十年河东三十年河西，此一时彼一时。</p>
<p>”中国的君子独善其身，这样就没有了尊严。这是因为尊严是属于个人的、不可压缩的空间，这块空间要靠自己来捍卫——捍卫的意思是指敢争、敢打官司、敢动手（勇斗歹徒）。我觉得人还是有点尊严的好，假如个人连个待的地方都没有，就无法为人做事，更不要说做别人的典范。“这句话同样适合我，该说该争该做的时候就应该大胆站出来，有一个男子汉的样子。要敢于亮剑！</p>
<p>我现在还不太明白我的人生目标是什么，名利？我不知道。我只想做一个懂点道理的人。上班以后感觉也变得世俗化了，不经意间都会主动被动地谈及任何关于钱的话题。我对钱有一些兴趣，但不愿为之受罪。我不想把自己的下半生绑在房子上，虽然我也买不起。找不到人同我谈谈诗歌、文学、历史、足球，谈谈理想和爱情。但正如小波所言：”和我志趣相投的人总不会一个人都没有吧。“我也不顾影自怜了。</p>
<p><br><br><br></p>
<h1 id="展望2018"><a href="#展望2018" class="headerlink" title="展望2018"></a>展望2018</h1><ul>
<li>最重要的事情当然是涨工资啦，哈哈。加油加油，为了涨工资可得好好奋斗；</li>
<li>如果能找一个离家近一点的工作当然是最好；</li>
<li>一个人总是孤独寂寞的，能找到一个能相互扶持的人当然最好；</li>
<li>改善自己的不同，提升自己的优点。扬长避短，向优秀的人多学习。</li>
</ul>
<p><br><br><br></p>
<h1 id="不成熟的想法"><a href="#不成熟的想法" class="headerlink" title="不成熟的想法"></a>不成熟的想法</h1><ul>
<li>成都这地方什么都要争，连坐个公交地铁也得积极地抢位置，哎；</li>
<li>人太多，太拥挤，随便去哪都是拥挤的要命。但另一方面却是人越多机会越多；</li>
<li>原来工作才是一生的主题。但到底图个啥——名？利？</li>
<li>上班以后认识的人也变少了，圈子也基本没什么了。曾经的同学们也各奔东西了；</li>
<li>我发觉任何一件事都是矛盾的。正面想是这样，反面想却又是那样，但都有道理。让我想起了一个故事，“一个农夫和一个老板在海边的对话。问：这么努力工作干嘛？答：为了以后能过更轻松的日子。那你看我现在不是挺轻松自在的吗？”</li>
<li>现在的自媒体为了流量真的是无所不用其极。各种大噱头的标题，完全不负责任的报道，只为吸引流量。到最后都不知道该相信谁，会不会被带节奏…；</li>
<li>一天24小时。8小时睡觉，8小时上班，3小时上下班，2小时吃饭及其他。It means that I only have 3 hours a day without Rest Day;</li>
<li>一个人只拥有此生此世是不够的，他还应该拥有诗意的世界。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2018.jpg&quot; alt=&quot;2018&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Zhang" scheme="https://zhang21.github.io/categories/Zhang/"/>
    
    
      <category term="2017" scheme="https://zhang21.github.io/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>君子的尊严</title>
    <link href="https://zhang21.github.io/2017/12/28/%E5%90%9B%E5%AD%90%E7%9A%84%E5%B0%8A%E4%B8%A5/"/>
    <id>https://zhang21.github.io/2017/12/28/君子的尊严/</id>
    <published>2017-12-28T01:58:32.000Z</published>
    <updated>2017-12-28T02:00:25.347Z</updated>
    
    <content type="html"><![CDATA[<p>笔者是个学究，待人也算谦和有礼，自以为算个君子——当然，实际上是不是，还要别人来评判。总的来说，君子是有文化有道德的人，是士人或称知识分子。按照中国的传统，君子是做人的典范。君子不言利。君子忍让不争。君子动口不动手。君子独善其身。这都是老辈子传下来的规矩，时至今日，以君子自居的人还是如此行事。我是宁做君子不做小人的，但我还是以为，君子身上有些缺点，不配作为人的典范；因为他太文弱、太窝囊、太受人欺。</p>
<a id="more"></a>
<p><br></p>
<p>君子既不肯与人争利，就要安于清贫。但有时不是钱的问题，是尊严的问题。前些时候在电视上看到北京的一位人大代表发言，说儿童医院的挂号费是一毛钱，公厕的收费是两毛钱。很显然，这样的收费标准有损医务工作的尊严。当然，发言的结尾是呼吁有关领导注意这个问题，有关领导也点点头说：是呀是呀，这个问题要重视。我总觉得这位代表太君子，没把话讲清楚——直截了当的说法是：我们要收两块钱。别人要是觉得太贵，那你就还个价来——这样三下五除二就切入了正题。这样说话比较能解决问题。</p>
<p><br></p>
<p>君子不与人争，就要受气。举例来说，我乘地铁时排队购票，总有些不三不四的人到前面加塞。说实在的，我有很多话要说：我排队，你为什么不排队？你忙，难道我就没有事？但是碍于君子的规范，讲不出口来。话憋在肚子里，难免要生气。有时气不过，就嚷嚷几句：排队，排队啊。这种表达方式不够清晰，人家也不知是在说他。正确的方式是：指住加塞者的鼻子，口齿清楚地说道：先生，大家都在排队，请你也排队。但这样一来，就陷入与人争论的境地，肯定不是君子了。</p>
<p><br></p>
<p>常在报纸上看到这样的消息：流氓横行不法，围观者如堵，无人上前制止。我敢断定，围观的都是君子，也很想制止，但怎么制止呢？难道上前和他打架吗？须知君子动口不动手啊。我知道英国有句俗话：绅士动拳头，小人动刀子。假如在场的是英国绅士，就可以上前用拳头打流氓了。</p>
<p><br></p>
<p>既然扯到了绅士，就可以多说几句。从前有个英国人到澳大利亚去旅行，过海关时，当地官员问他是干什么的。他答道：我是一个绅士。因为历史的原因，澳大利亚人不喜欢听到这句话，尤其不喜欢听到这句话从一个英国人嘴里说出来。那官员又问：我问你的职业是什么？英国人答道：职业就是绅士。难道你们这里没有绅士吗？这下澳大利亚人可火了，差点揍他，幸亏有人拉开了。在英美，说某人不是绅士，就是句骂人话。当然，在我们这里说谁不是君子，等于说他是小人，也是句骂人话。但君子和绅士不是一个概念。从字面上看，绅士（gentleman）是指温文有礼之人，其实远不止此。绅士要保持个人的荣誉和尊严，甚至可以说是这方面的专业户。坦白地说，他们有点狂傲自大。但也有一种好处：真正的绅士决不在危险面前止步。大战期间，英国绅士大批开赴前线为国捐躯，甚至死在了一般人前面。君子的标准里就不包括这一条。</p>
<p><br></p>
<p>中国的君子独善其身，这样就没有了尊严。这是因为尊严是属于个人的、不可压缩的空间，这块空间要靠自己来捍卫——捍卫的意思是指敢争、敢打官司、敢动手（勇斗歹徒）。我觉得人还是有点尊严的好，假如个人连个待的地方都没有，就无法为人做事，更不要说做别人的典范。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者是个学究，待人也算谦和有礼，自以为算个君子——当然，实际上是不是，还要别人来评判。总的来说，君子是有文化有道德的人，是士人或称知识分子。按照中国的传统，君子是做人的典范。君子不言利。君子忍让不争。君子动口不动手。君子独善其身。这都是老辈子传下来的规矩，时至今日，以君子自居的人还是如此行事。我是宁做君子不做小人的，但我还是以为，君子身上有些缺点，不配作为人的典范；因为他太文弱、太窝囊、太受人欺。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="王小波" scheme="https://zhang21.github.io/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>个人尊严</title>
    <link href="https://zhang21.github.io/2017/12/28/%E4%B8%AA%E4%BA%BA%E5%B0%8A%E4%B8%A5/"/>
    <id>https://zhang21.github.io/2017/12/28/个人尊严/</id>
    <published>2017-12-28T01:54:39.000Z</published>
    <updated>2017-12-28T01:56:45.130Z</updated>
    
    <content type="html"><![CDATA[<p>在国外时看到，人们对时事做出价值评判时，总是从两个独立的方面来进行：一个方面是国家或者社会的尊严，这像是时事的经线；另一个方面是个人的尊严，这像是时事的纬线。回到国内，一条纬线就像是没有，连尊严这个字眼也感到陌生了。提到尊严这个概念，我首先想到的英文词＂dignity＂，然后才想到相应的中文词。在英文中，这个词不仅有尊严之义，还有体面、身份的意思。尊严不但指人受到尊重，它还是人价值之所在。从上古到现代，数以亿万计的中国人里，没有几个人有过属于个人的尊严。举个大点的例子，中国历史上有过皇上对大臣施廷杖的事，无论是多大的官，一言不和，就可能受到如此当众羞辱，高官尚且如此，遑论百姓。除了皇上一人，没有一个人能有尊严。有一件最怪的事是，按照传统道德，挨皇帝的板子倒是一种光荣，文死谏嘛。说白了就是：无尊严就是有尊严。此话如有任何古怪之处，罪不在我。到了现代以后，人与人的关系、个人与集体的关系，仍有这种遗风──我们就不必细说文革中、文革前都发生过什么样的事情。到了现在，已经不用见官下跪，也不会在屁股上挨板子，但还是缺少个人的尊严。环境就是这样，公共场所的秩序就是这样，人对人的态度就是这样，不容你有任何自尊。</p>
<a id="more"></a>
<p><br></p>
<p>举个小点的例子，每到春运高潮，大家就会在传媒上看到一辆硬座车厢里挤了三四百人，厕所里也挤了十几人。谈到这件事，大家会说国家的铁路需要建设，说到铁路工人的工作难做，提到安全问题，提到所有的方面，就是不提这些民工这样挤在一起，好像一个团，完全没有了个人的尊严──仿佛这件事很不重要似的。当然，只要民工都在过年时回家，火车总是要挤的；谁也想不出好办法。但个人的尊严毕竟大受损害；这件事总该有人提一提才对。另一件事现在已是老生常谈，人走在街上感到内急，就不得不上公共厕所。一进去就觉得自己的尊严一点都没了。现在北京的公厕正在改观，这是因为外国人到了中国也会内急，所以北京的公厕已经臭名远扬。假如外国人不来，厕所就要臭下去；而且大街上改了，小胡同里还没有改。我认识的一位美国留学生说，有一次他在小胡同里内急，走进公厕撒了一泡尿，出来以后，猛然想到自己刚才满眼都对黄白之物，居然能站住了不倒，觉得自己很了不起，就急忙来告诉我。北京的某些街道很脏很乱，总要到某个国际会议时才能改观，这叫借某某会的东风。不光老百姓这样讲，领导上也这样讲。这话听起来很有点不对味。不雅的景象外人看了丢脸，没有外人时，自己住在里面也不体面──这后一点总是被人忘掉。</p>
<p><br></p>
<p>作为一个知识分子，我发现自己曾有一种特别的虚伪之处，虽然一句话说不清，但可以举些例子来说明。假如我看到火车上特别挤，就感慨一声道：这种事居然可以发生在中华人民共和国的土地上！假如我看到厕所特脏，又长叹一声：唉！北京市这是怎么搞的嘛！这其中有点幽默的成份，也有点当真。我的确觉得国家和政府的尊严受到了损失，并为此焦虑着。当然，我自己也想要点个人尊严，但以个人名义提出就过于直露，不够体面──言必称天下，不以个人面目出现，是知识分子的尊严所在。当然，现在我把这做为虚伪提出，已经自外于知识分子。但也有种好处，我找到了自己的个人面目。有关尊严问题，不必引经据典，我个人就是这么看。但中国忽视个人尊严，却不是我的新发现。从大智者到通俗作家，有不少人注意到一个有中国特色的现象：罗素说，中国文化里只重家族内的私德，不重社会的公德公益，这一点造成了很要命的景象；费孝通说，中国社会里有所谓＂差序格局＂，与己关系近的就关心，关系远的就不关心或少关心；结果有些事从来就没人关心。龙应台为这类事而愤怒过，三毛也大发过一通感慨。读者可能注意到了，所有指出这个现象的人，或则是外国人，或则曾在国外生活过，又回到了国内。没有这层关系的中国人，对此浑然不觉。笔者自己曾在外国居住四年，假如没有这种经历，恐怕也发不出这种议论──但这一点并不让我感到开心。环境脏乱的问题，火车拥挤的问题，社会秩序的问题，人们倒是看到了。但总从总体方面提出问题，讲国家的尊严、民族的尊严。其实这些事就发生在我们身边，削我们每个人的面子──对此能够浑然无觉，倒是咄咄怪事。</p>
<p><br></p>
<p>人有无尊严，有一个简单的判据，是看他被当作一个人还是一个东西来对待。这件事有点两重性，其一是别人把你当做人还是东西，是你尊严之所在。其二是你把自己看成人还是东西，也是你的尊严所在。挤火车和上公共厕所时，人只被当身体来看待。这里既有其一的成份，也有其二的成份；而且归根结蒂，和我们的文化传统有关。</p>
<p><br></p>
<p>说来也奇怪，中华礼仪之邦，一切尊严，都从整体和人与人的关系上定义，就是没有个人的位置。一个人不在单位里、不在家里，不代表国家、民族，单独存在时，居然不算一个人，就算是一块肉。这种算法当然是有问题。我的算法是：一个人独处荒岛而且谁也不代表，就像鲁滨孙那样，也有尊严，可以很好的活着。这就是说，个人是尊严的基本单位。知道了这一点，火车上太挤了之后，我就不会再挤进去而且浑然无觉。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在国外时看到，人们对时事做出价值评判时，总是从两个独立的方面来进行：一个方面是国家或者社会的尊严，这像是时事的经线；另一个方面是个人的尊严，这像是时事的纬线。回到国内，一条纬线就像是没有，连尊严这个字眼也感到陌生了。提到尊严这个概念，我首先想到的英文词＂dignity＂，然后才想到相应的中文词。在英文中，这个词不仅有尊严之义，还有体面、身份的意思。尊严不但指人受到尊重，它还是人价值之所在。从上古到现代，数以亿万计的中国人里，没有几个人有过属于个人的尊严。举个大点的例子，中国历史上有过皇上对大臣施廷杖的事，无论是多大的官，一言不和，就可能受到如此当众羞辱，高官尚且如此，遑论百姓。除了皇上一人，没有一个人能有尊严。有一件最怪的事是，按照传统道德，挨皇帝的板子倒是一种光荣，文死谏嘛。说白了就是：无尊严就是有尊严。此话如有任何古怪之处，罪不在我。到了现代以后，人与人的关系、个人与集体的关系，仍有这种遗风──我们就不必细说文革中、文革前都发生过什么样的事情。到了现在，已经不用见官下跪，也不会在屁股上挨板子，但还是缺少个人的尊严。环境就是这样，公共场所的秩序就是这样，人对人的态度就是这样，不容你有任何自尊。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="王小波" scheme="https://zhang21.github.io/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>SaltStack</title>
    <link href="https://zhang21.github.io/2017/12/25/SaltStack/"/>
    <id>https://zhang21.github.io/2017/12/25/SaltStack/</id>
    <published>2017-12-25T01:47:39.000Z</published>
    <updated>2018-01-11T07:31:56.907Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p>
<ul>
<li>SaltStack官网：<a href="https://saltstack.com" target="_blank" rel="external">https://saltstack.com</a> ;</li>
<li>SaltStack官方文档：<a href="https://docs.saltstack.com" target="_blank" rel="external">https://docs.saltstack.com</a> ;</li>
<li>SaltStack-GitHub：<a href="https://github.com/saltstack" target="_blank" rel="external">https://github.com/saltstack</a> ;</li>
<li>Salt-repo：<a href="https://repo.saltstack.com/" target="_blank" rel="external">https://repo.saltstack.com/</a> .</li>
</ul>
<p>环境：</p>
<ul>
<li>CentOS7_x64;</li>
<li>Salt-2017.7.2</li>
</ul>
<a id="more"></a>
<p><br></p>
<hr>
<p><br></p>
<h1 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a>Instruction</h1><p><code>SaltStack</code>是一种革命性的用速度(speed)取代复杂性(complexity)的基础设施(infrastucture)管理方法。</p>
<ul>
<li>简单(Simple)，可以在几分钟内运行；</li>
<li>可伸缩性(Scalable)，足以管理数以万计的Server；</li>
<li>快速(Fast)，能在几秒内与各系统间进行通信。</li>
</ul>
<p><br></p>
<p><strong>You’ll learn how to:</strong></p>
<ul>
<li>安装和配置SaltStack；</li>
<li>在所有托管系统上远程执行命令(Remotely execute commands)；</li>
<li>设计、开发和部署系统配置；</li>
<li>使用Salt Reactor是基础设施自动化(automate)；</li>
<li>使用Salt Orchestration协调复杂管理操作。</li>
</ul>
<p><img src="/images/Salt/SaltStack.png" alt="SaltStack"></p>
<p><br></p>
<p>Salt是建立在动态通信总线(dynamic communication bus)上的基础设施管理的一种新方法。Salt可以用于数据驱动(data-driven)业务，远程执行(remote execution)任何基础设施，配置管理(configuration management)任意应用堆栈…</p>
<ul>
<li>REMOTE EXECUTION;</li>
<li>CONFIGURATION MANAGEMENT;</li>
<li>EVENT-DRIVEN INFRASTRUCTURE;</li>
<li>SALT ESSENTIALS.</li>
</ul>
<p><br></p>
<hr>
<p><br></p>
<h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><p>如果是第一次设置环境，你应该在专用的管理服务器上安装<code>Salt master</code>，然后在每个使用Salt管理的系统上安装<code>Salt minion</code>。现在不需要担心你的系统架构(architecture)，你可以在以后轻易添加组件(componet)和修改配置(configuration)而不需要重新安装任何东西。</p>
<p>The general installation process is as follows:</p>
<ul>
<li>安装<code>Salt master</code>，通过各平台说明安装或通过Salt <code>bootstrap.sh</code>脚本来安装；</li>
<li>确保你的<code>Salt minion</code>能够找到<code>Salt master</code>；</li>
<li>在想要管理的每个系统上安装<code>Salt minion</code>；</li>
<li>在<code>Salt minion</code>连接后接受<code>Salt minion key</code>。</li>
</ul>
<p>在此之后，就可以<strong>运行一个简单命令</strong>，并从所有的<code>Salt minion</code><strong>接收返回</strong>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#salt &lt;minion-id&gt; &lt;cmd&gt;</span></div><div class="line"></div><div class="line">salt minion1 test.ping</div><div class="line">salt * test.ping</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="Quick-Install"><a href="#Quick-Install" class="headerlink" title="Quick Install"></a>Quick Install</h2><p>在绝大多数发行版本上，可以使用<strong>Salt Bootstrap</strong>脚本进行快速安装。</p>
<p>参考：<a href="https://docs.saltstack.com/en/latest/topics/tutorials/salt_bootstrap.html#salt-bootstrap" target="_blank" rel="external">Salt Bootstrap</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#wget</div><div class="line">wget https://bootstrap.saltstack.com -O bootstrap-salt.sh</div><div class="line">sh bootstrap-salt.sh</div><div class="line"></div><div class="line">#curl</div><div class="line">curl -o bootstrap-salt.sh -L https://bootstrap.saltstack.com</div><div class="line">sh bootstrap-salt.sh</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="Platform-Specific-Installation"><a href="#Platform-Specific-Installation" class="headerlink" title="Platform-Specific Installation"></a>Platform-Specific Installation</h2><p><a href="https://docs.saltstack.com/en/latest/topics/installation/index.html#platform-specific-installation-instructions" target="_blank" rel="external">选择发行版本安装</a></p>
<p><br></p>
<h3 id="在CentOS7上安装Salt"><a href="#在CentOS7上安装Salt" class="headerlink" title="在CentOS7上安装Salt"></a>在CentOS7上安装Salt</h3><p>repo: <a href="https://repo.saltstack.com/#rhel" target="_blank" rel="external">https://repo.saltstack.com/#rhel</a></p>
<p><strong>1. 下载SaltStack-Repository进行安装：</strong></p>
<p><code>systemd</code>和<code>systemd-python</code>是Salt必须的，在安装Salt前需装好。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#安装salt-repo</span></div><div class="line">yum install -y https://repo.saltstack.com/yum/redhat/salt-repo-latest-2.el7.noarch.rpm</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">yum clean expire-cache</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#安装salt组件</span></div><div class="line">yum install -y salt-master salt-master salt-ssh salt-syndic salt-cloud salt-api</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#开启</span></div><div class="line">systemctl start salt-master</div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>2. 自建salt-repo：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">vim /etc/yum.repos.d/saltstack.repo</div><div class="line"></div><div class="line"></div><div class="line">[saltstack-repo]</div><div class="line">name=SaltStack repo <span class="keyword">for</span> Cent0S7</div><div class="line">baseurl=https://repo.saltstack.com/yum/redhat/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/latest</div><div class="line">enalbed=1</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=https://repo.saltstack.com/yum/redhat/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/latest/SALTSTACK-GPG-KEY.pub</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="Initial-Configuration"><a href="#Initial-Configuration" class="headerlink" title="Initial Configuration"></a>Initial Configuration</h2><h3 id="Configuration-Salt"><a href="#Configuration-Salt" class="headerlink" title="Configuration Salt"></a>Configuration Salt</h3><p><code>salt-master</code> 的默认配置会为安装而工作，唯一要求是在<code>salt-minion</code>的配置文件中设置<code>salt-master</code>的位置。</p>
<p><br></p>
<h4 id="salt-master-configuration"><a href="#salt-master-configuration" class="headerlink" title="salt-master configuration"></a>salt-master configuration</h4><p>默认的，<code>salt-master</code>配置文件位于<code>/etc/salt/master</code>，在all interfaces(0.0.0.0)上监听<code>4505</code>和<code>4506</code>端口。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim /etc/salt/master</div><div class="line"></div><div class="line"></div><div class="line">interface: 0.0.0.0</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="salt-minion-configuration"><a href="#salt-minion-configuration" class="headerlink" title="salt-minion configuration"></a>salt-minion configuration</h4><p>默认，一个<code>salt-minion</code>会尝试连接到DNS名称为<code>salt</code>。如果<code>salt-minion</code>能够正确解析(resolve)这个名称，则可以不需要配置文件。如果DNS名称<code>salt</code>未能解析为<code>salt-master</code>的正确位置，那么可在<code>/etc/salt/minion</code>配置文件下重新定义<code>salt</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vim /etc/salt/minion</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#master: salt</span></div><div class="line"><span class="comment">#如果是默认的salt,需要在本地hosts下解析salt</span></div><div class="line"></div><div class="line"><span class="comment">#此处我们修改为salt-master的IP地址</span></div><div class="line">master: 192.168.1.9</div></pre></td></tr></table></figure>
<p><strong>修改配置文件后，请重启服务。</strong></p>
<p><br></p>
<h4 id="Proxy-Minion-Configuration"><a href="#Proxy-Minion-Configuration" class="headerlink" title="Proxy Minion Configuration"></a>Proxy Minion Configuration</h4><p>A Proxy Minion 模仿一个规律的行为和继承(inherit)他们的选项。<br>类似地，它的配置文件存放于<code>/etc/salt/proxy</code>，<code>proxy</code>也将尝试连接DNS名为<code>salt</code>的主机。</p>
<p>除了<code>salt-minion</code>有规律的选型，<code>proxy</code>还有一些特定的选项。参考:<a href="https://docs.saltstack.com/en/latest/ref/configuration/proxy.html#configuration-salt-proxy" target="_blank" rel="external">Proxy minion</a></p>
<p><br></p>
<h4 id="Running-Salt"><a href="#Running-Salt" class="headerlink" title="Running Salt"></a>Running Salt</h4><p>以<code>salt</code>命令运行:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">salt-master</div><div class="line"></div><div class="line"><span class="comment">#开启守护进程</span></div><div class="line">dalt-master -d</div><div class="line"></div><div class="line"></div><div class="line">salt-minion</div><div class="line">salt-minion -d</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#日志信息</span></div><div class="line">salt-master --<span class="built_in">log</span>-level=debug</div></pre></td></tr></table></figure>
<p><strong>以non-root user运行salt</strong></p>
<ul>
<li>确保此用户有相应的权限；</li>
<li>可能需要手动创建<code>salt</code>运行需要的目录<code>/etc/salt, /var/cache/salt, /var/log/salt, /var/run/salt</code>。</li>
</ul>
<p><br></p>
<h4 id="Key-Identity"><a href="#Key-Identity" class="headerlink" title="Key Identity"></a>Key Identity</h4><p>在<code>initial key</code>交换之前，<code>Salt</code>会提供命令来验证(validate)<code>salt-master</code>和<code>salt-minion</code>的身份。<br>验证身份有助于避免疏忽地连接到错误的<code>salt-master</code>，并且在建立初始化连接的阻止MiTM攻击。</p>
<p><strong>Master Key Fingerprint</strong><br>复制<code>master.pub</code>的值，并将其作为<code>salt-minion</code>配置文件<code>/etc/salt/minion</code>中<code>master_finger</code>的值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#salt-key is used to manage Salt authentication keys</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#显示master的key</span></div><div class="line">salt-key -F master</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看minion的finger</span></div><div class="line"><span class="comment">#salt-key --finger &lt;minion_id&gt;</span></div><div class="line">dalt-key --finger <span class="string">'192.168.1.7'</span></div></pre></td></tr></table></figure>
<p><strong>Minion Key Fingerprint</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">salt-call is used to execute module <span class="built_in">functions</span> locally on a Salt Minion</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看minion key fingerprint</span></div><div class="line"><span class="comment">#可在master上查看，比对两者是否相同</span></div><div class="line">salt-call --<span class="built_in">local</span> key.finger</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="Key-Management"><a href="#Key-Management" class="headerlink" title="Key Management"></a>Key Management</h4><p>Salt使用AES Encryption加密<code>salt-master</code>与<code>salt-minion</code>间的所有通信。这确保了发送到Minion的命令不会被篡改(tamper)，并保证了master与minion间是认证的和受信任的。</p>
<p>当命令发送到<code>salt-minion</code>之前，<code>salt-minion</code>的key必须要被<code>salt-master</code>所接受。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#列出salt-master上已知的keys</span></div><div class="line">salt-key -L</div></pre></td></tr></table></figure>
<p>其中包含四项:</p>
<ul>
<li>Accepted Keys:</li>
<li>Denied Keys:</li>
<li>Unaccepted keys:</li>
<li>Rejected keys:</li>
</ul>
<p><strong>让<code>salt-master</code>接收key，并允许<code>salt-minion</code>被<code>salt-master</code>控制</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-a 192.168.1.7, --accept=192.168.1.7</span></div><div class="line"><span class="comment">#-A, --accept-all</span></div><div class="line"></div><div class="line">salt-key -A</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="Sending-Commands"><a href="#Sending-Commands" class="headerlink" title="Sending Commands"></a>Sending Commands</h4><p><code>salt-master</code>和<code>salt-minion</code>之间通过运行<code>test.ping</code>命令来证实(verified)。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">salt 192.168.1.7 test.ping</div><div class="line"></div><div class="line">salt * test.ping</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="Additional-Installation-Guides"><a href="#Additional-Installation-Guides" class="headerlink" title="Additional Installation Guides"></a>Additional Installation Guides</h2><h3 id="Salt-Bootstrap"><a href="#Salt-Bootstrap" class="headerlink" title="Salt Bootstrap"></a>Salt Bootstrap</h3><p>Salt Bootstrap脚本允许用户在各种系统和版本上安装<code>salt-minion</code>和<code>salt-master</code>。shell脚本为<code>bootstrap-salt.sh</code>，运行一系列的检查来确定操作系统的类型和版本，然后通过适当的方法安装salt二进制文件。salt-bootstrap脚本安装运行<code>salt</code>的最小化安装包，如Git便不会安装。</p>
<p>Salt Bootstrap’s GitHub: <a href="https://github.com/saltstack/salt-bootstrap" target="_blank" rel="external">https://github.com/saltstack/salt-bootstrap</a></p>
<p><br></p>
<h4 id="Example-Usage"><a href="#Example-Usage" class="headerlink" title="Example Usage"></a>Example Usage</h4><p>Satl Bootstrap脚本有多种可以传递的选项，以及获取引导脚本本身的方法。</p>
<p><strong>1. Using <code>curl</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -o bootstrap-salt.sh -L https://bootstrap.saltstack.com</div><div class="line">sh bootstrap-salt.sh git develop</div></pre></td></tr></table></figure>
<p><strong>2. Using <code>wget</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget -O bootstrap-salt.sh https://bootstrap.saltstack.com</div><div class="line">sh bootstrap-salt.sh</div></pre></td></tr></table></figure>
<p><strong>3. An Insecure one-liner</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -L https://bootstrap.saltstack.com | sh</div><div class="line"></div><div class="line">wget -O - https://bootstrap.saltstack.com | sh</div><div class="line"></div><div class="line">curl -L https://bootstrap.saltstack.com | sh -s -- git develop</div></pre></td></tr></table></figure>
<p><strong>4. cmd line options</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#查看帮助</div><div class="line">sh bootstrap-salt.sh -h</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="Openging-the-firewall-up-for-salt"><a href="#Openging-the-firewall-up-for-salt" class="headerlink" title="Openging the firewall up for salt"></a>Openging the firewall up for salt</h3><p><code>salt-master</code>和<code>salt-minion</code>间的通信使用AES加密的<code>ZeroMQ</code>，它使用TCP的<code>4505</code>和<code>4506</code>端口，仅需要在<code>salt-master</code>上可访问就行。</p>
<p>下面概述了关于<code>salt-master</code>的防火墙规则：</p>
<p><strong>RHEL7/CENTOS7</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --permanent --zone=&lt;zone&gt; --add-port=4505-4506/tcp</div><div class="line">firewall-cmd --reload</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="Preseed-minion-with-accepted-key"><a href="#Preseed-minion-with-accepted-key" class="headerlink" title="Preseed minion with accepted key"></a>Preseed minion with accepted key</h3><p>某些情况下，在<code>salt-master</code>上接受<code>minion-key</code>之前等待<code>salt-minion</code>启动是不方便的。比如，你可能希望<code>minion</code>一上线(online)就引导。</p>
<p>有多种方式生成<code>minion-key</code>，下面是一般生成<code>minion-key</code>的四个步骤：</p>
<ol>
<li>在<code>salt-master</code>上生成<code>key</code>：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#请给key取个名字</div><div class="line">salt-key --gen-keys=[key_name]</div></pre></td></tr></table></figure>
<ol>
<li>把公钥(publick key)添加到已接受的<code>salt-minion</code>文件夹中:</li>
</ol>
<p>公钥文件和 minion_id 有相同的名字是很有必要的，这就是Salt如何通过key与minions匹配。<br>还有，由于不同操作系统或特定的master配置文件，pki 文件夹可能位于不同的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp &lt;key_name&gt;.pub /etc/salt/pkimaster/minions/&lt;minion_id&gt;</div></pre></td></tr></table></figure>
<ol>
<li>分配<code>minion-key</code>：</li>
</ol>
<p>对于minion来说，没有单一方法去得到密钥对，难点是找到一种安全的分配方法。</p>
<p>由于<code>master</code>已经接受了<code>minion-key</code>，因此分发私钥(private key)会有潜在的安全风险。</p>
<ol>
<li>配置带key的minion：</li>
</ol>
<p>你可能希望在启动<code>salt-miniont daemon</code>之前取得<code>minion-key</code>的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/etc/salt/pki/minion/minion.pem</div><div class="line">/etc/salt/pki/minion/minion.pub</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="Running-salt-as-normal-user-tutorial"><a href="#Running-salt-as-normal-user-tutorial" class="headerlink" title="Running salt as normal user tutorial"></a>Running salt as normal user tutorial</h3><p><strong>以普通用户(non-root)运行salt function</strong></p>
<p>如果你不想使用<code>root</code>用户安装或运行salt，你可以在你的工作目录中创建一个虚拟根目录(virtual root dir)来配置它。<br>salt system使用<code>salt.syspath</code>module来查找变量。</p>
<p>如果你运行salt-build，它会生成在: <code>./build/lib.linux-x86_64-2.7/salt/_syspaths.py</code>；</p>
<p>运行<code>python setup.py build</code>命令来生成它；</p>
<p>复制生成的module到你的salt dir，<code>cp ./build/lib.linux-x86_64-2.7/salt/_syspaths.py ./salt/_syspaths.py</code></p>
<p>修改它，并加入需要的变量和新路径：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># you need to edit this</span></div><div class="line">ROOT_DIR = *your current dir* + <span class="string">'/salt/root'</span></div><div class="line"></div><div class="line"><span class="comment"># you need to edit this</span></div><div class="line">INSTALL_DIR = *location of source code*</div><div class="line"></div><div class="line">CONFIG_DIR =  ROOT_DIR + <span class="string">'/etc/salt'</span></div><div class="line">CACHE_DIR = ROOT_DIR + <span class="string">'/var/cache/salt'</span></div><div class="line">SOCK_DIR = ROOT_DIR + <span class="string">'/var/run/salt'</span></div><div class="line">SRV_ROOT_DIR= ROOT_DIR + <span class="string">'/srv'</span></div><div class="line">BASE_FILE_ROOTS_DIR = ROOT_DIR + <span class="string">'/srv/salt'</span></div><div class="line">BASE_PILLAR_ROOTS_DIR = ROOT_DIR + <span class="string">'/srv/pillar'</span></div><div class="line">BASE_MASTER_ROOTS_DIR = ROOT_DIR + <span class="string">'/srv/salt-master'</span></div><div class="line">LOGS_DIR = ROOT_DIR + <span class="string">'/var/log/salt'</span></div><div class="line">PIDFILE_DIR = ROOT_DIR + <span class="string">'/var/run'</span></div><div class="line">CLOUD_DIR = INSTALL_DIR + <span class="string">'/cloud'</span></div><div class="line">BOOTSTRAP = CLOUD_DIR + <span class="string">'/deploy/bootstrap-salt.sh'</span></div></pre></td></tr></table></figure>
<p>创建目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir -p root/etc/salt root/var/cache/run root/run/salt root/srv</div><div class="line">root/srv/salt root/srv/pillar root/srv/salt-master root/var/log/salt root/var/run</div></pre></td></tr></table></figure>
<p>填充配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cp -r conf/* /etc/salt/</div><div class="line"></div><div class="line"></div><div class="line">vi /etc/salt/master</div><div class="line"></div><div class="line">user: *your user name*</div></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PYTHONPATH=`pwd` scripts/salt-cloud</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="Standalone-minion"><a href="#Standalone-minion" class="headerlink" title="Standalone minion"></a>Standalone minion</h3><p>因为<code>salt-minion</code>包含了如此广泛的功能，它可以独立运行。一个<code>standalone minion</code>可以用来做很多事情:</p>
<ul>
<li>在没有连接到<code>master</code>的系统上使用<code>salt-call</code>命令；</li>
<li>无主状态(masterless states)。</li>
</ul>
<p>当以无主模式运行salt时，不要运行<code>salt-minion daemon</code>。否则，它将尝试连接到master并失败。<br><code>salt-call</code>命令是独立的，不需要<code>salt-minion daemon</code>。</p>
<p><br></p>
<h4 id="minion-configuration"><a href="#minion-configuration" class="headerlink" title="minion configuration"></a>minion configuration</h4><p>有几个参考方法来设置不同的选项来配置<code>masterless minion</code>，<code>salt-minion</code>很容易通过配置文件(默认位于:<code>/etc/salt/minion</code>)进行配置。</p>
<p><br></p>
<p><strong>告诉salt运行masterless</strong></p>
<p><code>salt-call</code>命令用于在<code>salt-minion</code>本地运行模块功能，而不是在<code>salt-master</code>执行他们。通常，<code>salt-call</code>命令检查主机检索文件服务器和支柱数据，当时当运行<code>standalone salt-call</code>时，需要指示不要检查master的这些数据。<br>为了指示<code>minion</code>不要查找<code>master</code>，需要在运行<code>salt-call</code>时设置<code>file_client</code>配置选项。默认情况下，<code>file_client</code>被设置为<code>remote</code>让<code>minion</code>知道将从<code>master</code>中收集文件服务器和支柱数据。当设置<code>file_client</code>为<code>local</code>时，<code>minion</code>将不会从<code>master</code>收集这些数据。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">file_client:</span> <span class="string">local</span></div><div class="line"></div><div class="line"><span class="comment">#这样，salt-call命令将不会查找master</span></div><div class="line"><span class="comment">#并认为本地系统拥有所有的文件文支柱资源</span></div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>masterless运行状态</strong></p>
<p>the state system在所有需要的文件都在<code>minion</code>本地，轻易地在没有<code>salt-master</code>的情况下运行。为了达到此效果，需要配置<code>minion</code>配置文件，以了解如何像<code>master</code>一样返回file_roots信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">file_roots:</span></div><div class="line"><span class="attr">  base:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">/srv/salt</span></div></pre></td></tr></table></figure>
<p>现在设置salt state tree, top file和SLS modules，就像在<code>master</code>上设置它们一样。将<code>file_client</code>设置为<code>local</code>，并且一个可用的state tree会调用state module中的function，将使用<code>minion</code>上的file_roots中的信息而不是<code>master</code>。</p>
<p>当在一个<code>minion</code>上创建一个<code>state tree</code>时，不需要语法或路径的更改。<code>master</code>上的SLS modules不需要进行任何修改就可以与<code>minion</code>一起工作。这就使得salt scrit不需要设置一个<code>master</code>就能轻易部署，并允许这些SLS modules随着部署发展而容易转移到<code>master</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#以声明的状态可以执行</span></div><div class="line">salt-call state.apply</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#无需修改配置文件</span></div><div class="line">salt-call state.apply --<span class="built_in">local</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="Salt-masterless-quickstart"><a href="#Salt-masterless-quickstart" class="headerlink" title="Salt masterless quickstart"></a>Salt masterless quickstart</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SaltStack官网：&lt;a href=&quot;https://saltstack.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://saltstack.com&lt;/a&gt; ;&lt;/li&gt;
&lt;li&gt;SaltStack官方文档：&lt;a href=&quot;https://docs.saltstack.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://docs.saltstack.com&lt;/a&gt; ;&lt;/li&gt;
&lt;li&gt;SaltStack-GitHub：&lt;a href=&quot;https://github.com/saltstack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/saltstack&lt;/a&gt; ;&lt;/li&gt;
&lt;li&gt;Salt-repo：&lt;a href=&quot;https://repo.saltstack.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://repo.saltstack.com/&lt;/a&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7_x64;&lt;/li&gt;
&lt;li&gt;Salt-2017.7.2&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="SaltStack" scheme="https://zhang21.github.io/tags/SaltStack/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://zhang21.github.io/2017/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://zhang21.github.io/2017/12/11/数据结构/</id>
    <published>2017-12-11T05:44:38.000Z</published>
    <updated>2017-12-12T01:56:29.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>在计算机科学中，<strong>数据结构(data structure)</strong>是计算机中存储、组织数据的方式。<br>大多数数据结构都有数列、记录、可辨识联合、引用等基本类型构成。</p>
<p>数据结构意味着结构和封装，一个数据结构可被视为两个函数之间的接口，或是由数据类型联合组成的存储内容的访问方法和封装。<br>数据结构可通过程序语言所提供的数据类型、引用及其它操作加以实现。不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计。<br>一个涉及良好的数据结构，应该尽可能使用较少的时间与空间资源的前提下，支持各种程序运行。</p>
<p>正确选择数据结构可以提高算法的效率，在计算机程序设计里，选择适当的数据结构是一项重要工作。</p>
<a id="more"></a>
<p><br></p>
<hr>
<h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><ul>
<li>数组(Array);</li>
<li>栈(Stack): 后进先出，线性表；</li>
<li>队列(Queue): 先进先出，线性表；</li>
<li>链表(Linked List): 每个节点包括两部分，一个存储数据元素的数据域，另一个存储下一个节点地址的指针域；</li>
<li>树(Tree)；</li>
<li>图(Graph)；</li>
<li>堆(Heap): 一种动态树形结构；</li>
<li>散列表(Hash)；</li>
</ul>
<p><br></p>
<hr>
<h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><p>数组数据结构，是由相同类型的元素的集合所组成，分配一块连续的内存来存储。利用数组元素的索引(index)可计算出元素对应存储地址。</p>
<p>数组有 <strong>一维数组、二维数组、多维数组、可变长数组…</strong>。</p>
<p><br></p>
<hr>
<h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h3><p>堆栈又称为栈，是计算机科学中一种特殊的串列形式的抽象资料类别。<br>其特殊之处在于只能允许在链接串列或阵列的一端(栈顶指标:top)，进行加入数据(push)和取出数据(pop)。</p>
<p>由于栈数据结构只允许在一端进行操作，因为按照后进先出(LIFO, last-in-first-out)的原理运行。</p>
<p><br></p>
<hr>
<h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h3><p>队列，是先进先出(FIFO, first-in-first-out)的线性表。在具体应用中通常用链表或数组来实现。<br>队列只允许在后端(Rear)进行插入操作，在前端(Front)进行删除操作。</p>
<p><br></p>
<hr>
<h3 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表(Linked List)"></a>链表(Linked List)</h3><p>链表是一种线性表，但并不按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。<br>由于不必须按顺序存储，链表再插入的时候可以达到 O(1)的时间复杂度，比另一种线性表顺序表快得多。但查找一个节点或访问特定节点则需要 O(n)的时间，而顺序表相应的时间复杂度分别是 O(logn)和O(1)。</p>
<p>是用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了节点的指针域，空间开销比较大。</p>
<p>链表有<strong>单向链表、双向链表、循环链表…</strong>。<br>链表用来构建许多其它数据结构，如栈，队列和他们的派生。</p>
<p><br></p>
<hr>
<h3 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树(Tree)"></a>树(Tree)</h3><p>树是一种抽象数据类型，用来模拟具有树状结构性质的数据集合。</p>
<p>树有<strong>有序树、无序树（二叉树，B树，霍夫曼树）</strong>。</p>
<p><br></p>
<hr>
<h3 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图(Graph)"></a>图(Graph)</h3><p>在数学上，一个图是表示物体与物体之间的关系的方法，是图论的基本研究对象。</p>
<p>图有：<strong>有向图、无向图、简单图、多重图</strong>。</p>
<p><br></p>
<hr>
<h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h3><p>堆是计算机科学中一类特殊的数据结构的统称。<br>堆通常是一个可以被看做一棵树的数组对象。在队列中，调度程序反复提取队列中的第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p>
<p>堆常用于排序，这种算法称作堆排序。</p>
<p><br></p>
<hr>
<h3 id="散列表-Hash"><a href="#散列表-Hash" class="headerlink" title="散列表(Hash)"></a>散列表(Hash)</h3><p>散列表也叫哈希表，是根据<strong>键(key)</strong>而直接访问在内存存储位置的数据结构。<br>它通过计算一个关于键值的函数，将所需查询的数据映射到表中的一个位置来访问记录，这加快了查找速度。这种映射函数称为散列函数，存放记录的数组称为散列表。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;在计算机科学中，&lt;strong&gt;数据结构(data structure)&lt;/strong&gt;是计算机中存储、组织数据的方式。&lt;br&gt;大多数数据结构都有数列、记录、可辨识联合、引用等基本类型构成。&lt;/p&gt;
&lt;p&gt;数据结构意味着结构和封装，一个数据结构可被视为两个函数之间的接口，或是由数据类型联合组成的存储内容的访问方法和封装。&lt;br&gt;数据结构可通过程序语言所提供的数据类型、引用及其它操作加以实现。不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计。&lt;br&gt;一个涉及良好的数据结构，应该尽可能使用较少的时间与空间资源的前提下，支持各种程序运行。&lt;/p&gt;
&lt;p&gt;正确选择数据结构可以提高算法的效率，在计算机程序设计里，选择适当的数据结构是一项重要工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Database" scheme="https://zhang21.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="https://zhang21.github.io/2017/12/11/MongoDB/"/>
    <id>https://zhang21.github.io/2017/12/11/MongoDB/</id>
    <published>2017-12-11T02:49:52.000Z</published>
    <updated>2018-01-20T03:12:21.918Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p>
<ul>
<li><a href="http://docs.mongoing.com/" target="_blank" rel="external">MongoDB官方文档</a>;</li>
<li><a href="http://www.mongoing.com/docs" target="_blank" rel="external">MongoDB中文文档</a>;</li>
<li><a href="https://zh.wikipedia.org/wiki/MongoDB" target="_blank" rel="external">https://zh.wikipedia.org/wiki/MongoDB</a>;</li>
<li><a href="http://www.ywnds.com/?p=5635" target="_blank" rel="external">http://www.ywnds.com/?p=5635</a>;</li>
<li><a href="https://www.centos.bz/2017/08/mongodb-secure-intro-user-auth/" target="_blank" rel="external">https://www.centos.bz/2017/08/mongodb-secure-intro-user-auth/</a>;</li>
<li><a href="http://www.03sec.com/3176.shtml" target="_blank" rel="external">http://www.03sec.com/3176.shtml</a>;</li>
<li><a href="http://www.ywnds.com/?p=6502" target="_blank" rel="external">http://www.ywnds.com/?p=6502</a>;</li>
<li><a href="http://wiki.jikexueyuan.com/project/the-little-mongodb-book/" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/the-little-mongodb-book/</a>;</li>
</ul>
<p>环境：</p>
<ul>
<li>CentOS7_x64；</li>
<li>MongoDB3.4；</li>
</ul>
<a id="more"></a>
<p><br></p>
<hr>
<p><br></p>
<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>NoSQL(Not Only SQL)是对不同于传统的<strong>关系型数据库</strong>的<strong>数据库管理系统(DBMS)</strong>的统称。<br>NoSQL不使用SQL作为查询语言，其数据结构可以不需要固定的表格模式，有横向可扩展性的特征。<br>NoSQL用于超大规模数据的存储，这些类型的数据存储不需要固定的模式，无序多余操作就可以横向扩展。</p>
<p><br><br>关系型数据库的典型实现主要被调整用于执行规模小而读写频繁，或大批量极少写访问的事务。<br>当代典型的关系型数据库在一些数据敏感的应用中表现了糟糕的性能。例如：</p>
<ul>
<li>为巨量文档创建索引；</li>
<li>高流量网站的网页服务；</li>
<li>发送流媒体。</li>
</ul>
<p><br><br>NoSQL数据库分类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>栗子</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>文档存储</td>
<td>MongoDB</td>
<td>用类似json的格式存储，存储的内容是文档型的。这样就有机会对某些字段建立索引，实现关系数据库的某些功能</td>
</tr>
<tr>
<td>图形关系存储</td>
<td>Neo4j</td>
<td>图形关系的最佳存储</td>
</tr>
<tr>
<td>键-值(ker-value)存储</td>
<td>最终一致性的键-值存储 <br> 架构性键-值存储</td>
<td>xxx</td>
</tr>
<tr>
<td>主机式服务</td>
<td>key-value硬盘存储 <br> key-value RAM存储</td>
<td>MemcacheDB <br> Redis</td>
</tr>
<tr>
<td>多数据库</td>
<td>OpenQM</td>
<td>xxx</td>
</tr>
<tr>
<td>时序型数据库</td>
<td>Graphite</td>
<td>xxx</td>
</tr>
<tr>
<td>对象数据库</td>
<td>ObjecStore</td>
<td>通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据</td>
</tr>
<tr>
<td>列存储</td>
<td>HBase</td>
<td>顾名思义，按列存储数据。方便存储结构化和半结构化数据，方便做数据压缩，针对某一列或某几列的查询有很大的IO优势。</td>
</tr>
</tbody>
</table>
<p><br><br><br></p>
<hr>
<h1 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h1><p><br><br><img src="/images/MongoDB/MongoDB.jpeg" alt="MongoDB"></p>
<p>MongoDB(<a href="https://www.mongodb.com/" target="_blank" rel="external">https://www.mongodb.com/</a>)，是一种文档导向的数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。它是一种NoSQL。<br>MongoDB支持的数据结构非常松散，是类似于json的bson格式，因此可以存储比较复杂的数据类型。<br>MongoDB是一个开源文档数据库，提供高性能，高可用性和自动扩展。</p>
<p><br><br><strong>预备知识：</strong></p>
<ol>
<li>MongoDB中的<code>database</code>有和数据库一样的概念。一个MongoDB实例中，可以有零个或多个数据库，每个都作为一个高等容器，用于存储数据；</li>
<li>MongoDB数据库中有零个或多个<code>collections</code>(集合)。集合类似于传统意义上的<code>table</code>(表)；</li>
<li>MongoDB的集合是由零个或多个<code>documents</code>(文档)组成。文档类似于<code>row</code>(行)；</li>
<li>MongoDB的文档由零个或多个<code>fields</code>(字段)组成。字段类似于<code>columns</code>(列)；</li>
<li>MongoDB中<code>Indexes</code>(索引)扮演的角色与RDMS中一样；</li>
<li>MongoDB中的<code>Cursors</code>(游标)很重要，当你向MongoDB取数据的时候，它会给你返回一个结果集的指针而不是真正的数据，这个指针我们叫它游标。我们可以用游标做任何事情，比如计数或跨行之类。</li>
</ol>
<p><br></p>
<h2 id="MongoDB特点"><a href="#MongoDB特点" class="headerlink" title="MongoDB特点"></a>MongoDB特点</h2><p>不如这样认为，MongoDB是关系型数据库的一个代替案。比如用<code>Lucene</code>作为关系型数据库的全文检索索引的加强，或者是<code>Redis</code>作为持久性<code>key-value</code>存储。</p>
<p><strong>无模式(Flexible Schema)</strong>：<br>它不需要一个固定的模式，这使得他们比传统的数据库表要灵活更多。</p>
<p><br><br><strong>写操作(Writes)</strong>：<br>MongoDB可以胜任的一个特殊角色是在日志领域。有两点使得MongoDB的写操作非常快：</p>
<ol>
<li>可以选择发送了写操作之后立刻返回，而无需等到操作完成；</li>
<li>可以控制数据持久性的写行为。</li>
</ol>
<p><br><br><strong>高性能(High Performance)</strong>：<br>MongoDB提供了高性能的数据持久性。尤其是：</p>
<ul>
<li>对嵌入式数据模型的支持减少了数据库系统上的I/O活动；</li>
<li>索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。</li>
</ul>
<p><br><br><strong>高可用(High Availability)</strong>：<br>MongoDB的复制工具，称为副本集。提供：自动故障转移和数据冗余。</p>
<p><br><br><strong>持久性(Durability)</strong>：<br>在MongoDB中，日志(Journaling)是默认启动的，该功能允许快速恢复服务器，比如遭遇到了服务器奔溃或停电的问题。</p>
<p><br><br><strong>丰富的查询语言(Rich Query Language)</strong>：<br>MongoDB支持丰富的查询语言来支持读写操作(CRUD)，数据聚合(Data Aggregation)，全文搜索(Text Search)。</p>
<p><br><br><strong>水平可伸缩性(Horizontal Scalability)</strong>：<br>MongoDB提供了横向可伸缩性。</p>
<p><br><br><strong>支持多个存储引擎(Support for Multiple Storage Engines)</strong>：<br>在MongoDB3.2以后默认引擎为: WiredTiger Storage Engine，允许第三方为MongoDB开发存储引擎。</p>
<p><br></p>
<h2 id="database和collection"><a href="#database和collection" class="headerlink" title="database和collection"></a>database和collection</h2><p>MongoDB stores BSON documents.</p>
<p><img src="/images/MongoDB/collection.png" alt="collection"></p>
<p><br></p>
<h3 id="databases"><a href="#databases" class="headerlink" title="databases"></a>databases</h3><p>In MongoDB,databases hold collections of documents.<br>如果一个数据库不存在，当你第一次存储数据时，MongoDB会自动创建数据库。这意味着可以切换到不存在的数据库。</p>
<p>默认情况下，集合不要求其文档具有相同的模式；文档不要求具有相同的字段集；字段的数据类型在集合的文档间可以有所不同。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#select a db</span></div><div class="line">use &lt;db&gt;</div><div class="line"></div><div class="line"><span class="comment">#create a db</span></div><div class="line">use newdb</div><div class="line">db.newcoll.insert(&#123;name:<span class="string">'zhang'</span>&#125;)</div><div class="line">db.newcoll.insert(&#123;filed01:<span class="string">'filed01'</span>, filed02:<span class="string">'filed02'</span>, filed03:<span class="string">'filed03'</span>, filed04:<span class="string">'filed04'</span>&#125;)</div><div class="line">db.newcoll.insert(&#123;groups: [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]&#125;)</div><div class="line">db.newcoll.find().pretty()</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><p>MongoDB stores documents in collections.<br>collection类似于关系型数据库中的table。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.coll02.insert(&#123;x:1&#125;)</div><div class="line">db.coll03.createIndex(&#123;y:1&#125;)</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="显式创建-explicit-creation"><a href="#显式创建-explicit-creation" class="headerlink" title="显式创建(explicit creation)"></a>显式创建(explicit creation)</h3><p>MongoDB提供了<code>db.createCollection()</code>方法来显式创建一个附带各种选项的集合。如设置document最大大小，文件验证规则等选项。<br>如果不需要指定这些选项，就不需要使用显式创建集合，而直接向集合中插入数据即可。<br>修改collection选项，使用<code>collMod</code>方法。</p>
<p><br></p>
<h3 id="视图-View"><a href="#视图-View" class="headerlink" title="视图(View)"></a>视图(View)</h3><p>视图的定义是公开的，视图的解释操作将包括定义视图的管道。因此，避免直接引用视图定义中的敏感字段和值。</p>
<p><strong>创建/删除视图：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">db.runCommand(</div><div class="line">&#123;</div><div class="line">	crete: &lt;view&gt;,</div><div class="line">	viewOn: &lt;<span class="built_in">source</span>&gt;,</div><div class="line">	pipeline: &lt;pipeline&gt;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">db.createView(&lt;view&gt;, &lt;<span class="built_in">source</span>&gt;, &lt;pipeline&gt;, &lt;collation&gt;)</div><div class="line"></div><div class="line">db.collection.drop()</div></pre></td></tr></table></figure>
<p><br><br><strong>视图行为：</strong></p>
<p>视图存在以下行为：</p>
<ul>
<li>视图只读，视图上的写操作将会出错；</li>
<li>视图使用底层集合的索引；</li>
<li>如果视图的基础集合被分割，视图也被认为可分割；</li>
<li>不能重命名视图；</li>
<li>视图上的字符串使用视图的默认排序规则。</li>
</ul>
<p><br></p>
<h3 id="限制集"><a href="#限制集" class="headerlink" title="限制集"></a>限制集</h3><p>限制集是固定大小的集合支持基于文档插入顺序的高吞吐率的插入、检索、删除操作。<br>限制收集工作在某种程度上类似于循环缓冲区：一旦一个文档填满分配给它的空间，它将通过在限制集中重写老文档来给新文档让出空间。</p>
<p><br></p>
<h4 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h4><p><strong>插入顺序</strong><br>限制集合能够保留插入顺序。因此，查询并不需要索引来保证以插入顺序来返回文档。减少了索引的消耗，限制集可以支持更高的插入吞吐量。</p>
<p><strong>最旧文档的自动删除</strong><br>为了给新文档腾出空间，再不需要脚本或显示删除操作的前提下，限制集自动删除集合中最旧的文档。</p>
<p>例如replication set中的oplog.rs集合。考虑潜在用于集合封顶的用例：</p>
<ul>
<li>存储高容量系统生成的日志信息。没有索引的情况下向限制集中插入文档的速度接近于直接在文件系统中写日志的速度；</li>
<li>在限制集中缓存少量的数据。</li>
</ul>
<p><strong>_id索引</strong><br>限制集合有一个_id字段并且默认在_id字段上创建索引。</p>
<p><br></p>
<h4 id="限制和建议"><a href="#限制和建议" class="headerlink" title="限制和建议"></a>限制和建议</h4><p><strong>更新</strong><br>更新限制集中的文档，创建一个索引保证这些更新操作不需要进行集合扫描。</p>
<p><strong>文档大小</strong><br>一个更新或替换操作改变了文档大小，操作将会失败。</p>
<p><strong>文档删除</strong><br>不能从一个限制集中删除文档！<br>为了从一个集合中删除所有文档，使用<code>drop()</code>方法来删除集合然后重新创建限制集。</p>
<p><strong>分片</strong><br>不能对限制集分片。</p>
<p><strong>查询效率</strong><br>用自然顺序监视限制集中大部分最近插入的文档。</p>
<p><br></p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><p><strong>创建一个限制集</strong><br>必须使用<code>db.createCollection()</code>方法创建限制集。且必须指定<strong>以字节为单位</strong>的最大集合大小。MongoDB将会预先分配集合。<br>另外，可为限制集指定最大文档数据，用<code>max</code>字段。</p>
<p>大小参数是必须的。MongoDB会在达到最大限制前删除旧的文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use &lt;db&gt;</div><div class="line"></div><div class="line"><span class="comment">#限制集大小</span></div><div class="line">db.createCollection(<span class="string">"log"</span>, &#123;capped: <span class="literal">true</span>, size: 1000000&#125;)</div><div class="line"></div><div class="line"><span class="comment">#限制集和文档大小</span></div><div class="line">db.createCollection(<span class="string">"log"</span>, &#123;capped: <span class="literal">true</span>, size: 5242880, max: 5000&#125;)</div></pre></td></tr></table></figure>
<p><strong>查询一个限制集</strong><br>如果没有对限制集指定排序，则MongoDB的结果顺序和插入顺序相同。</p>
<p><strong>检查一个集合是否是限制集</strong><br><code>isCapped()</code>方法</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.collection.isCapped()</div><div class="line"><span class="comment">#db.coll01.isCapped()</span></div><div class="line"><span class="comment">#false</span></div></pre></td></tr></table></figure>
<p><strong>将集合转换为限制集</strong><br><code>convertToCapped()</code>方法</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.runCommand(&#123;<span class="string">"covertToCapped"</span>: <span class="string">"coll01"</span>, size: 1000000&#125;);</div><div class="line"><span class="comment">#db.coll01.isCapped()</span></div><div class="line"><span class="comment">#true</span></div></pre></td></tr></table></figure>
<p><strong>在规定的时间周期之后将自动移除数据</strong><br>通过设置MongoDB的TTL时集合中的数据过期。<br>TTL collection与限制集不兼容。</p>
<p><strong>Tailable游标</strong><br>类似于Unix中的<code>taif -f</code></p>
<p><br><br><br></p>
<h2 id="document"><a href="#document" class="headerlink" title="document"></a>document</h2><p>MongoDB存储数据记录为BSON文档。<br>BSON是JSON文档的二进制表示，因此它包含比JSON更多的数据类型。</p>
<p><br></p>
<h3 id="document-structure"><a href="#document-structure" class="headerlink" title="document structure"></a>document structure</h3><p>MongoDB字段由key-value对组成。<br>字段值可以是任一BSON数据类型，包括其他文档，数组，阵列。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	filed1: value1;</div><div class="line">	filed2: value2;</div><div class="line">    ...</div><div class="line">    filedN: valueN</div><div class="line">&#125;g</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#data type</span></div><div class="line">var mydoc =&#123;</div><div class="line">		_id: ObjectId(<span class="string">"5099803df3f4948bd2f98391"</span>),</div><div class="line">		name: &#123; first: <span class="string">"Alan"</span>, last: <span class="string">"Turing"</span> &#125;,</div><div class="line">		birth: new Date(<span class="string">'Jun 23, 1912'</span>),</div><div class="line">		death: new Date(<span class="string">'Jun 07, 1954'</span>),</div><div class="line">		contribs: [ <span class="string">"Turing machine"</span>, <span class="string">"Turing test"</span>, <span class="string">"Turingery"</span> ],</div><div class="line">		views : NumberLong(1250000)</div><div class="line">&#125;</div><div class="line"></div><div class="line">_id是ObjectID；</div><div class="line">name是嵌入式文档；</div><div class="line">birth是日期类型；</div><div class="line">contribs是字符串数组；</div><div class="line">view是NumberLong类型。</div></pre></td></tr></table></figure>
<p><strong>字段名(field name)</strong><br>字段名是字符串。<br>document对field name有以下限制:</p>
<ul>
<li>字段名称<code>_id</code>保留用作主键(primary key)，它的值在collection中必须唯一，不可变。它的类型可以是数组外的任何类型；</li>
<li>字段名称不能以<code>$</code>字符开头；</li>
<li>字段名称不能包含<code>.</code>字符；</li>
<li>字段名称不能包含<code>null</code>字符。</li>
</ul>
<p>BSON documents 可能有多个字段名称相同的字段。然而，大多数的MongoDB Interface，MongoDB结构（如hash表），并不支持重复字段名称。<br>如果需要操作具有多个相同名称字段的文档，请参考 mongo driver。</p>
<p>一些由内部MongoDB进程创建的documents可能会有重复的字段，但是没有MongoDB进程会向一个已经存在的user document中添加重复字段。</p>
<p><strong>字段值限制(field value limit)</strong><br>For <code>indexed collections</code>，indexed fields的值有一个最大索引值长度限制(maximum index key length)。</p>
<p><br></p>
<h3 id="圆点表示法-dot-notation"><a href="#圆点表示法-dot-notation" class="headerlink" title="圆点表示法(dot notation)"></a>圆点表示法(dot notation)</h3><p>MongoDB使用圆点表示法来访问数组中的元素，访问嵌套文档中的字段。</p>
<p><strong>数组(array)</strong><br>通过基于0的索引位置来指定或访问数组中的元素。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;array&gt;.&lt;index&gt;</div><div class="line"></div><div class="line">&#123;</div><div class="line">	contribs: [ <span class="string">'Turing machine'</span>, <span class="string">'Turing test'</span>, <span class="string">'Turingery'</span> ]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#contribs.0 == 'Turing machine'</span></div><div class="line"><span class="comment">#contribs.1 == 'Turing test'</span></div><div class="line"><span class="comment">#contribs.2 == 'Turingery'</span></div></pre></td></tr></table></figure>
<p><strong>嵌套文档(embedded documents)</strong><br>通过圆点表示法来指定或访问嵌套文档中的字段。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;embedded document&gt;.&lt;field&gt;</div><div class="line"></div><div class="line">&#123;</div><div class="line">	name: &#123; first: <span class="string">'AAA'</span>, last: <span class="string">'ZZZ'</span>&#125;,</div><div class="line">    contact: &#123; phone: &#123; <span class="built_in">type</span>: <span class="string">'cell'</span>, number: <span class="string">'1-22-333'</span> &#125;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#name.first == 'AAA'</span></div><div class="line"><span class="comment">#contact.phone.number == '1-22-333'</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="文档限制-document-limitation"><a href="#文档限制-document-limitation" class="headerlink" title="文档限制(document limitation)**"></a>文档限制(document limitation)**</h3><p><strong>文档大小限制(size limit)</strong><br>BSON document最大size为：16MB。</p>
<p>最大document size确保一个单一document不能使用过量的RAM，或是传输期间的过量带宽。<br>MongoDB提供了<code>GridFS API</code>，用来保存超过最大size的文档。</p>
<p><strong>文档字段序列(field order)</strong><br>MongoDB用write operation来作为document的序列，除了一下情况：</p>
<ul>
<li><code>_id</code>字段总是document中的第一个field；</li>
<li>包含重命名的<code>update</code>操作，会导致document中的field重新排序。</li>
</ul>
<p><strong>_id字段</strong><br>在MongoDB中，每个保存在collection中的document都要求一个唯一的<code>_id</code>，用以担任主键(primary key)。<br>如果向document中<code>insert</code>数据是忽略的<code>_id</code>字段，则MongoDB driver会为<code>_id字段</code>自动生成一个ObjectID。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#默认生成_id</span></div><div class="line">db.coll01.insert(&#123;name: <span class="string">'zhang'</span>, sex: <span class="string">'man'</span>, hobby: <span class="string">'woman'</span>&#125;)</div><div class="line"><span class="comment"># "_id" : ObjectId("5a32166ebf2c986e8106f891")</span></div><div class="line"></div><div class="line"><span class="comment">#自定义_id</span></div><div class="line">db.coll01.insert(&#123;_id:<span class="string">'ZhangCustomDefine'</span>, name:<span class="string">'zhang'</span>, sex: <span class="string">'man'</span>, arr: [0, 1, 2, 3], emmdoc: &#123;emm01:<span class="string">'Emm01'</span>, emm02: <span class="string">'Emm02'</span>, emm03: <span class="string">'Emmo3'</span>&#125;&#125;)</div><div class="line"><span class="comment">#"_id" : "ZhangCustomDefine"</span></div></pre></td></tr></table></figure>
<p><code>_id字段</code>有以下行为和约束：</p>
<ul>
<li>默认情况下，MongoDB在collection创建document时，会创建一个唯一的<code>_id</code>作为索引；</li>
<li><code>_id字段</code>总是document中的第一个字段。如果server接受的document中<code>_id</code>不在第一个字段，那么Server会移动<code>_id</code>到第一个字段；</li>
<li><code>_id</code>字段的数据类型除了数组外的任意BSON 数据类型；</li>
<li>不要存储BSON正则表达式的类型在<code>_id</code>字段中。</li>
</ul>
<p><code>_id</code>字段值的常用选项：</p>
<ul>
<li>使用ObjectId；</li>
<li>使用了自然唯一的标识符，节省了空间并避免了额外的索引；</li>
<li>生成一个自动递增的数字；</li>
<li>在应用程序代码中生成UUID；</li>
</ul>
<p><br></p>
<h3 id="文档结构的其他用途"><a href="#文档结构的其他用途" class="headerlink" title="文档结构的其他用途"></a>文档结构的其他用途</h3><p><strong>查询过滤文档(query filter)</strong><br>使用<key>:<value>表达式来指定条件。</value></key></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	&lt;field1&gt;: &lt;value1&gt;</div><div class="line">    &lt;field2&gt;: &lt;value2&gt;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>更新特定文档(update)</strong><br>使用<code>db.collection.update()</code>操作更新数据。</p>
<p><br><br><br></p>
<h2 id="BSON类型"><a href="#BSON类型" class="headerlink" title="BSON类型"></a>BSON类型</h2><p>BSON是一个用来存储document和MongoDB进行远程调用的二进制序列化格式。<br>BSON支持一下数据类型作为文档中的值。每个数据类型都有一个相应的数字和字符串别名，可与$type操作符一起使用，以便按照bson类型查询文档。</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Number</th>
<th>Alias</th>
</tr>
</thead>
<tbody>
<tr>
<td>double</td>
<td>1</td>
<td>“double”</td>
</tr>
<tr>
<td>字符串</td>
<td>2</td>
<td>“string”</td>
</tr>
<tr>
<td>对象</td>
<td>3</td>
<td>“object”</td>
</tr>
<tr>
<td>数组</td>
<td>4</td>
<td>“array”</td>
</tr>
<tr>
<td>二进制数据</td>
<td>5</td>
<td>“binData”</td>
</tr>
<tr>
<td>未定义</td>
<td>6</td>
<td>“undefined”</td>
</tr>
<tr>
<td>ObjectId</td>
<td>7</td>
<td>“objectId”</td>
</tr>
<tr>
<td>Boolean</td>
<td>8</td>
<td>“bool”</td>
</tr>
<tr>
<td>日期</td>
<td>9</td>
<td>“date”</td>
</tr>
<tr>
<td>空</td>
<td>10</td>
<td>“null”</td>
</tr>
<tr>
<td>正则表达式</td>
<td>11</td>
<td>“regex”</td>
</tr>
<tr>
<td>DBPointer</td>
<td>12</td>
<td>“dbPointer”</td>
</tr>
<tr>
<td>JavaScript</td>
<td>13</td>
<td>“javascript”</td>
</tr>
<tr>
<td>符号</td>
<td>14</td>
<td>“symbol”</td>
</tr>
<tr>
<td>JavaScript(带范围)</td>
<td>15</td>
<td>“javascriptWithScope”</td>
</tr>
<tr>
<td>32位整数</td>
<td>16</td>
<td>“int”</td>
</tr>
<tr>
<td>时间戳</td>
<td>17</td>
<td>“timestamp”</td>
</tr>
<tr>
<td>64位整数</td>
<td>18</td>
<td>“long”</td>
</tr>
<tr>
<td>Decimal128</td>
<td>19</td>
<td>“decimal”</td>
</tr>
<tr>
<td>Min key</td>
<td>-1</td>
<td>“minKey”</td>
</tr>
<tr>
<td>Max key</td>
<td>127</td>
<td>—</td>
</tr>
</tbody>
</table>
<p>如果你想要将BSON转换为JSON，参考Extended JSON。</p>
<p><br></p>
<h3 id="ObjectId"><a href="#ObjectId" class="headerlink" title="ObjectId"></a>ObjectId</h3><p>ObjcetIds are small, likely unique, fast to generate, and ordered.<br>ObjectIds有12个字节组成，其中前4个字节是反映ObjectId创建的时间戳(timestamp)。</p>
<ul>
<li>一个4字节的值，代表从Unix纪元开始的秒数；</li>
<li>一个3字节的机器标识符；</li>
<li>日期对象排在时间戳对象之前；</li>
<li>MongoDB在比较过程中，会把一些类型看成相等。</li>
</ul>
<p>栗子：<code>{ &quot;_id&quot; : ObjectId(&quot;5a33354068b6c5e5fb6f213f&quot;), &quot;name&quot; : &quot;ZHANG&quot; }</code>。</p>
<p>在mongo shell中，可以访问ObjectId的创建时间，使用<code>ObjectId.getTimestamp()</code>方法。<br>在<code>_id</code>字段中存储的ObjectId值的排序，大致相当于按其创建时间排序。<br>ObjectId的值顺序与生成时间之间并不严格。</p>
<p><br></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>BSON字符串都是UTF-8编码。一般来说，每种编程语言的驱动程序在序列化和反序列化BSON的时候，都会从语言的字符串形式转化为UTF-8。这就使得使用BSON字符串简单存储大多数国际字符变为可能。</p>
<p><br></p>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>BSON有一个特殊的时间戳类型用于MongoDB内部使用，与普通的日期类型无关。而在应用开发中可使用BSON日期类型。<br>时间戳值是一个64位的值： 前32位是与Unix纪元相差的秒数，后32位是在某秒总操作的一个递增的序列数。</p>
<p>在MongoDB复制集中，<code>oplog</code>有一个ts字段。这个字段的值使用BSON时间戳表示了操作时间。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.coll02.insert( &#123; ts: new Timestamp() &#125; )</div><div class="line"></div><div class="line">db.coll02.find()</div><div class="line"><span class="comment">#&#123; "_id" : ObjectId("5a333e3f68b6c5e5fb6f2141"), "ts" : Timestamp(1513307711, 1) &#125;</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p>BSON日期是一个64位整数，表示利当前Unix新纪元(1970.01.01)的毫秒数，可到未来的2.9亿年。<br>BSON日期类型是有符号的，负数表示1970年之前的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var date1 = new Date()</div><div class="line">var date2 = ISODate()</div><div class="line"></div><div class="line">#date1</div><div class="line">#date2</div><div class="line">#ISODate(&quot;2017-12-15T03:28:08.227Z&quot;)</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="MongoDB-Extended-JSON"><a href="#MongoDB-Extended-JSON" class="headerlink" title="MongoDB Extended JSON"></a>MongoDB Extended JSON</h2><p>JSON只能表示BSON类型的一个子集。为了保留类型信息，MongoDB对JSON格式添加了如下扩展性：</p>
<ul>
<li>Strict mode： Any JSON parser can parse these strict mode representations as key/value pairs;</li>
<li>mongo shell mode： The MongoDB internal JSON parser and the mongo shell can parse this mode.</li>
</ul>
<p>多种数据类型的表示取决于JSON解析的上下文！</p>
<p><br></p>
<h3 id="解析器-parser-和支持的格式-format"><a href="#解析器-parser-和支持的格式-format" class="headerlink" title="解析器(parser)和支持的格式(format)"></a>解析器(parser)和支持的格式(format)</h3><p><strong>Input in Strict mode</strong><br>如下可在严格模式下被解析并识别类型信息。</p>
<ul>
<li>REST Interface;</li>
<li>mongo import;</li>
<li>–query;</li>
<li>MongoDB Compass.</li>
</ul>
<p><br><br><strong>Input in mongo shell mode</strong><br>如下可在严格模式下被解析并识别类型信息。</p>
<ul>
<li>REST Interface;</li>
<li>mongo import;</li>
<li>–query;</li>
<li>MongoDB Compass.</li>
</ul>
<p><br><br><strong>Output in Strict mode</strong><br><code>mongoexport</code>, REST, HTTP Interfaces.</p>
<p><br><br><strong>Output in mongo shell mode</strong><br><code>bsondump</code>.</p>
<p><br></p>
<h3 id="BSON数据类型和关联表示"><a href="#BSON数据类型和关联表示" class="headerlink" title="BSON数据类型和关联表示"></a>BSON数据类型和关联表示</h3><p><strong>Binary</strong></p>
<table>
<thead>
<tr>
<th>Strict mode</th>
<th>mongo shell mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>{ “$binary”: “<bindata>“, “$type”: “<t>“ }</t></bindata></td>
<td>BinData ( <t>, <bindata> )</bindata></t></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;bindata&gt;是二进制base64表示；</div><div class="line">&lt;t&gt;是由单字节的数据类型表示。</div></pre></td></tr></table></figure>
<p><br><br><strong>Date</strong></p>
<table>
<thead>
<tr>
<th>Strict mode</th>
<th>mongo shell mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>{ “$date”: “<date>“ }</date></td>
<td>new Date ( <date> )</date></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In Strict mode, &lt;date&gt;是 ISO-8601的日期格式的时区字段，类型如**YYYY-MM-DDTHH:mm:ss.mm&lt;+/-offset&gt;;</div><div class="line">MongoDb JSON解析器目前暂不支持载入ISO-8601日期类型。</div></pre></td></tr></table></figure>
<p><br><br><strong>Timestamp</strong></p>
<table>
<thead>
<tr>
<th>Strict mode</th>
<th>mongo shell mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>{ “$timestamp” ; { “t”: <t>, “i” } }</t></td>
<td>Timestamp( <t>, <i> )</i></t></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;t&gt;是32位无符号整数的JSON表现形式；</div><div class="line">&lt;i&gt;是增量的32位无符号整数。</div></pre></td></tr></table></figure>
<p><br><br><strong>Regular Expression</strong></p>
<table>
<thead>
<tr>
<th>Strict mode</th>
<th>mongo shell mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>{ “$regex”: <sregex>, “$options”: “<soptions>“ }</soptions></sregex></td>
<td>/<jregex>/<joptions></joptions></jregex></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;sRegex&gt;是有效地JSON字符串；</div><div class="line">&lt;jRegex&gt;是一个可能包含有效的JSON字符和未转义的双引号(&quot;)，但可能不包括未转义的斜杠(/)字符；</div><div class="line">&lt;sOptions&gt;是一个正则表达式选项；</div><div class="line">&lt;jOptions&gt;是一个只能包含字符&quot;g&quot;, &quot;i&quot;, &quot;m&quot;, &quot;s&quot;的字符串。</div></pre></td></tr></table></figure>
<p><br><br><strong>OID</strong></p>
<table>
<thead>
<tr>
<th>Strict mode</th>
<th>mongo shell mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>{ “$oid”: “<id>“ }</id></td>
<td>ObjectId( “<id>“ )</id></td>
</tr>
</tbody>
</table>
<p><code>&lt;id&gt;是一个24字符的十六进制(hexadecimal)字符串</code></p>
<p><br><br><strong>DB Reference</strong></p>
<table>
<thead>
<tr>
<th>strict mode</th>
<th>mongo shell mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>{ “$ref”: “<name>“, “$id”: “<id>“ }</id></name></td>
<td>DBRef(“<name>“, “<id>“)</id></name></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;name&gt;是一个有效的JSON字符；</div><div class="line">&lt;id&gt;是任一extended JSON type。</div></pre></td></tr></table></figure>
<p><br><br><strong>Undefined Type</strong></p>
<table>
<thead>
<tr>
<th>strict mode</th>
<th>mongo shell mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>{  “$undefined”: true }</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p><br><br><strong>MinKey/MaxKey</strong></p>
<table>
<thead>
<tr>
<th>strict mode</th>
<th>mongo shell mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>{ “$minkey”: 1 }</td>
<td>MinKey</td>
</tr>
<tr>
<td>{ “$maxkey”: 1 }</td>
<td>MaxKey</td>
</tr>
</tbody>
</table>
<p><br><br><strong>NumberLong</strong></p>
<table>
<thead>
<tr>
<th>strict mode</th>
<th>mongo shell mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>{ “$numberLong”: “<number>“ }</number></td>
<td>NumberLong( “number&gt;” )</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Number是一个64位有符号整数。必须使用&quot;，否则它将被解释为浮点数，从而导致损失精度；</div><div class="line">db.json.insert&#123;&#123; longquoted: NumberLong(&quot;12345678901234345&quot;) &#125;)</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<hr>
<h1 id="MongoDB安装"><a href="#MongoDB安装" class="headerlink" title="MongoDB安装"></a>MongoDB安装</h1><p>参考:</p>
<ul>
<li><a href="https://docs.mongodb.com/manual/administration/install-on-linux/" target="_blank" rel="external">https://docs.mongodb.com/manual/administration/install-on-linux/</a>;</li>
<li><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/" target="_blank" rel="external">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</a>;</li>
</ul>
<p>MongoDB有社区版(Community)和企业版(Enterprise)。社区版免费，企业版在商业方面收费。</p>
<p><br><br>MongoDB在仓库中提供官方支持的包，包含以下软件包：</p>
<table>
<thead>
<tr>
<th>Package</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>monogdb-org</td>
<td>将自动安装下面四个组件包</td>
</tr>
<tr>
<td>mongodb-org-server</td>
<td>包含<code>mongod</code>守护进程和相关配置和<code>init</code>脚本</td>
</tr>
<tr>
<td>mongodb-org-mongos</td>
<td>包含<code>mongos</code>守护进程</td>
</tr>
<tr>
<td>mongodb-org-shell</td>
<td>包含<code>mongo-shell</code></td>
</tr>
<tr>
<td>mongodb-org-tools</td>
<td>包含相关MongoDB工具，如<code>mongoimport</code>,<code>mongoexport</code>,<code>mongodump</code>,<code>mongorestore</code>…</td>
</tr>
</tbody>
</table>
<p><code>mongodb-org-server</code>包提供了一个<code>/etc/mongod.conf</code>配置文件来开始和初始化<code>mongod</code>。默认配置文件默认bind_ip为 <code>127.0.0.1</code>，当你有需要和副本集时请修改它。</p>
<p><br></p>
<h2 id="自建mongodb-repo仓库安装"><a href="#自建mongodb-repo仓库安装" class="headerlink" title="自建mongodb.repo仓库安装"></a>自建mongodb.repo仓库安装</h2><p>仓库地址：<a href="https://repo.mongodb.org" target="_blank" rel="external">https://repo.mongodb.org</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">vim /etc/yum.repos.d/mongodb34.repo</div><div class="line"><span class="comment">#编辑仓库</span></div><div class="line"></div><div class="line"></div><div class="line">[mongodb34]</div><div class="line">name=MongoDB34 Repository</div><div class="line">baseurl=https://repo.mongodb.org/yum/redhat/<span class="variable">$releasever</span>/mongodb-org/3.4/x86_64/</div><div class="line">gpgcheck=0</div><div class="line">enabled=1</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#安装mongodb</span></div><div class="line">yum install -y mongodb-org</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="下载rpm包安装"><a href="#下载rpm包安装" class="headerlink" title="下载rpm包安装"></a>下载rpm包安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /root/mongodb</div><div class="line">wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/3.4/x86_64/RPMS/mongodb-org-3.4.10-1.el7.x86_64.rpm</div><div class="line">wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/3.4/x86_64/RPMS/mongodb-xxx-3.4.10-1.el7.x86_64.rpm</div><div class="line"><span class="comment">#共五个包</span></div><div class="line"></div><div class="line"></div><div class="line">yum ./mongo-org*</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.0.tgz</div><div class="line"></div><div class="line">tar -axvf mongodb-linux-x86_64-rhel70-3.6.0.tgz -C ./</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#默认路径/usr/local</span></div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="开启mongodb"><a href="#开启mongodb" class="headerlink" title="开启mongodb"></a>开启mongodb</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#默认启动方式</span></div><div class="line">systemctl start mongod</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定配置文件启动</span></div><div class="line"><span class="comment">#注意修改配置文件里面的某些路径和名称，不然会和默认配置文件冲突</span></div><div class="line">mongod -f /etc/mongo_27018.conf</div><div class="line">mongod -f /etc/mongo_27019.conf</div><div class="line">``</div><div class="line"></div><div class="line"></div><div class="line">&lt;br&gt;</div><div class="line"><span class="comment">## 卸载mongodb</span></div><div class="line"></div><div class="line">```sh</div><div class="line">systemctl stop mongod</div><div class="line"></div><div class="line">yum remove $(rpm -qa | grep mongodb-org)</div><div class="line"></div><div class="line">rm -rf /var/<span class="built_in">log</span>/mongodb</div><div class="line">rm -rf /var/dbpath/mongo</div></pre></td></tr></table></figure>
<h2 id="mongodb异常关闭后"><a href="#mongodb异常关闭后" class="headerlink" title="mongodb异常关闭后"></a>mongodb异常关闭后</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#首先查看日志文件</span></div><div class="line">tail /var/<span class="built_in">log</span>/mongodb/mongod.log</div><div class="line"></div><div class="line"><span class="comment">#删除</span></div><div class="line">rm /var/run/mongodb/mongod.pid /var/db/mongodb/mongod.lock</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<hr>
<h1 id="MongoDB配置文件"><a href="#MongoDB配置文件" class="headerlink" title="MongoDB配置文件"></a>MongoDB配置文件</h1><p>MongoDB的配置文件格式使用了YAML格式。<br><a href="https://zh.wikipedia.org/wiki/YAML" target="_blank" rel="external">YAML维基百科</a>，Yet Another Markup Language。强调以数据为中心，而不是标记语言为重点，用方向缩略语重命名。</p>
<p><br><br>默认配置文件<code>/etc/mongod.conf</code> 的几个大块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">systemLog:        #日志</div><div class="line"></div><div class="line">storage:          #存储</div><div class="line"></div><div class="line">processManagement:        #进程管理</div><div class="line"></div><div class="line">net:        #网络</div><div class="line"></div><div class="line">security:        #安全</div><div class="line"></div><div class="line">operationProfiling:        #性能分析器</div><div class="line"></div><div class="line">replication:        #主从复制</div><div class="line"></div><div class="line">sharding:        #架构</div><div class="line"></div><div class="line">setParameter:        #自定义变量</div><div class="line"></div><div class="line">auditLog:        #检测日志</div><div class="line"></div><div class="line">snmp:        #简单网络管理协议</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="systemLog"><a href="#systemLog" class="headerlink" title="systemLog"></a>systemLog</h2><p>日志相关参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">systemLog:</div><div class="line">  verbosity: &lt;int&gt;                #日志级别，默认0,1-5均会包含debug信息</div><div class="line">  quiet: &lt;boolean&gt;                #安静，true时mongod将会减少日志的输出量</div><div class="line">  traceAllExceptions: &lt;boolean&gt;        #打印异常详细信息</div><div class="line">  syslogFacility:  &lt;string&gt;                #指定用于登录时信息到syslog Facility水平，前提是启用syslog</div><div class="line">  path:  &lt;string&gt;          #日志路径，默认情况下，MongoDB将覆盖现有的日志文件</div><div class="line">  logAppend: &lt;boolean&gt;        #mongod重启后，在现有日志后继续添加日志，否则备份当前日志，然后创建新日志</div><div class="line">  logRotate: rename|reopen        #日志轮询，防止一个日志文件特别大。rename重命名日志文件，默认值；reopen使用Linuxrotate特性，关闭并重新打开日志文件，前提为logAppend: true</div><div class="line">  destination: &lt;string&gt;        #日志输出目的地，可为file或syslog，若不指定，则会输出到 std out</div><div class="line">  timeStampFormat: &lt;string&gt;        #指定日志格式的时间戳，有 ctime, Iso869-utc, iso8691-local</div><div class="line">  component:            #为不同的组件指定各自的日志信息级别</div><div class="line">      accessControl:</div><div class="line">          verbosity: &lt;int&gt;</div><div class="line">      command:</div><div class="line">          verbosity: &lt;int&gt;</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h2><p>存储引擎相关参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">storage:</div><div class="line">  dbPath: &lt;string&gt;        #mongodb进程存储数据目录，此配置进队此mongod进程有效，你使用配置文件开启的mongod就可以指定额外的数据目录</div><div class="line">  indexBuildRetry:  &lt;boolean&gt;        #当构件索引时mongod意外关闭，那么在此启动是否重建索引，默认true</div><div class="line">  repairPath: &lt;string&gt;        #在repair期间使用此目录存储临时数据，repair结束后此目录下数据将被删除</div><div class="line">  journal:</div><div class="line">      enabled: &lt;boolean&gt;        #journal日志持久存储，journal日志用来数据恢复，通常用于故障恢复，建议开启</div><div class="line">      commitIntervalMs: &lt;num&gt;        #mongod日志刷新值，范围1-500毫秒，默认100，不建议修改</div><div class="line">  directoryPerDB:  &lt;boolean&gt;        #是否将不同的数据存储在不同的目录中，dbPath子目录</div><div class="line">  syncPeriodSecs:  &lt;int&gt;        #fsync操作将数据flush到磁盘的时间间隔，默认为60秒，不建议修改</div><div class="line">  engine:  &lt;string&gt;        #存储引擎</div><div class="line"></div><div class="line">  mmapv1:    #mmapv1存储引擎，3.2前默认</div><div class="line">      preallocDataFiles:  &lt;boolean&gt;</div><div class="line">      nsSize: &lt;int&gt;</div><div class="line">      quota:</div><div class="line">          enforced: &lt;boolean&gt;</div><div class="line">          maxFilesPerDB: &lt;int&gt;</div><div class="line">      smallFiles: &lt;boolean&gt;</div><div class="line">      journal:</div><div class="line">          debugFlags: &lt;int&gt;</div><div class="line">          commitIntervalMs: &lt;num&gt;</div><div class="line">  wiredTiger:    #WiredTiger存储引擎，3.2后默认</div><div class="line">      engineConfig:</div><div class="line">          cacheSizeGB: &lt;number&gt;    #最大缓存大小</div><div class="line">          journalCompressor: &lt;string&gt;    #日志压缩算法，可选值有 none，snappy(默认)，zlib</div><div class="line">          directoryForIndexes: &lt;boolean&gt;    #是否将索引和collections数据分别存储在dbPath单独的目录中</div><div class="line">      collectionConfig:</div><div class="line">          blockCompressor: &lt;string&gt;    #collection数据压缩算法，可选none, snappy，zlib</div><div class="line">      indexConfig:</div><div class="line">          prefixCompression: &lt;boolean&gt;    #是否对索引数据使用前缀压缩。对那些经过排序的值存储有很大帮助，可有效减少索引数据的内存使用量。</div><div class="line">  inMemory:    #inMemory内存存储引擎，bate版</div><div class="line">      engineConfig:</div><div class="line">          inMemorySizeGB: &lt;number&gt;</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="processManagement"><a href="#processManagement" class="headerlink" title="processManagement"></a>processManagement</h2><p>进程相关参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">processManagement:</div><div class="line">  fork: &lt;boolean&gt;        #是否以fork模式运行mongod进程，默认情况下，mongod不作为守护进程运行</div><div class="line">  pidFilePath: &lt;string&gt;        #将mongod进程ID写入指定文件，如未指定，将不会创建PID文件</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><p>网络相关参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">net:</div><div class="line">  prot: &lt;int&gt;    #监听端口，默认27017</div><div class="line">  bindIp: &lt;string&gt;    #绑定IP，如果此值是“0.0.0.0”则绑定所有接口</div><div class="line">  maxIncomingConnections: &lt;int&gt;    #mongod进程允许的最大连接数，如果此值超过系统配置的连接数阈值，将不会生效(ulimit)</div><div class="line">  wireObjectCheck: &lt;boolean&gt;    #当客户端写入数据时，检查数据的有效性（BSON）。如果数据格式不良，update,insert等操作将会被拒绝</div><div class="line">  ipv6: &lt;boolean&gt;    #是否支持多实例之间使用ipv6</div><div class="line">  unixDomainSocker:    #适用于Unix系统</div><div class="line">      enabled: &lt;boolean&gt;</div><div class="line">      pathPrefix: &lt;string&gt;</div><div class="line">      filePermissions: &lt;int&gt;</div><div class="line">  http:    #</div><div class="line">      enabled: &lt;boolean&gt;</div><div class="line">      JSONEnabled: &lt;boolean&gt;</div><div class="line">      RESTInterfaceEnabled: &lt;boolean&gt;</div><div class="line">  ssl:</div><div class="line">      sslOnNormalPorts: &lt;boolean&gt;</div><div class="line">      mode: &lt;string&gt;</div><div class="line">      PEMKeyFile: &lt;string&gt;</div><div class="line">      PEMKeyPassword: &lt;string&gt;</div><div class="line">      clusterFile: &lt;string&gt;</div><div class="line">      clusterPassword: &lt;string&gt;</div><div class="line">      CAFile: &lt;string&gt;</div><div class="line">      CRLFile: &lt;string&gt;</div><div class="line">      allowConnectionsWithoutCertificates: &lt;boolean&gt;</div><div class="line">      allowInvalidCertificates: &lt;boolean&gt;</div><div class="line">      allowInvalidHostnames: &lt;boolean&gt;</div><div class="line">      disabledProtocols: &lt;string&gt;</div><div class="line">      FIPSMode: &lt;boolean&gt;</div><div class="line">  compression:</div><div class="line">      compressors: &lt;string&gt;</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="security"><a href="#security" class="headerlink" title="security"></a>security</h2><p>安全相关参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">security:</div><div class="line">  authorization: enabled    #MondoDB认证功能</div><div class="line">  keyFile: /path/mongo.key    #MongoDB副本集节点身份验证密钥文件</div><div class="line">  clusterAuthMode: &lt;string&gt;    #集群members间的认证模式</div><div class="line">  transitionToAuth: &lt;boolean&gt;</div><div class="line">   javascriptEnabled:  &lt;boolean&gt;    #是否允许执行JavaScript脚本</div><div class="line">   redactClientLogData: &lt;boolean&gt;</div><div class="line">   sasl:</div><div class="line">      hostName: &lt;string&gt;</div><div class="line">      serviceName: &lt;string&gt;</div><div class="line">      saslauthdSocketPath: &lt;string&gt;</div><div class="line">   enableEncryption: &lt;boolean&gt;</div><div class="line">   encryptionCipherMode: &lt;string&gt;</div><div class="line">   encryptionKeyFile: &lt;string&gt;</div><div class="line">   kmip:</div><div class="line">      keyIdentifier: &lt;string&gt;</div><div class="line">      rotateMasterKey: &lt;boolean&gt;</div><div class="line">      serverName: &lt;string&gt;</div><div class="line">      port: &lt;string&gt;</div><div class="line">      clientCertificateFile: &lt;string&gt;</div><div class="line">      clientCertificatePassword: &lt;string&gt;</div><div class="line">      serverCAFile: &lt;string&gt;</div><div class="line">   ldap:</div><div class="line">      servers: &lt;string&gt;</div><div class="line">      bind:</div><div class="line">         method: &lt;string&gt;</div><div class="line">         saslMechanism: &lt;string&gt;</div><div class="line">         queryUser: &lt;string&gt;</div><div class="line">         queryPassword: &lt;string&gt;</div><div class="line">         useOSDefaults: &lt;boolean&gt;</div><div class="line">      transportSecurity: &lt;string&gt;</div><div class="line">      timeoutMS: &lt;int&gt;</div><div class="line">      userToDNMapping: &lt;string&gt;</div><div class="line">      authz:</div><div class="line">         queryTemplate: &lt;string&gt;</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="operationProfiling"><a href="#operationProfiling" class="headerlink" title="operationProfiling"></a>operationProfiling</h2><p>慢查询相关参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">operationProfiling:</div><div class="line">  slowOpThresholdMs: &lt;int&gt;    #数据库profiler判定一个操作是“慢查询”的时间阈值，单位毫秒。mongod会把慢查询记录到日志中，默认100ms</div><div class="line">  mode: &lt;string&gt;    #数据库profiler级别，操作的性能信息将会被写入日志文件中，可选值“off”--关闭profiling，“slowOp”--只包包含慢操作，“all”--记录所有操作</div><div class="line">  #数据库profiling会影响性能，建议只在性能调试阶段开启</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="replication"><a href="#replication" class="headerlink" title="replication"></a>replication</h2><p>副本集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">replication:</div><div class="line">  oplogSizeMB: &lt;int&gt;    #replication操作日志的最大尺寸，如果太小，secondary将不能通过oplog来同步数据，只能全量同步</div><div class="line">  replSetName: &lt;string&gt;    #副本集名称，副本集中所有的mongod实例都必须有相同的名字，Sharding分布式下，不同的sharding应该使用不同的repSetName</div><div class="line">  secondaryIndexPrefetch: &lt;string&gt;    #副本集中的secondary，从oplog中应用变更操作之前，将会先把索引加载到内存</div><div class="line">  enalbeMajorityReadConcern: &lt;boolean&gt;    #允许readConcern的级别为“majority”</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="sharding"><a href="#sharding" class="headerlink" title="sharding"></a>sharding</h2><p>分片相关参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sharding:</div><div class="line">  clusterRole: &lt;string&gt;    #在sharding集群中，此mongod实例可选的角色。configsvr,默认监听27019端口 和 shardsvr,默认监听27018端口</div><div class="line">  archiveMovedChunks: &lt;boolean&gt;    #当chunks因为“负载均衡”而迁移到其他节点时，mongod是否将这些chunks归档，并保存在dbPath/movechunk目录下，mongod不会删除moveChunk下的文件</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="setParameter"><a href="#setParameter" class="headerlink" title="setParameter"></a>setParameter</h2><p>自定义变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setParameter:</div><div class="line">  &lt;parameter1&gt;: &lt;value1&gt;</div><div class="line">  &lt;parameter2&gt;: &lt;value2&gt;</div><div class="line">  enableLocalhostAuthBypass: false    #栗子</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="auditLog"><a href="#auditLog" class="headerlink" title="auditLog"></a>auditLog</h2><p>审计相关参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">auditLog:</div><div class="line">  destination: &lt;string&gt;    #指定审计记录的输出方式，有syslog, console, file</div><div class="line">  format: &lt;string&gt;    #输出格式，有JSON 和 BSON</div><div class="line">  path: &lt;string&gt;    #如果审计时间输入为文件，那么就需要指定文件完整路径及文件名</div><div class="line">  filter: &lt;string&gt;    #过滤器，可限制审计系统记录的操作类型，该选项需要一个表单的查询文档的字符串表示形式</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<hr>
<h1 id="Mongo-Shell"><a href="#Mongo-Shell" class="headerlink" title="Mongo Shell"></a>Mongo Shell</h1><p><strong>mongo shell</strong>是一个交互式的JavaScript结构的MongoDB。使用mongo shell来查询和更新数据以及执行管理操作。</p>
<h2 id="mongo-shell基础知识"><a href="#mongo-shell基础知识" class="headerlink" title="mongo shell基础知识"></a>mongo shell基础知识</h2><h3 id="启动monso-shell"><a href="#启动monso-shell" class="headerlink" title="启动monso shell"></a>启动monso shell</h3><p>启动mongo shell前确保MongoDB实例正在运行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mongo [option] [db address] [.js]</div><div class="line"></div><div class="line"><span class="comment">#以默认配置启动</span></div><div class="line">mongo</div><div class="line"></div><div class="line"><span class="comment">#以特定配置启动</span></div><div class="line">mongo --port 27018</div><div class="line"></div><div class="line"><span class="comment">#连接远程mongo shell</span></div><div class="line">mongo --host <span class="variable">$host</span> --port <span class="variable">$port</span> -u <span class="variable">$user</span> -p <span class="variable">$passwd</span></div><div class="line"></div><div class="line">mongo &lt;db&gt;</div><div class="line">mongo &lt;host&gt;/&lt;db&gt;</div><div class="line">mongo &lt;hsot:port&gt;/&lt;db&gt;</div></pre></td></tr></table></figure>
<p><br><br><strong>.mongorc.js文件</strong><br>mongo shell开始运行时，mongo将在用户主目录下检查<code>.mongorc.js</code>的js文件。如果找到，mongo将在首次命令行之前解释执行.mongorc.js的内容。<br>如果你使用mongo shell执行一个js或表达式，无论是通过<code>mongo --eval</code>，或指定一个.js文件，mongo都将在js处理完成之后读取.mongorc.js文件。可使用 <code>--norc</code>选项禁止加载.mongorc.js。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ll /root/.mongorc.js</div><div class="line"><span class="comment"># -rw------- 1 root root 0 Dec 27  2016 /root/.mongorc.js</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="使用mongo-shell"><a href="#使用mongo-shell" class="headerlink" title="使用mongo shell"></a>使用mongo shell</h3><p>可能在启动mongo shell的时候会警告:</p>
<ul>
<li>WARNING: /sys/kernel/mm/transparent_hugepage/defrag is ‘always’. We suggest setting it to ‘never’.</li>
<li>WARNING: /sys/kernel/mm/transparent_hugepage/defrag is ‘always’. We suggest setting it to ‘never’</li>
<li>WARNING: Access control is not enabled for the database.</li>
</ul>
<p>hugepage(大内存页面)，是Linux操作系统一种管理内存的方式。和通常方式相比，hugepage模式下内存分配管理会有所差异。<br>MongoDB显然不希望这个特定被启用。<br>新版MongoDB增加了安全性设计，推荐用户创建使用数据库时进行验证。所以我们需要创建用户认证。</p>
<p>关闭hugepage:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vim /etc/rc.d/rc.local</div><div class="line"></div><div class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</div><div class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/defrag</div><div class="line"></div><div class="line">chmox a+x /etc/rc.d/rc.local</div></pre></td></tr></table></figure>
<p>创建用户认证:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;use admin</div><div class="line">&gt;db.createUser(</div><div class="line">&#123;</div><div class="line">	user: <span class="string">"zhang"</span>,</div><div class="line">    <span class="built_in">pwd</span>: <span class="string">"zhang"</span>,</div><div class="line">    roles: [&#123; role: <span class="string">"root"</span>, db: <span class="string">"admin"</span>&#125;]</div><div class="line">&#125;</div><div class="line">)</div><div class="line"></div><div class="line">mongo -u zhang -p zhang --authenticationDatabase admin</div><div class="line"><span class="comment">#或</span></div><div class="line">mongo</div><div class="line">use admin</div><div class="line">db.auth(<span class="string">"zhang"</span>, <span class="string">"1314520"</span>)</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mongo</div><div class="line"></div><div class="line"><span class="comment">#显示当前使用数据库</span></div><div class="line">&gt;db</div><div class="line"></div><div class="line"><span class="comment">#切换数据库</span></div><div class="line">&gt;use &lt;database&gt;</div><div class="line"></div><div class="line"><span class="comment">#查看所有数据库</span></div><div class="line">&gt;show dbs</div></pre></td></tr></table></figure>
<p><br><br>你可以切换到一个并不存在的数据库。当你第一次向数据库存储数据，如创建一个集合，MongoDB将自动创建数据库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">use nodb</div><div class="line"></div><div class="line">db.nocollestion.insert(&#123;x:1&#125;);</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="格式化打印结果"><a href="#格式化打印结果" class="headerlink" title="格式化打印结果"></a>格式化打印结果</h3><p><code>db.collection.find()</code>方法返回一个<code>cursor</code>(游标)。如果返回的游标未使用var关键字指定变量，则游标将自动迭代最多20次，以打印出与查询匹配的前20个<code>documents</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#在操作中添加`.pretty()`，以格式化打印结果</span></div><div class="line"><span class="comment">#使用.pretty显示结果很舒服</span></div><div class="line">db.collection.find().pretty()</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">print</span>()	<span class="comment">#无格式打印</span></div><div class="line">printjson() <span class="comment">#用JSON打印</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="mongo-shell中的多行操作"><a href="#mongo-shell中的多行操作" class="headerlink" title="mongo shell中的多行操作"></a>mongo shell中的多行操作</h3><p>mongo shell中如果你以<code>( , { , [</code>开始，那么知道你输入了对应的<code>) , } , ]</code>才算结束命令。</p>
<p><br></p>
<h3 id="Tab命令补全和键盘快捷键"><a href="#Tab命令补全和键盘快捷键" class="headerlink" title="Tab命令补全和键盘快捷键"></a>Tab命令补全和键盘快捷键</h3><p>mongo shell支持键盘快捷键，例如：</p>
<ul>
<li>使用 <code>上/下箭头</code> 进行历史命令切换；</li>
<li>使用 <code>Tab键</code> 自动补全命令。</li>
</ul>
<p><br></p>
<h3 id="mongo-shell批量操作"><a href="#mongo-shell批量操作" class="headerlink" title="mongo shell批量操作"></a>mongo shell批量操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mongo -u xxx -p xxx --authenticationDatabase=xxx &lt;&lt; EOF</div><div class="line">show dbs</div><div class="line">use zhang</div><div class="line">db.coll01.drop()</div><div class="line">db.coll02.update( &#123; _id: <span class="string">"xxx"</span> &#125;, &#123; name: <span class="string">"zhang"</span> &#125;)</div><div class="line">EOF</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="退出mongo-shell"><a href="#退出mongo-shell" class="headerlink" title="退出mongo shell"></a>退出mongo shell</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">quit()</div><div class="line"></div><div class="line"><span class="built_in">exit</span></div><div class="line"></div><div class="line">Ctrl+c</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="配置mongo-shell"><a href="#配置mongo-shell" class="headerlink" title="配置mongo shell"></a>配置mongo shell</h2><p>可在mongo shell中设置变量<code>prompt</code>的值来修改提示符内容。<br>prompt变量可以存储字符串以及JavaScript代码。</p>
<p>也可以在<code>.mongorc.js</code>文件中增加提示符的逻辑操作来设置每次启动mongo shell的提示符。</p>
<p><br></p>
<h3 id="自定义提示符"><a href="#自定义提示符" class="headerlink" title="自定义提示符"></a>自定义提示符</h3><p><strong>自定义提示符展示操作符：</strong></p>
<p>在mongo shell中定义一下变量。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cmdCount = 1;</div><div class="line">prompt = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> (cmdCount++) + <span class="string">'&gt; '</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#效果</span></div><div class="line">1&gt;</div><div class="line">2&gt;</div><div class="line">...</div></pre></td></tr></table></figure>
<p><br><br><strong>自定义提示符显示数据库和主机名：</strong></p>
<p>形式为：<database>@<hostname>$</hostname></database></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">host = db.serverStatus().host;</div><div class="line">prompt = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> db+<span class="string">'@'</span>+host+<span class="string">'$'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#效果</span></div><div class="line"><span class="built_in">test</span>@localhost$</div></pre></td></tr></table></figure>
<p><br><br><strong>自定义提示符展示服务器启动时间和文档数：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">prompt = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">			<span class="built_in">return</span> <span class="string">'Uptime:'</span> + db.serverStatus().uptime + <span class="string">'Documents:'</span> + db.stats().objects + <span class="string">'&gt; '</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#效果</span></div><div class="line">Uptime:1234 Documents:5 &gt;</div></pre></td></tr></table></figure>
<p><br><br><strong>注意：</strong><br>在mongo shell里面定义的<code>prompt</code>变量知识临时生效的，退出shell后便没有。<br>如果想要当前用户永久生效，可写入<code>~/.mongorc.js</code>文件。则此用户每次启动mongo shell前都会执行这个文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vim ~/.mongorc.js</div><div class="line"></div><div class="line">host = db.serverStatus().host;</div><div class="line">prompt = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">             <span class="built_in">return</span> db+<span class="string">"@"</span>+host+<span class="string">"&gt; "</span>;</div><div class="line">         &#125;</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="在mongo-shell中使用外部编辑器"><a href="#在mongo-shell中使用外部编辑器" class="headerlink" title="在mongo shell中使用外部编辑器"></a>在mongo shell中使用外部编辑器</h3><p>可在启动mongo shell之前设置<code>EDITOR</code>环境变量来在mongo shell中使用自己的编辑器。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> EDITOR=vim</div><div class="line">mongo</div><div class="line"></div><div class="line"><span class="comment">#edit &lt;variable&gt;|&lt;function&gt;</span></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">myfunc</span></span>()&#123;&#125;</div><div class="line"></div><div class="line">edit myfunc</div><div class="line"><span class="comment">#此时是edit使用vim编辑myfunc</span></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">myfunc</span></span>()&#123;</div><div class="line">	<span class="built_in">print</span>(<span class="string">"It was edited by vim!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">myfunc()</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="修改mongo-shell批处理大小"><a href="#修改mongo-shell批处理大小" class="headerlink" title="修改mongo shell批处理大小"></a>修改mongo shell批处理大小</h3><p><code>db.collection.find()</code>是一种JavaScript方法，返回一个<code>cursor</code>(游标)。如果返回的游标未使用var关键字指定变量，则游标将自动迭代最多20次，以打印出与查询匹配的前20个<code>documents</code>。<br>可以设置<code>DBQuery.shellBatchSize</code>属性来修改默认20篇文档。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DBQuery.shellBatchSize = 10;</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="获取mongo-shell帮助"><a href="#获取mongo-shell帮助" class="headerlink" title="获取mongo shell帮助"></a>获取mongo shell帮助</h2><p>合理运用<code>Tab键</code>补全命令！</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###命令行帮助</span></div><div class="line">mongo --<span class="built_in">help</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###mongo shell里查看帮助列表</span></div><div class="line"><span class="built_in">help</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###数据库帮助</span></div><div class="line"><span class="comment">#db.&lt;method&gt;</span></div><div class="line">show dbs</div><div class="line">db.help()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###集合帮助</span></div><div class="line"><span class="comment">#db.&lt;collection&gt;.&lt;method&gt;</span></div><div class="line">show collections</div><div class="line">db.collections.help()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###游标帮助</span></div><div class="line">db.collection.find().<span class="built_in">help</span>()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###封装对象帮助</span></div><div class="line"><span class="built_in">help</span> misc</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="给mongo-shell写脚本"><a href="#给mongo-shell写脚本" class="headerlink" title="给mongo shell写脚本"></a>给mongo shell写脚本</h2><p>可使用JavaScript为mongo shell编写脚本，用于处理MongoDB中的数据或执行管理操作。</p>
<p><br></p>
<h3 id="打开新连接"><a href="#打开新连接" class="headerlink" title="打开新连接"></a>打开新连接</h3><p>在mongo shell或JavaScript文件中，可使用<code>Mongo()</code>构造函数来实例化数据库连接：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">new Mongo()</div><div class="line">new Mongo(&lt;host&gt;)</div><div class="line">new Mongo(&lt;host:port&gt;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">conn = new Mongo();</div><div class="line">db = conn.getDB(<span class="string">'mydb'</span>);	<span class="comment">#将全局db变量设置为mydb</span></div><div class="line"></div><div class="line"><span class="comment">#连接</span></div><div class="line">db = connect(<span class="string">'localhost:27017/mydb'</span>);</div><div class="line"></div><div class="line"><span class="comment">#认证</span></div><div class="line">db.auth(&lt;user&gt;, &lt;passwd&gt;)</div><div class="line"></div><div class="line">db.auth(&#123;</div><div class="line">	user: &lt;user&gt;,</div><div class="line">    <span class="built_in">pwd</span>: &lt;passed&gt;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="交互式和脚本化mongo的区别"><a href="#交互式和脚本化mongo的区别" class="headerlink" title="交互式和脚本化mongo的区别"></a>交互式和脚本化mongo的区别</h3><p>mongo shell中的帮助与JavaScript中帮助不一样！</p>
<table>
<thead>
<tr>
<th>mongo shell帮助</th>
<th>JavaScript等量</th>
</tr>
</thead>
<tbody>
<tr>
<td>show dbs</td>
<td>db.adminCommand(‘listDatabases’)</td>
<td></td>
</tr>
<tr>
<td>use <db></db></td>
<td>db = db.getSiblingDB(‘<db>‘)</db></td>
<td></td>
</tr>
<tr>
<td>show collections</td>
<td>db.getCollectionNames()</td>
<td></td>
</tr>
<tr>
<td>show users</td>
<td>db.getUsers()</td>
<td></td>
</tr>
<tr>
<td>show log <logname></logname></td>
<td>db.adminCommand({‘getLog’ : ‘<logname>‘})</logname></td>
<td></td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>使用mongo shell来计算JavaScript的值。</p>
<p><br><br><strong>–eval <javascript></javascript></strong><br><code>mongo</code>执行 <code>--eval</code>后的js命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongo test --eval &quot;printjson(db.getCollectionNames())&quot;</div></pre></td></tr></table></figure>
<p><br><br><strong>执行JavaScript文件</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mongo localhost:27017/<span class="built_in">test</span> myjs.js</div><div class="line"></div><div class="line"><span class="comment">#在shell中执行.js</span></div><div class="line">&gt;load(<span class="string">"myjs.js"</span>)</div><div class="line">&gt;loca(<span class="string">"/root/mongo/myjs.js"</span>)</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="mongo-shell中的数据类型"><a href="#mongo-shell中的数据类型" class="headerlink" title="mongo shell中的数据类型"></a>mongo shell中的数据类型</h2><p>MongoDB BSON提供了除JSON之外的其它数据类型的支持。Driver提供了对这些数据类型在主机语言的本地化支持，mongo shell也提供了一些帮助类来支持这些数据类型在mongo javascript shell中的使用。</p>
<p><br></p>
<h3 id="日期-1"><a href="#日期-1" class="headerlink" title="日期"></a>日期</h3><p>mongo shell提供了多种方法返回日期:</p>
<ul>
<li><code>Date()</code> 方法返回当前日期为一个字符串；</li>
<li><code>new Date()</code> 构造函数返回一个使用ISODate()包装返回的Date对象；</li>
<li><code>ISODate()</code> 构造函数返回一个使用ISODate()包装返回的Date对象。</li>
</ul>
<p><br><br>返回一个日期为字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myDateString = Date();</div><div class="line">#查看变量值</div><div class="line">myDateString</div></pre></td></tr></table></figure>
<p><br><br>验证类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typeof myDateString()</div><div class="line">#string</div></pre></td></tr></table></figure>
<p><br><br>返回Date：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var myDate = new Date();</div><div class="line">myDate</div><div class="line">#ISODate(&quot;2017-12-12T08:43:31.405Z&quot;)</div><div class="line"></div><div class="line">#验证</div><div class="line">myDate instanceof Date</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="ObjectId-1"><a href="#ObjectId-1" class="headerlink" title="ObjectId"></a>ObjectId</h3><p>mongo shell对objectid数据类型提供objectId()包装类。</p>
<p><code>new ObjectId</code></p>
<p><br></p>
<h3 id="NumberLong"><a href="#NumberLong" class="headerlink" title="NumberLong"></a>NumberLong</h3><p>mongo shell默认将所有数字处理为浮点值。</p>
<p>用<code>numberlong()</code>包装来处理64位整数。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NumberLong(<span class="string">"2090845886852"</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="NumberInt"><a href="#NumberInt" class="headerlink" title="NumberInt"></a>NumberInt</h3><p>用<code>NumberInt()</code>构造函数来显式指定32位整数。</p>
<p><br></p>
<h3 id="NumberDecimal"><a href="#NumberDecimal" class="headerlink" title="NumberDecimal"></a>NumberDecimal</h3><p><code>mongo shell</code>默认将所有的数字处理为64位浮点的<code>double</code>值。<code>mongo shell</code>提供了<code>NumberDecimal()</code>构造函数限制指定128位基于十进制的浮点值，能够以精确的精度仿效十进制近似值。<br>这个功能在金融、税务以及科学计算等方面应用。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;NumberDecimal(<span class="string">'1000.55'</span>)</div><div class="line"><span class="comment">#强烈建议加上引号，没加引号可能会存在精度丢失的情况</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>###　在mongo shell中检查类型</p>
<p><code>instanceof</code>返回一个bool值来验证一个值是否为某些类型的实例。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mydoc._id instanceof ObjectId</div><div class="line"><span class="comment">#true</span></div></pre></td></tr></table></figure>
<p><code>typeof</code>返回一个字段的类型。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typeof mydoc._id</div><div class="line"><span class="comment">#object</span></div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="mongo-shell快速参考"><a href="#mongo-shell快速参考" class="headerlink" title="mongo shell快速参考"></a>mongo shell快速参考</h2><h3 id="mongo-shell-历史命令"><a href="#mongo-shell-历史命令" class="headerlink" title="mongo shell 历史命令"></a>mongo shell 历史命令</h3><p>mongo shell历史命令保存在<code>~/.dbshell</code>文件中，<code>cat ~/.dbshell</code>。也可以使用<strong>上/下键</strong>切换历史命令。</p>
<p><br></p>
<h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><table>
<thead>
<tr>
<th>option</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--help</code></td>
<td>显示命令行选项</td>
</tr>
<tr>
<td><code>--nodb</code></td>
<td>启动mongo shell而不连接到数据库</td>
</tr>
<tr>
<td><code>--shell</code></td>
<td>执行文件后运行mongo shell</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="mongo-shell命令助手"><a href="#mongo-shell命令助手" class="headerlink" title="mongo shell命令助手"></a>mongo shell命令助手</h3><table>
<thead>
<tr>
<th>help methods and commands</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>help</code></td>
<td>显示帮助</td>
</tr>
<tr>
<td><code>db.help</code></td>
<td>显示数据库方法的帮助</td>
</tr>
<tr>
<td><code>db.collection.help()</code></td>
<td>显示集合方法的帮助</td>
</tr>
<tr>
<td><code>show dbs</code></td>
<td>打印服务器上的所有数据库列表</td>
</tr>
<tr>
<td><code>show databases</code></td>
<td>打印所有可获取的数据库列表</td>
</tr>
<tr>
<td><code>use &lt;db&gt;</code></td>
<td>切换数据库</td>
</tr>
<tr>
<td><code>show collections</code></td>
<td>打印当前数据库上的所有集合列表</td>
</tr>
<tr>
<td><code>show users</code></td>
<td>打印当前数据库的用户列表</td>
</tr>
<tr>
<td><code>show roles</code></td>
<td>打印当前数据库的所有角色(user-define and built-in)列表</td>
</tr>
<tr>
<td><code>show profile</code></td>
<td>打印花费1ms或更多时间的五个最近的操作</td>
</tr>
<tr>
<td><code>load()</code></td>
<td>在shell中执行一个JavaScript文件，建议使用绝对路径</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="mongo-shell的基本JavaScript操作"><a href="#mongo-shell的基本JavaScript操作" class="headerlink" title="mongo shell的基本JavaScript操作"></a>mongo shell的基本JavaScript操作</h3><p>mongo shell为数据库操作提供了一个JavaScript API。<br>db引用当的是前数据库的变量。</p>
<table>
<thead>
<tr>
<th>JavaScript db-operation</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>db.auth()</code></td>
<td>在安全模式下认证用户</td>
</tr>
<tr>
<td><code>coll = db.&lt;collection&gt;</code></td>
<td>将当前db中的特定collection设置为coll，可在此变量上执行操作，如<code>coll.find();</code></td>
</tr>
<tr>
<td><code>db.collection.find()</code></td>
<td>查找集合中的所有文档，并返回一个游标</td>
</tr>
<tr>
<td><code>db.collection.insert()</code></td>
<td>插入一个新文档到集合中</td>
</tr>
<tr>
<td><code>db.collection.update()</code></td>
<td>更新集合中一个存在的文档</td>
</tr>
<tr>
<td><code>db.collection.save()</code></td>
<td>插入或更新 集合中的文档</td>
</tr>
<tr>
<td><code>db.collection.remove()</code></td>
<td>从集合中删除文档</td>
</tr>
<tr>
<td><code>db.collection.drop()</code></td>
<td>删除整个集合</td>
</tr>
<tr>
<td><code>db.collection.createIndex()</code></td>
<td>在集合中创建索引</td>
</tr>
<tr>
<td><code>db.getSiblingDB()</code></td>
<td>跨数据库查询</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="键盘快捷键"><a href="#键盘快捷键" class="headerlink" title="键盘快捷键"></a>键盘快捷键</h3><table>
<thead>
<tr>
<th>keysrtoke</th>
<th>function</th>
</tr>
</thead>
<tbody>
<tr>
<td>Up/Down arrow</td>
<td>前/后 历史命令</td>
</tr>
<tr>
<td>Left/Right arrow</td>
<td>左右移动</td>
</tr>
<tr>
<td>Home/End</td>
<td>行首/行尾</td>
</tr>
<tr>
<td>Tab</td>
<td>自动补全</td>
</tr>
<tr>
<td>ctrl+c</td>
<td>退出</td>
</tr>
<tr>
<td>ctrl+L</td>
<td>清屏</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="mongo-shell查询方法"><a href="#mongo-shell查询方法" class="headerlink" title="mongo shell查询方法"></a>mongo shell查询方法</h3><p>在mongo shell中，使用<code>find()</code>和<code>findOne()</code>方法执行读操作。</p>
<table>
<thead>
<tr>
<th>read-operations</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>db.collection.find(&lt;query&gt;)</code></td>
<td>查找集合中与<query>匹配的文档，如果未指定<query>或为空，则读取操作会选择集合中的所有文档</query></query></td>
</tr>
<tr>
<td><code>db.collection.find(&lt;query&gt;, &lt;projection&gt;)</code></td>
<td>查找与<query>匹配的文档，返回<projection>特定字段</projection></query></td>
</tr>
<tr>
<td><code>db.collection.find().sort(&lt;sort order&gt;)</code></td>
<td>返回<sort order="">排序结果</sort></td>
</tr>
<tr>
<td><code>db.collection.find(&lt;query&gt;).sort(&lt;sort order&gt;)</code></td>
<td>返回匹配<query>和<sort order="">排序结果</sort></query></td>
</tr>
<tr>
<td><code>db.collection.find(...).limit(&lt;n&gt;)</code></td>
<td>限制输出结果为<n>行</n></td>
</tr>
<tr>
<td><code>db.collection.find().pretty().limit()</code></td>
<td>匹配，格式化，限制输出</td>
</tr>
<tr>
<td><code>db.collection.find().limit().pretty()</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>db.collection.find(...).skip(&lt;n&gt;)</code></td>
<td>跳过前<n>行</n></td>
</tr>
<tr>
<td><code>db.collection.count()</code></td>
<td>返回集合中文档总数</td>
</tr>
<tr>
<td><code>db.collection.find().count()</code></td>
<td>返回匹配文档总数</td>
</tr>
<tr>
<td><code>db.collection.findOne(&lt;query&gt;)</code></td>
<td>查找并返回单一的文档，null表示未找到</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="管理命令助手"><a href="#管理命令助手" class="headerlink" title="管理命令助手"></a>管理命令助手</h3><table>
<thead>
<tr>
<th>js db-administrative-methods</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>db.cloneDatabase(&lt;host&gt;)</code></td>
<td>从指定主机克隆当前数据库，noauth mode</td>
</tr>
<tr>
<td><code>db.copyDatabase(&lt;from&gt;, &lt;to&gt;, &lt;host&gt;)</code></td>
<td>copy <from>db to <to>db</to></from></td>
</tr>
<tr>
<td><code>db.fromColl.renameCollection(&lt;toColl&gt;)</code></td>
<td>rename collection</td>
</tr>
<tr>
<td><code>db.repairDatabase()</code></td>
<td>修复当前db</td>
</tr>
<tr>
<td><code>db.dropDatabases()</code></td>
<td>删除当前数据库</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="打开附加连接"><a href="#打开附加连接" class="headerlink" title="打开附加连接"></a>打开附加连接</h3><p>可以在mongo shell中创建一个新连接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;db = connect(<span class="string">"&lt;host&gt;:&lt;port&gt;/&lt;db&gt;"</span>)</div><div class="line">#db = connect("192.168.1.11/admin")</div><div class="line"></div><div class="line">&gt;conn = <span class="keyword">new</span> Mongo()</div><div class="line">&gt;db = conn.getDB(<span class="string">"dbname"</span>)</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<hr>
<h1 id="MongoDB-CRUD操作"><a href="#MongoDB-CRUD操作" class="headerlink" title="MongoDB CRUD操作"></a>MongoDB CRUD操作</h1><p><code>CRUD</code>操作就是<em>创建(create)，读取(read)，更新(update)，删除(delete)</em>文档(document)!</p>
<p><br><br><strong>创建(create)操作</strong><br>创建或插入， 即是向 collection 添加新的 document。如果插入时集合不存在，插入操作会创建该集合。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.collection.insert()</div><div class="line">db.collection.insertOne()</div><div class="line">db.collection.insertMany()</div></pre></td></tr></table></figure>
<p><br><br><strong>读取(read)操作</strong><br>读操作，获取 collection 中的 document。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.collection.find()</div></pre></td></tr></table></figure>
<p><br><br><strong>更新(update)操作</strong><br>更新操作，修改 collection 中已经存在的 document。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.collection.update()</div><div class="line">db.collection.updateOne()</div><div class="line">db.collection.updateMany()</div><div class="line">db.collection.replaceOne()</div></pre></td></tr></table></figure>
<p><br><br><strong>删除(delete)操作</strong><br>删除操作，是从一个 collection 中删除 document 的操作。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.collection.remove()</div><div class="line">db.collection.deleteOne()</div><div class="line">db.collection.deleteMany()</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="插入文档-Insert"><a href="#插入文档-Insert" class="headerlink" title="插入文档(Insert)"></a>插入文档(Insert)</h2><p><br></p>
<h3 id="插入方法"><a href="#插入方法" class="headerlink" title="插入方法"></a>插入方法</h3><p>MongoDB提供了如下插入方法向collection中插入document：</p>
<ul>
<li><code>db.collection.insert()</code>, 向集合中插入一个或多个文档;</li>
<li><code>db.collection.insertOne()</code>, 向集合中插入一个文档;</li>
<li><code>db.collection.insertMany()</code>, 向集合中插入多个文档.</li>
</ul>
<p><br></p>
<h4 id="db-collection-insert"><a href="#db-collection-insert" class="headerlink" title="db.collection.insert()"></a>db.collection.insert()</h4><p><code>db.collection.insert()</code>,向collection中插入一个或多个document。<br>要想插入一个document，传递<strong>一个文档</strong>给该方法；要想插入多个documents，传递<strong>文档数组</strong>给该方法。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#插入一个文档</span></div><div class="line">db.user.insert(</div><div class="line">	&#123;</div><div class="line">    	_id: <span class="string">"ZhangTest"</span>,</div><div class="line">    	name: <span class="string">"zhang"</span>,</div><div class="line">        age: 2017,</div><div class="line">        sex: <span class="string">"man"</span></div><div class="line">    &#125;</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#插入多个文档</span></div><div class="line">db.user.insert(</div><div class="line">	[</div><div class="line">    	&#123; name: <span class="string">"AAA"</span>, age: 20, status: <span class="string">"A"</span> &#125;,</div><div class="line">        &#123; name: <span class="string">"BBB"</span>, age: 21, status: <span class="string">"B"</span> &#125;,</div><div class="line">        &#123; name: <span class="string">"CCC"</span>, age: 22, status: <span class="string">"C"</span> &#125;</div><div class="line">    ]</div><div class="line">)</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="db-collection-insertOne"><a href="#db-collection-insertOne" class="headerlink" title="db.collection.insertOne()"></a>db.collection.insertOne()</h4><p><code>db.collection.insertOne()</code>,向collection中插入单个document。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">db.user.insertOne(</div><div class="line">	&#123;</div><div class="line">		name: <span class="string">"zhang"</span>,</div><div class="line">        age: <span class="string">"2017"</span>,</div><div class="line">        sex: <span class="string">"man"</span>,</div><div class="line">        education: <span class="string">"bachelor"</span></div><div class="line">	&#125;</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">#此处并未自定义_id字段，因此它会自动添加_id字段</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="db-collection-insertMany"><a href="#db-collection-insertMany" class="headerlink" title="db.collection.insertMany()"></a>db.collection.insertMany()</h4><p><code>db.collection.insertMany()</code>,向collection插入多个documents。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.user.insertMany(</div><div class="line">	[</div><div class="line">    	&#123; name: <span class="string">"AAA"</span>, age: <span class="string">"20"</span>, status: <span class="string">"A"</span> &#125;,</div><div class="line">        &#123; name: <span class="string">"BBB"</span>, age: <span class="string">"21"</span>, status: <span class="string">"B"</span> &#125;,</div><div class="line">        &#123; name: <span class="string">"CCC"</span>, age: <span class="string">"22"</span>, status: <span class="string">"C"</span> &#125;</div><div class="line">    ]</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">#自动生成3个document的_id字段</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="插入操作的行为表现"><a href="#插入操作的行为表现" class="headerlink" title="插入操作的行为表现"></a>插入操作的行为表现</h3><p><strong>创建集合</strong><br>插入的时候如果collection不存在，那么插入操作会创建collection。</p>
<p><strong>_id字段</strong><br>在MongoDB中，存储于collection中的每一个document都需要一个唯一的<code>_id</code>字段作为<code>primary_key</code>。如果一个插入的document操作遗漏了<code>_id</code>字段，则<code>MongoDB driver</code>会自动生成一个<code>ObjectId</code>。</p>
<p><strong>原子性</strong><br>MongoDB中所有的写操作在单一文档层级上是原子的。</p>
<p><br><br><br></p>
<h2 id="查询文档-Read"><a href="#查询文档-Read" class="headerlink" title="查询文档(Read)"></a>查询文档(Read)</h2><p>MongoDB提供了<code>db.collection.find()</code>方法从collection中读取document。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.collection.find( &lt;query filter&gt;, &lt;projection&gt; )</div><div class="line"></div><div class="line"><span class="comment">#&lt;query filter&gt;指明返回哪些document</span></div><div class="line"><span class="comment">#&lt;projection&gt;指明返回匹配document的那些filed</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">db.user.insertMany(</div><div class="line">  [</div><div class="line">  	&#123;</div><div class="line">		_id: 1,</div><div class="line">		name: <span class="string">"A"</span>,</div><div class="line">		favorites: &#123; artist: <span class="string">"Picasso"</span>, food: <span class="string">"pizza"</span> &#125;,</div><div class="line">        finished: [ 11, <span class="string">"AA"</span> ],</div><div class="line">        points: [ &#123; points: 85, bonus: 30 &#125;, &#123; points: 85, bonus: 10 &#125; ]</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">    	_id: 2,</div><div class="line">        name: <span class="string">"B"</span>,</div><div class="line">    	favorites: &#123; artist: <span class="string">"Miro"</span>, food: <span class="string">"merigue"</span> &#125;,</div><div class="line">        finished: [ 22, <span class="string">"BB"</span> ],</div><div class="line">        points: [ &#123; points: 85, bonus: 20 &#125;, &#123; points: 64, bonus: 12 &#125; ]</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">    	_id: 3,</div><div class="line">        name: <span class="string">"C"</span>,</div><div class="line">        favorites: &#123; artist: <span class="string">"Gaogeng"</span>, food: <span class="string">"cake"</span> &#125;,</div><div class="line">        finished: [ 33, <span class="string">"CC"</span> ],</div><div class="line">        points: [ &#123; points: 67, bonus: 8 &#125;, &#123; points: 55, bonus: 21 &#125; ]</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">)</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="查询和规划操作符"><a href="#查询和规划操作符" class="headerlink" title="查询和规划操作符"></a>查询和规划操作符</h3><p><strong>Comparison:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$eq</div><div class="line">$gt</div><div class="line">$gte</div><div class="line">$lt</div><div class="line">$ne</div><div class="line">$in</div><div class="line">$nin</div></pre></td></tr></table></figure>
<p><strong>Logical：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$or</div><div class="line">$and</div><div class="line">$not</div><div class="line">$nor</div></pre></td></tr></table></figure>
<p><strong>Element:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$exists</div><div class="line">$type</div></pre></td></tr></table></figure>
<p><strong>Evaluation:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$mod</div><div class="line">$regex</div><div class="line">$text</div><div class="line">$where</div></pre></td></tr></table></figure>
<p><strong>Geospatial:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$geoWithin</div><div class="line">$geoIntersects</div><div class="line">$near</div><div class="line">$nearSphere</div></pre></td></tr></table></figure>
<p><strong>Array:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$all</div><div class="line">$eleMatch</div><div class="line">$size</div></pre></td></tr></table></figure>
<p><strong>Bitwise:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$bitsAllSet</div><div class="line">$bitsAnySet</div><div class="line">$bitsAllClear</div><div class="line">$bitsAnyClear</div></pre></td></tr></table></figure>
<p><strong>Comments:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$comment</div></pre></td></tr></table></figure>
<p><strong>Projection Operators:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$</div><div class="line">$eleMatch</div><div class="line">$meta</div><div class="line">$slice</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="选择collectino中所有document"><a href="#选择collectino中所有document" class="headerlink" title="选择collectino中所有document"></a>选择collectino中所有document</h4><p>一个空的<code>query filter</code>会选择集合汇总所有文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.users.find(&#123;&#125;)</div><div class="line">db.user.find()</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="指定查询过滤条件"><a href="#指定查询过滤条件" class="headerlink" title="指定查询过滤条件"></a>指定查询过滤条件</h4><p><strong>1. 指定等于条件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; &lt;field1&gt;: &lt;value1&gt;, ...&#125;</div><div class="line"></div><div class="line">#栗子</div><div class="line">db.user.find( &#123; name: &quot;C&quot; &#125; )</div></pre></td></tr></table></figure>
<p><strong>2. 使用查询操作符指定条件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; &lt;field1&gt;: &#123; &lt;operator1&gt;: &lt;value1&gt; &#125;, ... &#125;</div><div class="line"></div><div class="line">#栗子</div><div class="line">db.user.find( &#123; name: &#123; $in: [ &quot;A&quot;, &quot;B&quot; ] &#125; &#125; )</div></pre></td></tr></table></figure>
<p><strong>3. 指定逻辑查询条件条件</strong><br>逻辑查询(AND, OR, NOT)。符合查询可以在集合文档的多个字段上指定条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#AND</div><div class="line">db.user.find( &#123; name: &quot;A&quot;, age: &#123; $lt: 30&#125; &#125; )</div><div class="line"></div><div class="line"></div><div class="line">#OR</div><div class="line">db.user.find( &#123;</div><div class="line">	$or: [ &#123; name: &quot;A&quot; &#125;, &#123; age: &#123; $lt: 30 &#125; &#125; ]</div><div class="line">&#125; )</div><div class="line"></div><div class="line"></div><div class="line">#AND和OR</div><div class="line">db.user.find( &#123;</div><div class="line">	name: &quot;A&quot;,</div><div class="line">    $or: [ &#123;age: &#123; $lt: 30 &#125; &#125;, &#123; type: 1 &#125; ]</div><div class="line">&#125; )</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="嵌入式文档的查询"><a href="#嵌入式文档的查询" class="headerlink" title="嵌入式文档的查询"></a>嵌入式文档的查询</h4><p>当字段中包含嵌入文档时，查询可以指定嵌入文档中的精确匹配或使用<code>圆点(.)表示法</code>对嵌入文档的单个字段指定匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#精确匹配</div><div class="line">db.user.find(&#123;</div><div class="line">	favorites: &#123; artist: &quot;Picasso&quot;, food: &quot;pizza&quot; &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">#圆点.表示法，记得加引号</div><div class="line">db.user.find( &#123; &quot;favorites.artist&quot;: &quot;Picasso&quot; &#125; )</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="数组上的查询"><a href="#数组上的查询" class="headerlink" title="数组上的查询"></a>数组上的查询</h4><p>当字段包含数组，可查询精确的匹配数组或数组中特定的值。如果数组包含嵌入文档，可使用<code>圆点表示法</code>查询内嵌文档中特定的字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#精确匹配</div><div class="line">db.user.find(&#123; finished: [ 11, &quot;AA&quot; ] &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#匹配一个数组元素，会显示整个文档</div><div class="line">db.user.find(&#123; finished: &quot;BB&quot; &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#匹配数组中指定元素，会返回整个文档</div><div class="line">db.user.find(&#123; &quot;finished.1&quot;: &quot;CC&quot; &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#指定数组中的多个查询条件</div><div class="line">db.user.find(&#123; finished: &#123; $elemMatch: &#123;$gte: 11, $lt: 33&#125; &#125; &#125;)</div><div class="line"></div><div class="line">db.user.find(&#123; finished: &#123; $gt: 11, $lt: 33 &#125; &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#嵌入文档数组</div><div class="line">db.user.find(&#123; &apos;points.points&apos;: &#123;$lte: 80 &#125; &#125;)</div><div class="line">db.user.find(&#123; &quot;points.0.points&quot;: &#123;$lte: 80&#125; &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#元素组合满足查询条件</div><div class="line">db.user.find(&#123;</div><div class="line">	&quot;points.points&quot;: &#123;$lte: 80&#125;, &quot;points.bouns&quot;: 20</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="返回查询的映射字段"><a href="#返回查询的映射字段" class="headerlink" title="返回查询的映射字段"></a>返回查询的映射字段</h3><p>默认地，MongoDB中的查询返回匹配文档中的所有字段。为了限制MongoDB发送给应用的数据量，我们可以在查询操作中包括一个<code>projection</code>文档。</p>
<p><br></p>
<h4 id="映射文档"><a href="#映射文档" class="headerlink" title="映射文档"></a>映射文档</h4><p>映射文档限制了返回所有匹配文档的字段。映射文档可以致命包括哪些字段或排除哪些字段。<br>这个就很不错了，可以过滤掉我们不需要的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.users.find( &#123;name: &quot;AAA&quot;&#125; ,&#123;_id: 0, name: 1, age: ture&#125; )</div><div class="line">db.user.find( &#123; name: &quot;BBB&quot;&#125;, &#123;_id: false&#125; )</div><div class="line"></div><div class="line">1或true，表示在返回的文档中包含字段；</div><div class="line">0或false，排除该字段；</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="更新文档-Update"><a href="#更新文档-Update" class="headerlink" title="更新文档(Update)"></a>更新文档(Update)</h2><p><strong>更新方法：</strong></p>
<ul>
<li><code>db.collection.updateOne()</code>, 更新一个文档</li>
<li><code>db.collection.updateMany()</code>, 更新多个文档</li>
<li><code>db.replaceOne()</code>, 替换一个文档</li>
<li><code>db.collection.update()</code>, 更新或替换一个文档</li>
</ul>
<p><br></p>
<h3 id="更新的行为表现"><a href="#更新的行为表现" class="headerlink" title="更新的行为表现"></a>更新的行为表现</h3><ul>
<li><p>原子性：<br>MongoDB中所有的写操作在单一文档层级上是原子的。</p>
</li>
<li><p>_id字段：<br>不能更新<code>_id</code>字段的值，也不能用不同<code>_id</code>字段值的替换文档来替换已存在的文档。</p>
</li>
<li><p>文档大小：<br>当执行更新操作增加的文档大小超过了为该文档分配的空间时，更新操作会在磁盘上重定位该文档。</p>
</li>
<li><p>字段顺序：<br>MongoDB按照文档写入的顺序整理文档字段。但<code>_id</code>字段始终是文档中第一个字段；<code>renaming</code>操作可能会导致文档中的字段重新排序。</p>
</li>
</ul>
<p><br></p>
<h3 id="Update-Operator"><a href="#Update-Operator" class="headerlink" title="Update Operator"></a>Update Operator</h3><p><strong>Fields</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$currentDate</td>
<td>将字段值设置为当前日期(date or timestamp)</td>
</tr>
<tr>
<td>$inc</td>
<td>按指定的数字递增字段的值</td>
</tr>
<tr>
<td>$min</td>
<td>指定的值小于字段的值时才更新</td>
</tr>
<tr>
<td>$max</td>
<td>指定的值大于字段的值时才更新</td>
</tr>
<tr>
<td>$mul</td>
<td>将字段的值乘以指定的数字</td>
</tr>
<tr>
<td>$rename</td>
<td>重命名一个字段</td>
</tr>
<tr>
<td>$set</td>
<td>设置文档中字段的值</td>
</tr>
<tr>
<td>$setOnInsert</td>
<td>如果更新导致文档插入，则设置字段的值</td>
</tr>
<tr>
<td>$unset</td>
<td>从文档中删除指定的字段，</td>
</tr>
</tbody>
</table>
<p><br></p>
<p><strong>Array</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$</td>
<td>用作更新与查询条件匹配的第一个元素的占位符</td>
</tr>
<tr>
<td>$[]</td>
<td>用作更新与查询条件匹配的文档的数组的所有元素的占位符</td>
</tr>
<tr>
<td>$[<identifier>]</identifier></td>
<td>xxx</td>
</tr>
<tr>
<td>$addToSet</td>
<td>在集合中不存在元素时添加元素到数组</td>
</tr>
<tr>
<td>$pop</td>
<td>移除数组中的第一项或最后一项</td>
</tr>
<tr>
<td>$pull</td>
<td>删除所有匹配指定查询的数组元素</td>
</tr>
<tr>
<td>$push</td>
<td>向数组中添加项</td>
</tr>
<tr>
<td>$pullAll</td>
<td>从数组中删除所有匹配的值</td>
</tr>
</tbody>
</table>
<p><br></p>
<p><strong>Modifiers</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$each</td>
<td>修饰$push and $addToSet， 向数组中添加多个项</td>
</tr>
<tr>
<td>$position</td>
<td>修饰$push，在数组中指定位置添加元素</td>
</tr>
<tr>
<td>$slice</td>
<td>修饰$push，限制更新数组的大小</td>
</tr>
<tr>
<td>$sort</td>
<td>修饰$push，重新排列存储在数组中的文档</td>
</tr>
</tbody>
</table>
<p><br></p>
<p><strong>BitWise</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$bit	执行按位AND,OR,XOR更新</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="更新文档字段中指定字段"><a href="#更新文档字段中指定字段" class="headerlink" title="更新文档字段中指定字段"></a>更新文档字段中指定字段</h3><p>为了修改文档中的字段，MongoDB提供了<code>update operators</code>，如用来修改值的<code>$set</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	&lt;update operator&gt;: &#123; &lt;field&gt;: &lt;value&gt;, ...&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">#更改指定字段的值</div><div class="line">db.user.update(</div><div class="line">	&#123; _id: 1 &#125;,</div><div class="line">    &#123; $set: &#123;name: &quot;SET&quot;&#125; &#125;</div><div class="line">)</div><div class="line"></div><div class="line">#删除指定字段，文档中其他字段还在</div><div class="line">db.user.update(</div><div class="line">	&#123; _id: 1 &#125;,</div><div class="line">    &#123; $unset: &#123;name: &quot;SET&quot;&#125; &#125;</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line">#</div><div class="line">db.user.updateMany(</div><div class="line">	&#123; _id: 2&#125;,</div><div class="line">    &#123; $set: &#123;name: &quot;AAA&quot;, age: 222&#125; &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="文档替换-Replace"><a href="#文档替换-Replace" class="headerlink" title="文档替换(Replace)"></a>文档替换(Replace)</h3><p>当替换文档时，替换的文档必须仅仅有 <code>&lt;field&gt;: &lt;value&gt;</code>组成。<br>替换文档可以有不同于源文档的字段，但<code>_id</code>字段是不变的。</p>
<p>**建议使用<code>_id</code>作为过滤条件，因为它是唯一的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">db.collection.replaceOne()</div><div class="line"></div><div class="line"></div><div class="line">db.user.replaceOne(</div><div class="line">	&#123; name: &quot;AAA&quot; &#125;,</div><div class="line">    &#123; name: &quot;A&quot;, age: 2, sex: &quot;man&quot;, favorites: &#123; artist: &quot;Dali&quot;, food: &quot;banana&quot; &#125; &#125;</div><div class="line">)</div><div class="line"></div><div class="line">db.user.update(</div><div class="line">	&#123; _id: 1&#125;,</div><div class="line">    &#123; name: &quot;A&quot;, age: 2, sex: &quot;man&quot;, favorites: &#123; artist: &quot;Dali&quot;, food: &quot;banana&quot; &#125; &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="删除文档-Delete"><a href="#删除文档-Delete" class="headerlink" title="删除文档(Delete)"></a>删除文档(Delete)</h2><p><strong>方法：</strong></p>
<ul>
<li><code>db.collection.remove()</code>, 删除一个文档，或所有满足匹配的文档;</li>
<li><code>db.collection.deleteOne()</code>, 删除匹配最多条件的单个文档，即使可能有多个文档可能与指定过滤条件匹配;</li>
<li><code>db.collection.deleteMany()</code>, 删除所有匹配指定过滤条件的文档。</li>
</ul>
<p><br></p>
<h3 id="删除的行为表现"><a href="#删除的行为表现" class="headerlink" title="删除的行为表现"></a>删除的行为表现</h3><ul>
<li><p>Indexes<br>删除操作不会删除索引，即使从集合中删除了所有的文档。</p>
</li>
<li><p>原子性<br>MongoDB中所有的写操作在单一文档层级上是原子的。</p>
</li>
</ul>
<p><br></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#删除所有文档</div><div class="line">db.collectin.deleteMany(&#123;&#125;)</div><div class="line">db.collection.remove(&#123;&#125;)</div><div class="line"></div><div class="line"></div><div class="line">#删除所有满足条件的文档</div><div class="line">db.user.remove( &#123; name: &quot;A&quot; &#125; )</div><div class="line">db.user.deleteMany( &#123; name: &quot;A: &#125; )</div><div class="line"></div><div class="line"></div><div class="line">#仅删除一个满足条件最多的文档</div><div class="line">db.user.deleteOne( &#123; name: &quot;A&quot; &#125; )</div><div class="line"></div><div class="line">db.users.remove( &#123; name: &quot;A&quot;&#125;, 1)</div></pre></td></tr></table></figure>
<p><br></p>
<hr>
<p><br></p>
<h1 id="聚合-Agrregation"><a href="#聚合-Agrregation" class="headerlink" title="聚合(Agrregation)"></a>聚合(Agrregation)</h1><p>聚合操作处理数据记录并返回计算的结果。聚合操作将多个文档中的值(value)分组，并对分组的数据进行各类操作以返回单个结果。</p>
<p>MongoDB提供了三种方式进行聚合：</p>
<ul>
<li>aggregation pipeline(聚合管道);</li>
<li>map-reduce function(映射化简);</li>
<li>single aggregation methods(聚合指南)</li>
</ul>
<p><br></p>
<p><strong>Aggregation Pipeline(聚合管道)</strong></p>
<p>MongoDB的聚合框架(aggregation framework)是仿照数据处理管道的概念(concept)。Document输入多级管道，它将Document转换为聚合结果。</p>
<p>最基本的pipeline stage提供了：类似查询(query)操作的过滤器(filter)和类似修改(modify)输出文档格式的文档转换。</p>
<p>其他pipeline operation提供了按特定字段对文档进行分组和排序的工具，以及聚合数组内容(包括文档数组)的字段或工具。此外，pipeline stage可以使用运算符(operators)来处理任务。(如计算平均值和连接等…)</p>
<p>pipeline通过在MongoDB中使用本地操作，从而提供了高效的数据聚合。所以也是MongoDB中数据聚合的首选方法。</p>
<p>aggregation pipeline能够在一个共享的集合上操作。</p>
<p>aggregation pipeline可以使用索引来提高某些阶段的性能(performance)。另外，管道聚合还有一个内部优化阶段(optimization phase)。</p>
<p><img src="/images/MongoDB/aggregation-pipeline.png" alt="aggregation-pipeline"></p>
<p><br></p>
<p><strong>Map-Reduce(映射化简)</strong></p>
<p>一般来说，map-reduce操作有两个阶段：</p>
<ul>
<li>map stage: 处理每个文档并未每个输入文档发出一个或多个对象(object)；</li>
<li>reduce stage: 结合映射操作的输出。</li>
</ul>
<p>可选地，map-reduce有一个对结果做最后修改的最后阶段。与aggregation-operation类似，map-reduce可以指定查询条件来选择一个输入文档，以及对结果进行排序和限制。</p>
<p>map-reduce使用自定义的JavaScript函数执行映射和化简操作，以及可选的最终操作。与聚合管线相比，自定义的JavaScript提供了很大的灵活性。一般来说，map-reduce比aggregation pipeline效率更低，更复杂。</p>
<p>map-reduce能够在一个共享的集合上操作，同样也可以输出到共享集合。</p>
<p><img src="/images/MongoDB/map-reduce.png" alt="map-reduce"></p>
<p><br></p>
<p><strong>Single Purpose Aggregation Operations(聚合指南)</strong></p>
<p>MongoDB同样提供了<code>db.collection.count()</code>和<code>db.collection.distinct()</code>。</p>
<p>所有这些操作都从单个集合中聚合文档，虽然这些操作提供了对常见聚合过程的简单访问，但它们缺少aggregation pipeline和map-reduce的灵活性和功能。</p>
<p><img src="/images/MongoDB/distinct.png" alt="distinct"></p>
<p><br><br><br></p>
<h2 id="Aggregation-Pipeline-聚合管道"><a href="#Aggregation-Pipeline-聚合管道" class="headerlink" title="Aggregation Pipeline(聚合管道)"></a>Aggregation Pipeline(聚合管道)</h2><p>MongoDB的聚合框架是仿照数据处理管道的概念。文档输入多级管道，它将文档转换为聚合结果。</p>
<p>当map-reduce的复杂性可能是没有保证的，aggregation pipeline为map-reduce提供了一个可选也可能是聚合任务的首选解决方案。<br>aggregation pipeline对key value和result size有一些限制。</p>
<p><br><br><br></p>
<h2 id="映射化简"><a href="#映射化简" class="headerlink" title="映射化简"></a>映射化简</h2><p><br><br><br></p>
<h2 id="聚合指南"><a href="#聚合指南" class="headerlink" title="聚合指南"></a>聚合指南</h2><p><br></p>
<hr>
<p><br></p>
<h1 id="文本索引"><a href="#文本索引" class="headerlink" title="文本索引"></a>文本索引</h1><p>MongoDB支持在字符串内容上执行文本检索(text search)的查询操作。视图不支持文本检索。<br>为了执行文本检索，MongoDB使用<code>text index</code>和<code>$text</code>操作符。text索引可以包括任何值为字符串或字符串元素数组的字段。</p>
<p>栗子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.sample.insert(</div><div class="line">	[</div><div class="line">		&#123; _id: 1, name: <span class="string">"A"</span>, description: <span class="string">"AAA"</span> &#125;,</div><div class="line">        &#123; _id: 2, name: <span class="string">"B"</span>, description: <span class="string">"BBB"</span> &#125;,</div><div class="line">        &#123; _id: 3, name: <span class="string">"C"</span>, description: <span class="string">"CCC"</span> &#125;</div><div class="line">	]</div><div class="line">)</div></pre></td></tr></table></figure>
<p>为了执行文本检索查询，你必须在集合有一个text索引，一个集合只能有<strong>一个</strong>文本检索索引，但是这个索引可以覆盖多个字段。</p>
<p>启动在<code>name</code>和<code>description</code>字段上的文本检索：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.sample.createIndex(</div><div class="line">	&#123; name: <span class="string">"text"</span>, description: <span class="string">"text"</span> &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>使用<code>$text</code>查询操作符在一个有<code>text index</code>的集合上执行文本检索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">db.sample.find(&#123;</div><div class="line">	$text: &#123; $search: &quot;A B&quot; &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">#精确检索</div><div class="line">db.sample.find(&#123;</div><div class="line">	$text: &#123; $search: &quot;A \&quot;B\&quot;&quot; &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">#词语排除</div><div class="line">db.sample.find(&#123;</div><div class="line">	$text: &#123; $search: &quot;A B -AAA&quot; &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>MongoDB默认返回没排序的结果。然而文本检索将会对每个文档计算一个相关性分数，表明该文档与查询的匹配程度。<br>为了使用相关性分数进行排序，你必须使用 <code>$meta textScore</code>字段进行映射然后基于该字段进行排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.sample.find(</div><div class="line">	&#123; $text: &#123; $search: &quot;A AAA B&quot; &#125; &#125;,</div><div class="line">    &#123; score: &#123; $meta: &quot;textScore&quot; &#125; &#125;</div><div class="line">).sort( &#123; score: &#123; $meta: &quot;textScore&quot; &#125; &#125;)</div></pre></td></tr></table></figure>
<p>文本检索可以在聚合管道中使用。</p>
<p><br><br><br></p>
<h2 id="文本索引-1"><a href="#文本索引-1" class="headerlink" title="文本索引"></a>文本索引</h2><p><br><br><br></p>
<h2 id="文本检索操作符"><a href="#文本检索操作符" class="headerlink" title="文本检索操作符"></a>文本检索操作符</h2><p><br><br><br></p>
<h2 id="在管道聚合中使用文本索引"><a href="#在管道聚合中使用文本索引" class="headerlink" title="在管道聚合中使用文本索引"></a>在管道聚合中使用文本索引</h2><p><br><br><br></p>
<h2 id="使用基本技术Rosette语义平台的文本索引"><a href="#使用基本技术Rosette语义平台的文本索引" class="headerlink" title="使用基本技术Rosette语义平台的文本索引"></a>使用基本技术Rosette语义平台的文本索引</h2><p><br><br><br></p>
<h2 id="文本检索语言"><a href="#文本检索语言" class="headerlink" title="文本检索语言"></a>文本检索语言</h2><p><br></p>
<hr>
<p><br></p>
<h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>MongoDB的数据具有灵活的模式，集合本身没有对文档结构的规则性校验。</p>
<p><br></p>
<h2 id="数据模型设计介绍"><a href="#数据模型设计介绍" class="headerlink" title="数据模型设计介绍"></a>数据模型设计介绍</h2><p>关系型数据库要求你再插入数据之前必须先定义好一个表的模式结构，而MongoDB的集合并不限制文档结构。<br>这种灵活性让对象和数据库文档之间的映射变得很容易。即使数据记录之间有很大的变化，每个文档也可以很好的映射到各条不同的记录。<br>当然，在实际使用中，同一个集合中的文档往往都有一个比较类似的结构。</p>
<p>数据模型设计中最具挑战性的是在应用程序需求，数据库引擎性能要求和数据读写模式之间的权衡考量。</p>
<p><br></p>
<h3 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h3><p><strong>引用(reference)</strong><br>引用方式通过<strong>存储链接</strong>或<strong>引用信息</strong>来实现两个不同文档之间的关联。<br>应用程序可以通过解析这些数据库引用来访问相关数据。简单来讲，这就是规范化的数据模型。</p>
<p><img src="/images/MongoDB/data-model-normalized.png" alt="规范化数据模型"></p>
<p><strong>内嵌(embedded data)</strong><br>内嵌方式指把相关联的数据保存在同一个文档之内。<br>MongoDB的文档结构允许一个字段或一个数组内的值为一个嵌套的文档。这种<strong>冗余</strong>的数据模型可以让应用程序在一个数据库内完成对相关数据的读取或修改。</p>
<p><img src="/images/MongoDB/data-model-denormalized.png" alt="内嵌式数据模型"></p>
<p><br></p>
<h3 id="写操作的原子性"><a href="#写操作的原子性" class="headerlink" title="写操作的原子性"></a>写操作的原子性</h3><p>在MongoDB中，写操作在文档级别是原子的(atomic)，没有一个单独的写操作可以原子地影响多个文档或多个集合。但，对原子性写操作利好的内嵌数据模型会限制应用程序对数据的使用场景。</p>
<ul>
<li>嵌入(embdded)数据的非规格化(denormalized)数据模型将单个文档所表示的实体(entity)的所有相关数据组合在一起。这有利于原子写操作，因为单个写操作可以插入或更新实体的数据；</li>
<li>规格化(normalizing)数据通过多个集合拆分数据，并需要多个不是原子集合的写操作。</li>
</ul>
<p><br></p>
<h3 id="文档的增长"><a href="#文档的增长" class="headerlink" title="文档的增长"></a>文档的增长</h3><p>如果文档的大小超出分配给文档的原空间大小，那么MongoDB就需要把文档从磁盘上的现有位置移动到一个新的位置以存放更多的数据。这种数据增长的情况也会影响到是否要使用规范化或非规范化。</p>
<p><br></p>
<h3 id="数据的使用和性能"><a href="#数据的使用和性能" class="headerlink" title="数据的使用和性能"></a>数据的使用和性能</h3><p>设计文档模型时，一定要考虑应用程序会如何使用你的数据。</p>
<p>例如：</p>
<ul>
<li>假如应用程序通常只会使用最近插入的文档，那么可以考虑使用限制集；</li>
<li>假如应用会做大量的读操作，那么可以加多一些索引的方法来提升常见查询的性能。</li>
</ul>
<p><br><br><br></p>
<h2 id="文档验证"><a href="#文档验证" class="headerlink" title="文档验证"></a>文档验证</h2><p>MongoDB提供了在更新和插入期间验证(validate)文档的功能(capability)。验证规则是在每个集合中指定使用验证符(validator)选项，利用一个文档指定验证堆栈或表达式。</p>
<ul>
<li>通过<code>collMod</code>命令附带验证符选项向一个已经存在的集合添加文档验证；</li>
<li>利用<code>db.createCollection()</code>命令附带验证符选项来创建文档验证规则。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.createCollection( <span class="string">"contacts"</span>,</div><div class="line">   &#123; validator: &#123; <span class="variable">$or</span>:</div><div class="line">      [</div><div class="line">         &#123; phone: &#123; <span class="variable">$type</span>: <span class="string">"string"</span> &#125; &#125;,</div><div class="line">         &#123; email: &#123; <span class="variable">$regex</span>: /@mongodb\.com$/ &#125; &#125;,</div><div class="line">         &#123; status: &#123; <span class="variable">$in</span>: [ <span class="string">"Unknown"</span>, <span class="string">"Incomplete"</span> ] &#125; &#125;</div><div class="line">      ]</div><div class="line">   &#125;</div><div class="line">&#125; )</div></pre></td></tr></table></figure>
<p>MongoDb同样提供了<code>validationLevel</code>选项，它确定了MongoDb在更新期间如何将验证规则应用到已有文档，以及验证操作选项。它确定MongoDB是否错误并<strong>拒绝</strong>违反验证规则的文档，或者<strong>警告</strong>日志中的违规，但允许无效的文档。</p>
<p><br></p>
<h3 id="行为-1"><a href="#行为-1" class="headerlink" title="行为"></a>行为</h3><p>验证发生在更新和插入期间。当向一个文档添加验证，在修改之前，现有文档不会进行验证检查。</p>
<p><br></p>
<p><strong>现有文档</strong></p>
<p>可使用<code>validationLevel</code>选项来控制MongoDB怎样处理现有文档。</p>
<p>默认情况下，<code>MongoDB</code>是严格的，并且将验证规则应用于所有插入和更新操作。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#moderate level</span></div><div class="line"><span class="comment">#在中等级别下，对不符合验证标准的现有文档更新将不会检查有效性</span></div><div class="line"></div><div class="line">db.runCommand(&#123;</div><div class="line">	collMod: <span class="string">"contacts"</span>,</div><div class="line">    validator: &#123; <span class="variable">$or</span>: [ &#123; phone: &#123; <span class="variable">$exists</span>: <span class="literal">true</span> &#125; &#125;, &#123; email: &#123; <span class="variable">$exists</span>: <span class="literal">true</span>&#125;&#125; ] &#125;,</div><div class="line">    validationLevel: <span class="string">"moderate"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>设置<code>validationLevel</code>为<code>off</code>以禁用验证功能。</p>
<p><br></p>
<p><strong>接受或拒绝无效文档</strong></p>
<p><code>validationAction</code>选项决定了MongoDB如何处理违反(violate)验证规则的文档。</p>
<p>默认情况下，<code>validationAction</code>是错误的，并且拒绝任何违反验证条件的插入和更新操作。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#当validationAction为warn时，MongoDB记录所有违反行为，但允许插入或更新操作。</span></div><div class="line"></div><div class="line">db.createCollection( <span class="string">"contacts"</span>,</div><div class="line">   &#123;</div><div class="line">      validator: &#123; <span class="variable">$or</span>:</div><div class="line">         [</div><div class="line">            &#123; phone: &#123; <span class="variable">$type</span>: <span class="string">"string"</span> &#125; &#125;,</div><div class="line">            &#123; email: &#123; <span class="variable">$regex</span>: /@mongodb\.com$/ &#125; &#125;,</div><div class="line">            &#123; status: &#123; <span class="variable">$in</span>: [ <span class="string">"Unknown"</span>, <span class="string">"Incomplete"</span> ] &#125; &#125;</div><div class="line">         ]</div><div class="line">      &#125;,</div><div class="line">      validationAction: <span class="string">"warn"</span></div><div class="line">   &#125;</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#如下违规操作将会报警，并由于是warn，所以写入成功</span></div><div class="line">db.contacts.insert( &#123; name: <span class="string">"Amanda"</span>, status: <span class="string">"Updated"</span> &#125; )</div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>约束(restriction)</strong></p>
<p>无法在<code>admin</code>,<code>local</code>,<code>config</code>数据库的集合 和 <code>system.*</code>集合 里面指定验证符(validator)。</p>
<p><br></p>
<p><strong>绕过文档验证</strong></p>
<p>通过<code>bypassDocumentValidation</code>选项来绕过文档验证。</p>
<p><br><br><br></p>
<h2 id="数据建模理论"><a href="#数据建模理论" class="headerlink" title="数据建模理论"></a>数据建模理论</h2><h3 id="数据模型设计"><a href="#数据模型设计" class="headerlink" title="数据模型设计"></a>数据模型设计</h3><p>一个高效的数据模型能够很好的满足应用程序的需求。设计一个文档数据结构最关键的考量就是决定是使用<strong>嵌套(embdded)</strong>还是<strong>引用(reference)</strong>。</p>
<p><br></p>
<h4 id="内嵌式数据模型-非规范化"><a href="#内嵌式数据模型-非规范化" class="headerlink" title="内嵌式数据模型(非规范化)"></a>内嵌式数据模型(非规范化)</h4><p>在MongoDB里面，可以把相关的数据包括在一个单个的结构或者文档下面。这样的数据模型也叫作<strong>非规范化</strong>模式。</p>
<p>内嵌数据可以让应用程序把相关的数据保存在同一条数据记录里面，这样，应用程序就可以发送较少的请求给MongoDB来完成常用的查询和更新请求。</p>
<p><br></p>
<p>一般来说，下述情况建议使用内嵌数据模型：</p>
<ul>
<li>数据对象之间有包含(contain)关系；</li>
<li>数据对象间有一对多的关系。</li>
</ul>
<p>通常情况下，内嵌数据会对读操作有比较好的性能提高，可以使应用程序在一个单个操作就可以完成对数据的读取。同时，内嵌数据也对更新相关数据提供了一个原子性写操作。</p>
<p><br></p>
<h4 id="规范化数据模型"><a href="#规范化数据模型" class="headerlink" title="规范化数据模型"></a>规范化数据模型</h4><p>一般来说，下述情况可以使用规范化模型：</p>
<ul>
<li>内嵌数据会导致很多数据的重复，并且读性能的优势又不足与盖过数据重复的弊端时；</li>
<li>需要表达比较复杂的多对多关系时；</li>
<li>大型多层次结构数据集。</li>
</ul>
<p><br></p>
<h3 id="MongoDB特性和数据模型的关系"><a href="#MongoDB特性和数据模型的关系" class="headerlink" title="MongoDB特性和数据模型的关系"></a>MongoDB特性和数据模型的关系</h3><p>MongoDB的数据建模不仅仅取决于应用程序的数据需求，也要考虑MongoDB本身的一些特性。</p>
<p><br></p>
<h4 id="文档增长性-increase"><a href="#文档增长性-increase" class="headerlink" title="文档增长性(increase)"></a>文档增长性(increase)</h4><p>如果更新操作导致文档大小增加，那么可能需要重新设计数据模型，在不同文档之间使用引用的方式而非内嵌、冗余的数据结构。<br>MongoDB会自动调整空白填充的大小以尽可能的减小文档迁移。你也可以使用一个<strong>预分配策略</strong>来防止文档的增长。</p>
<p><br></p>
<h4 id="原子性-atomic"><a href="#原子性-atomic" class="headerlink" title="原子性(atomic)"></a>原子性(atomic)</h4><p>在MongoDB中，所有在文档级别的操作都具有原子性。一个单个写操作最多只可以修改一个文档。即使是一个会改变同一个集合中多个文档的命令，在同一时间也只会操作一个文档。即便是涉及多个子文档的多个操作，只要是在同一文档之内，这些操作仍旧是有原子性的。</p>
<p>尽可能保证那些需要在一个原子操作内进行修改的字段定义在同一个文档里面。如果你的应用程序允许对两个数据的非原子性更新操作，那么可把这些数据定义在不同的文档内。</p>
<p>把相关数据定义到同一个文档里的内嵌方式有利于这种原子性操作。对于那些使用引用来关联相关数据的数据模型，应用程序必须再用额外的读和写操作去取回和修改相关的数据。</p>
<p><br></p>
<h4 id="分片-sharding"><a href="#分片-sharding" class="headerlink" title="分片(sharding)"></a>分片(sharding)</h4><p>MongoDB使用分片来实现水平扩展。使用分片的集群可以支持海量的数据和高并发读写。使用分片技术把一个数据库内的某一个集合的数据进行分区，从而达到把数据分到多个mongod实例(或分片上)的目的。</p>
<p>MongoDB依据<strong>分片键</strong>分发数据和应用程序的事务请求。选择一个合适的分片键对性能有很大的影响，也会促进或阻碍MongoDB的定向分片查询和增强的写性能。所以在选择分片键的时候要仔细考量分片键所用的字段。</p>
<p><br></p>
<h4 id="索引-index"><a href="#索引-index" class="headerlink" title="索引(index)"></a>索引(index)</h4><p>对常用操作可以使用索引来提高性能。对查询条件中常见的字段，以及需要排序的字段创建索引。<br>MongoDB会对<code>_id</code>自动创建唯一索引。</p>
<p>创建索引时，需要考虑索引的下述特征：</p>
<ul>
<li>每个索引要求至少8KB的数据空间；</li>
<li>每增加一个索引，就会对写操作性能有一些影响。对于一个写多读少的集合，索引会变得很费时。因为每个插入必须要更新所有索引；</li>
<li>每个索引都会占一定的硬盘空间和内存(对于活跃的索引)。索引可能会用到很多这样的资源，因此对这些资源要进行管理和规划，特别是在计算热点数据大小的时候。</li>
</ul>
<p><br></p>
<h4 id="集合的数量"><a href="#集合的数量" class="headerlink" title="集合的数量"></a>集合的数量</h4><p>某些情况下，可能需要把相关的数据保存到多个集合里面。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; log: &quot;dev&quot;, ts:..., info: ... &#125;</div><div class="line">&#123; log: &quot;debug&quot;, ts:..., info: ... &#125;</div></pre></td></tr></table></figure>
<p>一般来说，很大的集合数量对性能没有什么影响，反而在某些场景下有不错的性能。使用不同的集合在高并发批处理场景下会有很好的帮助。</p>
<p>当使用有大量集合的数据模型时，请注意：</p>
<ul>
<li>每个集合有几KB的额外开销；</li>
<li>每个索引(包含<code>_id</code>)，需要至少8KB的数据空间；</li>
<li>每个MongoDB的数据库有且仅有一个命名文件(namespace file)(<db>.ns)。这个命名文件保存了数据库的所有元数据，每个索引和集合在这个文件里都有一条记录；</db></li>
<li>MongoDB的命名文件有大小的限制(默认16MB)。利用<code>db.system.namespaces.count()</code>查看。</li>
</ul>
<p><br></p>
<h4 id="包含大量小文档的集合"><a href="#包含大量小文档的集合" class="headerlink" title="包含大量小文档的集合"></a>包含大量小文档的集合</h4><p>如果你有一个包含大量小文档的集合，则应该考虑为了性能而嵌入。如果你可以通过一些逻辑关系将这些小文档分组，并且你经常通过这个分组来检索文档，那么你应该考虑将小文档”卷起来”成为包含一系列嵌入式文档的大文档。</p>
<p>将这些小文档“卷起来”成为逻辑分组，意味着检索一组文档的查询设计顺序读取和较少的随机磁盘访问。此外，将文档“卷起”并将公共字段移动到较大的文档会使字段上的索引受益。公共字段的副本将会减少，并且相应索引中的关联键条目也会减少。</p>
<p>然而，如果你通常只需要检索分组中的一个文档的子集，那么“滚动”文档可能无法提供更好的性能。此外，如果晓得，独立的文档代表数据的自然模型，那你应该维护改模型。</p>
<p><br></p>
<h4 id="小文档的存储优化-storage-optimization"><a href="#小文档的存储优化-storage-optimization" class="headerlink" title="小文档的存储优化(storage optimization)"></a>小文档的存储优化(storage optimization)</h4><p>每个MongoDB文档都包含一定的开销(overhead)，这些开销通常是无关紧要的。但如果文档只有几个字节，那就相当重要了。</p>
<p>考虑以下有关优化这些集合的存储利用率的建议：</p>
<ul>
<li>显示地使用<code>_id</code>字段；</li>
<li>使用较短的字段名称；</li>
<li>嵌套文档。</li>
</ul>
<p><br></p>
<h4 id="数据生命周期管理"><a href="#数据生命周期管理" class="headerlink" title="数据生命周期管理"></a>数据生命周期管理</h4><p>数据模型决策应考虑数据生命周期管理。</p>
<p>集合的<em>*TTL功能</em>在一段时间后标识文档到期。如果应用程序需要一些数据才能在数据库中持久化一段有限的时间，请考虑使用TTL特性。</p>
<p>此外，你的应用程序仅使用最近插入的文档，请考虑限制集。</p>
<p><br><br><br></p>
<h2 id="数据模型例子与范式"><a href="#数据模型例子与范式" class="headerlink" title="数据模型例子与范式"></a>数据模型例子与范式</h2><h3 id="文档关系建模"><a href="#文档关系建模" class="headerlink" title="文档关系建模"></a>文档关系建模</h3><h4 id="一对一关系建模：内嵌文档模型"><a href="#一对一关系建模：内嵌文档模型" class="headerlink" title="一对一关系建模：内嵌文档模型"></a>一对一关系建模：内嵌文档模型</h4><p>用内嵌文档方式实现一对一关系。</p>
<h4 id="一对多关系建模：内嵌文档模型"><a href="#一对多关系建模：内嵌文档模型" class="headerlink" title="一对多关系建模：内嵌文档模型"></a>一对多关系建模：内嵌文档模型</h4><p>用内嵌文档方式实现一对多关系。</p>
<h4 id="一对多关系建模：文档引用模式"><a href="#一对多关系建模：文档引用模式" class="headerlink" title="一对多关系建模：文档引用模式"></a>一对多关系建模：文档引用模式</h4><p>用文档引用实现一对多关系。</p>
<p><br></p>
<h3 id="树结构建模"><a href="#树结构建模" class="headerlink" title="树结构建模"></a>树结构建模</h3><h4 id="父文档引用"><a href="#父文档引用" class="headerlink" title="父文档引用"></a>父文档引用</h4><p>父文档引用模式用一个文档来表示树的一个节点。每一个文档除了存储节点的信息，同时也保存该节点父节点文档的id值。</p>
<p><img src="/images/MongoDB/data-model-tree.png" alt="data-model-tree"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, parent: <span class="string">"Databases"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, parent: <span class="string">"Programming"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Programming"</span>, parent: <span class="string">"Books"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Books"</span>, parent: null &#125;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查询父节点</span></div><div class="line">db.test.findOne(&#123; _id: <span class="string">"MongoDB"</span> &#125;).parent</div><div class="line"></div><div class="line"><span class="comment">#对parent字段创建索引，这样可以快速的按照父节点查找</span></div><div class="line">db.test.createIndex(&#123; parent: 1 &#125;)</div><div class="line"></div><div class="line"><span class="comment">#查询一个父节点的所有子节点</span></div><div class="line">db.test.find(&#123; parent: <span class="string">"Databases"</span> &#125;)</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="子文档引用"><a href="#子文档引用" class="headerlink" title="子文档引用"></a>子文档引用</h4><p>子文档引用模式用一个文档来表示树的一个节点。每一个文档除了存储节点信息外，同时也用一个数组来保存该节点的所有子节点的id值。</p>
<p><img src="/images/MongoDB/data-model-tree.png" alt="data-model-tree"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, children: [] &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, children: [ <span class="string">"MongoDB"</span>, <span class="string">"dbm"</span> ]&#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Programming"</span>, children: [ <span class="string">"Languages"</span>, <span class="string">"Databases"</span> ]&#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Books"</span>, children: [ <span class="string">"Programming"</span> ]&#125;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查询子节点</span></div><div class="line">db.test.findOne(&#123; _id: <span class="string">"Databases"</span>&#125;).children</div><div class="line"></div><div class="line"><span class="comment">#对children字段创建索引，这样就可以快速按照子节点查找</span></div><div class="line">db.test.createIndex(&#123; children: 1 &#125;)</div><div class="line"></div><div class="line"><span class="comment">#查找一个子节点的父节点和同级节点</span></div><div class="line">db.test.find(&#123; children: <span class="string">"MongoDB"</span> &#125;)</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="祖先数组-ancestors-array"><a href="#祖先数组-ancestors-array" class="headerlink" title="祖先数组(ancestors array)"></a>祖先数组(ancestors array)</h4><p>祖先数组模式用一个文档来表示树的一个节点。每一个文档除了存储节点的信息，同时也存储了对父文档及祖先文档的id值。</p>
<p><img src="/images/MongoDB/data-model-tree.png" alt="data-model-tree"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, ancestors: [ <span class="string">"Books"</span>, <span class="string">"Programming"</span>, <span class="string">"Databases"</span> ], parent: <span class="string">"Databases"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, ancestors: [ <span class="string">"Books"</span>, Programming<span class="string">" ], parent: [ "</span>MongoDB<span class="string">", "</span>dbm<span class="string">" ]&#125;)</span></div><div class="line"><span class="string">db.test.insert(&#123; _id: "</span>Programming<span class="string">", ancestors: [ "</span>Books<span class="string">" ], parent: "</span>Books<span class="string">" &#125;)</span></div><div class="line"><span class="string">db.test.insert(&#123; _id: "</span>Books<span class="string">", ancestors: [ ], parent: null &#125;)</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#查询一个节点的祖先节点</span></div><div class="line"><span class="string">db.test.findOne(&#123; _id: "</span>MongoDB<span class="string">" &#125;).ancestors</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#对ancestors创建索引</span></div><div class="line"><span class="string">db.test.createIndex(&#123; ancestors: 1 &#125;)</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#利用ancestors字段来查找某个节点的所有子代节点</span></div><div class="line"><span class="string">db.test.find(&#123; ancetors: "</span>Programmming<span class="string">" &#125;)</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="物化路径-materialized-path"><a href="#物化路径-materialized-path" class="headerlink" title="物化路径(materialized path)"></a>物化路径(materialized path)</h4><p>物化路径模式将每个树节点存储在文档中。除了存储节点信息外，同时也存储了祖先文档或路径的id值。</p>
<p><img src="/images/MongoDB/data-model-tree.png" alt="data-model-tree"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"Books"</span>, path: null &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Programming"</span>, path: <span class="string">",Books,"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, path: <span class="string">",Books,Programming,"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, path: <span class="string">",Books,Programming,Databases,"</span> &#125;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查询整个树的所有节点并按path排序</span></div><div class="line">db.test.find().sort(&#123; path: 1 &#125;)</div><div class="line"></div><div class="line"><span class="comment">#可以在path字段上使用re来查询</span></div><div class="line">db.test.find(&#123; path: /,Programming,/ &#125;)</div><div class="line">db.test.find(&#123; path: /^,Books,/ &#125;)</div><div class="line"></div><div class="line"><span class="comment">#在path字段上创建索引</span></div><div class="line">db.test.createIndex(&#123; path: 1 &#125;)</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="嵌套集合-nested-set"><a href="#嵌套集合-nested-set" class="headerlink" title="嵌套集合(nested set)"></a>嵌套集合(nested set)</h4><p>嵌套集合模式对整个树结构进行一次深度优先的遍历。遍历时候对每个节点的压栈和出栈作为两个不同的步骤记录下来。每一个节点就是一个文档，除了节点信息外，文档还保存父节点的id以及遍历的两个步骤编号。压栈是的步骤保存到<strong>left字段</strong>里，而出栈时的步骤编号则保存到<strong>right字段</strong>里。</p>
<p><img src="/images/MongoDB/data-model-example-nested-set.png" alt="data-model-example-nested-set"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"Books"</span>, parent: 0, left: 1, right: 12 &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Programming"</span>, parent: <span class="string">"Books"</span>, left: 2, right: 11 &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, parent: <span class="string">"Programming"</span>, left: 5, right: 10 &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, parent: <span class="string">"Databases"</span>, left: 6, right: 7 &#125;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查询摸个节点的子代节点</span></div><div class="line">db.test.find(&#123; left: &#123; <span class="variable">$gt</span>: db.test.findOne(&#123; _id: <span class="string">"Databases"</span> &#125;), right: &#123; <span class="variable">$lt</span>: db.test.findOne(&#123;<span class="string">"_id: "</span>Databases<span class="string">"&#125;) &#125; &#125;)</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="具体应用模型举例"><a href="#具体应用模型举例" class="headerlink" title="具体应用模型举例"></a>具体应用模型举例</h3><h4 id="原子性事务建模"><a href="#原子性事务建模" class="headerlink" title="原子性事务建模"></a>原子性事务建模</h4><p>如何使用内嵌技术来保证同一文档内相关字段更新操作的原子性。</p>
<p>举例来说，假设你在设计一个图书馆的借书系统，你需要管理书的库存量以及出借记录。一本书的可借数量加上借出数量的和必须等于总的保有量，那么对这两个字段的更新必须是原子性的。</p>
<p><br></p>
<h4 id="关键词搜索建模"><a href="#关键词搜索建模" class="headerlink" title="关键词搜索建模"></a>关键词搜索建模</h4><p>描述了一种把关键词保存在数组里并使用多键索引来实现关键词搜索功能的方法。</p>
<p>为实现关键词搜索，在文档内增加一个数组字段并把每一个关键词加到数组里。然后你可以对该字段建一个 多键索引。这样你就可以对数组里面的关键词进行查询了。</p>
<p><br></p>
<h4 id="货币数据建模"><a href="#货币数据建模" class="headerlink" title="货币数据建模"></a>货币数据建模</h4><p>处理货币数据的应用程序通常需要捕获小数(franctional)货币单位，并在执行算术时需要精确地模拟十进制四舍五入。许多现代系统(float,double)使用的基于二级制的浮点运算不能精确地表示小数，而且需要某种程度的近似，因而不适合于货币运算。因此，在货币数据建模时，这一约束是一个重要的考虑因素。</p>
<ul>
<li><p>数字模型<br>如果需要查询数据库中精确、数学书有效匹配或需要执行Server端算术，则数字模型可能是适合的。</p>
</li>
<li><p>非数字模型<br>如果需要在Server端做一些对货币数值的数学计算，那么严格精度可能会更合适一些。</p>
</li>
</ul>
<p><br></p>
<h4 id="时间数据模型"><a href="#时间数据模型" class="headerlink" title="时间数据模型"></a>时间数据模型</h4><p>MongoDB默认存储UTC时间，并将任何本地时间转换成这种形式。</p>
<p><br></p>
<hr>
<p><br></p>
<h1 id="MongoDB管理-administration"><a href="#MongoDB管理-administration" class="headerlink" title="MongoDB管理(administration)"></a>MongoDB管理(administration)</h1><p>The administration 文档说明了MongoDB实例和部署正在进行的操作和维护。本文档包括这些问题的高级概述，以及涵盖操作MongoDB的特定过程的教程。</p>
<p><br><br><br></p>
<h2 id="操作清单-operation-checklist"><a href="#操作清单-operation-checklist" class="headerlink" title="操作清单(operation checklist)"></a>操作清单(operation checklist)</h2><p>如下清单，提供了帮助你避免在MongoDB部署中出现问题的建议。</p>
<p><br></p>
<h3 id="文件系统-file-system"><a href="#文件系统-file-system" class="headerlink" title="文件系统(file system)"></a>文件系统(file system)</h3><ul>
<li>将磁盘分区与RAID配置对齐；</li>
<li>避免对<code>dbpath</code>使用NFS。使用NFS会导致性能下降和不稳定；</li>
<li>针对Linux/Unix的文件格式，建议使用XFS或EXT4。如果可能的话，对MongoDB使用XFS性能会更好；</li>
<li>对于WiredTiger存储引擎，强烈建议使用XFS来避免使用EXT4时发现的性能问题；</li>
<li>针对Windows，不要使用FAT(FAT16/32/exFAT)文件系统，请使用NTFS文件系统。</li>
</ul>
<p><br></p>
<h3 id="复制-replication"><a href="#复制-replication" class="headerlink" title="复制(replication)"></a>复制(replication)</h3><ul>
<li>验证所有非隐藏副本集成员的RAM, CPU, 磁盘, 网络设置, 配置等方面是否相同；</li>
<li>配置<code>oplog</code>的大小来适合你的用例；</li>
<li>确保副本集包好至少3个以journaling方式运行的数据承载节点；</li>
<li>在配置副本集成员时使用主机名(hostname)，而不是IP地址；</li>
<li>确保所有的mongod实例之间使用全双工网络；</li>
<li>确保每台主机都能解析它自己；</li>
<li>确保副本集包含奇数个投票的成员(voting members)，确保票数不会相等则一定会有主被选举出来；</li>
<li>确保mongod实例有0或1票；</li>
<li>为了高可用(high availability)，副本集集群最少部署3台数据中心。</li>
</ul>
<p><br></p>
<h3 id="分片-sharding-1"><a href="#分片-sharding-1" class="headerlink" title="分片(sharding)"></a>分片(sharding)</h3><ul>
<li>将配置服务器放置于专用硬件，以便在大型集群中实现最佳性能。确保硬件有足够的RAM来讲数据文件完全存储到内存中，并且有专门的存储；</li>
<li>使用NTP同步分片集群上所有组件的时钟；</li>
<li>确保Mongod, mongos和配置服务器之间的全双工网络连接；</li>
<li>使用CNAME将配置服务器标识到集群中，以便可以在不停机的情况下重命名和重新编号配置服务器。</li>
</ul>
<p><br></p>
<h3 id="Journaling"><a href="#Journaling" class="headerlink" title="Journaling"></a>Journaling</h3><ul>
<li>确保所有实例都使用journaling；</li>
<li>将journal放置于低延迟(low-latency)磁盘上，用于编写密集的工作负载。注意，这将影响快照式备份(snapshot)，因为构成数据库状态的文件将驻留在单独的volume上。</li>
</ul>
<p><br></p>
<h3 id="硬件-hardware"><a href="#硬件-hardware" class="headerlink" title="硬件(hardware)"></a>硬件(hardware)</h3><ul>
<li>使用RAID10和SSD能够获得最佳性能；</li>
<li>确保每个mongod为它的dbpath提供了IOPS；</li>
<li>在虚拟环境中运行时，避免动态内存功能；</li>
<li>避免将所有副本集成员放置于相同的SAN(存储区网络)中。</li>
</ul>
<p><br></p>
<h3 id="部署到云上"><a href="#部署到云上" class="headerlink" title="部署到云上"></a>部署到云上</h3><ul>
<li>AWS;</li>
<li>Azure;</li>
<li>Aliyun;</li>
<li>Tencent.</li>
</ul>
<p><br></p>
<h3 id="操作系统配置"><a href="#操作系统配置" class="headerlink" title="操作系统配置"></a>操作系统配置</h3><p><strong>Linux</strong></p>
<ul>
<li>关闭<code>hugepages</code>和<code>defrag</code>；</li>
<li>调整存储数据库文件设备上的readahead设置，以适应用例；</li>
<li>在虚拟环境中的RHEL7/CENTOS7上禁用优化工具；</li>
<li>为SSD驱动使用<code>noop</code>或<code>deadline</code>磁盘调度；</li>
<li>禁用<code>NUMA</code>或将<code>vm.zone_reclaim_mode</code>设置为0，并运行<code>node interleaving</code>的mongod实例；</li>
<li>调整硬件的<code>ulimit</code>值以适应实例；</li>
<li>对dbpath挂载点使用<code>noatime</code>；</li>
<li>对你的部署配置足够的文件句柄(fs.file-max value of 98000)，内核pid限制(kernel.pid_max value of 64000)，每个进程的最大线程数(kernel.threads-max value 0f 64000)；</li>
<li>确保你的系统配置有swap交换分区；</li>
<li>确保系统默认TCP keepalived设置正确。</li>
</ul>
<p><strong>Windows</strong></p>
<ul>
<li>考虑禁用NTFS的最后访问时间更新。这类似与在Unix-like系统上禁用atime。</li>
</ul>
<p><br></p>
<h3 id="备份-backup"><a href="#备份-backup" class="headerlink" title="备份(backup)"></a>备份(backup)</h3><ul>
<li>安排备份和恢复过程的定期测试，以便手头有时间估计，并恢复其功能。</li>
</ul>
<p><br></p>
<h3 id="监控-monitor"><a href="#监控-monitor" class="headerlink" title="监控(monitor)"></a>监控(monitor)</h3><ul>
<li>监视Server的硬件统计信息(磁盘使用，CPU，可用磁盘空间…)</li>
<li>监视mongodb的状态。</li>
</ul>
<p><br></p>
<h3 id="负载均衡-load-balance"><a href="#负载均衡-load-balance" class="headerlink" title="负载均衡(load balance)"></a>负载均衡(load balance)</h3><ul>
<li>配置负载均衡启用”sticky session”或“client affinity”，对现有连接有足够的超时时间；</li>
<li>避免放置负载均衡器在MongoDb集群或副本集组件。</li>
</ul>
<p><br><br><br></p>
<h2 id="开发清单-development-checklist"><a href="#开发清单-development-checklist" class="headerlink" title="开发清单(development checklist)"></a>开发清单(development checklist)</h2><p>如下清单，提供了帮助你避免在MongoDB部署期间出现的问题的建议。</p>
<p><br></p>
<h3 id="数据持久性-data-durability"><a href="#数据持久性-data-durability" class="headerlink" title="数据持久性(data durability)"></a>数据持久性(data durability)</h3><ul>
<li>确保副本集至少包含3个(带有w:majority)数据承载节点，这3个数据承载节点需要为副本集的高数据持久性；</li>
<li>确保所有实例都是用了journaling。</li>
</ul>
<p><br></p>
<h3 id="架构设计-schema-design"><a href="#架构设计-schema-design" class="headerlink" title="架构设计(schema design)"></a>架构设计(schema design)</h3><p>MongoDB中的数据具有动态结构。collection并不要求document结构。这有助于迭代开发和多态性。然而，集合中的文档通常具有高度的同类结构。</p>
<ul>
<li>确保你需要的集合集中的索引(indexes)支持你的查询(query)。除了<code>_id</code>索引，你必须显式的创建所有索引；</li>
<li>确保你的架构设计支持你的开发类型；</li>
<li>确保你的架构设计不依赖于长度不受绑定的索引数组；</li>
<li>再架构设计时考虑文档大小限制。</li>
</ul>
<p><br></p>
<h3 id="复制-replication-1"><a href="#复制-replication-1" class="headerlink" title="复制(replication)"></a>复制(replication)</h3><ul>
<li>使用奇数个副本集成员以确保选举顺利进行。如果有偶数个成员，请使用仲裁者(arbiter)以确保级数的选票；</li>
<li>确保使用监控工具和适当的写关注来保持从库数据最新；</li>
<li>不要使用从库读取来扩展整体读取吞吐量。</li>
</ul>
<p><br></p>
<h3 id="分片-sharding-2"><a href="#分片-sharding-2" class="headerlink" title="分片(sharding)"></a>分片(sharding)</h3><ul>
<li>确保你的<code>sharded key</code>将负载均匀地分配到分片上；</li>
<li>对需要按分片数进行缩放的工作负载(workload)使用有针对性的操作；</li>
<li>对非目标(non-targeted)查询，总是从主节点读取可能对陈旧或孤立的数据很敏感；</li>
<li>当向新的非散列(hash)分片集合中插入大数据集时，Pre-split and manually balance chunks。</li>
</ul>
<p><br></p>
<h3 id="驱动-drivers"><a href="#驱动-drivers" class="headerlink" title="驱动(drivers)"></a>驱动(drivers)</h3><ul>
<li>使用连接池(connection pooling)；</li>
<li>确保你的应用程序在复制集选举期间还能够处理瞬时写入(transient write)和错误读取；</li>
<li>确保你的应用程序处理失败的请求并适时地重试它们；</li>
<li>使用指数退避逻辑重试数据库请求；</li>
<li>如果需要计算数据库操作的编译执行时间，对读操作使用<code>cursor.maxTimeMS()</code>，对写操作使用<code>wtimeout</code>。</li>
</ul>
<p><br><br><br></p>
<h2 id="性能-MongoDB-Perfomance"><a href="#性能-MongoDB-Perfomance" class="headerlink" title="性能(MongoDB Perfomance)"></a>性能(MongoDB Perfomance)</h2><ul>
<li>当遇到性能下降时，通常与数据库的访问策略、硬件可用性和开放的数据库连接数相关；</li>
<li>一些用户可能由于不适当的索引策略或结果不足而经历性能限制，或由于架构设计模式差；</li>
<li>性能问题可能表明数据库正以最大限度运行，是时候给数据库添加额外的容量(capacity)了。尤其是，应用程序的工作集应该有足够的物理内存。</li>
</ul>
<p><br></p>
<h3 id="锁紧性能-lock-performance"><a href="#锁紧性能-lock-performance" class="headerlink" title="锁紧性能(lock performance)"></a>锁紧性能(lock performance)</h3><ul>
<li>MongoDB使用锁系统来确保数据集的一致性。如果某些操作需要长时间运行(long-running)，或队列窗体，随着请求和操作等待<code>lock</code>，性能将会下降；</li>
<li>锁相关的减速是可以间歇的，可查看<code>lock</code>部分是否影响了性能；</li>
<li><code>locak.deadlockCount</code>提供了遭遇死锁(deadlocks)的次数；</li>
<li>如果<code>globalLock.currentQueue.total</code>很高，则可能有大量的请求在等待<code>lock</code>。这表明并发问题(concurrency issue)可能影响性能；</li>
<li>如果<code>globalLock.totalTime</code>时间比<code>uptime</code>高，那么数据库在锁定状态中存在了大量时间；</li>
<li>长查询(long query)可能会导致索引无效使用、非最佳(non-optimal)建构设计、差的查询结构、系统体系结构问题、RAM不足导致页面错误(page fault)和磁盘读取。</li>
</ul>
<p><br></p>
<h3 id="连接数-number-of-connections"><a href="#连接数-number-of-connections" class="headerlink" title="连接数(number of connections)"></a>连接数(number of connections)</h3><p>在某些情况下，应用程序和数据库之间的连接数量可能超出服务器处理请求的能力。<code>serverStatus</code>文档中的以下字段可以提供观察：</p>
<ul>
<li><code>globalLock.activeClients</code>包含正在进行或排队的活动操作的客户端总数；</li>
<li><code>connnections</code>由以下两个字段组成： 1，<code>connections.current</code>连接到数据库实例的当前客户端总数； 2，<code>connections.available</code>可用的连接总数。</li>
</ul>
<p>如果有大量的并发程序请求，则数据库可能无法满足需求。那么就需要增加部署的容量。</p>
<p>对于读操作巨大(read-heavy)的应用程序，增加你的副本集大小并将读操作分发给SECONDARY。<br>对于写操作巨大(write-heavy)的应用程序，部署分片并将一个或多个分片添加到分片集群中，以便在mongod实例之间分配负载。</p>
<p>连接数到达峰值也可能是应用程序或驱动错误所导致的结果。</p>
<p>除非收到系统范围的限制，否则MongoDB对传入连接没有限制。在基于Unix系统上，可使用<code>ulimit</code>命令或修改<code>/etc/sysctl</code>系统文件来修改系统限制。</p>
<p><br></p>
<h3 id="数据库性能分析-database-profiling"><a href="#数据库性能分析-database-profiling" class="headerlink" title="数据库性能分析(database profiling)"></a>数据库性能分析(database profiling)</h3><p>MongoDB的<strong>profiler</strong>是一种数据库分析系统，可以帮助识别低效的查询和操作。</p>
<p>有如下分析级别(profiling-level)可用：</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>Settiing</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Off.No profiling</td>
</tr>
<tr>
<td>1</td>
<td>On.Only includes “slow” operations</td>
</tr>
<tr>
<td>2</td>
<td>On.Includes all operations</td>
</tr>
</tbody>
</table>
<p>在mongo shell中运行如下命令来配置性能分析器：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#dbsetProfilingLever()</span></div><div class="line"></div><div class="line">db.setProfilingLevel(1)</div></pre></td></tr></table></figure>
<p><code>slowOpThresholdMs</code>的设置定义了什么是一个<code>slow</code>操作，要设置一个慢操作的阈值(threshold)，可以在运行时作为<code>db.setProfilingLevel()</code>操作的一个参数来配置<code>slowOpThresholdMs</code>。</p>
<p>默认情况下，mongod将会把所有的慢查询(slow query)记录到日志，这是由<code>slowOpThresholdMs</code>定义的。</p>
<p>通过在mongo shell中使用<code>show profile</code>，你可以在数据库中的<code>system.profile</code>集合中查看性能分析器的输出。<br>或者执行如下操作：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#返回超过100ms的所有操作，这个值请高于阈值`slowOpThresholdMs`</span></div><div class="line"></div><div class="line">db.system.profile.find(</div><div class="line">	&#123; millis: &#123; <span class="variable">$gt</span>: 100 &#125; &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>你必须使用查询操作符去访问<code>system.profile</code>文档中的查询字段。</p>
<p><br></p>
<h3 id="数据库性能分析器-databases-profiler"><a href="#数据库性能分析器-databases-profiler" class="headerlink" title="数据库性能分析器(databases profiler)"></a>数据库性能分析器(databases profiler)</h3><p>数据库性能分析器(db profiler)收集有关MongoDB的<strong>写操作、游标和运行在mongod实例上的命令</strong>的细微数据，你可以在每个数据库或每个实例基础上启用性能分析(profiling)。默认情况系，分析器是关闭的。启用profiling的时候需要配置<code>profiling leverl</code>。</p>
<p>The <code>database profiler</code>将所有的数据收集到<code>system.profile</code>集合中，它是一个限制集(capped collection)。</p>
<p><br></p>
<h4 id="分析等级-Profiling-levels"><a href="#分析等级-Profiling-levels" class="headerlink" title="分析等级(Profiling levels)"></a>分析等级(Profiling levels)</h4><ul>
<li>0， 关闭分析器，不收集任何数据。<code>mongod</code>总是将操作时间长于<code>slowOpThresholdMs</code>的值写入日志。这是默认分析器级别；</li>
<li>1， 只收集慢操作的分析数据。默认是以100ms；</li>
<li>2， 收集所有数据库操作的分析数据。</li>
</ul>
<p><br></p>
<h4 id="启用分析器-profiling-和设置分析级别-profiling-level"><a href="#启用分析器-profiling-和设置分析级别-profiling-level" class="headerlink" title="启用分析器(profiling)和设置分析级别(profiling level)"></a>启用分析器(profiling)和设置分析级别(profiling level)</h4><p>当启用<code>profiling</code>，也要设置<code>profiling level</code>，分析器将数据记录到<code>system.profile</code>集合。当你在数据库中启用profiling后，MongoDB会在数据库中创建<code>system.profile</code>集合。</p>
<p>使用<code>db.setProfilingLevel()</code>来设置<code>profiling level</code>和启用profiling。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.setProfilingLevel(1)</div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>指定慢操作的阈值(the Threshold for slow operations)</strong></p>
<p>慢操作的阈值(threshold)应用于整个mongod实例。当你修改了阈值，那你就对所有的数据库实例进行了修改。修改了数据库慢操作的阈值同样也会影响整个mongod实例性能分析子系统的慢操作阈值。<br>默认情况下，慢操作的阈值为100ms。性能分析<code>level-1</code>将会记录长于阈值的慢操作到日志。</p>
<p>要更改阈值，请将两个参数(parameter)在<code>mongo shell</code>传递给<code>db.setProfilingLevel()</code>。第一个参数是为当前的数据库设置<code>profiling level</code>，第二个参数是为整个mongod实例设置默认的慢操作阈值。</p>
<p>栗子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mongo</div><div class="line"></div><div class="line">&gt;use zhang</div><div class="line">&gt;db.serProfilingLevel(1,100)</div><div class="line"></div><div class="line"><span class="comment">#会在zhang数据库下生产system.profile集合</span></div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>检查分析等级(check profiling level)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.getProfilingStatus()</div><div class="line">#default</div><div class="line">#&#123; &quot;was&quot; : 0, &quot;slowms&quot; : 100 &#125;</div><div class="line"></div><div class="line"></div><div class="line">db.getProfilingLevel()</div><div class="line">#0</div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>为一个完整的mongod实例启用profiling</strong></p>
<p>在测试环境中，处于开发目的，你可以为一个完整的mongod实例启用profiling功能。性能分析等级应用于mongod实例中的所有数据库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#设置level：1，slowOpThresholdMs: 50</div><div class="line">mongod --profile 1 --slowms 50</div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>数据库分析和分片</strong></p>
<p>无法对mongos实例启用profiling。要对分片集群启用profiling功能，你必须对分片集群中的每个mongod实例启用profiling功能才行。</p>
<p><br></p>
<h4 id="查看性能分析器的数据-profiler-data"><a href="#查看性能分析器的数据-profiler-data" class="headerlink" title="查看性能分析器的数据(profiler data)"></a>查看性能分析器的数据(profiler data)</h4><p>数据库性能分析器关于数据库操作的日志信息放置于<code>system.profile</code>集合中。如需查看性能信息，请查询该集合。</p>
<p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">db.system.profile.find()</div><div class="line"></div><div class="line">db.system.profile.find().limit(10).sort(&#123; ts: -1 &#125;).pretty()</div><div class="line"></div><div class="line">#指定时间</div><div class="line">db.system.profile.find( &#123; millis: &#123; $gt: 5 &#125; &#125; ).pretty()</div><div class="line"></div><div class="line"></div><div class="line">#除了某个命令外</div><div class="line">db.system.profile.find(&#123; op: &#123; $ne: &apos;cmd&apos; &#125; &#125;).pretty</div><div class="line"></div><div class="line">#某个特定集合</div><div class="line">db.system.profile.find( &#123; ns: &apos;db.collection&apos; &#125; ).pretty()</div><div class="line"></div><div class="line"></div><div class="line">#显示最近的事件</div><div class="line">show profile</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="分析器开销-profiler-overhead"><a href="#分析器开销-profiler-overhead" class="headerlink" title="分析器开销(profiler overhead)"></a>分析器开销(profiler overhead)</h4><p>分析器对性能影响很小。<code>system.profile</code>集合是一个默认大小为1MB的限制集。这样大小的集合通常可以存储上千份分析文档，但一些应用程序可能在每次操作中只使用或多或少的分析数据。</p>
<p><br></p>
<p><strong>在Primary上面修改<code>system.profile</code>集合的大小</strong></p>
<ol>
<li>停止profiling；</li>
<li>删除(drop)<code>system.profile</code>集合；</li>
<li>新建一个<code>system.profile</code>集合；</li>
<li>重启profiling。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use db</div><div class="line">db.serProfilingLevel(0)</div><div class="line">db.system.profile.drop()</div><div class="line">db.createCollection( &quot;system.profile&quot;, &#123; capped: true, size: 4000000 &#125; )</div><div class="line">db.setProfilingLevel(1)</div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>在Secondary上修改<code>system.profile</code>集合的大小</strong></p>
<p>在Secondary上修改<code>system.profile</code>集合的大小，你必须停止Secondary，然后以standalone模式运行它，之后执行修改步骤。当做完上述步骤之后，以一个副本集成员的方式使用standalone模式重启它。</p>
<p><br><br><br></p>
<h3 id="禁用显见的大页面-Disable-Transparent-Huge-Pages"><a href="#禁用显见的大页面-Disable-Transparent-Huge-Pages" class="headerlink" title="禁用显见的大页面(Disable Transparent Huge Pages)"></a>禁用显见的大页面(Disable Transparent Huge Pages)</h3><p>Transpatent Huge Pages(THP)是一个Linux的内存管理系统，通过使用更大的内存页，减少了在具有大量内存的机器上进行Translation Lookaside Buffer(TLB)查找的开销。</p>
<p>然而，数据库工作负载(workload)在THP中的性能往往很差，因为它们往往具有稀疏的(sparse)而不是连续的(contiguous)内存访问模式。你应该在Linux机器上禁用THP来确保MongoDB获得最佳的性能。</p>
<p><br></p>
<p><strong>1. 创建<code>init.d</code>脚本</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment">### BEGIN INIT INFO</span></div><div class="line"><span class="comment"># Provides:          disable-transparent-hugepages</span></div><div class="line"><span class="comment"># Required-Start:    $local_fs</span></div><div class="line"><span class="comment"># Required-Stop:</span></div><div class="line"><span class="comment"># X-Start-Before:    mongod mongodb-mms-automation-agent</span></div><div class="line"><span class="comment"># Default-Start:     2 3 4 5</span></div><div class="line"><span class="comment"># Default-Stop:      0 1 6</span></div><div class="line"><span class="comment"># Short-Description: Disable Linux transparent huge pages</span></div><div class="line"><span class="comment"># Description:       Disable Linux transparent huge pages, to improve</span></div><div class="line"><span class="comment">#                    database performance.</span></div><div class="line"><span class="comment">### END INIT INFO</span></div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></div><div class="line">  start)</div><div class="line">    <span class="keyword">if</span> [ -d /sys/kernel/mm/transparent_hugepage ]; <span class="keyword">then</span></div><div class="line">      thp_path=/sys/kernel/mm/transparent_hugepage</div><div class="line">    <span class="keyword">elif</span> [ -d /sys/kernel/mm/redhat_transparent_hugepage ]; <span class="keyword">then</span></div><div class="line">      thp_path=/sys/kernel/mm/redhat_transparent_hugepage</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="built_in">return</span> 0</div><div class="line">    <span class="keyword">fi</span></div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">'never'</span> &gt; <span class="variable">$&#123;thp_path&#125;</span>/enabled</div><div class="line">    <span class="built_in">echo</span> <span class="string">'never'</span> &gt; <span class="variable">$&#123;thp_path&#125;</span>/defrag</div><div class="line"></div><div class="line">    re=<span class="string">'^[0-1]+$'</span></div><div class="line">    <span class="keyword">if</span> [[ $(cat <span class="variable">$&#123;thp_path&#125;</span>/khugepaged/defrag) =~ <span class="variable">$re</span> ]]</div><div class="line">    <span class="keyword">then</span></div><div class="line">      <span class="comment"># RHEL 7</span></div><div class="line">      <span class="built_in">echo</span> 0  &gt; <span class="variable">$&#123;thp_path&#125;</span>/khugepaged/defrag</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="comment"># RHEL 6</span></div><div class="line">      <span class="built_in">echo</span> <span class="string">'no'</span> &gt; <span class="variable">$&#123;thp_path&#125;</span>/khugepaged/defrag</div><div class="line">    <span class="keyword">fi</span></div><div class="line"></div><div class="line">    <span class="built_in">unset</span> re</div><div class="line">    <span class="built_in">unset</span> thp_path</div><div class="line">    ;;</div><div class="line"><span class="keyword">esac</span></div></pre></td></tr></table></figure>
<p><strong>2. 使之可执行</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 755 /etc/init.d/<span class="built_in">disable</span>-transparent-hugepages</div></pre></td></tr></table></figure>
<p><strong>3. 配置操作系统以在开机的时候运行它</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Debian系列</span></div><div class="line">update-rc.d <span class="built_in">disable</span>-transparent-hugepages defaults</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#RedHat系列</span></div><div class="line">chkconfig --add <span class="built_in">disable</span>-transparent-hugepages</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#SUSE</span></div><div class="line">insserv /etc/init.d/<span class="built_in">disable</span>-transparent-hugepages</div></pre></td></tr></table></figure>
<p><strong>4. 如果适用，覆盖(override)tuned和ktune</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#RedHat/CentOS7</span></div><div class="line">mkdir /etc/tuned/no-thp</div><div class="line"></div><div class="line"></div><div class="line">vim /etc/tuned/no-thp/tuned.conf</div><div class="line"></div><div class="line">[main]</div><div class="line">include=virtual-guest</div><div class="line">[vm]</div><div class="line">transparent_hugepages=never</div><div class="line"></div><div class="line"></div><div class="line">tuned-adm profile no-thp</div></pre></td></tr></table></figure>
<p><strong>5. 测试你做的改变</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cat /sys/kernel/mm/redhat_transparent_hugepage/enabled</div><div class="line">cat /sys/kernel/mm/redhat_transparent_hugepage/defrag</div><div class="line"></div><div class="line"><span class="comment">#always madvise [never]</span></div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>另一种简便的方式来禁用THP</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vim /etc/rc.d/rc.local</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">'never'</span> &gt; /sys/kernel/mm/transparent_hugepage/enabled</div><div class="line"><span class="built_in">echo</span> <span class="string">'never'</span> &gt; /sys/kernel/mm/transparent_hugepage/defrag</div><div class="line"></div><div class="line">chmod u+x /etc/rc.d/rc.local</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="Unix系统下的ulimit的设置"><a href="#Unix系统下的ulimit的设置" class="headerlink" title="Unix系统下的ulimit的设置"></a>Unix系统下的<code>ulimit</code>的设置</h3><p>大多Unix-Like系统，都提供了限制每个进程和每个基本用户使用线程，文件和网络连接等系统资源的一些方法。<br><strong>ulimits</strong>防止单个用户使用太多的系统资源。有时，这些限制的默认值太小，这会导致MongoDB操作过程中出现一系列问题。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#限制文件</span></div><div class="line"><span class="comment">#/etc/security/limits.conf</span></div><div class="line"><span class="comment">#/etc/security/limits.d/</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="资源利用"><a href="#资源利用" class="headerlink" title="资源利用"></a>资源利用</h4><p>mongod和mongos每次使用线程和文件描述符来跟踪连接和管理内部操作。</p>
<p>通常情况下，所有的mongod和mongos实例：</p>
<ul>
<li>利用每一个文件描述符和线程来跟踪每个即将到来的连接；</li>
<li>将每个内部线程或pthread作为一个系统进程来跟踪。</li>
</ul>
<p><br></p>
<p><strong>mongod</strong></p>
<ul>
<li>mongod实例使用的每个数据文件都有一个文件描述符；</li>
<li>当<code>storage.journal.enabled</code>为true是，mongod进程实例使用的每个日志文件都有一个文件描述符；</li>
<li>在复制集中，每个mongod保持一个连接复制集中所有其他集合成员的连接。</li>
</ul>
<p><strong>mongos</strong></p>
<ul>
<li>mongos实例与每个分片都保持一个连接池，所有mongos可以重用连接，这样因为不用建立新连接，从而能快速的满足请求；</li>
<li>通过限制连接数，可以防止mongos因在mongod实例上创建太多连接而产生级联效应。</li>
</ul>
<p><br></p>
<h4 id="资源限制的设置"><a href="#资源限制的设置" class="headerlink" title="资源限制的设置"></a>资源限制的设置</h4><p><code>ulimit</code>是指每个user使用各种资源的限制值。因此，无论你的mongod实例是以单个用户多进程执行还是以多mongod进程执行，都可以看到对这些资源的连接。</p>
<p>ulimits有<strong>hard</strong>和<strong>soft</strong>两个方式。</p>
<ul>
<li>hard：是指用户在任何时候都可以活动的进程的最大数量，这是上限。没有任何non-root进程能够增加hard ulimit；</li>
<li>soft：是对会话或进程实际执行的限制，但任何进程都可以将其增加到hard ulimit的最大值。</li>
</ul>
<p>较低的soft limit可能无法创建新线程(thread)，如果连接数太高，则关闭错误连接。因此，将soft和hard的值都设置为推荐值是非常重要的。</p>
<p>修改<code>ulimit</code>设置之后，要重启程序修改值才会有效。可通过<code>/proc</code>文件系统查看运行进程当前的限制值。</p>
<p>使用<code>ulimit</code>对系统限制的改变在系统重启后都会恢复到默认值。需要修改其它文件来确保修改一直生效。</p>
<p><strong>ulimit</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">ulimit</span> -a</div><div class="line"></div><div class="line">core file size          (blocks, -c) 0</div><div class="line">data seg size           (kbytes, -d) unlimited</div><div class="line">scheduling priority             (-e) 0</div><div class="line">file size               (blocks, -f) unlimited</div><div class="line">pending signals                 (-i) 7170</div><div class="line">max locked memory       (kbytes, -l) 64</div><div class="line">max memory size         (kbytes, -m) unlimited</div><div class="line">open files                      (-n) 1024</div><div class="line">pipe size            (512 bytes, -p) 8</div><div class="line">POSIX message queues     (bytes, -q) 819200</div><div class="line">real-time priority              (-r) 0</div><div class="line">stack size              (kbytes, -s) 8192</div><div class="line">cpu time               (seconds, -t) unlimited</div><div class="line">max user processes              (-u) 7170</div><div class="line">virtual memory          (kbytes, -v) unlimited</div><div class="line">file locks                      (-x) unlimited</div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>修改ulimit</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-f (文件大小)</span></div><div class="line"><span class="comment">#-t (cpu 时间)</span></div><div class="line"><span class="comment">#-v (虚拟内存)</span></div><div class="line"><span class="comment">#-n (单个进程文件打开数)</span></div><div class="line"><span class="comment">#-m (memory size)</span></div><div class="line"><span class="comment">#-u (可打开的进程/线程)</span></div><div class="line"></div><div class="line"><span class="built_in">ulimit</span> -t unlimited</div><div class="line"><span class="built_in">ulimit</span> -u 64000</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="配置和维护-maintenance"><a href="#配置和维护-maintenance" class="headerlink" title="配置和维护(maintenance)"></a>配置和维护(maintenance)</h2><h3 id="Run-time-databases-configuration"><a href="#Run-time-databases-configuration" class="headerlink" title="Run-time databases configuration"></a>Run-time databases configuration</h3><p>command line和configuration file interfaces为MongoDB管理员提供了控制数据库系统操作的大量选项和设置。</p>
<p>使用配置文件启动MongoDB实例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mongod --config /etc/mongod.conf</div><div class="line">mongod -f /etc/mongod.conf</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h4><p>mongodb的配置文件从MongoDB3.0以后使用YAML格式。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line"></div><div class="line">processManagement:</div><div class="line">   fork: <span class="literal">true</span></div><div class="line">net:</div><div class="line">   bindIp: 127.0.0.1</div><div class="line">   port: 27017</div><div class="line">storage:</div><div class="line">   dbPath: /var/lib/mongodb</div><div class="line">systemLog:</div><div class="line">   destination: file</div><div class="line">   path: <span class="string">"/var/log/mongodb/mongod.log"</span></div><div class="line">   logAppend: <span class="literal">true</span></div><div class="line">storage:</div><div class="line">   journal:</div><div class="line">      enabled: <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>对于大多数以standalone模式运行的servers，以上是一个足够的基本配置。<br>Unix-Like操作系统需要以超级用户(root)权限才能运行端口小于1024的程序。</p>
<p><br></p>
<h4 id="安全考虑-security-consideration"><a href="#安全考虑-security-consideration" class="headerlink" title="安全考虑(security consideration)"></a>安全考虑(security consideration)</h4><p>下面的配置选项集合对于限制对于mongod实例的访问非常有用。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">net:</div><div class="line">   port: 27017</div><div class="line">   bindIp: 127.0.0.1,192.168.1.11</div><div class="line"></div><div class="line">security:</div><div class="line">   authorization: enabled</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="复制集和分片配置-replication-and-sharding-configuration"><a href="#复制集和分片配置-replication-and-sharding-configuration" class="headerlink" title="复制集和分片配置(replication and sharding configuration)"></a>复制集和分片配置(replication and sharding configuration)</h4><p>复制集的配置非常简单，只需要replSetName在集合中的所有成员具有一致的副本集名字。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">replication:</div><div class="line">  replSetName: zhang</div></pre></td></tr></table></figure>
<p>开启副本集认证：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#利用openssl生成keyFile</span></div><div class="line">openssl rand -base64 256 &gt; /dir/path/mongodb/keyFile</div><div class="line"></div><div class="line"></div><div class="line">security:</div><div class="line">  replSetName: zhang</div><div class="line">  keyFile: /dir/path/mongodb/keyfile</div><div class="line"></div><div class="line"></div><div class="line">chown -R mongod:mongod /dir/path/mongodb</div></pre></td></tr></table></figure>
<p>设置<code>keyFile</code>启用身份认证，并为复制集成员在相互身份认证时使用的认证文件指定一个密钥文件。密钥文件的内容是任意的，但在复制集中的所有成员和连接到该集合的mongos实例之间必须相同。不然怎么能认证通过呢。<br>秘钥文件的大小必须<strong>小于1KB</strong>，并且只能包含<strong>base64集</strong>中的字符，并且此密钥文件在Unix系统上必须<strong>not have group</strong>或<strong>not have world permissions</strong>。</p>
<p><br></p>
<h4 id="分片配置-sharding-configuration"><a href="#分片配置-sharding-configuration" class="headerlink" title="分片配置(sharding configuration)"></a>分片配置(sharding configuration)</h4><p>分片要求配置服务器和分片服务器的Mongod实例具有不同的mongod配置文件。配置服务器存储集群的元数据(metadata)，而分片服务器存储数据(data)。</p>
<p>在配置文件中给mongod实例配置<strong>配置服务器(config-server)</strong>，给<code>sharding.clusterRole</code>指定配置服务器。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#配置config-server</span></div><div class="line"></div><div class="line">net:</div><div class="line">  bindIp: 192.168.1.11</div><div class="line">  port:27001</div><div class="line">replication:</div><div class="line">  replSetName: zhang</div><div class="line">sharding:</div><div class="line">  clusterRole: configserver</div><div class="line"><span class="comment">#configserver必须要是一个部署的副本集</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="在同一个系统上运行多个数据库实例-multiple-database-instances"><a href="#在同一个系统上运行多个数据库实例-multiple-database-instances" class="headerlink" title="在同一个系统上运行多个数据库实例(multiple database instances)"></a>在同一个系统上运行多个数据库实例(multiple database instances)</h4><p><strong>在许多情况下，在单个系统(single system)上运行多个数据库实例是不推荐的。</strong></p>
<p>但可能由于一些部署或者测试的目的，你需要在单个系统上运行多个mongod实例。在这些情况下，请为每一个mongod实例使用一个基本的配置文件，但要额外配置如下值：</p>
<ul>
<li>dbpath(必须);</li>
<li>pidFilePath(必须);</li>
<li>systemLog(非必须，但建议开启);</li>
</ul>
<p>栗子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#mongod_27017实例</span></div><div class="line">vim /etc/mongod_27017.conf</div><div class="line"></div><div class="line">systemLog:</div><div class="line">  path: /var/<span class="built_in">log</span>/mongod_27017.log</div><div class="line">storage:</div><div class="line">  dbPath: /var/lib/mongodb27017</div><div class="line">processManagement:</div><div class="line">  pidFilePath: /var/lib/mongodb27017/mongod_27017.pid</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#mongod_27018实例</span></div><div class="line">vim /etc/mongod_27018.conf</div><div class="line"></div><div class="line">systemLog:</div><div class="line">  path: /var/<span class="built_in">log</span>/mongod_27018.log</div><div class="line">storage:</div><div class="line">  dbPath: /var/lib/mongodb27018</div><div class="line">processManagement:</div><div class="line">  pidFilePath: /var/lib/mongodb27018/mongod_27018.pid</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##启动实例</span></div><div class="line">mongod -f /etc/mongod_27017.conf</div><div class="line">mongod -f /etc/mongod_27018.conf</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="诊断配置-diagnostic-configuration"><a href="#诊断配置-diagnostic-configuration" class="headerlink" title="诊断配置(diagnostic configuration)"></a>诊断配置(diagnostic configuration)</h4><p>以下配置选项可控制各种mongod行为，用以诊断的目的：</p>
<ul>
<li><code>operationProfiling.mode</code>设置<code>database profiler level</code>。profiler在默认情况下不处于活动状态，因为它本身可能会影响性能。除非启用它，否则不会对查询进行分析；</li>
<li><code>operationProfiling.slowOpThresholdMs</code>配置慢操作的阈值以确定查询是否<strong>慢</strong>，用以作为分析器记录日志的目的。默认阈值是100ms；</li>
<li><code>systemLog.verbosity</code>控制mongod写入日志的日志输出量。只有在遇到未在正常日志记录级别中反映的问题是才启用此选项。</li>
</ul>
<p><br><br><br></p>
<h3 id="升级-upgrade-到最新的MongoDB"><a href="#升级-upgrade-到最新的MongoDB" class="headerlink" title="升级(upgrade)到最新的MongoDB"></a>升级(upgrade)到最新的MongoDB</h3><p>修订(revisions)提供了security patches、bug fixes以及不包含任何反向破坏更改的新的或更改的功能。但是，最新版本也可能存在一些兼容性问题，请注意。</p>
<p><br></p>
<h4 id="升级之前-before-upgrading"><a href="#升级之前-before-upgrading" class="headerlink" title="升级之前(before upgrading)"></a>升级之前(before upgrading)</h4><ul>
<li>确保备份了最新的数据集；</li>
<li>有关特定MongoDb版本的特殊事项和兼容性问题，请注意查看；</li>
<li>如果你的安装包包括了复制集，在升级期间预定维护窗口(maintanence window)。</li>
</ul>
<p><br></p>
<h4 id="升级程序-upgrade-procedure"><a href="#升级程序-upgrade-procedure" class="headerlink" title="升级程序(upgrade procedure)"></a>升级程序(upgrade procedure)</h4><p><strong>在升级之前请一定要备份所有数据！</strong></p>
<p>按照如下步骤升级：</p>
<ol>
<li>对于使用认证的部署，首先升级所有的MongoDB drivers；</li>
<li>升级分片集群；</li>
<li>升级任一standalone实例；</li>
<li>升级不属于分片集群的任一副本集。</li>
</ol>
<p><br></p>
<h4 id="升级一个MongoDB实例"><a href="#升级一个MongoDB实例" class="headerlink" title="升级一个MongoDB实例"></a>升级一个MongoDB实例</h4><p>要升级mongod或mongos实例，使用如下方法之一：</p>
<ul>
<li>使用操作系统的包管理工具和官方MongoDB包进行升级(推荐的方法)；</li>
<li>使用新二进制文件替换现有二进制文件来升级实例。</li>
</ul>
<p><br></p>
<h4 id="替换现有二级制文件-replace-the-existing-binaries"><a href="#替换现有二级制文件-replace-the-existing-binaries" class="headerlink" title="替换现有二级制文件(replace the existing binaries)"></a>替换现有二级制文件(replace the existing binaries)</h4><p><strong>在升级MongoDB前请一定备份你的所有数据！</strong></p>
<p>首选的升级方式是使用包管理工具和官方的MongoDB包。</p>
<p>通过替换现有二进制文件来升级mongod或mongos实例，执行如下操作：</p>
<ol>
<li>下载最新MongoDB二进制文件到本地，并解压缩到MongoDB安装目录；</li>
<li>关闭实例；</li>
<li>替换二进制文件；</li>
<li>重启实例。</li>
</ol>
<p><br></p>
<h4 id="升级分片集群"><a href="#升级分片集群" class="headerlink" title="升级分片集群"></a>升级分片集群</h4><ol>
<li>禁用分片集群的平衡器(blancer)；</li>
<li>升级配置服务器(config-server)；</li>
<li>升级每个分片；</li>
<li>升级每个mongos实例；</li>
<li>重新启用平衡器。</li>
</ol>
<p><br></p>
<h4 id="升级复制集"><a href="#升级复制集" class="headerlink" title="升级复制集"></a>升级复制集</h4><p>若要升级复制集，请单独升级每个副本集成员。从Secondary开始，最后以Primary结束。</p>
<p><br></p>
<p><strong>升级SECONDARY</strong></p>
<ol>
<li>升级SECONDARY的mongod实例；</li>
<li>升级一个Secondary之后，在升级下一个实例之前，请等待Secondary恢复(recover)到SECONDARY state。使用<code>rs.status()</code>命令来检查复制集成员的状态。</li>
</ol>
<p><strong>升级PRIMARY</strong></p>
<ol>
<li>使用<code>rs.stepDown</code>命令来退出primary，以启动正常的故障转移过程；</li>
<li>查看是否有另外的SECONDARY节点成为了PRIMARY节点；</li>
<li>关闭并升级实例。</li>
</ol>
<p><br><br><br></p>
<h3 id="管理mongod进程"><a href="#管理mongod进程" class="headerlink" title="管理mongod进程"></a>管理mongod进程</h3><h4 id="开启mongod进程"><a href="#开启mongod进程" class="headerlink" title="开启mongod进程"></a>开启mongod进程</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mongod</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定数据目录</span></div><div class="line">mongod --dbpath /dir/mongodb/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定TCP端口</span></div><div class="line">mondod --port 12345</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#将mongod以守护进程的方式启动</span></div><div class="line">mongod --fork --logpath /var/<span class="built_in">log</span>/mongod.log</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#其他选项</span></div><div class="line">mongod --<span class="built_in">help</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="停止mongod进程"><a href="#停止mongod进程" class="headerlink" title="停止mongod进程"></a>停止mongod进程</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#使用shutdownServer()</span></div><div class="line">use admin</div><div class="line">db.shutdownServer()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#使用--shutdown</span></div><div class="line">mongod --shutdown</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#使用ctrl+c</span></div><div class="line">ctrl+c</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#使用kill</span></div><div class="line"><span class="comment">#千万不要使用kill -9(SIGKILL)来终止mongod</span></div><div class="line"><span class="built_in">kill</span> mongod_pid</div><div class="line"><span class="built_in">kill</span> -2 mongod_pid</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="停止一个复制集"><a href="#停止一个复制集" class="headerlink" title="停止一个复制集"></a>停止一个复制集</h4><p>步骤：</p>
<ol>
<li>检查SECONDARY的oplog的时间戳；</li>
<li>如果从节点的时间戳落后于主节点10s内，mongod将会返回不会被关闭的消息。你可以传递一个<code>timeoutSecs</code>参数给shutdown命令来等待从节点追上主节点；</li>
<li>一旦从节点追上进度或60s后，主节点将会关闭。</li>
</ol>
<p>强制关闭复制集：<code>db.adminCommand( { shutdown: 1, force: true } )</code></p>
<p>如果没有节点能立刻更新到最新的数据，发送<code>shutdown</code>加上<code>timeoutSecs</code>参数来在指定的时间内保持对从节点的检查。如果在分配的时间内有任意的一个从节点追上，主节点将会关闭。反之，主节点不会关闭。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.adminCommand(&#123; <span class="attr">shutdown</span>: <span class="number">1</span>, <span class="attr">timeoutSecs</span>: <span class="number">5</span> &#125;)</div><div class="line"></div><div class="line">#或</div><div class="line">db.shutdownServer(&#123; <span class="attr">timeoutSecs</span>: <span class="number">5</span>&#125;)</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="终止-Terminate-运行的操作"><a href="#终止-Terminate-运行的操作" class="headerlink" title="终止(Terminate)运行的操作"></a>终止(Terminate)运行的操作</h3><p>MongoDB提供了两种方法来终止正在运行的操作。</p>
<ul>
<li><code>maxTimeMS()</code></li>
<li><code>db.killOp()</code></li>
</ul>
<p><br></p>
<h4 id="maxTimeMS"><a href="#maxTimeMS" class="headerlink" title="maxTimeMS()"></a>maxTimeMS()</h4><p><code>maxTimeMS()</code>方法给一个操作(operation)设置了时间限制(time limit)。这个时间单位默认是毫秒(ms)。当这个操作达到了指定的时间限制时，MongoDB将在下一个中断点(interrupt point)中断这个操作。</p>
<p>栗子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">db.location.find(</div><div class="line">  &#123;</div><div class="line">	<span class="string">"town"</span>: &#123; <span class="string">"$regex"</span>: <span class="string">"(Pine Lumber)"</span>,</div><div class="line">    			<span class="string">"$options"</span>: <span class="string">'i'</span> &#125;</div><div class="line">  &#125; ).maxTimeMS(<span class="number">30</span>)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">db.runCommand(</div><div class="line">  &#123;</div><div class="line">	distinct: <span class="string">"collection"</span>,</div><div class="line">    key: <span class="string">"city"</span>,</div><div class="line">    maxTimeMS: <span class="number">45</span></div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="killOp"><a href="#killOp" class="headerlink" title="killOp"></a>killOp</h4><p><code>killOp()</code>方法将在下一个中断节点中断正在运行的操作。<code>killOp()</code>方法通过<strong>操作ID</strong>(operation ID)来标识目标操作。</p>
<p>栗子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.killOp(&lt;opID&gt;)</div><div class="line"></div><div class="line"></div><div class="line">#查看正在运行的操作</div><div class="line">db.currentOp()</div></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>终止正在运行的操作时一定要谨慎！只使用<code>db.killOp()</code>方法来终止由客户端发起的操作，而不要终止内部数据库(internal database)的操作。</p>
<p><br><br><br></p>
<h3 id="轮询-rotate-日志文件"><a href="#轮询-rotate-日志文件" class="headerlink" title="轮询(rotate)日志文件"></a>轮询(rotate)日志文件</h3><p>当使用<code>--logpath</code>选项或<code>systemLog.path</code>设置时，mongod或mongos实例会将所有活动和操作的实时账户报告给日志文件。默认情况下，只有当使用了<code>logRotate</code>命令，或者mongod或mongos进程从操作系统接收到一个<code>SIGUSR1</code>信号时，才会进行日志轮询响应。</p>
<p>MongoDB的标准日志轮询方法会存档当前日志文件并启动一个新的日志文件。为此，mongod或mongos实例将通过ISODate日期格式的UTC时间戳来重命名当前日志文件。然后它会打开一个新的日志文件，关闭旧的日志文件，并将所有新的日志发送到新的日志文件。</p>
<p>你也可以通过配置MongoDB的<code>systemLog.logRatate</code>或<code>--logRotate</code>选项，来支持Unix/Linux的日志轮询功能。<br>最后，你可以使用<code>--syslog</code>选项来配置mongod发送日志数据到系统日志。在这种情况下，你可以选用其他的日志轮询工具。</p>
<p><br></p>
<h4 id="默认日志轮询行为"><a href="#默认日志轮询行为" class="headerlink" title="默认日志轮询行为"></a>默认日志轮询行为</h4><p><strong>在mongo shell中轮询日志：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#开启一个实例</span></div><div class="line">mongod -v --logpath /var/<span class="built_in">log</span>/mongodb/test01.log</div><div class="line"></div><div class="line"><span class="comment">#列出日志文件</span></div><div class="line">ls /var/<span class="built_in">log</span>/mongodb/test01.log*</div><div class="line"></div><div class="line"><span class="comment">#轮询日志文件</span></div><div class="line">mongo</div><div class="line">&gt;use admin</div><div class="line">&gt;db.runCommand(&#123; logRotate: 1 &#125;)</div><div class="line"></div><div class="line"><span class="comment">#查看新的日志文件</span></div><div class="line">ls /var/<span class="built_in">log</span>/mongodb/test01.log*</div><div class="line"><span class="comment">#new: test01.log</span></div><div class="line"><span class="comment">#old: test01.log-2018-01-11T08-22-50</span></div></pre></td></tr></table></figure>
<p><strong>使用<code>--logRotate reopen</code>选项轮询日志：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mongod -v --logpath /var/<span class="built_in">log</span>/mongodb/test01.log --logRotate reopen --logapend</div><div class="line"></div><div class="line">ls /var/<span class="built_in">log</span>/mongodb/test01.log*</div><div class="line"></div><div class="line">mongo</div><div class="line">&gt;use admin</div><div class="line">&gt;db.runCommand(&#123; logRotate: 1 &#125;)</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="系统日志轮询-Syslog-log-rotate"><a href="#系统日志轮询-Syslog-log-rotate" class="headerlink" title="系统日志轮询(Syslog log rotate)"></a>系统日志轮询(Syslog log rotate)</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod --syslog</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="使用SIGUSR1强制日志轮询"><a href="#使用SIGUSR1强制日志轮询" class="headerlink" title="使用SIGUSR1强制日志轮询"></a>使用SIGUSR1强制日志轮询</h4><p>对于基于Unix/Linux的系统，可以使用<strong>SIGUSR1</strong>信号来轮询单个进程的日志。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">kill</span> -SIGUSR1 &lt;mongod-pid&gt;</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="数据中心意识-data-center-awareness"><a href="#数据中心意识-data-center-awareness" class="headerlink" title="数据中心意识(data center awareness)"></a>数据中心意识(data center awareness)</h2><h3 id="MongoDB部署中的分离-segregation-操作"><a href="#MongoDB部署中的分离-segregation-操作" class="headerlink" title="MongoDB部署中的分离(segregation)操作"></a>MongoDB部署中的分离(segregation)操作</h3><p>MongoDB拥有许多特性，包括允许数据库管理员和开发者在部署数据库的过程中通过一些功能或地理组群对数据库应用进行分割操作。</p>
<p>MongoDB支持跨越不同维度的操作的分段，这可能包括了在单个数据中心(single data center)的部署中的多数据中心(multi-date center)部署、机架、网络或电源电路的多个数据中心和地理区域。</p>
<p>MongoDB还支持基于功能或操作参数的数据库分离操作，以确保某些mongod实例仅用于报告工作负载，或只在特定的分片上分离集合的某些高频部分。</p>
<p><br></p>
<p>特别是在MongoDB中你可以：</p>
<ul>
<li>确保写操作传播到复制集的特定成员；</li>
<li>确保复制集中的特定成员响应了查询操作；</li>
<li>确保分片键在具体范围上的平衡，并且驻留在特定的分片上。</li>
</ul>
<p><br></p>
<h3 id="区域-zone"><a href="#区域-zone" class="headerlink" title="区域(zone)"></a>区域(zone)</h3><h4 id="管理分片区域-manage-shard-zones"><a href="#管理分片区域-manage-shard-zones" class="headerlink" title="管理分片区域(manage shard zones)"></a>管理分片区域(manage shard zones)</h4><p><br></p>
<h4 id="按位置分割数据-segementing-data-by-location"><a href="#按位置分割数据-segementing-data-by-location" class="headerlink" title="按位置分割数据(segementing data by location)"></a>按位置分割数据(segementing data by location)</h4><p><br></p>
<h4 id="为SLA或SLO改变分层硬件"><a href="#为SLA或SLO改变分层硬件" class="headerlink" title="为SLA或SLO改变分层硬件"></a>为SLA或SLO改变分层硬件</h4><p><br></p>
<h4 id="按应用程序或客户分割数据"><a href="#按应用程序或客户分割数据" class="headerlink" title="按应用程序或客户分割数据"></a>按应用程序或客户分割数据</h4><p><br></p>
<h4 id="Distributed-Local-Writes-for-Insert-Only-Workloads"><a href="#Distributed-Local-Writes-for-Insert-Only-Workloads" class="headerlink" title="Distributed Local Writes for Insert Only Workloads"></a>Distributed Local Writes for Insert Only Workloads</h4><p><br></p>
<h4 id="管理分片区域"><a href="#管理分片区域" class="headerlink" title="管理分片区域"></a>管理分片区域</h4><p><br><br><br></p>
<h2 id="MongoDB备份方案-backup-methods"><a href="#MongoDB备份方案-backup-methods" class="headerlink" title="MongoDB备份方案(backup methods)"></a>MongoDB备份方案(backup methods)</h2><p><strong>在生存中部署MongoDB时，如果发生数据丢失的事件，你应该指定一个捕获和恢复备份的策略(strategy)。</strong></p>
<p><br></p>
<p><strong>back up with MongoDB cloud manager or Ops manager</strong></p>
<ul>
<li>MongoDB Cloud Manager</li>
<li>Ops Manager</li>
</ul>
<p><br></p>
<p><strong>复制底层数据文件进行备份(back up by copying underlying data files)</strong></p>
<ul>
<li>使用文件系统快照备份(back up with filesystem snapshots)</li>
</ul>
<p>你可以通过复制MongoDB的底层数据文件来创建MongoDB部署的备份。<br>如果MongoDB储存其数据文件的卷(volume)支持时间点快照(point-in-time snapshots)，则可以使用这些快照在某个时刻创建MongoDB系统的备份。<br>文件系统的快照是一个操作系统的卷管理器的功能，并没有具体到MongoDB。通过文件系统快照，操作系统将卷的快照用作数据备份的基准。快照的机制取决于底层的存储系统。<br>例如，在Linux上，逻辑卷管理器(LVM)可以创建快照。</p>
<p>要获得运行中的MongoDB进程的正确快照，必须启用日志记录(jorunaling)，并且日志必须与其它MongoDB数据文件存储在相同的逻辑卷上。如果没有启用日志记录，则无法保证快照将是一致有效地。</p>
<p>为了获得分片集群一致的快照，你必须禁用平衡器(balancer)和捕捉每一个分片的快照以及大约在同一时刻的配置服务器。</p>
<ul>
<li>使用<code>cp</code>或<code>scp</code>备份</li>
</ul>
<p>如果你的系统不支持快照功能，则可以使用<code>cp</code>，<code>rsync</code>或类似的工具直接复制文件。<br>由于复制多个文件不是原子操作，因此你必须在复制文件之前停止对mongod的所有写入。否则，你将复制处于无效状态的文件。</p>
<p>复制底层数据而产生的备份不支持复制集的时间恢复节点，并且难以管理更大的共享集群。此外，这些备份很大。因为它们包括索引和复制底层存储填充和分片。<br>相反，<code>mongodump</code>会创建较小的备份。</p>
<ul>
<li>使用<code>mongodump</code>备份</li>
</ul>
<p>如果在<code>mongodump</code>创建备份的同时，应用程序对数据进行修改，那么<code>mongodump</code>将会与这些应用竞争资源。</p>
<p><code>mongodump</code>从一个MongoDB数据库中读取数据，并创建高保真度(high fidelity)的BSON文件。<code>mongorestore</code>工具可使用这个文件来进行MongoDB数据库恢复。<br><code>mongodump</code>和<code>mongorestore</code>是用于备份和恢复小型MongoDB部署的简单和高效的工具，但对于捕获较大的系统并不理想。</p>
<p><code>mongodump</code>和<code>mongorestore</code>针对正在运行的mongod进程进行操作，可以直接操纵底层的数据文件。默认情况下，<code>mongodump</code>不会捕获<code>local database</code>数据库的内容。</p>
<p><code>mongodump</code>只捕获数据库中的文档(documents)，用以给备份节省空间，但<code>mongorestore</code>或mongod必须在恢复数据之后重建索引。</p>
<p>当连接到MongoDB实例时，<code>mongodump</code>可能会对MongoDB的性能产生不利影响。如果你的数据大小大于系统内存，查询可能会将工作单元从内存中推开，从而导致页面错误。</p>
<p>当<code>mongodump</code>在捕获输出时，应用程序可以继续修改数据。对于复制集来说，<code>mongodump</code>提供了<code>--oplog</code>选项来用以在<code>mongodump</code>操作期间包含数据的oplog条目。这允许相应的<code>mongorestore</code>操作去还原所捕获的oplog。</p>
<p>然而，对于复制集来说，请考虑使用MongoDB Cloud Manager 或 Ops Manager来备份。</p>
<p><br><br><br></p>
<h3 id="使用文件系统快照进行备份和恢复-back-up-and-restore-with-filesystem-snapshots"><a href="#使用文件系统快照进行备份和恢复-back-up-and-restore-with-filesystem-snapshots" class="headerlink" title="使用文件系统快照进行备份和恢复(back up and restore with filesystem snapshots)"></a>使用文件系统快照进行备份和恢复(back up and restore with filesystem snapshots)</h3><p>使用系统工具创建MongoDB系统的备份，诸如<strong>LVM</strong>，或<strong>block-level</strong>备份方法。使用系统工具来创建MongoDB数据文件的设备的副本。这些方法完成迅速、工作可靠，但是需要在MongoDB之外进行额外的系统配置。</p>
<p><br></p>
<h4 id="快照综述-snapshots-overview"><a href="#快照综述-snapshots-overview" class="headerlink" title="快照综述(snapshots overview)"></a>快照综述(snapshots overview)</h4><p>快照的工作方式是在实时数据(live data)和一个特定快照卷之间创建指针(pointer)。这个指针在理论上等同于<strong>硬链接(hard link)</strong>。作为工作数据偏离的快照，快照过程使用<strong>写时复制</strong>(copy-on-write)策略。结果，快照又只存储修改的数据。</p>
<p>创建快照后，在文件系统上挂载(mount)快照镜像，并从中复制数据。生成的备份包含所有数据的完整副本。</p>
<p><br></p>
<p><strong>Valid database at the time of snapshot</strong></p>
<p>当快照生成时数据库必须有效。这就意味着数据库所接收的所有写入(write)都需要完整的写入磁盘————无论是<code>journal</code>还是数据文件。<br>如果备份发生时磁盘上没有写入(write)，备份将不反映这些更改。</p>
<p>对于WiredTiger storage engine，数据文件反映了最后一个检查点(last checkpoint)的一致状态。每2GB的数据或每分钟就会出现检查点。</p>
<p><br></p>
<p><strong>Entire disk image</strong></p>
<p>快照创建一个整个磁盘镜像的镜像。除非你需要备份你的整个系统，否则考虑隔离(isolate)你的MongoDB数据文件、journal，并配置一个不包含任何其他数据的逻辑磁盘。<br>或者，将所有的MongoDB数据文件保存在一个专用的设备上，这样你就可以在没有重复(duplicating)和无关(extraneous)数据的情况下进行备份。</p>
<p><br></p>
<p><strong>Site failure precaution</strong></p>
<p>确保将数据从快照复制到其他系统。这确保了在站点故障(site failure)的时候数据是安全的。</p>
<p><br></p>
<p><strong>No incremental backups</strong></p>
<p>本教程不包含增量备份(incremental backups)的过程。虽然不同的快照方法提供了不同的功能，但下面列出的LVM方法不提供捕获增量备份的任何容量。</p>
<p><br></p>
<p><strong>Snapshots with journaling</strong></p>
<p>如果你的mongod实例启用了journaling，则可以使用任何类型的文件系统和volume/block level快照工具来创建备份。</p>
<p>如果你在基于Linux的系统上管理你自己的基础架构，请使用LVM配置你的系统以提供磁盘包并提供快照功能。</p>
<p><br></p>
<h4 id="在Linux上使用LVM进行备份和还原"><a href="#在Linux上使用LVM进行备份和还原" class="headerlink" title="在Linux上使用LVM进行备份和还原"></a>在Linux上使用LVM进行备份和还原</h4><p>生产备份系统必须考虑一些特定环境的应用程序特定需求和因素。</p>
<p><br></p>
<p><strong>Crete a snapshot</strong></p>
<ul>
<li>确保你创建的快照具有足够的空间来考虑数据的增长；</li>
<li>如果快照超出了空间，快照镜像将无法使用。请放弃这个逻辑卷并创建另外一个；</li>
<li>命令执行完毕时快照将存在。你可以随时直接从快照进行还原，也可以创建新的逻辑卷并从此快照还原到备用镜像；</li>
<li>虽然快照对于快速创建高质量的备份非常好，但它们并不是理想的作为存储备份数据的格式；</li>
<li>快照通常取决于并位于与原始磁盘镜像相同的存储基础架构上。因此，将这些快照存档并将其存储在别处至关重要。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#下面的这个vg-name指卷组名，这个卷组首先需要建立</span></div><div class="line"><span class="comment">#系统卷组和设备的位置和路径可能因LVM的配置二略有不同</span></div><div class="line"><span class="comment">#此大小不反映数据大小</span></div><div class="line"></div><div class="line">lvcreate --size 1G --snapshot --name mongodb-snap20180111 /dev/vg-name/mongodb</div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>Archive a snapshot</strong></p>
<p>创建好snapshot之后，挂载<code>mount</code>快照并将数据复制到单独的存储中。</p>
<p>压缩快照：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">umount /dev/vg-name/mongodb-snap01</div><div class="line">dd <span class="keyword">if</span>=/dev/vg-name/mongodb-snap01 | gzip &gt; mongodb-snap01.gz</div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>Restore a snapshot</strong></p>
<p>同样适用LVM进行还原。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#lv-mongodb, vg0-vgname</span></div><div class="line"></div><div class="line">lvcreate --size 1G --name mongodb vg0</div><div class="line">gzip -d -c mongodb-snap01.gz | dd of=/dev/vg0/mongodb</div><div class="line">mount /dev/bg0/mongodb /dir/path</div></pre></td></tr></table></figure>
<p>还原的快照中有一个陈旧的<code>mongo.lock</code>文件，如果你没有从快照中删除此文件，那么MongoDB可能会认为锁文件指示的是不正常的关闭。如果你开启了<code>storage.journal.enabled</code>，但没有使用<code>db.fsyncLock()</code>的话，那不需要删除<code>mongo.lock</code>文件，反之，删除它。</p>
<p><br></p>
<p><strong>Restore directly form a snapshot</strong></p>
<p>不使用gz压缩文件下还原备份。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">umount /dev/vg-name/mongodb-snap01</div><div class="line">lvcreate --size 1G --name mongodb vg0</div><div class="line">dd <span class="keyword">if</span>=/dev/vg0/mongodb-snap01 of=/dev/vg0/mongodb</div><div class="line">mount /dev/vg0/mongodb /dir/path</div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>Remote backup storage</strong></p>
<p>可以使用组合的进程和SSH实施离线备份。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">umount /dev/vg-name/mongodb-snap01</div><div class="line">dd <span class="keyword">if</span>=/dev/vg0/mongodb-snap01 | ssh user@host gzip &gt; /dir/path/mongodb-snap01.gz</div><div class="line">lvcreate --size 1G --name mongodb vg0</div><div class="line">ssh user@host gzip -d -c /dir/path/mongodb-snap-01.gz | dd of =/dev/vg0/mongodb</div><div class="line">mount /dev/vg0/mongodb /dir/path</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="使用单独卷上的Journal日志文件或没有Journal日志文件进行备份实例"><a href="#使用单独卷上的Journal日志文件或没有Journal日志文件进行备份实例" class="headerlink" title="使用单独卷上的Journal日志文件或没有Journal日志文件进行备份实例"></a>使用单独卷上的Journal日志文件或没有Journal日志文件进行备份实例</h4><p>从MongoDB3.2开始，为了使用WiredTiger对MongoDB实例进行volume-level备份，数据文件和Journal日志文件不再要求驻留在一个卷上。</p>
<p>如果你的mongod实例没有使用Journal，或者启用了将Journal志文件放置于一个单独的卷上，则必须刷新(flush)对磁盘的所有写入，并在备份期间锁住数据库用以阻止写操作。<br>如果有复制集(replica set)配置，那么你可以在SECONDARY上不接收读取用以备份数据。</p>
<p><br></p>
<p><strong>1. 刷新写入磁盘并锁定数据库以防止进一步的写入：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#锁住数据库</div><div class="line">db.fsyncLock();</div></pre></td></tr></table></figure>
<p><strong>2. 使用快照备份数据库：</strong></p>
<p><strong>3. 解锁数据库：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#解锁数据库</div><div class="line">db.fsyncUnlock();</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="使用MongoDB工具进行备份和恢复-back-up-and-restore-with-MongoDB-tools"><a href="#使用MongoDB工具进行备份和恢复-back-up-and-restore-with-MongoDB-tools" class="headerlink" title="使用MongoDB工具进行备份和恢复(back up and restore with MongoDB tools)"></a>使用MongoDB工具进行备份和恢复(back up and restore with MongoDB tools)</h3><p>使用MongoDB提供的备份还原工具——<code>mongodump</code>和<code>mongorestore</code>来处理BSON data，对于创建小型部署的备份是很有用的。<br>对于弹性(resilient)备份和非破坏性(non-disruptive)备份，使用文件系统或块级磁盘快照。</p>
<p>因为<code>mongodump</code>和<code>mongorestore</code>操作通过与正在运行中的<code>mongod</code>实例进行交互(interacting)，它们会影响正在运行的数据库的性能(performance)。这些工具不仅会为正在运行的数据库实例创建流量，还会强制数据库通过内存读取所有的数据。当MongoDB读取不经常(infrequently)使用的数据时，它会驱逐(evict)频繁(frequently)访问的数据，导致数据库正常工作负载的性能下降。</p>
<p><br></p>
<p>当使用MongoDB’s tools 来备份你的数据时，考虑如下建议：</p>
<ul>
<li>标签文件(label file)，以便你可以识别备份的内容以及备份所反映的时间点</li>
<li>如果对你来说，<code>mongodump</code>和<code>mongorestore</code>对性能的影响是不可接受的，请使用替代备份策略——filesystem snapshot或MongoDB CloudManager</li>
<li>使用<code>--oplog</code>去捕获在<code>mongodump</code>期间的传入写(write)操作，以确保备份一致性的数据状态</li>
<li>通过将备份文件还原到测试环境中，以确认备份是可用的</li>
</ul>
<p><br></p>
<h4 id="MongoDB-tools"><a href="#MongoDB-tools" class="headerlink" title="MongoDB tools"></a>MongoDB tools</h4><p><strong>MongoDB工具介绍及区别：</strong></p>
<ul>
<li><p>mongoexport<br><code>mongoexport</code> is a utility that produces a <strong>JSON or CSV</strong> export of data stored in a MongoDB instance.</p>
</li>
<li><p>mongoimport<br>The <code>mongoimport</code> tool imports content from an <strong>Extended JSON, CSV, or TSV</strong> export created by mongoexport, or potentially, another third-party export tool.</p>
</li>
<li><p>mongodump<br><code>mongodump</code> is a utility for creating a <strong>binary export of the contents of a database</strong>. mongodump can export data from either mongod or mongos instances.<br>mongodump excludes the content of the local database in its output.<br>The mongodump utility backs up data by connecting to a running mongod or mongos instance.</p>
</li>
<li><p>mongorestore<br>The <code>mongorestore</code> program writes data from a <strong>binary database dump</strong> created by mongodump to a MongoDB instance.</p>
</li>
</ul>
<p><br></p>
<h4 id="步骤-Procedures"><a href="#步骤-Procedures" class="headerlink" title="步骤(Procedures)"></a>步骤(Procedures)</h4><h5 id="使用mongodump备份"><a href="#使用mongodump备份" class="headerlink" title="使用mongodump备份"></a>使用mongodump备份</h5><ul>
<li>`mongodump·备份数据库，如果数据库启用了访问控制，则必须拥有每个备份的数据库查询的权限。内置的备份角色提供了执行任何和数据库备份有关所需的权限。</li>
<li>这就意味着你使用<code>mongodump</code>的user必须要对所备份的数据库有读取权限。</li>
<li><code>mongodump</code>能够为<strong>整个服务器、数据库或集合</strong>创建备份，或者使用查询仅备份集合的一部分。</li>
<li><code>mongodump</code>默认排除<code>local</code>数据库。</li>
<li><code>mongodump</code>必须要能够连接到正在运行的mongod或mongos实例。默认连接为127.0.0.1:27017。</li>
<li><code>mongodump</code>默认创建在当前目录下创建./dump备份文件。</li>
<li>如果<code>mongodump</code>备份目录中已经存在备份数据目录，那么<code>mongodump</code>将会覆盖它们。</li>
<li>指定认证库来认证你的用户名和密码。</li>
</ul>
<p><br></p>
<p><strong>使用oplog进行时间点操作</strong></p>
<ul>
<li>在<code>mongodump</code>中使用<code>--oplog</code>选项来收集oplog条目，用以在副本集中构建数据库的实时快照。</li>
<li>使用<code>--oplog</code>，<code>mongodump</code>会从源数据库复制所有的数据，包括备份开始到结束这段时间所有的oplog记录。</li>
<li>在<code>mongorestore</code>还原时使用<code>--oplogReplay</code>选项，允许你还原特定时间节点的备份。这就对应在<code>mongodump</code>期间oplog的记录。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#127.0.0.1:27017 ./dump</span></div><div class="line">mongodump</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--host,-h  --port</span></div><div class="line">mongodump -h mongodb.example.net --port 27107</div><div class="line">mongudump -h 127.0.0.1 --port 27018</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-o, --out</span></div><div class="line">mongoodump -o /var/mongodb_backup/</div><div class="line">mongodump --host 127.0.0.1 --port 27017 --out /var/mongodb_backup/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--collection, --db</span></div><div class="line">mongodump --db zhang --out /var/mongodb_backup/zhang</div><div class="line">mongodump --db zhang --collection <span class="built_in">test</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--authenticationDatabase</span></div><div class="line">mongodump --port 27018 -u zhang -p <span class="string">"passwd"</span>  --authenticationDatabase admin -d zhang -o /var/mongodb_backup/zhang</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="使用mongorestore还原"><a href="#使用mongorestore还原" class="headerlink" title="使用mongorestore还原"></a>使用mongorestore还原</h4><p>若要将数据还原到启用了访问控制的MongoDB部署，如果备份数据不包括<code>system.profile</code>集合数据，则restore角色提供了对数据库的访问权限。</p>
<p>如果备份数据包含了<code>system.profile</code>集合并且目标数据库不包含<code>system.profile</code>集合，那么<code>mongorestore</code>会去创建这个集合即使<code>mongorestore</code>并没有还原<code>system.profile</code>文档。因此，用户就需要额外的权限才能在<code>system.profile</code>集合中上执行<code>createCollection</code>和<code>convertToCapped</code>。</p>
<p>如果使用<code>--oplogReplay</code>，这个restore角色还不足以重放oplog。所以如果需要重放oplog，请使用一个能够重放oplog的角色。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mongorestore /var/mnogodb_backup</div><div class="line"></div><div class="line"></div><div class="line">mongorestore /var/mnogodb_backup --oplogReplay</div><div class="line"></div><div class="line"></div><div class="line">mongorestore --port 27018 -u zhang -p <span class="string">"passwd"</span> --authecticationDatabase admin -d zhang /var/mongodb_back/zhang</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="批量化操作mongo-shell-EOF"><a href="#批量化操作mongo-shell-EOF" class="headerlink" title="批量化操作mongo shell(EOF)"></a>批量化操作mongo shell(<code>EOF</code>)</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> coll <span class="keyword">in</span> &#123;collection1,collection2,...&#125;</div><div class="line"><span class="keyword">do</span></div><div class="line">	mongo host:port/db -u x -p xx &lt;&lt; EOF</div><div class="line">    use db</div><div class="line">    db.<span class="variable">$coll</span>.drop()</div><div class="line">    EOF</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="从MongoDB备份中还原副本集"><a href="#从MongoDB备份中还原副本集" class="headerlink" title="从MongoDB备份中还原副本集"></a>从MongoDB备份中还原副本集</h3><p>你不能将单个数据集(data set)还原为三个新的mongod实例，然后为此创建一个副本集(replication set)。<br>如果你将数据集复制到每个mongod实例，然后创建副本集，则MongoDB将强制SECONDARY执行<code>initial sync</code>。</p>
<p><br></p>
<h4 id="向一个单一副本集节点中还原数据-Restore-Database-into-a-Single-Node-Replica-Set"><a href="#向一个单一副本集节点中还原数据-Restore-Database-into-a-Single-Node-Replica-Set" class="headerlink" title="向一个单一副本集节点中还原数据(Restore Database into a Single Node Replica Set)"></a>向一个单一副本集节点中还原数据(Restore Database into a Single Node Replica Set)</h4><ol>
<li><p>获取备份数据库文件</p>
</li>
<li><p>使用备份数据库文件作为数据库路径启动一个mongod实例</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#方法1，直接启动</span></div><div class="line">mongod --dbpath /dir/path/mongodump --replSet &lt;replName&gt;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#方法2，使用配置文件启动，推荐</span></div><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">storage:</div><div class="line">  dbPath: /dir/path/mongodump</div><div class="line">replication:</div><div class="line">  replSetName: zhang</div></pre></td></tr></table></figure>
<ol>
<li><p>连接到mongo shell</p>
</li>
<li><p>初始化这个新的副本集</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#对于有且仅有一个成员的副本集使用rs.initiate()</div><div class="line">rs.initiate()</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="向副本集中添加成员-Add-Members-to-the-Replica-Set"><a href="#向副本集中添加成员-Add-Members-to-the-Replica-Set" class="headerlink" title="向副本集中添加成员(Add Members to the Replica Set)"></a>向副本集中添加成员(Add Members to the Replica Set)</h4><p>MongoDB对于还原副本集SECONDARY节点提供了两种选择：</p>
<ol>
<li>手动复制数据库文件到数据目录</li>
<li>允许<code>initial sync</code></li>
</ol>
<p><strong>建议：</strong></p>
<blockquote>
<p>如果备份的数据库文件很大，那么<code>initial sync</code>可能需要很长的时间才能完成。对于大型数据库，最好将数据库文件复制到每台主机上。</p>
</blockquote>
<p><br></p>
<h5 id="Copy-Database-File-and-Restart-mongod-Instance"><a href="#Copy-Database-File-and-Restart-mongod-Instance" class="headerlink" title="Copy Database File and Restart mongod Instance"></a>Copy Database File and Restart mongod Instance</h5><ol>
<li>Shut down the mongod instance that you restored</li>
</ol>
<blockquote>
<p>使用 <code>--shutdown</code> 或 <code>db.shutdownServer()</code>来确保一个正常干净的关闭</p>
</blockquote>
<ol>
<li><p>复制Primary的数据目录到每个从节点</p>
</li>
<li><p>Start the mongod instance that you restorerd</p>
</li>
<li><p>Add the secondaries to the replica set</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PRIMARY&gt;rs.add()</div></pre></td></tr></table></figure>
<p><br></p>
<h5 id="Update-Secondaries-using-Initial-Sync"><a href="#Update-Secondaries-using-Initial-Sync" class="headerlink" title="Update Secondaries using Initial Sync"></a>Update Secondaries using Initial Sync</h5><ol>
<li>确保副本集成员的数据目录为空</li>
<li>将每个潜在成员添加到副本集</li>
</ol>
<p><br><br><br></p>
<h3 id="备份和还原分片集群-sharded-cluster"><a href="#备份和还原分片集群-sharded-cluster" class="headerlink" title="备份和还原分片集群(sharded cluster)"></a>备份和还原分片集群(sharded cluster)</h3><p><br></p>
<h4 id="通过文件系统快照-fs-snapshots-备份一个分片集群"><a href="#通过文件系统快照-fs-snapshots-备份一个分片集群" class="headerlink" title="通过文件系统快照(fs snapshots)备份一个分片集群"></a>通过文件系统快照(fs snapshots)备份一个分片集群</h4><p><br></p>
<h4 id="通过Database-Dumps备份一个分片集群"><a href="#通过Database-Dumps备份一个分片集群" class="headerlink" title="通过Database Dumps备份一个分片集群"></a>通过Database Dumps备份一个分片集群</h4><p><br></p>
<h4 id="Schedule-Backup-Window-for-Sharded-Clusters"><a href="#Schedule-Backup-Window-for-Sharded-Clusters" class="headerlink" title="Schedule Backup Window for Sharded Clusters"></a>Schedule Backup Window for Sharded Clusters</h4><p><br></p>
<h4 id="还原一个分片集群"><a href="#还原一个分片集群" class="headerlink" title="还原一个分片集群"></a>还原一个分片集群</h4><p><br><br><br></p>
<h3 id="从意外关闭中恢复-Recover-a-standalone-after-an-unexpected-shutdow"><a href="#从意外关闭中恢复-Recover-a-standalone-after-an-unexpected-shutdow" class="headerlink" title="从意外关闭中恢复(Recover a standalone after an unexpected shutdow)"></a>从意外关闭中恢复(Recover a standalone after an unexpected shutdow)</h3><p>当一个standalone模式的mongod实例关闭了journaling功能后，一个unclean的shutdown可能会导致数据处于不一致的状态。<br>当unclean shutdown之后，如果在dbPath下存在一个非空的<code>mongod.lock</code>文件，则mongod实例会记录如下信息：</p>
<blockquote>
<p>Dectected unclean shutdown - mongod.lock is not empty</p>
</blockquote>
<p>这样的话你必须要修复你的数据库，才能正常的启动mongod。</p>
<blockquote>
<p><strong>警告：</strong><br>不要用如下方法处理副本集 unclean shutdown。相反，你应该从备份或者从另一个副本集的成员恢复。</p>
</blockquote>
<p>默认情况下，MongoDB在启用journaling的情况下运行，以防止发生unclean shutdown时数据不一致的问题。</p>
<p>使用运行mongod实例的那个用户来进行修复，避免由权限不一致而导致的新问题。</p>
<ol>
<li>Create a backup of the data files</li>
<li>Start mongod with –repair</li>
</ol>
<p><br><br><br></p>
<h2 id="监控-Monitoring-MongoDB"><a href="#监控-Monitoring-MongoDB" class="headerlink" title="监控(Monitoring)MongoDB"></a>监控(Monitoring)MongoDB</h2><p>监控是数据库管理的重要组成部分，充分了解MongoDB的运行状态，并在没有危机的情况下维护和部署。此外，了解MongoDB的正常操作参数将允许你在问题升级成为故障前诊断他们。</p>
<p><br></p>
<h3 id="Monitoring-for-MongoDB"><a href="#Monitoring-for-MongoDB" class="headerlink" title="Monitoring for MongoDB"></a>Monitoring for MongoDB</h3><p><br></p>
<h4 id="Monitoring-Strategies-策略"><a href="#Monitoring-Strategies-策略" class="headerlink" title="Monitoring Strategies(策略)"></a>Monitoring Strategies(策略)</h4><p>有三种方法可以从运行中的MongoDB实例中收集状态信息：</p>
<ol>
<li>MongoDB提供的一组实时上报程序，提供数据库活动的实时报告；</li>
<li>数据库命令以更大的保真度返回有关当前数据库状态的统计信息；</li>
<li>MongoDB Atlas，MongoDB Cloud Manager；</li>
</ol>
<p>每个策略在不同的情况下都是很有用的，所以它们能够很好地进行互补。</p>
<p><br></p>
<h4 id="MongoDB-Reporting-Tools"><a href="#MongoDB-Reporting-Tools" class="headerlink" title="MongoDB Reporting Tools"></a>MongoDB Reporting Tools</h4><p><strong>Utilities</strong></p>
<p>MongoDB提供了许多可以返回活动统计信息的实用工具，这对于诊断问题和评估操作非常有用。</p>
<ul>
<li><code>mongostat</code><br><code>mongostat</code>按类型捕获并返回数据库操作的计数(e.g: insert,query,update,delete…)</li>
</ul>
<p><img src="/images/Zabbix/mongostat.png" alt="mongostat"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.mongoing.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MongoDB官方文档&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mongoing.com/docs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MongoDB中文文档&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/MongoDB&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://zh.wikipedia.org/wiki/MongoDB&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ywnds.com/?p=5635&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ywnds.com/?p=5635&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.centos.bz/2017/08/mongodb-secure-intro-user-auth/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.centos.bz/2017/08/mongodb-secure-intro-user-auth/&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.03sec.com/3176.shtml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.03sec.com/3176.shtml&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ywnds.com/?p=6502&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ywnds.com/?p=6502&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/the-little-mongodb-book/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://wiki.jikexueyuan.com/project/the-little-mongodb-book/&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7_x64；&lt;/li&gt;
&lt;li&gt;MongoDB3.4；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="https://zhang21.github.io/categories/Database/"/>
    
    
      <category term="MongoDB" scheme="https://zhang21.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>HTTP请求方法和状态码</title>
    <link href="https://zhang21.github.io/2017/12/01/HTTP-method-status/"/>
    <id>https://zhang21.github.io/2017/12/01/HTTP-method-status/</id>
    <published>2017-12-01T05:53:20.000Z</published>
    <updated>2017-12-04T06:42:32.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见HTTP请求方法"><a href="#常见HTTP请求方法" class="headerlink" title="常见HTTP请求方法"></a>常见HTTP请求方法</h1><p>HTTP协议的请求方法有：<code>GET, POST, HEAD PUT DELETE, OPTIONS, TRACE, CONNECT</code></p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>向Server请求文件</td>
</tr>
<tr>
<td>POST</td>
<td>向Server发送数据并让Server进行处理</td>
</tr>
<tr>
<td>PUT</td>
<td>向Server发送数据并存储在Server端</td>
</tr>
<tr>
<td>HEAD</td>
<td>检查一个对象是否存在</td>
</tr>
<tr>
<td>DELETE</td>
<td>从Server上删除一个文件</td>
</tr>
<tr>
<td>CONNECT</td>
<td>对通道提供支持</td>
</tr>
<tr>
<td>TRACE</td>
<td>跟踪到Server的路径</td>
</tr>
<tr>
<td>OPTION</td>
<td>查询Server的性能</td>
</tr>
</tbody>
</table>
<p><br><br><br></p>
<h1 id="HTTP-Status-Code"><a href="#HTTP-Status-Code" class="headerlink" title="HTTP Status Code"></a>HTTP Status Code</h1><p>当我们从Client向Server发送请求时，Server会向我们返回StatusCode。<br>StatusCode会告诉我们Server的响应的状态，通过它，我们就可以知道当前请求是成功还是出现了问题。</p>
<p>HTTP StatusCode放置在HTTP  Response报文中。</p>
<p>StatusCode由三位数字组成，第一个数字定义了响应类型，有五种可能值：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>响应类别</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td>指示信息</td>
<td>服务器正在处理请求</td>
</tr>
<tr>
<td>2xx</td>
<td>成功</td>
<td>请求以正常处理完毕</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向</td>
<td>需要进行额外操作以完成请求</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误</td>
<td>客户端原因导致服务器无法处理请求</td>
</tr>
<tr>
<td>5xx</td>
<td>服务器错误</td>
<td>服务器原因导致处理请求出错</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="常见HTTP状态码"><a href="#常见HTTP状态码" class="headerlink" title="常见HTTP状态码"></a>常见HTTP状态码</h2><table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>200-OK</td>
<td>服务器成功返回网页，这是成功的HTTP请求返回的标准状态码</td>
</tr>
<tr>
<td>301 - Moved Permanently</td>
<td>永久跳转，所有请求的网页将永久跳转到被设定的新位置</td>
</tr>
<tr>
<td>400 - Bad Request</td>
<td>客户端请求有语法错误，不能被服务器理解</td>
</tr>
<tr>
<td>403 - Forbidden</td>
<td>禁止访问，这个请求时合法的，但是服务器端因为匹配了预先设置的规则而拒绝响应客户端的请求，此类问题一般为服务器权限配置不当所致</td>
</tr>
<tr>
<td>404 - Not Found</td>
<td>服务器找不到客户端请求的指定页面，可能是客户端请求了服务器不存在的资源所导致</td>
</tr>
<tr>
<td>500 - Internal Server Error</td>
<td>内部服务器错误，服务器遇到了意料不到的情况，不能完成客户的请求。这是一个较为笼统的报错，一般为服务器的设置或内部程序问题所致</td>
</tr>
<tr>
<td>502 - Bad Gateway</td>
<td>坏的网关，一般是代理服务器请求后端服务器时，后端服务不可用或没有完成响应网关服务器。一般为代理服务器下面的节点出了问题</td>
</tr>
<tr>
<td>503 - Service Unavailable</td>
<td>服务当前不可用，可能为服务器超载或停机维护所致，或者是代理服务器后面没有可以提供服务的节点</td>
</tr>
<tr>
<td>504 - Gateway Timeout</td>
<td>网关超时，一般是网关代理服务器请求后端服务时，后端服务没有在特定的时间内完成处理请求，一般为服务器过载所致，没有在指定的时间内返回数据给代理服务器</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h2><p>1xx（临时响应），表示临时响应并需要请求者继续执行操作。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>100 - Continue</td>
<td>请求者应当继续提出请求</td>
</tr>
<tr>
<td>101 - Switching Protocols</td>
<td>请求者要求服务器更换协议，服务器已确认并准备更换</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h2><p>2xx（成功），表示成功处理了请求。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>200 - OK</td>
<td>Server已成功处理了请求</td>
</tr>
<tr>
<td>201 - Created</td>
<td>请求成功并且Server创建了新的资源</td>
</tr>
<tr>
<td>202 - Accepted</td>
<td>Server以接受请求，但尚未处理</td>
</tr>
<tr>
<td>203 - Non-Authoritative Information</td>
<td>Server已成功处理了请求，但返回的信息可能来自另一个来源</td>
</tr>
<tr>
<td>204 - No Content</td>
<td>Server成功处理了请求，但没有返回任何内容</td>
</tr>
<tr>
<td>205 - Reset Content</td>
<td>没有新的内容，但浏览器应该重置它所显示的内容</td>
</tr>
<tr>
<td>206 - Partial Content</td>
<td>服务器成功处理了部分GET请求</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h2><p>3xx（重定向），表示要完成请求需要进一步操作。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>300 - Multiple Choices</td>
<td>针对请求，Server可执行多种操作</td>
</tr>
<tr>
<td>301 - Moved Permanently</td>
<td>请求的网页已移动到新位置</td>
</tr>
<tr>
<td>302 - Found</td>
<td>Server目前从不同位置的网页响应请求</td>
</tr>
<tr>
<td>303 - See Other</td>
<td>请求者对不同位置使用单独的GET请求来检索时</td>
</tr>
<tr>
<td>304 - Not Modified</td>
<td>自从上次请求后，请求的网页内容未修改过</td>
</tr>
<tr>
<td>305 - Use Proxy</td>
<td>请求者只能使用代理访问请求的网页</td>
</tr>
<tr>
<td>307 - Temporary Redirect</td>
<td>Server从不同位置的网页响应请求，但请求者继续使用原有位置进行请求</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>4xx（请求错误），表示请求可能出错，妨碍了Server的处理。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>400 - Bad Request</td>
<td>Server不理解请求的语法</td>
</tr>
<tr>
<td>401 - Unauthorized</td>
<td>请求要求身份认证</td>
</tr>
<tr>
<td>403 - Forbidden</td>
<td>Server拒绝请求</td>
</tr>
<tr>
<td>404 - Not Found</td>
<td>Server找不到请求的网页</td>
</tr>
<tr>
<td>405 - Method Not Allowed</td>
<td>请求方法不被允许</td>
</tr>
<tr>
<td>406 - Not Acceptable</td>
<td>无法使用请求的恩日工特性响应请求的网页</td>
</tr>
<tr>
<td>407 - Proxy Authentication Required</td>
<td>请求需要代理授权</td>
</tr>
<tr>
<td>408 - Request Timeout</td>
<td>Server等候请求时超时</td>
</tr>
<tr>
<td>409 - Conflict</td>
<td>Server在完成请求时发生冲突</td>
</tr>
<tr>
<td>410 - Gone</td>
<td>请求的资源以永久删除</td>
</tr>
<tr>
<td>411 - Length Required</td>
<td>Server不接受不含有效内容长度Header的请求</td>
</tr>
<tr>
<td>412 - Precondition Failed</td>
<td>Server为满足请求者在请求中设置的一个前提条件</td>
</tr>
<tr>
<td>413 – Request Entity Too Large</td>
<td>请求实体太大，Server无法处理</td>
</tr>
<tr>
<td>414 - Request URI Too Long</td>
<td>请求的URI过长，Server无法处理</td>
</tr>
<tr>
<td>415 – 不支持的媒体类型</td>
<td>请求的格式不受支持</td>
</tr>
<tr>
<td>416 – Requested Range Not Satisfiable</td>
<td>页面无法提供请求的范围</td>
</tr>
<tr>
<td>417 – 执行失败</td>
<td>Server未满足期望请求Header的要求</td>
</tr>
<tr>
<td>451</td>
<td>基于法律上的的原因，不能像请求者展示网页内容</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p>5xx（服务器错误），表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>500 - Internal Server Error</td>
<td>Server遇到错误，无法完成请求</td>
</tr>
<tr>
<td>501 - Not Implemented</td>
<td>Server不具备完成请求的功能</td>
</tr>
<tr>
<td>502 - Bad Gateway</td>
<td>Server作为网关或代理时，从upstream收到无效响应</td>
</tr>
<tr>
<td>503 - Service Unavailable</td>
<td>Server暂时无法使用</td>
</tr>
<tr>
<td>504 - Gateway Timeout</td>
<td>Server作为网关或代理时，没有及时从upstream收到请求</td>
</tr>
<tr>
<td>505 - HTTP Version Not Supported</td>
<td>Server不支持请求中所用的HTTP版本</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常见HTTP请求方法&quot;&gt;&lt;a href=&quot;#常见HTTP请求方法&quot; class=&quot;headerlink&quot; title=&quot;常见HTTP请求方法&quot;&gt;&lt;/a&gt;常见HTTP请求方法&lt;/h1&gt;&lt;p&gt;HTTP协议的请求方法有：&lt;code&gt;GET, POST, HEAD PUT DELETE, OPTIONS, TRACE, CONNECT&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="https://zhang21.github.io/categories/Network/"/>
    
    
      <category term="HTTP" scheme="https://zhang21.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Filesystem Hierarchy Standard</title>
    <link href="https://zhang21.github.io/2017/11/27/FHS/"/>
    <id>https://zhang21.github.io/2017/11/27/FHS/</id>
    <published>2017-11-27T08:42:33.000Z</published>
    <updated>2017-12-08T06:54:59.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FHS介绍"><a href="#FHS介绍" class="headerlink" title="FHS介绍"></a>FHS介绍</h1><p>FHS(Filesystem Hierarchy Standard)，文件系统层次化标准：<a href="http://www.pathname.com/fhs" target="_blank" rel="external">http://www.pathname.com/fhs</a></p>
<p><br><br>FHS主要目的是希望让用户了解安装文件通常放置的目录。所以希望软件开发商、系统制定者以及维护系统的用户，都能够遵循FHS的标准。</p>
<p><strong>FHS-compliant system：</strong></p>
<table>
<thead>
<tr>
<th>-</th>
<th>可分享的(shareable)</th>
<th>不可分享的(unshareable)</th>
</tr>
</thead>
<tbody>
<tr>
<td>不变的(static)</td>
<td>/usr <br> /opt</td>
<td>/etc <br> /boot</td>
</tr>
<tr>
<td>可变的(variable)</td>
<td>/var/mail <br> /var/spool/news</td>
<td>/var/run <br> /var/lock</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<ul>
<li>shareable： 可分享给其他系统(主机)挂载使用；</li>
<li>unshareable： 不适合分享给其他主机；</li>
<li>static： 有些数据基本是不会变化的；</li>
<li>variable： 进程变更的数据。</li>
</ul>
<p><br><br>FHS针对目录树架构仅定义出三层目录下应该放置什么数据，这三个目录下所应该放置的目录也都有特定规定。</p>
<ul>
<li><code>/</code>： The root filesystem, 与开机系统有关；</li>
<li><code>/usr</code>: The /usr hierarchy, Unix software resource；</li>
<li><code>/var</code>: The /var hierarchy, 与系统运行过程有关。</li>
</ul>
<p><br><br><br></p>
<h1 id="The-Root-Filesystem"><a href="#The-Root-Filesystem" class="headerlink" title="The Root Filesystem"></a>The Root Filesystem</h1><p><strong>根目录(/)</strong>是系统最重要的一个目录。不但所有目录都是由根目录衍生出来，同时根目录还与<strong>系统的启动、还原、修复</strong>等操作相关。<br>若系统出现问题，根目录必须要包含能够修复文件系统的程序才行。<br>破坏根文件系统上的数据的错误比破坏其他任何分区都要严重！</p>
<p>为了平衡这些考虑，建议尽可能保持根分区小。<br>应用程序不应在根目录中创建特殊文件或子目录！</p>
<p><br><br>The following dirs or symbolic-links, are required in /</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/bin</code></td>
<td>必要的二进制命令</td>
</tr>
<tr>
<td><code>/boot</code></td>
<td>boot-loader的静态文件</td>
</tr>
<tr>
<td><code>/dev</code></td>
<td>设备文件</td>
</tr>
<tr>
<td><code>/etc</code></td>
<td>主机特定的系统配置文件</td>
</tr>
<tr>
<td><code>/lib</code></td>
<td>基本的共享库(shared libraries)和内核模块(kernel modules)</td>
</tr>
<tr>
<td><code>/media</code></td>
<td>可移除媒体的挂载点</td>
</tr>
<tr>
<td><code>/mnt</code></td>
<td>临时挂载文件系统的挂载点</td>
</tr>
<tr>
<td><code>/opt</code></td>
<td>第三方软件包放置目录</td>
</tr>
<tr>
<td><code>/sbin</code></td>
<td>必要的系统二进制命令</td>
</tr>
<tr>
<td><code>/srv</code></td>
<td>系统提供的服务数据</td>
</tr>
<tr>
<td><code>/tmp</code></td>
<td>临时文件</td>
</tr>
<tr>
<td><code>/usr</code></td>
<td>/usr层次结构</td>
</tr>
<tr>
<td><code>/var</code></td>
<td>/var层次结构</td>
</tr>
</tbody>
</table>
<p><br><br>除了上面列出必须存在的目录，下面这些目录很也很重要。</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/lost+found</code></td>
<td>在ext文件系统里，当文件系统发生错误时，将一些遗失的片段放置到此目录下</td>
</tr>
<tr>
<td><code>/home</code></td>
<td>用户家目录</td>
</tr>
<tr>
<td><code>/root</code></td>
<td>root用户家目录</td>
</tr>
<tr>
<td><code>/proc</code></td>
<td>虚拟文件系统，放置的数据都在内存当中，不占磁盘空间</td>
</tr>
<tr>
<td><code>/sys</code></td>
<td>虚拟文件系统，记录内核相关信息，不占磁盘空间</td>
</tr>
</tbody>
</table>
<p><br><br>另外需要注意的是，因为根目录与开机有关，开机过程中仅有根目录被挂载。其他分区则是在开机完成后才会持续进行挂载。<br>因此，根目录下与开机过程有关的目录就不能放到不同的分区中去。</p>
<p>如：</p>
<ul>
<li><code>/etc</code></li>
<li><code>/bin</code></li>
<li><code>/sbin</code></li>
<li><code>/dev</code></li>
<li><code>/lib</code></li>
</ul>
<p><br></p>
<h2 id="bin"><a href="#bin" class="headerlink" title="/bin"></a>/bin</h2><p><code>/bin</code>, 基本用户二进制命令文件，供所有用户（系统管理员和用户）使用。</p>
<p><code>/bin</code>下不能有子目录(subdirectory)。</p>
<p><br><br>The following commands or symbolic-links to commands, are required in /bin</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cat</code></td>
<td>将文件连接到stdout的实用程序(Utility)</td>
</tr>
<tr>
<td><code>chgrp</code></td>
<td>更改文件所有权</td>
</tr>
<tr>
<td><code>chmod</code></td>
<td>更改文件访问权限</td>
</tr>
<tr>
<td><code>chown</code></td>
<td>更改文件所有者和和组</td>
</tr>
<tr>
<td><code>cp</code></td>
<td>复制文件和目录</td>
</tr>
<tr>
<td><code>date</code></td>
<td>打印或设置系统数据和时间</td>
</tr>
<tr>
<td><code>dd</code></td>
<td>转换和复制文件</td>
</tr>
<tr>
<td><code>df</code></td>
<td>磁盘使用情况</td>
</tr>
<tr>
<td><code>dmesg</code></td>
<td>打印或控制kernel消息缓冲区</td>
</tr>
<tr>
<td><code>echo</code></td>
<td>显示一行文本</td>
</tr>
<tr>
<td><code>false</code></td>
<td>do nothing, 不成功</td>
</tr>
<tr>
<td><code>true</code></td>
<td>do nothing, 成功</td>
</tr>
<tr>
<td><code>hostname</code></td>
<td>系统主机名</td>
</tr>
<tr>
<td><code>kill</code></td>
<td>发送信号到进程</td>
</tr>
<tr>
<td><code>ln</code></td>
<td>在文件之间创建链接</td>
</tr>
<tr>
<td><code>login</code></td>
<td>在系统上开始会话</td>
</tr>
<tr>
<td><code>ls</code></td>
<td>列出目录内容</td>
</tr>
<tr>
<td><code>mkdir</code></td>
<td>创建目录</td>
</tr>
<tr>
<td><code>mknod</code></td>
<td>创建block或character特殊文件</td>
</tr>
<tr>
<td><code>more</code></td>
<td>文本翻页</td>
</tr>
<tr>
<td><code>mount</code></td>
<td>挂载文件系统</td>
</tr>
<tr>
<td><code>umount</code></td>
<td>解挂文件系统</td>
</tr>
<tr>
<td><code>mv</code></td>
<td>move/rename文件</td>
</tr>
<tr>
<td><code>ps</code></td>
<td>报告进程状态</td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>打印当前工作目录</td>
</tr>
<tr>
<td><code>rm</code></td>
<td>remove文件或目录</td>
</tr>
<tr>
<td><code>sed</code></td>
<td>sed流编辑器</td>
</tr>
<tr>
<td><code>sh</code></td>
<td>Bourne command shell</td>
</tr>
<tr>
<td><code>stty</code></td>
<td>更改或打印终端设置</td>
</tr>
<tr>
<td><code>su</code></td>
<td>change uid</td>
</tr>
<tr>
<td><code>sync</code></td>
<td>刷新文件系统缓冲区</td>
</tr>
<tr>
<td><code>uname</code></td>
<td>打印系统信息</td>
</tr>
</tbody>
</table>
<p><br><br>The following programs or symbolic-links to programs, must be in /bin if the corresponding-system is installed:</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>csh</code></td>
<td>The C shell(可选)</td>
</tr>
<tr>
<td><code>ed</code></td>
<td>编辑器(可选)</td>
</tr>
<tr>
<td><code>tar</code></td>
<td>tar归档(可选)</td>
</tr>
<tr>
<td><code>cpio</code></td>
<td>cpio归档(可选)</td>
</tr>
<tr>
<td><code>gzip</code></td>
<td>GNU压缩工具(可选)</td>
</tr>
<tr>
<td><code>gunzip</code></td>
<td>GNU解压缩工具(可选)</td>
</tr>
<tr>
<td><code>netstat</code></td>
<td>网络统计(可选)</td>
</tr>
<tr>
<td><code>ping</code></td>
<td>ICMP网络测试(可选)</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="boot"><a href="#boot" class="headerlink" title="/boot"></a>/boot</h2><p><code>/boot</code> :static file of the boot-loader</p>
<p>该目录包含引导过程所需所有内容，处理引导是不需要的配置文件和映射安装文件外。<br>因此，/boot储存kernel开始执行用户模式之前使用的数据。</p>
<p><strong><br>操作系统kernel必须位于 / or /boot</strong></p>
<p><br></p>
<h2 id="dev"><a href="#dev" class="headerlink" title="/dev"></a>/dev</h2><p><code>/dev</code> :device files</p>
<p><code>/dev</code> 目录是特殊或设备文件的位置。</p>
<p><br></p>
<h2 id="etc"><a href="#etc" class="headerlink" title="/etc"></a>/etc</h2><p><code>/etc</code> :host-specific system configuration</p>
<p>配置文件是用来控制程序操作的本地静态文件，不能是可执行的二进制文件。</p>
<p><br><br>The following files or symbolic-links to files, must be in /etc if the corresponding-subsystem is installed.</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>csh.login</td>
<td>C shell登录的系统范围初始化文件</td>
<td>Optional</td>
</tr>
<tr>
<td>exports</td>
<td>NFS文件系统访问控制列表</td>
<td>Optional</td>
</tr>
<tr>
<td>fstab</td>
<td>文件系统静态信息</td>
<td>Optional</td>
</tr>
<tr>
<td>ftpusers</td>
<td>FTP守护进程用户访问控制列表</td>
<td>Optional</td>
</tr>
<tr>
<td>gateways</td>
<td>路由网关文件</td>
<td>Optional</td>
</tr>
<tr>
<td>gettydefs</td>
<td>getty终端设置</td>
<td>Optional</td>
</tr>
<tr>
<td>group</td>
<td>用户组文件</td>
<td>Optional</td>
</tr>
<tr>
<td>passwd</td>
<td>密码文件</td>
<td>Optional</td>
</tr>
<tr>
<td>host.conf</td>
<td>解析器配置文件</td>
<td>Optional</td>
</tr>
<tr>
<td>hosts</td>
<td>主机域名的静态信息</td>
<td>Optional</td>
</tr>
<tr>
<td>hosts.allow</td>
<td>Tcp-wrapper的主机访问文件</td>
<td>Optional</td>
</tr>
<tr>
<td>hosts.deny</td>
<td>Tcp-wrapper的主机禁止文件</td>
<td>Optional</td>
</tr>
<tr>
<td>hosts.equiv</td>
<td>rlogin, rsh, rcp的可信主机列表</td>
<td>Optional</td>
</tr>
<tr>
<td>hosts.lpd</td>
<td>lpd的可信主机列表</td>
<td>Optional</td>
</tr>
<tr>
<td>inetd.conf</td>
<td>inetd配置文件</td>
<td>Optional</td>
</tr>
<tr>
<td>inittab</td>
<td>init配置文件</td>
<td>inittab is no longer used when using systemd</td>
</tr>
<tr>
<td>id.so.conf</td>
<td>搜索共享库的额外目录</td>
<td>Optional</td>
</tr>
<tr>
<td>issue</td>
<td>预登录消息和</td>
<td>CentOS Linux 7(core) kernel \r on an \m</td>
</tr>
<tr>
<td>motd</td>
<td>登录后信息</td>
<td>Welcome to $host</td>
</tr>
<tr>
<td>mtab</td>
<td>文件系统动态信息</td>
<td>Optional</td>
</tr>
<tr>
<td>mtools.conf</td>
<td>mtools配置文件</td>
<td>Optional</td>
</tr>
<tr>
<td>networks</td>
<td>网络名称的静态信息</td>
<td>Optional</td>
</tr>
<tr>
<td>printcap</td>
<td>lpd打印机功能数据库</td>
<td>Optional</td>
</tr>
<tr>
<td>profile</td>
<td>sh shell login的系统范围初始化文件</td>
<td>Optional</td>
</tr>
<tr>
<td>protocols</td>
<td>IP协议列表</td>
<td>Optional</td>
</tr>
<tr>
<td>resolv.conf</td>
<td>域名服务器解析文件</td>
<td>Optional</td>
</tr>
<tr>
<td>rpc</td>
<td>RPC协议列表</td>
<td>Optional</td>
</tr>
<tr>
<td>securetty</td>
<td>root登录的TTY访问控制</td>
<td>Optional</td>
</tr>
<tr>
<td>shells</td>
<td>有效登录shell的路径名</td>
<td>Optional</td>
</tr>
<tr>
<td>syslog.conf</td>
<td>syslogd配置文件</td>
<td>Optional</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="etc-opt"><a href="#etc-opt" class="headerlink" title="/etc/opt"></a>/etc/opt</h2><p>/etc/opt :/opt的配置文件</p>
<p>第三方应用程序软件的特定主机配置文件，必须安装在/etc/opt/<subdir> 中。</subdir></p>
<p><br></p>
<h2 id="etc-xml"><a href="#etc-xml" class="headerlink" title="/etc/xml"></a>/etc/xml</h2><p><code>/etc/xml</code> :XML的配置文件</p>
<p>这里安装和定义XML系统的高级参数同通用配置文件。</p>
<p><br></p>
<h2 id="home-Optional"><a href="#home-Optional" class="headerlink" title="/home (Optional)"></a>/home (Optional)</h2><p><code>/home</code> :用户主目录</p>
<p><code>/home</code>是一个相当标准的概念，但它显然是一个特定于站点的文件系统。设置会因主机而异。<br>因此，任何程序都不应该依赖这个目录。</p>
<p><br></p>
<h2 id="lib"><a href="#lib" class="headerlink" title="/lib"></a>/lib</h2><p><code>/lib</code> :基本的共享库和内核模块</p>
<p><code>/lib</code>目录中包含引导系统和运行在根文件系统的命令，即<code>/bin</code>和<code>/sbin</code>中的命令。</p>
<p><br><br>至少需要包含以下文件(链接)：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>libc.so.*</code></td>
<td>动态链接C库</td>
</tr>
<tr>
<td><code>ld*</code></td>
<td>执行时间 链接器/加载器</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="lib-Optional"><a href="#lib-Optional" class="headerlink" title="/lib (Optional)"></a>/lib<qual> (Optional)</qual></h2><p><code>/lib&lt;qual&gt;</code> : 不同格式的基本共享函数库<br>如：64位的<code>/lib64</code>; 32位的<code>/lib32</code>。</p>
<p>用来存放与/lib不同格式的二进制函数库，如支持64位的/lib64函数库等。</p>
<p><br></p>
<h2 id="media"><a href="#media" class="headerlink" title="/media"></a>/media</h2><p><code>/media</code> :可移除媒体的挂载点</p>
<p>此目录包含的子目录，可作为各移动介质(USB,cdrom,floppy…)的挂载点。</p>
<p>尽管在 /mnt 中使用子目录作为挂载点已经很常见了，但与直接使用/mnt作为临时挂载点的传统相去甚远。</p>
<p><br></p>
<h2 id="mnt"><a href="#mnt" class="headerlink" title="/mnt"></a>/mnt</h2><p><code>/mnt</code> :临时挂载文件系统的挂载点</p>
<p><br></p>
<h2 id="opt"><a href="#opt" class="headerlink" title="/opt"></a>/opt</h2><p><code>/opt</code> :为第三方软件包保留的目录</p>
<p>要安装在<code>/opt</code>中的软件包必须将其静态文件放置在单独的<code>/opt/&lt;packge&gt;</code>目录树中。</p>
<p>目录/opt/bin, /opt/doc, /opt/include, /opt/info, /opt/lib, /opt/man 是保留给本地系统管理员使用。<br>如果第三方软件包含Unix手册，而手册必须放置于/opt/<package>/share/man/，必须使用与/usr/share/man相同的子结构。</package></p>
<p><br></p>
<h2 id="root-Optional"><a href="#root-Optional" class="headerlink" title="/root (Optional)"></a>/root (Optional)</h2><p><code>/root</code> :root用户的主目录</p>
<p><br></p>
<h2 id="sbin"><a href="#sbin" class="headerlink" title="/sbin"></a>/sbin</h2><p><code>/sbin</code> :系统二进制文件</p>
<p>系统管理的实用程序(命令)，存储在<code>/sbin, /usr/sbin, /usr/local/sbin</code>中。<br><code>/sbin</code>包含<strong>启动，恢复，修复</strong>系统，以及<code>/bin</code>中二进制文件所必须的二进制文件。<br>本地安装的系统管理程序应放置在<code>/usr/local/sbin</code>中。</p>
<p><br><br>The following commands or symbolic-links to commands are required in /sbin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shutdown		#关闭系统</div></pre></td></tr></table></figure></p>
<p><br><br>The following files or symbolic-links to files，must be in /sbin if the corresponding subsystem is installed</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fastboot</code></td>
<td>重启系统而不检查磁盘</td>
<td>Optional</td>
</tr>
<tr>
<td><code>fasthalt</code></td>
<td>停止系统而不检查磁盘</td>
<td>Optional</td>
</tr>
<tr>
<td><code>fdisk</code></td>
<td>分区表操作器</td>
<td>Optional</td>
</tr>
<tr>
<td><code>fsck</code></td>
<td>文件系统检查和修理工具</td>
<td>Optional</td>
</tr>
<tr>
<td><code>fsck.*</code></td>
<td>针对特定文件系统检查和修复</td>
<td>Optional<br>eg：fsck.ext3</td>
</tr>
<tr>
<td><code>getty</code></td>
<td>getty程序</td>
<td>Optional</td>
</tr>
<tr>
<td><code>half</code></td>
<td>停止系统</td>
<td>Optional</td>
</tr>
<tr>
<td><code>ifconfig</code></td>
<td>配置网络接口</td>
<td>Optional</td>
</tr>
<tr>
<td><code>init</code></td>
<td>初始化进程</td>
<td>Optional</td>
</tr>
<tr>
<td><code>mkfs</code></td>
<td>创建文件系统</td>
<td>Optional</td>
</tr>
<tr>
<td><code>mkfs.*</code></td>
<td>创建特定文件系统</td>
<td>OPtional<br>eg: mkfs.ext4</td>
</tr>
<tr>
<td><code>mkswap</code></td>
<td>设置swap分区</td>
<td>OPtional</td>
</tr>
<tr>
<td><code>reboot</code></td>
<td>重启系统</td>
<td>OPtional</td>
</tr>
<tr>
<td><code>route</code></td>
<td>IP路由表实用程序</td>
<td>OPtional</td>
</tr>
<tr>
<td><code>swapon</code></td>
<td>启用分页和交换</td>
<td>OPtional</td>
</tr>
<tr>
<td><code>swapoff</code></td>
<td>Disable paging and swapping</td>
<td>Optional</td>
</tr>
<tr>
<td><code>update</code></td>
<td>守护进程定期刷新文件系统缓冲区</td>
<td>Optional</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="srv"><a href="#srv" class="headerlink" title="/srv"></a>/srv</h2><p><code>/srv</code> :系统提供的服务(service)的数据</p>
<p><br></p>
<h2 id="tmp"><a href="#tmp" class="headerlink" title="/tmp"></a>/tmp</h2><p><code>/tmp</code> :临时文件</p>
<p><code>/tmp</code>目录为临时需要文件的程序提供。<br>程序不能在程序的调用之间保留/tmp中的任何文件或目录。<br>尽管/tmp中数据可能会以某种特定方式删除，但建议在系统启动时删除/tmp中所有文件。</p>
<p><br><br><br></p>
<h1 id="The-usr-Hierarchy"><a href="#The-usr-Hierarchy" class="headerlink" title="The /usr Hierarchy"></a>The /usr Hierarchy</h1><p><code>/usr</code> 里面放置的数据是可分享与不可变动的。<br>这就意味着可在各种符合FHS的主机之间共享，但不能写入。<br>大型软件包不应在/usr层次结构下使用直接子目录。</p>
<p><br><br>The following dirs of symbolic-links to dirs are required in /usr</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/usr/bin</code></td>
<td>大多数用户命令</td>
</tr>
<tr>
<td><code>/usr/include</code></td>
<td>C程序包含的头文件</td>
</tr>
<tr>
<td><code>/usr/lib</code></td>
<td>库文件</td>
</tr>
<tr>
<td><code>/usr/local</code></td>
<td>本地层次结构</td>
</tr>
<tr>
<td><code>/usr/sbin</code></td>
<td>非重要的系统二进制文件</td>
</tr>
<tr>
<td><code>/usr/share</code></td>
<td>独立于架构的数据</td>
</tr>
</tbody>
</table>
<p>其他选项：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/usr/lib&lt;qual&gt;</code></td>
<td>可选格式库</td>
<td>Optional</td>
</tr>
<tr>
<td><code>/usr/src</code></td>
<td>源代码</td>
<td>OPtional</td>
</tr>
<tr>
<td><code>/usr/games</code></td>
<td>游戏和教育二进制文件</td>
<td>OPtional</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="usr-bin"><a href="#usr-bin" class="headerlink" title="/usr/bin"></a>/usr/bin</h2><p><code>/usr/bin</code> :大多数用户命令<br>这是系统上可执行命令的主要目录。</p>
<p><br><br>The following files or symbolic-links to files must be in /usr/bin, if the corresponding subsystem is installed</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>perl</code></td>
<td>实用提取和报告语言</td>
<td>OPtional</td>
</tr>
<tr>
<td><code>python</code></td>
<td>python解释语言</td>
<td>Optional</td>
</tr>
<tr>
<td><code>tclsh</code></td>
<td>tcl解释器的简单shell</td>
<td>OPtional</td>
</tr>
<tr>
<td><code>wish</code></td>
<td>简单 tcl/tk windowing shell</td>
<td>Optional</td>
</tr>
<tr>
<td><code>expect</code></td>
<td>程序交互式对话</td>
<td>Optional</td>
</tr>
</tbody>
</table>
<p>因为shell script解释器(在shell script脚本的第一行 #!<path></path>)不能依赖路径，所以标准化它们的位置是有利的。<br>Bourne shell 和 C-shell解释器已经被固定在/bin中，但 perl,python,tcl经常在许多不同的地方。</p>
<p><br></p>
<h2 id="usr-include"><a href="#usr-include" class="headerlink" title="/usr/include"></a>/usr/include</h2><p><code>/usr/include</code> :标准C包含文件的目录</p>
<p>这是C语言所有系统的通用包含文件应该被放置的地方。</p>
<p><br></p>
<h2 id="usr-lib"><a href="#usr-lib" class="headerlink" title="/usr/lib"></a>/usr/lib</h2><p><code>/usr/lib</code> :编程和包的所需要的库</p>
<p><code>/usr/lib</code>包括 不打算由用户或shell script直接执行的目标文件、库和内部二进制文件。</p>
<p><br></p>
<h2 id="usr-lib-Optional"><a href="#usr-lib-Optional" class="headerlink" title="/usr/lib (Optional)"></a>/usr/lib<qual> (Optional)</qual></h2><p><code>/usr/lib&lt;qual&gt;</code> :可选格式库</p>
<p><br></p>
<h2 id="usr-local"><a href="#usr-local" class="headerlink" title="/usr/local"></a>/usr/local</h2><p><code>/usr/local</code> :本地层次结构</p>
<p><code>/usr/local</code>是给系统管理员安装本地软件使用。当系统软件更新时，需保证安全。<br>它可以用于在一组主机之间共享，但在 <code>usr</code>中找不到的程序和数据。</p>
<p>本地安装软件必须放在 <code>/usr/local</code> 而不是 <code>/usr</code>，除非安装它来升级或替换<code>usr</code>的软件</p>
<p><br><br>The following dirs or symbolic-links to dis must be in <code>/usr/local</code></p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/usr/local/bin</code></td>
<td>本地二进制文件</td>
</tr>
<tr>
<td><code>/usr/local/etc</code></td>
<td>本地二进制文件的特定配置文件</td>
</tr>
<tr>
<td><code>/usr/local/games</code></td>
<td>本地游戏二进制文件</td>
</tr>
<tr>
<td><code>/usr/local/include</code></td>
<td>本地C头文件</td>
</tr>
<tr>
<td><code>/usr/local/lib</code></td>
<td>本地库</td>
</tr>
<tr>
<td><code>/usr/local/man</code></td>
<td>本地在线手册</td>
</tr>
<tr>
<td><code>/usr/local/sbin</code></td>
<td>本地系统二进制文件</td>
</tr>
<tr>
<td><code>/usr/local/share</code></td>
<td>本地独立架构层次结构</td>
</tr>
<tr>
<td><code>/usr/local/src</code></td>
<td>本地源码</td>
</tr>
</tbody>
</table>
<p><code>/usr/local/share</code>目录内容的要求应与<code>/usr/share</code>相同，唯一附加约束是<code>/usr/local/share/man</code>和<code>/usr/local/man</code>目录必须是同步的。（基本上就是符号链接了！）</p>
<p><br></p>
<h2 id="usr-sbin"><a href="#usr-sbin" class="headerlink" title="/usr/sbin"></a>/usr/sbin</h2><p><code>/usr/sbin</code> :非必要的标准系统二进制文件</p>
<p>该目录包含系统管理员专门使用的任何非必要的二进制文件。<br>系统修复、恢复、挂载/usr等其他重要必要功能必须放在/sbin中。</p>
<p><br></p>
<h2 id="usr-share"><a href="#usr-share" class="headerlink" title="/usr/share"></a>/usr/share</h2><p><code>/usr/share</code> :独立于架构的数据</p>
<p><code>/usr/share</code>层次 是为了所有只读架构独立数据。<br>该层次可以在给定OS的所有体系架构平台之间共享。如具有i386和PPC平台站点可能会维护一个集中安装的/usr/share目录。<br>但<code>/usr/share</code>一般不打算由不同的操作系统共享，或由同一操作系统的不同版本共享。</p>
<p><br><br>The following dis or symbolic-links to dirs must be in /usr/share</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>man</td>
<td>在线手册</td>
</tr>
<tr>
<td>misc</td>
<td>其他独立于架构的数据</td>
</tr>
</tbody>
</table>
<p><br><br>The following dis or symbolic-links to dirs must be in /usr/share, if the corresponding subsystem is installed</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>dict</td>
<td>单词列表</td>
<td>Optional</td>
</tr>
<tr>
<td>doc</td>
<td>各种文档</td>
<td>Optional</td>
</tr>
<tr>
<td>games</td>
<td>/usr/games的静态文件</td>
<td>Optional</td>
</tr>
<tr>
<td>info</td>
<td>GNU Info system’s primary dir</td>
<td>Optional</td>
</tr>
<tr>
<td>locale</td>
<td>支持的区域信息</td>
<td>Optional</td>
</tr>
<tr>
<td>zoneinfo</td>
<td>Timezone info and conf</td>
<td>Optional</td>
</tr>
<tr>
<td>NLS</td>
<td>Native language support</td>
<td>Optional</td>
</tr>
<tr>
<td>sgml</td>
<td>SGML数据</td>
<td>Optional</td>
</tr>
<tr>
<td>terminfo</td>
<td>terminfo数据库目录</td>
<td>Optional</td>
</tr>
<tr>
<td>xml</td>
<td>xml数据</td>
<td>Optional</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="usr-share-dict"><a href="#usr-share-dict" class="headerlink" title="/usr/share/dict"></a>/usr/share/dict</h3><p><code>/usr/share/dict</code> :单词列表<br>这个目录是系统上单词列表的家目录，只包含英文单词，它们由<code>look</code>和各种拼写程序使用。<br>它们是所有拼写检查器唯一通用的文件。</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>words</td>
<td>单词列表</td>
<td>Optional</td>
</tr>
<tr>
<td>linu.words</td>
<td>linux可用单词列表</td>
<td>Optional</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="usr-share-man"><a href="#usr-share-man" class="headerlink" title="/usr/share/man"></a>/usr/share/man</h3><p><code>/usr/share/man</code> :手册页<br>它包含了<code>/</code>, <code>/usr</code>文件系统下的命令和数据的手册信息</p>
<p>手册页存储在 <code>/usr/share/man/&lt;locale&gt;/man&lt;section&gt;/&lt;arch&gt;</code>中。</p>
<p>每个部分的描述：</p>
<ul>
<li>man1: 可公开访问的命令的手册页，用户需要使用的大多数程序文档放置于此；</li>
<li>man2: 系统调用部分，描述所有的系统调用(请求内核执行操作)；</li>
<li>man3: 函数库和子例程部分，描述不直接调用内核服务的程序库例程；</li>
<li>man4: 特定文件部分，描述系统中特定文件，相关驱动程序和网络支持。通常，这包含/dev中找到的设备以及网络协议支持的内核接口；</li>
<li>man5: 文件格式部分，许多数据文件的格式记录在此；</li>
<li>man6: 游戏，演示和一般小程序；</li>
<li>man7: 各种难以分类的手册页；</li>
<li>man8: 系统管理员用于操作和维护系统的程序记录在这。</li>
</ul>
<p><br><br>The following dirs or symboli-link to dirs must be in <code>/usr/share/man/&lt;locale&gt;</code>, unless they are empty</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>man1</td>
<td>用户程序</td>
<td>Optional</td>
</tr>
<tr>
<td>man2</td>
<td>系统调用</td>
<td>Optional</td>
</tr>
<tr>
<td>man3</td>
<td>函数库调用</td>
<td>Optional</td>
</tr>
<tr>
<td>man4</td>
<td>特定文件</td>
<td>Optional</td>
</tr>
<tr>
<td>man5</td>
<td>文件格式</td>
<td>Optional</td>
</tr>
<tr>
<td>man6</td>
<td>游戏</td>
<td>Optional</td>
</tr>
<tr>
<td>man7</td>
<td>混杂的手册页</td>
<td>Optional</td>
</tr>
<tr>
<td>man8</td>
<td>系统管理</td>
<td>Optional</td>
</tr>
</tbody>
</table>
<p><br><br>必须在<code>/usr/share/man</code>结构中作出规定，以支持用不同语言编写的手册页。这些规定必须考虑到手册页的存储和参考，相关因素包括语言和字符编码集。</p>
<p>栗子：</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Country</th>
<th>CharacterSet</th>
<th>Dir</th>
</tr>
</thead>
<tbody>
<tr>
<td>English</td>
<td>-</td>
<td>ASCII</td>
<td>/usr/share/man/en</td>
</tr>
<tr>
<td>English</td>
<td>United Kingdom</td>
<td>ISO 8859-15</td>
<td>/usr/share/man/en_GB</td>
</tr>
<tr>
<td>English</td>
<td>United States</td>
<td>ASCII</td>
<td>/usr/share/man/en_US</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="usr-share-misc"><a href="#usr-share-misc" class="headerlink" title="/usr/share/misc"></a>/usr/share/misc</h3><p><code>/usr/share/misc</code> :与架构无关的数据</p>
<p><br></p>
<h3 id="usr-share-sgml"><a href="#usr-share-sgml" class="headerlink" title="/usr/share/sgml"></a>/usr/share/sgml</h3><p><code>/usr/share/sgml</code> :SGML数据</p>
<p><br></p>
<h3 id="usr-share-xml"><a href="#usr-share-xml" class="headerlink" title="/usr/share/xml"></a>/usr/share/xml</h3><p><code>/usr/share/xml</code> :XML数据</p>
<p><br></p>
<h2 id="usr-src"><a href="#usr-src" class="headerlink" title="/usr/src"></a>/usr/src</h2><p><code>/usr/src</code> :源代码<br>Source Code可能放置在此目录的子目录中，仅供参考。</p>
<p><br><br><br></p>
<h1 id="var-Hierarchy"><a href="#var-Hierarchy" class="headerlink" title="/var Hierarchy"></a>/var Hierarchy</h1><p><code>/var</code> 包含可变数据文件，包括假脱机目录和文件，系统管理和登录数据，以及临时文件。</p>
<p>如果<code>/var</code>不能成为一个单独的分区，最好将<code>/var</code>移出<code>/</code>分区并移入<code>/usr</code>分区。（为了减小根分区大小或当根分区空间不足时）<br>也可将<code>/var</code>链接到<code>/usr/var</code>。</p>
<p><br><br>The following dirs or symbolic-link to dirs are required in <code>/var</code>.</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/var/cache</code></td>
<td>应用程序缓存数据</td>
</tr>
<tr>
<td><code>/var/lib</code></td>
<td>可变状态信息</td>
</tr>
<tr>
<td><code>/var/local</code></td>
<td>/usr/local的可变数据</td>
</tr>
<tr>
<td><code>/var/lock</code></td>
<td>锁文件</td>
</tr>
<tr>
<td><code>/var/log</code></td>
<td>日志文件</td>
</tr>
<tr>
<td><code>/var/opt</code></td>
<td>/opt的可变数据</td>
</tr>
<tr>
<td><code>/var/run</code></td>
<td>与运行进程相关的数据</td>
</tr>
<tr>
<td><code>/var/spool</code></td>
<td>应用程序队列数据</td>
</tr>
<tr>
<td><code>/var/tmp</code></td>
<td>为系统重启保留的临时文件</td>
</tr>
</tbody>
</table>
<p><br><br>The following dirs or symbolic-link to dir must be in /var,if the corresponding subsystem is installed.</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/var/account</code></td>
<td>进程账户日志</td>
<td>可选</td>
</tr>
<tr>
<td><code>/var/crash</code></td>
<td>系统奔溃转储</td>
<td>可选</td>
</tr>
<tr>
<td><code>/var/games</code></td>
<td>可变游戏数据</td>
<td>可选</td>
</tr>
<tr>
<td><code>/var/mail</code></td>
<td>用户邮箱文件</td>
<td>可选</td>
</tr>
<tr>
<td><code>/var/yp</code></td>
<td>网络信息服务数据库文件</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="var-account"><a href="#var-account" class="headerlink" title="/var/account"></a>/var/account</h2><p><code>/var/account</code> :该目录保存当前活动的进程记账日志和复合进程数据。</p>
<p><br></p>
<h2 id="var-cache"><a href="#var-cache" class="headerlink" title="/var/cache"></a>/var/cache</h2><p><code>/var/cache</code> :保存应用程序缓存的数据。应用程序必须能够重新生成或回复数据。<br>与<code>/var/spool</code>不同，删除了缓存文件不会丢失数据。数据必须在应用程序调用和系统重启间保持有效。<br>缓存目录的数据格式没有其他要求。</p>
<p>对于缓存数据单独存在的目录，系统管理员可从<code>/var</code>下其他目录设备不同的磁盘和备份策略。</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/var/cache/fonts</code></td>
<td>本地生成的字体</td>
<td>可选</td>
</tr>
<tr>
<td><code>/var/cache/man</code></td>
<td>本地格式化的手册页</td>
<td>可选</td>
</tr>
<tr>
<td><code>/var/cache/www</code></td>
<td>www代理或缓存数据</td>
<td>可选</td>
</tr>
<tr>
<td><code>/var/cache/&lt;package&gt;</code></td>
<td>特定包缓存数据</td>
<td>可选</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="var-lib"><a href="#var-lib" class="headerlink" title="/var/lib"></a>/var/lib</h2><p><code>/var/lib</code> :可变状态信息。目录保存于应用程序或系统有关的状态信息。<br>状态信息(state infofmation)，是程序在运行时修改的数据，属于一个特定的主机。</p>
<p>应用程序必须为其数据使用<code>/var/lib/&lt;subdir&gt;</code>，有一个必须的子目录<code>/var/lib/misc</code>用于不需要子目录的状态文件。</p>
<p><br></p>
<h2 id="var-lock"><a href="#var-lock" class="headerlink" title="/var/lock"></a>/var/lock</h2><p><code>/var/lock</code> :锁文件，锁文件应该存储在此目录中。<br>锁文件锁定多个应用程序共享的设备和其他资源。</p>
<p>这种锁文件内容的格式必须是HDB UUCP锁文件格式。<br>HDB格式是将进程标识符(PID)存储为ASCII十进制数，并带有换行符。</p>
<p><br></p>
<h2 id="var-log"><a href="#var-log" class="headerlink" title="/var/log"></a>/var/log</h2><p><code>/var/log</code> :日志文件和目录，大多数日志必须写入此目录或适当子目录。</p>
<p><br><br>The following file or symbolic-link to file must be in /var/log.</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>lastlog</td>
<td>每个用户上次登录信息的记录</td>
</tr>
<tr>
<td>message</td>
<td>syslogd的系统信息</td>
</tr>
<tr>
<td>wtmp</td>
<td>所有登录和注销的记录</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="var-mail"><a href="#var-mail" class="headerlink" title="/var/mail"></a>/var/mail</h2><p>邮件缓存区必须通过<code>/var/mail</code>访问，邮件缓冲区文件必须采用<username>的形式。</username></p>
<p><br></p>
<h2 id="var-run"><a href="#var-run" class="headerlink" title="/var/run"></a>/var/run</h2><p><code>/var/run</code> :运行时变化数据，此目录包含系统信息数据，描述系统启动以来的情况。<br>此目录下的文件必须在引导过程开始时被清除。<br>进程标识符(PID)文件放置于此目录或下的子目录里面。</p>
<p><br></p>
<h2 id="var-spool"><a href="#var-spool" class="headerlink" title="/var/spool"></a>/var/spool</h2><p><code>/var/spool</code> :应用程序队列数据。<br>此目录包含正在等待某种稍后处理的数据，/var/spool中的数据表示工作将在将来执行(通过程序，用户或管理员)，数据通常会在工作处理后被删除。</p>
<p><br><br>The following dirs or symbolic-link to dirs must be in /var/spool,if the corresponding subsystem is installed.</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>lpd</td>
<td>打印机队列目录</td>
<td>可选</td>
</tr>
<tr>
<td>mqueue</td>
<td>发送邮件队列</td>
<td>可选</td>
</tr>
<tr>
<td>news</td>
<td>新闻假脱机目录</td>
<td>可选</td>
</tr>
<tr>
<td>rwho</td>
<td>rwhod文件</td>
<td>可选</td>
</tr>
<tr>
<td>uucp</td>
<td>uucp的假脱机目录</td>
<td>可选</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="var-tmp"><a href="#var-tmp" class="headerlink" title="/var/tmp"></a>/var/tmp</h2><p><code>/var/tmp</code> :在系统重启之间保存的临时文件。存储在<code>/var/tmp</code>的数据比<code>/tmp</code>中的数据更持久。</p>
<p><br><br><br></p>
<h1 id="OS-Specific-Annex"><a href="#OS-Specific-Annex" class="headerlink" title="OS Specific Annex"></a>OS Specific Annex</h1><p>本节是针对仅适用于特定OS的其他建议和要求。</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>Linux操作系统的附件</p>
<h3 id="根目录"><a href="#根目录" class="headerlink" title="/ :根目录"></a>/ :根目录</h3><p>在Linux系统上，如果内核位于<code>/</code>，建议使用Linux内核源代码包中使用的名称<strong>vmlinux或vmlinuz</strong>。</p>
<p>我的<code>CentOS7</code>中，内核文件默认是<code>/boot/vmlinuz-$kernel-version.$arch</code></p>
<p><br></p>
<h3 id="bin-基本用户命令二进制文件-供多有用户使用"><a href="#bin-基本用户命令二进制文件-供多有用户使用" class="headerlink" title="/bin :基本用户命令二进制文件(供多有用户使用)"></a>/bin :基本用户命令二进制文件(供多有用户使用)</h3><p><br></p>
<h3 id="dev-设备和特殊文件"><a href="#dev-设备和特殊文件" class="headerlink" title="/dev :设备和特殊文件"></a>/dev :设备和特殊文件</h3><ol>
<li><code>/dev/null</code> :<br> 写入该设备的所有数据都被丢弃。从这个设备读取将返回一个EOF条件。</li>
<li><code>/dev/zero</code> :<br> 该设备是归零数据的来源，写入该设备的所有数据被丢弃。从这个设备读取将返回包含zero的请求的字节数。</li>
<li><code>/dev/tty</code> :<br> 该设备类似于进程控制终端。一旦这个设备被打开，所有读写操作就好像实际的控制终端以及被打开一样。</li>
</ol>
<p><br></p>
<h3 id="etc-主机的特定系统配置"><a href="#etc-主机的特定系统配置" class="headerlink" title="/etc :主机的特定系统配置"></a>/etc :主机的特定系统配置</h3><p>Linux系统要将附件文件放置到<code>/etc</code>中。</p>
<p><br></p>
<h3 id="lib64-和-lib32-64-32位库-依赖于体系结构"><a href="#lib64-和-lib32-64-32位库-依赖于体系结构" class="headerlink" title="/lib64 和 /lib32 :64/32位库(依赖于体系结构)"></a>/lib64 和 /lib32 :64/32位库(依赖于体系结构)</h3><p>64位体系结构PPC64,AMD64,x86_64必须将64位库放置于<code>/lib64</code>中，将32位库放置于<code>/lib</code>中；<br>64位体系结构IA64必须将64位库放置于<code>/lib</code>中。</p>
<p><br></p>
<h3 id="proc-内核和进程信息虚拟文件系统"><a href="#proc-内核和进程信息虚拟文件系统" class="headerlink" title="/proc :内核和进程信息虚拟文件系统"></a>/proc :内核和进程信息虚拟文件系统</h3><p>PROC文件系统是用于处理进程和系统信息的标准Linux方法，而不是/dev/kmem和其它类似方法。<br>强烈建议使用PROC文件系统获取 存储，进程，内存，内核等信息。</p>
<p><br></p>
<h3 id="sbin-基本系统二进制文件"><a href="#sbin-基本系统二进制文件" class="headerlink" title="/sbin :基本系统二进制文件"></a>/sbin :基本系统二进制文件</h3><p>Linux系统将这些附加文件放置于<code>/sbin</code>中：</p>
<p><strong>第二扩展文件系统命令（可选）：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">badblocks</div><div class="line">dumpe2fs</div><div class="line">e2fsck</div><div class="line">mke2fs</div><div class="line">mklost+found</div><div class="line">tune2fs</div></pre></td></tr></table></figure>
<p><strong>boot-loader 映射安装程序（可选）：</strong><br><code>lilo</code></p>
<p><strong>静态二进制文件：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ldconfig</div><div class="line">sln(static ln)</div><div class="line">ssync(static sync)</div></pre></td></tr></table></figure>
<blockquote>
<p>出现问题时，sln（静态ln）和ssync（静态同步）非常有用；<br>idconfig程序可以作为升级知道的手段；<br>sln的主要用途，修复不良协调升级后/lib中不正确的符号链接动态库。</p>
</blockquote>
<p>对于/sbin, idconfig二进制文件是可选的。因为站点可能会在启动时选择运行idconfig而不是仅在升级共享库时。<br>以下是一些常见问题：</p>
<ul>
<li>我刚刚删除了/lib/<file>；</file></li>
<li>我无法找到库的名称，因为<code>ls</code>是动态链接。我使用的shell没有内置<code>ls</code>，我也不知道使用<code>echo *</code>作为替换；</li>
<li>我有一个静态ln，但我不知道怎么称呼这个链接。</li>
</ul>
<p><strong>杂项：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#ctrl+alt+del</div><div class="line">ctrlaltdel</div><div class="line"></div><div class="line">#keyboard rate</div><div class="line">kbdrate</div></pre></td></tr></table></figure>
<p>为了应对某些键盘出现如此高的重复速率一致无法使用,<code>kbdrate</code>可以安装在某些系统上的<code>/sbin</code>中；</p>
<p>由于<code>ctrl+alt+del</code>组合键在内核中的默认操作是<strong>硬重启</strong>，因此通常建议在将根文件系统挂在到读写模式之前禁用该行为。这就可能需要<code>ctrlaltdel</code>程序，它可以安装在系统的<code>/sbin</code>中。</p>
<p><br></p>
<h2 id="usr-include-C程序包含的头文件"><a href="#usr-include-C程序包含的头文件" class="headerlink" title="/usr/include :C程序包含的头文件"></a>/usr/include :C程序包含的头文件</h2><p>如果安装了C或C++编译器，则只有非 基于glibc的系统才需要这些链接符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/include/asm  -&gt; /usr/src/linux/include/asm-&lt;arch&gt;</div><div class="line">/usr/include/linux  -&gt; /usr/src/linux/include/linux</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="usr-src-源代码"><a href="#usr-src-源代码" class="headerlink" title="/usr/src :源代码"></a>/usr/src :源代码</h2><p>对于基于glibc的系统，此目录没有具体指导。</p>
<p>对于glibc之前基于linux libc修订版的系统： <code>/usr/src/linux</code>是唯一放置Linux内核源代码的位置。</p>
<p><br></p>
<h2 id="usr-spool-cron-cron和jobs"><a href="#usr-spool-cron-cron和jobs" class="headerlink" title="/usr/spool/cron :cron和jobs"></a>/usr/spool/cron :cron和jobs</h2><p>此目录包含了cron和程序的可变数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;FHS介绍&quot;&gt;&lt;a href=&quot;#FHS介绍&quot; class=&quot;headerlink&quot; title=&quot;FHS介绍&quot;&gt;&lt;/a&gt;FHS介绍&lt;/h1&gt;&lt;p&gt;FHS(Filesystem Hierarchy Standard)，文件系统层次化标准：&lt;a href=&quot;http://www.pathname.com/fhs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.pathname.com/fhs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;FHS主要目的是希望让用户了解安装文件通常放置的目录。所以希望软件开发商、系统制定者以及维护系统的用户，都能够遵循FHS的标准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FHS-compliant system：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;可分享的(shareable)&lt;/th&gt;
&lt;th&gt;不可分享的(unshareable)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;不变的(static)&lt;/td&gt;
&lt;td&gt;/usr &lt;br&gt; /opt&lt;/td&gt;
&lt;td&gt;/etc &lt;br&gt; /boot&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可变的(variable)&lt;/td&gt;
&lt;td&gt;/var/mail &lt;br&gt; /var/spool/news&lt;/td&gt;
&lt;td&gt;/var/run &lt;br&gt; /var/lock&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="FHS" scheme="https://zhang21.github.io/tags/FHS/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix</title>
    <link href="https://zhang21.github.io/2017/11/14/Zabbix/"/>
    <id>https://zhang21.github.io/2017/11/14/Zabbix/</id>
    <published>2017-11-14T02:18:09.000Z</published>
    <updated>2018-01-20T10:41:48.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zabbix简介"><a href="#Zabbix简介" class="headerlink" title="Zabbix简介"></a>Zabbix简介</h1><p>参考：</p>
<p><a href="https://www.zabbix.com/" target="_blank" rel="external">Zabbix官方网站</a><br><a href="https://www.zabbix.com/documentation/3.4/zh/manual/" target="_blank" rel="external">Zabbix中文文档</a><br>Zabbix-repo仓库: <a href="http://repo.zabbix.com" target="_blank" rel="external">http://repo.zabbix.com</a> , 阿里云镜像: <a href="https://mirrors.aliyun.com/zabbix/zabbix/" target="_blank" rel="external">https://mirrors.aliyun.com/zabbix/zabbix/</a> .</p>
<p>环境：</p>
<p>CentOS7x86_64, Zabbix 3.4。</p>
<a id="more"></a>
<p>Zabbix （音同 zæbix），是由 Alexei Vladishev 开发的一种网络监视、管理系统，基于 Server-Client 架构。Zabbix 的授权是属于 GPLv2。<br>Zabbix可用于监视各种网络服务、服务器和网络机器等状态。是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。<br>Zabbix也可经由SNMP、TCP、ICMP、SSH等对目标进行监视。</p>
<p><br></p>
<h2 id="Zabbix的系统构成"><a href="#Zabbix的系统构成" class="headerlink" title="Zabbix的系统构成"></a>Zabbix的系统构成</h2><p>Zabbix系统由以下各独立模块组成：</p>
<ul>
<li>Zabbix Server，服务端(以C开发)。Server端通过收集SNMP和Agent发送的数据，写入数据库，再通过PHP+Apache在Web端展示；</li>
<li>Zabbix Agent，客户端(基本支持所有操作系统)，并将监控主机数据发送给Server；</li>
<li>Zabbix Frontend，Web管理端(以PHP和JavaScript构成)；</li>
<li>Zabbix Proxy(可选组件)。用于分布式监控。</li>
</ul>
<p><br></p>
<h2 id="Zabbix的特点"><a href="#Zabbix的特点" class="headerlink" title="Zabbix的特点"></a>Zabbix的特点</h2><p>Zabbix是一个高度集成的网络监控解决方案，一个简单的安装包中提供多样性功能。</p>
<ul>
<li>数据收集；</li>
<li>灵活的阀值(触发器)定义；</li>
<li>高度可配置化的告警；</li>
<li>实现图表绘制；</li>
<li>Web监控功能；</li>
<li>丰富的可视化选项；</li>
<li>历史数据存储；</li>
<li>配置简单；</li>
<li>使用模板；</li>
<li>网络发现；</li>
<li>Zabbix API；</li>
<li>权限管理系统；</li>
<li>功能强大并易于扩展的监控代理。</li>
</ul>
<p><br><br><br></p>
<hr>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Zabbix的常用术语含义。</p>
<p><strong>主机(host)：</strong></p>
<p>一台你想监控的网络设备，用IP或域名表示。主机名不能使用中文创建，会报错。</p>
<p><strong>主机组(host group):</strong><br>主机的逻辑组，它包含主机和模板。组名可以使用中文。</p>
<p><strong>监控项(item):</strong><br>你想要接收的主机的特定数据，一个度量数据。</p>
<p><strong>触发器(trigger):</strong><br>一个被用于定义问题阀值和评估监控项接收到的数据的逻辑表达式。</p>
<p><strong>事件(event):</strong><br>单次发生的需要注意的事情。</p>
<p><strong>异常(problem):</strong><br>一个处在异常状态的触发器。</p>
<p><strong>动作(action):</strong><br>一个对事件作出反应的预定义的操作。</p>
<p><strong>升级(escalation):</strong><br>一个在动作内执行操作的自定义场景。</p>
<p><strong>媒介(media):</strong><br>发送报警通知的手段。</p>
<p><strong>通知(notification):</strong><br>利用已选择的媒体途径把事情相关信息发送给用户。</p>
<p><strong>远程命令(remote command):</strong><br>预先定义好的，满足一定条件后，可在被监控主机上自动执行的命令。</p>
<p><strong>模板(template):</strong><br>一组可以被应用到一个或多个主机上的实体的集合。</p>
<p><strong>应用(application):</strong><br>一组监控项组成的逻辑分组。</p>
<p><strong>Web场景(Web scenario):</strong><br>利用一个或多个HTTP请求来检查网站的可用性。</p>
<p><strong>前端(frontend):</strong><br>Zabbix提供的Web界面。</p>
<p><strong>Zabbix API:</strong><br>Zabbix API允许你使用JSON RPC协议来创建、更新和获取Zabbix对象信息或执行任何其他的自定义的任务。</p>
<p><strong>Zabbix server:</strong><br>Zabbix软件监控的核心程序，主要功能是与Zabbix proxies和agent进行交互、触发器计算、发送告警通知，并将数据集中保存等。</p>
<p><strong>Zabbix agent:</strong><br>部署在监控对象上，能够主动监控本地资源和应用。</p>
<p><strong>Zabbix proxy:</strong><br>帮助Zabbix server收集数据，分担Zabbix server的负载。</p>
<p><br><br><br></p>
<hr>
<h1 id="Zabbix进程"><a href="#Zabbix进程" class="headerlink" title="Zabbix进程"></a>Zabbix进程</h1><h2 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h2><p>zabbix agent部署在监控的目标上，主动监测本地的资源和应用（硬件驱动，内存，处理器统计等）。<br>zabbix agent手机本地的操作信息并将数据报告给zabbix server用于进一步处理。</p>
<p>zabbix agent有被动(passive)和主动(active)两种检查方式。</p>
<p><br></p>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>zabbix server是zabbix软件的核心程序。它通过轮询和捕获数据，计算是否满足触发器条件，向用户发送通知。<br>它是zabbix监控代理和Proxy代理报告系统可用性和完整性数据的核心组件。zabbix server自身可以通过简单远程检查网络服务(如Web服务器和邮件服务器)。</p>
<p>server是一个包含了被存储了所有配置，统计方面的和可操作数据的中央仓库，它是监控系统问题升级以致于激活警告管理器的zabbix中的实体。</p>
<p>基本的zabbix server分三个不同的组件：<strong>zabbix server，web前端，数据库存储</strong>。<br>zabbix的所有配置信息都存储在服务器和web前端进行交互的数据库中。</p>
<p>zabbix server进程是以守护进程（Daemon）运行的。</p>
<p><br></p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>zabbix proxy是一个可以从一个或多个受监控的设备设备收集监控数据，并将信息发送到zabbix server的进程，基本上是代表server工作。<br>所有收集的数据都在本地进行缓存，然后传送到proxy所属的zabbix server。</p>
<p>zabbix proxy是完成远程区域、分支机构、没有本地管理员的网络的集中监控的理想解决方案。</p>
<p>zabbix proxy需要使用独立的数据库，以守护进程的方式运行。</p>
<p><br></p>
<h2 id="Java-gateway"><a href="#Java-gateway" class="headerlink" title="Java gateway"></a>Java gateway</h2><p>zabbix守护进程原生支持监控JMX程序，它被称为zabbix java gateway。zabbix gateway是用Java语言写成。</p>
<p>要查得一台主机特定的JMX计数器值，zabbix server向zabbix java gateway发送请求，后者使用JMX管理API去请求远程的有关应用。应用不许额外安装软件，只需要启动时在命令行指定 <code>-Dcom.sun.management.jmxremote</code>即可（是在java程序）。</p>
<p>每个zabbix server或zabbix agent只能配置一个java gateway。</p>
<p><br></p>
<h2 id="Sender"><a href="#Sender" class="headerlink" title="Sender"></a>Sender</h2><p>zabbix sender是一种命令行应用，它可以将性能数据发送到zabbix server进行处理。该应用通常用在长时间运行的用户脚本，用于定期发送可用性和性能数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">zabbix_sender -z zabbix -s &quot;xxx&quot; -k db.connections -0 43</div><div class="line"></div><div class="line">-z :server主机</div><div class="line">-s :受监控主机的技术名称</div><div class="line">-k :监控项的键</div><div class="line">-o :要发送的值</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p>zabbix get也是一种命令行应用，用于与zabbix agent进行通信，并从agent那里获取所需的信息。<br>该应用通常被用于zabbix agent故障排除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">zabbix_get -s $host -p xxx -k system.cpu.load[all,avg15]</div><div class="line"></div><div class="line">-s  --host</div><div class="line">-p --port</div><div class="line">-I --source-address</div><div class="line">-k --key</div><div class="line">-h --help</div><div class="line">-V --version</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<hr>
<h1 id="安装Zabbix"><a href="#安装Zabbix" class="headerlink" title="安装Zabbix"></a>安装Zabbix</h1><h2 id="Zabbix安装要求"><a href="#Zabbix安装要求" class="headerlink" title="Zabbix安装要求"></a>Zabbix安装要求</h2><p><strong>硬件：</strong></p>
<ul>
<li>内存，最小128MB；</li>
<li>磁盘，最小256MB；</li>
<li>CPU，可能需要大量CPU资源；</li>
<li>SMS(短信)通知服务，串行通讯口(serial communication port)和串口GSM调制解调器(serial GSM modem)。可选项。</li>
</ul>
<p><strong>支持平台：</strong></p>
<ul>
<li>Linux;</li>
<li>IBM AIX;</li>
<li>FreeBSD;</li>
<li>NetBSD;</li>
<li>OpenBSD;</li>
<li>Mac OS X;</li>
<li>Solaris;</li>
<li>Windows(Only Agent).</li>
</ul>
<p><strong>软件：</strong><br>Zabbix基于Apache Web服务器、领先的数据库引擎和PHP脚本语言进行构建。</p>
<p><strong>数据库管理系统：</strong></p>
<ul>
<li>MySQL 5.0.3 及以上；</li>
<li>Oracle 10g 及以上；</li>
<li>PostgreSQL 8.1 及以上；</li>
<li>SQLite 3.5及以上；</li>
<li>IBM DB2 9.7 及以上。</li>
</ul>
<p><strong>前端：</strong></p>
<ul>
<li>Apache 1.3.12 及以上；</li>
<li>PHP 5.4.0及以上；</li>
</ul>
<p><strong>PHP-Extension:</strong></p>
<table>
<thead>
<tr>
<th>软件</th>
<th>版本</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>gd</td>
<td>2.0及以上</td>
<td>PHP GD扩展包必须支持PNG图片</td>
</tr>
<tr>
<td>bcmatch</td>
<td></td>
<td>php-bcmatch</td>
</tr>
<tr>
<td>ctype</td>
<td></td>
<td>php-ctype</td>
</tr>
<tr>
<td>libXML</td>
<td>2.6.15及以上</td>
<td>php-xml</td>
</tr>
<tr>
<td>xmlreader</td>
<td></td>
<td>php-xmlreader</td>
</tr>
<tr>
<td>xmlwrite</td>
<td></td>
<td>php-xmlwriter</td>
</tr>
<tr>
<td>session</td>
<td></td>
<td>php-session</td>
</tr>
<tr>
<td>sockets</td>
<td></td>
<td>php-net-socket</td>
</tr>
<tr>
<td>mbstring</td>
<td></td>
<td>php-mbstring</td>
</tr>
<tr>
<td>gettext</td>
<td></td>
<td>php-gettext</td>
</tr>
<tr>
<td>ldap</td>
<td></td>
<td>php-ldap</td>
</tr>
<tr>
<td>mysqli</td>
<td></td>
<td>使用MySQL作为Zabbix后端数据库所需的组件</td>
</tr>
<tr>
<td>pgsql</td>
<td></td>
<td>使用PostgreSQL作为Zabbix后端数据库所需的组件</td>
</tr>
<tr>
<td>sqlite3</td>
<td></td>
<td>使用SQLite作为Zabbix后端数据库所需的组件</td>
</tr>
</tbody>
</table>
<p><strong>客户端浏览器：</strong><br>必须启用Cookie和JavaScript功能。</p>
<p><strong>服务器：</strong></p>
<table>
<thead>
<tr>
<th>要求</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>OpenlPMI</td>
<td>支持IPMI功能所需组件</td>
<td></td>
</tr>
<tr>
<td>libssh2</td>
<td>支持SSH功能</td>
<td></td>
</tr>
<tr>
<td>fping</td>
<td>支持ICMP ping功能</td>
<td></td>
</tr>
<tr>
<td>libcurl</td>
<td>支持Web监控，VMware监控及SMTP认证</td>
<td></td>
</tr>
<tr>
<td>libiksemel</td>
<td>支持Jabber功能</td>
<td></td>
</tr>
<tr>
<td>libxml2</td>
<td>支持VMware监控</td>
<td></td>
</tr>
<tr>
<td>net-snmp</td>
<td>支持SNMP监控</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Java网关：</strong><br>Java gateway编译和运行在Java 1.6 及以上版本。</p>
<p><strong>数据库容量：</strong><br>Zabbix配置数据需要使用固定的磁盘空间，而这个空间不会过多增长。</p>
<p>Zabbix数据库容量主要依赖于以下参数：</p>
<ul>
<li>每秒处理值的数量(Number of processed values per second);</li>
<li>历史(History)数据的回收清理设置(Housekeeper);</li>
<li>趋势(Trends)数据的回收清理设置(Housekeeper);</li>
<li>事件(Events)数据的回收清理设置(Housekeeper)。</li>
</ul>
<p><strong>时钟同步：</strong><br>对于Zabbix稳定运行而言，服务获取精确的系统时间是非常重要的。对于所有运行Zabbix组件的系统，强烈建议这些系统的时间保持同步。<br><code>ntpd</code>是一个临幸的用于同步主机和其他服务器之间的时间的后台程序。</p>
<p><br></p>
<h2 id="安装、启动、配置Zabbix"><a href="#安装、启动、配置Zabbix" class="headerlink" title="安装、启动、配置Zabbix"></a>安装、启动、配置Zabbix</h2><p>Zabbix-repo仓库：<a href="repo.zabbix.com">repo.zabbix.com</a><br>该仓库服务器同时提供<code>yum</code>和<code>apt</code>源码库。</p>
<h3 id="配置源码库"><a href="#配置源码库" class="headerlink" title="配置源码库"></a>配置源码库</h3><p><strong>1. 从官方下载源码库</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#rpm -ivh http://repo.zabbix.com/zabbix/$version/rhel/7/$arch/$zabbix-release.rpm</span></div><div class="line">rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.centos.noarch.rpm</div><div class="line"></div><div class="line"><span class="comment">#阿里云镜像</span></div><div class="line"><span class="comment">#rpm -ivh http://mirrors.aliyun.com/zabbix/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.noarch.rpm</span></div><div class="line"></div><div class="line"><span class="comment">#镜像失效的话自己去官网找</span></div></pre></td></tr></table></figure>
<p><strong>2. 手动配置zabbix.repo</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vim /etc/yum.repos.d/zabbix.repo</div><div class="line"></div><div class="line">[zabbix]</div><div class="line">name=Zabbix-Repo</div><div class="line">baseurl=http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/</div><div class="line">gpgcheck=0</div><div class="line"><span class="built_in">enable</span>=1</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="安装Zabbix部署包"><a href="#安装Zabbix部署包" class="headerlink" title="安装Zabbix部署包"></a>安装Zabbix部署包</h3><p>使用MySQL数据库安装Zabbix Server、Web前端：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y zabbix-server-mysql zabbix-get</div></pre></td></tr></table></figure></p>
<p><strong>注意：此处Zabbix数据库使用MySQL，请自行安装MySQL。</strong></p>
<p>安装Zabbix Agent：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y zabbix-agent</div></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="安装初始化数据库"><a href="#安装初始化数据库" class="headerlink" title="安装初始化数据库"></a>安装初始化数据库</h3><p>查看刚刚安装的 <strong>zabbix-server-mysql</strong>：<br>解压得到的sql脚本<code>create.sql</code>只会在对应的数据库中初始化zabbix所需要的数据库表，但是不会创建zabbix数据库。所以后面我们还需要手动创建<code>zabbix</code>数据库。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rpm -ql zabbix-server-mysql</div><div class="line"></div><div class="line"><span class="built_in">cd</span> /usr/share/doc/zabbix-server-mysql-3.x.xx/</div><div class="line"></div><div class="line"><span class="comment">#有一个create.sql.gz的压缩文件</span></div><div class="line">gunzip create.sql.gz</div><div class="line"><span class="comment">#得到create.sql</span></div></pre></td></tr></table></figure></p>
<p><strong>在MySQL中创建zabbix数据库：</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">msyql -uxxx -p</div><div class="line"></div><div class="line">mysql&gt;CREATE DATABASE <span class="string">'zabbix'</span> DEFAULT CHARACTER SET <span class="string">'utf8'</span>;</div><div class="line">mysql&gt;SHOW DATABASES;</div><div class="line">mysql&gt;GRANT ALL ON zabbix.* TO <span class="string">'zabbix'</span>@<span class="string">'localhost'</span> identified by <span class="string">'zabbix'</span>;</div><div class="line">mysql&gt;FLUSH PRIVILEGES;</div><div class="line"></div><div class="line"><span class="comment">#导入sql脚本</span></div><div class="line">mysql -uroot -p -Dzabbix &lt; ./create.sql</div><div class="line"></div><div class="line">USE zabbix;</div><div class="line">SHOW TABLES;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#mysql限制IP</span></div><div class="line">vim /etc/my.cnf</div><div class="line"></div><div class="line">[mysqld]</div><div class="line"><span class="built_in">bind</span>-address=127.0.0.1</div></pre></td></tr></table></figure></p>
<p><br><br><img src="/images/zabbix_database.png" alt="zabbix-database alt=&quot;zabbix-database&quot;"></p>
<p><br></p>
<h3 id="配置zabbix-server并启动"><a href="#配置zabbix-server并启动" class="headerlink" title="配置zabbix server并启动"></a>配置zabbix server并启动</h3><p>编辑zabbix server配置文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">vim /etc/zabbix/zabbix_server.conf</div><div class="line"></div><div class="line"><span class="comment">#常会修改的参数</span></div><div class="line"></div><div class="line"><span class="comment">#数据库配置</span></div><div class="line">DBHost=localhost</div><div class="line">DBName=zabbix</div><div class="line">DBUser=zabbix</div><div class="line">DBPassword=zabbix</div><div class="line">DBPort=3306</div><div class="line">DBSocket=/var/lib/mysql/mysql.sock</div><div class="line"></div><div class="line"><span class="comment">#服务监听端口</span></div><div class="line">ListenPort=10051</div><div class="line"></div><div class="line"><span class="comment">#服务端源IP</span></div><div class="line">SourceIP=</div><div class="line"></div><div class="line"><span class="comment">#日志记录方式，file使用指定文件作为日志文件，system将日志发往syslog，console将日志发送控制台</span></div><div class="line">LogType=file</div><div class="line">LogFile=/var/<span class="built_in">log</span>/zabbix/zabbix_server.log</div></pre></td></tr></table></figure></p>
<p>启动zabbix服务端：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">systemctl start zabbix-server</div><div class="line"></div><div class="line"><span class="comment">#此处可能由于没有关闭SELinux而报错</span></div><div class="line">tail /var/<span class="built_in">log</span>/zabbix/zabbix_server.log</div><div class="line">cannot <span class="built_in">set</span> resource <span class="built_in">limit</span>: [13] Permission denied</div><div class="line"></div><div class="line"><span class="comment">#关闭SELinux</span></div><div class="line">setenforce=0</div><div class="line"></div><div class="line">vim /etc/selinux/config</div><div class="line">SELINUX=disabled</div><div class="line"></div><div class="line"><span class="comment">#查看zabbix-server默认监听的10051端口</span></div><div class="line">netstat -nltp</div></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="安装zabbix-web"><a href="#安装zabbix-web" class="headerlink" title="安装zabbix web"></a>安装zabbix web</h3><p>zabbix web可以安装在单独的主机上，只要能连接到zabbix database所在数据库就行。但为了方便，都安装在了server上。</p>
<p>zabbix web需要LAMP环境：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#可能需要自己配置PHP remi源，注意PHP及扩展版本问题</span></div><div class="line">yum install -y httpd php php-mysql php-mbstring php-gd php-bcmatch php-ldap php-xml</div><div class="line"></div><div class="line"><span class="comment">#指定php版本</span></div><div class="line"><span class="comment">#yum --enablerepo=remi-php56 install php-mysql php-mbstring php-gd php-bcmatch php-ldap php-xml</span></div></pre></td></tr></table></figure></p>
<p>安装zabbix web所需的两个包：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">yum install -y zabbix-web zabbix-web-mysql</div><div class="line"><span class="comment">#此处默认使用php5.4</span></div><div class="line"><span class="comment">#因为我的环境是php5.6,会报错</span></div><div class="line"><span class="comment">#此时就需要指定php版本来安装</span></div><div class="line">yum --enablerepo=remi-php56 install zabbix-web zabbix-web-mysql</div><div class="line"></div><div class="line"></div><div class="line">rpm -ql zabbix-web</div><div class="line"><span class="comment">#zabbix-web位于/usr/share/zabbix/</span></div></pre></td></tr></table></figure></p>
<h3 id="编辑zabbix的前端Apach-PHP配置文件"><a href="#编辑zabbix的前端Apach-PHP配置文件" class="headerlink" title="编辑zabbix的前端Apach-PHP配置文件"></a>编辑zabbix的前端Apach-PHP配置文件</h3><p>zabbix前端的Apache配置文件位于 /etc/httpd/conf.d/zabbix.conf:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">vim /etc/httpd/conf.d/zabbix.conf</div><div class="line"></div><div class="line"><span class="comment">#需修改时区</span></div><div class="line">php_value max_execution_time 300</div><div class="line">php_value memory_limit 128M</div><div class="line">php_value post_max_size 16M</div><div class="line">php_value upload_max_filesize 2M</div><div class="line">php_value max_input_time 300</div><div class="line">php_value always_populate_raw_post_data -1</div><div class="line">php_value date.timezone Asia/Shanghai</div><div class="line"></div><div class="line"><span class="comment">#建议顺便修改/etc/php.ini的时区</span></div><div class="line">vim /etc/php.ini</div><div class="line"></div><div class="line">date.timezone = Asia/Shanghai</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#添加httpd的虚拟主机访问zabbix web</span></div><div class="line">&lt;VirtualHost IP:80&gt;</div><div class="line">servername zabbix.me</div><div class="line">documentroot /usr/share/zabbix</div><div class="line"></div><div class="line">默认数据</div><div class="line"></div><div class="line">&lt;/VirtualHost&gt;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#开启httpd服务</span></div><div class="line">systemctl start httpd</div></pre></td></tr></table></figure></p>
<p><br><br><img src="/images/Zabbix/zabbix_conf.png" alt="/etc/httpd/conf.d/zabbix.conf"></p>
<p><br><br>添加hosts后就可以利用域名访问zabbix-web端了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> -e <span class="string">"192.168.1.9 \t zabbix.me"</span> &gt;&gt; /etc/hosts</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="在web端配置zabbix"><a href="#在web端配置zabbix" class="headerlink" title="在web端配置zabbix"></a>在web端配置zabbix</h3><p>在浏览器访问 <a href="http://zabbix.me" target="_blank" rel="external">http://zabbix.me</a> 初始化zabbix配置。<br>配置好后就需要用账号密码进行登录zabbix-web端dashboard。</p>
<p>默认用户名是：admin，密码是配置文件里面设置的。<br><img src="/images/Zabbix/zabbix_me.png" alt="登录zabbix Dashboard"></p>
<p><br></p>
<p>登录进Dashboard后，可修改语言为中文。</p>
<p><img src="/images/Zabbix/dashboard.jpg" alt="Dashboard"></p>
<p><br></p>
<p><strong>如果你的Zabbix无法看到中文选项，那么可能需要如下操作：</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim /usr/share/zabbix/include/locales.inc.php</div><div class="line"></div><div class="line"><span class="comment">#修改</span></div><div class="line"><span class="string">'zh_CN'</span> =&gt; [<span class="string">'name'</span> =&gt; _(<span class="string">'Chinese (zh_CN)'</span>),     <span class="string">'display'</span> =&gt; <span class="literal">true</span>],</div></pre></td></tr></table></figure></p>
<p><strong>如果又遇到中文乱码的问题，则可以从windows中挑选一些好看的中文字体，将对应字体文件放置到zabbix web的字体目录中。</strong><br>windows中字体后缀.TTF，Linux中为.ttf。注意修改大小写。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/share/zabbix/fonts</div><div class="line"><span class="comment">#只有一个默认字体 graphfont.ttf</span></div><div class="line"><span class="comment">#将新字体放置到此目录下</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#修改配置文件中对应字体名称</span></div><div class="line">vim /usr/share/zabbix/include/define.inc.php</div><div class="line"></div><div class="line"><span class="comment">#将默认字体名字修改为字体目录下 你需要的字体名</span></div><div class="line">define(<span class="string">'ZBX_FONT_NAME'</span>, <span class="string">'graphfont'</span>);</div><div class="line">define(<span class="string">'ZBX_GRAPH_FONT_NAME'</span>,           <span class="string">'graphfont'</span>); // font file name</div><div class="line"></div><div class="line"><span class="comment">#栗子，如perpetua字图PER.ttf</span></div><div class="line">define(<span class="string">'ZBX_FONT_NAME'</span>, <span class="string">'PER'</span>);</div><div class="line">define(<span class="string">'ZBX_GRAPH_FONT_NAME'</span>,           <span class="string">'PER'</span>); // font file name</div></pre></td></tr></table></figure></p>
<p><br></p>
<p><strong>图形显示乱码，同样是用以上方法。在windowss上找一个中文字体上传到zabbix字体目录，并修改配置文件就可以了。</strong></p>
<p><br></p>
<p>Zabbix Web界面菜单：</p>
<p><img src="/images/Zabbix/zabbix_menu.png" alt="zabbix菜单"></p>
<p><br></p>
<ul>
<li>管理菜单，用于管理zabbix自身及zabbix相关设置；</li>
<li>配置菜单，用于配置监控相关设置；</li>
<li>报表菜单，为管理员生成一段时间内的监控统计信息；</li>
<li>检测中菜单，用于查看被监控的相关数据；</li>
<li>资产记录菜单，查看被监控的主机有哪些，以及相关的资产信息。</li>
</ul>
<p><br></p>
<h2 id="安装zabbix-agent"><a href="#安装zabbix-agent" class="headerlink" title="安装zabbix agent"></a>安装zabbix agent</h2><p>Agent端安装也非常方便，直接在Client上安装两个包即可。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#配置zabbix源</span></div><div class="line">rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.centos.noarch.rpm</div><div class="line"></div><div class="line"><span class="comment">#aliyun镜像</span></div><div class="line"><span class="comment">#rpm -ivh http://mirrors.aliyun.com/zabbix/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.noarch.rpm</span></div><div class="line"></div><div class="line"><span class="comment">#安装</span></div><div class="line">yum install -y zabbix-agent zabbix-sender</div><div class="line"></div><div class="line">rpm -ql zabbix-agent</div><div class="line"><span class="comment">#/etc/zabbix/zabbix_agentd.conf</span></div></pre></td></tr></table></figure>
<p>zabbix的“主动模式”与“被动模式”都在<code>/etc/zabbix/zabbix_agentd.conf</code>中定义。<br>配置最常用的agent端：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">vim /etc/zabbix/zabbix_agentd.conf</div><div class="line"></div><div class="line"><span class="comment">####GENERAL PARAMETERS 通用配置</span></div><div class="line">PidFile=</div><div class="line">LogFile=</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">####Passive checks related 被动模式配置</span></div><div class="line"><span class="comment">#指定允许哪台服务器拉取本机数据</span></div><div class="line">Server=</div><div class="line"><span class="comment">#指定agent端工作于被动模式时监听的端口号</span></div><div class="line">ListenPort=10050(默认)</div><div class="line"><span class="comment">#指定agent端工作与被动模式时所监听的IP地址</span></div><div class="line">ListenIP=0.0.0.0(默认)</div><div class="line"><span class="comment">#指定预生成的agent进程数量</span></div><div class="line">StartAgents=</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">####Active checks related</span></div><div class="line"><span class="comment">#agent工作于主动模式时，将消息推送到哪台Server上</span></div><div class="line">ServerActive=IP1,IP2...</div><div class="line"><span class="comment">#指定当前主机主机名，Server端通过对应的主机名识别主机</span></div><div class="line">Hostname=</div><div class="line"><span class="comment">#指明agent端每隔多少秒将采集的数据发往Server端</span></div><div class="line">RefreshActiveChecks=</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">Server=192.168.1.9</div><div class="line">ServerActive=192.168.1.9</div><div class="line">Hostname=zabbix.me</div></pre></td></tr></table></figure></p>
<p><br><br><strong>启动zabbix-agent</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">systemctl zabbix-agent start</div><div class="line"></div><div class="line"><span class="comment">#查看状态,默认端口10050</span></div><div class="line">netstat -nltp</div></pre></td></tr></table></figure></p>
<p><img src="/images/Zabbix/zabbix-agent.png" alt="zabbix-agent状态"></p>
<p><br><br><br></p>
<hr>
<h1 id="快速开始zabbix-web菜单"><a href="#快速开始zabbix-web菜单" class="headerlink" title="快速开始zabbix-web菜单"></a>快速开始zabbix-web菜单</h1><p>zabbix-web界面中包含有<strong>监测中、资产记录、报表、配置、管理</strong>五项菜单。</p>
<p><br></p>
<h2 id="登录和配置用户"><a href="#登录和配置用户" class="headerlink" title="登录和配置用户"></a>登录和配置用户</h2><p>在浏览器输入 <a href="zabbix.me">zabbix.me</a> (修改hosts)，登录zabbix-web后台。<br>默认用户名：<strong>Admin</strong>，密码：<strong>zabbix</strong>。它是超级管理员。</p>
<p>为了防止暴力破解和词典攻击，连续尝试五次登录失败，zabbix界面将暂停30秒。</p>
<p><br><br>可以通过<strong>管理(Management)</strong>菜单下的<strong>用户(User)</strong>，新建、查看、管理用户信息。</p>
<p>zabbix在安装后自定义了两个用户：</p>
<ul>
<li>Admin用户是zabbix的超级管理员，拥有所有权限；</li>
<li>Guest用户是一个特殊的默认用户。如果你没有登录，你访问zabbix的时候其实就是“guest”权限。guest默认没有任何权限。</li>
</ul>
<p>你可以创建一个用户(user)并将其加入特定的用户组(Group)以提升用户权限。<br><img src="/images/Zabbix/user.png" alt="新建用户"></p>
<p><br></p>
<h2 id="新建主机"><a href="#新建主机" class="headerlink" title="新建主机"></a>新建主机</h2><p>zabbix中的主机(host)是一个你想要监控的网络实体(物理的、虚拟的)。对于主机的定义非常灵活。它可以是一台物理服务器，一个网络交换机，一个虚拟机或一些应用。</p>
<p><br><br>可以通过<strong>配置(Configuration)</strong>菜单下的<strong>主机(Host)</strong>，查看已配置主机相关信息。<br>默认有一个“Zabbix Server”的定义好的主机。</p>
<p>点击<strong>创建主机(Create host)</strong>后，填写对应的主机名称、添加对应的主机群组，zabbix-agent的IP地址和端口，以及其它信息。</p>
<p><img src="/images/Zabbix/host.png" alt="创建主机"></p>
<p><br></p>
<h2 id="新建监控项"><a href="#新建监控项" class="headerlink" title="新建监控项"></a>新建监控项</h2><p>监控项是zabbix中获得数据的基础。没有监控项，就没有数据。因为一个主机中只有监控项定义了”单一的指标“或者”需要获得的数据“。</p>
<p><br><br>可以通过<strong>配置(Configuration)</strong>菜单下的<strong>主机(Item)</strong>，找到需要配置<strong>监控项(Item)</strong>的主机，然后创建监控项。<br>主机默认是没有定义任何监控项的。</p>
<p>填写对应的监控名称、类型、键值、主机接口、信息类型等等信息。<br><img src="/images/Zabbix/create-item.png" alt="添加监控项"></p>
<p><br><br>可在<strong>监控(Monitoring)</strong>菜单中<strong>最新数据(Latest data)</strong>查看之前定义的监控项和获得的值。<br>还可选择以<strong>图形(Graph)</strong>或<strong>值</strong>来查看监控项的相关信息。<br><img src="/images/Zabbix/upload.png" alt="upload监控信息"></p>
<p>同样也还以在Zabbix-Server端获得数据信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#zabbix_get -s $ip -k $value</span></div><div class="line">zabbix_get -s 192.168.1.9 -k system.cpu.load</div></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="新建触发器"><a href="#新建触发器" class="headerlink" title="新建触发器"></a>新建触发器</h2><p>监控项只用于收集数据。如果要自动评估收到的数据，我们则需要定义触发器(trigger)。<br>触发器包含了一个表达式，这个表达式定义了数据的可接受的阈值级别。</p>
<p>如果收到的数据超过了定义好的级别，触发器将被<strong>触发</strong>，或者进入<strong>异常状态</strong>(problem)。<br>从而引起我们的注意，让我们知道有问题发生。如果数据再次恢复到合理范围，触发器将会转到<strong>正常状态</strong>(OK)。</p>
<p><br><br>可以通过<strong>配置(Configuration)</strong>菜单下的<strong>主机(Hosts)</strong>选项，找到某主机的<strong>触发器(Triggers)</strong>创建触发器。</p>
<p>填写对应的触发器名称、表达式、描述等信息。<br><img src="/images/Zabbix/create-trigger.png" alt="创建触发器"></p>
<p><br></p>
<h2 id="获取问题通知"><a href="#获取问题通知" class="headerlink" title="获取问题通知"></a>获取问题通知</h2><p>当监控项收集了数据后，触发器会根据异常状态触发报警。根据一些报警机制，它也会通知我们一些重要的事情，而不是直接在zabbix-web端进行查看。<br>这就是<strong>通知(Notification)</strong>的功能。<br><strong>E-mail</strong>是最常用的异常通知发送方式。当然还有<strong>SMS（短信），脚本</strong>等媒体类型。</p>
<p><br><br>可以通过<strong>管理(Administration)</strong>菜单中的<strong>报警媒体类型(Media types)</strong>，点击预定义媒体类型列表中的Email，来配置Email。<br><img src="/images/Zabbix/create-email.png" alt="创建Email通知"></p>
<p>为了建立一个通知，我们需要在<strong>配置</strong>菜单下<strong>动作</strong>中，创建<strong>动作(Create action)</strong>。<br><img src="/images/Zabbix/create-action.png" alt="创建动作"></p>
<p>一旦满足了触发器的条件，变回触发执行动作。如收到E-mail等…</p>
<p><br></p>
<h2 id="新建模板"><a href="#新建模板" class="headerlink" title="新建模板"></a>新建模板</h2><p>如果我们配置上前台主机，一些自动化操作会带来更多便利性。没错，<strong>模板(templates)</strong>功能就可以实现。<br>模板允许对有用的监控项、触发器和其他对象进行分组，只需要一步就可以对监控主机应用模板，已达到反复重用的目的。</p>
<p>当一个模板链接到一个主机后，主机会继承这个模板中的所有对象。简单而言，一组预先定义好的检查会被快速应用到主机上。</p>
<p>Zabbix为各种操作系统、设备以及应用准备好了一些预定义的模板。你可以快速部署使用他们。<br><strong>但是请注意，一些模板需要根据你的实际情况和使用环境进行适当俄调整。</strong> 比如，一些检查项是不需要的，一些轮询周期过于频繁等。</p>
<p><br><br>在<strong>配置</strong>菜单下的<strong>模板(Templates)</strong>下，点击<strong>创建模板(Create template)</strong>。填写对应的模板名称，群组等信息。<br><img src="/images/Zabbix/create-template.png" alt="创建模板"></p>
<p>创建模板完毕后，可将模板链接到主机。之后，模板及其所有对象被添加到了主机。</p>
<p><br><br><br></p>
<hr>
<h1 id="配置-Configuration"><a href="#配置-Configuration" class="headerlink" title="配置(Configuration)"></a>配置(Configuration)</h1><h2 id="主机和主机组-Hosts-and-groups"><a href="#主机和主机组-Hosts-and-groups" class="headerlink" title="主机和主机组(Hosts and groups)"></a>主机和主机组(Hosts and groups)</h2><p>一般来讲，zabbix主机是指你希望监控的那些设备。如服务器、工作站、交换机等。<br>创建主机是使用zabbix过程的首要任务。</p>
<h3 id="配置一台主机"><a href="#配置一台主机" class="headerlink" title="配置一台主机"></a>配置一台主机</h3><p>配置–主机–创建主机–填写相关参数信息。</p>
<p>可以在已经存在的主机上使用 <strong>Clone</strong>或<strong>Full Clone</strong>创建一个新主机。</p>
<blockquote>
<p>Clone将保留所有的主机参数和模板链接；<br>Full Clone将额外保留指数实体(应用集、监控项、触发器、视图、规则、Web场景)。</p>
</blockquote>
<p><strong>新建主机下：</strong></p>
<ol>
<li>主机(Host)：包含了通用的主机属性；</li>
<li>模板(Template)：允许将模板链接诶到主机，所有实体将从模板继承；</li>
<li>IPMI：包含IPMI管理属性；</li>
<li>宏(Macros)：允许定义主机级别的<strong>用户宏</strong>；</li>
<li>主机资产记录(Host inventory)：允许为主机收工输入库存信息；</li>
<li>允许你请求与主机的加密的连接。</li>
</ol>
<p><br></p>
<h3 id="资产管理-Inventory"><a href="#资产管理-Inventory" class="headerlink" title="资产管理(Inventory)"></a>资产管理(Inventory)</h3><p>你可以将联网设备的资产信息保存在zabbix里。<br>资产信息实在配置主机时人工录入建立的资产信息数据，或者通过使用某些自动填充选项完成的录入。</p>
<p><strong>构建资产库：</strong></p>
<ul>
<li>手动模式： 在配置一台主机的时候，手动输入资产信息；</li>
<li>自动模式： 在配置主机的时候，选择自动。</li>
</ul>
<p>之后便可以在<strong>资产记录</strong>菜单中的<strong>概述，主机</strong>项中查看相关信息。</p>
<p><br></p>
<h3 id="批量更新-Mass-update"><a href="#批量更新-Mass-update" class="headerlink" title="批量更新(Mass update)"></a>批量更新(Mass update)</h3><p>有时候可能需要一次更改多个主机的某些属性，使用<strong>批量更新(mass update)</strong>功能来代替打开每个主机进行编辑。</p>
<p><img src="/images/Zabbix/mass-update.png" alt="批量更新"></p>
<p>可批量处理<strong>主机、模板、IPMI、资产、加密</strong>相关信息。</p>
<p><br><br><br></p>
<h2 id="监控项-Items"><a href="#监控项-Items" class="headerlink" title="监控项(Items)"></a>监控项(Items)</h2><p><strong>监控项</strong>是从主机收集的数据信息。<br>配置主机后，需要添加一些监控项以开始获取数据。快速添加多个监控项的一种方法是将预定义的模板附加到主机。</p>
<p>在单个监控项中，可指定从主机收集哪些数据信息。<br>为此，可使用<strong>监控项key</strong>。 如<strong>system.cpu.load</strong>将收集处理器负载的数据。<br>要给 key 指定更过参数，请在后面添加<strong>方括号[]</strong>。 如<strong>system.cpu.load[avg5]</strong>， 返回最近5分钟的CPU负载平均值。</p>
<p><br></p>
<h3 id="创建一个监控项"><a href="#创建一个监控项" class="headerlink" title="创建一个监控项"></a>创建一个监控项</h3><p>可在主机中新建一个监控项。<br>不支持的监控项：如果由于某种原因无法检索该值，则该监控项可能不被支持。这些监控项仍然以固定的间隔重新检查。</p>
<p><strong>监控项的key:</strong></p>
<ol>
<li>key名称允许使用字符： 0-9a-zA-Z_-.</li>
<li>key参数，用 逗,号 分隔： xxx[par1,par2…]</li>
<li>key参数也可以为空，此时使用默认值： key</li>
<li>key参数带引号，则允许任何Unicode字符，如果包含双引号则需要 \反斜杠 转义</li>
<li>key参数是一个数组，它需要包含在方括号中</li>
</ol>
<p><br><br><strong>自定义间隔(Custom intervals)</strong></p>
<p>创建关于监控项的自定义时间规则。<br>灵活间隔被设计为重新定义默认监控项的的更新间隔，但调度间隔用于指定独立执行的检查计划。</p>
<p><strong>灵活的间隔(Flexible intervals)：</strong>允许重定义特定时间段的默认间隔。</p>
<ul>
<li>间隔(Interval)： 指定时间段的更新间隔；</li>
<li>期间(Period)： 灵活间隔有效的时间段；</li>
<li>举个栗子： 60(interval), 1-7,00-24(period)。监控项每隔60s检查一次。</li>
</ul>
<p><br><br><strong>调度间隔(Scheduling intervals)：</strong>用于在特定时间检查监控项。</p>
<p>调度间隔定义为， <code>md&lt;filter&gt;wd&lt;filter&gt;h&lt;filter&gt;m&lt;filter&gt;s&lt;filter&gt;</code>。</p>
<ul>
<li>md: month days(1-31)</li>
<li>wd: week days(1-7)</li>
<li>h:  hours(0-23)</li>
<li>m:  minutes(0-59)</li>
<li>s:  seconds(0-58)</li>
<li><filter>: 指定其前缀的值—-[from-to/step]。</filter></li>
</ul>
<p>其实类似于Linux中定时任务的写法，只不过这里把单位(md,wd,h,m,s)写在了数值的前面。<br>举个栗子：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">md1-15	<span class="comment">#1-15号</span></div><div class="line"></div><div class="line">wd3	<span class="comment">#星期三</span></div><div class="line"></div><div class="line">h0-12	<span class="comment">#上半天</span></div><div class="line"></div><div class="line">m1,3,5,7,9	<span class="comment">#每个1,3,5,7,9分钟</span></div><div class="line"></div><div class="line">s/10	<span class="comment">#每个10s</span></div><div class="line"></div><div class="line"><span class="comment">#组合体</span></div><div class="line">wd1-5h9-18m/10	<span class="comment">#每个工作日的上班时间每个10分钟</span></div></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="监控项类型-Items-type"><a href="#监控项类型-Items-type" class="headerlink" title="监控项类型(Items type)"></a>监控项类型(Items type)</h3><p>监控项类型包含从系统获取数据的多种方式。每个监控项类型都有一组自己支持的监控项key和所需的参数。</p>
<p>zabbix提供的监控项类型：</p>
<ol>
<li>zabbix代理检查(agent checks)</li>
<li>SNMP代理检查</li>
<li>SNMP traps</li>
<li>IPMI检查</li>
<li>简单检查(simple checks)</li>
<li>VMware监控(monitoring)</li>
<li>日志文件监控</li>
<li>计算监控项(Calculated items)</li>
<li>zabbix内部检查(internal checks)</li>
<li>SSH检查</li>
<li>Telnet检查</li>
<li>外部检查(External checks)</li>
<li>汇总检查(Aggregate checks)</li>
<li>捕捉器监控项(Trapper items)</li>
<li>JMX监控</li>
<li>ODBC监控</li>
</ol>
<p><br><br><strong>zabbix代理(zabbix agent)：</strong><br>这些检查与zabbix代理进行通信实现数据的采集。</p>
<ol>
<li>zabbix agent-passive： 被动模式，Server向Agent索要数据；</li>
<li>zabbix agent-active： 主动模式，Agent主动上报数据给Server。</li>
</ol>
<p>可支持的监控项，可在新建监控项是在键值里面查看。</p>
<p><br><br><strong>SNMP代理(SNMP agent)：</strong></p>
<p>在启用SNMP的设备(如打印机，交换机，路由器…)上使用SNMP监控，为了能够监控SNMP代理在这些设备上提供的数据，zabbix服务器初始化配置时必须具有SNMP支持。<br>仅通过UDP协议执行SNMP检查。</p>
<p><strong>配置SNMP监控：</strong></p>
<ol>
<li>使用SNMP接口为设备创建一个主机；</li>
<li>找出要监控项目的SNMP字符串；</li>
<li>创建一个监控项。</li>
</ol>
<p><br><br><strong>IPMI检查：</strong><br>你可以在zabbix中监控 <strong>智能平台管理接口(IPMI)</strong> 设备的运行状况和可用性。<br>要执行IPMI检查，zabbix服务器必须首先配置IPMI支持。</p>
<p><br><br><strong>简单检查：</strong><br>简单检查通常用于远程无代理监控服务。</p>
<p><br><br><strong>日志文件监控：</strong><br>zabbix可用于集中监控和分析 具有/不具有 日志转动能力的日志文件。<br>当日志文件包含某些字符串或字符串模式时，通知信息可用于警告用户。</p>
<p><br><br><strong>计算监控项：</strong><br>计算监控项是创建虚拟数据源的一种方式。这些值将根据算术表达式定期计算。所有计算都由Server完成。</p>
<p><br><br><strong>内部检查：</strong><br>内部检查可以监控zabbix的内部检查。即Server或Agent Server的运行情况。</p>
<p><br><br><strong>SSH检查：</strong><br>运行SSH检查是作为无代理监控的，SSH检查不需要zabbix代理。<br>执行SSH检查zabbix服务器必须初始化配置为SSH2支持。</p>
<p>SSH检查提供两种身份验证方法，一种是用户/密码，另一种是基于密钥文件。</p>
<p>zabbix SSH 密钥配置:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">vim /etc/zabbix/zabbix_server.conf</div><div class="line"></div><div class="line"><span class="comment">#SSHKeyLocation=</span></div><div class="line">SSHKeyLocation=/home/zabbix/.ssh</div><div class="line"></div><div class="line">usermod -m -d /home/zabbix zabbix</div><div class="line">chown zabbix:zabbix /home/zabbix</div><div class="line">chmod 700 /home/zabbix</div><div class="line"><span class="built_in">cd</span> /home/zabbix &amp;&amp; su zabbix</div><div class="line"></div><div class="line">ssh-keygen -t rsa</div></pre></td></tr></table></figure></p>
<p><br><br><strong>外部检查：</strong><br>外部检查是由zabbix Server通过运行shell脚本或二进制的检查。<br>外部检查不需要再被监控的主机上运行任何代理。</p>
<p><br><br><strong>汇总检查：</strong><br>在汇总检查中，zabbix通过直接从数据库中查询监控信息，然后进行信息聚合。<br>聚合检查不需要再被监控的主机上运行任何代理。</p>
<p><br><br><strong>捕捉器监控项：</strong><br>捕捉器监控项接收传入的数据，而不是查询它。对于想要推送到zabbix的任何数据都是适用的。</p>
<p>要使用捕捉器监控项，需要在zabbix中建立一个捕捉器监控项，将数据送给zabbix。</p>
<p><br><br><strong>JMX监控项：</strong><br>JMX监控可用于监视Java应用程序的JMX计数器。<br>JMX监视器以zabbix守护进程方式运行，名为zabbix java gateway。</p>
<p><br><br><strong>ODBC监控：</strong><br>ODBC监控对应于zabbix web管理端中的数据库监控器监控项类型。<br>ODBC是用于访问 数据库管理系统(DBMS) 的C语言中间件API。</p>
<p>zabbix可以查询ODBC支持的任何数据库。为了实现监控，zabbix不直接连接到数据库，而是使用ODBC中设置的ODBC接口和驱动。<br>该功能允许为多个目的更加有效地监控不同的数据库。</p>
<p><br></p>
<h3 id="历史与趋势-history-and-trends"><a href="#历史与趋势-history-and-trends" class="headerlink" title="历史与趋势(history and trends)"></a>历史与趋势(history and trends)</h3><p>历史与趋势是zabbix中存储数据的两种方式。<br>历史保持每个收集的值，而趋势是每小时的平均信息。</p>
<p>建议保持的历史数据尽可能少，但可以保留更多的趋势数据。</p>
<p><br></p>
<h3 id="用户自定义参数-user-parameter"><a href="#用户自定义参数-user-parameter" class="headerlink" title="用户自定义参数(user parameter)"></a>用户自定义参数(user parameter)</h3><p>有时你想运行一个代理检查，但它不是zabbix预定义的。这时就能用到<strong>用户参数</strong>。<br>用户参数是由zabbix代理之星的命令，最多可以返回512KB的数据。<br><strong>key</strong> 是唯一的。</p>
<p>用户参数用法：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">UserParameter=&lt;key&gt;,&lt;<span class="built_in">command</span>&gt;</div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">UserParameter=ping,<span class="built_in">echo</span> 1</div><div class="line"><span class="comment">#使用ping键为一个监控项返回 1</span></div><div class="line"></div><div class="line"><span class="comment">#复杂栗子</span></div><div class="line">UserParameter=mysql.ping,mysqladmin -uroot -ppwd ping | grep -c <span class="string">'alive'</span></div><div class="line"><span class="comment">#mysqld状态为alive返回1，否则0</span></div><div class="line"></div><div class="line"><span class="comment">#灵活的用户参数</span></div><div class="line">UserParameter=key[*],<span class="built_in">command</span></div><div class="line"><span class="comment">#[*]定义该key接受括号内的参数</span></div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">UserParameter=ping[*],<span class="built_in">echo</span> <span class="variable">$1</span></div><div class="line"></div><div class="line">UserParameter=mysql.ping[*],mysqladmin -u<span class="variable">$1</span> -p<span class="variable">$2</span> ping | grep -c <span class="string">'alive'</span></div><div class="line"><span class="comment">#mysql.ping[zabbix,passwd]</span></div><div class="line"></div><div class="line">UserParameter=wc[*],grep -c <span class="string">"<span class="variable">$2</span>"</span> <span class="variable">$1</span></div><div class="line"><span class="comment">#wc[/etc/passwd,root]</span></div></pre></td></tr></table></figure></p>
<p><br><br><strong>用户自定义参数扩展zabbix代理：</strong><br>是将key添加到被监控的主机哦！<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#编写命令--SQL查询总数</span></div><div class="line">mysqladmin -uxxx -pxxx status | cut -f4 -d<span class="string">":"</span> | cut -f1 -d<span class="string">"S"</span></div><div class="line"></div><div class="line"><span class="comment">#将命令添加到zabbix_agentd.conf</span></div><div class="line">vim /etc/zabbix/zabbix_agentd.conf</div><div class="line"></div><div class="line"><span class="comment">#找到如下字段</span></div><div class="line"><span class="comment">### Option: UserParameter</span></div><div class="line">UserParameter=mysql.totalquery,mysqladmin -uroot -pxxx status | cut -f4 -d<span class="string">":"</span> | cut -f1 -d<span class="string">"S"</span></div><div class="line"><span class="comment">#mysql.totalquery这个key是唯一的标识符</span></div><div class="line"></div><div class="line"><span class="comment">#测试此参数</span></div><div class="line"><span class="comment">##测试参数可用与否很重要哈</span></div><div class="line">zabbix_agentd -t mysql.totalquery</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#重启zabbix-agent，将重新加载配置</span></div><div class="line">zabbix_get -s <span class="variable">$host</span> -k mysql.totalquery</div></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="可加载模块-loadable-modules"><a href="#可加载模块-loadable-modules" class="headerlink" title="可加载模块(loadable modules)"></a>可加载模块(loadable modules)</h3><p>可加载模块提供了一种关于zabbix性能扩展的选项。</p>
<p>可加载模块基本上只zabbix守护程序使用的共享库，并在启动时加载。<br>可加载模块具有很多优点，卓越的性能和可实现任何逻辑的能力，更重要的是使用和共享了zabbix模块的开发能力。</p>
<p><br></p>
<h3 id="windows性能计数器-windows-perfomance-counter"><a href="#windows性能计数器-windows-perfomance-counter" class="headerlink" title="windows性能计数器(windows perfomance counter)"></a>windows性能计数器(windows perfomance counter)</h3><p>使用perf_counter[]key有效的监控windows性能计数器</p>
<p><br></p>
<h3 id="批量更新-mass-update"><a href="#批量更新-mass-update" class="headerlink" title="批量更新(mass update)"></a>批量更新(mass update)</h3><p>使用批量更新功能，可一次更改多个监控属性。</p>
<p><br></p>
<h3 id="值映射-value-mapping"><a href="#值映射-value-mapping" class="headerlink" title="值映射(value mapping)"></a>值映射(value mapping)</h3><p>对于接收值更人性化的表示，可以使用包含数值和字符串之间的映射的<strong>值映射</strong>。</p>
<p>如：</p>
<ul>
<li>0 —&gt; error</li>
<li>1 —&gt; true</li>
<li>F —&gt; Full</li>
<li>D —&gt; Differential</li>
<li>I —&gt; Incremental</li>
<li>…</li>
</ul>
<p><br></p>
<h3 id="应用集-Application"><a href="#应用集-Application" class="headerlink" title="应用集(Application)"></a>应用集(Application)</h3><p><strong>应用集</strong>对逻辑组中的监控项进行分组。</p>
<p>如，对MongoDB的可用性，空间，负载，慢查询，执行命令…，可归于 MongoDB应用于中。</p>
<p><br></p>
<h3 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h3><p><strong>队列</strong>显示正在等待刷新的监控项。<br>队列只是一个逻辑表达的数据。</p>
<p>队列显示的统计信息是zabbix服务器性能是否健康的指标。<br>在 管理–队列 下对去队列。</p>
<p><br></p>
<h3 id="值缓存-value-cache"><a href="#值缓存-value-cache" class="headerlink" title="值缓存(value cache)"></a>值缓存(value cache)</h3><p>为了计算触发表达式，以及让计算/聚合监控项和一些宏更快，zabbix服务器支持值的缓存选项。</p>
<p>在内存中的缓存可用于访问历史数据，而不用之间调用数据库。如果缓存中不存在历史值，则从数据库请求缺少的值，并相应地跟新缓存。</p>
<p>要启用值缓存功能，修改zabbix_server.conf中可选的ValueCacheSize参数。</p>
<p><br><br><br></p>
<h2 id="触发器-Trigger"><a href="#触发器-Trigger" class="headerlink" title="触发器(Trigger)"></a>触发器(Trigger)</h2><p>触发器是评估有项目采集的数据并表示当前系统状况的逻辑表达式。<br>触发器表达式允许定义一个什么状况的数据是“可接受”的阈值。如果超过了可接受状态，则触发器会被触发。</p>
<p><br></p>
<h3 id="配置一个触发器-configuring-a-trigger"><a href="#配置一个触发器-configuring-a-trigger" class="headerlink" title="配置一个触发器(configuring a trigger)"></a>配置一个触发器(configuring a trigger)</h3><p>在主机里面配置触发器。</p>
<p><br></p>
<h3 id="触发器表达式-trigger-expression"><a href="#触发器表达式-trigger-expression" class="headerlink" title="触发器表达式(trigger expression)"></a>触发器表达式(trigger expression)</h3><p>一个简单有效的表达式看起来像：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;&lt;server&gt;:&lt;key&gt;.&lt;<span class="keyword">function</span>&gt;(&lt;parameter&gt;)&#125;&lt;operator&gt;&lt;constant&gt;</div><div class="line"></div><div class="line"><span class="comment">#如</span></div><div class="line">&#123;192.168.1.7:agent.ping.time()&#125;=0</div></pre></td></tr></table></figure></p>
<p><strong>函数参数(function parameters)：</strong><br>大多数数字型的函数接受秒数来作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#600s内所有值的总和</div><div class="line">sum(600)</div><div class="line"></div><div class="line">#随后5个值总和</div><div class="line">sum(#5)</div><div class="line"></div><div class="line">avg()</div><div class="line">count()</div><div class="line">last()</div><div class="line">min()</div><div class="line">max()</div><div class="line"></div><div class="line">#5m 可被 300s 代替</div><div class="line">#1k 代表 1024bytes</div></pre></td></tr></table></figure>
<p><strong>运算符(operators)：</strong></p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>-</td>
<td>负号(minus)</td>
</tr>
<tr>
<td>2</td>
<td>not</td>
<td>逻辑非(NOT)</td>
</tr>
<tr>
<td>3</td>
<td>*, /</td>
<td>乘，除</td>
</tr>
<tr>
<td>4</td>
<td>+, -</td>
<td>加，减</td>
</tr>
<tr>
<td>5</td>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td>-</td>
</tr>
<tr>
<td>6</td>
<td>=, &lt;&gt;</td>
<td>相等，不等于</td>
</tr>
<tr>
<td>7</td>
<td>and</td>
<td>逻辑与</td>
</tr>
<tr>
<td>8</td>
<td>or</td>
<td>逻辑或</td>
</tr>
</tbody>
</table>
<p><strong>触发器示例：</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;www.zabbix.com:system.cpu.load[all,avg1].last()&#125;&gt;5</div><div class="line"></div><div class="line">&#123;www.zabbix.com:system.cpu.load[all,avg1].last()&#125;&gt;5 or &#123;www.zabbix.com:system.cpu.load[all,avg1].min(10m)&#125;&gt;2</div><div class="line"></div><div class="line">&#123;www.zabbix.com:net.if.in[eth0,bytes].min(5m)&#125;&gt;100k</div><div class="line"></div><div class="line">&#123;<span class="variable">$url1</span>:net.tcp.service[smtp].last()&#125;=0 and &#123;<span class="variable">$url2</span>:net.tcp.service[smtp].last()&#125;=0</div><div class="line"></div><div class="line">&#123;<span class="variable">$host</span>:icmpping.count(30m,0)&#125;&gt;5</div><div class="line"></div><div class="line">&#123;<span class="variable">$host</span>:system.cpu.load[all,avg1].min(5m)&#125;&gt;2 and &#123;<span class="variable">$hsot</span>:system.cpu.load[all,avg1].time()&#125;&gt;000000 and &#123;<span class="variable">$host</span>:system.cpu.load[all,avg1].time)()&#125;&lt;060000</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p><strong>滞后(Hysteresis):</strong><br>有时候需要一个触发器状态OK和PROBLEM之间的间隔，而不是简单的阈值。</p>
<p>要做到这一点，我们首先定义一个PROBLEM事件的触发器表达式，然后为OK选择 ‘Recovery expression’，并未OK事件书如不同的表达式</p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#Problem expression</div><div class="line">&#123;server:temp.last()&#125;&gt;20</div><div class="line"></div><div class="line">#Recovery expression</div><div class="line">&#123;server:temp.last()&#125;&lt;=15</div><div class="line"></div><div class="line">#两者之间便有了几个滞后值</div></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="触发器依赖-trigger-dependency"><a href="#触发器依赖-trigger-dependency" class="headerlink" title="触发器依赖(trigger dependency)"></a>触发器依赖(trigger dependency)</h3><p>有时候，一台主机的可用性取决于另一台主机。如一台路由器后的上网设备。<br>这就是主机之间某些依赖关系可能有用的地方，依赖关系设置的通知可能会被抑制，而只发送根本问题的通知。</p>
<p>zabbix中触发器的依赖，一个触发器可能有多个依赖于它的触发器。</p>
<p>路由器和路由器后的Server同时宕机，如果有依赖关系，则zabbix不会执行服务器的触发动作。<br>值得注意的是，如果触发器所依赖的触发器被禁用，则次触发器的事件和动作将不会被抑制。</p>
<p><br></p>
<h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>使用批量更新，可一次更改一些触发器的某些属性。</p>
<p><br></p>
<h3 id="触发器严重性-trigger-severity"><a href="#触发器严重性-trigger-severity" class="headerlink" title="触发器严重性(trigger severity)"></a>触发器严重性(trigger severity)</h3><p>触发器严重性定义了触发器的重要程度:</p>
<ol>
<li>未分类(not classified), 灰色</li>
<li>信息(information), 淡蓝</li>
<li>警告(warning), 黄色</li>
<li>一般严重(average), 橙色</li>
<li>严重(High), 淡红</li>
<li>灾难(disaster), 红色</li>
</ol>
<p><br></p>
<h3 id="自定义触发器严重性-customising-trigger"><a href="#自定义触发器严重性-customising-trigger" class="headerlink" title="自定义触发器严重性(customising trigger)"></a>自定义触发器严重性(customising trigger)</h3><p>在 管理 – 一般 – 触发器严重性，里面自定义触发器严重性。</p>
<p><br></p>
<h3 id="预测触发功能-predictive-trigger-function"><a href="#预测触发功能-predictive-trigger-function" class="headerlink" title="预测触发功能(predictive trigger function)"></a>预测触发功能(predictive trigger function)</h3><p>有时候有即将到来的问题的迹象。可以发现这些迹象，以便提前采取行动，以减小影响。</p>
<p>zabbix具有基于历史数据预测受监视系统的未来行为的工具，这些工具通过预测触发功能实现。</p>
<p><br></p>
<h3 id="事件标签-event-tag"><a href="#事件标签-event-tag" class="headerlink" title="事件标签(event tag)"></a>事件标签(event tag)</h3><p>在zabbix中可以自定义事件标签，在触发器级别上定义事件标签。在事件标签定以后，相应的新事件被标记为时间标签数据。<br>在拥有自定义时间标签的情况下，可以变得更加灵活。</p>
<p>例如：</p>
<ol>
<li>识别日志文件中的问题并单独关闭他们；</li>
<li>用它来过滤通知；</li>
<li>查看前端的事件标签信息；</li>
<li>从项目值中提取的信息作为标签值；</li>
<li>在通知中更好地识别问题；</li>
<li>通过使用模板级别的标签来建华配置任务；</li>
<li>使用低级别发现的标签创建触发器。</li>
</ol>
<p><br><br><br></p>
<h2 id="事件-Events"><a href="#事件-Events" class="headerlink" title="事件(Events)"></a>事件(Events)</h2><p>zabbix可以生成一下几种类型的事件：</p>
<ol>
<li>trigger events-触发器事件；</li>
<li>discovery events-发现事件；</li>
<li>auto registration events-自动注册事件；</li>
<li>internal events-内部事件；</li>
</ol>
<p>事件以时间戳，并可以发送Email等基础动作。<br>在 监控-问题 里面查看信息信息。</p>
<p><br></p>
<h3 id="触发器事件生成-trigger-events-generation"><a href="#触发器事件生成-trigger-events-generation" class="headerlink" title="触发器事件生成(trigger events generation)"></a>触发器事件生成(trigger events generation)</h3><p>触发器状态的变化是事件最常见和最重要的来源。每次触发器的状态改变时，都会生成一个事件。<br>改时间包含了触发器状态变更的详细信息、发生时间以及信息的状态。</p>
<p>触发器会创建两种类型的事件：问题(problem)和正常(OK)</p>
<p><br></p>
<h3 id="手动关闭问题事件-manual-closing-of-problems"><a href="#手动关闭问题事件-manual-closing-of-problems" class="headerlink" title="手动关闭问题事件(manual closing of problems)"></a>手动关闭问题事件(manual closing of problems)</h3><p>当触发器状态从“问题(problem)”变成“正常(OK)”时，很难判断是通过触发器表达式的方式解决。这时就需要手动解决。</p>
<p>只有在触发器中启用 “允许手动关闭” 选项，问题事件才可以被手动关闭。</p>
<p><br></p>
<h3 id="其他事件来源-other-event-source"><a href="#其他事件来源-other-event-source" class="headerlink" title="其他事件来源(other event source)"></a>其他事件来源(other event source)</h3><p>zabbix定期扫描网络发现规则中定义的IP范围，可以为每个规则单独配置检查频率。一旦发现主机或服务，就会生成一个发现事件。</p>
<p>zabbix可以生成以下事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Service Up/Down</div><div class="line">Host Up/Down</div><div class="line">Service Discovered/Lost</div><div class="line">Host Discovered/Lost</div></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h2 id="事件关联-event-correlation"><a href="#事件关联-event-correlation" class="headerlink" title="事件关联(event correlation)"></a>事件关联(event correlation)</h2><p>通常，在zabbix中正常事件会关闭所有的问题事件，但在某些情况下需要更细致的方法。可以根据<strong>事件标签</strong>关联问题事件。<br>如，当监控日志文件时，在日志文件中想要发现某些问题，并将它们单独关闭，而不是一起关闭。</p>
<p><br><br><br></p>
<h2 id="可视化-visualisation"><a href="#可视化-visualisation" class="headerlink" title="可视化(visualisation)"></a>可视化(visualisation)</h2><h3 id="图形-graphs"><a href="#图形-graphs" class="headerlink" title="图形(graphs)"></a>图形(graphs)</h3><p>大量的监控数据被采集到zabbix中，如果能用可视化的表现形式来查看，那就直观和容易多了。</p>
<p>zabbix为用户提供了如下图形：</p>
<ol>
<li>监控项数据的内置简单图形 “simple graphs”；</li>
<li>创建更复杂的自定义图形 “customised graphs”；</li>
<li>特定图形 “ad-hosc graphs”快速访问几个监控项的数据比较。</li>
</ol>
<p><strong>简单图形(simple graphs)：</strong><br>zabbix提供的简单图形，用来可视化显示监控项采集到的数据。并不需要配置就可以查看。</p>
<p>通过 监控-最新数据-图形 来展示图形。</p>
<p><strong>自定义图形(customised graphs)：</strong><br>自定义图形，提供定制功能。这就有点厉害了。这个是手动配置的。<br>可以为单个主机、多个主机、单个模板、多个模板创建自定义图形。</p>
<p>在 配置-主机-图形-创建图形 里编辑图形属性；<br>图形编辑后可点击预览。</p>
<p><strong>特设图形(ad-hoc graphs)：</strong><br>简单图形和自定义图形都不允许快速创建多个监控项目数据的比较图形，工作量小且没有维护。</p>
<p>在 检测-最新数据-旋转监控项前复选框-显示数据图(显示堆叠数据图) 下， 里面也包含了 正常和层积 的图形风格。</p>
<p><br></p>
<h3 id="拓扑图-networking-maps"><a href="#拓扑图-networking-maps" class="headerlink" title="拓扑图(networking maps)"></a>拓扑图(networking maps)</h3><p>运维人员如果想要了解网络环境的基础设施状况，可以在zabbix中创建网络拓扑图。</p>
<p><strong>配置拓扑图(configurating network maps):</strong></p>
<p>在 监控-拓扑图 下，可以创建拓扑图。点击拓扑图中的 构造函数 选项，来打开编辑区域。<br>然后在编辑区域中添加元素和链接元素。</p>
<p><strong>链接指示器(link indicators):</strong><br>可以为网络拓扑图中的元素之间的链接分配一些触发器，当这些触发器状况为“Problem”时，可以在链接上体现出来。<br>如果多个触发器进入”Problem”状态，则严重程度最高的将决定链接的颜色和样式。</p>
<p><br></p>
<h3 id="聚合图形-screen"><a href="#聚合图形-screen" class="headerlink" title="聚合图形(screen)"></a>聚合图形(screen)</h3><p>在zabbix的聚合图形页面上，你可把各种来源的信息聚集到一起，一边在单个屏幕上快速查看。<br>在 监测-图形聚合 下，对其进行创建、配置、管理和查看。</p>
<p>基本上，聚合图形是一个表格，你选择把每个表格有多少单元格以及其中要显示的元素。<br>元素如下：</p>
<ul>
<li>简单图形；</li>
<li>简单图形原型；</li>
<li>用户自定义图形；</li>
<li>自定义图形原型；</li>
<li>拓扑图；</li>
<li>其他聚合图形；</li>
<li>纯文本信息；</li>
<li>服务器信息；</li>
<li>触发器信息；</li>
<li>主机/主机组信息；</li>
<li>系统状态；</li>
<li>数据概述；</li>
<li>时钟；</li>
<li>事件历史；</li>
<li>动作历史；</li>
<li>URL。</li>
</ul>
<p><br></p>
<h3 id="幻灯片演示-slide-shows"><a href="#幻灯片演示-slide-shows" class="headerlink" title="幻灯片演示(slide shows)"></a>幻灯片演示(slide shows)</h3><p>在幻灯片演示中，可以配置多个聚合图形以设定的间隔逐个显示。<br>在 监测-聚合图形-幻灯片演示 下。</p>
<p><br><br><br></p>
<h2 id="模板-template"><a href="#模板-template" class="headerlink" title="模板(template)"></a>模板(template)</h2><p>模板是可以方便地应用于多个主机的一组实体。</p>
<p><strong>配置模板(configuring a template)：</strong><br>配置模板需要首先通过定义一些参数来创建模板，然后添加实例。<br>在 配置-模板-创建模板</p>
<p><strong>链接模板(linking)：</strong><br>链接是将模板应用于主机的过程，之后主机将拥有模板的所有实体。</p>
<p><strong>嵌套(nesting)：</strong><br>嵌套是一种包含一个或多个其它模板的模板方式。<br>可以在一个嵌套模板中奖一些模板链接在一起。</p>
<p>嵌套的好处在于，您只需要讲一个模板链接到主机，并且主机会自动继承链接的模板的所有实体。</p>
<p><br><br><br></p>
<h2 id="事件通知-notifications-upon-events"><a href="#事件通知-notifications-upon-events" class="headerlink" title="事件通知(notifications upon events)"></a>事件通知(notifications upon events)</h2><p>当配置了一些项目和触发器，并且由于触发器改变状态，现在正在发生一些事件，之后就要考虑 action。<br>发送通知是zabbix提供的主要操作之一。</p>
<p>为了能够发送和接收通知，必须：</p>
<ol>
<li>定义一些media；</li>
<li>配置action，向指定的media发送消息。</li>
</ol>
<p>action由condition和operation组成。当条件满足是，执行操作。<br>操作主要是 <strong>发送消息</strong>和<strong>执行远程命令</strong>。</p>
<p><br></p>
<h3 id="media类型"><a href="#media类型" class="headerlink" title="media类型"></a>media类型</h3><p>媒体是zabbix中发送通知和警报的传送通道。</p>
<p><strong>E-mail:</strong><br>在 管理-媒体类型 下，配置Email。</p>
<p><strong>SMS：</strong><br>zabbix支持使用连接到zabbix-server的串行端口的串行GSM调制解调器发送SMS消息。</p>
<p>确保：</p>
<ul>
<li>串行设备的速度(在Linux下通常为/dev/ttyS0) 与 GSM调制解调器的速度相匹配。zabbix没有设置串行链路的速度，它使用默认设置。</li>
<li>zabbix用户对串行设备有读写访问权限。</li>
<li>GSM调制解调器输入PIN码，并在电源复位后保留PIN码。或者在SIM卡上禁用PIN。</li>
</ul>
<p>管理-媒体类型下<br>要为用户分配电话号码：管理-用户-报警媒介，添加报警媒介(如电话号码等)</p>
<p><strong>Jabber：</strong><br>zabbix支持发送jabber消息。</p>
<p><strong>Ez Texting：</strong><br>可以使用 zabbix技术合作伙伴 Ez Texting发送信息。</p>
<p><strong>脚本：</strong><br>警报脚本在zabbix服务器上执行，这些脚本位于服务器配置文件中定义的目录中(AlertScriptsPath)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">cat /etc/zabbix/zabbix_server.conf</div><div class="line"></div><div class="line">AlertScriptsPath=/usr/lib/zabbix/alertscripts</div><div class="line"></div><div class="line"></div><div class="line">#创建报警脚本</div><div class="line">vim /usr/lib/zabbix/alertscripts/zabbix_test.sh</div><div class="line"></div><div class="line">#!/bin/bash</div><div class="line">to=$1</div><div class="line">subject=$2</div><div class="line">body=$3</div><div class="line"></div><div class="line">cat &lt;&lt;EOF | mail -s &quot;$subject&quot; &quot;to&quot;</div><div class="line">$body</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>然后我们在创建脚本媒体的时候，写入相关参数。</p>
<p><br></p>
<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>可以根据所有支持的类型的时间定义操作：</p>
<ul>
<li>触发事件：当trigger的状态从OK转到Problem或回转时；</li>
<li>发现事件；</li>
<li>自动注册事件；</li>
<li>内部事件；</li>
</ul>
<p>配置-动作-创建动作</p>
<p><strong>条件(condition):</strong><br>只有在事件与定义的条件匹配的情况下才执行操作。</p>
<p>注意运算类型：似与非似</p>
<p><strong>操作(operation)：</strong><br>操作：发送信息，执行远程命令。</p>
<p>1.发送消息；<br>2.远程命令(不支持在zabbix-agent上执行远程命令，需要在zabbix-server到代理的命令才能直接连接。远程命令限制255字符，可以将过个命令放置于新行上来执行过个命令。及时目标主机处于维护状态，也会执行远程命令)；</p>
<p>配置-动作-操作，在操作细节中修改操作类型为远程命令。<br>支持自定义脚本、SSH、Telnet等方式。</p>
<p><strong>在信息中使用宏(using macros in messages)：</strong><br>在消息主题和消息文本中，可使用宏来更有效的问题报告。</p>
<p><strong>恢复操作(recovery operation):</strong><br>恢复操作允许在问题解决时通知我们。<br>恢复操作支持消息和远程命令。</p>
<p><br></p>
<h3 id="宏-macros"><a href="#宏-macros" class="headerlink" title="宏(macros)"></a>宏(macros)</h3><p>zabbix支持许多在多种情况下使用的宏。宏是一个变量，由如下特殊语法标识。</p>
<p><code>{MACRO}</code></p>
<p>根据在上下文汇总，宏解析为一个特殊的值。有效地使用宏可以节省时间，病史zabbix更加高效。</p>
<p>宏可以在监控项键值参数中使用。宏只能用在监控项键值参数的一部分中。<br>如<code>item.key[server_{HOST.HOST}_local]</code> 。</p>
<p><strong>宏函数(macro function)：</strong><br>宏函数能提供自定义宏值的功能。</p>
<p>宏函数语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;&lt;macro&gt;.&lt;func&gt;(&lt;params&gt;)&#125;</div><div class="line"></div><div class="line">#&lt;macro&gt;, 要定义的宏</div><div class="line">#&lt;func&gt;, 要应用的函数</div><div class="line">#&lt;params&gt;, 以逗号分隔的函数参数列表</div><div class="line"></div><div class="line">#栗子</div><div class="line">&#123;&#123;ITEM.VALUE&#125;.regsub&#123;pattern, output&#125;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>用户宏(user macro)：</strong><br>除了支持开箱即用的宏之外，zabbix还支持更灵活的用户宏。</p>
<p>用户宏可在全局、模板和主机级别进行定义。有一个特殊语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;$MACRO&#125;</div></pre></td></tr></table></figure></p>
<p>用户宏可用于：</p>
<ul>
<li>监控项名称；</li>
<li>监控项键值参数；</li>
<li>触发器名称和描述；</li>
<li>触发器表达式参数和常量；</li>
<li>许多其他位置。</li>
</ul>
<p><strong>自动发现宏：</strong><br>有一种自动发现(LLD)函数中使用的宏类型，可用于创建监控项、触发器和图形原型。然后，当发现真实的文件系统、网络接口等，这些宏将替换为真实的值，并且以这些值来创建真实的监控项、触发器和图形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;#MACRO&#125;</div></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="用户和用户组-user-and-group"><a href="#用户和用户组-user-and-group" class="headerlink" title="用户和用户组(user and group)"></a>用户和用户组(user and group)</h3><p>zabbix中所有用户都通过web前端去访问zabbix应用程序。并为每一个用户分配唯一的登录名和密码，被加密储存于zabbix数据库中。</p>
<p><strong>配置用户(configuring user)</strong><br>管理-用户，创建和管理用户。</p>
<p><strong>权限(permission)</strong><br>可定义相应的用户类型，如用户，管理员和超级管理员。</p>
<p><strong>用户组(groups)</strong><br>管理-用户组，创建和配置用户组。</p>
<p><br><br><br></p>
<hr>
<h1 id="服务监控-service-monitoring"><a href="#服务监控-service-monitoring" class="headerlink" title="服务监控(service monitoring)"></a>服务监控(service monitoring)</h1><p>服务监控，旨在帮助那些想要高级业务监控的人。<br>在很多情况下，我们关注的不是底层细节，而是提供的可用性服务。</p>
<p>服务是分层表示监控数据。</p>
<blockquote>
<p>IT</p>
<blockquote>
<p>Workstations</p>
<blockquote>
<p>workstation1<br>workstation2</p>
</blockquote>
<p>Services</p>
</blockquote>
</blockquote>
<p>配置-服务，最高节点的服务是’root’。<br>你可以通过添加低级服务节点和各个节点服务创建下层层次结构。</p>
<p><br><br><br></p>
<hr>
<h1 id="Web监控-web-monitoring"><a href="#Web监控-web-monitoring" class="headerlink" title="Web监控(web monitoring)"></a>Web监控(web monitoring)</h1><p>配置-主机-web监测，创建或修改web监测信息。<br>可使用zabbix检查几个网站可用性方面。(zabbix中包含libcurl库才行)</p>
<p>要使用web监控，需要定义web场景。包括一个或多个HTTP请求或步骤。Zabbix-Server根据预定义的命令周期性的执行这些步骤。</p>
<p>所有web场景会收集下列数据：</p>
<ul>
<li>整个场景中所有步骤的平均下载速度；</li>
<li>失败的步骤数量；</li>
<li>最后一次错误信息</li>
</ul>
<p>web场景的所有步骤，都会收集下列数据：</p>
<ul>
<li>平均下载速度；</li>
<li>响应时间</li>
<li>HTTP状态吗</li>
</ul>
<p><br></p>
<h2 id="Web监控项-web-monitoring-items"><a href="#Web监控项-web-monitoring-items" class="headerlink" title="Web监控项(web monitoring items)"></a>Web监控项(web monitoring items)</h2><p>在创建web场景时，会自动添加一些新监控项进行监控。</p>
<p>创建场景后，zabbix会自动添加以下监控项进行监控，将它们链接到所选的应用程序。</p>
<ul>
<li>场景<scenario>的下载速度；</scenario></li>
<li>场景<scenario>的失败步骤；</scenario></li>
<li>场景<scenario>的最后一个错误消息；</scenario></li>
</ul>
<p><br></p>
<p><strong>举个栗子：</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">##创建Web监测</span></div><div class="line"><span class="comment">#配置-主机-Web监测-创建web监测</span></div><div class="line"></div><div class="line">URL：web.zabbix.me/monitor.php</div><div class="line">要求的状态码：200</div><div class="line">超时：20s</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##创建web监测触发器</span></div><div class="line"><span class="comment">#配置-主机-触发器-创建触发器</span></div><div class="line"></div><div class="line">严重性：一般严重</div><div class="line"><span class="comment">#触发条件：状态码!=200</span></div><div class="line">表达式：N&lt;&gt;200</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##创建触发报警对应的动作</span></div><div class="line"><span class="comment">#配置-动作-创建动作</span></div><div class="line"></div><div class="line"><span class="comment">#触发条件</span></div><div class="line">触发器示警度=一般严重 or 触发器=web.zabbix.me</div><div class="line"></div><div class="line"><span class="comment">#操作：发送Email</span></div><div class="line">发送给zabbix administrator用户群组</div><div class="line">仅送到Email</div><div class="line">默认信息/自定义信息</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##在媒体类型中定义Email相关信息</span></div><div class="line"><span class="comment">#管理-报警媒体类型-Email</span></div><div class="line"></div><div class="line">SMTP服务器：smtp.xxx.com</div><div class="line">smtp端口：465</div><div class="line">SMTP电邮：发件人Email</div><div class="line">安全链接：SSL/TLS</div><div class="line">认证：Usernameand passwd</div><div class="line">用户名：xxx</div><div class="line">密码： xxx</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##接下来就可以测试接收报警Email了</span></div></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<hr>
<h1 id="虚拟机监控-VM-monitoring"><a href="#虚拟机监控-VM-monitoring" class="headerlink" title="虚拟机监控(VM monitoring)"></a>虚拟机监控(VM monitoring)</h1><p>zabbix支持对VMware的监控，使用low-levle-discovery(LLD)自动发现VMware hypervisors和虚拟机，并根据事先定义的主机原型，为这些虚拟机建立主机，添加监控。</p>
<p>zabbix中提供了几个模板，可以直接用来解控VMware vCenter 或 ESX hypervisor。</p>
<p><br><br>虚拟机监控分为两个步骤：</p>
<ul>
<li>首先，zabbix是通过VMware collector进程来监控虚拟机。这些进程通过SOAP协议从VMware服务获取必要的信息，对其进行预处理并储存到zabbix-server共享内存中；</li>
<li>然后，zabbix-pollers通过zabbix简单检查VMware keys来检索这些数据。</li>
</ul>
<p>要使虚拟机监控正常工作，需要libxml2库和libcurl库的支持。</p>
<blockquote>
<p>配置-自动发现-创建自动发现<br>配置-主机-自动发现</p>
</blockquote>
<p><br><br><br></p>
<hr>
<h1 id="维护-maintenance"><a href="#维护-maintenance" class="headerlink" title="维护(maintenance)"></a>维护(maintenance)</h1><p>可在zabbix中为主机和主机组定义维护周期。<br>有两种维护类型：“继续对目标进行监控数据的收集” 和 “停止对目标进行监控数据的收集”</p>
<p>要在维护期间正常接收问题通知，必须在动作配置中的选项中取消选择暂停操作。<br>为了确保定期维护按照预期的时间进行，需要对zabbix的所有部分使用通用时区。</p>
<blockquote>
<p>配置-维护-创建维护期</p>
</blockquote>
<p>维护期的主机显示的是橙色背景！</p>
<p><br><br><br></p>
<hr>
<h1 id="事件确认-event-acknowledgment"><a href="#事件确认-event-acknowledgment" class="headerlink" title="事件确认(event acknowledgment)"></a>事件确认(event acknowledgment)</h1><p>zabbix中的问题事件可以由用户确认。</p>
<p>如果用户获得了有关问题时间的通知，可以访问zabbix前端，从时间导航到确认屏幕并确认问题。<br>当他们确认时，可输入评论或其他一些相关描述。<br>这样其他系统用户同样的问题，他们便会立即看到是否已被解决和目前的评论。</p>
<p>以这种方式，可以更协调的进行解决多个系统用户的问题的工作流程。</p>
<p>要确认事件，用户必须至少要有对相应触发器的读取权限。</p>
<p><br><br>在Dashboard下，在出现的问题里，点击确认，进入确认事件。<br>也可在监控-问题下查看问题详细信息。</p>
<p><br><br><br></p>
<hr>
<h1 id="配置导出-导入-Configuration-export-import"><a href="#配置导出-导入-Configuration-export-import" class="headerlink" title="配置导出/导入(Configuration export/import)"></a>配置导出/导入(Configuration export/import)</h1><p>zabbix导入/导出功能，使得可以在一个zabbix系统与另一个zabbix系统之间交换各种配置实体。<br>类似于数据库的导入导出。即也可以对zabbix做备份。</p>
<p>可导出/导入的对象有：主机组； 模板； 主机； 拓扑； 图片； 聚合图形； 值映射。</p>
<p>数据也可导出：</p>
<ul>
<li>XML - 在前端</li>
<li>XML or JSON - 在zabbix API</li>
</ul>
<p>导出的详细信息：</p>
<ul>
<li>所有支持的元素都导出到一个文件中；</li>
<li>不导出从连链接模板继承的主机和模板实体；</li>
<li>由低级别发现创建的实体依赖于他们的任何实体不会导出。</li>
</ul>
<p>导入详细信息：</p>
<ul>
<li>第一次遇到错误停止导入；</li>
<li>导入支持XML和JSON文件；</li>
<li>使用“删除缺失”选项导入主机/模板时，导入的XML文件中不存在主机/模板宏也将被删除。</li>
</ul>
<p><br><br><br></p>
<hr>
<h1 id="将Zabbix展现在Nginx上"><a href="#将Zabbix展现在Nginx上" class="headerlink" title="将Zabbix展现在Nginx上"></a>将Zabbix展现在Nginx上</h1><p>毕竟现在Nginx用的多，那就把Apache换成Nginx吧！</p>
<p>Nginx仓库:<a href="http://nginx.org/packages/" target="_blank" rel="external">http://nginx.org/packages/</a></p>
<p>自己安装Nginx:</p>
<ol>
<li>下载<code>nginx-release-xx.rmp</code>仓库源来安装；</li>
<li>手动创建<code>/etc/yum.repo.d/nginx.repo</code>；</li>
<li>直接下载<code>ngix.rpm</code>来安装；</li>
<li>直接下载源码来安装。</li>
</ol>
<p>相较于Apache，Nginx也只是配置个server就行了。优化什么的自己弄。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">vim /etc/nginx/conf.d/zabbix.conf</div><div class="line"></div><div class="line">server &#123;</div><div class="line">	listen 80;</div><div class="line">    server_name zabbix.me;</div><div class="line">    root /usr/share/zabbix;</div><div class="line"></div><div class="line">    access_log  /var/<span class="built_in">log</span>/nginx/zabbix.access.log  main;</div><div class="line"></div><div class="line">	allow 127.0.0.1;</div><div class="line">	allow Your-IP;</div><div class="line">    deny all;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">    	<span class="keyword">if</span> (!-f <span class="variable">$request_filename</span>) &#123;</div><div class="line">        	rewrite ^([^\?]+)$ /index.php?1=<span class="variable">$1</span> last;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location ~ \.php$ &#123;</div><div class="line">    	root /usr/share/zabbix;</div><div class="line">        fastcgi_pass 127.0.0.1:9000;</div><div class="line">        fastcgi_index index.php;</div><div class="line">        fastcgi_param SCRIPT_FILENAME <span class="variable">$document_root</span>/<span class="variable">$fastcgi_script_name</span>;</div><div class="line">        include fastcgi_params;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">nginx -t</div><div class="line">systemctl start nginx</div></pre></td></tr></table></figure></p>
<p>下载就可以正常访问<code>zabbix-web</code>端了!</p>
<p><br><br><br></p>
<hr>
<h1 id="Zabbix监控"><a href="#Zabbix监控" class="headerlink" title="Zabbix监控"></a>Zabbix监控</h1><p>Zabbix自带的templates基本涵盖了大部分监控信息。</p>
<p>大部分操作系统：</p>
<ul>
<li>OS Linux;</li>
<li>OS AIx;</li>
<li>OS FreeBSD;</li>
<li>OS Solaris;</li>
<li>OS Windows;</li>
<li>…</li>
</ul>
<p>大部分服务：</p>
<ul>
<li>CPU;</li>
<li>Filesystems;</li>
<li>HTTP/HTTPS service;</li>
<li>Memory;</li>
<li>Network interfaces;</li>
<li>Processes;</li>
<li>Secutity;</li>
<li>Zabbix server/agent/Proxy;</li>
<li>SMTP,POP,SSH,NTP, service;</li>
<li>ICMP Ping;</li>
<li>SNMP;</li>
<li>…</li>
</ul>
<p>虚拟机：</p>
<ul>
<li>VM VMware;</li>
<li>VM WMware Hypervisor;</li>
<li>…</li>
</ul>
<p>网络设备：</p>
<ul>
<li>Cisco;</li>
<li>Huawei;</li>
<li>TPLink;</li>
<li>HP;</li>
<li>…</li>
</ul>
<p><br><br>除了Zabbix自带的templates，你还可以下载templates并导入zabbix-server。</p>
<p>例如PHP-FPM, MongoDB, Apache, Nginx, Redis等额外软件的监控就需要下载额外templates。</p>
<p><br><br><br></p>
<h2 id="监控MySQL"><a href="#监控MySQL" class="headerlink" title="监控MySQL"></a>监控MySQL</h2><h3 id="使用Zabbix自带模板监控MySQL"><a href="#使用Zabbix自带模板监控MySQL" class="headerlink" title="使用Zabbix自带模板监控MySQL"></a>使用Zabbix自带模板监控MySQL</h3><p>Zabbix默认带有MySQL的监控和模板，所以无需再去下载。不过需要配置用户，密码，主机，端口等信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">vim /etc/zabbix/zabbix-agentd.d/userparameter_mysql.conf</div><div class="line"></div><div class="line"><span class="comment">#For all the following commands HOME should be set to the directory that has .my.cnf file with password information.</span></div><div class="line"><span class="comment">#这句话叫我们新建一个带有mysql密码信息的.my.cnf文件</span></div><div class="line"><span class="comment">#并把此配置文件里面的HOME改为.my.cnf所的在目录</span></div><div class="line"><span class="comment">#.my.cnf文件里面的用户要对MySQL数据库有权限才行，没有权限请记得加</span></div><div class="line"></div><div class="line">[mysql]</div><div class="line">host=localhost</div><div class="line">user=zabbix</div><div class="line">password=zabiix</div><div class="line">socket=/var/lib/mysql/mysql.sock</div><div class="line"></div><div class="line">[mysqladmin]</div><div class="line">host=localhost</div><div class="line">user=root</div><div class="line">password=password</div><div class="line">socket=/var/lib/mysql/mysql.sock</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#测试</span></div><div class="line">zabbix_get -s 127.0.0.1 -k mysql.ping</div><div class="line"><span class="comment">#1</span></div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="使用Percona插件监控MySQL"><a href="#使用Percona插件监控MySQL" class="headerlink" title="使用Percona插件监控MySQL"></a>使用Percona插件监控MySQL</h3><p>Zabbix默认带有MySQL的监控和模板，所以无需再去下载。不过需要配置用户，密码，主机，端口等信息。<br>但是Zabbix自带的MySQL监控太简陋了。<br>所以使用Percona提供的模板及监控。</p>
<p><br></p>
<p>Percona Monitoring Plugins-URL:  <a href="https://www.percona.com/downloads/percona-monitoring-plugins/LATEST/" target="_blank" rel="external">https://www.percona.com/downloads/percona-monitoring-plugins/LATEST/</a><br>Percona Monitoring Plugins for Zabbix- Instructions:  <a href="https://www.percona.com/doc/percona-monitoring-plugins/LATEST/zabbix/index.html" target="_blank" rel="external">https://www.percona.com/doc/percona-monitoring-plugins/LATEST/zabbix/index.html</a></p>
<p>此插件地址需要我们选择Percona-Version和Software平台。</p>
<p><img src="/images/Zabbix/mysql01.png" alt="Percona Monitoring Plugins"></p>
<p>选择平台后，我们只需安装zabbix的rpm包就好：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#安装rpm包</span></div><div class="line">yum install -y https://www.percona.com/downloads/percona-monitoring-plugins/percona-monitoring-plugins-1.1.7/binary/redhat/7/x86_64/percona-zabbix-templates-1.1.7-2.noarch.rpm</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#安装软件</span></div><div class="line"><span class="comment">#注意php版本问题</span></div><div class="line">yum install -y percona-zabbix-templates</div><div class="line"></div><div class="line">ls /var/lib/zabbix/percona</div><div class="line"><span class="comment">#scripts目录有.sh脚本文件</span></div><div class="line"><span class="comment">#templates目录有配置文件和模板文件</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#复制配置文件</span></div><div class="line">cp /var/lib/zabbix/percona/templates/userparameter_percona_mysql.conf /etc/zabbix/zabbix_agentd.d/</div><div class="line"><span class="comment">#我看了一下，这个配置文件和zabbix自带的MySQL配置文件一样</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#添加MySQL的相关信息</span></div><div class="line">vim /var/lib/zabbix/percona/scripts/ss_get_mysql_stats.php</div><div class="line"></div><div class="line"><span class="variable">$mysql_user</span> = <span class="string">'root'</span>;</div><div class="line"><span class="variable">$mysql_pass</span> = <span class="string">'password'</span>;</div><div class="line"><span class="variable">$mysql_port</span> = 3306;</div><div class="line"><span class="variable">$mysql_socket</span> = <span class="string">'/var/lib/mysql/mysql.sock'</span>;</div><div class="line"><span class="variable">$mysql_flags</span> = 0;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#测试脚本</span></div><div class="line">/var/lib/zabbix/percona/scripts/get_mysql_stats_wrapper.sh gg</div><div class="line"><span class="comment">#10</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#创建.my.cnf文件</span></div><div class="line">vim /etc/zabbix/zabbix_agentd.d/.my.cnf</div><div class="line"></div><div class="line">[mysql]</div><div class="line">host=localhost</div><div class="line">user=root</div><div class="line">password=password</div><div class="line">socket=/var/lib/mysql/mysql.sock</div><div class="line"></div><div class="line">[mysqladmin]</div><div class="line">host=localhost</div><div class="line">user=root</div><div class="line">password=password</div><div class="line">socket=/var/lib/mysql/mysql.sock</div><div class="line"></div><div class="line">[client]</div><div class="line">host=localhost</div><div class="line">user=root</div><div class="line">password=password</div><div class="line">socker=/var/lib/mysql/mysql.sock</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#重启服务</span></div><div class="line">systemctl restart zabbix-agent</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#测试</span></div><div class="line">sudo -u zabbix -H /var/lib/zabbix/percona/scripts/get_mysql_stats_wrapper.sh running-slave</div><div class="line"><span class="comment">#0/1</span></div></pre></td></tr></table></figure>
<p>导入模板，模板文件位于：<code>/var/lib/zabbix/percona/templates/zabbix_agent_template_percona_mysql_server_ht_2.0.9-sver1.1.7.xml</code></p>
<p>但我直接导入模板时报错——标签无效 “/zabbix_export/date”: “YYYY-MM-DDThh:mm:ssZ” 预计。<br>此模板需要先导入Zabbix2.4后再导出，然后再导入到Zabbix3.4。太麻烦。<br><img src="/images/Zabbix/mysql02.png" alt="导入percona模板"></p>
<p>所以需要下载修改过的模板： <a href="http://jaminzhang.github.io/soft-conf/Zabbix/zbx_percona_mysql_template.xml" target="_blank" rel="external">http://jaminzhang.github.io/soft-conf/Zabbix/zbx_percona_mysql_template.xml</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://jaminzhang.github.io/soft-conf/Zabbix/zbx_percona_mysql_template.xml</div></pre></td></tr></table></figure>
<p>下载之后导入模板，然后链接主机。<br>链接之后可以部分监控可能显示不支持的。</p>
<p>如：Received value [rm: 无法删除”/tmp/localhost-mysql_cacti_stats.txt”: 不允许的操作0] is not suitable for value type [Numeric (float)]<br>没有权限。<br><img src="/images/Zabbix/mysql03.png" alt=""></p>
<p>解决办法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /tmp</div><div class="line">chown -R zabbix:zabbix localhost-mysql_cacti_stats.txt</div><div class="line"></div><div class="line">systemcet restart zabbix-agent</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="监控MongoDB"><a href="#监控MongoDB" class="headerlink" title="监控MongoDB"></a>监控MongoDB</h2><p><strong>感谢大神：</strong></p>
<ul>
<li>MongoDB-templates: <a href="https://share.zabbix.com/databases/mongodb/mongodb-for-zabbix-3-2" target="_blank" rel="external">https://share.zabbix.com/databases/mongodb/mongodb-for-zabbix-3-2</a> ;</li>
<li>GitHub: <a href="https://github.com/oscm/zabbix/tree/master/mongodb" target="_blank" rel="external">https://github.com/oscm/zabbix/tree/master/mongodb</a></li>
<li>此github-repo中还包含了<code>Oracle</code>, <code>php-fpm</code>, <code>postfix</code>, <code>redis</code>, <code>Nginx</code>。可参看README.md来配置zabbix对它们的监控。</li>
</ul>
<p><br></p>
<p><img src="/images/Zabbix/zabbix_master.png" alt="./master"></p>
<p><br></p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p><strong>1. 在zabbix-agent安装<code>jq</code></strong><br>jq - Command-line JSON processor;</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y jq</div></pre></td></tr></table></figure>
<p><br><br><strong>2. 在zabbix-agent的MongoDB中创建用于监控的账号</strong><br>创建用于读取MongoDB相关信息的账户及其权限。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mongo</div><div class="line"></div><div class="line">&gt;use admin</div><div class="line"></div><div class="line">&gt;db.createUser(</div><div class="line">  &#123;</div><div class="line">	user:<span class="string">'zabbix'</span>,</div><div class="line">	<span class="built_in">pwd</span>:<span class="string">'zabbix'</span>,</div><div class="line">	roles:[&#123;</div><div class="line">		role:<span class="string">'clusterMonitor'</span>,</div><div class="line">		db:<span class="string">'admin'</span>&#125;]</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p><br><br><strong>3. 在agent下载github仓库的MongoDB模板等文件</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">wget https://codeload.github.com/oscm/zabbix/zip/master -O master.zip</div><div class="line"><span class="comment">#这里面不仅仅有mongodb，还有redis,php等。</span></div><div class="line"><span class="comment">#我们只需要进入mongodb目录就好</span></div><div class="line"></div><div class="line">unzip master.zip</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">cd</span> ./zabbix-master/mongodb</div><div class="line">ls</div><div class="line"></div><div class="line"><span class="comment">#mongodb.sh , 执行脚本</span></div><div class="line"><span class="comment">#userparameter_mongodb.conf ，配置脚本</span></div><div class="line"><span class="comment">#zbx_export_templates.xml，zabbix模板文件</span></div></pre></td></tr></table></figure>
<p><img src="/images/Zabbix/zabbix_mongodb1.png" alt="./master/mongodb"></p>
<p><br><br><strong>4. 移动并配置mongodb.sh</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">cp ./mongodb.sh /etc/zabbix</div><div class="line"></div><div class="line">chmod a+x /etc/zabbix/mongodb.sh</div><div class="line"></div><div class="line"></div><div class="line">vi mongodb.sh</div><div class="line"></div><div class="line"><span class="comment">#如果HOST,PORT不是默认，请修改</span></div><div class="line">DB_HOST=127.0.0.1</div><div class="line">DB_PORT=27017</div><div class="line">DB_USERNAME=zabbix</div><div class="line">DB_PASSWORD=zabbix</div></pre></td></tr></table></figure>
<p><img src="/images/Zabbix/zabbix_mongodb2.png" alt="mongodb.sh"></p>
<p><br><br><strong>5. 移动并修改userparameter_mongodb.conf</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cp ./zabbix-master/userparameter_mongodb.conf /etc/zabbix/zabbix_agentd.d</div><div class="line"></div><div class="line">vi ./userparameter_mongodb.conf</div><div class="line"></div><div class="line">UserParameter=mongodb.status[*],/etc/zabbix/mongodb.sh <span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span> <span class="variable">$4</span> <span class="variable">$5</span></div><div class="line"><span class="comment">#修改为mongdb.sh真实位置</span></div><div class="line"><span class="comment">#这个是用户自定义的参数，可以之间写入到zabbix_agent.conf里面</span></div></pre></td></tr></table></figure>
<p><img src="/images/Zabbix/zabbix_mongodb3.png" alt="userparameter_mongodb.conf"></p>
<p><br><br><strong>6. 重启zabbix-agent</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart zabbix-agent</div></pre></td></tr></table></figure>
<p><br><br><strong>7. 在zabbix-web导入mongodb模板</strong></p>
<ul>
<li>配置-模板-导入模板；</li>
<li>选择<code>./master/mongodb/zbx_export_templates.xml</code>模板文件，并导入；</li>
<li>接下来便可以在 templates中看到”Template App MongoDB”这个模板；</li>
<li>可将此模板链接到某个主机上监控，并到最新数据里查看相关MongoDB信息；</li>
<li>如果相对此模板就行修改，可编辑zbx_export_templates.xml文件。</li>
</ul>
<p><br></p>
<p><img src="/images/Zabbix/zabbix_web_import_mongodb1.png" alt="导入mongodb模板"><br><img src="/images/Zabbix/zabbix_web_import_mongodb2.png" alt="选择导入文件"><br><img src="/images/Zabbix/zabbix_web_import_mongodb3.png" alt="查看MongoDB模板"><br><img src="/images/Zabbix/zabbix_web_import_mongodb4.png" alt="在主机中关联MongoDB模板"><br><img src="/images/Zabbix/zabbix_web_import_mongodb5.png" alt="查看最新MongoDb数据"></p>
<p><br></p>
<h3 id="监控一台主机上的额外mongod实例"><a href="#监控一台主机上的额外mongod实例" class="headerlink" title="监控一台主机上的额外mongod实例"></a>监控一台主机上的额外mongod实例</h3><p>由于可能一台主机上运行的mongod实例不止一个，所以我们需要修改一下前面下载的配置文件，用以监控其它端口的mongod实例。</p>
<ul>
<li>此处假设默认的mongod实例运行在27017端口上</li>
<li>另外还有一个mongod实例运行在27018端口上</li>
<li>此处假设我们已经完成了前面对27017mongodb的监控了</li>
</ul>
<p>操作：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /etc/zabbix</div><div class="line">cp mongodb.sh mongodb_27018.sh</div><div class="line"></div><div class="line">vim ./mongodb_27018.sh</div><div class="line"><span class="comment">#配置监控的mongodb账号和端口</span></div><div class="line"></div><div class="line">DB_HOST=127.0.0.1</div><div class="line">DB_PORT=27018</div><div class="line">DB_USERNAME=zabbix</div><div class="line">DB_PASSWORD=zabbix</div><div class="line"></div><div class="line"><span class="comment">#现在就有了提取27017/27018两个mongodb实例的脚本</span></div><div class="line"><span class="comment">#mongodb.sh</span></div><div class="line"><span class="comment">#mongodb_27018.sh</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">cd</span> ./zabbxi-agentd.d</div><div class="line"></div><div class="line">vim userparameter_mongodb.conf</div><div class="line"><span class="comment">#在默认的27017下面添加一行提取mongodb_27018信息的脚本</span></div><div class="line"></div><div class="line">UserParameter=mongodb.status[*],/etc/zabbix/mongodb.sh <span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span> <span class="variable">$4</span> <span class="variable">$5</span></div><div class="line">UserParameter=mongodb_27018.status[*],/etc/zabbix/mongodb_27018.sh <span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span> <span class="variable">$4</span> <span class="variable">$5</span></div><div class="line"></div><div class="line"><span class="comment">#现在zabbix-server端就可以同时获取27017/27018两个mongodb实例的信息</span></div><div class="line"><span class="comment">#但是Web界面还不能直接显示出来，因为27018的键值和默认不相同</span></div><div class="line"><span class="comment">#没错，就是上面我们修改的 mongodb_27018.status[*]</span></div></pre></td></tr></table></figure>
<p><br></p>
<p><img src="/images/Zabbix/mongodb_27018.png" alt="mongodb_27018.sh"></p>
<p><img src="/images/Zabbix/mongodb_27018_02.png" alt="mongodb_27018.sh"></p>
<p><br></p>
<p><strong>接下来要在Zabbix-Web端配置监控项用以提取信息</strong></p>
<p>我们先找到一个默认的MongoDB自带的配置模板，如<code>MongoDB Connections current</code>，点进去查看它的键值对为<code>mongodb.status[connections,current]</code></p>
<p>因此我们只需要修改为我们配置文件里面的<code>mongodb_27018.status[*]</code>就可以了。</p>
<p><img src="/images/Zabbix/mongodb_27018_03.png" alt="mongodb_27018.sh"></p>
<p><img src="/images/Zabbix/mongodb_27018_04.png" alt="mongodb_27018.sh"></p>
<p><br></p>
<p>其余个监控项以此类推，我觉得其他服务也应该可以如此。</p>
<p><strong>你也可以对此建立一个单独的模板，如MongoDB_27108 templates。在此监控模板下创建上面的监控项。这样就可以对所有主机生效了。也可以批量化操作，更方便一些。</strong></p>
<p>下面是我的参考<strong>Template App MongoDB</strong>模板建立的<strong>Template App MongoDB_27018</strong></p>
<p><img src="/images/Zabbix/mongodb_27018_05.png" alt="mongodb_27018.sh"></p>
<p><img src="/images/Zabbix/mongodb_27018_06.png" alt="mongodb_27018.sh"></p>
<p><br><br><br></p>
<h2 id="监控PHP-FPM"><a href="#监控PHP-FPM" class="headerlink" title="监控PHP-FPM"></a>监控PHP-FPM</h2><p>同样使用上面大神的模板。</p>
<p>步骤和监控MongoDB类似：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#进入下载的文件目录</span></div><div class="line"><span class="built_in">cd</span> ./zabbix-master/php-fpm</div><div class="line">cp ./php-fpm.xml.sh /etc/zabbix</div><div class="line">chmod a+x /etc/zabbix/php-fpm.xml.sh</div><div class="line">vim /etc/zabbix/php-fpm.xml.sh</div><div class="line"></div><div class="line"><span class="comment">#如果这三个参数修改了，请修改</span></div><div class="line"><span class="comment">#因为是使用culr，所以请允许此IP能够访问此页面</span></div><div class="line"><span class="comment">#另外还要Nginx允许Server-IP访问哦，不然无法读取数据</span></div><div class="line"><span class="comment">#我测试的时候用IP无法获取数据，所以用的域名</span></div><div class="line"><span class="comment">#如果没做域名解析，请加本地hosts</span></div><div class="line"><span class="comment">#php-fpm_status使用我修改的</span></div><div class="line"></div><div class="line">HOST=<span class="string">"localhost"</span></div><div class="line">PORT=<span class="string">"80"</span></div><div class="line"><span class="comment">#status="status"</span></div><div class="line">status=<span class="string">"php-fpm_status"</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">cp ./userparameter_php-fpm.conf /etc/zabbix/zabbix_agent.d/</div><div class="line"><span class="comment">#当然也可以把这个用户自定义参数写入zabbix_agent.conf</span></div><div class="line"><span class="comment">#修改自定义参数里面的文件位置</span></div><div class="line">vim /etc/zabbix/zabbix_agent.d/userparameter_php-fpm.conf</div><div class="line"></div><div class="line">UserParameter=php-fpm.status[*],/etc/zabbix/php-fpm.xml.sh <span class="variable">$1</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#php-fpm，nginx的状态必须用Nginx展现，Zabbix-Server是使用curl提取状态页面的信息</span></div><div class="line">vim /etc/nginx/conf.d/zabbix.conf</div><div class="line"></div><div class="line">server &#123;</div><div class="line">	listen 80;</div><div class="line">    server_name zabbix.me localhost;</div><div class="line"><span class="comment">#如果localhost与其他配置文件冲突，那就用IP</span></div><div class="line"><span class="comment">#server_name zabbix.me 127.0.0.1 Private-IP Public-IP;</span></div><div class="line">    root /usr/share/zabbix;</div><div class="line"></div><div class="line">    access_log  /var/<span class="built_in">log</span>/nginx/zabbix.access.log  main;</div><div class="line"></div><div class="line"><span class="comment">#allow无法使用localhost，所有内外网要分开写</span></div><div class="line">	allow 127.0.0.1;</div><div class="line">	allow Private-IP;</div><div class="line">	allow Public-IP;</div><div class="line">	allow Zabbix-Server-IP;</div><div class="line">	allow Remote-View-IP;</div><div class="line">	deny all;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">    	<span class="keyword">if</span> (!-f <span class="variable">$request_filename</span>) &#123;</div><div class="line">			rewrite ^([^\?]+)$ /index.php?1=<span class="variable">$1</span> last;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#Nignx_Status</span></div><div class="line">    location /nginx_status &#123;</div><div class="line">        stub_status on;</div><div class="line">        <span class="comment">#开启nginx自带的状态检查功能</span></div><div class="line">        access_log off;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#php-fpm_Status</span></div><div class="line"><span class="comment">#php-fpm的默认状态页面是/status,/ping。我修改了一下。</span></div><div class="line">    location ~ ^/php-fpm_(status|ping)$ &#123;</div><div class="line">    	access_log off;</div><div class="line">        fastcgi_pass 127.0.0.1:9000;</div><div class="line">        fastcgi_index index.php;</div><div class="line">        fastcgi_param SCRIPT_FILENAME <span class="variable">$document_root</span>/<span class="variable">$fastcgi_script_name</span>;</div><div class="line">        include fastcgi_params;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    location ~ \.php$ &#123;</div><div class="line">    	root /usr/share/zabbix;</div><div class="line">        fastcgi_pass 127.0.0.1:9000;</div><div class="line">        fastcgi_index index.php;</div><div class="line">        fastcgi_param SCRIPT_FILENAME <span class="variable">$document_root</span>/<span class="variable">$fastcgi_script_name</span>;</div><div class="line">        include fastcgi_params;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/Zabbix/zabbix-master_php-fpm.png" alt="监控php-fpm"></p>
<p><br></p>
<p><strong>php-fpm状态页面的配置文件</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line">vim /etc/php-fpm.d/www.conf</div><div class="line"></div><div class="line"><span class="comment">#说明和用法如下，我做简单修改</span></div><div class="line"><span class="comment">#修改默认值</span></div><div class="line">;pm.status_path = /status</div><div class="line">pm.status_path = /php-fpm_status</div><div class="line"></div><div class="line">;ping.path = /ping</div><div class="line">ping.path = /php-fpm_ping</div><div class="line">;ping.response = pong</div><div class="line">ping.response = 200</div><div class="line"></div><div class="line"><span class="comment">#用法</span></div><div class="line">zabbix.me/php-fpm_status</div><div class="line">zabbix.me/php-fpm_ping</div><div class="line"></div><div class="line"><span class="comment">#配置文件提供了格式化输出</span></div><div class="line">zabbix.me/php-fpm_status?html</div><div class="line">zabbix.me/php-fpm_status?html&amp;full</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">; output syntax. Example:</div><div class="line">;   http://www.foo.bar/status</div><div class="line">;   http://www.foo.bar/status?json</div><div class="line">;   http://www.foo.bar/status?html</div><div class="line">;   http://www.foo.bar/status?xml</div><div class="line">;   http://www.foo.bar/status?full</div><div class="line">;   http://www.foo.bar/status?json&amp;full</div><div class="line">;   http://www.foo.bar/status?html&amp;full</div><div class="line">;   http://www.foo.bar/status?xml&amp;full</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#修改完毕后重启服务</span></div><div class="line">systemctl restart php-fpm nginx</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#具体看下面描述</span></div><div class="line"><span class="comment">##这下面是说明</span></div><div class="line"></div><div class="line">; The URI to view the FPM status page. If this value is not <span class="built_in">set</span>, no URI will be</div><div class="line">; recognized as a status page. It shows the following informations:</div><div class="line">;   pool                 - the name of the pool;</div><div class="line">;   process manager      - static, dynamic or ondemand;</div><div class="line">;   start time           - the date and time FPM has started;</div><div class="line">;   start since          - number of seconds since FPM has started;</div><div class="line">;   accepted conn        - the number of request accepted by the pool;</div><div class="line">;   listen queue         - the number of request <span class="keyword">in</span> the queue of pending</div><div class="line">;                          connections (see backlog <span class="keyword">in</span> listen(2));</div><div class="line">;   max listen queue     - the maximum number of requests <span class="keyword">in</span> the queue</div><div class="line">;                          of pending connections since FPM has started;</div><div class="line">;   listen queue len     - the size of the socket queue of pending connections;</div><div class="line">;   idle processes       - the number of idle processes;</div><div class="line">;   active processes     - the number of active processes;</div><div class="line">;   total processes      - the number of idle + active processes;</div><div class="line">;   max active processes - the maximum number of active processes since FPM</div><div class="line">;                          has started;</div><div class="line">;   max children reached - number of <span class="built_in">times</span>, the process <span class="built_in">limit</span> has been reached,</div><div class="line">;                          when pm tries to start more children (works only <span class="keyword">for</span></div><div class="line">;                          pm <span class="string">'dynamic'</span> and <span class="string">'ondemand'</span>);</div><div class="line">; Value are updated <span class="keyword">in</span> real time.</div><div class="line">; Example output:</div><div class="line">;   pool:                 www</div><div class="line">;   process manager:      static</div><div class="line">;   start time:           01/Jul/2011:17:53:49 +0200</div><div class="line">;   start since:          62636</div><div class="line">;   accepted conn:        190460</div><div class="line">;   listen queue:         0</div><div class="line">;   max listen queue:     1</div><div class="line">;   listen queue len:     42</div><div class="line">;   idle processes:       4</div><div class="line">;   active processes:     11</div><div class="line">;   total processes:      15</div><div class="line">;   max active processes: 12</div><div class="line">;   max children reached: 0</div><div class="line">;</div><div class="line">; By default the status page output is formatted as text/plain. Passing either</div><div class="line">; <span class="string">'html'</span>, <span class="string">'xml'</span> or <span class="string">'json'</span> <span class="keyword">in</span> the query string will <span class="built_in">return</span> the corresponding</div><div class="line">; output syntax. Example:</div><div class="line">;   http://www.foo.bar/status</div><div class="line">;   http://www.foo.bar/status?json</div><div class="line">;   http://www.foo.bar/status?html</div><div class="line">;   http://www.foo.bar/status?xml</div><div class="line">;</div><div class="line">; By default the status page only outputs short status. Passing <span class="string">'full'</span> <span class="keyword">in</span> the</div><div class="line">; query string will also <span class="built_in">return</span> status <span class="keyword">for</span> each pool process.</div><div class="line">; Example:</div><div class="line">;   http://www.foo.bar/status?full</div><div class="line">;   http://www.foo.bar/status?json&amp;full</div><div class="line">;   http://www.foo.bar/status?html&amp;full</div><div class="line">;   http://www.foo.bar/status?xml&amp;full</div><div class="line">; The Full status returns <span class="keyword">for</span> each process:</div><div class="line">;   pid                  - the PID of the process;</div><div class="line">;   state                - the state of the process (Idle, Running, ...);</div><div class="line">;   start time           - the date and time the process has started;</div><div class="line">;   start since          - the number of seconds since the process has started;</div><div class="line">;   requests             - the number of requests the process has served;</div><div class="line">;   request duration     - the duration <span class="keyword">in</span> µs of the requests;</div><div class="line">;   request method       - the request method (GET, POST, ...);</div><div class="line">;   request URI          - the request URI with the query string;</div><div class="line">;   content length       - the content length of the request (only with POST);</div><div class="line">;   user                 - the user (PHP_AUTH_USER) (or <span class="string">'-'</span> <span class="keyword">if</span> not <span class="built_in">set</span>);</div><div class="line">;   script               - the main script called (or <span class="string">'-'</span> <span class="keyword">if</span> not <span class="built_in">set</span>);</div><div class="line">;   last request cpu     - the %cpu the last request consumed</div><div class="line">;                          it<span class="string">'s always 0 if the process is not in Idle state</span></div><div class="line"><span class="string">;                          because CPU calculation is done when the request</span></div><div class="line"><span class="string">;                          processing has terminated;</span></div><div class="line"><span class="string">;   last request memory  - the max amount of memory the last request consumed</span></div><div class="line"><span class="string">;                          it'</span>s always 0 <span class="keyword">if</span> the process is not <span class="keyword">in</span> Idle state</div><div class="line">;                          because memory calculation is <span class="keyword">done</span> when the request</div><div class="line">;                          processing has terminated;</div><div class="line">; If the process is <span class="keyword">in</span> Idle state, <span class="keyword">then</span> informations are related to the</div><div class="line">; last request the process has served. Otherwise informations are related to</div><div class="line">; the current request being served.</div><div class="line">; Example output:</div><div class="line">;   ************************</div><div class="line">;   pid:                  31330</div><div class="line">;   state:                Running</div><div class="line">;   start time:           01/Jul/2011:17:53:49 +0200</div><div class="line">;   start since:          63087</div><div class="line">;   requests:             12808</div><div class="line">;   request duration:     1250261</div><div class="line">;   request method:       GET</div><div class="line">;   request URI:          /test_mem.php?N=10000</div><div class="line">;   content length:       0</div><div class="line">;   user:                 -</div><div class="line">;   script:               /home/fat/web/docs/php/test_mem.php</div><div class="line">;   last request cpu:     0.00</div><div class="line">;   last request memory:  0</div><div class="line">;</div><div class="line">; Note: There is a real-time FPM status monitoring sample web page available</div><div class="line">;       It<span class="string">'s available in: @EXPANDED_DATADIR@/fpm/status.html</span></div><div class="line"><span class="string">;</span></div><div class="line"><span class="string">; Note: The value must start with a leading slash (/). The value can be</span></div><div class="line"><span class="string">;       anything, but it may not be a good idea to use the .php extension or it</span></div><div class="line"><span class="string">;       may conflict with a real PHP file.</span></div><div class="line"><span class="string">; Default Value: not set</span></div><div class="line"><span class="string">;pm.status_path = /status</span></div><div class="line"><span class="string">pm.status_path = /php-fpm_status</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">; The ping URI to call the monitoring page of FPM. If this value is not set, no</span></div><div class="line"><span class="string">; URI will be recognized as a ping page. This could be used to test from outside</span></div><div class="line"><span class="string">; that FPM is alive and responding, or to</span></div><div class="line"><span class="string">; - create a graph of FPM availability (rrd or such);</span></div><div class="line"><span class="string">; - remove a server from a group if it is not responding (load balancing);</span></div><div class="line"><span class="string">; - trigger alerts for the operating team (24/7).</span></div><div class="line"><span class="string">; Note: The value must start with a leading slash (/). The value can be</span></div><div class="line"><span class="string">;       anything, but it may not be a good idea to use the .php extension or it</span></div><div class="line"><span class="string">;       may conflict with a real PHP file.</span></div><div class="line"><span class="string">; Default Value: not set</span></div><div class="line"><span class="string">;ping.path = /ping</span></div><div class="line"><span class="string">ping.path = /php-fpm_ping</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">; This directive may be used to customize the response of a ping request. The</span></div><div class="line"><span class="string">; response is formatted as text/plain with a 200 response code.</span></div><div class="line"><span class="string">; Default Value: pong</span></div><div class="line"><span class="string">;ping.response = pong</span></div><div class="line"><span class="string">ping.response = 200</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>效果图：</p>
<p><img src="/images/Zabbix/zabbix-master_php-fpm2.png" alt="将php-fpm状态展现在Nginx上"></p>
<p><br></p>
<p>展现的话是在Agent端的Nginx上，这个更直观一些。<br>而Zabbix-Server就是通过<code>curl -s zabbix.me</code>来获取数据的，并通过对数据的提取来返回给Zabbix-Server。<br>所以收集php-fpm，nginx的信息状态，都是基于这个页面的。</p>
<p>现在导入PHP-FPM模板，导入操作同MongoDB。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#就是这个文件</div><div class="line">zbx_export_templates.xml</div></pre></td></tr></table></figure>
<p>导入模板后，直接链接模板就可以啦。<br>然后就可以使用了。</p>
<p><br><br><br></p>
<h2 id="监控Nginx"><a href="#监控Nginx" class="headerlink" title="监控Nginx"></a>监控Nginx</h2><p>Zabbix是通过<code>stub_status</code>模块实现对Nginx的监控。<br>Nginx的ngx_http_stub_status_module模块提供了基本的Nginx状态信息，源码安装的话需要加上–with-http_stub_status_module编译参数，如果是epel源yum安装的话，已经默认启用该模块。</p>
<p>在Nginx配置文件中加入如下配置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">location /nginx_status &#123;</div><div class="line">	allow IP;</div><div class="line">	deny all;</div><div class="line">	stub_status on;</div><div class="line">    access_log off;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">Active connections: 14</div><div class="line">server accepts handled requests</div><div class="line"> 22889 22889 72510</div><div class="line">Reading: 0 Writing: 2 Waiting: 12</div></pre></td></tr></table></figure>
<p><img src="/images/Zabbix/nginx_status.png" alt="nginx_status栗子"></p>
<p><br></p>
<p>以上数据是通过Web端查看。<br>但，我们需要把数据收集到Zabbix-Server。还需要使用之前下载同MongoDB，php-fpm一起的那个包。</p>
<p><strong>操作，基本还是类似MongoDB，php-fpm。只是个别参数需要修改一下。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">cd ./zabbix-master/nginx/</div><div class="line">cp ./nginx.sh /etc/zabbix/</div><div class="line">chmod a+x /etc/zabbix/nginx.sh</div><div class="line"></div><div class="line">cp ./userparameter_nginx.conf /etc/zabbix/zabbix_agentd.d</div><div class="line"></div><div class="line"></div><div class="line">vim /etc/zabbix/nginx.sh</div><div class="line"></div><div class="line">#HOST=&quot;localhost&quot;</div><div class="line">PORT=&quot;80&quot;</div><div class="line">#stub_status=stub_status</div><div class="line">stub_status=nginx_status</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">vim /etc/zabbix/zabbix_agentd.d/userparameter_nginx.conf</div><div class="line"></div><div class="line">#修改成脚本对应的位置</div><div class="line">UserParameter=nginx.status[*],/etc/zabbix/nginx.sh $1</div></pre></td></tr></table></figure>
<p>现在想以前一样导入模板。<br>然后在链接模板就可以了。</p>
<p><br><br><br></p>
<h2 id="监控Redis"><a href="#监控Redis" class="headerlink" title="监控Redis"></a>监控Redis</h2><p>监控Redis，也是把包里面对应的文件复制过去就行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ./zabbix-master/redis</div><div class="line">cp ./userparameter_redis.conf /etc/zabbix/zabbix_agentd.d/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#如果redis设置有密码，请加上密码</span></div><div class="line"><span class="comment">#如果是不同的端口，请修改</span></div><div class="line">UserParameter=redis.local[*],redis-cli -h 127.0.0.1 -p 6379 info|grep <span class="variable">$1</span>|grep -v _human|cut -d : -f2</div><div class="line"><span class="comment">#UserParameter=redis.local[*],redis-cli -h 127.0.0.1 -p 6379 -a Password info|grep $1|grep -v _human|cut -d : -f2</span></div><div class="line">UserParameter=redis.status[*],redis-cli -h <span class="variable">$1</span> -p <span class="variable">$2</span> -a Password info|grep <span class="variable">$3</span>|grep -v _human|cut -d : -f2</div><div class="line">UserParameter=redis.proc,pidof redis-server | wc -l</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#重启服务</span></div><div class="line">systemctl restart redis</div></pre></td></tr></table></figure>
<p>导入模板，链接主机，OK。</p>
<p><br></p>
<hr>
<p><br></p>
<h1 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h1><p><br></p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU的性能状态信息：</p>
<table>
<thead>
<tr>
<th>简写</th>
<th>描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>us</td>
<td>user cpu tim</td>
<td>用户使用CPU时间</td>
</tr>
<tr>
<td>sy</td>
<td>system cpu time</td>
<td>系统使用CPU时间</td>
</tr>
<tr>
<td>id</td>
<td>idle cpu time</td>
<td>CPU的空闲时间</td>
</tr>
<tr>
<td>wa</td>
<td>io wait cpu time</td>
<td>CPU等待IO时间</td>
</tr>
<tr>
<td>ni</td>
<td>user nice cpu time</td>
<td>用nice调整进程优先级的CPU时间</td>
</tr>
<tr>
<td>st</td>
<td>steal time</td>
<td>虚拟机偷取的CPU时间比，被强制等待虚拟CPU的时间</td>
</tr>
<tr>
<td>si</td>
<td>softirq time</td>
<td>系统处理软件中断所花费的CPU时间</td>
</tr>
<tr>
<td>hi</td>
<td>hard time</td>
<td>系统硬中断所花费的CPU时间</td>
</tr>
<tr>
<td>interrupt</td>
<td>中断</td>
<td>被处理过的中断数</td>
</tr>
<tr>
<td>cs</td>
<td>Context switches</td>
<td>上下文切换</td>
</tr>
<tr>
<td>ql</td>
<td>processor queue length</td>
<td>队列长度</td>
</tr>
<tr>
<td>processor load</td>
<td>processor load</td>
<td>处理器负载，几核乘以几</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul>
<li>当我们要监控并报警CPU使用率时，我们可以反过来用CPU空闲时间来定义</li>
<li>cpu idle tiem%  + cpu usage time% = 1</li>
<li>(CPU usage time% gt 80%) == (CPU idel time% lt 20%)</li>
<li>(CPU usage time% gt 90%) == (CPU idel time% &lt; 10%)</li>
<li>所以监控CPU使用率就可以监控CPU空闲时间，并依据这个报警</li>
</ul>
<p><br><br><br></p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>Zabbix中自带的Linux OS模板提供了<code>Total memory</code>和<code>Available memory</code>选项，这两者直接用模板就可以了。<br>但没有提供内存使用率的选项，因此需要我们自定义。</p>
<ul>
<li>内存使用率 = 可用内存 / 总内存</li>
<li>ast(vm.memory.size[available])/last(vm.memory.size[total])</li>
</ul>
<h3 id="自定义内存使用率"><a href="#自定义内存使用率" class="headerlink" title="自定义内存使用率"></a>自定义内存使用率</h3><p>我们只需要在Linux OS模板下配置内存使用率，就可以一劳永逸。</p>
<ol>
<li>配置(Configuration)</li>
<li>模板(Templates)</li>
<li>OS Linux模板的监控项(Items)</li>
<li>创建监控项</li>
<li>监控项名称: Available memory percent</li>
<li>类型： 可计算的</li>
<li>键值： vm.memory.size[percent]</li>
<li>公式： 100*last(vm.memory.size[available])/last(vm.memory.size[total])</li>
<li>记得将其加入Memory应用集，这样便于查找和管理</li>
<li>可加入单位： %</li>
</ol>
<p><br></p>
<p><img src="/images/Zabbix/custom_memorypercent.png" alt="自定义可用内存率"></p>
<p><img src="/images/Zabbix/custom_memorypercent2.png" alt="自定义可用内存率"></p>
<p><img src="/images/Zabbix/custom_memorypercent3.png" alt="效果图"></p>
<p><img src="/images/Zabbix/custom_memorypercent4.png" alt="效果图"></p>
<p><br></p>
<h3 id="添加触发器"><a href="#添加触发器" class="headerlink" title="添加触发器"></a>添加触发器</h3><ol>
<li>配置</li>
<li>模板</li>
<li>OS Linux模板</li>
<li>触发器</li>
<li>创建触发器，当可用内存率在三分钟内的平均值小于20%时报警</li>
<li>名字：Available memory percent lt 20% on {HOST.NAME}</li>
<li>严重性：一般严重</li>
<li>表达式： {Template OS Linux:vm.memory.size[percent].avg(3)}&lt;20</li>
</ol>
<p><br></p>
<p><img src="/images/Zabbix/custom_memorypercent5.png" alt="自定义可用内存率报警"></p>
<p><img src="/images/Zabbix/custom_memorypercent6.png" alt="效果图"></p>
<p><br><br><br></p>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>由于Zabbix-Server自带的Linux OS模板中的filesystem的监控是一个自动发现规则，而在应用集中的filesystem是没有监控项的。所有对于磁盘的监控和触发要在自动发现规则中去定义。</p>
<p><br></p>
<p><img src="/images/Zabbix/custom_disk1.png" alt="监控项"></p>
<p><img src="/images/Zabbix/custom_disk2.png" alt="触发器"></p>
<p><img src="/images/Zabbix/custom_disk3.png" alt="触发器"></p>
<p><img src="/images/Zabbix/custom_disk4.png" alt="触发器"></p>
<p><br><br><br></p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Zabbix简介&quot;&gt;&lt;a href=&quot;#Zabbix简介&quot; class=&quot;headerlink&quot; title=&quot;Zabbix简介&quot;&gt;&lt;/a&gt;Zabbix简介&lt;/h1&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zabbix.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Zabbix官方网站&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zabbix.com/documentation/3.4/zh/manual/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Zabbix中文文档&lt;/a&gt;&lt;br&gt;Zabbix-repo仓库: &lt;a href=&quot;http://repo.zabbix.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://repo.zabbix.com&lt;/a&gt; , 阿里云镜像: &lt;a href=&quot;https://mirrors.aliyun.com/zabbix/zabbix/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://mirrors.aliyun.com/zabbix/zabbix/&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;p&gt;CentOS7x86_64, Zabbix 3.4。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Zabbix" scheme="https://zhang21.github.io/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>Love at First Sight</title>
    <link href="https://zhang21.github.io/2017/11/06/Love-at-First-Sight/"/>
    <id>https://zhang21.github.io/2017/11/06/Love-at-First-Sight/</id>
    <published>2017-11-06T02:03:00.000Z</published>
    <updated>2017-11-06T05:27:19.950Z</updated>
    
    <content type="html"><![CDATA[<p>——波兰诗人维斯拉瓦·辛波丝卡(Wislawa Szymborska)<br><br></p>
<p>They’re both convinced<br>that a sudden passion joined them.</p>
<p>Such certainty is beautiful,<br>but uncertainty is more beautiful still.</p>
<p>Since they’d never met before,<br>they’re sure that there’d been nothing between them.</p>
<p>But what’s the word from the streets, staircases, hallways –<br>perhaps they’ve passed each other a million times?<br><a id="more"></a></p>
<p>I want to ask them<br>if they don’t remember<br>a moment face to face<br>in some revolving door?<br>perhaps a “sorry” muttered in a crowd?<br>a curt “wrong number” caught in the receiver?<br>but I know the answer.</p>
<p>No, they don’t remember<br>They’d be amazed to hear<br>that Chance has been toying with them<br>now for years.</p>
<p>Not quite ready yet<br>to become their Destiny,<br>it pushed them close, drove them apart,<br>it barred their path, stifling a laugh,<br>and then leaped aside.</p>
<p>There were signs and signals,<br>even if they couldn’t read them yet.</p>
<p>Perhaps three years ago<br>or just last Tuesday<br>a certain leaf fluttered<br>from one shoulder to another?</p>
<p>Something was dropped and then picked up.<br>Who knows, maybe the ball that vanished into childhood’s thicket?</p>
<p>There were doorknobs and doorbells<br>where one touch had covered another beforehand.</p>
<p>Suitcases checked and standing side by side.<br>One night, perhaps, the same dream,<br>grown hazy by morning.</p>
<p>Every beginning is only a sequel,<br>after all,<br>and the book of events<br>is always open halfway through.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;——波兰诗人维斯拉瓦·辛波丝卡(Wislawa Szymborska)&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;They’re both convinced&lt;br&gt;that a sudden passion joined them.&lt;/p&gt;
&lt;p&gt;Such certainty is beautiful,&lt;br&gt;but uncertainty is more beautiful still.&lt;/p&gt;
&lt;p&gt;Since they’d never met before,&lt;br&gt;they’re sure that there’d been nothing between them.&lt;/p&gt;
&lt;p&gt;But what’s the word from the streets, staircases, hallways –&lt;br&gt;perhaps they’ve passed each other a million times?&lt;br&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="Poetry" scheme="https://zhang21.github.io/tags/Poetry/"/>
    
  </entry>
  
  <entry>
    <title>LinuxShell脚本攻略</title>
    <link href="https://zhang21.github.io/2017/10/24/LinuxShell%E8%84%9A%E6%9C%AC%E6%94%BB%E7%95%A5/"/>
    <id>https://zhang21.github.io/2017/10/24/LinuxShell脚本攻略/</id>
    <published>2017-10-24T10:16:38.000Z</published>
    <updated>2018-01-11T07:25:50.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#bash(Bourne Again Shell)，shell环境使得用户能与操作系统的内核进行交互操作</span></div><div class="line"></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment">#date</span></div><div class="line"><span class="comment">#description</span></div><div class="line"></div><div class="line">cmd1; cmd2</div><div class="line">cmd3</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#sh /path/xx.sh</span></div><div class="line"><span class="comment">#Bash还有一个历史记录文件 ~/.bash_history</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p><br></p>
<h2 id="终端打印-echo"><a href="#终端打印-echo" class="headerlink" title="终端打印(echo)"></a>终端打印(<code>echo</code>)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#终端作为交互式工具，用户可以通过它与shell环境进行交互</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">'$var'</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$var</span></div><div class="line"><span class="built_in">echo</span> -e <span class="string">"1\t2\t3"</span></div><div class="line"><span class="built_in">echo</span> -e <span class="string">'\e[1;31m Red color \e[0m'</span>    <span class="comment">#彩色</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">echo</span> &#123;1..10&#125;		<span class="comment">#输出1到10</span></div><div class="line"><span class="built_in">echo</span> &#123;A..H&#125;		<span class="comment">#for i in &#123;a..z&#125;</span></div><div class="line"></div><div class="line"></div><div class="line">cat &lt;&lt; EOF</div><div class="line">11</div><div class="line">22</div><div class="line">33</div><div class="line">EOF</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># \转义字符</span></div><div class="line"><span class="built_in">printf</span> <span class="string">"%-5s %-10s $-4.2f\n"</span> 001 Zhang 56.789</div><div class="line"><span class="comment">#格式替代符%s %d %c %f, -左对齐</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="玩转变量和环境变量"><a href="#玩转变量和环境变量" class="headerlink" title="玩转变量和环境变量"></a>玩转变量和环境变量</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Bash中，每一个变量默认值值都是字符串形式</span></div><div class="line"><span class="comment">#环境变量和自定义变量</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$UID</span></div><div class="line"></div><div class="line"></div><div class="line">var=value	<span class="comment">#这是赋值</span></div><div class="line"><span class="comment">#var = value这是相等操作</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$var</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span>	<span class="comment">#字符数</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#export用来设置环境变量，此后，任何shell中的程序都会继承环境变量</span></div><div class="line">ZHANG=Gentleman</div><div class="line"><span class="built_in">export</span> ZHANG</div><div class="line"></div><div class="line"></div><div class="line">PATH=<span class="string">"<span class="variable">$PATH</span>:/home/zhang/bin"</span></div><div class="line"><span class="built_in">export</span> <span class="variable">$PATH</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="通过shell进行数学运算"><a href="#通过shell进行数学运算" class="headerlink" title="通过shell进行数学运算"></a>通过shell进行数学运算</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#let, expr, bc, [], (())</span></div><div class="line"><span class="comment">#要注意默认是字符串类型哦</span></div><div class="line"></div><div class="line">n1=1;n2=2</div><div class="line"><span class="built_in">let</span> sum=n1+n2</div><div class="line"><span class="built_in">let</span> n1++;<span class="built_in">let</span> n2-=1</div><div class="line"></div><div class="line">sum=$[ n1 + n2 ]</div><div class="line">sum2=$(( sum + 3 ))</div><div class="line"></div><div class="line">sum=`expr 3 + 4`</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#浮点计算 bc</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"8 * 1.1"</span> | bc</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#设置小数点精度</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"scale=2; 3/8"</span> | bc</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#进制转换</span></div><div class="line">num=100</div><div class="line"><span class="built_in">echo</span> <span class="string">"obase=2; <span class="variable">$num</span>"</span> | bc</div><div class="line"></div><div class="line">num=1100100</div><div class="line"><span class="built_in">echo</span> <span class="string">"obase=10; ibase=2; <span class="variable">$num</span>"</span> | bc</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#平方和平方根</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"sqrt(100)"</span> | bc</div><div class="line"><span class="built_in">echo</span> <span class="string">"10^2"</span> | bc</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="文件描述符重定向"><a href="#文件描述符重定向" class="headerlink" title="文件描述符重定向"></a>文件描述符重定向</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#最常用的文件描述符是 stdin(0), stdout(1), stderr(2); 通过内容过滤将输出重定向到文件</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"This is a sample text 1"</span> &gt; temp.txt	<span class="comment">#覆盖</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"This is sample text 2"</span> &gt;&gt; temp.txt	<span class="comment">#追加</span></div><div class="line"></div><div class="line">ls + &gt;stdout.txt 2&gt;stderr.txt</div><div class="line">cmd 2&gt;&amp;1 /dev/null  == com &amp;&gt; /dev/null		<span class="comment">#null设备也被称为黑洞</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#当一个command发生错误并退回时，它会返回一个非0的状态码</span></div><div class="line"><span class="built_in">echo</span> $?</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#tee命令，一方面可将数据重定向到文件，另一方面还可提供一份重定向数据的副本作为后续命令的stdin</span></div><div class="line"><span class="comment">#tee默认覆盖文件，-a选项追加</span></div><div class="line">cat temp.txt | tee tee.txt | cat -n</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="数组和关联数组"><a href="#数组和关联数组" class="headerlink" title="数组和关联数组"></a>数组和关联数组</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#数组借助索引将多个独立的数据存储为一个集合</span></div><div class="line"><span class="comment">#普通数组只能使用整数作为数组索引，而关联数组可以使用字符串作为数组索引</span></div><div class="line"><span class="comment">#还可将数组定义成一组索引-值(index-value)</span></div><div class="line"></div><div class="line"></div><div class="line">arr=(1 two 3 four 5)</div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[0]&#125;</span></div><div class="line">arr[0]=One</div><div class="line"></div><div class="line"></div><div class="line">index=3</div><div class="line"><span class="built_in">echo</span> $&#123;arr[<span class="variable">$index</span>]		<span class="comment">#arr[3]</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[*]&#125;</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#arr[*]&#125;</span>		<span class="comment">#arr-length</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#关联数组可用任意文本作为数组索引</span></div><div class="line"><span class="built_in">declare</span> -A ass_arr</div><div class="line">ass_arr=([index1]=val1 [index2]=val2 ...)	<span class="comment">#内嵌索引-值</span></div><div class="line">ass_arr[index3]=val3	<span class="comment">#独立索引-值</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!ass_arr[*]&#125;</span>		<span class="comment">#列出数组索引</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="别名-alias"><a href="#别名-alias" class="headerlink" title="别名(alias)"></a>别名(<code>alias</code>)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#alias作用是暂时的，关闭终端后别名就失效；</span></div><div class="line"><span class="comment">#为使别名一直保持，可将其写入 ~/.bashrc，因为每一个新的shell都会执行~/.bashrc中的命令</span></div><div class="line"><span class="comment">#新设置的别名将取代已有别名</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">alias</span> vi=vim;</div><div class="line"><span class="built_in">unalias</span> vi</div><div class="line"><span class="built_in">echo</span> <span class="string">"alias ll='ls -l --color=auto'"</span> &gt;&gt; ~/.bashrc</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#\对别名命令进行转义，执行原本的命令。避免攻击者利用别名将某些特权命令替换成别有用心的命令</span></div><div class="line">\vi test.sh</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="获取、设置日期和延时-date"><a href="#获取、设置日期和延时-date" class="headerlink" title="获取、设置日期和延时(date)"></a>获取、设置日期和延时(<code>date</code>)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#很多应用程序需要以不同的格式打印日期，设置日期和时间，以及根据日期和时间执行操作;</span></div><div class="line"><span class="comment">#延时通常用于在程序执行过程中提供一段等待时间;</span></div><div class="line"><span class="comment">#在Unix-like系统中，日期被存储为一个整数，其大小为世界标准时间1970年1月1日0时0分0秒起所流逝的秒数；</span></div><div class="line"><span class="comment">#这种计时方式被称之为 纪元时或Unix时间；</span></div><div class="line"><span class="comment">#通过纪元时间，可知道两个日期之间相隔了多少秒</span></div><div class="line"><span class="comment">#编写以循环方式运行的监视脚本时，设置时间间隔是必不可少的</span></div><div class="line"></div><div class="line">date +%s</div><div class="line"></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">start=$(date +%s)</div><div class="line">commands</div><div class="line">sleep 1</div><div class="line">end=$(date +%s)</div><div class="line">diff=$((end - start))</div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$diff</span> seconds"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#显示指定时间</span></div><div class="line">date +%F -d -1days</div><div class="line">date +%H -d -3hours</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="调试脚本-sh"><a href="#调试脚本-sh" class="headerlink" title="调试脚本(sh)"></a>调试脚本(<code>sh</code>)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#调试功能能在出现一些异常情况时生成运行信息</span></div><div class="line"></div><div class="line"><span class="comment">#!/bin/bash -xv</span></div><div class="line">sh -x</div><div class="line">sh -n</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="函数和参数-function"><a href="#函数和参数-function" class="headerlink" title="函数和参数(function)"></a>函数和参数(<code>function</code>)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> fname()</div><div class="line">&#123;</div><div class="line">statements</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">fname()</div><div class="line">&#123;</div><div class="line"><span class="built_in">echo</span> <span class="variable">$1</span>, <span class="variable">$2</span>		<span class="comment">#访问第参数1和参数2,$n第n个参数</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$@</span>"</span>		<span class="comment">#以列表的形式一次性打印所有参数</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"$*"</span>		<span class="comment">#类似于$@，但参数被作为单个实体</span></div><div class="line"><span class="built_in">return</span> 0		<span class="comment">#f返回值</span></div><div class="line">&#125;</div><div class="line">fname 1 22 333	<span class="comment">#返回上面定义的变量</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#递归函数，能够调用自身，不断地生成新的进程，最终会造成xx</span></div><div class="line"><span class="comment">#导出函数，使用export导出，这样函数作用域就可以扩展到子进程</span></div><div class="line"><span class="built_in">export</span> -f fname</div><div class="line"><span class="comment">#读取命令返回值</span></div><div class="line"><span class="built_in">echo</span> $?</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="读取命令序列输出"><a href="#读取命令序列输出" class="headerlink" title="读取命令序列输出(` `, $() )"></a>读取命令序列输出(` `, $() )</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#输入通常是stdin，输出stderr或stdout,这些命令称为 过滤器(filter)。我们使用 管道(pipe) 来连接每一个过滤器</span></div><div class="line">cmd1 | cmd2 | cmd3</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#子shell，子shell生成独立的进程，不会对当前shell有任何影响，所做改变仅限于子shell内</span></div><div class="line">zhang=$(ls | cat -n)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#反引用</span></div><div class="line">zhang=`ls | cat -n`</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="读取字符-read"><a href="#读取字符-read" class="headerlink" title="读取字符(read)"></a>读取字符(<code>read</code>)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#read是一个重要的从标准输入中读取文本的命令</span></div><div class="line"><span class="comment">#可以使用read以交互的形式来读取用户的输入</span></div><div class="line"></div><div class="line"><span class="built_in">read</span> -n 5 zhang		<span class="comment">#读取字符数</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$zhang</span></div><div class="line"></div><div class="line"><span class="built_in">read</span> -s passwd		<span class="comment">#不回显</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$passwd</span></div><div class="line"></div><div class="line"><span class="built_in">read</span> -t 5 zhang		<span class="comment">#超时时间</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$zhang</span></div><div class="line"></div><div class="line"><span class="built_in">read</span> -p zhang		<span class="comment">#显示提示信息</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$zhang</span></div><div class="line"></div><div class="line"><span class="built_in">read</span> -d <span class="string">":"</span> zhang		<span class="comment">#定界符结束输入</span></div><div class="line">123：</div><div class="line"><span class="built_in">echo</span> <span class="variable">$zhang</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="字段分隔符和迭代器"><a href="#字段分隔符和迭代器" class="headerlink" title="字段分隔符和迭代器"></a>字段分隔符和迭代器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#内部字段分隔符(Internal Field Separator, IFS)是shell中的一个重要概念</span></div><div class="line"><span class="comment">#IFS的默认值为空白字符(换行符、制表符、空格)</span></div><div class="line">awk -F: <span class="string">'&#123;print $1,$3&#125;'</span> /etc/passwd		<span class="comment">#IFS=":"</span></div><div class="line"></div><div class="line"><span class="comment">#对一些列值进行迭代，循环非常有用</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10&#125;</div><div class="line"><span class="keyword">do</span></div><div class="line">cmd</div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> condition</div><div class="line"><span class="keyword">do</span></div><div class="line">cmd</div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line">until condition</div><div class="line"><span class="keyword">do</span></div><div class="line">cmd</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="比较与测试"><a href="#比较与测试" class="headerlink" title="比较与测试"></a>比较与测试</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#程序中的流程控制是由比较和测试语句来处理的</span></div><div class="line"><span class="keyword">if</span> condition1 || condition2</div><div class="line"><span class="keyword">then</span></div><div class="line">	cmd1</div><div class="line"><span class="keyword">elif</span> condition3 &amp;&amp; condition4</div><div class="line"><span class="keyword">then</span></div><div class="line">	cmd2</div><div class="line"><span class="keyword">else</span></div><div class="line">	cmd3</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#算术比较</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$num</span> -ge 10 -a <span class="variable">$num</span> -lt 20 ]</div><div class="line"></div><div class="line">-eq</div><div class="line">-gt</div><div class="line">-ge</div><div class="line">-lt</div><div class="line">-le</div><div class="line">-a</div><div class="line">-o</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#文件系统相关</span></div><div class="line"><span class="keyword">if</span> [ -f <span class="variable">$file1</span> -o -x <span class="variable">$file2</span>]</div><div class="line"></div><div class="line">-x</div><div class="line">-w</div><div class="line">-r</div><div class="line">-f</div><div class="line">-d</div><div class="line">-e</div><div class="line">-b		<span class="comment">#block</span></div><div class="line">-l</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#字符串比较</span></div><div class="line">[[ <span class="variable">$str1</span> = <span class="variable">$str2</span>]]</div><div class="line"></div><div class="line">=		<span class="comment">#=号旁有空格--是比较关系；=号旁没空格，是赋值语句</span></div><div class="line">!=</div><div class="line">&gt;</div><div class="line">&lt;</div><div class="line">-z		<span class="comment">#空字符</span></div><div class="line">-n		<span class="comment">#非空字符</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#使用test命令来执行条件检测</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$num</span> -eq 0 ]  -- <span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$num</span> -eq 0</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="命令之乐"><a href="#命令之乐" class="headerlink" title="命令之乐"></a>命令之乐</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>各种命令可谓Unix-Like系统中优美的部分，它能帮我们搞定各种繁杂的任务。<br>一旦你尝试过Linux提供的这些利器，你一定会感到惊讶：以前没有这些命令的时候，自己是什么熬过来的。<br>最钟爱的莫过于 <code>grep</code>, <code>awk</code>, <code>sed</code>, <code>find</code> 命令了！</p>
<p>本章将会为你介绍一些最有趣同时也是最实用的命令。</p>
<p><br></p>
<h2 id="用cat进行拼接"><a href="#用cat进行拼接" class="headerlink" title="用cat进行拼接"></a>用<code>cat</code>进行拼接</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#cat命令通常用于读取、显示或拼接文件内容，不过它所具备的能力远不止此</span></div><div class="line"><span class="comment">#cat(concatenate, 拼接)</span></div><div class="line">cat file1 file2 ···</div><div class="line"><span class="built_in">echo</span> <span class="string">"Ahaha"</span> | cat - file1 file2		<span class="comment">#-指stdin文本文件名</span></div><div class="line"></div><div class="line">cat -s file3  -- cat file3 | tr -s <span class="string">'\n'</span>		<span class="comment">#压缩空白行</span></div><div class="line">cat -T test.py		<span class="comment">#将制表符显示为 ^I, 避免制表符和连续空格误用, 产生错误缩进</span></div><div class="line">cat -n file4		<span class="comment">#显示行号</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="录制与回放终端会话-script"><a href="#录制与回放终端会话-script" class="headerlink" title="录制与回放终端会话(script)"></a>录制与回放终端会话(<code>script</code>)</h2><p>当你需要准备一个命令行教程时，如果将我们输入命令后的一切按照先后次序记录下来，再进行回放，是不是很nice！<br>通过 <code>script</code>, <code>scriptreplay</code> 命令, 把终端会话记录到文件，并回放。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-t,将时间数据输出到标准错误； -a,追加输出</span></div><div class="line">script -t 2&gt; timing.log -a output.session		<span class="comment">#两个文件随意取名, 如不将错误重定向会显示在屏幕上导致很乱</span></div><div class="line">输入命令</div><div class="line">cmd2</div><div class="line">···</div><div class="line"><span class="built_in">exit</span>		<span class="comment">#退出录制</span></div><div class="line"></div><div class="line"></div><div class="line">scriptreplay -t timing.log output.session		<span class="comment">#播放</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="文件查找与文件列表-find"><a href="#文件查找与文件列表-find" class="headerlink" title="文件查找与文件列表(find)"></a>文件查找与文件列表(<code>find</code>)</h2><p><code>find</code> 是Unix/Linux命令行工具箱中最棒的工具之一。<br><code>find</code> 命令沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应的操作。</p>
<p>find - search for files in a directory hierarchy</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#基于文件名及正则表达式搜索</span></div><div class="line">find /home/zhang		<span class="comment">#列出/home/zhang目录及其子目录线所有文件和文件夹</span></div><div class="line">find /home/zhang -name <span class="string">"*.txt"</span></div><div class="line">find . -name <span class="string">"*.sh"</span> -o -iname <span class="string">"zhang*"</span>		<span class="comment">#匹配多个</span></div><div class="line">find /home/zhang -path <span class="string">"201710*"</span>		<span class="comment">#-path将文件路径作为一个整体进行匹配</span></div><div class="line">find . -regex	<span class="string">".*\(\.txt|\.[0-9]+\)$"</span>		<span class="comment">#匹配以.txt或数字结尾的文件</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#使用-maxdepth, -mindepth参数，来限制find的遍历深度</span></div><div class="line"><span class="comment">#-type, 根据文件类型搜索。 f(普通文件)，d(目录)，b(块设备)，l(符号链接)，s(套接字)等</span></div><div class="line">find /home -maxdepth 1 -<span class="built_in">type</span> f(d)		<span class="comment">#参数顺序也会影响find的查找效率</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#根据文件类型搜索</span></div><div class="line">find /dev -<span class="built_in">type</span> b		<span class="comment">#查看/dev及其子目录下设备文件</span></div><div class="line">find / -maxdepth 1 -<span class="built_in">type</span> l		<span class="comment">#查找/下链接文件</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#根据文件时间进行搜索</span></div><div class="line"><span class="comment">#Unix/Linux文件系统中的每一个文件都有三种时间戳(timestamp),-表示小于，+表示大于</span></div><div class="line"><span class="comment">#Unix中并没有所谓的 "创建时间" 的概念</span></div><div class="line"><span class="comment">#访问时间(-atime,以天为单位； -amin,以分钟为单位):用户最近一次访问文件时间；</span></div><div class="line"><span class="comment">#修改时间(-mtime,以天为单位； -mmin,以分钟为单位):文件最后一次修改时间；</span></div><div class="line"><span class="comment">#变化时间(-ctime,以天为单位； -cmin,以分钟为单位):文件元数据(如权限，所有权)最后一次变化时间；</span></div><div class="line">find /home/zhang -<span class="built_in">type</span> f -mtime 7		<span class="comment">#7天前被修改的普通文件</span></div><div class="line">find /home/zhang -<span class="built_in">type</span> f -amin -10		<span class="comment">#搜索10分钟内被修改的普通文件</span></div><div class="line">find . -<span class="built_in">type</span> f -newer file1.txt		<span class="comment">#找出比file1.txt新的文件</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#基于文件大小的搜索</span></div><div class="line"><span class="comment">#b(块，512字节), c(字节), w(字，2字节), k(千字节), M(兆字节), G(吉字节)</span></div><div class="line">find . -<span class="built_in">type</span> -f -size +100k</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#删除匹配的文件</span></div><div class="line">find . -<span class="built_in">type</span> f -name <span class="string">"*.swp"</span> -delete</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#基于文件权限和所有权的匹配</span></div><div class="line">find . -<span class="built_in">type</span> f -perm 644</div><div class="line">find /var/apache -<span class="built_in">type</span> f -name <span class="string">"*.php"</span> -perm 644		<span class="comment">#搜索基于权限的文件</span></div><div class="line">find /var -maxdepth 2 -<span class="built_in">type</span> f -user zhang		<span class="comment">#搜索基于用户的文件</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#执行命令或动作</span></div><div class="line"><span class="comment">#find命令可以借助-exec与其他命令进行结合</span></div><div class="line"><span class="comment">#&#123;&#125;是一个特殊字符串，将替换为相应文件名</span></div><div class="line">find . -<span class="built_in">type</span> f -perm 764 -user zhang -<span class="built_in">exec</span> chmod 644 &#123;&#125; \;		<span class="comment">#将所属用户zhang，权限764的文件权限修改为644</span></div><div class="line">find . -<span class="built_in">type</span> f -mmin +30 -name <span class="string">"*.txt"</span> -<span class="built_in">exec</span> cp &#123;&#125; &#123;&#125;.old \;		<span class="comment">#复制最近30内修改的名字为.txt的文件</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-exec结合多个命令</span></div><div class="line"><span class="comment">#我们无法在-exec参数中直接使用多个命令，不过我们可以把多个命令写到一个shellscript中，然后执行</span></div><div class="line">-<span class="built_in">exec</span> ./test.sh &#123;&#125; \;</div><div class="line">find . -<span class="built_in">type</span> f -name <span class="string">"*.sh"</span> -mmin -10 -<span class="built_in">exec</span> sh &#123;&#125; \;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#让find跳过特定目录</span></div><div class="line">-prune</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#利用find搭配tar打包</span></div><div class="line"><span class="comment">#查找7天内的文件并打包</span></div><div class="line"><span class="comment">#建议使用绝对路径，管道无效，所有要定向到文件</span></div><div class="line">find /dir/path/zhang -<span class="built_in">type</span> -f -mmtime -7 &gt; /dir/path/zhang/zhang.list &amp;&amp; tar -T /dir/path/zhang/zhang.list -czvf /dir/path/zhang123.tar.gz</div><div class="line"><span class="comment">#检查是否正确</span></div><div class="line">tar -tf /dir/path/zhang123.tar.gz</div><div class="line"></div><div class="line"><span class="comment">#不能使用find -exec tar，这样打包以后只有最后一个文件</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="利用stat命令查看atime-mtime-ctime"><a href="#利用stat命令查看atime-mtime-ctime" class="headerlink" title="利用stat命令查看atime, mtime, ctime"></a>利用<code>stat</code>命令查看atime, mtime, ctime</h3><p><code>stat</code> - display file or file system status</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">stat 1.txt</div><div class="line"></div><div class="line">#Access:</div><div class="line">#Modify:</div><div class="line">#Change:</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="利用touch命令修改atime-mtime-ctime"><a href="#利用touch命令修改atime-mtime-ctime" class="headerlink" title="利用touch命令修改atime, mtime, ctime"></a>利用<code>touch</code>命令修改atime, mtime, ctime</h3><p>touch - change file timestamps</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#-a     change only the access time</div><div class="line">#-m     change only the modification time</div><div class="line">#-d     instead of current time</div><div class="line">#-t     instead of current time</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="玩转xargs"><a href="#玩转xargs" class="headerlink" title="玩转xargs"></a>玩转<code>xargs</code></h2><p>xargs - build and execute command lines from standard input</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#xargs能够处理stdin并将其转换为特定命令的命令行参数</span></div><div class="line"><span class="comment">#也可以将单行或多行输入文本转换成其他格式(如多行变单行)</span></div><div class="line">cmd | xargs</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#将多行输入转换为单行输出</span></div><div class="line"><span class="built_in">echo</span> -e <span class="string">"1\n2\n3"</span> | xargs	<span class="comment">#将换行符替换为空格</span></div><div class="line"><span class="comment">#将单行输入转换成多行输出</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"1 2 3"</span> | xargs -n 1	<span class="comment">#每行一个参数</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"hahaZhahaZhahaZhaha"</span> | xargs -n 2 -d Z	<span class="comment">#-d指定分隔符</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#读取stdin，将格式化参数传递给命令</span></div><div class="line">cat test.txt | xargs -n 1 ./zhang.sh	<span class="comment">#zhang.sh arg1; zhang.sh arg2... 每次提供一个参数</span></div><div class="line">cat test.txt | xargs -n X ./zhang.sh	<span class="comment">#X为参数个数，一次提供全部参数</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定替换字符串</span></div><div class="line">cat test.txt | xargs -I &#123;&#125; ./zhang.sh &#123;&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#结合find使用xargs</span></div><div class="line">find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -print0 | xargs -0 ls	<span class="comment">#-print0无换行输出, -0将\0作为输入界定符</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#统计某文件行数</span></div><div class="line">find /path -<span class="built_in">type</span> f -name <span class="string">"*.c"</span> -print0 | xargs -0 wc -l</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#结合stdin，运用while和子shell</span></div><div class="line">cat file.txt | <span class="keyword">while</span> <span class="built_in">read</span> arg; <span class="keyword">do</span> cat <span class="variable">$arg</span>; <span class="keyword">done</span> == cat file.txt | xargs - &#123;&#125; cat &#123;&#125;</div><div class="line">cmd0 | (cmd1; cmd2; cmd3) | cmd4	<span class="comment">#子shell</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用tr进行转换"><a href="#用tr进行转换" class="headerlink" title="用tr进行转换"></a>用<code>tr</code>进行转换</h2><p>tr - translate or delete characters</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#tr命令经常用来编写优美的单行命令</span></div><div class="line"><span class="comment">#tr可对来自stdin的字符 进行替换、删除以及压缩</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"AH WONDERFUL"</span> | tr <span class="string">'A-Z'</span> <span class="string">'a-z'</span>	<span class="comment">#转换大小写</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"AH WONDERFUL"</span> | tr <span class="string">'A-Z'</span> <span class="string">'a-b'</span> --&gt; ab bbbbbbbbb</div><div class="line"><span class="comment">#tr [option] set1 set2</span></div><div class="line"><span class="comment">#如果两个字符集长度不相等，那么set2会不断重复其最后一个字符，直到长度与set1相同</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">echo</span> 12345 | tr <span class="string">'0-9'</span> <span class="string">'9876543210'</span>	<span class="comment">#数字加密</span></div><div class="line"><span class="built_in">echo</span> 87654 | tr <span class="string">'9876543210'</span> <span class="string">'0-9'</span>	<span class="comment">#数字解密</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">'He is a cool boy, and she is a beautiful girl'</span> | tr <span class="string">'A-Za-z'</span> <span class="string">'NOPQRSRUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm'</span>	<span class="comment">#加密</span></div><div class="line"><span class="built_in">echo</span> <span class="string">'Ur vf n pbby obl, naq fur'</span> | tr <span class="string">'NOPQRSRUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm'</span> <span class="string">'A-Za-z'</span>	<span class="comment">#解密</span></div><div class="line"></div><div class="line">cat 1.txt | tr <span class="string">'\t'</span> <span class="string">' '</span>	<span class="comment">#将制表符转换为空格</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#删除字符</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"Hello 530 World"</span> | tr -d <span class="string">'0-9'</span>	<span class="comment">#-d删除，删除数字</span></div><div class="line">Hello  World</div><div class="line"><span class="built_in">echo</span> <span class="string">"Hello 520 World"</span> | tr -d -c <span class="string">'0-9'</span>	<span class="comment">#-c补集</span></div><div class="line"> 520</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#压缩字符，将连续的重复字符压缩为单个字符</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"GNU's    not   Unix"</span> | tr -s <span class="string">' '</span>	<span class="comment">#-s压缩，压缩空格</span></div><div class="line">GNU<span class="string">'s not Unix</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">echo -e "1\n2\n3\n4\n5" &gt; sum.txt</span></div><div class="line"><span class="string">cat sum.txt | echo $[ $(tr '</span>\n<span class="string">' '</span>+<span class="string">') 0 ] -- echo $[1+2+3+4+5+0]</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#tr字符类</span></div><div class="line"><span class="string">\a	终端鸣响</span></div><div class="line"><span class="string">\b	退格</span></div><div class="line"><span class="string">\f	换页</span></div><div class="line"><span class="string">\n	换行</span></div><div class="line"><span class="string">\r	回车</span></div><div class="line"><span class="string">\t	水平制表符</span></div><div class="line"><span class="string">\v	垂直制表符</span></div><div class="line"><span class="string">string1-stringN	#从字符1到字符N升序过程中的所有字符</span></div><div class="line"><span class="string">[字符*次数]</span></div><div class="line"><span class="string">[:alnum:]	#所有字母和数字</span></div><div class="line"><span class="string">[:alpha:]	#所有字母</span></div><div class="line"><span class="string">[:digit:]	#所有数字</span></div><div class="line"><span class="string">[:lower:]	#所有小写字母</span></div><div class="line"><span class="string">[:upper:]	#所有大写字母</span></div><div class="line"><span class="string">[:graph:]	#所有可打印字符，不含空格</span></div><div class="line"><span class="string">[:print:]	#所有可打印字符，包含空格</span></div><div class="line"><span class="string">[:blank:]	#所有水平排列的空白字符</span></div><div class="line"><span class="string">[:cntrl:]	#所有控制字符</span></div><div class="line"><span class="string">[:punct:]	#所有标点字符</span></div><div class="line"><span class="string">[:space:]	#所有空白字符</span></div><div class="line"><span class="string">[:xdigit:]	#所有十六进制数</span></div><div class="line"><span class="string">[=字符]	#指定字符</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="校验和-与-核实文件完整性-md5sum"><a href="#校验和-与-核实文件完整性-md5sum" class="headerlink" title="校验和 与 核实文件完整性(md5sum)"></a>校验和 与 核实文件完整性(<code>md5sum</code>)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#校验和(checksum)程序从文件中生成校验和密钥，然后利用校验和密钥核实文件的完整性</span></div><div class="line"><span class="comment">#校验和对于编写备份脚本或系统维护脚本非常重要，因为它们都会涉及通过网络传输文件</span></div><div class="line"><span class="comment">#通过使用校验和核实，我们就可以识别那些在网络传输过程中出现损坏的文件，并重传，从而确保数据完整性</span></div><div class="line"><span class="comment">#校验和对于核实数据完整性非常有用</span></div><div class="line"><span class="comment">#广泛使用的校验和技术有：md5sum, sha1sum</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#对单个文件进行校验</span></div><div class="line">md5sum sum.txt &gt; sum.md5</div><div class="line"><span class="comment">#302c28003d487124d97c242de94da856  sum.txt</span></div><div class="line">md5sum -c sum.md5	<span class="comment">#-c检查</span></div><div class="line"><span class="comment">#sum.txt: 确定</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#对目录进行校验</span></div><div class="line"><span class="comment">#对目录计算校验和意味着我们需要对目录中的所有文件以递归的方式进行计算</span></div><div class="line">yum install -y md5deep</div><div class="line">md5deep -r ./dir &gt; dir.md5	<span class="comment">#recursive递归</span></div><div class="line">md5sum -c dir.md5</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#可以将测试dir下某个文件更改一下，校验的时候会报错</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="排序、单一、重复-sort-uniq"><a href="#排序、单一、重复-sort-uniq" class="headerlink" title="排序、单一、重复(sort,uniq)"></a>排序、单一、重复(<code>sort</code>,<code>uniq</code>)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#sort - 对文本文件进行行排序</span></div><div class="line"><span class="comment">#uniq - 删除排序文件中的重复行</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">echo</span> -e <span class="string">"333\n1"</span> &gt; 1.txt; <span class="built_in">echo</span> -e <span class="string">"22\n22"</span> &gt; 2.txt</div><div class="line">sort 1.txt 2.txt -o ./sorted.txt</div><div class="line"><span class="comment">#1</span></div><div class="line"><span class="comment">#22</span></div><div class="line"><span class="comment">#22</span></div><div class="line"><span class="comment">#333</span></div><div class="line">cat sortec.txt | uniq</div><div class="line"><span class="comment">#1</span></div><div class="line"><span class="comment">#22</span></div><div class="line"><span class="comment">#333</span></div><div class="line"></div><div class="line"></div><div class="line">sort -n	<span class="comment">#按数字进行排序</span></div><div class="line">sort -r	<span class="comment">#逆向排序</span></div><div class="line">sort -M	<span class="comment">#按月份排序</span></div><div class="line">sort -C	<span class="comment">#检查是否排序</span></div><div class="line">sort -b	<span class="comment">#忽略空白</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#依据键或列进行排序</span></div><div class="line">sort -k 2 data.txt	<span class="comment">#依据第二列来排序</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#uniq要么使用管道，要么使用排过序的文件作文输入</span></div><div class="line">uniq -u sorted.txt	<span class="comment">#只显示唯一的行(即没有重复出现的行)</span></div><div class="line">uniq -d sorted.txt	<span class="comment">#只显示重复的行</span></div><div class="line">uniq -s 2 -w 2 sorted.txt	<span class="comment">#-s忽略前2个字符，-w指定用于比较的最大字符数</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="临时文件命名、随机数"><a href="#临时文件命名、随机数" class="headerlink" title="临时文件命名、随机数"></a>临时文件命名、随机数</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#在编写shell脚本时，我们经常需要存储临时文件。最适合存储临时数据的位置是 /tmp</span></div><div class="line"><span class="comment">#/tmp目录中的内容会在系统重启后被清空</span></div><div class="line"></div><div class="line">filename=<span class="variable">$RANDOM</span>	<span class="comment">#RANDOM返回一个随机数</span></div><div class="line">filename2=$$	<span class="comment">#当前shell的PID</span></div><div class="line">filename3=$((date +%F))	<span class="comment">#通过日期命令</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="分割文件和数据-split"><a href="#分割文件和数据-split" class="headerlink" title="分割文件和数据(split)"></a>分割文件和数据(<code>split</code>)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#某些情况下，需要把文件分割成多个更小的片段</span></div><div class="line">dd <span class="keyword">if</span>=/dev/zero bs=100k count=1 of=./data.file	<span class="comment">#生成一个大小100k内容全是0的文件</span></div><div class="line">split -b 20k data.file	<span class="comment">#-d指定分割大小</span></div><div class="line"><span class="comment">#data.file xaa xab xac xad xae,这五个文件都为20k</span></div><div class="line"><span class="comment">#我测试了一下，几个文件加起来数据没变，几个文件总行数没变</span></div><div class="line"><span class="comment">#单位有 k, m, G, c(byte), w(word)</span></div><div class="line"><span class="comment">#-d以数字为后缀， -a指定后缀长度</span></div><div class="line"></div><div class="line"></div><div class="line">split data.file -b 20k -d -a 2 spt	<span class="comment">#增加前缀名'spt'</span></div><div class="line"><span class="comment">#data.file  spt00  spt01  spt02  spt03  spt04</span></div><div class="line"></div><div class="line"></div><div class="line">split -l 10 data.file	<span class="comment">#-l按行数来分割文件</span></div><div class="line"><span class="comment">#split只能根据大小或行数分割文件</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#csplit可以根据文件本身特点进行分割</span></div><div class="line">-f	<span class="comment">#指定分割后文件前缀</span></div><div class="line">-n	<span class="comment">#指定分割后文件后缀数字个数</span></div><div class="line">-b	<span class="comment">#指定后缀格式</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="根据扩展名切分文件名"><a href="#根据扩展名切分文件名" class="headerlink" title="根据扩展名切分文件名"></a>根据扩展名切分文件名</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#借助%操作符将名称从 “名称.扩展名” 格式中提取出来</span></div><div class="line"></div><div class="line"></div><div class="line">file=<span class="string">"zhang.txt"</span></div><div class="line">name1=<span class="variable">$&#123;file%.*&#125;</span>	<span class="comment">#删除位于%右侧的通配符(.*)所匹配的字符串，通配符从右向左进行匹配</span></div><div class="line"><span class="comment">#zhang</span></div><div class="line"><span class="comment">#*号通配符，.号</span></div><div class="line"><span class="comment">#%属于非贪婪匹配(non-greedy),它会匹配通配符最短结果</span></div><div class="line"><span class="comment">#%%属于贪婪匹配(greedy)，它会匹配符号条件的最长字符串</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">name2=<span class="variable">$&#123;file#*.&#125;</span>	<span class="comment">#删除位于#右侧的通配符(*.)所匹配的字符串，通配符从左向右进行匹配</span></div><div class="line"><span class="comment">#txt</span></div><div class="line"><span class="comment"># #属于非贪婪匹配</span></div><div class="line"><span class="comment"># ##属于贪婪匹配</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">URL=“www.google.com”</div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;URL%.*&#125;</span>	<span class="comment">#非贪婪匹配，移除最右边.及其后面内容</span></div><div class="line">www.google</div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;URL%%.*&#125;</span>	<span class="comment">#贪婪匹配</span></div><div class="line">www</div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;URL#*.&#125;</span>	<span class="comment">#非贪婪匹配，移除最左边.及其前面内容</span></div><div class="line">google.com</div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;URL##*.&#125;</span>	<span class="comment">#贪婪匹配</span></div><div class="line">com</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="批量重命名和移动"><a href="#批量重命名和移动" class="headerlink" title="批量重命名和移动"></a>批量重命名和移动</h2><p>综合运用<code>find</code>、<code>rename</code>、<code>mv</code>命令。</p>
<p><br></p>
<h2 id="拼写检查与词典操作"><a href="#拼写检查与词典操作" class="headerlink" title="拼写检查与词典操作"></a>拼写检查与词典操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Linux大多数发行版都含有一份词典文件，另外还有一个被称为aspell的拼写检查命令</span></div><div class="line"><span class="comment">#words --&gt; /usr/share/dict/linux.words</span></div><div class="line"></div><div class="line">grep <span class="string">"^good"</span> /usr/share/dict/linux.words</div><div class="line"></div><div class="line">aspell</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="交互输入自动化"><a href="#交互输入自动化" class="headerlink" title="交互输入自动化"></a>交互输入自动化</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#写一个读取交互式输入脚本</span></div><div class="line">vi jiaohu.sh</div><div class="line"></div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">read</span> -p <span class="string">"Input a number:"</span> num</div><div class="line"><span class="built_in">read</span> -p <span class="string">"Input name:"</span> name</div><div class="line"><span class="built_in">echo</span> <span class="string">"You have enterd number:<span class="variable">$num</span>, name:<span class="variable">$name</span>"</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> -e <span class="string">"1\nzhang"</span> | ./jiaohu.sh</div><div class="line">You have entered number:1, name:hello</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#or</span></div><div class="line"><span class="built_in">echo</span> -e <span class="string">"1\nzhang"</span> &gt; input.txt</div><div class="line">./jiaohu.sh &lt; input.txt</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#交互式输入自动化</span></div><div class="line"><span class="comment">#用expect实现自动化</span></div><div class="line">yum install -y expect</div><div class="line">vim auto_expect.sh</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#!/bin/expect</span></div><div class="line">spawn ./jiaohu.sh	<span class="comment">#spawn指定需要自动化哪一个命令</span></div><div class="line">expect <span class="string">"Input a number:"</span>	<span class="comment">#expect提供需要等待的消息</span></div><div class="line">send <span class="string">"1\n"</span>		<span class="comment">#send是要发送的消息</span></div><div class="line">expect <span class="string">"Input name:"</span></div><div class="line">send <span class="string">"zhang"</span></div><div class="line">expect eof	<span class="comment">#expect eof指明命令交互结束</span></div><div class="line"></div><div class="line">./auto_expect.sh</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="以文件之名"><a href="#以文件之名" class="headerlink" title="以文件之名"></a>以文件之名</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>Unix将操作系统中的一切都视为文件。</p>
<p><br></p>
<h2 id="生成任意大小的文件-dd"><a href="#生成任意大小的文件-dd" class="headerlink" title="生成任意大小的文件(dd)"></a>生成任意大小的文件(<code>dd</code>)</h2><p>由于各种原因，可能需要生成一个包含随机数据的文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#dd命令会克隆给定的输入内容，然后将一模一样的副本写到输出</span></div><div class="line"><span class="comment">#如果不指定if，dd会从stdin中读取输入；如果不指定of，dd会输出到stdout</span></div><div class="line"><span class="comment">#/dev/zero是一个字符设备，它会不断返回0值字节(\0)</span></div><div class="line"></div><div class="line">dd <span class="keyword">if</span>=/dev/zero of=junk.data bs=1M count=1</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="文本文件的交集与差集"><a href="#文本文件的交集与差集" class="headerlink" title="文本文件的交集与差集"></a>文本文件的交集与差集</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#comm命令用于两个文件之间的比较</span></div><div class="line"><span class="comment">#交集(intersection),差集(set difference), 求差</span></div><div class="line"><span class="comment">#comm必须使用排过序的文件作为输入</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">echo</span> -e <span class="string">"1\n2\n3"</span> &gt; A.txt &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"3\n2\n3"</span> &gt; B.txt</div><div class="line">sort -n A.txt -o A.txt &amp;&amp; sort -n B.txt -o B.txt</div><div class="line">comm A.txt B.txt</div><div class="line"><span class="comment">#输出第一列为A独有，第二列为B独有，第三列为交集</span></div><div class="line"></div><div class="line"></div><div class="line">comm A.txt B.txt -1 -2</div><div class="line"><span class="comment">#-1从输出中删除第一列，-2删除第二列，-3删除第三列</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="查找并删除重复文件"><a href="#查找并删除重复文件" class="headerlink" title="查找并删除重复文件"></a>查找并删除重复文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#重复文件指的是那些虽然名字不同但内容却一模一样的文件</span></div><div class="line"></div><div class="line">ls -lS	<span class="comment">#以文件大小排序，识别大小相等的文件</span></div><div class="line">md5sum	<span class="comment">#接下来计算这些文件的校验和</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="创建长路径目录"><a href="#创建长路径目录" class="headerlink" title="创建长路径目录"></a>创建长路径目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir -p /home/zhang/1/22/333 2&gt;/dev/null</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="文件权限、所有权和粘滞位"><a href="#文件权限、所有权和粘滞位" class="headerlink" title="文件权限、所有权和粘滞位"></a>文件权限、所有权和粘滞位</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#用户(user)，用户组(group)，其他用户(other)</span></div><div class="line"></div><div class="line">ll ./*</div><div class="line"><span class="comment">#d目录，c字符设备，b块设备，l符号链接，s套接字，p管道，-普通文件</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#用户还有一个称为setuid(S)的特殊权限，它出现在用户的x位置</span></div><div class="line"><span class="comment">#setuid权限允许用户以其拥有者的权限来执行可执行文件，即便这个文件是由其他用户运行的</span></div><div class="line">-rwSrw-r--</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#组也拥有一个setgid(S)权限，它出现在组的x位置</span></div><div class="line"><span class="comment">#它允许以同该目录拥有者所在组相同的有效组权限来运行可执行文件</span></div><div class="line">-rwxrwSr--</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#目录有一个特殊权限，叫做粘滞位(sticky bit)(T或t)，出现在其他用户的x位置</span></div><div class="line"><span class="comment">#当一个目录设置了粘滞位，只有创建该目录的用户才能删除目录中的文件,即便group和other有w权限</span></div><div class="line">-rwxr--rwT</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">chmod u=rwx g=rw o=r file1</div><div class="line">chmod u+x g-w file2</div><div class="line">chmod 744 file3</div><div class="line"></div><div class="line"></div><div class="line">chmod a+x . -R	<span class="comment">#以递归方式设置权限</span></div><div class="line">chown user.group . -R	<span class="comment">#以递归方式设置所有权</span></div><div class="line"></div><div class="line"></div><div class="line">chmod a+t dir1	<span class="comment">#设置粘滞位</span></div><div class="line"></div><div class="line"></div><div class="line">chmod +s fiel4</div><div class="line">chown root.root file4</div><div class="line">chmod +s file4</div><div class="line">./file4	<span class="comment">#每次file4都是以root运行</span></div><div class="line"></div><div class="line"><span class="comment">#setuid的使用不是无限制的，它只能应用在Linux ELF格式二进制，而不能用于脚本文件。</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="创建不可修改文件"><a href="#创建不可修改文件" class="headerlink" title="创建不可修改文件"></a>创建不可修改文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#不可修改(immutable),是保护文件不被修改的安全手段之一。</span></div><div class="line"><span class="comment">#一旦文件被设置为不可修改，任何用户(包括root)都不能修改，除非将其不可修改属性移除</span></div><div class="line"></div><div class="line">chattr	<span class="comment">#修改文件在Linux第二扩展文件系统(E2fs)上的特有属性</span></div><div class="line">chattr +i file1	<span class="comment">#这样就无法删除file1</span></div><div class="line">chattr -i file1</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="批量生成空白文件"><a href="#批量生成空白文件" class="headerlink" title="批量生成空白文件"></a>批量生成空白文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#touch命令可用来生成空白文件，如果文件存在，则可以用它修改文件的时间戳</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> &#123;1..100&#125;.txt;<span class="keyword">do</span></div><div class="line">touch <span class="variable">$name</span></div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"></div><div class="line">touch -a/-m	<span class="comment">#更改文件访问/修改时间</span></div><div class="line">touch -d <span class="string">"Thu Oct 31 14:20:13 CST 2017"</span> file1	<span class="comment">#指定特定时间戳</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="查找符号链接及其指向目标"><a href="#查找符号链接及其指向目标" class="headerlink" title="查找符号链接及其指向目标"></a>查找符号链接及其指向目标</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#符号链接(软链接)只不过是指向其他文件的指针</span></div><div class="line"></div><div class="line">ln -s /usr/bin /bin</div><div class="line">ls -l / | grep <span class="string">"^l"</span></div><div class="line">find / -maxdepth 1 -<span class="built_in">type</span> l</div><div class="line"></div><div class="line">readlink /bin	<span class="comment">#找出链接目标</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="列举文件类型统计信息"><a href="#列举文件类型统计信息" class="headerlink" title="列举文件类型统计信息"></a>列举文件类型统计信息</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#在Unix/Linux系统中，文件类型并不是由文件扩展名决定的</span></div><div class="line"></div><div class="line">file /etc/passwd</div><div class="line">file -b /etc/passwd</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="环回文件与挂载-mount"><a href="#环回文件与挂载-mount" class="headerlink" title="环回文件与挂载(mount)"></a>环回文件与挂载(<code>mount</code>)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#环回文件系统是指那些在文件中而非物理设备中创建的文件系统</span></div><div class="line"></div><div class="line">dd <span class="keyword">if</span>=/dev/zero of=loopback.file bs=1G count=1</div><div class="line">mkfs.ext4 loopback.file</div><div class="line">mount -o loop loopback.file /mnt/loopback	<span class="comment">#-o loop来挂载环回文件</span></div><div class="line">df -h</div><div class="line">umount /mnt/loopback</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#将ISO文件作为环回文件挂载</span></div><div class="line">mount -o loop linux.iso /mnt/iso</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="生成ISO文件以及混合ISO"><a href="#生成ISO文件以及混合ISO" class="headerlink" title="生成ISO文件以及混合ISO"></a>生成ISO文件以及混合ISO</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#可引导光盘自身具备引导能力，也可以运行操作系统或其他软件。不可引导光盘则做不到这些。</span></div><div class="line"></div><div class="line">cat /dev/cdrom  &gt; /dev/sdc	<span class="comment">#sdc指U盘</span></div><div class="line">dd <span class="keyword">if</span>=/dev/cdrom of=/dev/sdc	<span class="comment">#将ISO写入usb存储设备</span></div><div class="line">mkisofs -V <span class="string">"Label"</span> -o /dev/sdc /dev/cdrom</div><div class="line"></div><div class="line"></div><div class="line">cdrecord -v dev=/dev/cdrom image.iso</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="查找文件差异并进行修补"><a href="#查找文件差异并进行修补" class="headerlink" title="查找文件差异并进行修补"></a>查找文件差异并进行修补</h2><p>diff - compare files line by line</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#补丁文件(patch file)</span></div><div class="line"><span class="comment">#diff命令可以生成差异文件</span></div><div class="line"></div><div class="line">diff -u file1 file2	<span class="comment">#一体化形式输出</span></div><div class="line">diff -u file1 file2 &gt; diff.patch</div><div class="line">patch -p1 file1 &lt; diff.patch	<span class="comment">#得到file2</span></div><div class="line">patch -p1 file2 &lt; diff.patch	<span class="comment">#得到file1</span></div><div class="line">patch -R file1 &lt; diff.patch; patch -R file2 &lt; diff.patch	<span class="comment">#还原</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#diff也能够以递归的形式作用于目录，它对目录中所有内容生成差异输出</span></div><div class="line">diff -Naur dir1 dir2</div><div class="line"><span class="comment">#-N将所有确实文件视为空文件， -a将所有文件视为文本文件</span></div><div class="line"><span class="comment">#-u生成一体化输出， -r遍历目录下所有文件</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="head与tail"><a href="#head与tail" class="headerlink" title="head与tail"></a><code>head</code>与<code>tail</code></h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">head file1; tail file1	<span class="comment">#head与tail默认打印10行</span></div><div class="line">head -n 5 file1; tail -n 6 file1	<span class="comment">#指定行数</span></div><div class="line">head -n -5 file1	<span class="comment">#打印除了最后5行外所有行</span></div><div class="line">tail -n +(5+1) file1	<span class="comment">#打印除了开始5行外所有行</span></div><div class="line"></div><div class="line">tail -f /var/<span class="built_in">log</span>/nginx/access.log	<span class="comment">#--follow，动态关注文件</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="只列出目录的其他方法"><a href="#只列出目录的其他方法" class="headerlink" title="只列出目录的其他方法"></a>只列出目录的其他方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ls -d .</div><div class="line">ls -l . | grep &quot;^d&quot;</div><div class="line">ls -F . | grep &quot;/$&quot;</div><div class="line">find . -maxdepth 1 -type d</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="pushd和popd"><a href="#pushd和popd" class="headerlink" title="pushd和popd"></a>pushd和popd</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#在命令行中使用pushd和popd快速定位，pushd和popd以栈的方式运作</span></div><div class="line"><span class="comment">#当没有鼠标时，复制粘贴就不怎么实用了</span></div><div class="line"><span class="comment">#pushd和popd可以用于在多个目录之间进行切换而无需复制并粘贴目录路径</span></div><div class="line"></div><div class="line"><span class="built_in">pushd</span> /home/user1; <span class="built_in">pushd</span> /home/user2; <span class="built_in">pushd</span> /home/user3	<span class="comment">#将路径添加到栈</span></div><div class="line"><span class="built_in">pushd</span> +2	<span class="comment">#切换到/home/user3</span></div><div class="line"></div><div class="line"><span class="built_in">popd</span>	<span class="comment">#移除最近添加入栈的目录</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">cd</span> /root; <span class="built_in">cd</span> /home/user</div><div class="line"><span class="built_in">cd</span> -	<span class="comment">#回到上次的目录</span></div><div class="line"><span class="built_in">cd</span> ..	<span class="comment">#切换到上一级目录</span></div><div class="line"><span class="built_in">cd</span> ~	<span class="comment">#切换到用户主目录</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="统计文件的行数、单词数、字符数"><a href="#统计文件的行数、单词数、字符数" class="headerlink" title="统计文件的行数、单词数、字符数"></a>统计文件的行数、单词数、字符数</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#wc(word count)，是一个统计工具</span></div><div class="line"></div><div class="line">wc -l file1	<span class="comment">#统计行数</span></div><div class="line">wc -w file1	<span class="comment">#统计单词数</span></div><div class="line">wc -c file	<span class="comment">#统计字符数</span></div><div class="line">wc -L file	<span class="comment">#打印最长行长度</span></div><div class="line">wc file1	<span class="comment">#行、单词、字符数</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#tree命令是以图形化的树状结构打印文件和目录,在Linux发行版中默认未安装</span></div><div class="line"></div><div class="line">yum install -y tree</div><div class="line">tree /home/zhang</div><div class="line">tree /home/zhang -P <span class="string">"*.sh"</span>	<span class="comment">#只标记出.sh文件</span></div><div class="line">tree /home/zhang -I <span class="string">"*.sh"</span>	<span class="comment">#标记出除.sh文件外所有文件</span></div><div class="line">tree /home/zhang -h	<span class="comment">#显示大小</span></div><div class="line"></div><div class="line">tree /home/zhang -H http://localhost -o tree.html	<span class="comment">#以html形式输出目录树</span></div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="让文本飞"><a href="#让文本飞" class="headerlink" title="让文本飞"></a>让文本飞</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>shell脚本可以将<code>sed</code>, <code>awk</code>, <code>grep</code>, <code>cut</code>等这类优美的工具组合在一起，用于解决文本处理相关问题。</p>
<p><br></p>
<h2 id="正则表达式-re"><a href="#正则表达式-re" class="headerlink" title="正则表达式(re"></a>正则表达式(re</h2><p>)<br>正则表达式是一种用于文本匹配的形式小巧、具有高度针对性的编程语言。只依靠通配符技术，能够匹配的文本范围相当有限。<br></p>
<p><strong>正则表达式基本组成</strong></p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>行起始标记</td>
</tr>
<tr>
<td>$</td>
<td>行尾标记</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td>[]</td>
<td>匹配包含在[]中的任意一个字符</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配出[^]之外任意一个字符</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配[]中范围内的任意一个字符</td>
</tr>
<tr>
<td>？</td>
<td>重复0或1次</td>
</tr>
<tr>
<td>+</td>
<td>重复&gt;=1次</td>
</tr>
<tr>
<td>*</td>
<td>重复&gt;=0次</td>
</tr>
<tr>
<td>()</td>
<td>创建一个用于匹配的子串</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n, }</td>
<td>重复&gt;=n次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
<tr>
<td>\</td>
<td>转义字符</td>
</tr>
<tr>
<td>竖线l</td>
<td>匹配竖线l两边任意一项</td>
</tr>
</tbody>
</table>
<p><br></p>
<p><strong>POSIX字符类</strong></p>
<p>POSIX字符类(POSIX character class),是一个形如[:…:]的特殊元序列，它用于匹配特定的字符范围。<br></p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[:alnum:]</td>
<td>字母与数字字符</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>字母字符</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格与制表符</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>数字字符</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>小写字母</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>大写字母</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>标点符号</td>
</tr>
<tr>
<td>[:space:]</td>
<td>所有空白字符</td>
</tr>
</tbody>
</table>
<p><br></p>
<p><strong>元字符</strong></p>
<p>元字符(meta character)，是一种Perl风格的正则表达式，只有一部分文本处理工具支持它。<br></p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\b</td>
<td>单词边界</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界</td>
</tr>
<tr>
<td>\d</td>
<td>单个数字字符</td>
</tr>
<tr>
<td>\D</td>
<td>单个非数字字符</td>
</tr>
<tr>
<td>\w</td>
<td>单个单词字符(数字，字母和_)</td>
</tr>
<tr>
<td>\W</td>
<td>单个非单词字符</td>
</tr>
<tr>
<td>\s</td>
<td>单个空白字符</td>
</tr>
<tr>
<td>\S</td>
<td>单个非空白字符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
</tbody>
</table>
<p><br></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#匹配一个ipv4地址</span></div><div class="line">[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#匹配一个邮箱地址</span></div><div class="line">[\w]+@[\w]\.com</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用grep在文件中搜索文本"><a href="#用grep在文件中搜索文本" class="headerlink" title="用grep在文件中搜索文本"></a>用<code>grep</code>在文件中搜索文本</h2><p><code>grep</code>命令是Unix中用于文本搜索的工具，它能够接受正则表达式和通配符。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">grep <span class="string">"匹配文本/通配符"</span> file1 file2... --color=auto	<span class="comment">#重点标记匹配</span></div><div class="line">grep -E <span class="string">"正则表达式"</span> file</div><div class="line">egrep <span class="string">"正则"</span> file</div><div class="line"></div><div class="line"></div><div class="line">grep -v	<span class="comment">#反向匹配</span></div><div class="line">grep -c	<span class="comment">#统计匹配行数</span></div><div class="line">grep -n	<span class="comment">#打印出匹配的行号</span></div><div class="line">grep -o	<span class="comment">#唯一匹配</span></div><div class="line">grep -l	<span class="string">"匹配"</span> file1 file2	<span class="comment">#返回匹配的文件名</span></div><div class="line">grep -R	<span class="comment">#递归匹配</span></div><div class="line">grep -i	<span class="comment">#忽略大小写</span></div><div class="line">grep -e <span class="string">"匹配1"</span> -e <span class="string">"匹配2"</span>	<span class="comment">#匹配多个样式</span></div><div class="line">grep -f match.txt file1	<span class="comment">#从match.txt文件读取匹配</span></div><div class="line">grep <span class="string">"匹配"</span> --include=*.&#123;sh,txt&#125; --exclude=*.<span class="built_in">log</span> --exclude-dir=/home/user -r /home	<span class="comment">#包括或排除文件</span></div><div class="line">-A/-B n	<span class="comment">#输出匹配 之后/之前 n行</span></div><div class="line">-c n	<span class="comment">#输出匹配 前后 n行</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用cut按列切分文件"><a href="#用cut按列切分文件" class="headerlink" title="用cut按列切分文件"></a>用<code>cut</code>按列切分文件</h2><p><code>cut</code>是一个将文本按列进行切分的小工具，它也可以指定每列定界符。在cut的术语中，每列都是一个字段。<br></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#制表符'\t' 是cut默认的定界符</span></div><div class="line">cut -d<span class="string">' '</span> -f1 1.txt	<span class="comment">#-d指定分隔符，-f打印第几个字段</span></div><div class="line">cut -f1,2,3	<span class="comment">#打印1,2，3列</span></div><div class="line">-c字符；	-b字节；</div><div class="line">cut -c 1-5 1.txt	<span class="comment">#打印1-5字符</span></div><div class="line">cut -c -2 1.txt	<span class="comment">#打印前2个字符</span></div><div class="line">cut -c 3-	<span class="comment">#打印第3个字符到行尾</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="统计特定文件词频"><a href="#统计特定文件词频" class="headerlink" title="统计特定文件词频"></a>统计特定文件词频</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#单词解析可以用 关联数组,正则表达式配合sed,awk,grep等工具来完成</span></div><div class="line"><span class="comment">#关联数组中，将单词作为数组索引，单词次数作为数组值</span></div><div class="line"></div><div class="line">egrep -o <span class="string">"\b[:alpha:]+\b"</span>	<span class="comment">#匹配单词</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="sed入门"><a href="#sed入门" class="headerlink" title="sed入门"></a><code>sed</code>入门</h2><p><code>sed</code>是stream editor(流编辑器)的缩写，它是文本处理中非常重要的工具。能够完美地配合正则表达式使用。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#sed - stream editor for filtering and transforming text</span></div><div class="line"><span class="comment">#字符/在sed中最为定界符使用</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#替换</span></div><div class="line"><span class="comment">#sed 's/匹配样式/替代字符串/'</span></div><div class="line">sed <span class="string">'s/pattern/repalce/'</span> file	<span class="comment">#替换</span></div><div class="line">sed -i <span class="string">'s/pattern/repalce/'</span> file	<span class="comment">#将替换应用于file</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"1.txt"</span> &gt; 1.txt &amp;&amp; sed <span class="string">'s/txt/haha'</span> 1.txt	<span class="comment">#在输出中用haha替换txt</span></div><div class="line">sed -i <span class="string">'s/txt/haha/'</span> 1.txt	<span class="comment">#将1.txt文件中的txt用haha替换掉</span></div><div class="line"><span class="comment">#-i选项替换原文件</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"hahaha"</span> | sed <span class="string">'s/ha/HA/g'</span>	<span class="comment">#全部替换</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"hahaha"</span>	| sed <span class="string">'s/ha/HA/2g'</span>	<span class="comment">#指定位置替换，从第2处开替换全局</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#移除匹配样式的行</span></div><div class="line">sed <span class="string">'/pattern/d</span></div><div class="line"><span class="string">sed '</span>/^$/d<span class="string">'	##移除空白行</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#在sed中用&amp;标记已匹配字符串</span></div><div class="line"><span class="string">echo "A wonderful goal" | sed '</span>s/\w\+/[&amp;]/g<span class="string">'	#\w\+匹配每一个单词</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#子串匹配标记\1,\2...</span></div><div class="line"><span class="string">echo "1st 2nd 3rd" | sed '</span>s/\(\w\+\) \(\w\+\) \(\w\+\)/\2 \1 \3/<span class="string">'</span></div><div class="line"><span class="string">2nd 1st 3rd</span></div><div class="line"><span class="string">#将\2和\1交换次序，(),+等在sed中要转义，否则要报错</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#组合多个表达式</span></div><div class="line"><span class="string">sed '</span>expression1; expression2; ...</div><div class="line"><span class="built_in">echo</span> <span class="string">"aabbcc"</span> | sed <span class="string">'s/a/A/; s/b/B/; s/c/C/g'</span></div><div class="line">AaBbCC</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#双引号 " " 内的特殊符号（如$等），可以保有原本的特性</span></div><div class="line"><span class="comment">#单引号 ' ' 内的特殊字符则仅为一般字符（纯文本）</span></div><div class="line"><span class="comment">#引用</span></div><div class="line">text=hello</div><div class="line"><span class="built_in">echo</span> <span class="string">'hello world'</span> | sed <span class="string">"s/<span class="variable">$text</span>/HELLO/"</span></div><div class="line">HELLO world</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="awk入门"><a href="#awk入门" class="headerlink" title="awk入门"></a><code>awk</code>入门</h2><p><code>awk</code>被设计用于数据流，它可以对列和行进行操作。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#awk ‘begin&#123;print "start"&#125; pattern &#123;command&#125; end&#123;print "end"&#125;’ file</span></div><div class="line"></div><div class="line">awk <span class="string">'&#123;sum += $1&#125;; &#123;print sum&#125;'</span></div><div class="line"></div><div class="line"><span class="comment">#awk脚本由:begin块、end块和能使用模式(pattern)匹配的通用语句块 组成</span></div><div class="line"><span class="comment">#3个部分都是可选的</span></div><div class="line"><span class="comment">#awk也可以从stdin中读取内容</span></div><div class="line"></div><div class="line">cat /etc/passwd | awk -F: <span class="string">'&#123;print $1&#125;'</span>	<span class="comment">#-F指定界定符</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#awk中的特殊变量</span></div><div class="line"><span class="comment">#NR：记录数量(number of records)，对应于当前行号</span></div><div class="line"><span class="comment">#NF：字段数量(number of fields)，对应于当前行的字段数</span></div><div class="line"><span class="comment">#$0：执行过程中当前行的文本内容</span></div><div class="line"><span class="comment">#$1,$2...$NF：第1个/2个.../最后一个 字段的内容</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> -e <span class="string">"L1 1\nL2 22\nL3 333"</span> | awk <span class="string">'&#123;print NR NF $0 $1 $2&#125;'</span></div><div class="line"><span class="comment"># NR NF $0    $1  $2 $NF=最后一个=$2</span></div><div class="line">  1  2  L1 1  L1  1  1</div><div class="line">  2  2  L2 2  L2  2  2</div><div class="line">  3  2  L3 3  L3  3  3</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#将外部变量传递给awk</span></div><div class="line"><span class="comment">#-v选项可将外部值传递给awk</span></div><div class="line"><span class="comment">#  -v var=val  --assign=var=val</span></div><div class="line"></div><div class="line">var=<span class="string">'12345'</span></div><div class="line"><span class="built_in">echo</span> | awk -v v1=<span class="variable">$var</span> <span class="string">'&#123;print v1&#125;'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#多个变量</span></div><div class="line">var1=111; var2=222</div><div class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123;print v1,v2&#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#变量来自文件而非标准输入</span></div><div class="line">awk <span class="string">'&#123;print v1,v2&#125;'</span> v1=<span class="variable">$var1</span> v2=<span class="variable">$var2</span> file</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#用样式对awk进行过滤处理</span></div><div class="line">awk <span class="string">'NR &lt; 3,NR==4'</span> 1.txt	<span class="comment">#行号&lt;5的行</span></div><div class="line">awk <span class="string">'/linux/'</span> 1.txt	<span class="comment">#匹配带有linux的行（可用re）</span></div><div class="line">awk <span class="string">'!/linux/'</span> 1.txt <span class="comment">#!匹配不带linux的行</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#设置定界符</span></div><div class="line">awk -F: <span class="string">'&#123;print $1&#125;'</span> /etc/passwd</div><div class="line">awk <span class="string">'&#123;FS=":"&#125; &#123;print $1&#125;'</span> /etc/passwd</div><div class="line">awk <span class="string">'&#123;FS=":"; print $1&#125;'</span> /etc/passwd</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#从awk中读取命令输出，用getline读取行</span></div><div class="line"><span class="built_in">echo</span> | awk <span class="string">'&#123;"grep root /etc/passwd" | getlin out; print out&#125;'</span></div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#在awk中使用循环</span></div><div class="line">awk <span class="string">'&#123;for(i=1;i&lt;4;i++) &#123;print $i&#125;&#125;'</span> 2.txt	<span class="comment">#输出第1,2,3列</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="对文件中的行、单词、字符进行迭代"><a href="#对文件中的行、单词、字符进行迭代" class="headerlink" title="对文件中的行、单词、字符进行迭代"></a>对文件中的行、单词、字符进行迭代</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#迭代文件中的每一行</span></div><div class="line"><span class="built_in">echo</span> -e <span class="string">"1\n22\n333"</span> | <span class="keyword">while</span> <span class="built_in">read</span> line;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$line</span>;<span class="keyword">done</span></div><div class="line">grep <span class="string">"bash"</span> /etc/passwd | <span class="keyword">while</span> <span class="built_in">read</span> line;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$line</span>;<span class="keyword">done</span></div><div class="line"><span class="comment">#1</span></div><div class="line"><span class="comment">#22</span></div><div class="line"><span class="comment">#333</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#迭代一行中的每一个单词</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"1 22 333"</span> | <span class="keyword">while</span> <span class="built_in">read</span> line;<span class="keyword">do</span> <span class="keyword">for</span> word <span class="keyword">in</span> <span class="variable">$line</span>;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$word</span>;<span class="keyword">done</span>;<span class="keyword">done</span></div><div class="line"><span class="comment">#1</span></div><div class="line"><span class="comment">#22</span></div><div class="line"><span class="comment">#333</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#迭代一个单词中的每一个字符</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"abc"</span> | <span class="keyword">while</span> <span class="built_in">read</span> line;</div><div class="line"><span class="keyword">do</span></div><div class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> <span class="variable">$line</span>;</div><div class="line">	<span class="keyword">do</span></div><div class="line">    	<span class="keyword">for</span>((i=0;i&lt;<span class="variable">$&#123;#word&#125;</span>;i++));</div><div class="line">		<span class="keyword">do</span></div><div class="line">        	<span class="built_in">echo</span> <span class="variable">$&#123;word:i:1&#125;</span>;</div><div class="line">		<span class="keyword">done</span>;</div><div class="line">	<span class="keyword">done</span>;</div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="comment">#写成一行</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"abc"</span> | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span> <span class="keyword">for</span> word <span class="keyword">in</span> <span class="variable">$line</span>; <span class="keyword">do</span> <span class="keyword">for</span>((i=0;i&lt;<span class="variable">$&#123;#word&#125;</span>;i++)); <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$&#123;word:i:1&#125;</span>; <span class="keyword">done</span>; <span class="keyword">done</span>; <span class="keyword">done</span></div><div class="line"><span class="comment">#a</span></div><div class="line"><span class="comment">#b</span></div><div class="line"><span class="comment">#c</span></div><div class="line"><span class="comment">#$&#123;#word&#125;返回变量word的长度</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="按列合并文件-paste"><a href="#按列合并文件-paste" class="headerlink" title="按列合并文件(paste)"></a>按列合并文件(<code>paste</code>)</h2><p>可以使用<code>paste</code>命令实现列拼接<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#paste - merge(整合) lines of files</span></div><div class="line"><span class="built_in">echo</span> -e  <span class="string">"1\n2\n3"</span> &gt; 1.txt &amp;&amp; <span class="built_in">echo</span> -e <span class="string">"Line1\nLine2\nLine3"</span> &gt; 2.txt</div><div class="line">paste 1.txt 2.txt</div><div class="line">1	Line1</div><div class="line">2	Line2</div><div class="line">3	Line3</div><div class="line"><span class="comment">#默认定界符是制表符，用-d指定</span></div><div class="line">paste 1.txt 2.txt -d<span class="string">','</span></div></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="打印文件或行中的第n个单词或n列"><a href="#打印文件或行中的第n个单词或n列" class="headerlink" title="打印文件或行中的第n个单词或n列"></a>打印文件或行中的第n个单词或n列</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">awk -F<span class="string">':'</span> <span class="string">'&#123;print $1,$3&#125;'</span> file1</div><div class="line">cut -d<span class="string">':'</span> -f 1,3 file1</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="打印不同行或样式之间的文本"><a href="#打印不同行或样式之间的文本" class="headerlink" title="打印不同行或样式之间的文本"></a>打印不同行或样式之间的文本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'NR==1,NR==10'</span> /etc/passwd</div><div class="line">awk <span class="string">'NR==1,NR==10'</span> /etc/passwd | awk -F<span class="string">":"</span> <span class="string">'&#123;print $1,$NF&#125;'</span> <span class="comment">#打印特定行内的特定列</span></div><div class="line"></div><div class="line">awk <span class="string">'/start_pattern/, /end_pattern/'</span> file	<span class="comment">#打印start到end之间的内容,可使用re</span></div><div class="line">awk <span class="string">'/root/, /zhang/'</span> /etc/passwd	<span class="comment">#打印root到zhang之间内容</span></div><div class="line">awk <span class="string">'/^ro.?t'</span>/, /bash$/<span class="string">' /etc/pass</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="以逆序形式打印行"><a href="#以逆序形式打印行" class="headerlink" title="以逆序形式打印行"></a>以逆序形式打印行</h2><p>可以使用<code>awk</code>, <code>tac</code>完成。tac就是反过来的cat。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#tac - 反转显示文件中的行，行内的内容无法用tac反向排列</span></div><div class="line">tac 1.txt</div><div class="line">awk <span class="string">'&#123;lifo[NR]=$0; lno=NR&#125; END&#123; for(;lno&gt;-1;lno--) &#123;print lifo[lno]&#125;;&#125;'</span> 1.txt</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="解析文本中的电子邮件和URL"><a href="#解析文本中的电子邮件和URL" class="headerlink" title="解析文本中的电子邮件和URL"></a>解析文本中的电子邮件和URL</h2><p>从给定的文件中解析出所需要的文本是我们从事文本处理时的一项任务。</p>
<p>grep, egrep, fgrep - print lines matching a pattern</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#egrep</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#匹配一个邮箱地址</span></div><div class="line">egrep -o <span class="string">'[a-zA-Z0-9.]+@[0-9a-zA-Z.]+\.[a-zA-Z]&#123;2,4&#125;'</span> emails.txt</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#匹配一个URL地址</span></div><div class="line">egrep -o <span class="string">"http://[a-zA-Z0-9.]+\.[a-zA-Z]&#123;2,3&#125;"</span> urls.txt</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="打印某个样式之前-之后n行-grep"><a href="#打印某个样式之前-之后n行-grep" class="headerlink" title="打印某个样式之前/之后n行(grep)"></a>打印某个样式之前/之后n行(<code>grep</code>)</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep <span class="string">"zhang"</span> /etc/passwd -A 5	<span class="comment">#Ater</span></div><div class="line">grep <span class="string">"zhang"</span> /etc/passwd -B 5	<span class="comment">#Before</span></div><div class="line">grep <span class="string">"zhang"</span> /etc/passwd -C 5	<span class="comment">#前后五行都打印</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="在文件中移除包含某个单词的句子"><a href="#在文件中移除包含某个单词的句子" class="headerlink" title="在文件中移除包含某个单词的句子"></a>在文件中移除包含某个单词的句子</h2><p>只要能写出正确的正则表达式(Regular Expression)，那就手到擒来</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'s/[^.]*handsome boy[^.]*\.//g'</span> file.txt	<span class="comment">#句子以.结束</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="文本切片与参数操作"><a href="#文本切片与参数操作" class="headerlink" title="文本切片与参数操作"></a>文本切片与参数操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#替换变量内容中的部分文字</span></div><div class="line">var=<span class="string">"One two three"</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var/t/T&#125;</span>	<span class="comment">#只替换了一个</span></div><div class="line"><span class="comment">#One Two three</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定字符串起始位置和长度</span></div><div class="line"><span class="comment">#$&#123;变量:开始部分:长度&#125;</span></div><div class="line"><span class="variable">$&#123;vari:start:length&#125;</span></div><div class="line"><span class="built_in">echo</span> &#123;var:0:2&#125;	<span class="comment">#On</span></div><div class="line"><span class="built_in">echo</span> &#123;var:1:6&#125;	<span class="comment">#ne two</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#起始字符的索引是0,将最后一个字符索引记为-1</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:(-1)&#125;</span>	<span class="comment">#e</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:(-3):3&#125;</span>	<span class="comment">#ree</span></div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="一团乱麻？没这回事"><a href="#一团乱麻？没这回事" class="headerlink" title="一团乱麻？没这回事"></a>一团乱麻？没这回事</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>本章会研究一些用于解析网站内容、下载数据、发送数据表单以及网站颇为任务自动化之类的实例。我们可以仅用几行脚本就将很多原本需要通过浏览器交互进行的活动管理自动化。通过命令行工具利用HTTP协议所提供的功能，我们可以用脚本解决大部分Web自动化的问题。</p>
<p><br></p>
<h2 id="网站下载-wget-curl"><a href="#网站下载-wget-curl" class="headerlink" title="网站下载(wget,curl)"></a>网站下载(<code>wget</code>,<code>curl</code>)</h2><p>使用一些命令行下载工具，从给定的URL中下载文件或网页。<br></p>
<p>wget是一个用于文件下载的命令行工具，选项多且用法灵活。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Wget - The non-interactive(非交互式) network downloader</span></div><div class="line"></div><div class="line">wget URL1 URL2...</div><div class="line">wget http://xxx.com/nginx-1.12.0.tag.gz</div><div class="line">wget https://xxx/a.rpm http://xxxx/bb.rpm</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定文件名，指定信息输出(wget默认是stdout)</span></div><div class="line">wget http://mirrors.aliyun.com/repo/Centos-7.repo -O aliyun.repo -o ./wget.log</div><div class="line">wget URL -t 5	<span class="comment">#-t，重试次数</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#下载限速</span></div><div class="line">wget --<span class="built_in">limit</span>-rate=10m URL	<span class="comment">#下载限速</span></div><div class="line">wget -Q 100m URL	<span class="comment">#指定下载配额</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#端点续传</span></div><div class="line"><span class="comment">#wget进行的下载在完成前被中断，从断点开始下载</span></div><div class="line">wget -c URL</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#用cURL下载</span></div><div class="line"><span class="comment">#cURL是一个比wget更强大的高级命令工具</span></div><div class="line"><span class="comment">#和wget不同，curl并不将下载数据写入文件，而是写入stdout，因此必须重定向到文件</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#复制或镜像整个网站</span></div><div class="line"><span class="comment">#wget有一个选项可以使其像爬虫一样以递归方式手机网页上所有URL链接，并逐个下载</span></div><div class="line"><span class="comment">#这样一来就可以下载一个网站的所有页面</span></div><div class="line">wget --mirror URL</div><div class="line"><span class="comment">#-m(--mirror) -N -r -l inf --no-remove-listing 的缩写形式。</span></div><div class="line">或 wget -r -N -l DEPTH URL</div><div class="line"><span class="comment">#-r递归下载，-l指定递归深度，-N(timestamp)只获取比本地时间新的文件</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#访问需要认证的HTTP或FTP页面</span></div><div class="line">wget --user <span class="string">"username"</span> --password <span class="string">"pass"</span> URL</div><div class="line"><span class="comment">#如未在命令行内输入密码，则会由网页提示手动输入</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="以格式化纯文本下载网页-links"><a href="#以格式化纯文本下载网页-links" class="headerlink" title="以格式化纯文本下载网页(links)"></a>以格式化纯文本下载网页(<code>links</code>)</h2><p>网页其实就是包含HTML标记和其他诸如Javascript，CSS等元素的HTML页面。HTML标记是网页的基础，也许需要解析网页来查找特定的内容。<br></p>
<p>links,是一个基于命令行的Web浏览器</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#links - lynx-like alternative character mode WWW browser</span></div><div class="line"></div><div class="line"><span class="comment">#在命令行中浏览一个网页</span></div><div class="line">links www.baidu.com</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#以ASCII形式下载网页</span></div><div class="line">links --dump URL &gt; URL.txt</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#打开本地html文件</span></div><div class="line">links 1.html</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="cURL入门"><a href="#cURL入门" class="headerlink" title="cURL入门"></a>cURL入门</h2><p>cURL支持包括HTTP、HTTPS、FTP在内的众多协议。它还支持POST、cookie、认证、从指定偏移处下载部分文件、参照页(referer)、用户代理字符串、扩展头部(extra header)、限速、文件大小限制、进度条等特性。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#curl - transfer a URL</span></div><div class="line"><span class="comment">#cURL通常将下载文件输出到stdout，将进度信息输出到stderr</span></div><div class="line"><span class="comment">#要想避免显示进度信息，可使用--silent</span></div><div class="line"><span class="comment">#curl可用来下载、发送各种HTTP请求、指定HTTP头部等操作</span></div><div class="line"></div><div class="line">curl URL --silent	<span class="comment">#输出到stdout</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-O写入文件，文件名从URL中解析</span></div><div class="line">curl http://www.baidu.com/index.html -O --silent	<span class="comment">#创建index.html</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-o将数据写入指定文件</span></div><div class="line">curl URL -o baidu.html --progress	<span class="comment">#--progress显示进度条</span></div><div class="line">links baidu.html</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#端点续传</span></div><div class="line"><span class="comment">#和wget不同，cURL包含更高级的下载恢复特性，能够从特定的文件偏移处继续下载</span></div><div class="line"><span class="comment">#curl可以通过指定一个偏移量来下载部分文件</span></div><div class="line">手动：curl URL/file -C offset	<span class="comment">#偏移量以Byte为单位的整数</span></div><div class="line">自动：curl -C -URL	<span class="comment">#自动续传</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#用cURL设置参照页字符串, --referer</span></div><div class="line"><span class="comment">#参照页(referer)是位于HTTP头部中的一个字符串，用来标识用户从哪个页面到达当前页面的</span></div><div class="line"><span class="comment">#如果用户点击网页A中某个链接，转到了网页B。那么网页B头部的referer会包含网页A的URL</span></div><div class="line">curl --referer Referer_URL target_URL</div><div class="line">curl --referer http://www.baidu.com http://jianshu.com</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#用cURL设置cookie, --cookie</span></div><div class="line"><span class="comment">#可以用curl来存储HTTP操作过程中使用到的cookie</span></div><div class="line"><span class="comment">#cookie用key=value形式，指定多个用 分号 分隔</span></div><div class="line">curl URL --cookie <span class="string">"user=AAA;name=bbb"</span></div><div class="line">curl URL --cookie-jar cookie.txt	<span class="comment">#将cookie另存为</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#用cURL设置用户代理字符串, --user-agent</span></div><div class="line"><span class="comment">#如果不指定代理，一些需要用户代理的网页就无法显示</span></div><div class="line">curl URL --user-agent(-A) <span class="string">"Mozilla"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#用-H "头部信息"传递多个头部信息</span></div><div class="line">curl -</div><div class="line">H <span class="string">"Host:www.haha.com"</span> -H <span class="string">"Accept-language: en"</span> URL</div><div class="line"></div><div class="line"><span class="comment">#限定cURL可占用的带宽</span></div><div class="line">curl URL --<span class="built_in">limit</span>-rate 10m</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定最大下载量</span></div><div class="line">curl URL --max-filesize 大小(Bytes)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#用cURL进行认证，-u username:password指定用户名和密码</span></div><div class="line">curl -u user:pass URL</div><div class="line">curl -u user URL	<span class="comment">#手动输入密码</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#只打印响应头部信息(无数据部分), -I</span></div><div class="line">curl -I URL</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="从命令行访问163邮箱"><a href="#从命令行访问163邮箱" class="headerlink" title="从命令行访问163邮箱"></a>从命令行访问163邮箱</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -u user http://mail.163.com</div><div class="line"><span class="comment">#手动输入密码</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="制作图片抓取器及下载工具"><a href="#制作图片抓取器及下载工具" class="headerlink" title="制作图片抓取器及下载工具"></a>制作图片抓取器及下载工具</h2><p>可以用脚本解析图像文件并将图片自动下载下来。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">curl -s URL | grep -o <span class="string">"&lt;img src=[^&gt;]*&gt;"</span> | sed <span class="string">'s/&lt;img src=//g; s/&gt;//g'</span> &gt; img.list</div><div class="line"><span class="comment">#匹配图片的URL，可能还需要细化修改</span></div><div class="line"><span class="comment">#不同的URL可能有不同的规则，根据实际情况取出img的URL</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#下载图片</span></div><div class="line">wget <span class="variable">$URL</span> 或 curl -s -O <span class="variable">$URL</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="查找网站中的无效链接-lynx"><a href="#查找网站中的无效链接-lynx" class="headerlink" title="查找网站中的无效链接(lynx)"></a>查找网站中的无效链接(<code>lynx</code>)</h2><p>将查找无效链接的工作自动化，那就比纯手动厉害多了！</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">lynx -traversal URL <span class="comment">#会将URL中所有链接生成到reject.dat文件中</span></div><div class="line">sort -u reject.dat | <span class="keyword">while</span> <span class="built_in">read</span> link</div><div class="line"><span class="keyword">do</span></div><div class="line">	output=`curl -I <span class="variable">$link</span> -s | grep <span class="string">"HTTP/.*OK"</span>`</div><div class="line">    <span class="keyword">if</span> [[ -z <span class="variable">$output</span> ]]</div><div class="line">    <span class="keyword">then</span></div><div class="line">    	<span class="built_in">echo</span> <span class="variable">$link</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span> &lt; links.txt</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="跟踪网站变更-curl-diff"><a href="#跟踪网站变更-curl-diff" class="headerlink" title="跟踪网站变更(curl+diff)"></a>跟踪网站变更(<code>curl+diff</code>)</h2><p>可以编写一个定期运行的变更跟踪器(change tracker)，一旦发生变更，跟踪器便会发出声音或发送提示信息。<br>在不同时间检索网站，然后利用 <code>diff</code> 命令进行比对。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl URL --silent -o `date +%F`.html	<span class="comment">#第一次</span></div><div class="line">curl URL --silent -o `date +%F`.html	<span class="comment">#第二次</span></div><div class="line">diff -u 第一次 第二次</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="以POST方式发送网页并读取响应"><a href="#以POST方式发送网页并读取响应" class="headerlink" title="以POST方式发送网页并读取响应"></a>以POST方式发送网页并读取响应</h2><p>POST 和 GET 是HTTP协议中用于发送或检索信息的两种请求类型。<br>在GET请求方式中，利用网页的URL来发送参数(“键-值”)；而POST方式用于提交表单，如提交用户名、密码以及检索登录页面等。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl URL -d “postarg=AABBCC” <span class="comment">#-d,http post data</span></div><div class="line">curl URL -d <span class="string">"post1=key1&amp;post2=key2&amp;post3..."</span>	<span class="comment">#指定多个数据</span></div><div class="line"></div><div class="line">wget URL -post-data <span class="string">"post1=key1"</span></div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="Plan-B"><a href="#Plan-B" class="headerlink" title="Plan B"></a>Plan B</h1><p><br></p>
<h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><p>提取快照和备份数据都是重要的工作，我们可以通过shell脚本来实现备份自动化。<br>归档和压缩对于SA来说同样很重要，有多种压缩格式。<br>加密是一种保护数据的方法，为了减少加密数据的大小，文件在加密前通常需要先归档和压缩。</p>
<p><br></p>
<h2 id="用tar归档"><a href="#用tar归档" class="headerlink" title="用tar归档"></a>用<code>tar</code>归档</h2><p><code>tar</code>命令可以用来归档文件(tar archives tar)。可以将多个文件和文件夹打包为单个文件，同时还能保留所有的文件属性。<br>由<code>tar</code>命令创建的文件通常称为tarball。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#归档文件，-c(create file)</span></div><div class="line">tar -cf 1.tar [sources]	<span class="comment">#-f(specify filename)指定文件名</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#文件名必须紧跟在-f之后</span></div><div class="line">tar -cvf txt.tar *.txt	<span class="comment">#-v(verbose)详细信息</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#向已归档文件中添加文件，-r</span></div><div class="line">tar -rvf txt.tar *.html</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#列出归档文件中的内容，-t</span></div><div class="line">tar -tf txt.tar	<span class="comment">#列出归档内容</span></div><div class="line">tar -tvf txt.tar	<span class="comment">#列出内容详细信息</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#从归档文件中提取文件或文件夹，-x(exact)</span></div><div class="line">tar -xf txt.tar	<span class="comment">#默认提取到当前目录</span></div><div class="line"><span class="comment">#-C指定提取目录</span></div><div class="line">tar -xvf txt.tar -C /dir/path</div><div class="line"><span class="comment">#只提取归档中特定文件</span></div><div class="line">tar -xf txt.tar 1.txt 1.html -C /tmp	<span class="comment">#只会提取1.txt和1.html文件</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#在tar中使用stdin和stdout</span></div><div class="line">tar -cvf - *.text | tar -xvf - -C /tmp</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#拼接两个归档文件，-A</span></div><div class="line">tar -Af txt.tar html.tar</div><div class="line">tar -tvf txt.tat	<span class="comment">#验证是否成功</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#添加选项，可以将指定的任意文件加入到归档文件中。如果同名文件已存在，不会覆盖源文件，那么结果就是归档中包含了多个同名文件</span></div><div class="line"><span class="comment">#通过检查时间戳来更新对党文件中的内容，-u</span></div><div class="line"><span class="comment">#只有比归档文件中同名文件 更新(newer) 才添加</span></div><div class="line">tar -uvf html.tar 1.html</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#比较归档文件与文件系统中的内容，-d</span></div><div class="line">tar -df txt.tar 1.txt 2.txt</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#从归档文件中删除文件，--delete</span></div><div class="line">tar -f txt.tar --delete 1.txt 2.txt</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#从归档文件中排除部分文件,--exclude</span></div><div class="line">tar -cf all.tar ./* --exclude=<span class="string">"*.html"</span>	<span class="comment">#排除.html文件</span></div><div class="line">tar -cvf txt.tar *.txt --exclude=<span class="string">"1.txt"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#打印总字节数,--totals</span></div><div class="line">tar -cf all.txt ./* --totals</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#压缩tar归档文件，指定不同压缩格式</span></div><div class="line"></div><div class="line"><span class="comment">#-z,	.tar.gz</span></div><div class="line"><span class="comment">#-j,	.tar.bz2</span></div><div class="line"><span class="comment">#--lzma,	.tar.lzma,</span></div><div class="line"><span class="comment">#.tar.lzo</span></div><div class="line">tar -czvf txt.tar.gzip *.txt</div><div class="line">tar -xzvf txt.tar -C /dir/path</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#tar后删除原文件</span></div><div class="line">tar -czvf txt.tar.gz ./txt --remove-files</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用cpio归档"><a href="#用cpio归档" class="headerlink" title="用cpio归档"></a>用<code>cpio</code>归档</h2><p><code>cpio</code>是类似于tar的另一种归档格式。它多用于RPM软件包、Linux内核和initramfs文件等。<br>cpio通过stdin获取输入，并将归档写入stdout。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">touch file&#123;1..4&#125;</div><div class="line"></div><div class="line"><span class="built_in">echo</span> file1 file2 file3 file4 | cpio -ov file.cpio</div><div class="line"><span class="comment">#-o指定输出，-v打印归档文件列表</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-i指定输入，-t列出归档中文件</span></div><div class="line">cpio -it &lt; file.cpio</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用gunzip或gzip压缩"><a href="#用gunzip或gzip压缩" class="headerlink" title="用gunzip或gzip压缩"></a>用<code>gunzip</code>或<code>gzip</code>压缩</h2><p>gzip是GNU/Linux下常用压缩格式。<code>gzip</code>,<code>gunzip</code>都可处理gzip压缩文件类型。<br><code>gzip</code>只能够压缩单个文件，而无法对目录和多个文件进行归档。因此需要先交给<code>tar</code>，然后再用<code>gzip</code>压缩</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">gzip file	<span class="comment">#file.gz，会覆盖原文件</span></div><div class="line">gunzip file.gz	<span class="comment">#file，也会删除原文件</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#列出压缩文件的属性信息，-l</span></div><div class="line">gzip -l file.gz</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定gzip的压缩级别，--fast或--best</span></div><div class="line">--fast	最低压缩比，最快速度完成</div><div class="line">--best	最高压缩比，最慢速度完成</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#将gzip与归档文件结合，-z</span></div><div class="line">tar -czvf txt.tar.gzip ./*.txt</div><div class="line"><span class="comment">#-a指定从文件扩展名自动判断压缩格式</span></div><div class="line">tar -cavf txt.tar.gzip ./*.txt</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#tar只能从命令行中接收有限个文件，要解决这个问题，可以写一个循环并添加-r选项</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#解压缩，-x</span></div><div class="line">tar -xzvf txt.tar.gzip</div><div class="line">tar -xavf txt.tar.gzip -C /dir/path</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用bunzip或bzip压缩"><a href="#用bunzip或bzip压缩" class="headerlink" title="用bunzip或bzip压缩"></a>用<code>bunzip</code>或<code>bzip</code>压缩</h2><p><code>bzip2</code>通常能够生成比gzip更小(压缩比更高)的文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">bzip2 file	<span class="comment">#file.bz2,同理会覆盖原文件</span></div><div class="line">bzip2 file -k	<span class="comment">#保留原文件</span></div><div class="line">bunzip2 file.bz2	<span class="comment">#解压缩</span></div><div class="line">bunzip file.bz2 -k</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#从stdin读入并写到stdout</span></div><div class="line">cat file | bzip2 -c &gt; file.bz2</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#将bzip2与归档文件结合，-j</span></div><div class="line">tar -cvjf 1.tar.bz2 ./1.*</div><div class="line">tar -cavf 1.tar.bz2 ./1.*	<span class="comment">#-a根据文件扩展名自动判断压缩格式</span></div><div class="line">tar -xjvf 1.tar.bz2</div><div class="line">tar -xavf 1.tar.bz2 -C /tmp</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#压缩比</span></div><div class="line"><span class="comment">#从1级(速度最快，压缩率最低)到9级</span></div><div class="line">bzip -9 -k file</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#对成千上万的文件进行归档，需要借助 循环和-r选项</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="lzma压缩"><a href="#lzma压缩" class="headerlink" title="lzma压缩"></a><code>lzma</code>压缩</h2><p><code>lzma</code>是一个较新的压缩工具，它提供了比gzip或bzip2更好的压缩率。<br>xz, unxz, xzcat, lzma, unlzma, lzcat - Compress or decompress .xz and .lzma files</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">lzma file	<span class="comment">#file.lzma,同样也会删除原文件</span></div><div class="line">lzma file -k 	<span class="comment">#保留原文件</span></div><div class="line">unlzma file.lzma</div><div class="line"></div><div class="line"><span class="comment">#从stdin读入并写入stdout</span></div><div class="line">cat file | lzma -C &gt; file.lzma</div><div class="line"></div><div class="line"><span class="comment">#与tar相结合,--lzma</span></div><div class="line">tar -cvf 1.tar.lzma ./1.* --lzma</div><div class="line">tar -cavf 1.tat.lzma ./1.*	<span class="comment">#自动判断</span></div><div class="line">tar -xvf 1.tar.lzma --lzma</div><div class="line">tar -xavf 1.tar.lzma -C /tmp</div><div class="line"></div><div class="line"><span class="comment">#压缩率</span></div><div class="line"><span class="comment">#从1级到9级(压缩级别最高，速度最慢)</span></div><div class="line"></div><div class="line"><span class="comment">#对成千上万的文件，需要使用循环和-r选项</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="zip归档和压缩"><a href="#zip归档和压缩" class="headerlink" title="zip归档和压缩"></a>zip归档和压缩</h2><p><code>zip</code>在Linux下不如<code>gzip</code>,<code>bzip2</code>那么广泛，但在Internet上的文件通常都采用这种格式。<br>zip - package and compress (archive) files</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">zip file.zip file</div><div class="line">unzip file.zip</div><div class="line"><span class="comment">#与lzma,gzip,bzip2相比，zip完成后不会删除原文件</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#对目录和文件进行递归操作,-r</span></div><div class="line">zip -r dir.zip /root/<span class="built_in">test</span> ./file</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#向归档文件中增加内容，-u</span></div><div class="line">zip dir.zip -u newfile</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#从压缩文件中删除内容，-d</span></div><div class="line">zip -d dir.zip file</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#列出归档文件中内容</span></div><div class="line">unzip -l dir.zip</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="超高压缩率的squashfs文件系统"><a href="#超高压缩率的squashfs文件系统" class="headerlink" title="超高压缩率的squashfs文件系统"></a>超高压缩率的<code>squashfs</code>文件系统</h2><p><code>squashfs</code>是一种只读型的超高压缩率文件系统。这种文件系统能够将 2GB-3GB的数据压缩成一个700MB的文件。<br>你有没有想过Linux Live CD是怎样运行的？当Live CD启动后，它会加载一个完整的Linux环境。这就是利用了一种被称为squashfs的只读型压缩文件系统。它将根文件系统保存在一个压缩过的文件系统文件中。这个文件可以使用环回的形式来挂载并对其中的文件进行访问。一次当进程需要某些文件，可以将它们解压，然后载入内存中使用。<br>如果需要构建一个定制的Live OS，或是需要超高压缩率的文件并且无需解压就可以访问文件，那么squashfs的相关知识就能派上用场。要解压个头较大的压缩文件，需要花费不少时间。但如果将文件以环回形式挂载，速度就飞快，因为只有出现访问请求的时候，对应的那部分压缩文件才会被解压缩。而普通的解压缩方式是首先解压缩所有的数据。</p>
<p>环回文件系统就是指那些在文件中而非物理设备中创建的文件系统。比如我们可以创建一个文件，然后把这个文件格式化为我们常见ntfs、exfat或者ext4等文件系统格式，然后把它挂载在一个目录上使用。</p>
<p>如果你有一张Ubuntu CD，可以在CDRom Root/casper/filesystem.squashfs中找到文件.squashfs。<br>squashfs在内部采用了gzip和lzma这类压缩算法。</p>
<p>mksquashfs - tool to create and append to squashfs filesystems</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">yum install squashfs-tools -y</div><div class="line"></div><div class="line"><span class="comment">#创建squashfs文件</span></div><div class="line">mksquashfs <span class="built_in">source</span> compressfile.squashfs</div><div class="line"></div><div class="line">mksquashfs /etc etc.squashfs</div><div class="line"><span class="comment">#/etc(67M) --&gt; etc.suqashfs(18M)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#要挂载squashfs文件，利用环回形式进行挂载</span></div><div class="line">mkdir /mnt/squash</div><div class="line">mount -o loop etc.squashfs /mnt/squash</div><div class="line"><span class="comment">#此处挂载使用etc.squashfs文件系统</span></div><div class="line"><span class="comment">#如果直接查看etc.squashfs，就是一个普通文件，但是挂载以后所有文件都出现了</span></div><div class="line">umount /mnt/squash</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#在创建squashfs文件时排除指定文件，-e</span></div><div class="line">mksquashfs /etc etc.squashfs -e /etc/passwd /etc/shadow /etc/*.txt</div><div class="line"><span class="comment">#在挂载之后就没有相关文件了</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="加密工具与散列"><a href="#加密工具与散列" class="headerlink" title="加密工具与散列"></a>加密工具与散列</h2><p>加密技术主要用于防止数据遭受未经授权的访问。<br>Linux下某些工具用于执行加密和解密，使用加密算法散列值来验证数据完整性。</p>
<p><strong><code>crypt</code>, <code>gpg</code>, <code>base64</code>, <code>md5sum</code>, <code>sha1sum</code>, <code>openssl</code>的用法</strong></p>
<h3 id="ccypt"><a href="#ccypt" class="headerlink" title="ccypt"></a><code>ccypt</code></h3><p>ccrypt是为了取代UNIX crypt而设计的，这个实用工具可用于文件和数据流加密及解密。</p>
<p>ccrypt - encrypt and decrypt files and streams</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ccrypt 1.txt	<span class="comment">#会要求输入口令(encryption key)</span></div><div class="line"><span class="comment">#之后会生成1.txt.cpt覆盖原文件</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#更改key,-x</span></div><div class="line">ccrypt -x 1.txt.cpt	<span class="comment">#输入old key和new key</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#解密，-d(--decrypt)</span></div><div class="line">ccrypt -d 1.txt.cpt	<span class="comment">#输入key解密</span></div></pre></td></tr></table></figure>
<h3 id="gpg"><a href="#gpg" class="headerlink" title="gpg"></a><code>gpg</code></h3><p>gpg(GNU privacy guard,GNU隐私保护)，是一种应用广泛的加密方案。<br>它采用签名密钥技术保护文件内容，只有经过认证的用户才能访问数据。我们对gpg签名早已耳熟能详。</p>
<p>gpg - OpenPGP encryption and signing tool</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#加密，-c(--symmetric)对称加密</span></div><div class="line">gpg -c file	<span class="comment">#会要求输入口令(Passphrase)，生成file.gpg</span></div><div class="line"></div><div class="line"><span class="comment">#解密</span></div><div class="line">gpg file.gpg</div></pre></td></tr></table></figure>
<h3 id="base64"><a href="#base64" class="headerlink" title="base64"></a><code>base64</code></h3><p><code>base64</code>是一组类似的编码方案(encoding scheme)，它通过将ASCII字符转换成以64为基数的形式(radix-64 representation)来用ASCII字符串描述二进制数据。base64可用来对 编码和解码 base64字符串。</p>
<p>base64 - base64 encode/decode data and print to standard output</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#将文件编码为base64格式</span></div><div class="line">base64 file &gt; outputfile</div><div class="line">cat file | base64 &gt; outputfile</div><div class="line"></div><div class="line"><span class="comment">#解码,-d</span></div><div class="line">base64 -d outputfile &gt; file</div></pre></td></tr></table></figure>
<h3 id="md5sum与sha1sum"><a href="#md5sum与sha1sum" class="headerlink" title="md5sum与sha1sum"></a><code>md5sum</code>与<code>sha1sum</code></h3><p><code>md5sum</code> 和 <code>sha1sum</code> 都是单向散列算法(unidirecrional hash algorithm)，均无法逆推出原始数据。<br>它们通常用于验证数据完整性或为特定数据生成唯一的密钥，因为通过分析文件内容，它们可以为每个文件生成一个唯一的密钥。</p>
<p>这种类型的散列算法是存储密码的理想方案。密码使用其对应的散列值来存储。如果某个用户需要认证，读取该用户提供的密码并转换成散列值，然后将其与之前存储的散列值进行比对。<br>将密码以明文的形式存储是非常危险的事情，它面临密码泄露的危险。而因为 md5sum和sha1sum 是单向散列算法，所以密码使用散列值存储是很安全的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"1.txt"</span> &gt; 1.txt</div><div class="line">md5sum 1.txt	<span class="comment">#生成密钥到stdout</span></div><div class="line"><span class="comment">#39061daa34ca3de20df03a88c52530ea  1.txt</span></div><div class="line"></div><div class="line"></div><div class="line">sha1sum file	<span class="comment">#生成密钥到stdout</span></div><div class="line"><span class="comment">#659fcbc505db207c03b5c4c0b6981d63286abe21  1.txt</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看/etc/shadow中密码的散列值</span></div><div class="line">awk <span class="string">'NR==1'</span> /etc/shadow | awk -F: <span class="string">'&#123;print $2&#125;'</span>	<span class="comment">#root密码散列</span></div><div class="line"><span class="comment">#$6$BxpV48gPsjuq6.pF$wE7pUDwtOI.v64kd5folG68yUt2UAQDTUGgKa5Iz69GaupEoRAdCeerP8nRKXo48c4azutUCGhnDgzd1qe8YX0</span></div></pre></td></tr></table></figure>
<h3 id="shadowlike散列-salted散列"><a href="#shadowlike散列-salted散列" class="headerlink" title="shadowlike散列(salted散列)"></a>shadowlike散列(salted散列)</h3><p>shadow密码通常都是salted密码，所谓SALT就是额外的一个字符串，用来起一个混淆的作用，使加密更加不同里被破解。salt由一些随机位组成，被用作密钥生成函数的输入之一，以生成密码的salted散列值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#/etc/passwd里面的密码散列类型就是salted散列</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看root密码对应的散列值</span></div><div class="line">head -1 /etc/shadow</div><div class="line">root:<span class="variable">$6</span><span class="variable">$ZlHRCZG2iRwQUXAu</span><span class="variable">$RAEDH97nPdZB2RK20npua6Qf6jB7osatoC99ow3LtPQ6aORdLISYC7</span>/4iTYU162emkQLt4ZafdgjyAeoSB7IU0::0:99999:7:::</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#openssl - OpenSSL command line tool</span></div><div class="line"></div><div class="line"><span class="comment">#shadow密码是使用openssl生成</span></div><div class="line"><span class="comment">#将SALT_STRING替换为随机字符串，同时将pass替换成你想测试的密码</span></div><div class="line">openssl -1 -salt SALT_STRING passwd</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用rsync备份系统"><a href="#用rsync备份系统" class="headerlink" title="用rsync备份系统"></a>用<code>rsync</code>备份系统</h2><p><code>rsync</code>借助差异计算以及压缩技术来最小化数据传输量。相较于<code>cp</code>命令，它的优势在于使用了高效的差异算法(difference algorithm)。<br>它还支持网络数据传输。在进行复制的同时，rsync会比较源端和目的端的文件，只有当文件有更新是才进行复制。默认情况下，rsync并不会在目的端删除源端已不存在的文件。</p>
<p>rsync - a fast, versatile, remote (and local) file-copying tool<br>inotifywait - wait for changes to files using inotify</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-a进行归档，-v详细信息</span></div><div class="line">rsync -av <span class="built_in">source</span> destination</div><div class="line">rsync -av /etc /tmp</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#异地cp</span></div><div class="line">rsync -av <span class="built_in">source</span> username@host:PATH</div><div class="line">rsync -av username@host:PATH destination</div><div class="line"><span class="comment">#rsync借助于ssh，可以使用ssh无秘钥认证</span></div><div class="line">rsync -av /etc zhang@192.168.1.11:~</div><div class="line"></div><div class="line"><span class="comment">#-z, --compress  compress file data during the transfer</span></div><div class="line">rsync -avz zhang@192.168.1.11:/etc /tmp</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#注意，路径格式</span></div><div class="line">rsync /etc /tmp	<span class="comment">#整个/etc目录</span></div><div class="line">rsync /etc/ /tmp	<span class="comment">#/etc目录下所有内容</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#显示进度，--progress</span></div><div class="line">rsync -avz --progress /etc /tmp</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#排除部分文件，--exclude</span></div><div class="line">rsync -avz /etc /tmp --exclude=/etc/nginx --exclude <span class="string">"*.txt"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#更新rsync时，删除不存在的文件，--delete</span></div><div class="line"><span class="comment">#默认情况下，rsync并不会在目的端删除源端已不存在的文件</span></div><div class="line">rsync -avz /etc zhang@192.168.1.1:~ --delete</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#定期调度</span></div><div class="line">crontab -e</div><div class="line">0 */10 * * * rsync -avz /etc user@host:PATH</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#实时同步，inotifywait+rsync</span></div><div class="line">yum install inotify-tools -y</div><div class="line"></div><div class="line"><span class="comment">#-m(monitor),-r(recursive),-q(--quiet)静默模式，-e(event)</span></div><div class="line"></div><div class="line">vi inotify_rsync.sh</div><div class="line">inotifywait -mrq -e creat,delete,modify,move --exclude <span class="string">"^.*\.filepart$"</span> /etc | <span class="keyword">while</span> <span class="built_in">read</span> file</div><div class="line"><span class="keyword">do</span></div><div class="line">rsync -az --exclude=<span class="string">".*"</span> --exclude=<span class="string">"*.swp"</span> --exclude=<span class="string">".filepart"</span> --delete /etc /tmp &gt; /dev/null 2&gt;<span class="variable">$1</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用Git备份版本控制"><a href="#用Git备份版本控制" class="headerlink" title="用Git备份版本控制"></a>用Git备份版本控制</h2><p>维护和恢复变更最好的方法是使用版本控制系统。由于代码变更频繁，版本控制系统多用于软件开发和代码维护。<br>Git(GNU it)是有名气也是最高效的版本控制系统。我们可在非编程环境下用Git备份普通文件。</p>
<p>git - the stupid content tracker</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">mkdir /home/zhang/gittest</div><div class="line"><span class="built_in">cd</span> /home/zhang/gittest</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#在源主机中添加用户信息</span></div><div class="line">git config --global user.name <span class="string">"username"</span>	<span class="comment">#设置用户名</span></div><div class="line">git config --global user.email <span class="string">"someone@example.com"</span>	<span class="comment">#设置邮箱</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#创建一个空的Git版本库或初始化一个老版本</span></div><div class="line">git init</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#记录变更到版本库</span></div><div class="line">git commit</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#添加远程git目录并同步备份</span></div><div class="line">git remote add origin user@host:/home/zhang/gittest</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#为git跟踪(git tracking)添加或删除文件</span></div><div class="line"><span class="comment">#add,添加内容至索引</span></div><div class="line">git add *</div><div class="line"><span class="comment">#git add *.txt; git add *.ph	#添加部分文件</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#删除不需要跟踪的文件和文件夹</span></div><div class="line"><span class="comment">#rm,从工作去和索引删除文件</span></div><div class="line">git rm file</div><div class="line"><span class="comment">#git rm *.txt</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#检查点或创建备份点(check point)</span></div><div class="line">git commit -m <span class="string">"Commit Message"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#push,更新远程</span></div><div class="line">git push</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#用Git恢复数据</span></div><div class="line"><span class="comment">#log,显示提交日志</span></div><div class="line">git <span class="built_in">log</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#返回之前某个版本或状态</span></div><div class="line">git checkout xxxxxxxx(Commit ID)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#clone,克隆一个版本库到本地</span></div><div class="line">git <span class="built_in">clone</span> URL</div><div class="line">git <span class="built_in">clone</span> user@host:PATH</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用dd克隆磁盘"><a href="#用dd克隆磁盘" class="headerlink" title="用dd克隆磁盘"></a>用<code>dd</code>克隆磁盘</h2><p><code>dd</code>命令能用于克隆任何类型的磁盘，如硬盘、闪存、CD、DVD及软盘。<br>可能需要创建所有分区的副本而不仅仅是复制内容，包括硬盘分区、引导记录、分区表等信息。</p>
<p>使用dd的时候，要留意参数的顺序。错误的参数会损毁全部数据。dd基本上算是一个比特流复制器(bitstream duplicator),它可以将来自磁盘的比特流写入文件，也可以将来自文件的比特流写入硬盘。</p>
<p>dd - convert and copy a file</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dd <span class="keyword">if</span>=<span class="built_in">source</span> of=target bs=block_size count=count</div><div class="line"><span class="comment">#bs块大小，count块数</span></div><div class="line"></div><div class="line">dd <span class="keyword">if</span>=/tmp/centos7.iso of=/dev/sdc</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#/dev/zero是一个字符设备，它总是返回字符'\0'</span></div><div class="line">dd <span class="keyword">if</span>=/dev/zero of=./file bs=10m count=100</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#用环回(loop back)方法可将任何由dd生产的文件镜像进行挂载</span></div><div class="line">mount -o loop file /mnt</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="无网不利"><a href="#无网不利" class="headerlink" title="无网不利"></a>无网不利</h1><h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><p>网络是计算机系统中重要的部分。我们以Tcp/Ip为协议栈，所有操作都是基于它进行的。</p>
<p>一些使用网络的应用通过打开并连接到防火墙端口进行运作，而有的管理任务可以通过网络进行。</p>
<p><br></p>
<h2 id="网络小知识"><a href="#网络小知识" class="headerlink" title="网络小知识"></a>网络小知识</h2><p>网络接口(Interface)用来连接网络。在每个系统中，默认都有一个称之为环回接口的lo，这个接口指向当前主机本身。<br>操作系统维护者一个被称为路由表(routing table)的表格，它包含了分组如何转发以及通过网络中的哪些节点转发的消息。<br>metric是路由算法用以确定到达目的地的最佳路径的计量标准，如路径长度。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#显示网络接口、子网掩码等详细信息</span></div><div class="line">ifconfig	<span class="comment">#/sbin/ifconfig</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#显示某个特定接口</span></div><div class="line">ifconfig eth0</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#提取IP地址</span></div><div class="line">ifconfig eth0 | egrep -o <span class="string">"inet [^ ]*"</span> | grep -o <span class="string">"[0-9.]*"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#设置网络接口的IP地址和子网掩码</span></div><div class="line">ifconfig eht0 192.168.1.11</div><div class="line">ifconfig eth0 192.168.1.11 netmask 255.255.255.0</div><div class="line"><span class="comment">#远程的时候，千万别乱改IP，不然连不上你就要去机房了</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#MAC地址欺骗</span></div><div class="line">ifoconfig eth0 hw ether 11:22:33:44:55:66</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#域名服务器与DNS</span></div><div class="line">cat /etc/resolv.conf</div><div class="line"><span class="comment">#添加域名服务器</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"name 114.114.114.114"</span> &gt;&gt; /etc/resolv.conf</div><div class="line"><span class="comment">#nameserver 114.114.114.114</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#一个域名可以分配多个地址，DNS只会返回其中一个</span></div><div class="line"><span class="comment">#要想获得域名所有IP地址，需要使用DNS查找工具</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#DNS查找工具</span></div><div class="line">host www.baidu.com</div><div class="line">nslookup www.baidu.com</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#自定义解析</span></div><div class="line">cat /etc/hosts</div><div class="line"><span class="built_in">echo</span> <span class="string">"192.168.1.11 www.zhang.me"</span> &gt;&gt; /etc/hosts</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#设置默认网关，显示路由表信息</span></div><div class="line"><span class="comment">#路由表</span></div><div class="line">route</div><div class="line">route -n	<span class="comment">#以数字形式显示地址</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#设置默认网关</span></div><div class="line">route add default gw <span class="variable">$ip</span> <span class="variable">$interface</span></div><div class="line">route add default gw 192.168.1.1 eht0</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#显示分组途经的所有网关地址</span></div><div class="line">traceroute www.baidu.com</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a><code>ping</code></h2><p><code>ping</code>使用 <strong>网际控制报文协议(Internet Control Message Protocol,ICMP)</strong>的echo分组。如果分组能够送达且该主机为活动主机，那它就会发送一条回应。一旦主机不可到达，ping返回错误信息”Destination Host Unreachable”。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ping 192.168.1.1</div><div class="line"></div><div class="line"><span class="comment">#往返时间(Round Trip Time,RTT)</span></div><div class="line"></div><div class="line"><span class="comment">#发送分组数量</span></div><div class="line">ping <span class="variable">$URL</span> -c 6</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="列出网络上所有活动主机"><a href="#列出网络上所有活动主机" class="headerlink" title="列出网络上所有活动主机"></a>列出网络上所有活动主机</h2><p>当涉及大型局域网时，可能需要检查网络上的其他主机的活动状态。<br>一台非活动主机可能是：没有开机；网络连接有问题；主机禁ping；防火墙问题。</p>
<p>当我们要检测ip时，在一个脚本中，每一次<code>ping</code>都是依次执行。即使所有的ip地址都是彼此独立，由于编写的是顺式程序(sequential program)，<code>ping</code>命令也只能按顺序执行。每次执行一个<code>ping</code>命令。都要经历一段延迟——“发送echo分组，并接收或等待回应超时”。</p>
<p>要是处理几百个ip地址的话，这个延时就真不短了。我们可以使用并行方式来加速所有ping命令的执行。<br>可以将<code>ping</code>命令中的循环体放入<strong>( )&amp;</strong> 中，<strong>( )</strong> 使其中的命令可作为子shell来执行，<strong>&amp;</strong> 使之在后台继续运行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#编写G一个并行方式的ping脚本</span></div><div class="line">fo ip <span class="keyword">in</span> 192.168.1.&#123;1..255&#125;</div><div class="line"><span class="keyword">do</span></div><div class="line">	(</div><div class="line">	ping <span class="variable">$ip</span> -c2 &amp;&gt; /dev/null;</div><div class="line">	<span class="keyword">if</span>[ $? -eq 0 ]</div><div class="line">		<span class="keyword">then</span></div><div class="line">			<span class="built_in">echo</span> <span class="string">"<span class="variable">$ip</span> is alive"</span></div><div class="line">	<span class="keyword">fi</span></div><div class="line">	)&amp;</div><div class="line"><span class="built_in">wait</span></div><div class="line"><span class="keyword">done</span></div><div class="line"><span class="comment">#wait命令是脚本只有在所有子进程或后台进程全部终止或完成后才能结束</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#使用fping,-a显示活动主机，-g生成目标列表,-u显示无法到达主机</span></div><div class="line">fping -a 192.168.0.0/24 -g 2&gt; /dev/null</div><div class="line">fping -a 192.168.0.1 192.168.3.255 -g 2&gt; ./unreach.txt</div><div class="line"><span class="comment">#将unreach主机找出</span></div><div class="line">cat unreach.txt | egrep -o <span class="string">"to [0-9.]+$"</span> | grep -o <span class="string">"[0-9.]*"</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h2><p>有很多不同的方法可以在网络节点上传输文件，常见的协议有<strong>FTP, SFTP, RSYNC, SCP</strong>。</p>
<p>通过FTP传输文件可使用<code>lftp</code>命令；<br>通过SSH传输文件可使用<code>sftp</code>；<br>RSYNC使用<code>SSH</code>与<code>rsync</code>命令；<br><code>scp</code>通过SSH进行传输。</p>
<p><br></p>
<p>文件传输协议(File Transfer Protocol, FTP)，使用21端口。FTP是明文传输，So…<br>需要远程主机上启用了FTP服务器才能使用FTP。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">lftp user@ftp-host</div><div class="line"><span class="comment">#输入密码后便可以操作如下命令</span></div><div class="line"><span class="built_in">cd</span> -- lcd(本地)</div><div class="line">mkdir</div><div class="line">get filename	<span class="comment">#下载文件</span></div><div class="line">put filename	<span class="comment">#上传文件</span></div><div class="line">quit	<span class="comment">#退出</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>SFTP(Secure FTP,安全FTP)，运行在SSH连接之上。利用SSH连接模拟FTP接口。<br>它不需要源端运行FTP服务器，不要运行OpenSSH。SFTP是一个交互式命令，提供了命令提示符。</p>
<p>rsync广泛用于网络文件与系统快照的备份。</p>
<p>SCP(Secure Copy,安全复制)，远程文件复制工具。通过SSH加密通过进行传输。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scp SOURCE DESTINATION</div><div class="line"></div><div class="line">scp /path/file user@host:PATH</div><div class="line">scp usr@host:/dir/file /home/zhang</div><div class="line"><span class="comment">#需要输入密码，可以用SSH无秘钥认证</span></div><div class="line"></div><div class="line"><span class="comment">#-r递归复制,-p保持文件权限和模式</span></div><div class="line">scp -r /etc user@host:/tmp</div><div class="line">scp -rp user@host:/var/www  /var</div></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="SSH无秘钥认证"><a href="#SSH无秘钥认证" class="headerlink" title="SSH无秘钥认证"></a>SSH无秘钥认证</h2><p>特别是在定时任务传输备份文件时，无秘钥认证就很方便了。SSH服务默认在22端口，你可以在配置文件中修改。</p>
<p>具体步骤：</p>
<ol>
<li>创建SSH密钥(公钥和私钥)；</li>
<li>将客户端公钥上传给需要连接的主机，并写入~/.ssh/authorized_keys文件；</li>
<li>修改相关目录(700)和文件权限(600)；</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa</div><div class="line"><span class="comment">#后续操作默认即可</span></div><div class="line"><span class="comment">#生成~/.ssh/id_rsa.pub和id_rsa</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#写入远程主机</span></div><div class="line">ssh user@host <span class="string">"cat &gt;&gt; ~/.ssh/authorized_keys"</span> &lt; ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用SSH在远程主机上运行命令"><a href="#用SSH在远程主机上运行命令" class="headerlink" title="用SSH在远程主机上运行命令"></a>用SSH在远程主机上运行命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#连接远程主机</span></div><div class="line">ssh user@host</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#非默认端口</span></div><div class="line">ssh user@host -p 2211</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#在远程主机中运行命令</span></div><div class="line">ssh user@host <span class="string">'command'</span></div><div class="line">ssh user@host <span class="string">'cmd1'</span>; <span class="string">'com2'</span>...</div><div class="line"></div><div class="line">ssh user@host <span class="string">'whoami'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-C压缩功能，当带宽有限时</span></div><div class="line">ssh -C user@host <span class="string">'cmd'</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="在本地挂载远程驱动器-sshfs"><a href="#在本地挂载远程驱动器-sshfs" class="headerlink" title="在本地挂载远程驱动器(sshfs)"></a>在本地挂载远程驱动器(<code>sshfs</code>)</h2><p>在执行读写数据操作时，通过本地挂载远程主机文件系统。利用SSH和sshfs来实现这一功能。<br>sshfs是FUSE文件系统的一个扩展，FUSE允许其支持的操作系统像使用本地文件系统一样挂载各类数据。<br><code>sshfs</code>允许将远程文件系统挂载到本地挂载点上。</p>
<p>相当于便捷的NFS，但并不需要搭建NFS服务。</p>
<p>SSHFS - filesystem client based on ssh</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#挂载远程文件到本地</span></div><div class="line">ssh user@host:PATH /mnt/sshfs</div><div class="line"></div><div class="line">umout /mnt/sshfs</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="网络流量和端口分析"><a href="#网络流量和端口分析" class="headerlink" title="网络流量和端口分析"></a>网络流量和端口分析</h2><p>应用程序在主机上打开端口，然后与远程主机中打开的端口实现通信。<br>出于安全方面的考虑，必须留意系统中打开及关闭的端口。</p>
<p>恶意软件和rootkit可能会利用特定的端口及服务运行在系统之中，从而进行攻击。<br>通过分析开放端口列表以及运行在端口上的服务，我们便可以分析并检查恶意软件，保证主机安全。</p>
<p>了解及使用各种端口分析工具。</p>
<p>lsof - list open files<br><code>lsof</code>列出系统中开放端口以及运行在端口上的服务的详细信息;</p>
<p>netstat查看开放端口与服务<br><code>netstat</code> - 显示网络连接，路由表，接口状态，伪装连接，网络链路信息和组播成员组;</p>
<p>iftop - display bandwidth usage on an interface by host<br><code>iftop</code> - 展示带宽使用情况；</p>
<p>ifstat - handy utility to read network interface statistics<br><code>ifstat</code> - 展示某时刻网络状态；</p>
<p>nload - displays the current network usage<br><code>nload</code> - 可查看系统总带宽；</p>
<p>nethogs - Net top tool grouping bandwidth per process<br><code>nethogs</code>- 可查看每个进程流量情况；<br>ethtool - query or control network driver and hardware settings<br><code>ethtool</code> - 检查网卡支持的带宽</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#lsof的每一项都对应着一个打开了特定端口的服务</span></div><div class="line">lsof -i</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看开放端口和服务</span></div><div class="line">netstat -nltp</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看网络实时状态</span></div><div class="line">iftop</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看当前网络状态</span></div><div class="line">ifstat</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看系统带宽</span></div><div class="line">nload</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看进程流量</span></div><div class="line">nethogs</div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="当个好管家"><a href="#当个好管家" class="headerlink" title="当个好管家"></a>当个好管家</h1><h2 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h2><p>操作系统(Operation System,OS)，是由一系列用于不同目的、服务于不同任务的系统软件组成。<br>日志记录(logging)和监视是很重要的，能帮助我们从大量数据中收集信息。</p>
<p>监视系统活动的各种命令，日志技术及其使用方法。</p>
<p><br></p>
<h2 id="统计磁盘使用情况-df-du-fdisk"><a href="#统计磁盘使用情况-df-du-fdisk" class="headerlink" title="统计磁盘使用情况(df+du+fdisk)"></a>统计磁盘使用情况(<code>df+du+fdisk</code>)</h2><p>磁盘空间是一种有限资源，我们需要了解磁盘的可用空间。</p>
<p><code>df</code>, <code>du</code>, <code>fdisk</code>是Linux中的磁盘管理三板斧<br>df(disk free): 报告文件系统磁盘空间的使用情况;<br>du(disk usage): 报告磁盘空间使用情况; 使用<code>du</code>时，要确保对其遍历的目录和文件拥有适合的读权限。<br>fdisk: Linux分区表操作工具软件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">du file1	<span class="comment">#默认以字节为单位</span></div><div class="line"></div><div class="line"><span class="comment">#-a,显示目录下所有文件大小</span></div><div class="line">du -a /home/zhang</div><div class="line">du /home/zhang	<span class="comment">#只显示目录大小</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-h,以可读形式打印</span></div><div class="line">du -h /home/zhang</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-c,显示使用总量</span></div><div class="line">du -c file1 /dir2</div><div class="line">du -c *.txt *.sh</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-s，打印摘要</span></div><div class="line">du -s /dir</div><div class="line">du -sh /home/zhang</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-b,-k,-m,-B，用特定单位打印</span></div><div class="line">du -k file1</div><div class="line">du -m file2</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--exclude,从磁盘统计中排除部分文件</span></div><div class="line">du --exclude=<span class="string">"*.swap"</span> -sh /home/zhang</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--max-depth,指定最大遍历深度</span></div><div class="line">du -h --max-depth n /dir</div><div class="line">du -h --max-depth=2 /home/zhang</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-x,将/mnt中所有挂载点排除在磁盘统计之外</span></div><div class="line">du -xh /dir</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#找出目录中最大的文件</span></div><div class="line">du -ak /dir | sort -nrk 1 | head -n 5</div><div class="line"><span class="comment">#此输出包含了目录大小，需要细化</span></div><div class="line"><span class="comment">#利用find替du过滤文件</span></div><div class="line">find /dir -<span class="built_in">type</span> f --<span class="built_in">exec</span> du -ak &#123;&#125; \; | sort -nrk 1 | head</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#df,磁盘可用空间信息</span></div><div class="line">df -h</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="计算命令执行时间"><a href="#计算命令执行时间" class="headerlink" title="计算命令执行时间"></a>计算命令执行时间</h2><p>当测试一个应用程序或比较不同的算法时，程序的执行时间非常重要。所以需要计算命令执行时间。</p>
<p>所有的Unix-Like操作系统都包含time命令，可将time放在需要计算执行时间的命令前。</p>
<blockquote>
<p>time命令有个可执行二进制文件位于/usr/bin/time，还有一个shell built-in命令也叫作time；<br>当运行time时，默认调用的是shell built-in命令。內建time命令选项有限；<br>因此，如果我们需要使用另外的功能，就应该使用/usr/bin/time命令。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#计算命令执行时间</span></div><div class="line">time <span class="built_in">command</span></div><div class="line">time ls</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#real,挂钟时间(wall clock time),命令从开始执行到结束的时间；</span></div><div class="line"><span class="comment">#user,指进程花费在用户模式(user-mode)中的CPU时间。这是唯一用于执行进程所花费的时间；</span></div><div class="line"><span class="comment">#sys，指进程花费在内核模式(in the kernel)中的CPU时间。它代表在内核中执行系统调用所使用的时间。</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-o,将命令执行时间写入文件</span></div><div class="line">/usr/bin/time -o exetime.txt ls /</div><div class="line"></div><div class="line"><span class="comment">#-a,不影响原文件</span></div><div class="line">/usr/bin/time -a -o exetime.txt ls /home</div><div class="line"></div><div class="line"><span class="comment">#-f,格式化时间输出</span></div><div class="line"><span class="comment">#时间格式字符串</span></div><div class="line"><span class="comment">#real	%e</span></div><div class="line"><span class="comment">#user	%U</span></div><div class="line"><span class="comment">#sys	%S</span></div><div class="line">/usr/bin/time -f <span class="string">"FORMAT STRING"</span> <span class="built_in">command</span></div><div class="line">/usr/bin/time -f <span class="string">"Rtme: %e"</span> -a -o timing.log uname</div><div class="line">/usr/bin/time -f <span class="string">"Rtime: %e\nUtime: %U\nStime: %S"</span> -ao timing.log uname</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="当前登录用户、启动日志、启动故障的相关信息-w-who-lastb-last"><a href="#当前登录用户、启动日志、启动故障的相关信息-w-who-lastb-last" class="headerlink" title="当前登录用户、启动日志、启动故障的相关信息(w+who+lastb+last)"></a>当前登录用户、启动日志、启动故障的相关信息(<code>w+who+lastb+last</code>)</h2><p>收集与操作系统、当前登录用户、主机运行时间、启动故障等相关信息很有用处。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#获取当前登录用户</span></div><div class="line">who	<span class="comment">#显示已经登录的用户</span></div><div class="line">w	<span class="comment">#显示已经登录的用户以及他们在做什么</span></div><div class="line"><span class="comment">#会显示用户使用的伪终端(pseudo TTY)，对应设备文件出现在/dev/pts/n</span></div><div class="line"></div><div class="line"><span class="comment">#列出登录主机的用户列表</span></div><div class="line">users</div><div class="line"></div><div class="line"><span class="comment">#查看系统运行时间</span></div><div class="line">uptime</div><div class="line"></div><div class="line"><span class="comment">#显示用户登录列表</span></div><div class="line">last</div><div class="line"><span class="comment">#获取某个用户登录信息</span></div><div class="line">last zhang</div><div class="line"><span class="comment">#获取重启会话信息</span></div><div class="line">last reboot</div><div class="line"></div><div class="line"><span class="comment">#获取失败的用户登录信息</span></div><div class="line">lastb</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="打印10条最常使用的命令-history"><a href="#打印10条最常使用的命令-history" class="headerlink" title="打印10条最常使用的命令(history)"></a>打印10条最常使用的命令(<code>history</code>)</h2><p>终端是用来访问shell的工具，在shell中我们可以输入并执行命令。我们可以找出在shell中运行最多的命令。</p>
<p>~/.bash_history，默认保留1000个最近执行命令。或者<code>history</code>命令。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat .bash_history | sort -n | uniq -c | sorn -nr | head</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="列出占用CPU最多的进程"><a href="#列出占用CPU最多的进程" class="headerlink" title="列出占用CPU最多的进程"></a>列出占用CPU最多的进程</h2><p>CPU时间是一项重要资源，有时需要跟踪占用CPU周期最多的进程。<br>对于需要处理大量请求的服务器来说，CPU是极其重要的资源。通过监视某个时期内CPU的使用情况，可以找出长期占用CPU的进程并对其进行优化，或是调试其他问题。</p>
<p>用<code>ps</code>命令收集系统中进程的详细信息。<br>ps - report a snapshot of the current processes</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-e,以标准语法显示每个进程</span></div><div class="line">ps -e</div><div class="line">ps -ef</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#ax,以BSD语法显示每个进程</span></div><div class="line">ps ax</div><div class="line">pa axu</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#获取安全信息</span></div><div class="line"><span class="comment">#ps -eo euser,ruser,suser,fuser,f,comm,pcpu,label</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#comm显示命令，pcpu显示CPU使用率</span></div><div class="line">ps -eo comm,pcpu</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#监视并计算一小时内CPU使用情况的shell脚本</span></div><div class="line">secs=3600</div><div class="line">unit_time=60</div><div class="line">steps=$((<span class="variable">$secs</span> / <span class="variable">$unit_time</span>))</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"Whatching CPU usage..."</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>((i=0; i&lt;steps; i++))</div><div class="line"><span class="keyword">do</span></div><div class="line">	ps -eo comm,pcpu | tail -n +2 &gt;&gt; /tmp/cpu_usage.$$</div><div class="line">    sleep <span class="variable">$unit_time</span></div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"CPU eaters: "</span></div><div class="line"></div><div class="line">cat /tmp/cpu_usage.$$ | \</div><div class="line">awk <span class="string">'&#123;process[$1]+=$2&#125;</span></div><div class="line"><span class="string">END&#123;</span></div><div class="line"><span class="string">	for (i in process) &#123;</span></div><div class="line"><span class="string">    	printf("%-20s %s",i,process[i]);</span></div><div class="line"><span class="string">    &#125;</span></div><div class="line"><span class="string">&#125;'</span> | sort -nrk 2 | head</div><div class="line"></div><div class="line"><span class="comment">#tail -n +K，从第K行开始输出。上面输出第一行是 COMAND 和 %CPU</span></div><div class="line"></div><div class="line"><span class="comment">#$1,command; $2,%CPU</span></div><div class="line"><span class="comment">#process[$1]是一个关联函数，相当于arr[command]</span></div><div class="line"><span class="comment">#arr[command]=arr[command]+ $2，计算同一命令的累积时间</span></div><div class="line"><span class="comment">#i指命令，process[i]指命令运行时间</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用watch监视命令输出"><a href="#用watch监视命令输出" class="headerlink" title="用watch监视命令输出"></a>用<code>watch</code>监视命令输出</h2><p>可能需要在在某段时期内以固定的间隔时间不短监视某个命令的输出。可利用<code>watch</code>命令。</p>
<p>watch - execute a program periodically, showing output fullscreen</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#watch命令可以用来在终端以固定的间隔监视命令输出，默认2秒间隔</span></div><div class="line">watch <span class="built_in">command</span></div><div class="line">watch <span class="string">'command'</span></div><div class="line"></div><div class="line"></div><div class="line">watch ls</div><div class="line">watch <span class="string">'ls -l'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-n,指定时间间隔</span></div><div class="line">watch -n 5 <span class="string">'yum update -y'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-d，突出(highlighting)watch输出中的差异</span></div><div class="line">watch -d -n 1<span class="string">'dd if=/dev/zero of=/tmp/zero.test'</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="对文件及目录访问进行记录-inotifywait"><a href="#对文件及目录访问进行记录-inotifywait" class="headerlink" title="对文件及目录访问进行记录(inotifywait)"></a>对文件及目录访问进行记录(<code>inotifywait</code>)</h2><p>记录重要文件及目录访问，对于追踪文件和目录的变化很有帮助。<br><code>inotifywait</code>命令可以用来收集有关文件访问的信息。<br><code>inotifywait</code>和<code>rsync</code>用户实时同步哦！</p>
<p>inotifywait - wait for changes to files using inotify</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">yum install -y inotify-tools</div><div class="line"></div><div class="line"><span class="comment">#-q,减少冗余信息</span></div><div class="line">inotifywait -m -r -q -e create,move,delete /dir</div><div class="line">inotifywait -m -r -q -e create,move,modify,delete /home/zhang &gt;&gt; inotifywait.log</div><div class="line"></div><div class="line"><span class="comment">#利用inotifywait检测，rsync同步</span></div><div class="line">inotifywait -mrq -e create,move,modify,delete /dir --exclude=<span class="string">"*.swap"</span> | <span class="keyword">while</span> <span class="built_in">read</span> file</div><div class="line"><span class="keyword">do</span></div><div class="line">rsync -av --exclude=<span class="string">"*.swqp"</span> --delete /dir user@host:PATH &gt; /dev/null 2&gt;&amp;1</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用logrotate管理日志文件"><a href="#用logrotate管理日志文件" class="headerlink" title="用logrotate管理日志文件"></a>用<code>logrotate</code>管理日志文件</h2><p>日志文件是Linux系统维护中必不可少的组成部分。日志文件可以帮助跟踪系统中多种服务所发生的事件，这有助于排除系统问题。<br>但随着时间推移，日志文件会变得越来越大。因而必须对日志文件进行管理。</p>
<p>我们可以利用一种称为“轮询(rotation)”的技术来限制日志文件的体积。一旦日志文件超过了限定大小，就要对它的内容进行抽取(strip)，同时将日志文件的旧条目归档到文件中。</p>
<p><code>logratate</code>是每一位Linux系统管理员都应该了解的命令。它能够将日志文件大大小限制在给定的SIZE内。<br>logrotate配置文件位于<code>/etc/logrotate.d</code></p>
<p>logrotate ‐ rotates, compresses, and mails system logs</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">vim /etc/logrotated.d/custom</div><div class="line"></div><div class="line">/var/<span class="built_in">log</span>/custom.log &#123;</div><div class="line">	missingok	<span class="comment">#日志文件丢失，则忽略</span></div><div class="line">    notifempty	<span class="comment">#仅当源日志文件非空时才进行轮替</span></div><div class="line">    size 30k	<span class="comment">#限制实施轮替的日志文件大小</span></div><div class="line">    compress	<span class="comment">#压缩旧日志</span></div><div class="line">    weekly	<span class="comment">#轮询时间，daily,weekly,yearly</span></div><div class="line">    rotate 7	<span class="comment">#保留旧日志数量</span></div><div class="line">    create 0600 root root	<span class="comment">#创建的日志文件模式，用户和用户组</span></div><div class="line"><span class="comment">#还有一些其他选项</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用sys记录日志"><a href="#用sys记录日志" class="headerlink" title="用sys记录日志"></a>用sys记录日志</h2><p>在Linux系统中，在/var/log中创建并写入日志信息的是由被称为syslog的协议处理的。它由守护进程syslogd负责执行。<br>每一个标准应用进程都可以用syslog记录日志信息。</p>
<p>syslog处理/var/log下的多个日志文件。但是当logger发送消息时，它用标记字符串来确定应该纪录到哪一个日志文件中。<br>syslogd使用与日志相关联的TAG来决定应该将其记录到哪一个文件中。<br>可以从<code>/etc/rsyslog.d/</code>目录的配置文件中看到与日志文件相关联的标记字符串。</p>
<p>Linux中一些重要日志文件：</p>
<blockquote>
<p>/var/log/boot.log， 系统启动信息；<br>/var/log/message， 内核启动信息；<br>/var/log/auth.log， 用户认证日志；<br>/var/log/dmesg， 系统启动信息；<br>/var/log/mail.log， 邮件服务器日志。</p>
</blockquote>
<p>logger - a shell command interface to the syslog</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#logger命令，默认记录日志信息到/var/log/messages</span></div><div class="line">logger <span class="string">"test log message to messages"</span></div><div class="line">tail -n 1 /var/<span class="built_in">log</span>/message</div><div class="line"></div><div class="line"><span class="comment">#-t，指定特定TAG</span></div><div class="line">logger -t TAG <span class="string">"test log message to messages"</span></div></pre></td></tr></table></figure>
<p><br><br><br></p>
<h1 id="管理重任"><a href="#管理重任" class="headerlink" title="管理重任"></a>管理重任</h1><h2 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h2><p>GNU/Linux的生态系统是由运行的程序、服务、连接的设备、文件系统、用户等组成。按照我们需要的方式对整个系统有一个微观并对操作系统进行整体上的管理，这就是系统管理的主要目的。</p>
<h2 id="收集进程信息-top-ps-pgrep"><a href="#收集进程信息-top-ps-pgrep" class="headerlink" title="收集进程信息(top+ps+pgrep)"></a>收集进程信息(<code>top+ps+pgrep</code>)</h2><p>进程是程序运行实例(runing instance)。<br>同一程序的多个实例可以同时运行，但他们的进程ID却互不相同。</p>
<p>进程管理相关的重要命令是：</p>
<ul>
<li><code>top</code>, display Linux processes;</li>
<li><code>ps</code>, report a snapshot of the current processes;</li>
<li><code>pgrep</code>, look up or signal processes based on name and other attributes.</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#ps命令</span></div><div class="line"><span class="comment">#-f, 显示更多进程信息</span></div><div class="line">ps -f</div><div class="line"></div><div class="line"><span class="comment">#-e,every; -a,all</span></div><div class="line">ps -ef</div><div class="line">ps -ax</div><div class="line"></div><div class="line"><span class="comment">#-o, 指定想要的列</span></div><div class="line">ps -e -o parameter1,parameter2...</div><div class="line">ps -eo comm,pcpu,pmem</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#pccpu	CPU占用率</span></div><div class="line"><span class="comment">#pid	进程ID</span></div><div class="line"><span class="comment">#ppid	父进程ID</span></div><div class="line"><span class="comment">#pmem	内存使用率</span></div><div class="line"><span class="comment">#comm	命令名</span></div><div class="line"><span class="comment">#cmd	简单命令</span></div><div class="line"><span class="comment">#user	启动进程的用户</span></div><div class="line"><span class="comment">#nice	优先级</span></div><div class="line"><span class="comment">#time	累积的CPU时间</span></div><div class="line"><span class="comment">#etime	进程启动后度过的时间</span></div><div class="line"><span class="comment">#tty	所关联的TTY设备</span></div><div class="line"><span class="comment">#euid	有效用户ID</span></div><div class="line"><span class="comment">#stat	进程状态</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--sort,根据参数对ps输出进行排序</span></div><div class="line"><span class="comment">#+升序，-降序</span></div><div class="line">ps -eo comm,pcpu,pmem --sort -pcpu</div><div class="line">ps -eo comm,pcpu,pmem --sort -pcpu,+pmem</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-C, 给定命令全名找出PID</span></div><div class="line">ps -C cmd -o comm,pid</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-u, 指定有效用户列表</span></div><div class="line"><span class="comment">#-U, 指定真实用户列表</span></div><div class="line">ps -u root -U zhang -o user,pcpu</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-t, 用TTY过滤输出</span></div><div class="line">ps -t TTY1,TTY2...</div><div class="line">ps -t pts/0,pts/1 -ef</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-L, 显示进程相关信息</span></div><div class="line"><span class="comment">#LWP线程ID， NLWP线程数量</span></div><div class="line">ps -efL</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#pgrep命令, 获得一个特定命令的PID列表</span></div><div class="line"><span class="comment">#它只需要命令的一部分即可</span></div><div class="line">pgrep cmd</div><div class="line">pgre inotif</div><div class="line">pgrep bas</div><div class="line"></div><div class="line"><span class="comment">#-d, 指定定界符</span></div><div class="line">pgrep rsync -d <span class="string">":"</span></div><div class="line"></div><div class="line"><span class="comment">#-u, 指定进程的用户</span></div><div class="line">pgrep -u root,zhang rsync</div><div class="line"></div><div class="line"><span class="comment">#-c, 返回匹配的进程数量</span></div><div class="line">pgrep -c rsync</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#top命令</span></div><div class="line">top</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="杀死进程以及发送响应信息-kill-killall-trap"><a href="#杀死进程以及发送响应信息-kill-killall-trap" class="headerlink" title="杀死进程以及发送响应信息(kill+killall+trap)"></a>杀死进程以及发送响应信息(<code>kill+killall+trap</code>)</h2><p>在Unix-Like环境中与进程有关的一个重要概念就是信号。<br>信号是一种进程间通信机制，它用来中断运行的进程以执行某些操作。终止程序也是通过使用信号技术来实现的。</p>
<p>像<code>ctrl+C</code>,<code>ctrl+Z</code>这种作业都属于信号。</p>
<ul>
<li><code>kill</code> 命令可用来向进程发送信号;</li>
<li><code>trap</code> 命令用来处理所接收的信号;</li>
<li><code>killall</code> 以名字方式来杀死进程.</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#列出所有可用信号</span></div><div class="line"><span class="built_in">kill</span> -l</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-s, 发送信号</span></div><div class="line"><span class="comment">#信号名称和信号数都可以</span></div><div class="line"><span class="built_in">kill</span> -信号数 PID</div><div class="line"><span class="built_in">kill</span> -s SIGNAL PID</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#常用信号</span></div><div class="line"><span class="comment">#SIGHUP 1 --对控制进程或终端进行挂起检测(hangup detection);</span></div><div class="line"><span class="comment">#SIGINT 2 --当按下ctrl+c时发送该信号;</span></div><div class="line"><span class="comment">#SIGKILL 9 --强行杀死进程;</span></div><div class="line"><span class="comment">#SIGTERM 15 --终止进程;</span></div><div class="line"><span class="comment">#SIGTSTP 20 --当按下crtl+z时发送该信号.</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#killall, 通过命令名终止进程</span></div><div class="line">killall -s SIGNAL PName</div><div class="line">killall -信号数 PName</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#trap, 捕捉并响应信号</span></div><div class="line"><span class="built_in">trap</span> <span class="string">'signal-handler-func'</span> SIGNAL LIST</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="which-whereis-file-whatis与平均负载"><a href="#which-whereis-file-whatis与平均负载" class="headerlink" title="which, whereis, file, whatis与平均负载"></a><code>which</code>, <code>whereis</code>, <code>file</code>, <code>whatis</code>与平均负载</h2><p><code>which</code> hows the full path of (shell) commands。找出某个命令的位置;<br><code>whereis</code> locate the binary, source, and manual page files for a command。不仅返回命令路径，还能打印命令手册的位置以及命令源代码路径;<br><code>file</code> determine file type。用来确定文件类型;<br><code>whatis</code> display manual page descriptions。输出简短描述信息;<br>平均负载(load average),是系统运行总负载量的一个重要参数。它指明了系统中可运行进程总量的平均值。平均负载由三个值来指定，第一个指明1分钟内的平均值，第二个指明5分钟内的平均值，第三个指明15分钟内的平均值。</p>
<ul>
<li>单核CPU，类似于单车道，负载在 0.00-1.00 之间正常；</li>
<li>多核CPU，类似于多车道，负载在 核数*(0.00-1.00) 之间正常；</li>
<li>安全的系统负载，单核应该在 0.7 以下；</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#查看平均负载</span></div><div class="line">uptime</div><div class="line">cat /proc/loadavg</div><div class="line"><span class="comment">#0.00 0.01 0.05 1/355 44955</span></div><div class="line"><span class="comment">#分母355表示系统进程总数, 分子表示正在运行的进程数, 最后一个数字表示最近运行进程ID</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="向用户终端发送消息"><a href="#向用户终端发送消息" class="headerlink" title="向用户终端发送消息"></a>向用户终端发送消息</h2><p>系统管理员可能需要向网络中所有主机上的所有用户或特定用户的终端发送消息。<br>`wallrsync -av –exclude=”*.s命令用来向所有当前登录用户的终端写入消息。</p>
<p>在Linux系统中，终端是作为设备存在的。因此那些打开的终端在<code>dev/pts/</code>中都会与对应的设备节点文件。向特定设备写入数据将会在对应的终端显示出消息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"It's just a test"</span> | wall</div><div class="line"></div><div class="line"><span class="comment">#查看用户对应的/dev/pts/, 并向某一个用户终端发送信息</span></div><div class="line">ll /dev/pts | awk <span class="string">'&#123;print $3,$6&#125;'</span></div><div class="line"><span class="built_in">echo</span><span class="string">"Haha"</span> &gt; /dev/pts/[1,2,3...]</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="收集系统信息"><a href="#收集系统信息" class="headerlink" title="收集系统信息"></a>收集系统信息</h2><p>包括主机名、内核版本、Linux发行版本、CPU信息、内存信息、磁盘分区信息等。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#主机名</span></div><div class="line">hostname</div><div class="line">uname -n</div><div class="line"></div><div class="line"><span class="comment">#内核版本，架构</span></div><div class="line">uname -r</div><div class="line">uname -m</div><div class="line">uname -a</div><div class="line"></div><div class="line"><span class="comment">#Linux发行版本</span></div><div class="line">cat /etc/redhat-release</div><div class="line"></div><div class="line"><span class="comment">#CPU相关信息</span></div><div class="line">lscpu</div><div class="line">cat /proc/cpuinfo</div><div class="line">cat /proc/cpuinfo | grep <span class="string">'model name'</span></div><div class="line"></div><div class="line"><span class="comment">#内存详细信息</span></div><div class="line">free -h</div><div class="line">cat /proc/meminfo</div><div class="line"></div><div class="line"><span class="comment">#分区信息</span></div><div class="line">cat /proc/partitions</div><div class="line">fdisk -l</div><div class="line"></div><div class="line"><span class="comment">#系统详细信息</span></div><div class="line">lshw</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用-proc收集信息"><a href="#用-proc收集信息" class="headerlink" title="用/proc收集信息"></a>用/proc收集信息</h2><p>在GNU/Linux操作系统中，/proc是一个位于内存中的伪文件系统(in-memory pseudo filesystem)。<br>它的引用是为了提供一个可以从用户空间(user space)读取系统参数的接口。</p>
<p>可以对<code>/proc</code>中的文件和子目录进行<code>cat</code>来获取信息，所有内容都是易读的格式化文本。</p>
<blockquote>
<p>/proc/下的数字目录，包含了对应进程的相关信息；<br>/proc/environ，包含于进程相关联的环境变量；<br>/proc/cwd，是一个到进程工作目录的符号链接；<br>/proc/fbcat，包含了由进程所使用的文件描述符。</p>
</blockquote>
<p><br></p>
<h2 id="用cron进行调度"><a href="#用cron进行调度" class="headerlink" title="用cron进行调度"></a>用cron进行调度</h2><p>GNU/Linux系统包含了各种用于调度任务的工具。cron就是其中之一，它通过守护进程crond使得任务能够以固定的时间间隔在系统后台自动运行。<br>cron利用的是一个被称为“cron表(cron table)”的文件，这个文件中存储了需要执行的脚本或命令的调度列表以及执行时间。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#分 时 日 月 周</span></div><div class="line"><span class="comment">#*  *  *  *  *  cmd</span></div><div class="line"><span class="comment">#分钟(0-59)</span></div><div class="line"><span class="comment">#小时(0-23)</span></div><div class="line"><span class="comment">#天(1-31)</span></div><div class="line"><span class="comment">#月(1-12)</span></div><div class="line"><span class="comment">#工作日(0-7)，0和7都代表周天</span></div><div class="line"><span class="comment">#命令</span></div><div class="line"></div><div class="line"><span class="comment">#*号,所有值</span></div><div class="line"><span class="comment">#,号,范围。1,3,5,7,9</span></div><div class="line"><span class="comment">#-号,连续范文。1-10</span></div><div class="line"><span class="comment">#/号,*/10;0-8/20</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">crontab -e</div><div class="line"></div><div class="line">* 0-6 * * * /home/zhang/test.sh</div><div class="line">1,3,5,7,9 * * * * /home/zhang/test.sh</div><div class="line">*/5 * * * * /home/zhang/test.sh</div><div class="line"></div><div class="line"><span class="comment">#-l,查看cron表</span></div><div class="line">crontab -l</div><div class="line"></div><div class="line"><span class="comment">#-r,移除cron表</span></div><div class="line">crontab -r</div></pre></td></tr></table></figure>
<h3 id="cron的高级写法"><a href="#cron的高级写法" class="headerlink" title="cron的高级写法"></a><code>cron</code>的高级写法</h3><p>栗子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@reboot  <span class="comment">#在启动的时候运行一次</span></div><div class="line"><span class="comment">#其实@reboot类似于rc.local，开机启动</span></div><div class="line"></div><div class="line">@yearly == @annually == 0 0 1 1 *  <span class="comment">#一年一次</span></div><div class="line"></div><div class="line">@monthly == 0 0 1 * *  <span class="comment">#每月一次</span></div><div class="line"></div><div class="line">@weekly  == 0 0 * * 0  <span class="comment">#每周一次</span></div><div class="line"></div><div class="line">@daily == @midnight == 0 0 * * *  <span class="comment">#每天一次</span></div><div class="line"></div><div class="line">@hourly == 0 * * * *  <span class="comment">#每小时一次</span></div><div class="line"></div><div class="line"></div><div class="line">crontab -e</div><div class="line">@reboot /bin/mongod -f /etc/mongod_27018.conf</div><div class="line"></div><div class="line">vim /etc/rc.d/rc.local</div><div class="line">/bin/mongod -f /etc/mongod_27018.conf</div><div class="line">chmod a+x /etc/rc.d/rc.local</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="用户管理常用命令"><a href="#用户管理常用命令" class="headerlink" title="用户管理常用命令"></a>用户管理常用命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#添加用户</span></div><div class="line">useradd</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#删除用户</span></div><div class="line">userdel</div><div class="line">--remove-all-file删除与用户相关的所有文件</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#修改shell</span></div><div class="line">chsh</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#修改用户属性</span></div><div class="line">usermod</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#修改密码过期时间</span></div><div class="line">chage</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#修改密码</span></div><div class="line">passwd</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#登录到一个新组</span></div><div class="line">newgrp</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#添加、删除组</span></div><div class="line">groupadd</div><div class="line">groupdel</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指纹</span></div><div class="line">finger</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;小试牛刀&quot;&gt;&lt;a href=&quot;#小试牛刀&quot; class=&quot;headerlink&quot; title=&quot;小试牛刀&quot;&gt;&lt;/a&gt;小试牛刀&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#bash(Bourne Again Shell)，shell环境使得用户能与操作系统的内核进行交互操作&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#!/bin/bash&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#date&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#description&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cmd1; cmd2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cmd3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#sh /path/xx.sh&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Bash还有一个历史记录文件 ~/.bash_history&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Shell" scheme="https://zhang21.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>工作与人生</title>
    <link href="https://zhang21.github.io/2017/09/04/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E4%BA%BA%E7%94%9F/"/>
    <id>https://zhang21.github.io/2017/09/04/工作与人生/</id>
    <published>2017-09-04T05:57:36.000Z</published>
    <updated>2017-11-03T01:54:52.321Z</updated>
    
    <content type="html"><![CDATA[<p>  我现在已经活到了人生的中途，拿一日来比喻人的一生，现在正是中午。人在童年时从朦胧中醒来．需要一些时间来克服清晨的软弱，然后就要投入工作；在正午时分，他的精力最为充沛，但已隐隐感到疲惫；到了黄昏时节，就要总结一日的工作，准备沉入永恒的休息。按我这种说法，工作是人一生的主题。这个想法不是人人都能同意的。我知道在中国，农村的人把生儿育女看作是一生的主题。把儿女养大，自己就死掉，给他们空出地方来——这是很流行的想法。在城市里则另有一种想法，但不知是不是很流行：它把取得社会地位看作一生的主题。站在北京八宝山的骨灰墙前，可以体会到这种想法。我在那里看到一位已故的大叔墓上写着：副系主任、支部副书记、副教授、某某教研室副主任，等等。假如能把这些“副”字去掉个把，对这位大叔当然更好一些，但这些“副”字最能证明有这样一种想法。顺便说一句，我到美国的公墓里看过，发现他们的墓碑上只写两件事：一是生卒年月。二是某年至某年服兵役；这就是说，他们以为人的一生只有这两件事值得记述：这位上帝的子民曾经来到尘世，以及这位公民曾去为国尽忠，写别的都是多余的，我觉得这种想法比较质朴……恐怕在一份青年刊物上写这些墓前的景物是太过伤感，还是及早回到正题上来罢。<br><a id="more"></a></p>
<p>  我想要把自己对人生的看法推荐给青年朋友们：人从工作中可以得到乐趣，这是一种巨大的好处。相比之下，从金钱、权力、生育子女方面可以得到的快乐，总要受到制约。举例来说，现在把生育作为生活的主题，首先是不合时宜；其次，人在生育力方面比兔子大为不如，更不要说和黄花鱼相比较；在这方面很难取得无穷无尽的成就。我对权力没有兴趣，对钱有一些兴趣，但也不愿为它去受罪——做我想做的事(这件事对我来说，就是写小说)，并且把它做好，这就是我的目标。我想，和我志趣相投的人总不会是一个都没有。<br><br><br>  根据我的经验，人在年轻时，最头疼的一件事就是决定自己这一生要做什么。在这方面，我倒没有什么具体的建议：干什么都可以，但最好不要写小说，这是和我抢饭碗。当然，假如你执意要写，我也没理由反对。总而言之，干什么都是好的；但要干出个样子来，这才是人的价值和尊严所在。人在工作时，不单要用到手、腿和腰，还要用脑子和自己的心胸。我总觉得国人对这后一方面不够重视，这样就会把工作看成是受罪。失掉了快乐最主要的源泉，对生活的态度也会因之变得灰暗……<br><br><br>  人活在世上，不但有身体，还有头脑和心胸——对此请勿从解剖学上理解。人脑是怎样的一种东西，科学还不能说清楚。心胸是怎么回事就更难说清。对我自己来说，心胸是我在生活中想要达到的最低目标。某件事有悖于我的心胸，我就认为它不值得一做；某个人有悖于我的心胸，我就觉得他不值得一交；某种生活有悖于我的心胸，我就会以为它不值得一过。罗素先生曾言，对人来说，不加检点的生活，确实不值得一过。我同意他的意见：不加检点的生活，属于不能接受的生活之一种。人必须过他可以接受的生活，这恰恰是他改变一切的动力。人有了心胸，就可以用它来改变自己的生活。<br><br><br>  中国人喜欢接受这样的想法：只要能活着就是好的，活成什么样子无所谓。从一些电影的名字就可以看出来：《活着》、《找乐》……我对这种想法是断然地不赞成。因为抱有这种想法的人就可能活成任何一种糟糕的样子，从而使生活本身失去意义。高尚、清洁、充满乐趣的生活是好的，人们很容易得到共识。卑下、肮脏、贫乏的生活是不好的，这也能得到共识。但只有这两条远远不够。我以写作为生，我知道某种文章好，也知道某种文章坏。仅知道这两条尚不足以开始写作。还有更加重要的一条，那就是：某种样子的文章对我来说不可取，绝不能让它从我笔下写出来，冠以我的名字登在报刊上。以小喻大，这也是我对生活的态度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  我现在已经活到了人生的中途，拿一日来比喻人的一生，现在正是中午。人在童年时从朦胧中醒来．需要一些时间来克服清晨的软弱，然后就要投入工作；在正午时分，他的精力最为充沛，但已隐隐感到疲惫；到了黄昏时节，就要总结一日的工作，准备沉入永恒的休息。按我这种说法，工作是人一生的主题。这个想法不是人人都能同意的。我知道在中国，农村的人把生儿育女看作是一生的主题。把儿女养大，自己就死掉，给他们空出地方来——这是很流行的想法。在城市里则另有一种想法，但不知是不是很流行：它把取得社会地位看作一生的主题。站在北京八宝山的骨灰墙前，可以体会到这种想法。我在那里看到一位已故的大叔墓上写着：副系主任、支部副书记、副教授、某某教研室副主任，等等。假如能把这些“副”字去掉个把，对这位大叔当然更好一些，但这些“副”字最能证明有这样一种想法。顺便说一句，我到美国的公墓里看过，发现他们的墓碑上只写两件事：一是生卒年月。二是某年至某年服兵役；这就是说，他们以为人的一生只有这两件事值得记述：这位上帝的子民曾经来到尘世，以及这位公民曾去为国尽忠，写别的都是多余的，我觉得这种想法比较质朴……恐怕在一份青年刊物上写这些墓前的景物是太过伤感，还是及早回到正题上来罢。&lt;br&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="王小波" scheme="https://zhang21.github.io/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>告别信</title>
    <link href="https://zhang21.github.io/2017/09/04/%E5%91%8A%E5%88%AB%E4%BF%A1/"/>
    <id>https://zhang21.github.io/2017/09/04/告别信/</id>
    <published>2017-09-04T03:46:11.000Z</published>
    <updated>2017-09-04T04:07:53.092Z</updated>
    
    <content type="html"><![CDATA[<p>1999年，72岁的马尔克斯患上淋巴癌后，写了一封信向读者告别。<br><img src="/images/farewell.png" alt=""><br><a id="more"></a><br>如果有一刹那，上帝忘记我是一只布偶并赋予我片刻生命，我可能不会说出我心中的一切所想，但我必定会思考我所说的一切。</p>
<p>我会评价事物，按其意义大小而非价值多少。  </p>
<p>我会少睡觉，多思考。因为我知道，每当我们闭上一分钟眼睛，我们也就同时失去了60秒。当他人停滞时我会前行，当他人入梦时我会清醒，当他人讲话时我会倾听，就像享受一支美味的巧克力冰激凌！  </p>
<p>如果上帝赏我一段生命，我会简单装束，伏在阳光下，袒露的不仅是身体，还有我的魂灵。 </p>
<p>上帝呀，如果我有一颗心，我会将仇恨写在冰上，然后期待太阳的升起；我会用凡高的梦在星星上画一首贝内德第的诗，而塞莱特的歌会是将是我献给月亮的小夜曲。我会用泪水浇灌玫瑰，以此体味花刺的痛苦和花瓣的亲吻……  </p>
<p>上帝呀，如果我有一段生命……我不会放过哪怕是一天，而不对我所爱的人说我爱他们。我会使每个男人和女人都了解他们皆我所爱，我要怀着爱而生活。  </p>
<p>对于大人，我会向他们证明，那种认为因衰老而失去爱的想法是多么错误，我们是因为失去爱而衰老而不是与之相反。对于孩子，我会给他们插上翅膀而让他们自己学会飞翔；对于老人，我会教给他们死亡的来临不是因为衰老而是因为遗忘。  </p>
<p>人呀，我从你们身上学会了太多的东西… …我知道，人们都想伫立在颠峰上，殊不知，真正的幸福恰恰就在于攀登险阻的过程。我懂得，当婴儿用小拳头第一次抓住爸爸的手指时，他也就永远地抓住了它。  </p>
<p>我明白，一个人只有在帮助他人站起时才有权利俯视他。我能够从你们身上学到的东西是如此之多，可事实上已经意义寥寥，因为当人们将我敛入棺木时，我正在死去。  </p>
<p>永远说你感到的，做你想到的吧！如果我知道今天是我最后一次看你入睡，我会热烈地拥抱你，祈求上帝守护你的灵魂。如果我知道这是最后一次看你离开家门，我会给你一个拥抱一个吻，然后重新叫住你，再度拥抱亲吻。如果我知道这是最后一次听到你的声音，我会录下你的每个字句，以便可以一遍又一遍永无穷尽地倾听。如果我知道这是看到你的最后几分钟，我会说”我爱你”，而不是傻傻地以为你早已知道。  </p>
<p>永远有一个明天，生活给我们另一个机会将事情做好，可是如果我搞错了，今天就是我们所剩的全部，我会对你说我多么爱你，我永远不会忘记你。  </p>
<p>明天从不向任何人作保证，无论青年或老人，今天可能就是你最后一次看到你所爱的人。因此，别再等待了，今天就开始！因为如果明天永远不来，你也许会遗憾今天没来得及微笑，拥抱，亲吻，会遗憾自己忙碌得只能把它们归为一个最后的愿望。保护周围你爱的人吧，告诉他们你多么需要他们。爱他们，善待他们，用些时间对他们说：”对不起”，”原谅我”，”劳驾”，”谢谢”，以及你知道的所有爱的话语。  </p>
<p>没有人会因为你秘而不宣的思想而记住你。向上帝祈求力量和智慧来表达它们吧，向你的朋友证明，他们对你来说是多么的重要。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1999年，72岁的马尔克斯患上淋巴癌后，写了一封信向读者告别。&lt;br&gt;&lt;img src=&quot;/images/farewell.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="马尔克斯" scheme="https://zhang21.github.io/tags/%E9%A9%AC%E5%B0%94%E5%85%8B%E6%96%AF/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="https://zhang21.github.io/2017/09/01/Markdown%E8%AF%AD%E6%B3%95/"/>
    <id>https://zhang21.github.io/2017/09/01/Markdown语法/</id>
    <published>2017-09-01T10:16:38.000Z</published>
    <updated>2017-12-11T03:00:37.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于Markdown"><a href="#关于Markdown" class="headerlink" title="关于Markdown"></a>关于Markdown</h2><p>Markdown 是一种轻量级标记语言。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。</p>
<h3 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h3><p><strong><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="external">Markdown-wiki</a></strong><br><strong><a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="external">Markdown官网</a></strong><br><strong><a href="https://markdown-zh.readthedocs.io/en/latest/" target="_blank" rel="external">Markdown中文文档</a></strong><br><strong><a href="http://itmyhome.com/markdown/article/extension/strikethrougn.html" target="_blank" rel="external">Markdown语法</a></strong></p>
<a id="more"></a>
<p><br></p>
<h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><h3 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#一个空格</div><div class="line">&amp;ensp;</div><div class="line"></div><div class="line">#两个空格</div><div class="line">&amp;emsp;</div><div class="line"></div><div class="line">#不断行空白格</div><div class="line">&amp;nbsp;</div></pre></td></tr></table></figure>
<p><strong>栗子：</strong></p>
<ol>
<li>&ensp;一个空格；</li>
<li>&emsp;两个空格；</li>
<li>&nbsp;不断行空白格；</li>
</ol>
<p><br></p>
<h3 id="段落与换行"><a href="#段落与换行" class="headerlink" title="段落与换行"></a>段落与换行</h3><ul>
<li>段落的前后必须是空行<br>空行是指行内什么都没有，或者只有空白符（空格或制表符）<br>相邻两行文本，如果中间没有空行，会显示在一行中（换行符被转换为空格）</li>
<li>如果需要在段内加入换行 <br><br>可以在前一行的末尾加入至少两个空格，然后换行写其它的文字</li>
<li>Markdown中的多数区块都需要在两个空行之间</li>
</ul>
<p><br></p>
<h3 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h3><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*斜体*, _斜体_</div><div class="line">**粗体**</div><div class="line">***粗斜体***</div><div class="line">~~删除线~~</div></pre></td></tr></table></figure></p>
<p>显示效果：</p>
<ul>
<li><em>斜体</em>, <em>斜体</em></li>
<li><strong>粗体</strong></li>
<li><strong><em>粗斜体</em></strong></li>
<li><del>删除线</del></li>
</ul>
<p><br></p>
<h3 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h3><h4 id="Setext形式"><a href="#Setext形式" class="headerlink" title="Setext形式"></a>Setext形式</h4><p>大标题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">一级大标题</div><div class="line">========</div><div class="line"></div><div class="line">二级大标题</div><div class="line">--------</div></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="atx形式"><a href="#atx形式" class="headerlink" title="atx形式"></a>atx形式</h4><p>普通标题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 一级标题</div><div class="line">## 二级标题</div><div class="line">### 三级标题</div><div class="line">#### 四级标题</div><div class="line">##### 五级标题</div></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>MarkDown支持两种形式的链接语法：行内式和参考式。</p>
<h4 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h4><p>语法说明：<br>[ ] 里面写链接文字，( ) 里面写链接地址，()中的” “可以指定title属性。</p>
<p>代码：<br><code>欢迎来到 [简书](www.jianshu.com &quot;Jianshu&quot;)</code></p>
<p>效果：<br>欢迎来到 <a href="www.jianshu.com" title="Jianshu">简书</a></p>
<h4 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h4><p>参考式超链接一般用在学术论文上面，或某一个链接在文章中多处使用，那么引用的方式创建链接将非常好，它可以让你对链接进行统一的管理。<br>语法说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">参考式链接分为两部分，文中的写法[链接文字][链接标记]，在文本任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格</div><div class="line">如果链接文字本身可以作为链接标记，也可以写成[链接文字][]</div><div class="line">[链接文字]：链接地址的形式</div></pre></td></tr></table></figure></p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">简书里面有 [简书早报][1]、[简书晚报][2]以及 [简黛玉][3]</div><div class="line">[简黛玉 美人][3] 是一个[才女][]</div><div class="line">[1]:http://www.jianshu.com &quot;Jianshu&quot;</div><div class="line">[2]:http://www.jianshu.com &quot;EveningPaper&quot;</div><div class="line">[3]:http://www.jianshu.com</div><div class="line">[才女]:http://www.jianshu.com</div></pre></td></tr></table></figure></p>
<p>效果：<br>简书里面有 <a href="http://www.jianshu.com" title="Jianshu" target="_blank" rel="external">简书早报</a>、<a href="http://www.jianshu.com" title="EveningPaper" target="_blank" rel="external">简书晚报</a>以及<a href="http://www.jianshu.com" target="_blank" rel="external">简黛玉</a><br><a href="http://www.jianshu.com" target="_blank" rel="external">简黛玉 美人</a> 是一个<a href="http://www.jianshu.com" target="_blank" rel="external">才女</a><br><br></p>
<h4 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h4><p>MarkDown支持以比较简短的自动链接形式来处理网址和电子邮件，只要用&lt;&gt;包起来，MarkDown就会自动把它转成链接。</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;http://example.com&gt;</div><div class="line">&lt;address@example.com&gt;</div></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>MarkDown Extra只支持在标题后插入锚点，其他地方无效<br>Leanote编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，你发布后的文章是支持的<br>在你准备跳转到的指定标题后插入锚点 { # 标记 }，然后在其他地方写上连接到锚点的链接</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">目录 \&#123; \# index \&#125;</div><div class="line">跳转到 \[ 目录\ ]( \# index)</div></pre></td></tr></table></figure></p>
<p>效果：<br>目录 { #index }<br>跳转到 [目录 ](#index)</p>
<p><br></p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>使用 <code>* ，+ ，-</code> 表示无序列表</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- 无序列表1</div><div class="line">- 无序列表2</div><div class="line">- 无序列表3</div></pre></td></tr></table></figure></p>
<p>效果：</p>
<ul>
<li>无序列表1</li>
<li>无序列表2</li>
<li>无序列表3</li>
</ul>
<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>有序列表使用数字接着英文点</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 有序列表1</div><div class="line">2. 有序列表2</div><div class="line">3. 有序列表3</div></pre></td></tr></table></figure></p>
<p>效果：</p>
<ol>
<li>有序列表1</li>
<li>有序列表2</li>
<li>有序列表3</li>
</ol>
<h4 id="定义型列表"><a href="#定义型列表" class="headerlink" title="定义型列表"></a>定义型列表</h4><p>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法：紧跟一个缩进（Tab）</p>
<h4 id="列表缩进"><a href="#列表缩进" class="headerlink" title="列表缩进"></a>列表缩进</h4><p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多3个空格，项目标记后则一定要接着至少一个空格或制表符。</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*    轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。</div><div class="line">那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。</div><div class="line">*    那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。</div></pre></td></tr></table></figure></p>
<p>效果：</p>
<ul>
<li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。</li>
<li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。</li>
</ul>
<p><br></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用需要在被引用的文本前加上 &gt; 符号</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; 引用1</div><div class="line">&gt; 引用2</div></pre></td></tr></table></figure></p>
<p>效果：</p>
<blockquote>
<p>引用1<br>引用2</p>
</blockquote>
<h4 id="引用的多层嵌套"><a href="#引用的多层嵌套" class="headerlink" title="引用的多层嵌套"></a>引用的多层嵌套</h4><p>区块引用可以嵌套（如引用的引用），只要根据层次加上不同数量的 <code>&gt;</code>符号</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; 请问MarkDown怎么用？</div><div class="line">&gt;&gt; 自己看教程！</div><div class="line">&gt; 教程在哪里？</div></pre></td></tr></table></figure></p>
<p>效果：</p>
<blockquote>
<p>请问MarkDown怎么用？</p>
<blockquote>
<p>自己看教程！</p>
<blockquote>
<p>教程在哪里？</p>
</blockquote>
</blockquote>
</blockquote>
<p><br></p>
<h3 id="插入图像"><a href="#插入图像" class="headerlink" title="插入图像"></a>插入图像</h3><p>图片的创建方式与超链接类似。</p>
<p>代码：<br><code>![](http://zhangxx5678.lofter.com/post/39b969_df4f526#)</code></p>
<p><br></p>
<h3 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容结构目录</p>
<p><br></p>
<h3 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h3><p>在需要添加注脚的文字后加上注脚名字 [^注脚名字]，称为加注。然后在文中的任意位置（一般最后）添加脚注，脚注前必须有对应的脚注名字。<br>注脚与注脚间必须空一行！<br>注脚自动被搬运到最后面，请到文章末尾查看，并且脚注后的链接可以直接跳转会到加注的地方</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">使用 MarkDown[^1]可以提高书写效率，直接转换成 HTML[^2]</div><div class="line">[^1]:MarkDown是一种纯文本标记语言</div><div class="line">[^2]:HTML超文本标记语言</div></pre></td></tr></table></figure></p>
<p>效果：<br> 使用 MarkDown<a href="MarkDown是一种纯文本标记语言">^1</a>可以提高书写效率，直接转换成 HTML<a href="HTML超文本标记语言">^2</a></p>
<p><br></p>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>可以在一行中用 三个以上的 <code>*</code>,<code>-</code>,<code>_</code> 建立一个分割线，行内不能有其他东西。</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1. * * *</div><div class="line">2.</div><div class="line">3. ***</div><div class="line">4.</div><div class="line">5. - - -</div><div class="line">6.</div><div class="line">7. ---</div></pre></td></tr></table></figure></p>
<p>效果：</p>
<hr>
<hr>
<hr>
<hr>
<p><br></p>
<h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h2><p>Markdown标准 本身所包含的功能有限，所以产生了许多第三方扩展语法，如 <a href="https://help.github.com/categories/writing-on-github/" target="_blank" rel="external">GFW, GitHub Flavored Markdown</a></p>
<h3 id="Tasklist"><a href="#Tasklist" class="headerlink" title="Tasklist"></a>Tasklist</h3><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- [ ] Monday</div><div class="line">- [ ] Tuesday</div><div class="line">- [ ] Wednesday</div><div class="line">- [ ] Tuesday</div><div class="line">- [ ] Friday</div></pre></td></tr></table></figure></p>
<p>效果：</p>
<ul>
<li style="list-style: none"><input type="checkbox"> Monday</li>
<li style="list-style: none"><input type="checkbox"> Tuesday</li>
<li style="list-style: none"><input type="checkbox"> Wednesday</li>
<li style="list-style: none"><input type="checkbox"> Tuesday</li>
<li style="list-style: none"><input type="checkbox"> Friday</li>
</ul>
<p><br></p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ol>
<li>不管是哪种方式，第一行为表头，第二行为分割表头和主体部分，第三行开始每一行为一个表格行；</li>
<li>列与列之间用管道符号 | 隔开；</li>
<li>第二行还可以为不同的列指定对其方向，默认左对齐，在 - 右边加上 : 就右对齐</li>
</ol>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">学号 | 姓名 | 分数</div><div class="line">- | - | -</div><div class="line">001 | 张三 | 78</div><div class="line">002 | 李四 | 67</div><div class="line">003 | 王五 | 99</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>张三</td>
<td>78</td>
</tr>
<tr>
<td>002</td>
<td>李四</td>
<td>67</td>
</tr>
<tr>
<td>003</td>
<td>王五</td>
<td>99</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="代码块和高亮"><a href="#代码块和高亮" class="headerlink" title="代码块和高亮"></a>代码块和高亮</h3><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>插入代码的方式有两种，一种是利用缩进(Tab)，另一种是利用反引号 `` 和 ```     ```</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Python语言的输出函数 `Print()` 怎么使用？</div></pre></td></tr></table></figure></p>
<p>效果：<br>Python语言的输出函数 <code>Print()</code> 怎么使用？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">from flask import Flask</div><div class="line">app = Flask(app)</div></pre></td></tr></table></figure>
<h4 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h4><p>在 ``` 之后添加代码的语言</p>
<p>代码：<br>```python<br>import os<br>from flask import Flask<br>app = Flask(app)<br>```</p>
<p>效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line">app = Flask(app)</div></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><strong> <a href="http://flowchart.js.org/" target="_blank" rel="external">流程图语法参考</a> </strong></p>
<p><br></p>
<h3 id="LaTeX公式"><a href="#LaTeX公式" class="headerlink" title="LaTeX公式"></a>LaTeX公式</h3><p><strong><a href="https://zh.wikipedia.org/wiki/LaTeX" target="_blank" rel="external">关于LaTEX：</a></strong></p>
<blockquote>
<p>是一种跨平台的基于<a href="https://zh.wikipedia.org/wiki/TeX" target="_blank" rel="external">TEX</a>的排版系统，对于生成复杂表格和数学公式，这一点表现得尤为突出。<br>因此它非常适用于生成高印刷质量的科技和数学、化学类文档。</p>
</blockquote>
<p><strong><a href="https://en.wikipedia.org/wiki/MathJax" target="_blank" rel="external">关于MathJax：</a></strong></p>
<blockquote>
<p>MathJax是一种跨浏览器JavaScript库，它使用MathML，LaTeX和ASCIIMathML 标记在Web浏览器中显示数学符号。<br>MathJax作为Apache License下的开源软件。</p>
</blockquote>
<p><strong><a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">MathJax语法</a></strong></p>
<p><br></p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>$</code>表示行内公式<br>质能守恒公式 <code>$E=mc^2$</code> 方程式</p>
<p>效果：$E=mc^2$</p>
<p><code>$$</code>表示整行公式</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$$\sum_&#123;i=1&#125;^n a_i=0$$</div><div class="line"></div><div class="line">$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</div><div class="line"></div><div class="line">$$\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$$</div></pre></td></tr></table></figure></p>
<p>效果：<br>$$\sum_{i=1}^n a_i=0$$</p>
<p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p>
<p>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p>
<p><br></p>
<h2 id="Markdown编辑器"><a href="#Markdown编辑器" class="headerlink" title="Markdown编辑器"></a>Markdown编辑器</h2><p>介绍一些常用的书写、编辑Markdown的工具。</p>
<ul>
<li>MarkdownPad Windows (windows);</li>
<li>Texts (Windows, osX);</li>
<li>MarkPad (Windows);</li>
<li>Haroopad (Windows, osX, Linux);</li>
<li>ReText (Linux);</li>
<li>等等</li>
</ul>
<p><br></p>
<h2 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h2><p>Markdown文档可以方便地转换为 HTML, Word, PDF 等文件格式。<br>可以利用 软件 或者 命令 转换文件。</p>
<h3 id="转换为-HTML"><a href="#转换为-HTML" class="headerlink" title="转换为 HTML"></a>转换为 HTML</h3><h3 id="转换为-PDF"><a href="#转换为-PDF" class="headerlink" title="转换为 PDF"></a>转换为 PDF</h3><h3 id="转换为-Word"><a href="#转换为-Word" class="headerlink" title="转换为 Word"></a>转换为 Word</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于Markdown&quot;&gt;&lt;a href=&quot;#关于Markdown&quot; class=&quot;headerlink&quot; title=&quot;关于Markdown&quot;&gt;&lt;/a&gt;关于Markdown&lt;/h2&gt;&lt;p&gt;Markdown 是一种轻量级标记语言。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。&lt;/p&gt;
&lt;h3 id=&quot;参考文件&quot;&gt;&lt;a href=&quot;#参考文件&quot; class=&quot;headerlink&quot; title=&quot;参考文件&quot;&gt;&lt;/a&gt;参考文件&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Markdown&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markdown-wiki&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;&lt;a href=&quot;https://daringfireball.net/projects/markdown/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markdown官网&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;&lt;a href=&quot;https://markdown-zh.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markdown中文文档&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;&lt;a href=&quot;http://itmyhome.com/markdown/article/extension/strikethrougn.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markdown语法&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="https://zhang21.github.io/categories/Network/"/>
    
    
      <category term="Markdown" scheme="https://zhang21.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
