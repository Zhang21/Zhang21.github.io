<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风继续吹</title>
  
  <subtitle>Yesterday, you said tomorrow!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhang21.github.io/"/>
  <updated>2018-02-09T03:16:16.961Z</updated>
  <id>https://zhang21.github.io/</id>
  
  <author>
    <name>Zhang21</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://zhang21.github.io/2018/02/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://zhang21.github.io/2018/02/08/正则表达式/</id>
    <published>2018-02-08T03:33:16.000Z</published>
    <updated>2018-02-09T03:16:16.961Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>《鸟哥的Linux私房菜》</li><li>正则表达式： <a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F</a></li></ul><p><br><br><br></p><a id="more"></a><p><br></p><h1 id="正则表达式介绍"><a href="#正则表达式介绍" class="headerlink" title="正则表达式介绍"></a>正则表达式介绍</h1><p>正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法(Regular Expression, 在代码中常简写为regex、regexp或RE）。<br>是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p><p><br></p><p>正则表达式的POSIX规范，分为两大流派：</p><ul><li>基本型正则表达式（Basic Regular Expression，BRE）<ul><li><code>grep</code>、<code>vi</code>、<code>sed</code>都属于BRE，是历史最早的正则表达式，因此元字符必须转译之后才具有特殊含义</li></ul></li><li>扩展型正则表达式（Extended Regular Express，ERE）<ul><li><code>egrep</code>、<code>awk</code>则属于ERE，元字符不用转译</li></ul></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="正则表达式基本语法"><a href="#正则表达式基本语法" class="headerlink" title="正则表达式基本语法"></a>正则表达式基本语法</h1><p>一个正则表达式通常被称为一个模式（pattern），用来描述或者匹配一系列匹配某个句法规则的字符串。</p><p><br></p><p>大部分正则表达式有如下结构：</p><ul><li><strong>选择</strong><ul><li><code>|</code>竖线符代表选择(或)，具有最低优先级</li></ul></li><li><strong>数量限定</strong><ul><li>字符后的数量限定符用来限定前面这个字符允许出现的个数</li><li>不加数量限定则代表仅出现一次</li><li>常见的数量限定符包括 <strong>+</strong>、<strong>?</strong>、<strong>*</strong><ul><li><code>+</code>加号代表前面的字符必须至少出现一次 ( $$$&gt;=1$$$ )</li><li><code>?</code>问号代表前面的字符最多只可出现一次 ( $$$1&gt;=?&gt;=0$$$ )</li><li><code>*</code>星号代表前面的字符可不出现，也可出现一次或多次 ($$$&gt;=0$$$)</li></ul></li></ul></li><li><strong>匹配</strong><ul><li><code>()</code>圆括号可以定义操作符的范围和优先度</li></ul></li></ul><p><br><br><br></p><hr><p><br></p><h1 id="PCRE表达式全集"><a href="#PCRE表达式全集" class="headerlink" title="PCRE表达式全集"></a>PCRE表达式全集</h1><p>正则表达式有多种不同的风格。<br>PCRE（Perl兼容正则表达式，Perl Compatible Regular Expression）。适用于Perl或者Python编程语言（grep或者egrep的正则表达式文法是PCRE的子集）</p><p><br></p><p><strong>基础正则表达式</strong></p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>转义字符</td></tr><tr><td>zhang</td><td>匹配文本字符串值<code>zhang</code></td></tr><tr><td>.</td><td>匹配除<code>\r</code>,<code>\n</code>之外的任何单个字符</td></tr><tr><td>竖线l</td><td>匹配竖线两边某一个</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次</td></tr><tr><td>{n}</td><td>n是一个非负整数。匹配n次</td></tr><tr><td>{n,}</td><td>n是一个非负整数。至少匹配n次</td></tr><tr><td>{n,m}</td><td>m和n均为非负整数，匹配n-m次</td></tr><tr><td>[xyz]</td><td>字符集合（character class）。匹配所包含的任意一个字符</td></tr><tr><td>[^xyz]</td><td>排除型字符集合（negated character classes）。匹配未列出的任意字符</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符</td></tr><tr><td>[^a-z]</td><td>排除型的字符范围。匹配任何不在指定范围内的任意字符</td></tr><tr><td>[:name:]</td><td>增加命名字符类（named character class）</td></tr><tr><td>[=elt=]</td><td>增加当前locale下排序（collate）等价于字符“elt”的元素</td></tr><tr><td>[.elt.]</td><td>增加排序元素（collation element）elt到表达式中。这是因为某些排序元素由多个字符组成</td></tr></tbody></table><p><br></p><p><strong>元字符</strong><br>元字符(meta character)，是一种Perl风格的正则表达式，只有一部分文本处理工具支持它。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置</td></tr><tr><td>\B</td><td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”</td></tr><tr><td>\cx</td><td>匹配由x指明的控制字符</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于[0-9]。注意Unicode正则表达式会匹配全角数字字符</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于[^0-9]</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于\x0c和\cL</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于\x0a和\cJ</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于\x0d和\cM</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于[^ \f\n\r\t\v]</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于\x09和\cI</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于\x0b和\cK</td></tr><tr><td>\w</td><td>匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。注意Unicode正则表达式会匹配中文字符</td></tr><tr><td>\W</td><td>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”</td></tr><tr><td>\ck</td><td>匹配控制转义字符。k代表一个字符。等价于“Ctrl-k”。用于ECMA语法</td></tr><tr><td>\xnn</td><td>十六进制转义字符序列。匹配两个十六进制数字nn表示的字符</td></tr><tr><td>\num</td><td>向后引用（back-reference）一个子字符串（substring），该子字符串与正则表达式的第num个用括号围起来的捕捉群（capture group）子表达式（subexpression）匹配。其中num是从1开始的十进制正整数，其上限可能是9[注 2]、31、[注 3]99甚至无限。[注 4]例如：“(.)\1”匹配两个连续的相同字符</td></tr><tr><td>\n</td><td>标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值</td></tr><tr><td>\nm</td><td>3位八进制数字，标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm</td></tr><tr><td>\nml</td><td>如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml</td></tr><tr><td>\un</td><td>Unicode转义字符序列。其中n是一个用四个十六进制数字表示的Unicode字符</td></tr></tbody></table><p><br></p><p><strong>扩展正则表达式</strong></p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>?</td><td>非贪心量化（Non-greedy quantifiers）：当该字符紧跟在任何一个其他重复修饰符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串</td></tr><tr><td>(pattern)</td><td>匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”</td></tr><tr><td>(?:pattern)</td><td>匹配pattern但不获取匹配的子字符串（shy groups)，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用</td></tr><tr><td>(?=pattern)</td><td>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用</td></tr><tr><td>(?!pattern)</td><td>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用</td></tr><tr><td>(?&lt;=pattern)</td><td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反</td></tr><tr><td>(?&lt;!pattern)</td><td>反向否定预查，与正向否定预查类似，只是方向相反</td></tr></tbody></table><p><br><br><br></p><hr><p><br></p><h1 id="POSIX字符组"><a href="#POSIX字符组" class="headerlink" title="POSIX字符组"></a>POSIX字符组</h1><p>POSIX字符类(POSIX character class),是一个形如[:…:]的特殊元序列，它用于匹配特定的字符范围。</p><table><thead><tr><th>POSIX字符组</th><th>说明</th><th>ASCII环境</th><th>Unicode环境</th></tr></thead><tbody><tr><td>[:alnum:]</td><td>字母字符和数字字符</td><td>[a-zA-Z0-9]</td><td>[\p{L&amp;}\p{Nd}]</td></tr><tr><td>[:alpha:]</td><td>字母</td><td>[a-zA-Z]</td><td>\p{L&amp;}</td></tr><tr><td>[:ascii:]</td><td>ASCII字符</td><td>[\x00-\x7F]</td><td>\p{InBasicLatin}</td></tr><tr><td>[:blank:]</td><td>空格字符和制表符</td><td>[ \t]</td><td>[\p{Zs}\t]</td></tr><tr><td>[:cntrl:]</td><td>控制字符</td><td>[\x00-\x1F\x7F]</td><td>\p{Cc}</td></tr><tr><td>[:digit:]</td><td>数字字符</td><td>[0-9]</td><td>\p{Nd}</td></tr><tr><td>[:graph:]</td><td>空白字符之外的字符</td><td>[\x21-\x7E]</td><td>[^\p{Z}\p{C}]</td></tr><tr><td>[:lower:]</td><td>小写字母字符</td><td>[a-z]</td><td>\p{Ll}</td></tr><tr><td>[:print:]</td><td>类似[:graph:]，但包括空白字符</td><td>[\x20-\x7E]</td><td>\P{C}</td></tr><tr><td>[:punct:]</td><td>标点符号</td><td>}~-]</td><td>[\p{P}\p{S}]</td></tr><tr><td>[:space:]</td><td>空白字符</td><td>[ \t\r\n\v\f]</td><td>[\p{Z}\t\r\n\v\f]</td></tr><tr><td>[:upper:]</td><td>大写字母字符</td><td>[A-Z]</td><td>\p{Lu}</td></tr><tr><td>[:word:]</td><td>字母字符</td><td>[A-Za-z0-9_]</td><td>[\p{L}\p{N}\p{Pc}]</td></tr><tr><td>[:xdigit:]</td><td>十六进制字符</td><td>[A-Fa-f0-9]</td><td>[A-Fa-f0-9]</td></tr></tbody></table><p><br><br><br></p><hr><p><br></p><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><table><thead><tr><th>优先权</th><th>符号</th></tr></thead><tbody><tr><td>最高</td><td>\</td></tr><tr><td>高</td><td>( )、(?: )、(?= )、[ ]</td></tr><tr><td>中</td><td>*、+、?、{n}、{n,}、{m,n}</td></tr><tr><td>低</td><td>^、$、中介字符</td></tr><tr><td>次最低</td><td>串接，即相邻字符连接在一起</td></tr><tr><td>最低</td><td>l</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《鸟哥的Linux私房菜》&lt;/li&gt;
&lt;li&gt;正则表达式： &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="正则表达式" scheme="https://zhang21.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="RegularExpression" scheme="https://zhang21.github.io/tags/RegularExpression/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://zhang21.github.io/2018/02/05/Redis/"/>
    <id>https://zhang21.github.io/2018/02/05/Redis/</id>
    <published>2018-02-05T09:20:28.000Z</published>
    <updated>2018-02-06T03:10:11.527Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>《Redis官方文档》: <a href="http://www.redis.cn/documentation.html" target="_blank" rel="noopener">http://www.redis.cn/documentation.html</a></li><li>《Redis命令大全》: <a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">http://www.redis.cn/commands.html</a></li></ul><p><br></p><p>环境:</p><ul><li>CentOS7x86_64</li><li>Redis 3.2</li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p><br></p><h2 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h2><p>Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的、非关系型,键值对存储数据库。<br>Redis是一个开源(BSD许可)的,内存中的数据结构存储系统,它可以用作数据库、缓存和消息中间件。</p><p>毫无疑问,Redis开创了一种新的数据存储思路,使用Redis,我们不用在面对功能单调的数据库时,把精力放在如何把大象放进冰箱这样的问题上,而是利用Redis灵活多变的数据结构和数据操作,为不同的大象构建不同的冰箱。希望你喜欢这个比喻。</p><p>Remote Dictionary Server(Redis)是由一个Salvatore Sanfilippo写的key-value储存系统。Redis提供了一些丰富的数据结构,包括lists,sets,ordered sets,hashes,当然还有和Memcached一样的string结构,所以常被称为是一款数据结构服务器(data structure server)。Redis当然还包括了对这些数据结构的丰富操作。</p><p>你可以在这些类型上面运行原子操作,例如,追加字符串,增加哈希中的值,加入一个元素到列表,计算集合的交集、并集和差集,或者是从有序集合中获取最高排名的元素。</p><p><br><br><br></p><h2 id="Redis的优点"><a href="#Redis的优点" class="headerlink" title="Redis的优点"></a>Redis的优点</h2><p>为了满足性能,Redis采用内存(in-memory)数据集(dataset)。根据你的使用场景,你可以通过每隔一段时间转储数据集到磁盘,或者追加每条命令到日志来持久化。持久化也可以被禁用,如果你只是需要一个功能丰富,网络化的内存缓存。</p><ul><li>性能极高,Redis能支持超过100K+每秒的读写频率</li><li>丰富的数据类型,Redis支持二进制案例的Strings,Lists,Hashes,Sets及Ordered Sets数据类型操作</li><li>原子,Redis的所有操作都是原子性的,同时Redis还支持对几个操作全并后的原子性执行</li><li>丰富的特性,Redis还支持publish/sucscribe,通知,key过期等特性</li><li>Redis还支持主从异步复制,非常快的非阻塞初次同步、网络断开时自动重连局部重同步</li></ul><p><br></p><hr><p><br></p><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><p>直接通过<code>yum</code>安装:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y redis</div></pre></td></tr></table></figure><p><br></p><p>启动redis-server的两种方式:</p><ul><li>redis-server: standalone模式</li><li>systemctl redis start: daemon模式<ul><li>需要在配置文件中开启daemonize</li></ul></li></ul><p>启动redis-cli:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis-cli</div><div class="line">redis-cli -a passwd</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h1><p>redis配置文件(/etc/redis.conf)常用参数:</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>daemonize</td><td>以守护进程启动,放置于后台</td></tr><tr><td>bind</td><td>监听地址,建议只对本地127.0.0.1开放</td></tr><tr><td>protect-mode</td><td>edis的保护模式</td></tr><tr><td>requirepass</td><td>设置密码</td></tr><tr><td>timeout</td><td>超时</td></tr><tr><td>tcp-keepalive</td><td>在Linux上,指定值(秒)用于发送ACKs的时间,关闭连接需要双倍的时间,默认为0</td></tr><tr><td>loglevle</td><td>指定日志记录的级别。有四个级别:debug(记录很多信息,用于开发测试)、notice(常用于生产环境)、warning(严重的信息)、verbose(有用的信息)</td></tr><tr><td>logfile</td><td>日志文件,默认为stdout</td></tr><tr><td>databases</td><td>可用数据库,范围在0-(database-1)</td></tr><tr><td>save</td><td>保存数据到磁盘(.rdb)</td></tr><tr><td>stop-writes-on-bgsave-error</td><td>后台储存错误停止写</td></tr><tr><td>rdbcompression</td><td>储存到本地数据库时(持久化到rdb文件)是否压缩</td></tr><tr><td>dbfilename</td><td>本地持久化数据库文件名,默认dump.rdb</td></tr><tr><td>dir</td><td>数据库文件路径,是目录</td></tr><tr><td>salveof</td><td>设置从库</td></tr><tr><td>masterauth</td><td>设置主库认证的密码</td></tr><tr><td>slave-read-only</td><td>设置slave是否只读</td></tr><tr><td>slave-serve-stale-data</td><td>从库同主库失去连接或复制正在进行时,从库是否继续响应客户端请求</td></tr><tr><td>repl-disable-tcp-nodelay</td><td>tcp-nodelay</td></tr><tr><td>slave-priority</td><td>slave优先级,master不能工作后,从众多slave中选出优先值最小的slave提升为master,优先值为0表示不能为master</td></tr><tr><td>appendonly</td><td>是否开启AOF数据备份,redis会把所接收到的每一次写操作请求都追加到appendonly.aof文件,当此文件很大</td></tr><tr><td>appendsync</td><td>AOF文件同步策略,后台会进行大量I/O</td></tr><tr><td>no-appendfsync-on-rewrite</td><td>-</td></tr><tr><td>auto-aof-rewrite-percentage</td><td>aof自动重写</td></tr><tr><td>auto-aof-rewrite-min-size</td><td>指定最小大小用于aof重写</td></tr><tr><td>slowlog-log-slower-than</td><td>慢日志,记录超过特定执行时间的命令,不包括I/o</td></tr><tr><td>slowlog-max-len</td><td>慢日志记录的长度,超过大小,最先进入队列的记录会被踢出</td></tr><tr><td>hash-max-zipmap-entries</td><td>hash将以一种特殊的编码方式(大大减少内存使用)来储存,这是其中一个临界值</td></tr><tr><td>hash-max-zipmap-value</td><td>另一个临界值</td></tr><tr><td>list-max-ziplist-entries</td><td>多个list以特定的方式编码来节省空间</td></tr><tr><td>activerehashing</td><td>Redis将在每100ms时使用1ms的CPU时间来对redis的hash表进行重新hash,可降低内存的使用</td></tr><tr><td>hz</td><td>不是所有任务都以相同的频率执行,但redis按照指定的“hz”值执行检查任务</td></tr><tr><td>aof-rewrite-incremental-fsync</td><td>当一个子节点重写AOF文件时,则文件每生产32m数据进行同步</td></tr></tbody></table><p><br></p><p>官方文档对VM的使用建议:</p><ul><li>当KEY很小而VALUE很大时,使用VM的效果会比较好,因为这样节约内存比较大</li><li>当key不小时,可以考虑使用一些非常方法将很大的key变成value,比如将key,value组合成一个新的value</li></ul><p><br></p><hr><p><br></p><h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><p>Redis不仅仅是简单的key-value存储器,同时也是一种data structure server。传统的key-value是指支持使用一个key字符串来索引value字符串的储存。而Redis中,value不仅仅支持字符串,还支持更多的复杂结构,包括列表、集合、哈希表等。Redis采用二进制安全,这就意味着你可以使用任何二进制序列作为重点。</p><p><br></p><h2 id="字符串-strings"><a href="#字符串-strings" class="headerlink" title="字符串(strings)"></a>字符串(strings)</h2><p>字符串 是一种最基本的Redis值(key)类型。Redis字符串是二进制安全的,这意味着一个Redis字符串能包含任意类型的数据。</p><p>只关心二进制化的字符串,不关心具体格式.只会严格的按照二进制的数据存取。不会妄图已某种特殊格式解析数据。</p><p><br></p><h2 id="列表-lists"><a href="#列表-lists" class="headerlink" title="列表(lists)"></a>列表(lists)</h2><p>Redis列表是简单的字符串列表,按照插入顺序序列,你可以添加一个或多个元素到列表的头部或者尾部。</p><p><br></p><h2 id="散列-hash"><a href="#散列-hash" class="headerlink" title="散列(hash)"></a>散列(hash)</h2><p>Redis Hashes是字符串字段和字符串值之间的映射,因此他们是展现对象的完美数据类型。如一个有姓、名、年龄等属性的用户。一个带有一些字段的hash仅仅需要一块很小的空间储存,因此你可以储存数以百万计的对象在一个小的Redis实例中。</p><p>哈希主要用来表现对象,他们有能力储存很多对象,因此你可以将哈希用于许多其他的任务。</p><p><br></p><h2 id="无序集合-unorder-set"><a href="#无序集合-unorder-set" class="headerlink" title="无序集合(unorder set)"></a>无序集合(unorder set)</h2><p>Redis集合(Set)是一个无序的字符串集合。可以用O(1)的时间复杂度(无论集合中有多少元素时间复杂度都是常量)完成添加、删除、测试元素是否存在。</p><p>Redis集合拥有令人满意的不允许包含相同成员的属性。多次添加相同的元素,最终在集合里只会有一个元素。实际上就是添加元素时无序检测元素是否存在。</p><p>一个Redis集合有趣的事情是它支持一些服务端的命令从现有的集合出发去进行集合运算,因此你可以在非常短的时间内进行合并(unions)、交集(intersections)、找出不同的元素(difference of sets)。</p><p><br></p><h2 id="有序集合-order-set"><a href="#有序集合-order-set" class="headerlink" title="有序集合(order set)"></a>有序集合(order set)</h2><p>Redis有序集合与普通集合非常相似,也是一个没有重复项的字符串集合。不同之处是有序集合的每一个成员都关联了一个评分,这个评分被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的,但是评分可以是重复了。</p><p>使用有序集合可以以非常快的速度(O(log(N)))添加,删除和更新元素。可以很快根据评分(score)或者次序(position)来获取一个范围的元素。访问有序集合的中间元素也是很快的,因此能够使用有序集合作为一个没有重复成员的智能列表。在有序集合中,你可以很快捷的访问一切你需要的东西。</p><p>简而言之,使用有序的集合你可以做完许多对性能有极端要求的任务,而那些任务使用其他类型的数据库真的是很难完成。</p><p><br></p><hr><p><br></p><h1 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h1><p><br></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">exists key    <span class="comment">#判断一个key是否存在</span></div><div class="line"></div><div class="line">del key    <span class="comment">#删除某个或一系列key</span></div><div class="line"></div><div class="line"><span class="built_in">type</span> key    <span class="comment">#返回某个key元素的数据类型,key不存在返回空</span></div><div class="line"></div><div class="line">keys key-pattern    <span class="comment">#返回匹配的key列表</span></div><div class="line"></div><div class="line">randomkey    <span class="comment">#随机获取一个已经存在的key</span></div><div class="line"></div><div class="line">rename oldname newname<span class="comment">#改key的名字,如果存在将会覆盖</span></div><div class="line"></div><div class="line">renamex oldname newname<span class="comment">#改key名字,如果名字存在则失败</span></div><div class="line"></div><div class="line">dbsize    <span class="comment">#返回当前数据库的key的总和</span></div><div class="line"></div><div class="line">expire key time   <span class="comment">#设置某个key的过期时间(秒),到期后自动删除</span></div><div class="line"></div><div class="line">ttl    <span class="comment">#查询key剩余存活时间</span></div><div class="line"></div><div class="line">flushdb    <span class="comment">#清空当前数据库中的所有键</span></div><div class="line"></div><div class="line">flushall    <span class="comment">#清空所有数据库中的键</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="设置相关"><a href="#设置相关" class="headerlink" title="设置相关"></a>设置相关</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">config get    <span class="comment">#用来读取Redis服务器的配置参数</span></div><div class="line"></div><div class="line">config <span class="built_in">set</span>    <span class="comment">#用于更改运行Redis服务器的配置参数</span></div><div class="line"></div><div class="line">config resetstat    <span class="comment">#重置数据统计报告,通常返回OK</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">quit<span class="comment">#关闭连接</span></div><div class="line"></div><div class="line">auth<span class="comment">#密码认证</span></div><div class="line"></div><div class="line"><span class="built_in">help</span> <span class="built_in">command</span><span class="comment">#帮助</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">save<span class="comment">#将数据同步保存到磁盘</span></div><div class="line"></div><div class="line"></div><div class="line">bgsave<span class="comment">#将数据异步保存到磁盘</span></div><div class="line"></div><div class="line"></div><div class="line">lastsave<span class="comment">#返回上次成功将数据保存到磁盘的Unix时戳</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="远程服务"><a href="#远程服务" class="headerlink" title="远程服务"></a>远程服务</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">info<span class="comment">#服务器信息统计,基本所有信息</span></div><div class="line"></div><div class="line">monitor<span class="comment">#实时转储收到的请求</span></div><div class="line"></div><div class="line">slaveof<span class="comment">#改变复制策略</span></div><div class="line"></div><div class="line">shutdown<span class="comment">#将数据同步保存到磁盘,然后关闭服务</span></div><div class="line"></div><div class="line">server<span class="comment">#Redis server的常规信息</span></div><div class="line"></div><div class="line">clients<span class="comment">#Client的连接选项</span></div><div class="line"></div><div class="line">memory<span class="comment">#存储占用相关信息</span></div><div class="line"></div><div class="line">persistence<span class="comment">#RDB and AOF 相关信息</span></div><div class="line"></div><div class="line">stats<span class="comment">#常规统计</span></div><div class="line"></div><div class="line">replication<span class="comment">#Master/slave请求信息</span></div><div class="line"></div><div class="line">cpu<span class="comment">#CPU占用信息统计</span></div><div class="line"></div><div class="line">cluster<span class="comment">#Redis 集群信息</span></div><div class="line"></div><div class="line">keyspace<span class="comment">#数据库信息统计</span></div><div class="line"></div><div class="line">all<span class="comment">#返回所有信息</span></div><div class="line"></div><div class="line">default<span class="comment">#返回常规设置信息</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="值-value-操作"><a href="#值-value-操作" class="headerlink" title="值(value)操作"></a>值(value)操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">exists(key)<span class="comment">#判断一个key是否存在</span></div><div class="line"></div><div class="line">del(key)<span class="comment">#删除一个key</span></div><div class="line"></div><div class="line"><span class="built_in">type</span>(key)<span class="comment">#返回值的类型</span></div><div class="line"></div><div class="line">keys(pattern)<span class="comment">#返回满足给定模式的所有key</span></div><div class="line"></div><div class="line">randomkey<span class="comment">#随机返回key空间的一个</span></div><div class="line"></div><div class="line">keyrename(oldname,newname)<span class="comment">#重命名key</span></div><div class="line"></div><div class="line">dbsize<span class="comment">#返回当前数据库中key的数目</span></div><div class="line"></div><div class="line">expire<span class="comment">#设定一个key的活动时间(s)</span></div><div class="line"></div><div class="line">ttl<span class="comment">#获得一个key的活动时间</span></div><div class="line"></div><div class="line">select(index)<span class="comment">#按索引查询</span></div><div class="line"></div><div class="line">move(key,dbindex)<span class="comment">#移动当前数据库中的key到dbindex数据库</span></div><div class="line"></div><div class="line">flushdb<span class="comment">#删除当前选择的数据库中的所有key</span></div><div class="line"></div><div class="line">flushall<span class="comment">#删除所有数据库中的所有key</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="字符串-string-操作"><a href="#字符串-string-操作" class="headerlink" title="字符串(string)操作"></a>字符串(string)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">set(key,value)#给数据库中名称为key的string赋值value</div><div class="line"></div><div class="line">get(key)#返回数据库中名为key的string的value</div><div class="line"></div><div class="line">getset(key,value)#给名称为key的string赋予上一次的value</div><div class="line"></div><div class="line">mget(key1,key2,...,key N)#返回库中多个string的value</div><div class="line"></div><div class="line">setnx(key,value)#添加string,名称为key,值为value</div><div class="line"></div><div class="line">setex(key,time,value)#向库中添加string,设定过期时间time</div><div class="line"></div><div class="line">mset(key 1,value 1,...,key N,value N)#批量设置多个string的值</div><div class="line"></div><div class="line">msetnx(key 1,value 1,...,key N,value N)#如果所有名称为 key N的string都不存在,则向库中添加string,名称为 key N赋值value N</div><div class="line"></div><div class="line">incr(key)#名称为key的string加 1 操作</div><div class="line"></div><div class="line">incrby(key,integer)#名称为key的string增减integer</div><div class="line"></div><div class="line">decr(key)#名称为key的string减1操作</div><div class="line"></div><div class="line">decrby(key,integer)#名称为key的string的值附加value</div><div class="line"></div><div class="line">append(key,value)#名称为key的值附加value</div><div class="line"></div><div class="line">substr(key,start,end)#返回名称为key的string的value的子串</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="列表-list-操作"><a href="#列表-list-操作" class="headerlink" title="列表(list)操作"></a>列表(list)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">rpush(key,value)#在名称为key的list尾部添加一个值为value的元素</div><div class="line"></div><div class="line">lpush(key,value)#在名称为key的list首部添加一个值为value的元素</div><div class="line"></div><div class="line">llen(key)#返回名称为key的list的长度</div><div class="line"></div><div class="line">lrange(key,start,end)#返回名称为key的list中start至end之间的元素(下表从0开始)</div><div class="line"></div><div class="line">ltrim(key,start,end)#截取名称为key的list,保留start至end之间的元素</div><div class="line"></div><div class="line">lindex(key,index)#返回名称为key的list中index位置的元素</div><div class="line"></div><div class="line">lset(key,index,value)#给名称为key的list中index位置的元素赋值value</div><div class="line"></div><div class="line">lrem(key,count,value)#删除count个名称为key的list中值为value的元素</div><div class="line"></div><div class="line">brpop(key1,key2,...,key N)#rpop的block版本</div><div class="line"></div><div class="line">rpoplpush(srckey,dstkey)#返回并删除名为srckey的list尾元素,并将该元素添加到名为dstkey的list的头部</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="集合-set-操作"><a href="#集合-set-操作" class="headerlink" title="集合(set)操作"></a>集合(set)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">sadd(key,member)#向名为key的set中添加元素member</div><div class="line"></div><div class="line">srem(key,member)#删除名为key的set中元素的member</div><div class="line"></div><div class="line">spop(key)#随机返回并删除名为key的set中的一个元素</div><div class="line"></div><div class="line">smove(srckey,dstkey,member)#将member元素从名为srckey的集合移动到名为dstkey的集合</div><div class="line"></div><div class="line">scard(key)#返回名为key的set的基数</div><div class="line"></div><div class="line">sismember(key,member)#测试member是否是名称为key的set的集合</div><div class="line"></div><div class="line">sinter(key1,key2,...,key N)#求交集</div><div class="line"></div><div class="line">sinterstore(dstkey,key1,...,key N)#求交集并将交集保存到dstkey的集合</div><div class="line"></div><div class="line">sunion(key1,...,key N)#求并集</div><div class="line"></div><div class="line">sunionstore(dstkey,key 1,...,key N)#求并集并将并集保存到dstkey的集合</div><div class="line"></div><div class="line">sdiff(key1,...,key N)#求差集</div><div class="line"></div><div class="line">sdiffstore(dstkey,key 1,...,key N)#求差集并将差集保存到dstkey的集合</div><div class="line"></div><div class="line">smembers(key)#返回名为key的set的所有元素</div><div class="line"></div><div class="line">srandmember(key)#随机返回名为key的set的一个元素</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="有序集合-sorted-set-操作"><a href="#有序集合-sorted-set-操作" class="headerlink" title="有序集合(sorted set)操作"></a>有序集合(sorted set)操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">zadd(key,score,member)#向名为key的zset中添加元素member,score用于排序,如果该元素已经存在,则根据score更新该元素的顺序</div><div class="line"></div><div class="line">zrem(key,member)#删除名为key的zset中的元素member</div><div class="line"></div><div class="line">zincrby(key,increment,member)#如果在名为key的zset中已经存在元素member,则该元素的score增加increment,否则向集合中添加该元素,其score的值为increment</div><div class="line"></div><div class="line">zrank(key,member)#返回名为key的zset,顺序</div><div class="line"></div><div class="line">zrevrank(key,member)#返回名为key的zset,倒序</div><div class="line"></div><div class="line">zrange(key,start,end)#返回名为key的zset,score顺序按index从start到end返回所有元素</div><div class="line"></div><div class="line">zrevrange(key,start,end)#返回名为key的zset,score倒序按index从start到end返回所有元素</div><div class="line"></div><div class="line">zrangebyscore(key,min,max)#返回名为key的zset中score大于等于min,小于等于max的所有元素</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="hash操作"><a href="#hash操作" class="headerlink" title="hash操作"></a>hash操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">hset(key,field,value)#向名为key的hash中添加元素filed----value</div><div class="line"></div><div class="line">hget(key,field)#返回名为key的hash中field对应的value</div><div class="line"></div><div class="line">hmset(key,field1,value1,...,field N,value N)#向名为key的hash中添加元素field----value</div><div class="line"></div><div class="line">hmget(key,field1,...,field N)#返回名为key的hash中filed对应的value</div><div class="line"></div><div class="line">hincrby(key,field,integer)#将名为key的hash中field的value增加integer</div><div class="line"></div><div class="line">hexists(key,field)#名为key的hash中是否存在键为field的域</div><div class="line"></div><div class="line">hdel(key,field)#删除名为key的hash中键为field的域</div><div class="line"></div><div class="line">hlen(key)#返回名为key的hash中元素个数</div><div class="line"></div><div class="line">hkeys(key)#返回名为key的hash中所有键</div><div class="line"></div><div class="line">hvals(key)#返回名为key的hash中所有键对应的value</div><div class="line"></div><div class="line">hgetall(key)#返回名为key的hash中所有的键(field)及其对应的value</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="Redis高级应用"><a href="#Redis高级应用" class="headerlink" title="Redis高级应用"></a>Redis高级应用</h1><p>Redis高级应用包括<strong>安全性设置、主从复制、事务处理、持久化机制和虚拟内存的使用</strong>。</p><p><br><br><br></p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>由于redis速度相当快，一秒钟可以150K次密码尝试，所以需要设置一个密码强度很强大的密码。</p><p>设置密码的两种方法：</p><ul><li><code>configg set requirepass &quot;passwd&quot;</code>，通过命令设置密码</li><li>直接在配置文件中<code>requirepass</code>属性后加上密码</li></ul><p>认证登录的两种方式：</p><ul><li><code>redis-cli -a passwd</code></li><li><code>redi-cli</code> –&gt; <code>auth passwd</code></li></ul><p><br><br><br></p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>Redis的主从复制的配置和使用都比较简单。</p><ul><li>master server</li><li>slave server</li></ul><p>Redis主从复制特点：</p><ul><li>一主多从</li><li>当master宕机后，优先级值小的那台slave server自动转变为master</li><li>主从复制不同阻塞master，在同步数据时master可以继续处理client的请求</li><li>提高了系统的可伸缩性</li></ul><p>Redis主从复制过程：</p><ul><li>slave与master建立连接，发送sync同步命令</li><li>master会启动一个后台进程，将数据库快照保存到文件中，同时master主进程会开始收集新的写命令并缓存</li><li>后台完成保存后，就将此文件发送给slave</li><li>slave将文件保存在磁盘上</li></ul><p><br><br><br></p><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>Redis的事务处理比较简单。只能保证client发起的事务中的命令可以连续的执行，而且不会插入其他的client命令。</p><p>当一个client在连接中发出multi命令时，这个连接就进入一个事务的上下文，该连接后续的命令不会执行，而是存放在一个队列中，当执行exec命令时，redis会顺序的执行队列中的所有命令。如果其中执行出现错误，执行正确的不会回滚，不同于关系型数据库的事务。</p><p><br><br><br></p><h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>持久化就是把数据从内存保存到硬盘。</p><p>Redis是一个支持持久化的内存数据库，Redis需要经常将内存中的数据同步到磁盘来保证持久化。</p><p>Redis支持两种持久化方式：</p><ol><li>snapshotting(快照)<ul><li>将数据存放到文件里，默认方式。默认写入dump.rdb二进制文件中</li><li>可配置redis在n秒内超过m个key被修改就自动做快照</li><li>save 500 10 –&gt; 500s内超过10个key被修改，则保存快照</li></ul></li></ol><p>由于快照方式在一定间隔时间做一次保存， 如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。<br>AOF比快照方式有更好的持久化性，是由于使用aof时，redis会将每一个收到的写命令都通过write函数写入到文件中当redis启动时会通过重新执行文件中保存的写命令在内存中重新建立整个数据库的内容。</p><ol><li>appendonly file(AOF)<ul><li>aof方式redis会将每一次的函数都追加到文件中，当redis重启时会重新执行文件中保存的命令</li></ul></li></ol><p><br></p><p>配置文件参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#启用aof持久化方式</span></div><div class="line">appendonly yes</div><div class="line"></div><div class="line"><span class="comment">#每秒写入磁盘一次，在性能和持久化方面做了很好的折中</span></div><div class="line">appendonly everysc</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#将数据写入磁盘</span></div><div class="line">save 900 1</div><div class="line">save 300 10</div><div class="line">save 60 10000</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>Redis的虚拟内存是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出内存空间用于其它的访问数据。<br>对于redis这样的内存数据库，内存总是不够用的。</p><p>在配置文件(/etc/redis.conf)中配置VM:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#开启vm功能</span></div><div class="line">vm-enableyes</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#交换出来的value保存的文件路径</span></div><div class="line">vm-swap-file    /tmp/redis.swap</div><div class="line"></div><div class="line"><span class="comment">#redis使用的最大内存上线</span></div><div class="line">vm-max-memory 10000000</div><div class="line"></div><div class="line"><span class="comment">#每个页面的大小32字节</span></div><div class="line">vm-page-size 32</div><div class="line"></div><div class="line"><span class="comment">#最多使用多少个页面</span></div><div class="line">vm-pages 123217729</div><div class="line"></div><div class="line"><span class="comment">#用于执行value对象换入的工作线程数量</span></div><div class="line">vm-max-threads 4</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>Redis监听地址<code>bind： x.x.x.x</code>，强烈建议只对本地<code>127.0.0.1</code>开放。不建议对外网开放，有安全隐患</li><li>防火墙，最简单就是关闭防火墙，另一个就是开放redis的监听端口</li><li>开启守护进程，让redis可以在后台运行而不必通过<code>redis-server</code>的方式来启动，将配置文件里的<code>deamonize no</code>改为<code>yes</code></li><li>关闭redis的保护模式(protect-mode)，这里的保护模式是指是否允许其他IP的设备访问redis。如果开启的话就只能允许本机访问。如果是生产开发的实际运行环境，请一定开启保护模式</li><li>设置redis数据库密码！不仅仅是redis，任何数据库都应该设置密码，否则对外网开放的数据库就成了活靶子。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Redis官方文档》: &lt;a href=&quot;http://www.redis.cn/documentation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.redis.cn/documentation.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Redis命令大全》: &lt;a href=&quot;http://www.redis.cn/commands.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.redis.cn/commands.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7x86_64&lt;/li&gt;
&lt;li&gt;Redis 3.2&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="https://zhang21.github.io/categories/Database/"/>
    
    
      <category term="Redis" scheme="https://zhang21.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>计算机集群</title>
    <link href="https://zhang21.github.io/2018/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4/"/>
    <id>https://zhang21.github.io/2018/02/03/计算机集群/</id>
    <published>2018-02-03T05:56:45.000Z</published>
    <updated>2018-02-03T09:51:11.882Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>《老男孩Linux运维》</li><li>《服务器集群系统各概念》: <a href="https://segmentfault.com/a/1190000009923581" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009923581</a></li><li>《WEB的负载均衡、集群、高可用解决方案》： <a href="https://zhuanlan.zhihu.com/p/23826048" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23826048</a></li><li>《计算机集群》： <a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4</a></li></ul><p><br></p><a id="more"></a><hr><p><br></p><h1 id="计算机集群"><a href="#计算机集群" class="headerlink" title="计算机集群"></a>计算机集群</h1><p>计算机集群简称<strong>集群</strong>(Clusters)，是一种计算机系统。它通过一组散列集成的软件或硬件 连接起来高度紧密地协作完成计算工作。在某种意义上，他们可以被看做是一台计算机。</p><p>集群就是指一组（若干）相互独立的计算机，利用高速通信网络组成的一个较大的计算机服务系统，每个集群结点都是运行各自服务的独立服务器。这些服务器之间可以彼此通信，协同向用户提供应用程序、系统资源和数据，并以单一系统的模式加以管理。</p><p>当客户机请求集群系统时，集群给用户的感觉就是一个单一独立的服务器，而实际上用户请求的是一组集群服务器。</p><p>集群系统中的单个计算机通常称为节点，通常通过内网连接，但也有其它的可能连接方式。集群计算机通常用来改进单个计算机的计算速度和可靠性。</p><p><br><br><br></p><h2 id="服务器集群概念"><a href="#服务器集群概念" class="headerlink" title="服务器集群概念"></a>服务器集群概念</h2><p>集群、冗余、负载均衡、主从复制、读写分离、分布式、分布式计算、分布式计算平台、并行计算……</p><p>实际生产环境中常有的问题：</p><ul><li>当数据库性能遇到问题时，是否能够横向扩展，通过添加服务器的方式达到更高的吞吐量，从而充分利用现有的硬件实现更好的投资回报率;</li><li>是否拥有实时同步的副本，当数据库面临灾难时，可以短时间内通过故障转移的方式保证数据库的可用性。此外，当数据丢失或损坏时，能否通过所谓的实时副本（热备）实现数据的零损失;</li><li>数据库的横向扩展是都对应用程序透明，如果数据库的横向扩展需要应用程序端进行大量修改，则所带来的后果不仅仅是高昂的开发成本，同时也会带来很多潜在和非潜在的风险.</li></ul><p><br></p><h3 id="集群和冗余"><a href="#集群和冗余" class="headerlink" title="集群和冗余"></a>集群和冗余</h3><p>集群和冗余并不对立，多台服务器做集群（不是主从），本身就有冗余和负载均衡的效果。<br>狭义上来说，集群就是把多台服务器虚拟成一台服务器，而冗余的每台服务器都是独立的。</p><ul><li>集群的侧重点在于协同，多台服务器系统分担工作，提升效率；</li><li>冗余的侧重点在于防止单点故障，一主多备的架构，也就是主从复制；</li></ul><blockquote><p>数据冗余==高可用性==主从</p></blockquote><ul><li>主从一定程度上起到了负载均衡的作用，但主要目的还是为了保证数据冗余和高可用性</li><li>主从只提供一种成本较低的数据备份方案加上不完美的灾难和负载均衡，由于复制存在时间差，不能同步读，所以只是不完善的负载均衡和有损灾备</li><li>主从显然达不到集群的严格度，不论是 HA 还是 AA（多活并行集群），主从都达不到数据一致性的集群要求</li></ul><p><br><br><br></p><h2 id="为什么要使用集群"><a href="#为什么要使用集群" class="headerlink" title="为什么要使用集群"></a>为什么要使用集群</h2><ul><li>高性能（Performance）<br>  大型网站谷歌、淘宝、百度等，都不是几台大型机可以构建的，都是上万台服务器组成的高性能集群，分布于不同的地点。<br>  只有当并发或总请求数量超过单台服务器的承受能力时，服务器集群的优势才会体现出来。</li><li>价格有效性（Cost-effectiveness）<br>  在达到同样性能的需求下，采用计算机集群架构比采用同等运算能力的大型计算机具有更高的性价比。</li><li>可伸缩性（Scalability）<br>  当服务负载、压力增长时，针对集群系统进行较简单的扩展即可满足需求，且不会降低服务质量。</li><li>高可用（Availability）<br>  单一计算机发生故障时，就无法正常提供服务；而集群架构技术可以是得系统在若干硬件设备发生故障时仍可以继续工作。<br>  集群系统在提高系统可靠性的同时，也大大减小了系统故障带来的业务损失，目前几乎100%的网站都要求7x24h提供服务。</li><li>透明性（Transparency）<br>  多个独立计算机组成的耦合集群系统构成一个虚拟服务器。用户访问集群系统时，就像访问一台高性能、高可用的服务器一样，集群中一部分服务器的上线、下线不会中断整个系统服务，这对用户也是透明的。</li><li>可管理性（Manageability）<br>  这个系统可能在物理上很大，但其实很容易管理，就像管理一个单一映像系统一样。</li><li>可编程性（Programmability）<br>  在集群系统上，容易开发及修改各类应用程序。</li></ul><p><br></p><hr><p><br></p><h1 id="集群分类"><a href="#集群分类" class="headerlink" title="集群分类"></a>集群分类</h1><p>集群分为同构和异构，他们区别在于 “组成集群系统的计算机之间的体系结构是否相同”。</p><p>集群计算机按功能和结构可以分为以下几类：</p><ul><li>均衡集群（Load balancing clusters）</li><li>用性集群（High-availability clusters）</li><li>能计算集群（High-performance cluster）</li><li>计算集群（Grid computing）</li></ul><blockquote><p>负载均衡集群（LB）和高可用性集群（HA）是互联网行业常用的集群架构模式</p></blockquote><p><br><br><br></p><h2 id="负载均衡集群"><a href="#负载均衡集群" class="headerlink" title="负载均衡集群"></a>负载均衡集群</h2><p><strong>负载均衡集群用于抗并发。</strong></p><blockquote><p>负载均衡集群典型的开源软件包括：LVS、Nginx、Haproxy 等。</p></blockquote><p><br></p><p>负载均衡集群可以把很多客户集中的访问请求负载压力尽可能平均分摊在计算机集群中处理。<br>集群中每个节点都可以一定的访问请求负载压力，并且可以实现访问请求在各节点之间动态分配，以实现负载均衡。<br>负载均衡集群运行时，一般是通过一个或多个前端负载均衡器（Director）将客户访问请求分发到后端的一组服务器上，从而达到整个系统的高性能和高可用性。<br>一般高可用性集群和负载均衡集群会使用类似的技术，或同时具有高可用性与负载均衡的特点。</p><p>Linux虚拟服务器（LVS）项目 在Linux操作系统上提供最常用的负载均衡软件。</p><p><br></p><p>负载均衡的作用：</p><ul><li>用户访问请求及数据流量（负载均衡）</li><li>业务连续性，即7x24h服务（高可用）</li><li>于Web业务及数据库从库等服务器的业务</li></ul><p><br><br><br></p><h2 id="高可用性集群"><a href="#高可用性集群" class="headerlink" title="高可用性集群"></a>高可用性集群</h2><p><strong>高可用性集群用于避免单点故障。</strong></p><blockquote><p>高可用性集群常用开源软件包括：Keepalived、Heartbeat 等。</p></blockquote><p><br></p><p>一般是指集群中任意一个节点失效的情况下，该节点上的所有任务会自动转移到其他正常的节点上。此过程不会影响整个集群的运行。</p><p>当集群中的一个节点系统发生故障时，运行着的集群服务器会迅速做出反应，将该系统的服务分配到集群中其他正在工作的系统上运行。考虑到计算机硬件和软件的容错性，高可用性集群的主要目的是使局群的整体服务尽可能可用。<br>如果高可用集群中的主节点发生了故障，那么这段时间内将由备节点代替它。备节点通常是主节点的镜像。当它代替主节点时，它可以完全接管主节点（包括Ip和其他资源）提供服务，因此，使集群系统环境对系统环境来说是一致的，既不会影响用户的访问。</p><p>高可用性集群使服务器系统的运行速度和响应速度会尽可能的快。它们经常利用在多台机器上运行的冗余节点和服务来相互跟踪。<br>如果某个节点失败，它的替补者将在几秒钟或更多时间内接管它的职责。因此，对于用户来说，集群里的任意一台机器宕机，业务都不会受影响。</p><p>高可用性集群的作用：</p><ul><li>当一台机器宕机后，另外一台机器接管宕机的机器的Ip资源和服务资源，提供服务；</li><li>常用于不易实现负载均衡的应用，如负载均衡器、主数据库、主存储对之间；</li></ul><p><br><br><br></p><h2 id="高性能计算集群"><a href="#高性能计算集群" class="headerlink" title="高性能计算集群"></a>高性能计算集群</h2><p>高性能计算集群也称并行计算。通常，高性能计算集群涉及为集群开发的并行应用程序，以解决复杂的科学问题。</p><p>高性能计算集群对外就好像一个超级计算机，这种超级计算机内部由数万个独立服务器组成，并且在公共消息传递层上进行通信以运行并行应用程序。</p><p><br><br><br></p><h2 id="高可用与负载均衡有什么区别"><a href="#高可用与负载均衡有什么区别" class="headerlink" title="高可用与负载均衡有什么区别"></a>高可用与负载均衡有什么区别</h2><ul><li>HA偏重于备用资源，切机时会有业务的断开的，保证了数据的安全，但造成资源的浪费；</li><li>LB侧重于资源的充分应用，没有主备的概念，只有资源的最大限度的加权平均应用，基本不会业务的中断；</li><li>HA的目的是不中断服务，LB的目的是为了提高接入能力。虽然经常放一起用，但确实是两个不同的领域；</li><li>HA在一条路不通的时候提供另一条路可走，而 LB 就类似于是春运时的多个窗口；</li></ul><p><br></p><hr><p><br></p><h1 id="集群软硬件"><a href="#集群软硬件" class="headerlink" title="集群软硬件"></a>集群软硬件</h1><p><br></p><p>企业运维中常见集群产品：</p><ul><li>开源集群软件：<pre><code>+ Nginx, LVS, Haproxy, Keepalived, Heartbear...</code></pre></li><li>商业集群硬件：<pre><code>+ F5， Netscaler,Radware, A10...</code></pre></li></ul><p>如何选择开源集群软件：</p><ul><li>网站在并发访问和总访问量不是很大的情况下，建议首选Nginx负载均衡，Nginx配置简单使用方便安全稳定。 另一个实现负载均衡的产品为Haproxy</li><li>如果要考虑Nginx负载均衡的高可用功能，建议首选Keepalived软件，因为安装配置简单方便稳定。类似高可用软件还有Heartbeat，但比较复杂</li><li>如果是大型企业，负载均衡可以使用 LVS+Keepalived 在前端做四层转发，后端使用Nginx或Haproxy做七层转发，再后面是应用服务器。如果是数据库与存储的负载均衡和高可用，可选用<code>LVS+Heartbeat</code></li></ul><p><img src="/images/Zabbix/cluster.png" alt=""></p><p><br></p><hr><p><br></p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>所谓负载均衡，就是把大访问量分发给不同的服务器，也就是分流请求。</p><p><br></p><h2 id="HTTP重定向协议实现负载均衡"><a href="#HTTP重定向协议实现负载均衡" class="headerlink" title="HTTP重定向协议实现负载均衡"></a>HTTP重定向协议实现负载均衡</h2><p>HTTP 重定向就是应用层的请求转发，用户的请求其实已经到了HTTP重定向负载均衡服务器，服务器根据算法要求用户重定向，用户收到重定向请求后，再次请求真正的集群.</p><ul><li>优点：简单</li><li>缺点：性能较差</li></ul><p><br><br><br></p><h2 id="DNS域名解析负载均衡"><a href="#DNS域名解析负载均衡" class="headerlink" title="DNS域名解析负载均衡"></a>DNS域名解析负载均衡</h2><p>DNS域名解析负载均衡就是在用户请求DNS服务器，获取域名对应的IP地址时，DNS服务器直接给出负载均衡后的服务器IP。</p><ul><li>优点：交给DNS，不用我们去维护负载均衡服务器</li><li>缺点：当一个应用服务器挂了，不能及时通知DNS，而且DNS负载均衡的控制权在域名服务商那里，网站无法做更多的改善和更强大的管理</li></ul><p><br><br><br></p><h2 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h2><p>在用户的请求到达方向代理服务器时（已到达网站机房），由于反向代理服务器根据算法转发到具体的服务器，常用的Apache，Nginx都可以充当反向代理服务器。</p><ul><li>优点：部署简单</li><li>缺点：代理服务器可能成为性能的瓶颈，特别是一次上传大文件</li></ul><p><br><br><br></p><h2 id="IP负载均衡-LVS-NAT"><a href="#IP负载均衡-LVS-NAT" class="headerlink" title="IP负载均衡(LVS-NAT)"></a>IP负载均衡(LVS-NAT)</h2><p>LVS集群中实现的三种IP负载均衡技术。</p><p><br></p><p>在请求到达负载均衡器后，负载均衡器通过修改请求的目的IP地址，从而实现请求的转发，做到负载均衡。</p><ul><li>优点：性能更好</li><li>缺点：负载均衡器的带宽称为瓶颈</li></ul><p><br><br><br></p><h2 id="直接路由负载均衡-LVS-DR"><a href="#直接路由负载均衡-LVS-DR" class="headerlink" title="直接路由负载均衡(LVS-DR)"></a>直接路由负载均衡(LVS-DR)</h2><p>数据链路层负载均衡，在请求到达负载均衡器后，负载均衡器通过修改请求的Mac地址，从而做到负载均衡，与IP负载均衡不一样的是，当请求访问完服务器之后，直接返回客户，而无需在经过负载均衡器。</p><p><br><br><br></p><h3 id="IP隧道负载均衡-LVS-TUN"><a href="#IP隧道负载均衡-LVS-TUN" class="headerlink" title="IP隧道负载均衡(LVS-TUN)"></a>IP隧道负载均衡(LVS-TUN)</h3><p><br></p><hr><p><br></p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主从是一种用于数据容错和灾备的高可用解决方案，而不是一种处理高并发压力的解决方案（负载均衡是用来抗并发的）。</p><blockquote><p>如MySQL主从复制，MongoDB主从复制(副本集)</p></blockquote><ul><li>主机负责查询，从机负责增删改</li><li>可以在从机上执行备份，以避免备份期间影响主机的服务</li><li>主从复制后，也可以在从机上查询，以降低主机的访问压力。但是，只有更新不频繁的数据或者对实时性要求不高的数据可以通过从服务器查询，实时性要求高的数据仍需在主服务器查询（因为主从复制有同步延迟，所以不能保证强数据一致性）</li></ul><p><br><br><br></p><h2 id="主从复制和读写分离"><a href="#主从复制和读写分离" class="headerlink" title="主从复制和读写分离"></a>主从复制和读写分离</h2><ul><li>主从复制是实现读写分离的技术之一，也是实现读写分离的前提条件</li><li>做读写分离时最重要的就是确保 读库 和 写库 的数据统一，而主从复制是实现数据统一最简单的方法（并不能够保证强数据的一致性）</li><li>读写分离，顾名思义，就是一个表只负责向前台页面展示数据，而后台管理人员对表的增删改在另一个表中，把两个表分开，就是读写分离</li><li>主从复制则是一个表数据 增删改 之后会及时更新到另一个表中，保证两个表的数据一致</li></ul><p><br><br><br></p><h2 id="主从类型"><a href="#主从类型" class="headerlink" title="主从类型"></a>主从类型</h2><ul><li>双机热备=主机+备机</li><li>主要应用运行在主机，备机即备用机器。备机不工作，主机出现故障时备机接管主机的所有工作</li><li>双机互备=主机（备机） + 备机（主机）</li><li>互为主备，部分应用运行于主机，部分应用运行于备机，主机备机同时工作</li><li>双机双工=主机+主机</li><li>两台主机同时运行应用，主机备机同时工作</li></ul><p><br></p><hr><p><br></p><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><ul><li>广义上的分布式是指，将不同的服务分布在不同的服务器上</li><li>集群是指，将几台服务器集中在一起，实现同一业务</li><li>分布式中的每一个节点都可以做集群，而集群并不一定是分布式的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《老男孩Linux运维》&lt;/li&gt;
&lt;li&gt;《服务器集群系统各概念》: &lt;a href=&quot;https://segmentfault.com/a/1190000009923581&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000009923581&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《WEB的负载均衡、集群、高可用解决方案》： &lt;a href=&quot;https://zhuanlan.zhihu.com/p/23826048&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/23826048&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《计算机集群》： &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Nginx" scheme="https://zhang21.github.io/tags/Nginx/"/>
    
      <category term="Cluster" scheme="https://zhang21.github.io/tags/Cluster/"/>
    
  </entry>
  
  <entry>
    <title>Bash特殊符号</title>
    <link href="https://zhang21.github.io/2018/01/25/Bash%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"/>
    <id>https://zhang21.github.io/2018/01/25/Bash特殊符号/</id>
    <published>2018-01-25T09:37:17.000Z</published>
    <updated>2018-01-25T09:54:06.458Z</updated>
    
    <content type="html"><![CDATA[<p>在编写shellscripts的时候，特殊符号也有其重要的功能。</p><a id="more"></a><p>具体描述如下：</p><table><thead><tr><th>符号</th><th>描述</th><th>栗子</th></tr></thead><tbody><tr><td>#!</td><td>shellban，申明脚本所使用的shell</td><td>#!/bin/bash</td></tr><tr><td>\</td><td>转义字符</td><td>\n</td></tr><tr><td>l</td><td>管道</td><td>stdout l grep</td></tr><tr><td>&gt;,&gt;&gt;</td><td>输出重定向</td><td>&gt;1.txt</td></tr><tr><td>&lt;,&lt;&lt;</td><td>输入重定向</td><td>&lt;1.txt</td></tr><tr><td>2&gt;</td><td>错误输出</td><td>2&gt;error.txt</td></tr><tr><td>;</td><td>连续命令分隔符</td><td>cmd1; cmd2</td></tr><tr><td>&amp;&amp;</td><td>与，只有当前命令完成后才执行后一个命令</td><td>cmd1 &amp;&amp; cmd2</td></tr><tr><td>ll</td><td>或，或此或彼</td><td>cmd1 ll cmd2</td></tr><tr><td>~</td><td>用户家目录</td><td>cd ~</td></tr><tr><td>#</td><td>注释符</td><td>#it’s a comments</td></tr><tr><td>$</td><td>取用变量前导符</td><td>\$PATH或${PATH}</td></tr><tr><td>&amp;</td><td>工作控制，将命令放入后台(bg)</td><td>command&amp;</td></tr><tr><td>*, ?, [], [-], [^]</td><td>通配符</td><td><em>.sh，?.sh，[a-z]</em>.txt</td></tr><tr><td>!</td><td>逻辑运算’非’not</td><td>!=</td></tr><tr><td>=,两边无空格</td><td>赋值符号</td><td>name=zhang</td></tr><tr><td>=,两边有空格</td><td>比较符号</td><td>if  [ $name  =  zhang ]</td></tr><tr><td>\$0</td><td>代表脚本自身</td><td>zhang.sh</td></tr><tr><td>\$1，\$2</td><td>第1个/2个…变量</td><td>./zhang.sh start…</td></tr><tr><td>$#</td><td>命令后面参数个数</td><td>if [ $# -ne 2 ]；then echo “Usage: \$0 arg1 arg2”</td></tr><tr><td>$@</td><td>代表\$1,\$2,\$3…之意，每个变量是独立的</td><td>xx</td></tr><tr><td>$*</td><td>代\$1 \$2 \$3 …”之意</td><td>xxx</td></tr><tr><td>\$?</td><td>命令状态码，成功为0</td><td>\$?</td></tr><tr><td>\$\$</td><td>当前shell的PID</td><td>echo \$\$</td></tr><tr><td>‘单引号’</td><td>单引号内特殊字符仅为一般字符</td><td>echo ‘\$host’–$host</td></tr><tr><td>“双引号”</td><td>双引号内特殊符号，可保有原本特性</td><td>echo “\$host” –localhost</td></tr><tr><td>`反引号`</td><td>运行命令，也可用()代替</td><td>`date`或 \$(date)</td></tr><tr><td>()</td><td>以子shell方式执行</td><td>($(date))</td></tr><tr><td>{}</td><td>命令区块的组合</td><td>xxx</td></tr><tr><td>PS1</td><td>命令提示符</td><td>$PS1</td></tr><tr><td>PS2</td><td>第二行以后的提示字符</td><td>$PS2</td></tr><tr><td>shift</td><td>移动参数</td><td>当使用shift后，\$1=\$2;再次shift后，\$1=\$3</td></tr><tr><td>set</td><td>查看所有变量</td><td><code>set</code></td></tr><tr><td>unset</td><td>取消变量</td><td>unset name，没有$符号</td></tr><tr><td>export</td><td>使某变量成为环境变量</td><td>export name，没有$符号</td></tr><tr><td>source</td><td>source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录</td><td>source file</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编写shellscripts的时候，特殊符号也有其重要的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Shell" scheme="https://zhang21.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>不成熟的小想法</title>
    <link href="https://zhang21.github.io/2018/01/21/%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84%E5%B0%8F%E6%83%B3%E6%B3%95/"/>
    <id>https://zhang21.github.io/2018/01/21/不成熟的小想法/</id>
    <published>2018-01-21T14:11:16.000Z</published>
    <updated>2018-02-09T01:42:32.072Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ynwa.png" alt="YNWA"></p><a id="more"></a><p><br><br><br></p><blockquote><p>你在大学奋斗四年和你进入工作岗位后奋斗四年，这两者的质量是完全不同的。前者是一个人一生的黄金时代，他有绝对的选择权来决定自己要成为什么样子；而后者则不同，吃饱饭才是这些已经步入社会的人需要考虑的第一要务。</p></blockquote><p><br></p><blockquote><p>我想不明白，为什么非要把成都建设成为2/3个四川？(或许西部省份都是这样，省会便是这个省)2017年成都市GDP约为13800亿人民币，而第二名的绵阳，却连2000亿都不到。</p></blockquote><p><br></p><blockquote><p>我喜欢苹果，你却给了我一车梨，然后告诉全世界你花光了所有的钱给我买了一车梨。可是我却没有一点点感动，你说我是一个铁石心肠的人，可是我只是喜欢苹果而已。</p></blockquote><p><br></p><blockquote><p>任何人不是要你来教他如何做人的！</p></blockquote><p><br></p><blockquote><p>难道真如马尔克斯所说——“上了年纪的人不是按照已经活了多少岁来衡量年龄的，而是通过距离死亡还有多远来衡量！”</p></blockquote><p><br></p><blockquote><p>我刚开上本田的时候，也是宋总这心情，把骑自行车的人贬个贼死，而且心里就会骂出口，大屁股晃什么晃，开个玛萨拉蒂得瑟呀，我那时就像我买得起玛萨拉蒂一样。哈哈，就是个工具，先上手再说。<br>原来人都有这种心态，哈哈哈。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/ynwa.png&quot; alt=&quot;YNWA&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Zhang" scheme="https://zhang21.github.io/categories/Zhang/"/>
    
    
      <category term="Zhang" scheme="https://zhang21.github.io/tags/Zhang/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://zhang21.github.io/2018/01/16/MySQL/"/>
    <id>https://zhang21.github.io/2018/01/16/MySQL/</id>
    <published>2018-01-16T02:47:12.000Z</published>
    <updated>2018-02-09T03:30:27.848Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>MySQL5.7参考文档： <a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/</a></li></ul><p><br></p><p>环境：</p><ul><li>CentOS7.x86_64</li><li>MySQL5.7</li></ul><a id="more"></a><p><br><br><br></p><hr><p><br></p><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>MySQL官网： <a href="https://www.mysql.com/" target="_blank" rel="noopener">https://www.mysql.com/</a></p><p>由于MySQL5.7和以前版本之间的许多功能和其他差异，因此此手册不太适用于之前的老版本。之前的版本请参考MySQL相关版本的手册。</p><p><br></p><p><img src="/images/Mysql/MySQL.png" alt="MySQL"></p><p><br><br><br></p><hr><p><br></p><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>General information</p><p>MySQL™ software提供了一个快速、多线程、多任务和健壮的SQL(结构化查询语言)的数据库服务器。MySQL server是为关键服务(mission-critical)、重负荷(heavy-load)生产系统以及嵌入式(embedding)大规模部署的软件而设计。<br>MySQL是Oracle Corporation的商标(trademark)。</p><p>MySQL software是双重许可的(dual license)：</p><ol><li>Open Source product of the GNU General Public License</li><li>A Standard commercial License from Oracle</li></ol><p><br><br><br></p><h2 id="关于此手册"><a href="#关于此手册" class="headerlink" title="关于此手册"></a>关于此手册</h2><ul><li>该手册作为一个参考，它不提供关于SQL或关系型数据库概念的一般指令；</li><li>MySQL Database Software正在不断发展，所以参考手册也经常更新。可在此 &lt; <a href="http://dev.mysql.com/doc/&gt;" target="_blank" rel="noopener">http://dev.mysql.com/doc/&gt;</a> 获取最新版的手册；</li><li>参考手册(Reference Manual)的源文件使用DocBook XML格式书写的，其他版本(如HTML)等是自动生成的；</li><li>如果在使用过程中有任何问题或建议，请发邮件给我们；</li><li>手册由MySQL Documentation Team维护。</li></ul><p><br><br><br></p><h2 id="MySQL数据库管理系统"><a href="#MySQL数据库管理系统" class="headerlink" title="MySQL数据库管理系统"></a>MySQL数据库管理系统</h2><p>MySQL Database Management System</p><p><br></p><h3 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a>MySQL介绍</h3><p>MySQL是最流行的开源的SQL数据库管理系统，由Oracle Corporation开发、分发和支持。</p><p><br></p><ul><li><p>MySQL is a database management system<br>数据库是一个结构化的数据集合。它可能是从简单的购物清单到图片库，或是公司网络中的大量信息。若要添加、访问和处理存储在计算机数据库中的数据，你需要一个像MySQL Server这样的数据库管理系统。由于计算机非常擅长处理大量的数据，数据库管理系统在计算机中扮演这一个重要的角色。</p></li><li><p>MySQL databases are relational<br>关系型数据库将数据存储在单独的表(table)中，而不是将所有数据放入一个大的库房中。数据库结构被组织成针对速度优化的物理文件。具有数据库(database)，表(table)，视图(view)，行(row)，列(column)等物理对象的逻辑模型提供了灵活的编程环境。你设置了管理不同数据字段之间关系的规则，如一对一，一对多，唯一，必须和可选关系，以及不同表之间的指针(pointer)。数据库强制执行这些规则，这样在设计良好的数据库中，应用程序就不会看到不一致、重复、孤立、过时或丢失的数据。</p></li></ul><p>MySQL也是代表SQL(Structure Query Language)的一部分。SQL是访问数据库最常用的标准化语言。你可以直接使用SQL语句，或者将SQL语法隐藏到语言特定的API中。</p><p>-MySQL software is Open Source<br>MySQL software使用GPL(GNU General Public License)，开源意味着任何人都可以下载、转发、使用和修改软件，而不需要支付任何费用。</p><ul><li><p>MySQL database server is very fast,reliable,scalabe and easy to use</p></li><li><p>MySQL server works in Client/Server or embedded system<br>MySQL Database Server是一个由多线程(multi-threaded)SQL Server组成的客户/服务器系统。它支持不同的后端，多个不同的客户程序和库、管理工具和广泛的APIs。<br>还提供MySQL Server作为一个嵌入式多线程库以便链接到你的产品，以获得一个更小，更快，更容易管理的独立产品。</p></li><li><p>A large amount of contributed MySQL software is available</p></li></ul><p><br><br><br></p><h3 id="MySQL主要特点"><a href="#MySQL主要特点" class="headerlink" title="MySQL主要特点"></a>MySQL主要特点</h3><h4 id="Internals-and-Portability"><a href="#Internals-and-Portability" class="headerlink" title="Internals and Portability"></a>Internals and Portability</h4><ul><li>由C和C++写成</li><li>适用于许多不同的平台</li><li>为了可移植性，使用<code>CMake</code></li><li>采用独立(independent)模块的多层(layer)服务器设计</li><li>设计为使用内核线程的完全多线程，如果有多核CPU，能够轻松使用它们</li><li>提供了事务性(transactional)和非事务性(notransactional)存储引擎</li><li>使用非常快速的带有索引压缩的B-tree磁盘表</li><li>添加其他存储引擎相对容易</li><li>使用非常快速的基于线程的内存分配系统</li><li>使用优化的嵌套循环(nested-loop)连接执行非常快的联结</li><li>实现内存中的hash table，这些表用作临时表</li><li>使用高度优化的类库实现SQL函数</li></ul><p><br></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>1,2,3,4和8byte的有无符号(signed/unsigned)的整数(integers)</li><li>FLOAT</li><li>DOUBLE</li><li>CHAR, VARCHAR</li><li>BINARY, VARBINARY</li><li>TEXT</li><li>BLOB</li><li>DATE, TIME, DATETIME</li><li>TIMESTAMP</li><li>YEAR</li><li>SET</li><li>ENUM</li><li>OpenGIS</li></ul><p><br></p><h4 id="状态和功能"><a href="#状态和功能" class="headerlink" title="状态和功能"></a>状态和功能</h4><p>statement and function</p><ul><li><code>SELECT</code>和<code>WHERT</code>中包含了所有支持的操作符和函数</li><li>SQL中的<code>GROUP BY</code>和<code>ORDER BY</code>也全部支持</li><li>GROUP functions(<code>COUNT()</code>, <code>AVG()</code>, <code>STD()</code>, <code>SUM()</code>, <code>MAX()</code>, <code>MIN()</code>, <code>GROUP_CONCAT()</code>)</li><li>支持<code>LEFT OUTER JOIN</code>和<code>ROGHT OUTER JOIN</code></li><li>按照SQL标准支持table和columns的别名</li><li>支持<code>DELETE</code>,<code>INSERT</code>,<code>REPLACE</code>,<code>UPDATE</code>，以返回受影响的行数</li><li>支持MySQL特定的<code>SHOW</code>显示语句</li><li>一个<code>EXPLAIN</code>语句显示优化器如何解析查询</li></ul><p><br></p><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>security</p><ul><li>权限(privilege)和密码系统，非常灵活和安全，并且支持基于主机的验证</li><li>当连接到Server时，通过加密(encryption)所有密码通信量来确保密码安全</li></ul><p><br></p><h4 id="扩展性和限制"><a href="#扩展性和限制" class="headerlink" title="扩展性和限制"></a>扩展性和限制</h4><p>Scalability and Limits</p><ul><li>支持大型数据库。包含五千万条记录，二十万个表，五十亿行</li><li>每个表最多支持64个索引，每个索引可以由1到16个列组成</li></ul><p><br></p><p>####　连通性</p><p>Conectivity</p><ul><li>客户端使用如下几种协议连接到MySQL Server<ul><li>TCP/IP sockets</li><li>–enable-named-pipe on Windows</li><li>Unix domain socket files on UNIX</li></ul></li><li>MySQL客户端可用多种语言编写</li><li>APIs对于多数语言是可用的</li></ul><p><br></p><h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>Localization</p><ul><li>Server可以向多种语言的客户端提供错误信息</li><li>完全支持几个不同的字符集(character sets)</li><li>所有数据都被保存在选取的字符集(chracter set)</li><li>排序和比较是根据默认的字符集和排序规则完成</li><li>服务器时区(time zone)可动态更改，个客户端也可修改自己的时区</li></ul><p><br></p><h4 id="客户端和工具"><a href="#客户端和工具" class="headerlink" title="客户端和工具"></a>客户端和工具</h4><p>Clients and Tools</p><ul><li>MySQL包含几个客户机和使用程序<ul><li>command-line： <code>mysqldump</code>, <code>mysqladmin</code></li><li>graphical: MySQL Workbench</li></ul></li><li>MySQL Server内置了对SQL语句的支持来检查、优化和修复表</li><li>MySQL程序可使用<code>--help</code>或<code>-?</code>来获取帮助</li></ul><p><br><br><br></p><h3 id="MySQL历史"><a href="#MySQL历史" class="headerlink" title="MySQL历史"></a>MySQL历史</h3><p>History of MySQL</p><ul><li>MySQL is named after co-founder Monty Widenius’s daughter, My.</li><li>The name of the MySQL Dolphin (our logo) is “Sakila,” which was chosen from a huge list of names suggested by users in our “Name the Dolphin” contest.</li></ul><p><br><br><br></p><h2 id="MySQL5-7新特色"><a href="#MySQL5-7新特色" class="headerlink" title="MySQL5.7新特色"></a>MySQL5.7新特色</h2><p>What Is New in MySQL 5.7</p><p><br></p><h3 id="MySQL5-7新功能"><a href="#MySQL5-7新功能" class="headerlink" title="MySQL5.7新功能"></a>MySQL5.7新功能</h3><p>Features Added in MySQL 5.7</p><p><br><br><br></p><h3 id="MySQL5-7中过期的功能"><a href="#MySQL5-7中过期的功能" class="headerlink" title="MySQL5.7中过期的功能"></a>MySQL5.7中过期的功能</h3><p>Features Deprecated in MySQL 5.7</p><p><br><br><br></p><h3 id="MySQL5-7中移除的功能"><a href="#MySQL5-7中移除的功能" class="headerlink" title="MySQL5.7中移除的功能"></a>MySQL5.7中移除的功能</h3><p>Features Removed in MySQL 5.7</p><p><br><br><br></p><h2 id="Server-and-Status-Variables-and-Options-Added-Deprecated-or-Removed-in-MySQL-5-7"><a href="#Server-and-Status-Variables-and-Options-Added-Deprecated-or-Removed-in-MySQL-5-7" class="headerlink" title="Server and Status Variables and Options Added, Deprecated, or Removed in MySQL 5.7"></a>Server and Status Variables and Options Added, Deprecated, or Removed in MySQL 5.7</h2><p><br><br><br></p><h2 id="MySQL信息源"><a href="#MySQL信息源" class="headerlink" title="MySQL信息源"></a>MySQL信息源</h2><p>MySQL Information Sources</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL5.7参考文档： &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7.x86_64&lt;/li&gt;
&lt;li&gt;MySQL5.7&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="https://zhang21.github.io/categories/Database/"/>
    
    
      <category term="MySQL" scheme="https://zhang21.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>2018小计划</title>
    <link href="https://zhang21.github.io/2018/01/15/2018%E5%B0%8F%E8%AE%A1%E5%88%92/"/>
    <id>https://zhang21.github.io/2018/01/15/2018小计划/</id>
    <published>2018-01-15T03:08:11.000Z</published>
    <updated>2018-02-09T01:44:12.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><ul><li style="list-style: none"><input type="checkbox" checked> 《MongoDB官方文档》： <a href="https://docs.mongodb.com" target="_blank" rel="noopener">https://docs.mongodb.com</a></li><li style="list-style: none"><input type="checkbox"> 《SatlStack官方文档》： <a href="https://docs.saltstack.com" target="_blank" rel="noopener">https://docs.saltstack.com</a></li><li style="list-style: none"><input type="checkbox"> 《MySQL官方文档》： <a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">https://dev.mysql.com/doc/</a></li><li style="list-style: none"><input type="checkbox"> 《TCP/IP协议族》： <a href="https://book.douban.com/subject/5386194/" target="_blank" rel="noopener">https://book.douban.com/subject/5386194/</a></li><li style="list-style: none"><input type="checkbox"> 《Linux性能调优指南》： <a href="https://lihz1990.gitbooks.io/transoflptg/content/" target="_blank" rel="noopener">https://lihz1990.gitbooks.io/transoflptg/content/</a></li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h1><ul><li style="list-style: none"><input type="checkbox"> 《资本论》： <a href="https://book.douban.com/subject/1150503/" target="_blank" rel="noopener">https://book.douban.com/subject/1150503/</a></li><li style="list-style: none"><input type="checkbox"> 《灵飞经小楷》： <a href="https://book.douban.com/subject/1115916/" target="_blank" rel="noopener">https://book.douban.com/subject/1115916/</a></li><li style="list-style: none"><input type="checkbox"> 《经济学原理》： <a href="https://book.douban.com/subject/26435630/" target="_blank" rel="noopener">https://book.douban.com/subject/26435630/</a></li></ul><p><br></p><hr><p><br></p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><ul><li style="list-style: none"><input type="checkbox"> 沉得住气；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h1&gt;&lt;ul&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot; checked&gt; 《MongoDB官方文档》： &lt;a href=&quot;https://docs.mongodb.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.mongodb.com&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《SatlStack官方文档》： &lt;a href=&quot;https://docs.saltstack.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.saltstack.com&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《MySQL官方文档》： &lt;a href=&quot;https://dev.mysql.com/doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《TCP/IP协议族》： &lt;a href=&quot;https://book.douban.com/subject/5386194/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://book.douban.com/subject/5386194/&lt;/a&gt;&lt;/li&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 《Linux性能调优指南》： &lt;a href=&quot;https://lihz1990.gitbooks.io/transoflptg/content/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://lihz1990.gitbooks.io/transoflptg/content/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Zhang" scheme="https://zhang21.github.io/categories/Zhang/"/>
    
    
      <category term="2018" scheme="https://zhang21.github.io/tags/2018/"/>
    
  </entry>
  
  <entry>
    <title>海明威的《老人与海》</title>
    <link href="https://zhang21.github.io/2018/01/13/%E6%B5%B7%E6%98%8E%E5%A8%81%E7%9A%84%E3%80%8A%E8%80%81%E4%BA%BA%E4%B8%8E%E6%B5%B7%E3%80%8B/"/>
    <id>https://zhang21.github.io/2018/01/13/海明威的《老人与海》/</id>
    <published>2018-01-13T01:49:53.000Z</published>
    <updated>2018-01-15T02:06:45.715Z</updated>
    
    <content type="html"><![CDATA[<p>我不相信人会有所谓的“命运”，但是我相信对于任何人来说，“限度”总是存在的。再聪明再强悍的人，能够做到的事情也总是有限度的。老人桑地亚哥不是无能之辈，然而，尽管他是最好的渔夫，也不能让那些鱼来上他的钩。他遇到他的限度了，就象最好的农民遇上了大旱，最好的猎手久久碰不到猎物一般。每一个人都会遇到这样的限度，仿佛是命运在向你发出停止前行的命令。</p><a id="more"></a><p><br></p><p>可是老人没有沮丧，没有倦怠，他继续出海，向限度挑战。他终于钓到了一条鱼。如同那老人是人中的英雄一样，这条鱼也是鱼中的英雄。鱼把他拖到海上去，把他拖到远离陆地的地方，在海上与老人决战。在这场鱼与人的恶战中，鱼也有获胜的机会。鱼在水下坚持了几天几夜，使老人不能休息，穷于应付，它用酷刑来折磨老人，把他弄得血肉模糊。这时，只要老人割断钓绳，就能使自己摆脱困境，得到解放，但这也就意味着宣告自己是失败者。老人没有作这样得选择，甚至没有产生过放弃战斗的念头。他把那条鲨鱼当作一个可与之交战的敌手，一次又一次地做着限度之外的战斗，他战胜了。</p><p><br></p><p>老人载着他的鱼回家去，鲨鱼在路上抢劫他的猎物。他杀死了一条来袭的鲨鱼，但是折断了他的鱼叉。于是他用刀子绑在棍子上做武器。到刀子又折断的时候，似乎这场战斗已经结束了。他失去了继续战斗的武器，他又遇到了他的限度。这是，他又进行了限度之外的战斗：当夜幕降临，更多的鲨鱼包围了他的小船，他用木棍、用桨、甚至用舵和鲨鱼搏斗，直到他要保卫的东西失去了保卫的价值，直到这场搏斗已经变得毫无意义的时候他才住手。</p><p><br></p><p>老人回到岸边，只带回了一条白骨，只带回了残破不堪的小船和耗尽了精力的躯体。人们怎样看待这场斗争呢？</p><p>有人说老人桑地亚哥是一个失败了得英雄。尽管他是条硬汉，但还是失败了。</p><p>什么叫失败？也许可以说，人去做一件事情，没有达到预期得目的，这就是失败。</p><p><br></p><p>但是，那些与命运斗争的人，那些做接近自己限度的斗争的人，却天生地接近这种失败。老人到海上去，不能期望天天有鱼来咬他的钩，于是他常常失败。一个常常在进行着接近自己限度的斗争的人总是会常常失败的，一个想探索自然奥秘的人也常常会失败，一个想改革社会的人更是会常常失败。只有那些安于自己限度之内的生活的人才总是“胜利”，这种“胜利者”之所以常胜不败，只是因为他的对手是早已降伏的，或者说，他根本没有投入斗争。</p><p><br></p><p>在人生的道路上，“失败“这个词还有另外的含义，即是指人失去了继续斗争的信心，放下了手中的武器。人类向限度屈服，这才是真正的失败。而没有放下手中武器，还在继续斗争，继续向限度挑战的人并没有失败。如此看来，老人没有失败，老人从未放下武器，只不过是丧失了武器。老人没有失去信心，因此不应当说他是“失败了的英雄”。</p><p><br></p><p>那么，什么也没有得到的老人竟是胜利的么？我确是这样看的。我认为，胜利就是战斗到最后的时刻。老人总怀着无比的勇气走向莫测的大海，他的信心是不可战胜的。</p><p>他和其他许多人一样，是强悍的人类的一员。我喜欢这样的人，也喜欢这样的人性。我发现，人们常常把这样的事情当作人性最可贵的表露：七尺男子汉坐在厨房里和三姑六婆磨嘴皮子，或者衣装笔挺的男女们坐在海滨，谈论着高尚的、别人不能理解的感情。我不喜欢人们像这样沉溺在人性软弱的部分之中，更不喜欢人们总是这样描写人性。</p><p><br></p><p>正像老人每天走向大海一样，很多人每天也走向与他们的限度斗争的战场，仿佛他们要与命运一比高低似的。他们是人中的强者。</p><p>人类本身也有自己的限度，但是当人们一再把手伸到限度之外，这个限度就一天一天地扩大了。人类在与限度的斗争中成长。他们把飞船送上太空，他们也用简陋的渔具在加勒比海捕捉巨大的马林鱼。这些事情是同样伟大的。做这样不可思议的事情的人都是英雄。而那些永远不肯或不能越出自己限度的人是平庸的人。</p><p><br></p><p>在人类前进的道路上，强者与弱者的命运是不同的。弱者不羡慕强者的命运，强者也讨厌弱者的命运。强者带有人性中强悍的一面，弱者带有人性中软弱的一面。强者为弱者开辟道路，但是强者往往为弱者所奴役，就像老人是为大腹便便的游客打鱼一样。</p><p><br></p><p>《老人与海》讲了一个老渔夫的故事，但是在这个故事里却揭示了人类共同的命运。我佩服老人的勇气，佩服他不屈不饶的斗争精神，也佩服海明威。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我不相信人会有所谓的“命运”，但是我相信对于任何人来说，“限度”总是存在的。再聪明再强悍的人，能够做到的事情也总是有限度的。老人桑地亚哥不是无能之辈，然而，尽管他是最好的渔夫，也不能让那些鱼来上他的钩。他遇到他的限度了，就象最好的农民遇上了大旱，最好的猎手久久碰不到猎物一般。每一个人都会遇到这样的限度，仿佛是命运在向你发出停止前行的命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="王小波" scheme="https://zhang21.github.io/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>sysctl,ulimit以及/proc</title>
    <link href="https://zhang21.github.io/2018/01/09/sysctl%E3%80%81ulimit%E5%92%8Cproc/"/>
    <id>https://zhang21.github.io/2018/01/09/sysctl、ulimit和proc/</id>
    <published>2018-01-09T09:22:48.000Z</published>
    <updated>2018-01-10T02:44:10.858Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="http://man.linuxde.net/sysctl" target="_blank" rel="noopener">sysctl命令</a></li><li><a href="http://man.linuxde.net/ulimit" target="_blank" rel="noopener">ulimit命令</a></li><li><a href="http://www.jianshu.com/p/20a2dd80cbad" target="_blank" rel="noopener">ulimit、limits.conf、sysctl和proc文件系统</a></li><li><a href="http://www.jianshu.com/p/9a8e383b5b49" target="_blank" rel="noopener">sysctl.conf学习和调优</a></li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a>sysctl</h1><p><code>sysctl</code> 命令被用于在内核运行时动态地修改内核的运行参数，可用的内核参数在目录 <code>/proc/sys</code> 中。它包含一些<code>Tcp/Ip</code>堆栈和虚拟内存系统的高级选项，可以通过修改某些值来提高系统性能。</p><p><code>sysctl</code>可以读取和设置超过五百个系统变量。<br><code>sysctl</code>变量的设置通常是<strong>字符串、数字或布尔型</strong>（布尔型用1表示yes，0表示no）。</p><p><code>sysctl</code> - configure kernel parameters at runtime.</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#sysctl [options] [variable[=value]] [...]</div><div class="line"></div><div class="line">sysctl -w net.ipv4.tcp_syncookies=1</div></pre></td></tr></table></figure><p><br></p><p>可以通过<code>sysctl</code>命令修改系统变量，也可以通过编辑<code>sysctl.conf</code>配置文件来修改系统变量。</p><p><code>sysctl.conf</code> - sysctl preload/configuration file.</p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line">vim /etc/sysct.conf</div><div class="line"></div><div class="line"></div><div class="line"># Controls source route verification</div><div class="line"># Default should work for all interfaces net.ipv4.conf.default.rp_filter = 1</div><div class="line"># net.ipv4.conf.all.rp_filter = 1</div><div class="line"># net.ipv4.conf.lo.rp_filter = 1</div><div class="line"># net.ipv4.conf.eth0.rp_filter = 1</div><div class="line"></div><div class="line"></div><div class="line"># Disables IP source routing</div><div class="line"># Default should work for all interfaces net.ipv4.conf.default.accept_source_route = 0</div><div class="line"># net.ipv4.conf.all.accept_source_route = 0</div><div class="line"># net.ipv4.conf.lo.accept_source_route = 0</div><div class="line"># net.ipv4.conf.eth0.accept_source_route = 0</div><div class="line"></div><div class="line"></div><div class="line"># Controls the System Request debugging functionality of the kernel</div><div class="line">kernel.sysrq = 0</div><div class="line"></div><div class="line"></div><div class="line"># Controls whether core dumps will append the PID to the core filename</div><div class="line"># Useful for debugging multi-threaded applications</div><div class="line">kernel.core_uses_pid = 1</div><div class="line"></div><div class="line"></div><div class="line"># Increase maximum amount of memory allocated to shm</div><div class="line"># Only uncomment if needed</div><div class="line"># kernel.shmmax = 67108864</div><div class="line"></div><div class="line"></div><div class="line"># Disable ICMP Redirect Acceptance</div><div class="line"># Default should work for all interfaces</div><div class="line">net.ipv4.conf.default.accept_redirects = 0</div><div class="line"># net.ipv4.conf.all.accept_redirects = 0</div><div class="line"># net.ipv4.conf.lo.accept_redirects = 0</div><div class="line"># net.ipv4.conf.eth0.accept_redirects = 0</div><div class="line"></div><div class="line"></div><div class="line"># enable Log Spoofed Packets, Source Routed Packets, Redirect Packets</div><div class="line"># Default should work for all interfaces</div><div class="line">net.ipv4.conf.default.log_martians = 1</div><div class="line">#net.ipv4.conf.all.log_martians = 1</div><div class="line"># net.ipv4.conf.lo.log_martians = 1</div><div class="line"># net.ipv4.conf.eth0.log_martians = 1</div><div class="line"></div><div class="line"></div><div class="line"># Decrease the time default value for tcp_fin_timeout connection</div><div class="line">net.ipv4.tcp_fin_timeout = 25</div><div class="line"></div><div class="line"></div><div class="line"># Decrease the time default value for tcp_keepalive_time connection</div><div class="line">net.ipv4.tcp_keepalive_time = 1200</div><div class="line"></div><div class="line"></div><div class="line"># Turn on the tcp_window_scaling</div><div class="line">net.ipv4.tcp_window_scaling = 1</div><div class="line"></div><div class="line"></div><div class="line"># Turn on the tcp_sack</div><div class="line">net.ipv4.tcp_sack = 1</div><div class="line"></div><div class="line"></div><div class="line"># tcp_fack should be on because of sack</div><div class="line">net.ipv4.tcp_fack = 1</div><div class="line"></div><div class="line"></div><div class="line"># Turn on the tcp_timestamps</div><div class="line">net.ipv4.tcp_timestamps = 1</div><div class="line"></div><div class="line"></div><div class="line"># Enable TCP SYN Cookie Protection</div><div class="line">net.ipv4.tcp_syncookies = 1</div><div class="line"></div><div class="line"></div><div class="line"># Enable ignoring broadcasts request</div><div class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</div><div class="line"></div><div class="line"></div><div class="line"># Disable ping requests</div><div class="line">net.ipv4.icmp_echo_ignore_all = 1</div><div class="line"></div><div class="line"></div><div class="line"># Enable bad error message Protection</div><div class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</div><div class="line"></div><div class="line"></div><div class="line"># make more local ports available</div><div class="line"># net.ipv4.ip_local_port_range = 1024 65000</div><div class="line"></div><div class="line"></div><div class="line"># set TCP Re-Ordering value in kernel to 5</div><div class="line">net.ipv4.tcp_reordering = 5</div><div class="line"></div><div class="line"></div><div class="line"># Lower syn retry rates</div><div class="line">net.ipv4.tcp_synack_retries = 2</div><div class="line">net.ipv4.tcp_syn_retries = 3</div><div class="line"></div><div class="line"></div><div class="line"># Set Max SYN Backlog to 2048</div><div class="line">net.ipv4.tcp_max_syn_backlog = 2048</div><div class="line"></div><div class="line"></div><div class="line"># Various Settings</div><div class="line">net.core.netdev_max_backlog = 1024</div><div class="line"></div><div class="line"></div><div class="line"># Increase the maximum number of skb-heads to be cached</div><div class="line">net.core.hot_list_length = 256</div><div class="line"></div><div class="line"></div><div class="line"># Increase the tcp-time-wait buckets pool size</div><div class="line">net.ipv4.tcp_max_tw_buckets = 360000</div><div class="line"></div><div class="line"></div><div class="line"># This will increase the amount of memory available for socket input/output queues</div><div class="line">net.core.rmem_default = 65535</div><div class="line">net.core.rmem_max = 8388608</div><div class="line">net.ipv4.tcp_rmem = 4096 87380 8388608 net.core.wmem_default = 65535</div><div class="line">net.core.wmem_max = 8388608</div><div class="line">net.ipv4.tcp_wmem = 4096 65535 8388608</div><div class="line">net.ipv4.tcp_mem = 8388608 8388608 8388608</div><div class="line">net.core.optmem_max = 40960</div></pre></td></tr></table></figure><p>重新加载内核参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-p, read values from file</span></div><div class="line">sysctl -p</div><div class="line"></div><div class="line"><span class="comment">#-a, display all variables</span></div><div class="line">sysctl -a</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h1><p>大多Unix-Like系统，都提供了限制每个进程和每个基本用户使用线程，文件和网络连接等系统资源的一些方法。</p><p>假设有这样一种情况，当一台Linux主机上同时登陆了10人，在资源无限制的情况下，这10个用户同时打开了500个文件。假设每个文件的大小有10M，这是系统的内存资源就会收到巨大挑战。<br>但是任何一台主机的资源都不可能是无限的。所以，资源的合理配置和分配，不仅仅是保证系统可用性的必要条件，也与系统上软件运行的性能有着密不可分的联系。</p><p><code>ulimit</code>是指每个user使用各种资源的限制值。<code>ulimit</code> 命令用来限制系统用户对shell资源的访问，它是一种简单并且有效的实现资源限制的方式。</p><ul><li><code>ulimit</code>的设置值是 per-process的，也就是说，每个进程都有自己的limits值；</li><li>使用<code>ulimit</code>进行修改，是立即生效的；</li><li><code>ulimit</code>只影响shell进程及其子进程，用户登出后失效；</li><li>修改<code>ulimit</code>设置之后，要重启程序修改值才会有效。可通过<code>/proc</code>文件系统查看运行进程当前的限制值;</li><li>使用<code>ulimit</code>对系统限制的改变在系统重启后都会恢复到默认值;</li><li>可以在<code>profile</code>中加入<code>ulimit</code>的设置，便能做到永久生效。</li></ul><p><br></p><p><strong>ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：</strong></p><ul><li>所创建的内核文件的大小；</li><li>进程数据块的大小；</li><li>Shell进程创建文件的大小；</li><li>内存锁住的大小；</li><li>常驻内存集的大小；</li><li>打开文件描述符的数量；</li><li>分配堆栈的最大大小；</li><li>CPU时间；</li><li>单个用户的最大线程数；</li><li>Shell进程所能使用的最大虚拟内存；</li><li>它支持硬资源(hard)和软资源(soft)的限制。</li></ul><p><br></p><p><strong>sort和hard</strong></p><ul><li>hard：是指用户在任何时候都可以活动的进程的最大数量，这是上限。没有任何non-root进程能够增加hard ulimit；</li><li>soft：是对会话或进程实际执行的限制，但任何进程都可以将其增加到hard ulimit的最大值。</li></ul><p><br></p><h2 id="设置ulimit"><a href="#设置ulimit" class="headerlink" title="设置ulimit"></a>设置ulimit</h2><p>可以在以下位置进行ulimit的设置：</p><ul><li><code>/etc/profile</code>，所有用户有效，永久生效；</li><li><code>~/.bash_profile</code>,当前用户有效，永久生效；</li><li>直接在控制台修改，当前用户有效，临时生效；</li></ul><p><br></p><p>永久生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div><div class="line"></div><div class="line">vim ~/.bash_profile</div></pre></td></tr></table></figure><p>临时生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">ulimit</span> -a</div><div class="line"></div><div class="line"></div><div class="line">core file size          (blocks, -c) 0</div><div class="line">data seg size           (kbytes, -d) unlimited</div><div class="line">scheduling priority             (-e) 0</div><div class="line">file size               (blocks, -f) unlimited</div><div class="line">pending signals                 (-i) 7170</div><div class="line">max locked memory       (kbytes, -l) 64</div><div class="line">max memory size         (kbytes, -m) unlimited</div><div class="line">open files                      (-n) 1024</div><div class="line">pipe size            (512 bytes, -p) 8</div><div class="line">POSIX message queues     (bytes, -q) 819200</div><div class="line">real-time priority              (-r) 0</div><div class="line">stack size              (kbytes, -s) 8192</div><div class="line">cpu time               (seconds, -t) unlimited</div><div class="line">max user processes              (-u) 7170</div><div class="line">virtual memory          (kbytes, -v) unlimited</div><div class="line">file locks                      (-x) unlimited</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#修改限定值</span></div><div class="line"><span class="built_in">ulimit</span> -n 201400</div><div class="line"><span class="built_in">ulimit</span> -t ulimited</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="limits-conf"><a href="#limits-conf" class="headerlink" title="limits.conf"></a>limits.conf</h1><p><code>limits.conf</code> - configuration file for the pam_limits module</p><p><code>limits.conf</code>是<code>pam_limits.so</code>的配置文件，Linux PAM(Pluggable Authentication Modules，插入式认证模块)。突破系统默认限制，对系统资源有一定保护作用。</p><p><strong>pam_limits模块</strong>对用户的会话进行资源限制，然后<code>/etc/pam.d/</code>下的应用程序调用<code>pam_***.so</code>模块。</p><p><br></p><p><strong><code>limits.conf</code>是针对用户，而<code>sysctl.conf</code>是针对整个系统参数配置。</strong></p><ul><li>一个shell的初始limits就是由pam_limits设定的，用户登录后，pam_limits会给用户的shell设定在limits.conf定义的值；</li><li>pam_limits的设定值也是per-process；</li><li>pam_limits的设置是 永久生效的。</li></ul><p><br></p><p>配置limits.conf：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/security/limits.conf</div></pre></td></tr></table></figure><p><br></p><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#&lt;domain&gt;      &lt;type&gt;  &lt;item&gt;         &lt;value&gt;</div><div class="line"></div><div class="line">#*               soft    core            0</div><div class="line">#*               hard    rss             10000</div><div class="line">#@student        hard    nproc           20</div><div class="line">#@faculty        soft    nproc           20</div><div class="line">#@faculty        hard    nproc           50</div><div class="line">#ftp             hard    nproc           0</div><div class="line">#@student        -       maxlogins       4</div></pre></td></tr></table></figure><p>domain：</p><ul><li>username</li><li>@groupname</li></ul><p>type：</p><ul><li>soft</li><li>hard</li><li>-</li></ul><p>item：</p><ul><li>core，限制内核文件的大小</li><li>date，最大数据大小</li><li>fsize，最大文件大小</li><li>memlock，最大锁定内存地址空间</li><li>nofile，打开文件的最大数目</li><li>rss，最大持久设置大小</li><li>stack，最大栈大小</li><li>cpu，以分钟为单位的最多CPU时间</li><li>nproc，进程的最大数目</li><li>as，地址空间限制</li><li>maxlogins，此用户允许登录的最大数目</li></ul><p>value：</p><ul><li>item值的大小</li></ul><p><br></p><hr><p><br></p><h1 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h1><h2 id="什么是-proc文件系统"><a href="#什么是-proc文件系统" class="headerlink" title="什么是/proc文件系统"></a>什么是/proc文件系统</h2><p>Linux内核提供了一种通过<code>/proc</code>文件系统，在运行时访问内核内部数据结构，改变内核设置的机制。</p><p>proc文件系统是一个伪文件系统，它只存在内存当中，不占用外部空间。它以文件系统的方式为访问系统内核数据的操作提供接口。</p><p>对<code>/proc</code>中内核文件的修改，针对的是<strong>整个系统</strong>的<strong>内核参数</strong>，修改后<strong>立即生效</strong>，但修改是 <strong>临时的</strong>，重启后失效。</p><p><br></p><h2 id="proc与sysctl-conf的对应关系"><a href="#proc与sysctl-conf的对应关系" class="headerlink" title="/proc与sysctl.conf的对应关系"></a>/proc与sysctl.conf的对应关系</h2><p>修改<code>/proc</code>文件系统中的参数是临时的，但修改<code>sysctl.conf</code>的参数确是永久有效的。</p><p>配置文件<code>sysctl.conf</code>变量在<code>/proc/sys</code>下，其对应关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#将文件名的 . 变为 /</div><div class="line"></div><div class="line">#/proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line">#net.ipv4.icmp_echo_ignore_all</div><div class="line"></div><div class="line">echo 0 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line"></div><div class="line">vim /etc/sysctl.conf</div><div class="line">net.ipv4.icmp_echo_ignore_all = 0</div></pre></td></tr></table></figure><p><br></p><h2 id="proc文件系统几个常用的内核文件"><a href="#proc文件系统几个常用的内核文件" class="headerlink" title="/proc文件系统几个常用的内核文件"></a>/proc文件系统几个常用的内核文件</h2><ul><li>/proc/meminfo    #内存信息</li><li>/proc/cpuinfo    #CPU信息</li><li>/proc/sys/fs/file-max    #文件打开数</li><li>/proc/sys/fs/file-nr    #整个系统目前使用的文件句柄数量</li></ul><p><br></p><h2 id="proc文件系统中文件的权限"><a href="#proc文件系统中文件的权限" class="headerlink" title="/proc文件系统中文件的权限"></a>/proc文件系统中文件的权限</h2><p>proc中的每个文件都有一组分配给它的非常特殊的文件许可权，并且每个文件属于特定的用户标识。</p><ul><li>只读：任何用户都不能更改该文件，它用于表示系统信息</li><li>root写</li><li>root读</li></ul><p><br></p><h2 id="对-proc进行读写"><a href="#对-proc进行读写" class="headerlink" title="对/proc进行读写"></a>对/proc进行读写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cat /proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line">#0</div><div class="line"></div><div class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</div><div class="line"></div><div class="line">#当然,也可是用sysctl来配置</div></pre></td></tr></table></figure><p><br></p><h2 id="proc内核文件详解"><a href="#proc内核文件详解" class="headerlink" title="/proc内核文件详解"></a>/proc内核文件详解</h2><ul><li>/proc/buddyinfo 每个内存区中的每个order有多少块可用，和内存碎片问题有关</li><li>/proc/cmdline 启动时传递给kernel的参数信息</li><li>/proc/cpuinfo cpu的信息</li><li>/proc/crypto 内核使用的所有已安装的加密密码及细节</li><li>/proc/devices 已经加载的设备并分类</li><li>/proc/dma 已注册使用的ISA DMA频道列表</li><li>/proc/execdomains Linux内核当前支持的execution domains</li><li>/proc/fb 帧缓冲设备列表，包括数量和控制它的驱动</li><li>/proc/filesystems 内核当前支持的文件系统类型</li><li>/proc/interrupts x86架构中的每个IRQ中断数</li><li>/proc/iomem 每个物理设备当前在系统内存中的映射</li><li>/proc/ioports 一个设备的输入输出所使用的注册端口范围</li><li>/proc/kcore 代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于RAM大小加上4kb</li><li>/proc/kmsg 记录内核生成的信息，可以通过/sbin/klogd或/bin/dmesg来处理</li><li>/proc/loadavg 根据过去一段时间内CPU和IO的状态得出的负载状态，与uptime命令有关</li><li>/proc/locks 内核锁住的文件列表</li><li>/proc/mdstat 多硬盘，RAID配置信息(md=multiple disks)</li><li>/proc/meminfo RAM使用的相关信息</li><li>/proc/misc 其他的主要设备(设备号为10)上注册的驱动</li><li>/proc/modules 所有加载到内核的模块列表</li><li>/proc/mounts 系统中使用的所有挂载</li><li>/proc/mtrr 系统使用的Memory Type Range Registers (MTRRs)</li><li>/proc/partitions 分区中的块分配信息</li><li>/proc/pci 系统中的PCI设备列表</li><li>/proc/slabinfo 系统中所有活动的 slab 缓存信息</li><li>/proc/stat 所有的CPU活动信息</li><li>/proc/sysrq-trigger 使用echo命令来写这个文件的时候，远程root用户可以执行大多数的系统请求关键命令，就好- 像在本地终端执行一样。要写入这个文件，需要把/proc/sys/kernel/sysrq不能设置为0。这个文件对root也是不可- 读的</li><li>/proc/uptime 系统已经运行了多久</li><li>/proc/swaps 交换空间的使用情况</li><li>/proc/version Linux内核版本和gcc版本</li><li>/proc/bus 系统总线(Bus)信息，例如pci/usb等</li><li>/proc/driver 驱动信息</li><li>/proc/fs 文件系统信息</li><li>/proc/ide ide设备信息</li><li>/proc/irq 中断请求设备信息</li><li>/proc/net 网卡设备信息</li><li>/proc/scsi scsi设备信息</li><li>/proc/tty tty设备信息</li><li>/proc/net/dev 显示网络适配器及统计信息</li><li>/proc/vmstat 虚拟内存统计信息</li><li>/proc/vmcore 内核panic时的内存映像</li><li>/proc/diskstats 取得磁盘信息</li><li>/proc/schedstat kernel调度器的统计信息</li><li>/proc/zoneinfo 显示内存空间的统计信息，对分析虚拟内存行为很有用</li></ul><p><br></p><p><strong>以下是/proc目录中进程N的信息：</strong></p><ul><li>/proc/N pid为N的进程信息</li><li>/proc/N/cmdline 进程启动命令</li><li>/proc/N/cwd 链接到进程当前工作目录</li><li>/proc/N/environ 进程环境变量列表</li><li>/proc/N/exe 链接到进程的执行命令文件</li><li>/proc/N/fd 包含进程相关的所有的文件描述符</li><li>/proc/N/maps 与进程相关的内存映射信息</li><li>/proc/N/mem 指代进程持有的内存，不可读</li><li>/proc/N/root 链接到进程的根目录</li><li>/proc/N/stat 进程的状态</li><li>/proc/N/statm 进程使用的内存的状态</li><li>/proc/N/status 进程状态信息，比stat/statm更具可读性</li><li>/proc/self 链接到当前正在运行的进程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://man.linuxde.net/sysctl&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sysctl命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://man.linuxde.net/ulimit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ulimit命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/20a2dd80cbad&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ulimit、limits.conf、sysctl和proc文件系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/9a8e383b5b49&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sysctl.conf学习和调优&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="系统优化" scheme="https://zhang21.github.io/tags/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>开源许可协议</title>
    <link href="https://zhang21.github.io/2018/01/09/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
    <id>https://zhang21.github.io/2018/01/09/开源许可协议/</id>
    <published>2018-01-09T03:50:27.000Z</published>
    <updated>2018-01-09T05:55:22.617Z</updated>
    
    <content type="html"><![CDATA[<p>当你为你的产品签发许可，你就是在出让自己的权利。不过，你仍拥有版权和专利（如果申请了专利）。许可的目的，是向使用你产品的人提供一定的权利。</p><p>不管产品是免费分发，还是出售，指定一份许可协议都非常有用。否则，对于免费，你相当于放弃了自己的所有权利，任何人都没有义务表明你的原始作者身份。对于出售，你将不得不花费比开发更多的精力用来处理授权问题。</p><p>而开源许可协议是这些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的身份，使你至少获得认可。开源许可协议还可以阻止其它人将某个产品据为己有。</p><p><br><br><a id="more"></a></p><p><img src="/images/opensourcelicence.png" alt="开源许可协议区别"></p><p><br></p><p><img src="/images/opensourcelicence.jpg" alt="开源许可协议区别"></p><p><br></p><hr><p><br></p><h1 id="几大开源许可协议"><a href="#几大开源许可协议" class="headerlink" title="几大开源许可协议"></a>几大开源许可协议</h1><p><br><br><br></p><h2 id="GNU-Project"><a href="#GNU-Project" class="headerlink" title="GNU Project"></a>GNU Project</h2><ul><li>GNU是“GNU’s Not Unix”的递归缩写，发音为 /‘gnu:’/；</li><li>GNU Project，是一个由自由软件集体协作项目，它的目标是创建一套完全自由的操作系统，称为GNU；</li><li>GNU是一个自由操作系统，其内容软件完全以 GPL 方式发布，它的设计类似于Unix，但它不包含具有著作权的Unix代码。</li></ul><p><br></p><h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GNU(General Public Licence)，GNU通用许可协议(简称GPL)是广泛使用的免费软件许可证，也称为 copyleft，与copyright相对应。<br>GPL保证了所有开发者的权利，同时为使用者提供了足够的复制、分发、修改的权利。</p><p>需要注意的是，分发的时候，需要明确提供源代码和二进制文件。</p><ul><li><strong>可自由复制：</strong> 你可以将软件复制到你的电脑或任何地方，复制份数没有限制；</li><li><strong>可自由分发：</strong> 可下载后拷贝分发；</li><li><strong>可以用来盈利：</strong> 你可以在分发软件的时候收费，但必须在收费前向你的客户提供该软件的 GNU GPL许可协议，以便让他们知道，他们可以从别的渠道免费得到这份软件以及你收费的理由；</li><li><strong>可自由修改：</strong> 你过你想添加或删除某个功能，没问题。如果你想在别的项目中使用部分代码，也没问题，唯一要求是使用了这段代码的项目也必须使用 GPL协议。</li></ul><p><br></p><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>GNU还有另外一种协议，叫做LGPL（Lesser General Public License），它对产品所保留的权利比GPL少。<br>总的来说，LGPL适合那些用于非GPL或非开源产品的开源类库或框架。因为GPL要求，使用了GPL代码的产品也必须使用GPL协议，开发者不允许将GPL代码用于商业产品。LGPL绕过了这一限制。</p><p>GPL和LGPL都属于GNU计划里面的许可证。</p><p><br></p><hr><p><br></p><h2 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h2><p>伯克利软件套件（Berkeley Software Distribution，缩写BSD），也被称为伯克利Unix，是一个操作系统的名称，衍生自Unix，也被用来代表一整套软件发行版。</p><p>BSD许可证（Berkeley Software Distribution License），是自由软件中使用广泛的许可证。BSD软件就是遵照这个许可证来发布，该许可证也因此而得名。</p><p>BSD在软件分发方面的限制比别的开源协议要少，且和GPL兼容，并为开源组织所认可。</p><p><br></p><hr><p><br></p><h2 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h2><p>MIT（Massachusetts Institute of Technology），麻省理工学院。<br>MIT许可协议（The MIT License）是许多软件授权条款中，被广泛使用的其中一种。与其他常见的软件许可协议相比，MIT是相对宽松的软件许可协议，除了必须包含许可声明外，再无任何限制。</p><p>MIT许可协议核心条款：</p><ul><li>该软件及其相关文档对所有人免费，可以任意处置，包括使用、复制、修改、合并、发表、分发、再授权或销售；</li><li>唯一的限制，软件中必须包含上述版权和许可证。</li></ul><p><br></p><hr><p><br></p><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>Apache许可证（Apache License），是一个由Apache软件基金会发布的自由软件许可证。Apache许可证要求被授权者保留版权和放弃权利的声明，但它不是一个反版权的许可证。兼容与GPL。</p><p>除了为用户提供版权许可之外，还有专利许可，对于那些涉及专利内容的开发者而言，该协议最适合。</p><ul><li>永久权利：一旦被授权，永久拥有；</li><li>全球范围的权利：在一个国家获得授权，适用于所有国家；</li><li>授权免费，且无版税：前后期均无任何费用；</li><li>授权不可撤销：一旦获得授权，没有任何人可以取消。</li></ul><p>分发代码方面，要在声明中对参与开发的人给予认可并包含一份许可协议原文。</p><p><br></p><hr><p><br></p><h2 id="MPL"><a href="#MPL" class="headerlink" title="MPL"></a>MPL</h2><p>MPL是The Mozilla[mɔzilə] Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。<br>MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。</p><p>同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA 认定的开源软件许可证）。</p><p>MPL几个特点：</p><ul><li>MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL 许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口；</li><li>MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序；</li><li>对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利；</li><li>对源代码的定义，MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。</li></ul><p><br></p><hr><p><br></p><h2 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h2><p>知识共享许可协议(Creative Commons License，简称CC)，并非严格意义上的开源许可，是一种公共版权许可协议。它主要用于设计，其允许分发受版权保护的作品。</p><p>CC协议主要包含4种基本形式：</p><ul><li>署名权：必须为原始作业署名，然后才可以修改、分发、复制；</li><li>保持一致：作品同样可以在CC协议的基础上修改、分发、复制；</li><li>非商业：不能用于商业用途；</li><li>不能衍生新作品：你可以复制、分发、但不能修改，也不能以此为基础创作自己的作品。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你为你的产品签发许可，你就是在出让自己的权利。不过，你仍拥有版权和专利（如果申请了专利）。许可的目的，是向使用你产品的人提供一定的权利。&lt;/p&gt;
&lt;p&gt;不管产品是免费分发，还是出售，指定一份许可协议都非常有用。否则，对于免费，你相当于放弃了自己的所有权利，任何人都没有义务表明你的原始作者身份。对于出售，你将不得不花费比开发更多的精力用来处理授权问题。&lt;/p&gt;
&lt;p&gt;而开源许可协议是这些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的身份，使你至少获得认可。开源许可协议还可以阻止其它人将某个产品据为己有。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="开源许可协议" scheme="https://zhang21.github.io/tags/%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Yum源</title>
    <link href="https://zhang21.github.io/2018/01/09/Yum%E6%BA%90/"/>
    <id>https://zhang21.github.io/2018/01/09/Yum源/</id>
    <published>2018-01-09T03:46:21.000Z</published>
    <updated>2018-01-09T04:48:12.418Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="http://blog.csdn.net/leshami/article/details/78133716" target="_blank" rel="noopener">CentOS 7下配置本地yum源及yum客户端</a></li><li><a href="http://blog.csdn.net/conling_/article/details/70399694" target="_blank" rel="noopener">Centos7 配置本地源+阿里yum源/epel-yum+修改优先级</a></li><li><a href="http://blog.csdn.net/kingfox/article/details/51233153" target="_blank" rel="noopener">调整CentOS 7中yum仓库的优先级</a></li><li><a href="https://segmentfault.com/a/1190000000375848" target="_blank" rel="noopener">国内开源站点</a></li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="国内开源镜像站点"><a href="#国内开源镜像站点" class="headerlink" title="国内开源镜像站点"></a>国内开源镜像站点</h1><ul><li>网易开源镜像站：<a href="http://mirrors.163.com/" target="_blank" rel="noopener">http://mirrors.163.com/</a></li><li>阿里云开源镜像站：<a href="http://mirrors.aliyun.com" target="_blank" rel="noopener">http://mirrors.aliyun.com</a></li><li>清华大学开源镜像站：<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a></li><li>浙江大学开源镜像站： <a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/</a></li><li>中国科技大学开源镜像站：<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a></li></ul><p><br></p><hr><p><br></p><h1 id="CentOS自带源"><a href="#CentOS自带源" class="headerlink" title="CentOS自带源"></a>CentOS自带源</h1><p>rpm包管理方式，对于安装、升级、卸载却难以处理包之间的依赖关系。而yum作为一个rpm包前端管理工具，可以自动处理依赖性，并支持在线现在、安装、升级、卸载rpm软件包。</p><p>CentOS默认自带<code>CentOS-Base.repo</code>源，但官方源在国外，连接速度令人心痛。并且有很多软件在默认源里面是找不到的。</p><h2 id="配置网络yun源"><a href="#配置网络yun源" class="headerlink" title="配置网络yun源"></a>配置网络yun源</h2><p><strong>配置aliyun.repo：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#先备份默认源</div><div class="line">mv CentOS-Base.repo&#123;,.bak&#125;</div><div class="line"></div><div class="line">#下载阿里云源替换默认源</div><div class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</div><div class="line"></div><div class="line">yum clean all</div><div class="line">yum makecache    #重构yum缓存</div><div class="line"></div><div class="line">yum repolist    #查看yum仓库</div></pre></td></tr></table></figure><p><br></p><h2 id="配置本地yum源"><a href="#配置本地yum源" class="headerlink" title="配置本地yum源"></a>配置本地yum源</h2><p><strong>配置本地yum源，考虑到优先使用本地安装包，所以会涉及到一个优先级的概念。</strong></p><p>安装完毕后，就可以在yum源中添加一个优先级<code>priority</code>。</p><p><strong>安装yum优先级插件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">yum install -y yum-plugin-priorities</div><div class="line"></div><div class="line">#检查安装完成后配置</div><div class="line">vim /etc/yum/pluginconf.d/priorities.conf</div><div class="line"></div><div class="line">enable=1</div><div class="line">#enable=0</div></pre></td></tr></table></figure><p><br></p><p><strong>创建本地yum源：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">mv /etc/yum.repos.d/CentOS-Base.repo&#123;,.bak&#125;</div><div class="line"></div><div class="line">vim /etc/yum.repos.d/CentOS-Local.repo</div><div class="line"></div><div class="line">[base-Local]</div><div class="line">name=Centos- Local</div><div class="line">baseurl=file:///mnt/xxx</div><div class="line">gpgcheck=0</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line">priority=1    #优先级为1</div><div class="line"></div><div class="line">[updates-Local]</div><div class="line">name=CentOS- Local</div><div class="line">gpgcheck=0</div><div class="line">baseurl=file:///dir/path/</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line">priority=1</div><div class="line"></div><div class="line">······</div><div class="line">#具体可参考CentOS-Base.repo</div><div class="line">#可将aliyun源优先级写成2</div><div class="line"></div><div class="line">yum clean all</div><div class="line">yum makecache</div></pre></td></tr></table></figure><p><br></p><h2 id="配置ftp方式源"><a href="#配置ftp方式源" class="headerlink" title="配置ftp方式源"></a>配置ftp方式源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">vim /etc/yum.repos.d/ftp.repo</div><div class="line"></div><div class="line">[ftp-media]</div><div class="line">name=name=CentOS-$releasever - media</div><div class="line">baseurl=ftp://ip</div><div class="line">gpgcheck=0</div><div class="line">enable=1</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</div><div class="line"></div><div class="line">yum clean all</div><div class="line">yum makecache</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="其他常见YUM源"><a href="#其他常见YUM源" class="headerlink" title="其他常见YUM源"></a>其他常见YUM源</h1><p>官方的默认<code>yum源</code>提供的软件包往往是很滞后的，(可能为了服务器版本的稳定性和安全性)。并且官方默认源提供的RPM包也不够丰富。</p><p><br></p><h2 id="EPEL源"><a href="#EPEL源" class="headerlink" title="EPEL源"></a>EPEL源</h2><p>EPEL的全称叫 <code>Extra Packages for Enterprise Linux</code> 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。</p><p><code>EPEL源</code>为服务器提供了大量的rpm包(这些包可能有很多在默认源中没有)，并且绝大多数rpm包比官方默认源版本要新。</p><p><strong>添加epel源：</strong><br>epel下载地址：<a href="http://download.fedora.redhat.com/pub/epel/" target="_blank" rel="noopener">http://download.fedora.redhat.com/pub/epel/</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpm -vih http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-9.noarch.rpm</div><div class="line"></div><div class="line"><span class="comment">#yum install -y epel-release</span></div></pre></td></tr></table></figure></p><p><br></p><h2 id="remi源"><a href="#remi源" class="headerlink" title="remi源"></a>remi源</h2><p>Remi源大家或许很少听说，不过Remi源GoFace强烈推荐，尤其对于不想编译最新版的linux使用者，因为Remi源中的软件几乎都是最新稳定版。<br>或许您会怀疑稳定不？<br>放心，这些都是Linux骨灰级的玩家编译好放进源里的，他们对于系统环境和软件编译参数的熟悉程度毋庸置疑。</p><p><strong>添加remi源：</strong><br>Remi下载地址：<a href="http://rpms.famillecollet.com" target="_blank" rel="noopener">http://rpms.famillecollet.com</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</div><div class="line"></div><div class="line"><span class="comment">#yum install -y  http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</span></div></pre></td></tr></table></figure></p><p><br></p><h2 id="RPMForge源"><a href="#RPMForge源" class="headerlink" title="RPMForge源"></a>RPMForge源</h2><p><code>RPMForge</code>是<code>CentOS</code>系统下的软件仓库，拥有4000多种的软件包, 被CentOS社区认为是最安全也是最稳定的一个软件仓库。</p><p><strong>添加RPMForge源：</strong><br>RPMForge下载地址：<a href="http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/" target="_blank" rel="noopener">http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/</a><br>GitHub:<a href="https://github.com/repoforge" target="_blank" rel="noopener">https://github.com/repoforge</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpm -ivh http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm</div><div class="line"></div><div class="line">#yum localinstall --nogpgcheckhttp://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/leshami/article/details/78133716&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CentOS 7下配置本地yum源及yum客户端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/conling_/article/details/70399694&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Centos7 配置本地源+阿里yum源/epel-yum+修改优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/kingfox/article/details/51233153&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;调整CentOS 7中yum仓库的优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000375848&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;国内开源站点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Yum" scheme="https://zhang21.github.io/tags/Yum/"/>
    
  </entry>
  
  <entry>
    <title>写给2017</title>
    <link href="https://zhang21.github.io/2018/01/01/%E5%86%99%E7%BB%992017/"/>
    <id>https://zhang21.github.io/2018/01/01/写给2017/</id>
    <published>2018-01-01T02:25:20.000Z</published>
    <updated>2018-01-09T05:42:35.492Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2018.jpg" alt="2018"></p><p><br><br><a id="more"></a></p><h1 id="2017大事件"><a href="#2017大事件" class="headerlink" title="2017大事件"></a>2017大事件</h1><ul><li>Feb.27.2017，开始工作；</li><li>May.27.2017，工作转正；</li><li>Jun.25.2017，大学毕业；</li><li>Aug.27.2017，工作半年；</li><li>Aug.30.2017，搭建博客。</li></ul><p>记得大四下期的时候，在学校实在是想出来工作，以为这样就可以有工资有点钱可以实现财务自由。Naive x3!</p><p>记得刚去面试的时候，公司的HR问我期待的薪资是多少。我这个老实人也不敢往高了说，以为能解决温饱就不错。这就导致后面日子过得紧巴巴，生活基本上处于没钱不敢消费不敢出去的惨状。Naive x3!</p><p>记得那天是星期四，从学校收拾了一箱子的衣物加上自己的笔记本就来了成都。还要感谢<strong>强</strong>对我的帮助，在他那借宿了两天。这两天跑到公司附近找房子，这打个电话，那去看看…结果看了看自己兜里不到三千，再看看房租，还是算了吧！后来由于周一就要开始去公司报道了，实在没办法，硬着头皮找了一个750的单间。我现在觉得，人在生活面前真的没有办法。借用张主任的一句话——“是生活，生活强奸了所有人。”一个套三的屋子，硬是被房主改造成了七间房，住了11人。我想各位住户都迫于无奈吧，有谁想和别人挤在一起了，况且还要忍受上厕所的艰难时光。<br>还是说说我住的那间房屋吧。是客厅使用木板隔得房间，手指随便敲几下都铛铛作响，况且隔壁还住了一对情侣。一张床，一个烂小衣柜，一张摆放电脑的桌子。客厅的后面有一个阳台，所以就会有一个大窗户间隔阳台。然而这个阳台是和隔壁公用的，也就是说，这个大窗户是可以互通的。哎！阳台风大，还好我只住到了夏天。<br>五月二十号，和我强一起搬到了中和。也是没有做好十足打算，说搬就搬了。虽说住宿条件好了一些，可这面修路是真的堵，公家车是真的挤，真的是挤得怀疑人生的那种，还是走路吧。由于搬过来中和，房租和其他开支多了一些，刚开始没什么钱的时候，自己带饭去公司。我都佩服自己，那么挤得车上还能坚持带饭几个月，看来还是穷吧。冬天到了，太冷了就没有带饭到公司了。但公司楼下吃饭真的好贵，吃不起吃不起。由于住宿条件好了一些，晚上回来可以自己做饭，还是不错。并且晚上基本有两个小时干干工作之外的事情，看看小说、看看电视、发发呆什么也挺好的！</p><p>记得才开始工作的时候，好像每天都很闲，没有事做。心里担忧的不行，这样怎么有提升呢？每天都急躁不安，这不会那不会，又腼腆害羞…后来慢慢理解，任何事情都不能操之过急，不能带着情绪上班。不喜欢某个同事也不能表现出来，更不能带到工作上。工作是工作，生活是生活，一定要分开。被骂也没有办法，骂吧，你骂高兴。任何人都不会听你的理由，理由对于别人来说只是你没有完成的狡辩。踏踏实实上班，做好自己的事情才是正解！千万不要好为人师，人都是有嫉妒心得，不要太招摇！也不要羡慕别人工作轻松之类，那是人家的工作，和你没有半毛钱关系。上班好好上班，不要搞东搞西。我个人比较看重效率，怀着为了加班而加班的目的真的没有必要。那时由于住单间，条件差，愿意在公司多呆一会，多学习知识。越到后面，觉得自己越得努力学习新知识，需要了解的知识就在那，就等我把它们一个个打上勾，撸起袖子加油干。</p><p><br></p><p><strong>自我批评:</strong></p><ul><li>心胸不够宽广，容易嫉妒别人；</li><li>害羞爱面子，拉不下面子做事情；</li><li>由于自卑心理导致的不敢说不敢争。</li></ul><p>以前我以为自己是讨厌某种方式、讨厌别人炫耀、讨厌别人秀恩爱，现在才知道是由于自己没有，就用自己的不屑和厌恶来突出自己，让自己心安理得。说白了还不是自己嫉妒人家，嫉妒人家比我好，有女票。这点是真的要改，一定要改。千万别用别人的缺点来突出自己，这很SB，切记切记。如同小波所说：“人的一切痛苦，本质都是对于自己无能的愤怒。”</p><p>在学校总幻想自己能成为英雄，总想做一番事业，像历史上的英雄那般。不屑考个老师公务员职位，以为一辈子就那样，混吃等死的咸鱼。其实其它工作不也同样是这样吗。混吃等死的不是任何工作岗位，而是人！任何岗位都可以有所成就。自己也不过只是凡人一个。不过凡人却也可以有自己的一片天地。就像小波说的：“井底之蛙也能拥有自己的一片天地。”</p><p>工作没有高低贵贱之分，不要带着要面子的心情而不愿意做些打杂的活。没有基础的积累，哪来平地起的万丈高楼。不要看不起自己也不要看不起他人。三十年河东三十年河西，此一时彼一时。</p><p>”中国的君子独善其身，这样就没有了尊严。这是因为尊严是属于个人的、不可压缩的空间，这块空间要靠自己来捍卫——捍卫的意思是指敢争、敢打官司、敢动手（勇斗歹徒）。我觉得人还是有点尊严的好，假如个人连个待的地方都没有，就无法为人做事，更不要说做别人的典范。“这句话同样适合我，该说该争该做的时候就应该大胆站出来，有一个男子汉的样子。要敢于亮剑！</p><p>我现在还不太明白我的人生目标是什么，名利？我不知道。我只想做一个懂点道理的人。上班以后感觉也变得世俗化了，不经意间都会主动被动地谈及任何关于钱的话题。我对钱有一些兴趣，但不愿为之受罪。我不想把自己的下半生绑在房子上，虽然我也买不起。找不到人同我谈谈诗歌、文学、历史、足球，谈谈理想和爱情。但正如小波所言：”和我志趣相投的人总不会一个人都没有吧。“我也不顾影自怜了。</p><p><br><br><br></p><h1 id="展望2018"><a href="#展望2018" class="headerlink" title="展望2018"></a>展望2018</h1><ul><li>最重要的事情当然是涨工资啦，哈哈。加油加油，为了涨工资可得好好奋斗；</li><li>如果能找一个离家近一点的工作当然是最好；</li><li>一个人总是孤独寂寞的，能找到一个能相互扶持的人当然最好；</li><li>改善自己的不同，提升自己的优点。扬长避短，向优秀的人多学习。</li></ul><p><br><br><br></p><h1 id="不成熟的想法"><a href="#不成熟的想法" class="headerlink" title="不成熟的想法"></a>不成熟的想法</h1><ul><li>成都这地方什么都要争，连坐个公交地铁也得积极地抢位置，哎；</li><li>人太多，太拥挤，随便去哪都是拥挤的要命。但另一方面却是人越多机会越多；</li><li>原来工作才是一生的主题。但到底图个啥——名？利？</li><li>上班以后认识的人也变少了，圈子也基本没什么了。曾经的同学们也各奔东西了；</li><li>我发觉任何一件事都是矛盾的。正面想是这样，反面想却又是那样，但都有道理。让我想起了一个故事，“一个农夫和一个老板在海边的对话。问：这么努力工作干嘛？答：为了以后能过更轻松的日子。那你看我现在不是挺轻松自在的吗？”</li><li>现在的自媒体为了流量真的是无所不用其极。各种大噱头的标题，完全不负责任的报道，只为吸引流量。到最后都不知道该相信谁，会不会被带节奏…；</li><li>一天24小时。8小时睡觉，8小时上班，3小时上下班，2小时吃饭及其他。It means that I only have 3 hours a day without Rest Day;</li><li>一个人只拥有此生此世是不够的，他还应该拥有诗意的世界。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2018.jpg&quot; alt=&quot;2018&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Zhang" scheme="https://zhang21.github.io/categories/Zhang/"/>
    
    
      <category term="2017" scheme="https://zhang21.github.io/tags/2017/"/>
    
  </entry>
  
  <entry>
    <title>君子的尊严</title>
    <link href="https://zhang21.github.io/2017/12/28/%E5%90%9B%E5%AD%90%E7%9A%84%E5%B0%8A%E4%B8%A5/"/>
    <id>https://zhang21.github.io/2017/12/28/君子的尊严/</id>
    <published>2017-12-28T01:58:32.000Z</published>
    <updated>2017-12-28T02:00:25.347Z</updated>
    
    <content type="html"><![CDATA[<p>笔者是个学究，待人也算谦和有礼，自以为算个君子——当然，实际上是不是，还要别人来评判。总的来说，君子是有文化有道德的人，是士人或称知识分子。按照中国的传统，君子是做人的典范。君子不言利。君子忍让不争。君子动口不动手。君子独善其身。这都是老辈子传下来的规矩，时至今日，以君子自居的人还是如此行事。我是宁做君子不做小人的，但我还是以为，君子身上有些缺点，不配作为人的典范；因为他太文弱、太窝囊、太受人欺。</p><a id="more"></a><p><br></p><p>君子既不肯与人争利，就要安于清贫。但有时不是钱的问题，是尊严的问题。前些时候在电视上看到北京的一位人大代表发言，说儿童医院的挂号费是一毛钱，公厕的收费是两毛钱。很显然，这样的收费标准有损医务工作的尊严。当然，发言的结尾是呼吁有关领导注意这个问题，有关领导也点点头说：是呀是呀，这个问题要重视。我总觉得这位代表太君子，没把话讲清楚——直截了当的说法是：我们要收两块钱。别人要是觉得太贵，那你就还个价来——这样三下五除二就切入了正题。这样说话比较能解决问题。</p><p><br></p><p>君子不与人争，就要受气。举例来说，我乘地铁时排队购票，总有些不三不四的人到前面加塞。说实在的，我有很多话要说：我排队，你为什么不排队？你忙，难道我就没有事？但是碍于君子的规范，讲不出口来。话憋在肚子里，难免要生气。有时气不过，就嚷嚷几句：排队，排队啊。这种表达方式不够清晰，人家也不知是在说他。正确的方式是：指住加塞者的鼻子，口齿清楚地说道：先生，大家都在排队，请你也排队。但这样一来，就陷入与人争论的境地，肯定不是君子了。</p><p><br></p><p>常在报纸上看到这样的消息：流氓横行不法，围观者如堵，无人上前制止。我敢断定，围观的都是君子，也很想制止，但怎么制止呢？难道上前和他打架吗？须知君子动口不动手啊。我知道英国有句俗话：绅士动拳头，小人动刀子。假如在场的是英国绅士，就可以上前用拳头打流氓了。</p><p><br></p><p>既然扯到了绅士，就可以多说几句。从前有个英国人到澳大利亚去旅行，过海关时，当地官员问他是干什么的。他答道：我是一个绅士。因为历史的原因，澳大利亚人不喜欢听到这句话，尤其不喜欢听到这句话从一个英国人嘴里说出来。那官员又问：我问你的职业是什么？英国人答道：职业就是绅士。难道你们这里没有绅士吗？这下澳大利亚人可火了，差点揍他，幸亏有人拉开了。在英美，说某人不是绅士，就是句骂人话。当然，在我们这里说谁不是君子，等于说他是小人，也是句骂人话。但君子和绅士不是一个概念。从字面上看，绅士（gentleman）是指温文有礼之人，其实远不止此。绅士要保持个人的荣誉和尊严，甚至可以说是这方面的专业户。坦白地说，他们有点狂傲自大。但也有一种好处：真正的绅士决不在危险面前止步。大战期间，英国绅士大批开赴前线为国捐躯，甚至死在了一般人前面。君子的标准里就不包括这一条。</p><p><br></p><p>中国的君子独善其身，这样就没有了尊严。这是因为尊严是属于个人的、不可压缩的空间，这块空间要靠自己来捍卫——捍卫的意思是指敢争、敢打官司、敢动手（勇斗歹徒）。我觉得人还是有点尊严的好，假如个人连个待的地方都没有，就无法为人做事，更不要说做别人的典范。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者是个学究，待人也算谦和有礼，自以为算个君子——当然，实际上是不是，还要别人来评判。总的来说，君子是有文化有道德的人，是士人或称知识分子。按照中国的传统，君子是做人的典范。君子不言利。君子忍让不争。君子动口不动手。君子独善其身。这都是老辈子传下来的规矩，时至今日，以君子自居的人还是如此行事。我是宁做君子不做小人的，但我还是以为，君子身上有些缺点，不配作为人的典范；因为他太文弱、太窝囊、太受人欺。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="王小波" scheme="https://zhang21.github.io/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>个人尊严</title>
    <link href="https://zhang21.github.io/2017/12/28/%E4%B8%AA%E4%BA%BA%E5%B0%8A%E4%B8%A5/"/>
    <id>https://zhang21.github.io/2017/12/28/个人尊严/</id>
    <published>2017-12-28T01:54:39.000Z</published>
    <updated>2017-12-28T01:56:45.130Z</updated>
    
    <content type="html"><![CDATA[<p>在国外时看到，人们对时事做出价值评判时，总是从两个独立的方面来进行：一个方面是国家或者社会的尊严，这像是时事的经线；另一个方面是个人的尊严，这像是时事的纬线。回到国内，一条纬线就像是没有，连尊严这个字眼也感到陌生了。提到尊严这个概念，我首先想到的英文词＂dignity＂，然后才想到相应的中文词。在英文中，这个词不仅有尊严之义，还有体面、身份的意思。尊严不但指人受到尊重，它还是人价值之所在。从上古到现代，数以亿万计的中国人里，没有几个人有过属于个人的尊严。举个大点的例子，中国历史上有过皇上对大臣施廷杖的事，无论是多大的官，一言不和，就可能受到如此当众羞辱，高官尚且如此，遑论百姓。除了皇上一人，没有一个人能有尊严。有一件最怪的事是，按照传统道德，挨皇帝的板子倒是一种光荣，文死谏嘛。说白了就是：无尊严就是有尊严。此话如有任何古怪之处，罪不在我。到了现代以后，人与人的关系、个人与集体的关系，仍有这种遗风──我们就不必细说文革中、文革前都发生过什么样的事情。到了现在，已经不用见官下跪，也不会在屁股上挨板子，但还是缺少个人的尊严。环境就是这样，公共场所的秩序就是这样，人对人的态度就是这样，不容你有任何自尊。</p><a id="more"></a><p><br></p><p>举个小点的例子，每到春运高潮，大家就会在传媒上看到一辆硬座车厢里挤了三四百人，厕所里也挤了十几人。谈到这件事，大家会说国家的铁路需要建设，说到铁路工人的工作难做，提到安全问题，提到所有的方面，就是不提这些民工这样挤在一起，好像一个团，完全没有了个人的尊严──仿佛这件事很不重要似的。当然，只要民工都在过年时回家，火车总是要挤的；谁也想不出好办法。但个人的尊严毕竟大受损害；这件事总该有人提一提才对。另一件事现在已是老生常谈，人走在街上感到内急，就不得不上公共厕所。一进去就觉得自己的尊严一点都没了。现在北京的公厕正在改观，这是因为外国人到了中国也会内急，所以北京的公厕已经臭名远扬。假如外国人不来，厕所就要臭下去；而且大街上改了，小胡同里还没有改。我认识的一位美国留学生说，有一次他在小胡同里内急，走进公厕撒了一泡尿，出来以后，猛然想到自己刚才满眼都对黄白之物，居然能站住了不倒，觉得自己很了不起，就急忙来告诉我。北京的某些街道很脏很乱，总要到某个国际会议时才能改观，这叫借某某会的东风。不光老百姓这样讲，领导上也这样讲。这话听起来很有点不对味。不雅的景象外人看了丢脸，没有外人时，自己住在里面也不体面──这后一点总是被人忘掉。</p><p><br></p><p>作为一个知识分子，我发现自己曾有一种特别的虚伪之处，虽然一句话说不清，但可以举些例子来说明。假如我看到火车上特别挤，就感慨一声道：这种事居然可以发生在中华人民共和国的土地上！假如我看到厕所特脏，又长叹一声：唉！北京市这是怎么搞的嘛！这其中有点幽默的成份，也有点当真。我的确觉得国家和政府的尊严受到了损失，并为此焦虑着。当然，我自己也想要点个人尊严，但以个人名义提出就过于直露，不够体面──言必称天下，不以个人面目出现，是知识分子的尊严所在。当然，现在我把这做为虚伪提出，已经自外于知识分子。但也有种好处，我找到了自己的个人面目。有关尊严问题，不必引经据典，我个人就是这么看。但中国忽视个人尊严，却不是我的新发现。从大智者到通俗作家，有不少人注意到一个有中国特色的现象：罗素说，中国文化里只重家族内的私德，不重社会的公德公益，这一点造成了很要命的景象；费孝通说，中国社会里有所谓＂差序格局＂，与己关系近的就关心，关系远的就不关心或少关心；结果有些事从来就没人关心。龙应台为这类事而愤怒过，三毛也大发过一通感慨。读者可能注意到了，所有指出这个现象的人，或则是外国人，或则曾在国外生活过，又回到了国内。没有这层关系的中国人，对此浑然不觉。笔者自己曾在外国居住四年，假如没有这种经历，恐怕也发不出这种议论──但这一点并不让我感到开心。环境脏乱的问题，火车拥挤的问题，社会秩序的问题，人们倒是看到了。但总从总体方面提出问题，讲国家的尊严、民族的尊严。其实这些事就发生在我们身边，削我们每个人的面子──对此能够浑然无觉，倒是咄咄怪事。</p><p><br></p><p>人有无尊严，有一个简单的判据，是看他被当作一个人还是一个东西来对待。这件事有点两重性，其一是别人把你当做人还是东西，是你尊严之所在。其二是你把自己看成人还是东西，也是你的尊严所在。挤火车和上公共厕所时，人只被当身体来看待。这里既有其一的成份，也有其二的成份；而且归根结蒂，和我们的文化传统有关。</p><p><br></p><p>说来也奇怪，中华礼仪之邦，一切尊严，都从整体和人与人的关系上定义，就是没有个人的位置。一个人不在单位里、不在家里，不代表国家、民族，单独存在时，居然不算一个人，就算是一块肉。这种算法当然是有问题。我的算法是：一个人独处荒岛而且谁也不代表，就像鲁滨孙那样，也有尊严，可以很好的活着。这就是说，个人是尊严的基本单位。知道了这一点，火车上太挤了之后，我就不会再挤进去而且浑然无觉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在国外时看到，人们对时事做出价值评判时，总是从两个独立的方面来进行：一个方面是国家或者社会的尊严，这像是时事的经线；另一个方面是个人的尊严，这像是时事的纬线。回到国内，一条纬线就像是没有，连尊严这个字眼也感到陌生了。提到尊严这个概念，我首先想到的英文词＂dignity＂，然后才想到相应的中文词。在英文中，这个词不仅有尊严之义，还有体面、身份的意思。尊严不但指人受到尊重，它还是人价值之所在。从上古到现代，数以亿万计的中国人里，没有几个人有过属于个人的尊严。举个大点的例子，中国历史上有过皇上对大臣施廷杖的事，无论是多大的官，一言不和，就可能受到如此当众羞辱，高官尚且如此，遑论百姓。除了皇上一人，没有一个人能有尊严。有一件最怪的事是，按照传统道德，挨皇帝的板子倒是一种光荣，文死谏嘛。说白了就是：无尊严就是有尊严。此话如有任何古怪之处，罪不在我。到了现代以后，人与人的关系、个人与集体的关系，仍有这种遗风──我们就不必细说文革中、文革前都发生过什么样的事情。到了现在，已经不用见官下跪，也不会在屁股上挨板子，但还是缺少个人的尊严。环境就是这样，公共场所的秩序就是这样，人对人的态度就是这样，不容你有任何自尊。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature" scheme="https://zhang21.github.io/categories/Literature/"/>
    
    
      <category term="王小波" scheme="https://zhang21.github.io/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>SaltStack</title>
    <link href="https://zhang21.github.io/2017/12/25/SaltStack/"/>
    <id>https://zhang21.github.io/2017/12/25/SaltStack/</id>
    <published>2017-12-25T01:47:39.000Z</published>
    <updated>2018-01-11T07:31:56.907Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>SaltStack官网：<a href="https://saltstack.com" target="_blank" rel="noopener">https://saltstack.com</a> ;</li><li>SaltStack官方文档：<a href="https://docs.saltstack.com" target="_blank" rel="noopener">https://docs.saltstack.com</a> ;</li><li>SaltStack-GitHub：<a href="https://github.com/saltstack" target="_blank" rel="noopener">https://github.com/saltstack</a> ;</li><li>Salt-repo：<a href="https://repo.saltstack.com/" target="_blank" rel="noopener">https://repo.saltstack.com/</a> .</li></ul><p>环境：</p><ul><li>CentOS7_x64;</li><li>Salt-2017.7.2</li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a>Instruction</h1><p><code>SaltStack</code>是一种革命性的用速度(speed)取代复杂性(complexity)的基础设施(infrastucture)管理方法。</p><ul><li>简单(Simple)，可以在几分钟内运行；</li><li>可伸缩性(Scalable)，足以管理数以万计的Server；</li><li>快速(Fast)，能在几秒内与各系统间进行通信。</li></ul><p><br></p><p><strong>You’ll learn how to:</strong></p><ul><li>安装和配置SaltStack；</li><li>在所有托管系统上远程执行命令(Remotely execute commands)；</li><li>设计、开发和部署系统配置；</li><li>使用Salt Reactor是基础设施自动化(automate)；</li><li>使用Salt Orchestration协调复杂管理操作。</li></ul><p><img src="/images/Salt/SaltStack.png" alt="SaltStack"></p><p><br></p><p>Salt是建立在动态通信总线(dynamic communication bus)上的基础设施管理的一种新方法。Salt可以用于数据驱动(data-driven)业务，远程执行(remote execution)任何基础设施，配置管理(configuration management)任意应用堆栈…</p><ul><li>REMOTE EXECUTION;</li><li>CONFIGURATION MANAGEMENT;</li><li>EVENT-DRIVEN INFRASTRUCTURE;</li><li>SALT ESSENTIALS.</li></ul><p><br></p><hr><p><br></p><h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><p>如果是第一次设置环境，你应该在专用的管理服务器上安装<code>Salt master</code>，然后在每个使用Salt管理的系统上安装<code>Salt minion</code>。现在不需要担心你的系统架构(architecture)，你可以在以后轻易添加组件(componet)和修改配置(configuration)而不需要重新安装任何东西。</p><p>The general installation process is as follows:</p><ul><li>安装<code>Salt master</code>，通过各平台说明安装或通过Salt <code>bootstrap.sh</code>脚本来安装；</li><li>确保你的<code>Salt minion</code>能够找到<code>Salt master</code>；</li><li>在想要管理的每个系统上安装<code>Salt minion</code>；</li><li>在<code>Salt minion</code>连接后接受<code>Salt minion key</code>。</li></ul><p>在此之后，就可以<strong>运行一个简单命令</strong>，并从所有的<code>Salt minion</code><strong>接收返回</strong>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#salt &lt;minion-id&gt; &lt;cmd&gt;</span></div><div class="line"></div><div class="line">salt minion1 test.ping</div><div class="line">salt * test.ping</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Quick-Install"><a href="#Quick-Install" class="headerlink" title="Quick Install"></a>Quick Install</h2><p>在绝大多数发行版本上，可以使用<strong>Salt Bootstrap</strong>脚本进行快速安装。</p><p>参考：<a href="https://docs.saltstack.com/en/latest/topics/tutorials/salt_bootstrap.html#salt-bootstrap" target="_blank" rel="noopener">Salt Bootstrap</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#wget</div><div class="line">wget https://bootstrap.saltstack.com -O bootstrap-salt.sh</div><div class="line">sh bootstrap-salt.sh</div><div class="line"></div><div class="line">#curl</div><div class="line">curl -o bootstrap-salt.sh -L https://bootstrap.saltstack.com</div><div class="line">sh bootstrap-salt.sh</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Platform-Specific-Installation"><a href="#Platform-Specific-Installation" class="headerlink" title="Platform-Specific Installation"></a>Platform-Specific Installation</h2><p><a href="https://docs.saltstack.com/en/latest/topics/installation/index.html#platform-specific-installation-instructions" target="_blank" rel="noopener">选择发行版本安装</a></p><p><br></p><h3 id="在CentOS7上安装Salt"><a href="#在CentOS7上安装Salt" class="headerlink" title="在CentOS7上安装Salt"></a>在CentOS7上安装Salt</h3><p>repo: <a href="https://repo.saltstack.com/#rhel" target="_blank" rel="noopener">https://repo.saltstack.com/#rhel</a></p><p><strong>1. 下载SaltStack-Repository进行安装：</strong></p><p><code>systemd</code>和<code>systemd-python</code>是Salt必须的，在安装Salt前需装好。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#安装salt-repo</span></div><div class="line">yum install -y https://repo.saltstack.com/yum/redhat/salt-repo-latest-2.el7.noarch.rpm</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">yum clean expire-cache</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#安装salt组件</span></div><div class="line">yum install -y salt-master salt-master salt-ssh salt-syndic salt-cloud salt-api</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#开启</span></div><div class="line">systemctl start salt-master</div></pre></td></tr></table></figure><p><br></p><p><strong>2. 自建salt-repo：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">vim /etc/yum.repos.d/saltstack.repo</div><div class="line"></div><div class="line"></div><div class="line">[saltstack-repo]</div><div class="line">name=SaltStack repo <span class="keyword">for</span> Cent0S7</div><div class="line">baseurl=https://repo.saltstack.com/yum/redhat/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/latest</div><div class="line">enalbed=1</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=https://repo.saltstack.com/yum/redhat/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/latest/SALTSTACK-GPG-KEY.pub</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Initial-Configuration"><a href="#Initial-Configuration" class="headerlink" title="Initial Configuration"></a>Initial Configuration</h2><h3 id="Configuration-Salt"><a href="#Configuration-Salt" class="headerlink" title="Configuration Salt"></a>Configuration Salt</h3><p><code>salt-master</code> 的默认配置会为安装而工作，唯一要求是在<code>salt-minion</code>的配置文件中设置<code>salt-master</code>的位置。</p><p><br></p><h4 id="salt-master-configuration"><a href="#salt-master-configuration" class="headerlink" title="salt-master configuration"></a>salt-master configuration</h4><p>默认的，<code>salt-master</code>配置文件位于<code>/etc/salt/master</code>，在all interfaces(0.0.0.0)上监听<code>4505</code>和<code>4506</code>端口。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim /etc/salt/master</div><div class="line"></div><div class="line"></div><div class="line">interface: 0.0.0.0</div></pre></td></tr></table></figure><p><br></p><h4 id="salt-minion-configuration"><a href="#salt-minion-configuration" class="headerlink" title="salt-minion configuration"></a>salt-minion configuration</h4><p>默认，一个<code>salt-minion</code>会尝试连接到DNS名称为<code>salt</code>。如果<code>salt-minion</code>能够正确解析(resolve)这个名称，则可以不需要配置文件。如果DNS名称<code>salt</code>未能解析为<code>salt-master</code>的正确位置，那么可在<code>/etc/salt/minion</code>配置文件下重新定义<code>salt</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vim /etc/salt/minion</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#master: salt</span></div><div class="line"><span class="comment">#如果是默认的salt,需要在本地hosts下解析salt</span></div><div class="line"></div><div class="line"><span class="comment">#此处我们修改为salt-master的IP地址</span></div><div class="line">master: 192.168.1.9</div></pre></td></tr></table></figure><p><strong>修改配置文件后，请重启服务。</strong></p><p><br></p><h4 id="Proxy-Minion-Configuration"><a href="#Proxy-Minion-Configuration" class="headerlink" title="Proxy Minion Configuration"></a>Proxy Minion Configuration</h4><p>A Proxy Minion 模仿一个规律的行为和继承(inherit)他们的选项。<br>类似地，它的配置文件存放于<code>/etc/salt/proxy</code>，<code>proxy</code>也将尝试连接DNS名为<code>salt</code>的主机。</p><p>除了<code>salt-minion</code>有规律的选型，<code>proxy</code>还有一些特定的选项。参考:<a href="https://docs.saltstack.com/en/latest/ref/configuration/proxy.html#configuration-salt-proxy" target="_blank" rel="noopener">Proxy minion</a></p><p><br></p><h4 id="Running-Salt"><a href="#Running-Salt" class="headerlink" title="Running Salt"></a>Running Salt</h4><p>以<code>salt</code>命令运行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">salt-master</div><div class="line"></div><div class="line"><span class="comment">#开启守护进程</span></div><div class="line">dalt-master -d</div><div class="line"></div><div class="line"></div><div class="line">salt-minion</div><div class="line">salt-minion -d</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#日志信息</span></div><div class="line">salt-master --<span class="built_in">log</span>-level=debug</div></pre></td></tr></table></figure><p><strong>以non-root user运行salt</strong></p><ul><li>确保此用户有相应的权限；</li><li>可能需要手动创建<code>salt</code>运行需要的目录<code>/etc/salt, /var/cache/salt, /var/log/salt, /var/run/salt</code>。</li></ul><p><br></p><h4 id="Key-Identity"><a href="#Key-Identity" class="headerlink" title="Key Identity"></a>Key Identity</h4><p>在<code>initial key</code>交换之前，<code>Salt</code>会提供命令来验证(validate)<code>salt-master</code>和<code>salt-minion</code>的身份。<br>验证身份有助于避免疏忽地连接到错误的<code>salt-master</code>，并且在建立初始化连接的阻止MiTM攻击。</p><p><strong>Master Key Fingerprint</strong><br>复制<code>master.pub</code>的值，并将其作为<code>salt-minion</code>配置文件<code>/etc/salt/minion</code>中<code>master_finger</code>的值。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#salt-key is used to manage Salt authentication keys</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#显示master的key</span></div><div class="line">salt-key -F master</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看minion的finger</span></div><div class="line"><span class="comment">#salt-key --finger &lt;minion_id&gt;</span></div><div class="line">dalt-key --finger <span class="string">'192.168.1.7'</span></div></pre></td></tr></table></figure><p><strong>Minion Key Fingerprint</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">salt-call is used to execute module <span class="built_in">functions</span> locally on a Salt Minion</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看minion key fingerprint</span></div><div class="line"><span class="comment">#可在master上查看，比对两者是否相同</span></div><div class="line">salt-call --<span class="built_in">local</span> key.finger</div></pre></td></tr></table></figure><p><br></p><h4 id="Key-Management"><a href="#Key-Management" class="headerlink" title="Key Management"></a>Key Management</h4><p>Salt使用AES Encryption加密<code>salt-master</code>与<code>salt-minion</code>间的所有通信。这确保了发送到Minion的命令不会被篡改(tamper)，并保证了master与minion间是认证的和受信任的。</p><p>当命令发送到<code>salt-minion</code>之前，<code>salt-minion</code>的key必须要被<code>salt-master</code>所接受。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#列出salt-master上已知的keys</span></div><div class="line">salt-key -L</div></pre></td></tr></table></figure><p>其中包含四项:</p><ul><li>Accepted Keys:</li><li>Denied Keys:</li><li>Unaccepted keys:</li><li>Rejected keys:</li></ul><p><strong>让<code>salt-master</code>接收key，并允许<code>salt-minion</code>被<code>salt-master</code>控制</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-a 192.168.1.7, --accept=192.168.1.7</span></div><div class="line"><span class="comment">#-A, --accept-all</span></div><div class="line"></div><div class="line">salt-key -A</div></pre></td></tr></table></figure><p><br></p><h4 id="Sending-Commands"><a href="#Sending-Commands" class="headerlink" title="Sending Commands"></a>Sending Commands</h4><p><code>salt-master</code>和<code>salt-minion</code>之间通过运行<code>test.ping</code>命令来证实(verified)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">salt 192.168.1.7 test.ping</div><div class="line"></div><div class="line">salt * test.ping</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Additional-Installation-Guides"><a href="#Additional-Installation-Guides" class="headerlink" title="Additional Installation Guides"></a>Additional Installation Guides</h2><h3 id="Salt-Bootstrap"><a href="#Salt-Bootstrap" class="headerlink" title="Salt Bootstrap"></a>Salt Bootstrap</h3><p>Salt Bootstrap脚本允许用户在各种系统和版本上安装<code>salt-minion</code>和<code>salt-master</code>。shell脚本为<code>bootstrap-salt.sh</code>，运行一系列的检查来确定操作系统的类型和版本，然后通过适当的方法安装salt二进制文件。salt-bootstrap脚本安装运行<code>salt</code>的最小化安装包，如Git便不会安装。</p><p>Salt Bootstrap’s GitHub: <a href="https://github.com/saltstack/salt-bootstrap" target="_blank" rel="noopener">https://github.com/saltstack/salt-bootstrap</a></p><p><br></p><h4 id="Example-Usage"><a href="#Example-Usage" class="headerlink" title="Example Usage"></a>Example Usage</h4><p>Satl Bootstrap脚本有多种可以传递的选项，以及获取引导脚本本身的方法。</p><p><strong>1. Using <code>curl</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -o bootstrap-salt.sh -L https://bootstrap.saltstack.com</div><div class="line">sh bootstrap-salt.sh git develop</div></pre></td></tr></table></figure><p><strong>2. Using <code>wget</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget -O bootstrap-salt.sh https://bootstrap.saltstack.com</div><div class="line">sh bootstrap-salt.sh</div></pre></td></tr></table></figure><p><strong>3. An Insecure one-liner</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">curl -L https://bootstrap.saltstack.com | sh</div><div class="line"></div><div class="line">wget -O - https://bootstrap.saltstack.com | sh</div><div class="line"></div><div class="line">curl -L https://bootstrap.saltstack.com | sh -s -- git develop</div></pre></td></tr></table></figure><p><strong>4. cmd line options</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#查看帮助</div><div class="line">sh bootstrap-salt.sh -h</div></pre></td></tr></table></figure><p><br></p><h3 id="Openging-the-firewall-up-for-salt"><a href="#Openging-the-firewall-up-for-salt" class="headerlink" title="Openging the firewall up for salt"></a>Openging the firewall up for salt</h3><p><code>salt-master</code>和<code>salt-minion</code>间的通信使用AES加密的<code>ZeroMQ</code>，它使用TCP的<code>4505</code>和<code>4506</code>端口，仅需要在<code>salt-master</code>上可访问就行。</p><p>下面概述了关于<code>salt-master</code>的防火墙规则：</p><p><strong>RHEL7/CENTOS7</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --permanent --zone=&lt;zone&gt; --add-port=4505-4506/tcp</div><div class="line">firewall-cmd --reload</div></pre></td></tr></table></figure><p><br></p><h3 id="Preseed-minion-with-accepted-key"><a href="#Preseed-minion-with-accepted-key" class="headerlink" title="Preseed minion with accepted key"></a>Preseed minion with accepted key</h3><p>某些情况下，在<code>salt-master</code>上接受<code>minion-key</code>之前等待<code>salt-minion</code>启动是不方便的。比如，你可能希望<code>minion</code>一上线(online)就引导。</p><p>有多种方式生成<code>minion-key</code>，下面是一般生成<code>minion-key</code>的四个步骤：</p><ol><li>在<code>salt-master</code>上生成<code>key</code>：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#请给key取个名字</div><div class="line">salt-key --gen-keys=[key_name]</div></pre></td></tr></table></figure><ol><li>把公钥(publick key)添加到已接受的<code>salt-minion</code>文件夹中:</li></ol><p>公钥文件和 minion_id 有相同的名字是很有必要的，这就是Salt如何通过key与minions匹配。<br>还有，由于不同操作系统或特定的master配置文件，pki 文件夹可能位于不同的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp &lt;key_name&gt;.pub /etc/salt/pkimaster/minions/&lt;minion_id&gt;</div></pre></td></tr></table></figure><ol><li>分配<code>minion-key</code>：</li></ol><p>对于minion来说，没有单一方法去得到密钥对，难点是找到一种安全的分配方法。</p><p>由于<code>master</code>已经接受了<code>minion-key</code>，因此分发私钥(private key)会有潜在的安全风险。</p><ol><li>配置带key的minion：</li></ol><p>你可能希望在启动<code>salt-miniont daemon</code>之前取得<code>minion-key</code>的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/etc/salt/pki/minion/minion.pem</div><div class="line">/etc/salt/pki/minion/minion.pub</div></pre></td></tr></table></figure><p><br></p><h3 id="Running-salt-as-normal-user-tutorial"><a href="#Running-salt-as-normal-user-tutorial" class="headerlink" title="Running salt as normal user tutorial"></a>Running salt as normal user tutorial</h3><p><strong>以普通用户(non-root)运行salt function</strong></p><p>如果你不想使用<code>root</code>用户安装或运行salt，你可以在你的工作目录中创建一个虚拟根目录(virtual root dir)来配置它。<br>salt system使用<code>salt.syspath</code>module来查找变量。</p><p>如果你运行salt-build，它会生成在: <code>./build/lib.linux-x86_64-2.7/salt/_syspaths.py</code>；</p><p>运行<code>python setup.py build</code>命令来生成它；</p><p>复制生成的module到你的salt dir，<code>cp ./build/lib.linux-x86_64-2.7/salt/_syspaths.py ./salt/_syspaths.py</code></p><p>修改它，并加入需要的变量和新路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># you need to edit this</span></div><div class="line">ROOT_DIR = *your current dir* + <span class="string">'/salt/root'</span></div><div class="line"></div><div class="line"><span class="comment"># you need to edit this</span></div><div class="line">INSTALL_DIR = *location of source code*</div><div class="line"></div><div class="line">CONFIG_DIR =  ROOT_DIR + <span class="string">'/etc/salt'</span></div><div class="line">CACHE_DIR = ROOT_DIR + <span class="string">'/var/cache/salt'</span></div><div class="line">SOCK_DIR = ROOT_DIR + <span class="string">'/var/run/salt'</span></div><div class="line">SRV_ROOT_DIR= ROOT_DIR + <span class="string">'/srv'</span></div><div class="line">BASE_FILE_ROOTS_DIR = ROOT_DIR + <span class="string">'/srv/salt'</span></div><div class="line">BASE_PILLAR_ROOTS_DIR = ROOT_DIR + <span class="string">'/srv/pillar'</span></div><div class="line">BASE_MASTER_ROOTS_DIR = ROOT_DIR + <span class="string">'/srv/salt-master'</span></div><div class="line">LOGS_DIR = ROOT_DIR + <span class="string">'/var/log/salt'</span></div><div class="line">PIDFILE_DIR = ROOT_DIR + <span class="string">'/var/run'</span></div><div class="line">CLOUD_DIR = INSTALL_DIR + <span class="string">'/cloud'</span></div><div class="line">BOOTSTRAP = CLOUD_DIR + <span class="string">'/deploy/bootstrap-salt.sh'</span></div></pre></td></tr></table></figure><p>创建目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir -p root/etc/salt root/var/cache/run root/run/salt root/srv</div><div class="line">root/srv/salt root/srv/pillar root/srv/salt-master root/var/log/salt root/var/run</div></pre></td></tr></table></figure><p>填充配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cp -r conf/* /etc/salt/</div><div class="line"></div><div class="line"></div><div class="line">vi /etc/salt/master</div><div class="line"></div><div class="line">user: *your user name*</div></pre></td></tr></table></figure><p>运行：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PYTHONPATH=`pwd` scripts/salt-cloud</div></pre></td></tr></table></figure><p><br></p><h3 id="Standalone-minion"><a href="#Standalone-minion" class="headerlink" title="Standalone minion"></a>Standalone minion</h3><p>因为<code>salt-minion</code>包含了如此广泛的功能，它可以独立运行。一个<code>standalone minion</code>可以用来做很多事情:</p><ul><li>在没有连接到<code>master</code>的系统上使用<code>salt-call</code>命令；</li><li>无主状态(masterless states)。</li></ul><p>当以无主模式运行salt时，不要运行<code>salt-minion daemon</code>。否则，它将尝试连接到master并失败。<br><code>salt-call</code>命令是独立的，不需要<code>salt-minion daemon</code>。</p><p><br></p><h4 id="minion-configuration"><a href="#minion-configuration" class="headerlink" title="minion configuration"></a>minion configuration</h4><p>有几个参考方法来设置不同的选项来配置<code>masterless minion</code>，<code>salt-minion</code>很容易通过配置文件(默认位于:<code>/etc/salt/minion</code>)进行配置。</p><p><br></p><p><strong>告诉salt运行masterless</strong></p><p><code>salt-call</code>命令用于在<code>salt-minion</code>本地运行模块功能，而不是在<code>salt-master</code>执行他们。通常，<code>salt-call</code>命令检查主机检索文件服务器和支柱数据，当时当运行<code>standalone salt-call</code>时，需要指示不要检查master的这些数据。<br>为了指示<code>minion</code>不要查找<code>master</code>，需要在运行<code>salt-call</code>时设置<code>file_client</code>配置选项。默认情况下，<code>file_client</code>被设置为<code>remote</code>让<code>minion</code>知道将从<code>master</code>中收集文件服务器和支柱数据。当设置<code>file_client</code>为<code>local</code>时，<code>minion</code>将不会从<code>master</code>收集这些数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">file_client:</span> <span class="string">local</span></div><div class="line"></div><div class="line"><span class="comment">#这样，salt-call命令将不会查找master</span></div><div class="line"><span class="comment">#并认为本地系统拥有所有的文件文支柱资源</span></div></pre></td></tr></table></figure><p><br></p><p><strong>masterless运行状态</strong></p><p>the state system在所有需要的文件都在<code>minion</code>本地，轻易地在没有<code>salt-master</code>的情况下运行。为了达到此效果，需要配置<code>minion</code>配置文件，以了解如何像<code>master</code>一样返回file_roots信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">file_roots:</span></div><div class="line"><span class="attr">  base:</span></div><div class="line"><span class="bullet">    -</span> <span class="string">/srv/salt</span></div></pre></td></tr></table></figure><p>现在设置salt state tree, top file和SLS modules，就像在<code>master</code>上设置它们一样。将<code>file_client</code>设置为<code>local</code>，并且一个可用的state tree会调用state module中的function，将使用<code>minion</code>上的file_roots中的信息而不是<code>master</code>。</p><p>当在一个<code>minion</code>上创建一个<code>state tree</code>时，不需要语法或路径的更改。<code>master</code>上的SLS modules不需要进行任何修改就可以与<code>minion</code>一起工作。这就使得salt scrit不需要设置一个<code>master</code>就能轻易部署，并允许这些SLS modules随着部署发展而容易转移到<code>master</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#以声明的状态可以执行</span></div><div class="line">salt-call state.apply</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#无需修改配置文件</span></div><div class="line">salt-call state.apply --<span class="built_in">local</span></div></pre></td></tr></table></figure><p><br></p><h3 id="Salt-masterless-quickstart"><a href="#Salt-masterless-quickstart" class="headerlink" title="Salt masterless quickstart"></a>Salt masterless quickstart</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SaltStack官网：&lt;a href=&quot;https://saltstack.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://saltstack.com&lt;/a&gt; ;&lt;/li&gt;
&lt;li&gt;SaltStack官方文档：&lt;a href=&quot;https://docs.saltstack.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.saltstack.com&lt;/a&gt; ;&lt;/li&gt;
&lt;li&gt;SaltStack-GitHub：&lt;a href=&quot;https://github.com/saltstack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/saltstack&lt;/a&gt; ;&lt;/li&gt;
&lt;li&gt;Salt-repo：&lt;a href=&quot;https://repo.saltstack.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://repo.saltstack.com/&lt;/a&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7_x64;&lt;/li&gt;
&lt;li&gt;Salt-2017.7.2&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="SaltStack" scheme="https://zhang21.github.io/tags/SaltStack/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://zhang21.github.io/2017/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://zhang21.github.io/2017/12/11/数据结构/</id>
    <published>2017-12-11T05:44:38.000Z</published>
    <updated>2017-12-12T01:56:29.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>在计算机科学中，<strong>数据结构(data structure)</strong>是计算机中存储、组织数据的方式。<br>大多数数据结构都有数列、记录、可辨识联合、引用等基本类型构成。</p><p>数据结构意味着结构和封装，一个数据结构可被视为两个函数之间的接口，或是由数据类型联合组成的存储内容的访问方法和封装。<br>数据结构可通过程序语言所提供的数据类型、引用及其它操作加以实现。不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计。<br>一个涉及良好的数据结构，应该尽可能使用较少的时间与空间资源的前提下，支持各种程序运行。</p><p>正确选择数据结构可以提高算法的效率，在计算机程序设计里，选择适当的数据结构是一项重要工作。</p><a id="more"></a><p><br></p><hr><h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><ul><li>数组(Array);</li><li>栈(Stack): 后进先出，线性表；</li><li>队列(Queue): 先进先出，线性表；</li><li>链表(Linked List): 每个节点包括两部分，一个存储数据元素的数据域，另一个存储下一个节点地址的指针域；</li><li>树(Tree)；</li><li>图(Graph)；</li><li>堆(Heap): 一种动态树形结构；</li><li>散列表(Hash)；</li></ul><p><br></p><hr><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><p>数组数据结构，是由相同类型的元素的集合所组成，分配一块连续的内存来存储。利用数组元素的索引(index)可计算出元素对应存储地址。</p><p>数组有 <strong>一维数组、二维数组、多维数组、可变长数组…</strong>。</p><p><br></p><hr><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h3><p>堆栈又称为栈，是计算机科学中一种特殊的串列形式的抽象资料类别。<br>其特殊之处在于只能允许在链接串列或阵列的一端(栈顶指标:top)，进行加入数据(push)和取出数据(pop)。</p><p>由于栈数据结构只允许在一端进行操作，因为按照后进先出(LIFO, last-in-first-out)的原理运行。</p><p><br></p><hr><h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h3><p>队列，是先进先出(FIFO, first-in-first-out)的线性表。在具体应用中通常用链表或数组来实现。<br>队列只允许在后端(Rear)进行插入操作，在前端(Front)进行删除操作。</p><p><br></p><hr><h3 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表(Linked List)"></a>链表(Linked List)</h3><p>链表是一种线性表，但并不按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。<br>由于不必须按顺序存储，链表再插入的时候可以达到 O(1)的时间复杂度，比另一种线性表顺序表快得多。但查找一个节点或访问特定节点则需要 O(n)的时间，而顺序表相应的时间复杂度分别是 O(logn)和O(1)。</p><p>是用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了节点的指针域，空间开销比较大。</p><p>链表有<strong>单向链表、双向链表、循环链表…</strong>。<br>链表用来构建许多其它数据结构，如栈，队列和他们的派生。</p><p><br></p><hr><h3 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树(Tree)"></a>树(Tree)</h3><p>树是一种抽象数据类型，用来模拟具有树状结构性质的数据集合。</p><p>树有<strong>有序树、无序树（二叉树，B树，霍夫曼树）</strong>。</p><p><br></p><hr><h3 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图(Graph)"></a>图(Graph)</h3><p>在数学上，一个图是表示物体与物体之间的关系的方法，是图论的基本研究对象。</p><p>图有：<strong>有向图、无向图、简单图、多重图</strong>。</p><p><br></p><hr><h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h3><p>堆是计算机科学中一类特殊的数据结构的统称。<br>堆通常是一个可以被看做一棵树的数组对象。在队列中，调度程序反复提取队列中的第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p><p>堆常用于排序，这种算法称作堆排序。</p><p><br></p><hr><h3 id="散列表-Hash"><a href="#散列表-Hash" class="headerlink" title="散列表(Hash)"></a>散列表(Hash)</h3><p>散列表也叫哈希表，是根据<strong>键(key)</strong>而直接访问在内存存储位置的数据结构。<br>它通过计算一个关于键值的函数，将所需查询的数据映射到表中的一个位置来访问记录，这加快了查找速度。这种映射函数称为散列函数，存放记录的数组称为散列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;在计算机科学中，&lt;strong&gt;数据结构(data structure)&lt;/strong&gt;是计算机中存储、组织数据的方式。&lt;br&gt;大多数数据结构都有数列、记录、可辨识联合、引用等基本类型构成。&lt;/p&gt;
&lt;p&gt;数据结构意味着结构和封装，一个数据结构可被视为两个函数之间的接口，或是由数据类型联合组成的存储内容的访问方法和封装。&lt;br&gt;数据结构可通过程序语言所提供的数据类型、引用及其它操作加以实现。不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计。&lt;br&gt;一个涉及良好的数据结构，应该尽可能使用较少的时间与空间资源的前提下，支持各种程序运行。&lt;/p&gt;
&lt;p&gt;正确选择数据结构可以提高算法的效率，在计算机程序设计里，选择适当的数据结构是一项重要工作。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Database" scheme="https://zhang21.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="https://zhang21.github.io/2017/12/11/MongoDB/"/>
    <id>https://zhang21.github.io/2017/12/11/MongoDB/</id>
    <published>2017-12-11T02:49:52.000Z</published>
    <updated>2018-02-10T09:58:05.182Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://docs.mongodb.com/" target="_blank" rel="noopener">MongoDB官方文档</a>;</li><li><a href="http://www.mongoing.com/docs" target="_blank" rel="noopener">MongoDB中文文档</a>;</li><li><a href="https://zh.wikipedia.org/wiki/MongoDB" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/MongoDB</a>;</li><li><a href="http://www.ywnds.com/?p=5635" target="_blank" rel="noopener">http://www.ywnds.com/?p=5635</a>;</li><li><a href="https://www.centos.bz/2017/08/mongodb-secure-intro-user-auth/" target="_blank" rel="noopener">https://www.centos.bz/2017/08/mongodb-secure-intro-user-auth/</a>;</li><li><a href="http://www.03sec.com/3176.shtml" target="_blank" rel="noopener">http://www.03sec.com/3176.shtml</a>;</li><li><a href="http://www.ywnds.com/?p=6502" target="_blank" rel="noopener">http://www.ywnds.com/?p=6502</a>;</li><li><a href="http://wiki.jikexueyuan.com/project/the-little-mongodb-book/" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/the-little-mongodb-book/</a>;</li></ul><p>环境：</p><ul><li>CentOS7_x64；</li><li>MongoDB3.4；</li></ul><a id="more"></a><p><br></p><hr><p><br></p><h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>NoSQL(Not Only SQL)是对不同于传统的<strong>关系型数据库</strong>的<strong>数据库管理系统(DBMS)</strong>的统称。<br>NoSQL不使用SQL作为查询语言，其数据结构可以不需要固定的表格模式，有横向可扩展性的特征。<br>NoSQL用于超大规模数据的存储，这些类型的数据存储不需要固定的模式，无序多余操作就可以横向扩展。</p><p><br><br>关系型数据库的典型实现主要被调整用于执行规模小而读写频繁，或大批量极少写访问的事务。<br>当代典型的关系型数据库在一些数据敏感的应用中表现了糟糕的性能。例如：</p><ul><li>为巨量文档创建索引；</li><li>高流量网站的网页服务；</li><li>发送流媒体。</li></ul><p><br><br>NoSQL数据库分类：</p><table><thead><tr><th>类型</th><th>栗子</th><th>特点</th></tr></thead><tbody><tr><td>文档存储</td><td>MongoDB</td><td>用类似json的格式存储，存储的内容是文档型的。这样就有机会对某些字段建立索引，实现关系数据库的某些功能</td></tr><tr><td>图形关系存储</td><td>Neo4j</td><td>图形关系的最佳存储</td></tr><tr><td>键-值(ker-value)存储</td><td>最终一致性的键-值存储 <br> 架构性键-值存储</td><td>xxx</td></tr><tr><td>主机式服务</td><td>key-value硬盘存储 <br> key-value RAM存储</td><td>MemcacheDB <br> Redis</td></tr><tr><td>多数据库</td><td>OpenQM</td><td>xxx</td></tr><tr><td>时序型数据库</td><td>Graphite</td><td>xxx</td></tr><tr><td>对象数据库</td><td>ObjecStore</td><td>通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据</td></tr><tr><td>列存储</td><td>HBase</td><td>顾名思义，按列存储数据。方便存储结构化和半结构化数据，方便做数据压缩，针对某一列或某几列的查询有很大的IO优势。</td></tr></tbody></table><p><br><br><br></p><hr><h1 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h1><p><br><br><img src="/images/MongoDB/MongoDB.jpeg" alt="MongoDB"></p><p>MongoDB(<a href="https://www.mongodb.com/" target="_blank" rel="noopener">https://www.mongodb.com/</a>)，是一种文档导向的数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。它是一种NoSQL。<br>MongoDB支持的数据结构非常松散，是类似于json的bson格式，因此可以存储比较复杂的数据类型。<br>MongoDB是一个开源文档数据库，提供高性能，高可用性和自动扩展。</p><p><br><br><strong>预备知识：</strong></p><ol><li>MongoDB中的<code>database</code>有和数据库一样的概念。一个MongoDB实例中，可以有零个或多个数据库，每个都作为一个高等容器，用于存储数据；</li><li>MongoDB数据库中有零个或多个<code>collections</code>(集合)。集合类似于传统意义上的<code>table</code>(表)；</li><li>MongoDB的集合是由零个或多个<code>documents</code>(文档)组成。文档类似于<code>row</code>(行)；</li><li>MongoDB的文档由零个或多个<code>fields</code>(字段)组成。字段类似于<code>columns</code>(列)；</li><li>MongoDB中<code>Indexes</code>(索引)扮演的角色与RDMS中一样；</li><li>MongoDB中的<code>Cursors</code>(游标)很重要，当你向MongoDB取数据的时候，它会给你返回一个结果集的指针而不是真正的数据，这个指针我们叫它游标。我们可以用游标做任何事情，比如计数或跨行之类。</li></ol><p><br></p><h2 id="MongoDB特点"><a href="#MongoDB特点" class="headerlink" title="MongoDB特点"></a>MongoDB特点</h2><p>不如这样认为，MongoDB是关系型数据库的一个代替案。比如用<code>Lucene</code>作为关系型数据库的全文检索索引的加强，或者是<code>Redis</code>作为持久性<code>key-value</code>存储。</p><p><strong>无模式(Flexible Schema)</strong>：<br>它不需要一个固定的模式，这使得他们比传统的数据库表要灵活更多。</p><p><br><br><strong>写操作(Writes)</strong>：<br>MongoDB可以胜任的一个特殊角色是在日志领域。有两点使得MongoDB的写操作非常快：</p><ol><li>可以选择发送了写操作之后立刻返回，而无需等到操作完成；</li><li>可以控制数据持久性的写行为。</li></ol><p><br><br><strong>高性能(High Performance)</strong>：<br>MongoDB提供了高性能的数据持久性。尤其是：</p><ul><li>对嵌入式数据模型的支持减少了数据库系统上的I/O活动；</li><li>索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。</li></ul><p><br><br><strong>高可用(High Availability)</strong>：<br>MongoDB的复制工具，称为副本集。提供：自动故障转移和数据冗余。</p><p><br><br><strong>持久性(Durability)</strong>：<br>在MongoDB中，日志(Journaling)是默认启动的，该功能允许快速恢复服务器，比如遭遇到了服务器奔溃或停电的问题。</p><p><br><br><strong>丰富的查询语言(Rich Query Language)</strong>：<br>MongoDB支持丰富的查询语言来支持读写操作(CRUD)，数据聚合(Data Aggregation)，全文搜索(Text Search)。</p><p><br><br><strong>水平可伸缩性(Horizontal Scalability)</strong>：<br>MongoDB提供了横向可伸缩性。</p><p><br><br><strong>支持多个存储引擎(Support for Multiple Storage Engines)</strong>：<br>在MongoDB3.2以后默认引擎为: WiredTiger Storage Engine，允许第三方为MongoDB开发存储引擎。</p><p><br></p><h2 id="database和collection"><a href="#database和collection" class="headerlink" title="database和collection"></a>database和collection</h2><p>MongoDB stores BSON documents.</p><p><img src="/images/MongoDB/collection.png" alt="collection"></p><p><br></p><h3 id="databases"><a href="#databases" class="headerlink" title="databases"></a>databases</h3><p>In MongoDB,databases hold collections of documents.<br>如果一个数据库不存在，当你第一次存储数据时，MongoDB会自动创建数据库。这意味着可以切换到不存在的数据库。</p><p>默认情况下，集合不要求其文档具有相同的模式；文档不要求具有相同的字段集；字段的数据类型在集合的文档间可以有所不同。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#select a db</span></div><div class="line">use &lt;db&gt;</div><div class="line"></div><div class="line"><span class="comment">#create a db</span></div><div class="line">use newdb</div><div class="line">db.newcoll.insert(&#123;name:<span class="string">'zhang'</span>&#125;)</div><div class="line">db.newcoll.insert(&#123;filed01:<span class="string">'filed01'</span>, filed02:<span class="string">'filed02'</span>, filed03:<span class="string">'filed03'</span>, filed04:<span class="string">'filed04'</span>&#125;)</div><div class="line">db.newcoll.insert(&#123;groups: [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]&#125;)</div><div class="line">db.newcoll.find().pretty()</div></pre></td></tr></table></figure><p><br></p><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><p>MongoDB stores documents in collections.<br>collection类似于关系型数据库中的table。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.coll02.insert(&#123;x:1&#125;)</div><div class="line">db.coll03.createIndex(&#123;y:1&#125;)</div></pre></td></tr></table></figure><p><br></p><h3 id="显式创建-explicit-creation"><a href="#显式创建-explicit-creation" class="headerlink" title="显式创建(explicit creation)"></a>显式创建(explicit creation)</h3><p>MongoDB提供了<code>db.createCollection()</code>方法来显式创建一个附带各种选项的集合。如设置document最大大小，文件验证规则等选项。<br>如果不需要指定这些选项，就不需要使用显式创建集合，而直接向集合中插入数据即可。<br>修改collection选项，使用<code>collMod</code>方法。</p><p><br></p><h3 id="视图-View"><a href="#视图-View" class="headerlink" title="视图(View)"></a>视图(View)</h3><p>视图的定义是公开的，视图的解释操作将包括定义视图的管道。因此，避免直接引用视图定义中的敏感字段和值。</p><p><strong>创建/删除视图：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">db.runCommand(</div><div class="line">&#123;</div><div class="line">crete: &lt;view&gt;,</div><div class="line">viewOn: &lt;<span class="built_in">source</span>&gt;,</div><div class="line">pipeline: &lt;pipeline&gt;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">db.createView(&lt;view&gt;, &lt;<span class="built_in">source</span>&gt;, &lt;pipeline&gt;, &lt;collation&gt;)</div><div class="line"></div><div class="line">db.collection.drop()</div></pre></td></tr></table></figure><p><br><br><strong>视图行为：</strong></p><p>视图存在以下行为：</p><ul><li>视图只读，视图上的写操作将会出错；</li><li>视图使用底层集合的索引；</li><li>如果视图的基础集合被分割，视图也被认为可分割；</li><li>不能重命名视图；</li><li>视图上的字符串使用视图的默认排序规则。</li></ul><p><br></p><h3 id="限制集"><a href="#限制集" class="headerlink" title="限制集"></a>限制集</h3><p>限制集是固定大小的集合支持基于文档插入顺序的高吞吐率的插入、检索、删除操作。<br>限制收集工作在某种程度上类似于循环缓冲区：一旦一个文档填满分配给它的空间，它将通过在限制集中重写老文档来给新文档让出空间。</p><p><br></p><h4 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h4><p><strong>插入顺序</strong><br>限制集合能够保留插入顺序。因此，查询并不需要索引来保证以插入顺序来返回文档。减少了索引的消耗，限制集可以支持更高的插入吞吐量。</p><p><strong>最旧文档的自动删除</strong><br>为了给新文档腾出空间，再不需要脚本或显示删除操作的前提下，限制集自动删除集合中最旧的文档。</p><p>例如replication set中的oplog.rs集合。考虑潜在用于集合封顶的用例：</p><ul><li>存储高容量系统生成的日志信息。没有索引的情况下向限制集中插入文档的速度接近于直接在文件系统中写日志的速度；</li><li>在限制集中缓存少量的数据。</li></ul><p><strong>_id索引</strong><br>限制集合有一个_id字段并且默认在_id字段上创建索引。</p><p><br></p><h4 id="限制和建议"><a href="#限制和建议" class="headerlink" title="限制和建议"></a>限制和建议</h4><p><strong>更新</strong><br>更新限制集中的文档，创建一个索引保证这些更新操作不需要进行集合扫描。</p><p><strong>文档大小</strong><br>一个更新或替换操作改变了文档大小，操作将会失败。</p><p><strong>文档删除</strong><br>不能从一个限制集中删除文档！<br>为了从一个集合中删除所有文档，使用<code>drop()</code>方法来删除集合然后重新创建限制集。</p><p><strong>分片</strong><br>不能对限制集分片。</p><p><strong>查询效率</strong><br>用自然顺序监视限制集中大部分最近插入的文档。</p><p><br></p><h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><p><strong>创建一个限制集</strong><br>必须使用<code>db.createCollection()</code>方法创建限制集。且必须指定<strong>以字节为单位</strong>的最大集合大小。MongoDB将会预先分配集合。<br>另外，可为限制集指定最大文档数据，用<code>max</code>字段。</p><p>大小参数是必须的。MongoDB会在达到最大限制前删除旧的文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use &lt;db&gt;</div><div class="line"></div><div class="line"><span class="comment">#限制集大小</span></div><div class="line">db.createCollection(<span class="string">"log"</span>, &#123;capped: <span class="literal">true</span>, size: 1000000&#125;)</div><div class="line"></div><div class="line"><span class="comment">#限制集和文档大小</span></div><div class="line">db.createCollection(<span class="string">"log"</span>, &#123;capped: <span class="literal">true</span>, size: 5242880, max: 5000&#125;)</div></pre></td></tr></table></figure><p><strong>查询一个限制集</strong><br>如果没有对限制集指定排序，则MongoDB的结果顺序和插入顺序相同。</p><p><strong>检查一个集合是否是限制集</strong><br><code>isCapped()</code>方法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.collection.isCapped()</div><div class="line"><span class="comment">#db.coll01.isCapped()</span></div><div class="line"><span class="comment">#false</span></div></pre></td></tr></table></figure><p><strong>将集合转换为限制集</strong><br><code>convertToCapped()</code>方法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.runCommand(&#123;<span class="string">"covertToCapped"</span>: <span class="string">"coll01"</span>, size: 1000000&#125;);</div><div class="line"><span class="comment">#db.coll01.isCapped()</span></div><div class="line"><span class="comment">#true</span></div></pre></td></tr></table></figure><p><strong>在规定的时间周期之后将自动移除数据</strong><br>通过设置MongoDB的TTL时集合中的数据过期。<br>TTL collection与限制集不兼容。</p><p><strong>Tailable游标</strong><br>类似于Unix中的<code>taif -f</code></p><p><br><br><br></p><h2 id="document"><a href="#document" class="headerlink" title="document"></a>document</h2><p>MongoDB存储数据记录为BSON文档。<br>BSON是JSON文档的二进制表示，因此它包含比JSON更多的数据类型。</p><p><br></p><h3 id="document-structure"><a href="#document-structure" class="headerlink" title="document structure"></a>document structure</h3><p>MongoDB字段由key-value对组成。<br>字段值可以是任一BSON数据类型，包括其他文档，数组，阵列。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">filed1: value1;</div><div class="line">filed2: value2;</div><div class="line">    ...</div><div class="line">    filedN: valueN</div><div class="line">&#125;g</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#data type</span></div><div class="line">var mydoc =&#123;</div><div class="line">_id: ObjectId(<span class="string">"5099803df3f4948bd2f98391"</span>),</div><div class="line">name: &#123; first: <span class="string">"Alan"</span>, last: <span class="string">"Turing"</span> &#125;,</div><div class="line">birth: new Date(<span class="string">'Jun 23, 1912'</span>),</div><div class="line">death: new Date(<span class="string">'Jun 07, 1954'</span>),</div><div class="line">contribs: [ <span class="string">"Turing machine"</span>, <span class="string">"Turing test"</span>, <span class="string">"Turingery"</span> ],</div><div class="line">views : NumberLong(1250000)</div><div class="line">&#125;</div><div class="line"></div><div class="line">_id是ObjectID；</div><div class="line">name是嵌入式文档；</div><div class="line">birth是日期类型；</div><div class="line">contribs是字符串数组；</div><div class="line">view是NumberLong类型。</div></pre></td></tr></table></figure><p><strong>字段名(field name)</strong><br>字段名是字符串。<br>document对field name有以下限制:</p><ul><li>字段名称<code>_id</code>保留用作主键(primary key)，它的值在collection中必须唯一，不可变。它的类型可以是数组外的任何类型；</li><li>字段名称不能以<code>$</code>字符开头；</li><li>字段名称不能包含<code>.</code>字符；</li><li>字段名称不能包含<code>null</code>字符。</li></ul><p>BSON documents 可能有多个字段名称相同的字段。然而，大多数的MongoDB Interface，MongoDB结构（如hash表），并不支持重复字段名称。<br>如果需要操作具有多个相同名称字段的文档，请参考 mongo driver。</p><p>一些由内部MongoDB进程创建的documents可能会有重复的字段，但是没有MongoDB进程会向一个已经存在的user document中添加重复字段。</p><p><strong>字段值限制(field value limit)</strong><br>For <code>indexed collections</code>，indexed fields的值有一个最大索引值长度限制(maximum index key length)。</p><p><br></p><h3 id="圆点表示法-dot-notation"><a href="#圆点表示法-dot-notation" class="headerlink" title="圆点表示法(dot notation)"></a>圆点表示法(dot notation)</h3><p>MongoDB使用圆点表示法来访问数组中的元素，访问嵌套文档中的字段。</p><p><strong>数组(array)</strong><br>通过基于0的索引位置来指定或访问数组中的元素。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;array&gt;.&lt;index&gt;</div><div class="line"></div><div class="line">&#123;</div><div class="line">contribs: [ <span class="string">'Turing machine'</span>, <span class="string">'Turing test'</span>, <span class="string">'Turingery'</span> ]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#contribs.0 == 'Turing machine'</span></div><div class="line"><span class="comment">#contribs.1 == 'Turing test'</span></div><div class="line"><span class="comment">#contribs.2 == 'Turingery'</span></div></pre></td></tr></table></figure><p><strong>嵌套文档(embedded documents)</strong><br>通过圆点表示法来指定或访问嵌套文档中的字段。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;embedded document&gt;.&lt;field&gt;</div><div class="line"></div><div class="line">&#123;</div><div class="line">name: &#123; first: <span class="string">'AAA'</span>, last: <span class="string">'ZZZ'</span>&#125;,</div><div class="line">    contact: &#123; phone: &#123; <span class="built_in">type</span>: <span class="string">'cell'</span>, number: <span class="string">'1-22-333'</span> &#125;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#name.first == 'AAA'</span></div><div class="line"><span class="comment">#contact.phone.number == '1-22-333'</span></div></pre></td></tr></table></figure><p><br></p><h3 id="文档限制-document-limitation"><a href="#文档限制-document-limitation" class="headerlink" title="文档限制(document limitation)**"></a>文档限制(document limitation)**</h3><p><strong>文档大小限制(size limit)</strong><br>BSON document最大size为：16MB。</p><p>最大document size确保一个单一document不能使用过量的RAM，或是传输期间的过量带宽。<br>MongoDB提供了<code>GridFS API</code>，用来保存超过最大size的文档。</p><p><strong>文档字段序列(field order)</strong><br>MongoDB用write operation来作为document的序列，除了一下情况：</p><ul><li><code>_id</code>字段总是document中的第一个field；</li><li>包含重命名的<code>update</code>操作，会导致document中的field重新排序。</li></ul><p><strong>_id字段</strong><br>在MongoDB中，每个保存在collection中的document都要求一个唯一的<code>_id</code>，用以担任主键(primary key)。<br>如果向document中<code>insert</code>数据是忽略的<code>_id</code>字段，则MongoDB driver会为<code>_id字段</code>自动生成一个ObjectID。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#默认生成_id</span></div><div class="line">db.coll01.insert(&#123;name: <span class="string">'zhang'</span>, sex: <span class="string">'man'</span>, hobby: <span class="string">'woman'</span>&#125;)</div><div class="line"><span class="comment"># "_id" : ObjectId("5a32166ebf2c986e8106f891")</span></div><div class="line"></div><div class="line"><span class="comment">#自定义_id</span></div><div class="line">db.coll01.insert(&#123;_id:<span class="string">'ZhangCustomDefine'</span>, name:<span class="string">'zhang'</span>, sex: <span class="string">'man'</span>, arr: [0, 1, 2, 3], emmdoc: &#123;emm01:<span class="string">'Emm01'</span>, emm02: <span class="string">'Emm02'</span>, emm03: <span class="string">'Emmo3'</span>&#125;&#125;)</div><div class="line"><span class="comment">#"_id" : "ZhangCustomDefine"</span></div></pre></td></tr></table></figure><p><code>_id字段</code>有以下行为和约束：</p><ul><li>默认情况下，MongoDB在collection创建document时，会创建一个唯一的<code>_id</code>作为索引；</li><li><code>_id字段</code>总是document中的第一个字段。如果server接受的document中<code>_id</code>不在第一个字段，那么Server会移动<code>_id</code>到第一个字段；</li><li><code>_id</code>字段的数据类型除了数组外的任意BSON 数据类型；</li><li>不要存储BSON正则表达式的类型在<code>_id</code>字段中。</li></ul><p><code>_id</code>字段值的常用选项：</p><ul><li>使用ObjectId；</li><li>使用了自然唯一的标识符，节省了空间并避免了额外的索引；</li><li>生成一个自动递增的数字；</li><li>在应用程序代码中生成UUID；</li></ul><p><br></p><h3 id="文档结构的其他用途"><a href="#文档结构的其他用途" class="headerlink" title="文档结构的其他用途"></a>文档结构的其他用途</h3><p><strong>查询过滤文档(query filter)</strong><br>使用<key>:<value>表达式来指定条件。</value></key></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&lt;field1&gt;: &lt;value1&gt;</div><div class="line">    &lt;field2&gt;: &lt;value2&gt;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>更新特定文档(update)</strong><br>使用<code>db.collection.update()</code>操作更新数据。</p><p><br><br><br></p><h2 id="BSON类型"><a href="#BSON类型" class="headerlink" title="BSON类型"></a>BSON类型</h2><p>BSON是一个用来存储document和MongoDB进行远程调用的二进制序列化格式。<br>BSON支持一下数据类型作为文档中的值。每个数据类型都有一个相应的数字和字符串别名，可与$type操作符一起使用，以便按照bson类型查询文档。</p><table><thead><tr><th>Type</th><th>Number</th><th>Alias</th></tr></thead><tbody><tr><td>double</td><td>1</td><td>“double”</td></tr><tr><td>字符串</td><td>2</td><td>“string”</td></tr><tr><td>对象</td><td>3</td><td>“object”</td></tr><tr><td>数组</td><td>4</td><td>“array”</td></tr><tr><td>二进制数据</td><td>5</td><td>“binData”</td></tr><tr><td>未定义</td><td>6</td><td>“undefined”</td></tr><tr><td>ObjectId</td><td>7</td><td>“objectId”</td></tr><tr><td>Boolean</td><td>8</td><td>“bool”</td></tr><tr><td>日期</td><td>9</td><td>“date”</td></tr><tr><td>空</td><td>10</td><td>“null”</td></tr><tr><td>正则表达式</td><td>11</td><td>“regex”</td></tr><tr><td>DBPointer</td><td>12</td><td>“dbPointer”</td></tr><tr><td>JavaScript</td><td>13</td><td>“javascript”</td></tr><tr><td>符号</td><td>14</td><td>“symbol”</td></tr><tr><td>JavaScript(带范围)</td><td>15</td><td>“javascriptWithScope”</td></tr><tr><td>32位整数</td><td>16</td><td>“int”</td></tr><tr><td>时间戳</td><td>17</td><td>“timestamp”</td></tr><tr><td>64位整数</td><td>18</td><td>“long”</td></tr><tr><td>Decimal128</td><td>19</td><td>“decimal”</td></tr><tr><td>Min key</td><td>-1</td><td>“minKey”</td></tr><tr><td>Max key</td><td>127</td><td>—</td></tr></tbody></table><p>如果你想要将BSON转换为JSON，参考Extended JSON。</p><p><br></p><h3 id="ObjectId"><a href="#ObjectId" class="headerlink" title="ObjectId"></a>ObjectId</h3><p>ObjcetIds are small, likely unique, fast to generate, and ordered.<br>ObjectIds有12个字节组成，其中前4个字节是反映ObjectId创建的时间戳(timestamp)。</p><ul><li>一个4字节的值，代表从Unix纪元开始的秒数；</li><li>一个3字节的机器标识符；</li><li>日期对象排在时间戳对象之前；</li><li>MongoDB在比较过程中，会把一些类型看成相等。</li></ul><p>栗子：<code>{ &quot;_id&quot; : ObjectId(&quot;5a33354068b6c5e5fb6f213f&quot;), &quot;name&quot; : &quot;ZHANG&quot; }</code>。</p><p>在mongo shell中，可以访问ObjectId的创建时间，使用<code>ObjectId.getTimestamp()</code>方法。<br>在<code>_id</code>字段中存储的ObjectId值的排序，大致相当于按其创建时间排序。<br>ObjectId的值顺序与生成时间之间并不严格。</p><p><br></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>BSON字符串都是UTF-8编码。一般来说，每种编程语言的驱动程序在序列化和反序列化BSON的时候，都会从语言的字符串形式转化为UTF-8。这就使得使用BSON字符串简单存储大多数国际字符变为可能。</p><p><br></p><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>BSON有一个特殊的时间戳类型用于MongoDB内部使用，与普通的日期类型无关。而在应用开发中可使用BSON日期类型。<br>时间戳值是一个64位的值： 前32位是与Unix纪元相差的秒数，后32位是在某秒总操作的一个递增的序列数。</p><p>在MongoDB复制集中，<code>oplog</code>有一个ts字段。这个字段的值使用BSON时间戳表示了操作时间。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.coll02.insert( &#123; ts: new Timestamp() &#125; )</div><div class="line"></div><div class="line">db.coll02.find()</div><div class="line"><span class="comment">#&#123; "_id" : ObjectId("5a333e3f68b6c5e5fb6f2141"), "ts" : Timestamp(1513307711, 1) &#125;</span></div></pre></td></tr></table></figure><p><br></p><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p>BSON日期是一个64位整数，表示利当前Unix新纪元(1970.01.01)的毫秒数，可到未来的2.9亿年。<br>BSON日期类型是有符号的，负数表示1970年之前的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var date1 = new Date()</div><div class="line">var date2 = ISODate()</div><div class="line"></div><div class="line">#date1</div><div class="line">#date2</div><div class="line">#ISODate(&quot;2017-12-15T03:28:08.227Z&quot;)</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="MongoDB-Extended-JSON"><a href="#MongoDB-Extended-JSON" class="headerlink" title="MongoDB Extended JSON"></a>MongoDB Extended JSON</h2><p>JSON只能表示BSON类型的一个子集。为了保留类型信息，MongoDB对JSON格式添加了如下扩展性：</p><ul><li>Strict mode： Any JSON parser can parse these strict mode representations as key/value pairs;</li><li>mongo shell mode： The MongoDB internal JSON parser and the mongo shell can parse this mode.</li></ul><p>多种数据类型的表示取决于JSON解析的上下文！</p><p><br></p><h3 id="解析器-parser-和支持的格式-format"><a href="#解析器-parser-和支持的格式-format" class="headerlink" title="解析器(parser)和支持的格式(format)"></a>解析器(parser)和支持的格式(format)</h3><p><strong>Input in Strict mode</strong><br>如下可在严格模式下被解析并识别类型信息。</p><ul><li>REST Interface;</li><li>mongo import;</li><li>–query;</li><li>MongoDB Compass.</li></ul><p><br><br><strong>Input in mongo shell mode</strong><br>如下可在严格模式下被解析并识别类型信息。</p><ul><li>REST Interface;</li><li>mongo import;</li><li>–query;</li><li>MongoDB Compass.</li></ul><p><br><br><strong>Output in Strict mode</strong><br><code>mongoexport</code>, REST, HTTP Interfaces.</p><p><br><br><strong>Output in mongo shell mode</strong><br><code>bsondump</code>.</p><p><br></p><h3 id="BSON数据类型和关联表示"><a href="#BSON数据类型和关联表示" class="headerlink" title="BSON数据类型和关联表示"></a>BSON数据类型和关联表示</h3><p><strong>Binary</strong></p><table><thead><tr><th>Strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$binary”: “<bindata>“, “$type”: “<t>“ }</t></bindata></td><td>BinData ( <t>, <bindata> )</bindata></t></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;bindata&gt;是二进制base64表示；</div><div class="line">&lt;t&gt;是由单字节的数据类型表示。</div></pre></td></tr></table></figure><p><br><br><strong>Date</strong></p><table><thead><tr><th>Strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$date”: “<date>“ }</date></td><td>new Date ( <date> )</date></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In Strict mode, &lt;date&gt;是 ISO-8601的日期格式的时区字段，类型如**YYYY-MM-DDTHH:mm:ss.mm&lt;+/-offset&gt;;</div><div class="line">MongoDb JSON解析器目前暂不支持载入ISO-8601日期类型。</div></pre></td></tr></table></figure><p><br><br><strong>Timestamp</strong></p><table><thead><tr><th>Strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$timestamp” ; { “t”: <t>, “i” } }</t></td><td>Timestamp( <t>, <i> )</i></t></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;t&gt;是32位无符号整数的JSON表现形式；</div><div class="line">&lt;i&gt;是增量的32位无符号整数。</div></pre></td></tr></table></figure><p><br><br><strong>Regular Expression</strong></p><table><thead><tr><th>Strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$regex”: <sregex>, “$options”: “<soptions>“ }</soptions></sregex></td><td>/<jregex>/<joptions></joptions></jregex></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;sRegex&gt;是有效地JSON字符串；</div><div class="line">&lt;jRegex&gt;是一个可能包含有效的JSON字符和未转义的双引号(&quot;)，但可能不包括未转义的斜杠(/)字符；</div><div class="line">&lt;sOptions&gt;是一个正则表达式选项；</div><div class="line">&lt;jOptions&gt;是一个只能包含字符&quot;g&quot;, &quot;i&quot;, &quot;m&quot;, &quot;s&quot;的字符串。</div></pre></td></tr></table></figure><p><br><br><strong>OID</strong></p><table><thead><tr><th>Strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$oid”: “<id>“ }</id></td><td>ObjectId( “<id>“ )</id></td></tr></tbody></table><p><code>&lt;id&gt;是一个24字符的十六进制(hexadecimal)字符串</code></p><p><br><br><strong>DB Reference</strong></p><table><thead><tr><th>strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$ref”: “<name>“, “$id”: “<id>“ }</id></name></td><td>DBRef(“<name>“, “<id>“)</id></name></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;name&gt;是一个有效的JSON字符；</div><div class="line">&lt;id&gt;是任一extended JSON type。</div></pre></td></tr></table></figure><p><br><br><strong>Undefined Type</strong></p><table><thead><tr><th>strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{  “$undefined”: true }</td><td>undefined</td></tr></tbody></table><p><br><br><strong>MinKey/MaxKey</strong></p><table><thead><tr><th>strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$minkey”: 1 }</td><td>MinKey</td></tr><tr><td>{ “$maxkey”: 1 }</td><td>MaxKey</td></tr></tbody></table><p><br><br><strong>NumberLong</strong></p><table><thead><tr><th>strict mode</th><th>mongo shell mode</th></tr></thead><tbody><tr><td>{ “$numberLong”: “<number>“ }</number></td><td>NumberLong( “number&gt;” )</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Number是一个64位有符号整数。必须使用&quot;，否则它将被解释为浮点数，从而导致损失精度；</div><div class="line">db.json.insert&#123;&#123; longquoted: NumberLong(&quot;12345678901234345&quot;) &#125;)</div></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="MongoDB安装"><a href="#MongoDB安装" class="headerlink" title="MongoDB安装"></a>MongoDB安装</h1><p>参考:</p><ul><li><a href="https://docs.mongodb.com/manual/administration/install-on-linux/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/administration/install-on-linux/</a>;</li><li><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</a>;</li></ul><p>MongoDB有社区版(Community)和企业版(Enterprise)。社区版免费，企业版在商业方面收费。</p><p><br><br>MongoDB在仓库中提供官方支持的包，包含以下软件包：</p><table><thead><tr><th>Package</th><th>Description</th></tr></thead><tbody><tr><td>monogdb-org</td><td>将自动安装下面四个组件包</td></tr><tr><td>mongodb-org-server</td><td>包含<code>mongod</code>守护进程和相关配置和<code>init</code>脚本</td></tr><tr><td>mongodb-org-mongos</td><td>包含<code>mongos</code>守护进程</td></tr><tr><td>mongodb-org-shell</td><td>包含<code>mongo-shell</code></td></tr><tr><td>mongodb-org-tools</td><td>包含相关MongoDB工具，如<code>mongoimport</code>,<code>mongoexport</code>,<code>mongodump</code>,<code>mongorestore</code>…</td></tr></tbody></table><p><code>mongodb-org-server</code>包提供了一个<code>/etc/mongod.conf</code>配置文件来开始和初始化<code>mongod</code>。默认配置文件默认bind_ip为 <code>127.0.0.1</code>，当你有需要和副本集时请修改它。</p><p><br></p><h2 id="自建mongodb-repo仓库安装"><a href="#自建mongodb-repo仓库安装" class="headerlink" title="自建mongodb.repo仓库安装"></a>自建mongodb.repo仓库安装</h2><p>仓库地址：<a href="https://repo.mongodb.org" target="_blank" rel="noopener">https://repo.mongodb.org</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">vim /etc/yum.repos.d/mongodb34.repo</div><div class="line"><span class="comment">#编辑仓库</span></div><div class="line"></div><div class="line"></div><div class="line">[mongodb34]</div><div class="line">name=MongoDB34 Repository</div><div class="line">baseurl=https://repo.mongodb.org/yum/redhat/<span class="variable">$releasever</span>/mongodb-org/3.4/x86_64/</div><div class="line">gpgcheck=0</div><div class="line">enabled=1</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#安装mongodb</span></div><div class="line">yum install -y mongodb-org</div></pre></td></tr></table></figure><p><br></p><h2 id="下载rpm包安装"><a href="#下载rpm包安装" class="headerlink" title="下载rpm包安装"></a>下载rpm包安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /root/mongodb</div><div class="line">wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/3.4/x86_64/RPMS/mongodb-org-3.4.10-1.el7.x86_64.rpm</div><div class="line">wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/3.4/x86_64/RPMS/mongodb-xxx-3.4.10-1.el7.x86_64.rpm</div><div class="line"><span class="comment">#共五个包</span></div><div class="line"></div><div class="line"></div><div class="line">yum ./mongo-org*</div></pre></td></tr></table></figure><p><br></p><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.0.tgz</div><div class="line"></div><div class="line">tar -axvf mongodb-linux-x86_64-rhel70-3.6.0.tgz -C ./</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#默认路径/usr/local</span></div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure><p><br></p><h2 id="开启mongodb"><a href="#开启mongodb" class="headerlink" title="开启mongodb"></a>开启mongodb</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#默认启动方式</span></div><div class="line">systemctl start mongod</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定配置文件启动</span></div><div class="line"><span class="comment">#注意修改配置文件里面的某些路径和名称，不然会和默认配置文件冲突</span></div><div class="line">mongod -f /etc/mongo_27018.conf</div><div class="line">mongod -f /etc/mongo_27019.conf</div><div class="line">``</div><div class="line"></div><div class="line"></div><div class="line">&lt;br&gt;</div><div class="line"><span class="comment">## 卸载mongodb</span></div><div class="line"></div><div class="line">```sh</div><div class="line">systemctl stop mongod</div><div class="line"></div><div class="line">yum remove $(rpm -qa | grep mongodb-org)</div><div class="line"></div><div class="line">rm -rf /var/<span class="built_in">log</span>/mongodb</div><div class="line">rm -rf /var/dbpath/mongo</div></pre></td></tr></table></figure><h2 id="mongodb异常关闭后"><a href="#mongodb异常关闭后" class="headerlink" title="mongodb异常关闭后"></a>mongodb异常关闭后</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#首先查看日志文件</span></div><div class="line">tail /var/<span class="built_in">log</span>/mongodb/mongod.log</div><div class="line"></div><div class="line"><span class="comment">#删除</span></div><div class="line">rm /var/run/mongodb/mongod.pid /var/db/mongodb/mongod.lock</div></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="MongoDB配置文件"><a href="#MongoDB配置文件" class="headerlink" title="MongoDB配置文件"></a>MongoDB配置文件</h1><p>MongoDB的配置文件格式使用了YAML格式。<br><a href="https://zh.wikipedia.org/wiki/YAML" target="_blank" rel="noopener">YAML维基百科</a>，Yet Another Markup Language。强调以数据为中心，而不是标记语言为重点，用方向缩略语重命名。</p><p><br><br>默认配置文件<code>/etc/mongod.conf</code> 的几个大块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">systemLog:        #日志</div><div class="line"></div><div class="line">storage:          #存储</div><div class="line"></div><div class="line">processManagement:        #进程管理</div><div class="line"></div><div class="line">net:        #网络</div><div class="line"></div><div class="line">security:        #安全</div><div class="line"></div><div class="line">operationProfiling:        #性能分析器</div><div class="line"></div><div class="line">replication:        #主从复制</div><div class="line"></div><div class="line">sharding:        #架构</div><div class="line"></div><div class="line">setParameter:        #自定义变量</div><div class="line"></div><div class="line">auditLog:        #检测日志</div><div class="line"></div><div class="line">snmp:        #简单网络管理协议</div></pre></td></tr></table></figure><p><br></p><h2 id="systemLog"><a href="#systemLog" class="headerlink" title="systemLog"></a>systemLog</h2><p>日志相关参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">systemLog:</div><div class="line">  verbosity: &lt;int&gt;                #日志级别，默认0,1-5均会包含debug信息</div><div class="line">  quiet: &lt;boolean&gt;                #安静，true时mongod将会减少日志的输出量</div><div class="line">  traceAllExceptions: &lt;boolean&gt;        #打印异常详细信息</div><div class="line">  syslogFacility:  &lt;string&gt;                #指定用于登录时信息到syslog Facility水平，前提是启用syslog</div><div class="line">  path:  &lt;string&gt;          #日志路径，默认情况下，MongoDB将覆盖现有的日志文件</div><div class="line">  logAppend: &lt;boolean&gt;        #mongod重启后，在现有日志后继续添加日志，否则备份当前日志，然后创建新日志</div><div class="line">  logRotate: rename|reopen        #日志轮询，防止一个日志文件特别大。rename重命名日志文件，默认值；reopen使用Linuxrotate特性，关闭并重新打开日志文件，前提为logAppend: true</div><div class="line">  destination: &lt;string&gt;        #日志输出目的地，可为file或syslog，若不指定，则会输出到 std out</div><div class="line">  timeStampFormat: &lt;string&gt;        #指定日志格式的时间戳，有 ctime, Iso869-utc, iso8691-local</div><div class="line">  component:            #为不同的组件指定各自的日志信息级别</div><div class="line">      accessControl:</div><div class="line">          verbosity: &lt;int&gt;</div><div class="line">      command:</div><div class="line">          verbosity: &lt;int&gt;</div></pre></td></tr></table></figure><p><br></p><h2 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h2><p>存储引擎相关参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">storage:</div><div class="line">  dbPath: &lt;string&gt;        #mongodb进程存储数据目录，此配置进队此mongod进程有效，你使用配置文件开启的mongod就可以指定额外的数据目录</div><div class="line">  indexBuildRetry:  &lt;boolean&gt;        #当构件索引时mongod意外关闭，那么在此启动是否重建索引，默认true</div><div class="line">  repairPath: &lt;string&gt;        #在repair期间使用此目录存储临时数据，repair结束后此目录下数据将被删除</div><div class="line">  journal:</div><div class="line">      enabled: &lt;boolean&gt;        #journal日志持久存储，journal日志用来数据恢复，通常用于故障恢复，建议开启</div><div class="line">      commitIntervalMs: &lt;num&gt;        #mongod日志刷新值，范围1-500毫秒，默认100，不建议修改</div><div class="line">  directoryPerDB:  &lt;boolean&gt;        #是否将不同的数据存储在不同的目录中，dbPath子目录</div><div class="line">  syncPeriodSecs:  &lt;int&gt;        #fsync操作将数据flush到磁盘的时间间隔，默认为60秒，不建议修改</div><div class="line">  engine:  &lt;string&gt;        #存储引擎</div><div class="line"></div><div class="line">  mmapv1:    #mmapv1存储引擎，3.2前默认</div><div class="line">      preallocDataFiles:  &lt;boolean&gt;</div><div class="line">      nsSize: &lt;int&gt;</div><div class="line">      quota:</div><div class="line">          enforced: &lt;boolean&gt;</div><div class="line">          maxFilesPerDB: &lt;int&gt;</div><div class="line">      smallFiles: &lt;boolean&gt;</div><div class="line">      journal:</div><div class="line">          debugFlags: &lt;int&gt;</div><div class="line">          commitIntervalMs: &lt;num&gt;</div><div class="line">  wiredTiger:    #WiredTiger存储引擎，3.2后默认</div><div class="line">      engineConfig:</div><div class="line">          cacheSizeGB: &lt;number&gt;    #最大缓存大小</div><div class="line">          journalCompressor: &lt;string&gt;    #日志压缩算法，可选值有 none，snappy(默认)，zlib</div><div class="line">          directoryForIndexes: &lt;boolean&gt;    #是否将索引和collections数据分别存储在dbPath单独的目录中</div><div class="line">      collectionConfig:</div><div class="line">          blockCompressor: &lt;string&gt;    #collection数据压缩算法，可选none, snappy，zlib</div><div class="line">      indexConfig:</div><div class="line">          prefixCompression: &lt;boolean&gt;    #是否对索引数据使用前缀压缩。对那些经过排序的值存储有很大帮助，可有效减少索引数据的内存使用量。</div><div class="line">  inMemory:    #inMemory内存存储引擎，bate版</div><div class="line">      engineConfig:</div><div class="line">          inMemorySizeGB: &lt;number&gt;</div></pre></td></tr></table></figure><p><br></p><h2 id="processManagement"><a href="#processManagement" class="headerlink" title="processManagement"></a>processManagement</h2><p>进程相关参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">processManagement:</div><div class="line">  fork: &lt;boolean&gt;        #是否以fork模式运行mongod进程，默认情况下，mongod不作为守护进程运行</div><div class="line">  pidFilePath: &lt;string&gt;        #将mongod进程ID写入指定文件，如未指定，将不会创建PID文件</div></pre></td></tr></table></figure><p><br></p><h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><p>网络相关参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">net:</div><div class="line">  prot: &lt;int&gt;    #监听端口，默认27017</div><div class="line">  bindIp: &lt;string&gt;    #绑定IP，如果此值是“0.0.0.0”则绑定所有接口</div><div class="line">  maxIncomingConnections: &lt;int&gt;    #mongod进程允许的最大连接数，如果此值超过系统配置的连接数阈值，将不会生效(ulimit)</div><div class="line">  wireObjectCheck: &lt;boolean&gt;    #当客户端写入数据时，检查数据的有效性（BSON）。如果数据格式不良，update,insert等操作将会被拒绝</div><div class="line">  ipv6: &lt;boolean&gt;    #是否支持多实例之间使用ipv6</div><div class="line">  unixDomainSocker:    #适用于Unix系统</div><div class="line">      enabled: &lt;boolean&gt;</div><div class="line">      pathPrefix: &lt;string&gt;</div><div class="line">      filePermissions: &lt;int&gt;</div><div class="line">  http:    #</div><div class="line">      enabled: &lt;boolean&gt;</div><div class="line">      JSONEnabled: &lt;boolean&gt;</div><div class="line">      RESTInterfaceEnabled: &lt;boolean&gt;</div><div class="line">  ssl:</div><div class="line">      sslOnNormalPorts: &lt;boolean&gt;</div><div class="line">      mode: &lt;string&gt;</div><div class="line">      PEMKeyFile: &lt;string&gt;</div><div class="line">      PEMKeyPassword: &lt;string&gt;</div><div class="line">      clusterFile: &lt;string&gt;</div><div class="line">      clusterPassword: &lt;string&gt;</div><div class="line">      CAFile: &lt;string&gt;</div><div class="line">      CRLFile: &lt;string&gt;</div><div class="line">      allowConnectionsWithoutCertificates: &lt;boolean&gt;</div><div class="line">      allowInvalidCertificates: &lt;boolean&gt;</div><div class="line">      allowInvalidHostnames: &lt;boolean&gt;</div><div class="line">      disabledProtocols: &lt;string&gt;</div><div class="line">      FIPSMode: &lt;boolean&gt;</div><div class="line">  compression:</div><div class="line">      compressors: &lt;string&gt;</div></pre></td></tr></table></figure><p><br></p><h2 id="security"><a href="#security" class="headerlink" title="security"></a>security</h2><p>安全相关参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">security:</div><div class="line">  authorization: enabled    #MondoDB认证功能</div><div class="line">  keyFile: /path/mongo.key    #MongoDB副本集节点身份验证密钥文件</div><div class="line">  clusterAuthMode: &lt;string&gt;    #集群members间的认证模式</div><div class="line">  transitionToAuth: &lt;boolean&gt;</div><div class="line">   javascriptEnabled:  &lt;boolean&gt;    #是否允许执行JavaScript脚本</div><div class="line">   redactClientLogData: &lt;boolean&gt;</div><div class="line">   sasl:</div><div class="line">      hostName: &lt;string&gt;</div><div class="line">      serviceName: &lt;string&gt;</div><div class="line">      saslauthdSocketPath: &lt;string&gt;</div><div class="line">   enableEncryption: &lt;boolean&gt;</div><div class="line">   encryptionCipherMode: &lt;string&gt;</div><div class="line">   encryptionKeyFile: &lt;string&gt;</div><div class="line">   kmip:</div><div class="line">      keyIdentifier: &lt;string&gt;</div><div class="line">      rotateMasterKey: &lt;boolean&gt;</div><div class="line">      serverName: &lt;string&gt;</div><div class="line">      port: &lt;string&gt;</div><div class="line">      clientCertificateFile: &lt;string&gt;</div><div class="line">      clientCertificatePassword: &lt;string&gt;</div><div class="line">      serverCAFile: &lt;string&gt;</div><div class="line">   ldap:</div><div class="line">      servers: &lt;string&gt;</div><div class="line">      bind:</div><div class="line">         method: &lt;string&gt;</div><div class="line">         saslMechanism: &lt;string&gt;</div><div class="line">         queryUser: &lt;string&gt;</div><div class="line">         queryPassword: &lt;string&gt;</div><div class="line">         useOSDefaults: &lt;boolean&gt;</div><div class="line">      transportSecurity: &lt;string&gt;</div><div class="line">      timeoutMS: &lt;int&gt;</div><div class="line">      userToDNMapping: &lt;string&gt;</div><div class="line">      authz:</div><div class="line">         queryTemplate: &lt;string&gt;</div></pre></td></tr></table></figure><p><br></p><h2 id="operationProfiling"><a href="#operationProfiling" class="headerlink" title="operationProfiling"></a>operationProfiling</h2><p>慢查询相关参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">operationProfiling:</div><div class="line">  slowOpThresholdMs: &lt;int&gt;    #数据库profiler判定一个操作是“慢查询”的时间阈值，单位毫秒。mongod会把慢查询记录到日志中，默认100ms</div><div class="line">  mode: &lt;string&gt;    #数据库profiler级别，操作的性能信息将会被写入日志文件中，可选值“off”--关闭profiling，“slowOp”--只包包含慢操作，“all”--记录所有操作</div><div class="line">  #数据库profiling会影响性能，建议只在性能调试阶段开启</div></pre></td></tr></table></figure><p><br></p><h2 id="replication"><a href="#replication" class="headerlink" title="replication"></a>replication</h2><p>副本集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">replication:</div><div class="line">  oplogSizeMB: &lt;int&gt;    #replication操作日志的最大尺寸，如果太小，secondary将不能通过oplog来同步数据，只能全量同步</div><div class="line">  replSetName: &lt;string&gt;    #副本集名称，副本集中所有的mongod实例都必须有相同的名字，Sharding分布式下，不同的sharding应该使用不同的repSetName</div><div class="line">  secondaryIndexPrefetch: &lt;string&gt;    #副本集中的secondary，从oplog中应用变更操作之前，将会先把索引加载到内存</div><div class="line">  enalbeMajorityReadConcern: &lt;boolean&gt;    #允许readConcern的级别为“majority”</div></pre></td></tr></table></figure><p><br></p><h2 id="sharding"><a href="#sharding" class="headerlink" title="sharding"></a>sharding</h2><p>分片相关参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sharding:</div><div class="line">  clusterRole: &lt;string&gt;    #在sharding集群中，此mongod实例可选的角色。configsvr,默认监听27019端口 和 shardsvr,默认监听27018端口</div><div class="line">  archiveMovedChunks: &lt;boolean&gt;    #当chunks因为“负载均衡”而迁移到其他节点时，mongod是否将这些chunks归档，并保存在dbPath/movechunk目录下，mongod不会删除moveChunk下的文件</div></pre></td></tr></table></figure><p><br></p><h2 id="setParameter"><a href="#setParameter" class="headerlink" title="setParameter"></a>setParameter</h2><p>自定义变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setParameter:</div><div class="line">  &lt;parameter1&gt;: &lt;value1&gt;</div><div class="line">  &lt;parameter2&gt;: &lt;value2&gt;</div><div class="line">  enableLocalhostAuthBypass: false    #栗子</div></pre></td></tr></table></figure><p><br></p><h2 id="auditLog"><a href="#auditLog" class="headerlink" title="auditLog"></a>auditLog</h2><p>审计相关参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">auditLog:</div><div class="line">  destination: &lt;string&gt;    #指定审计记录的输出方式，有syslog, console, file</div><div class="line">  format: &lt;string&gt;    #输出格式，有JSON 和 BSON</div><div class="line">  path: &lt;string&gt;    #如果审计时间输入为文件，那么就需要指定文件完整路径及文件名</div><div class="line">  filter: &lt;string&gt;    #过滤器，可限制审计系统记录的操作类型，该选项需要一个表单的查询文档的字符串表示形式</div></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="Mongo-Shell"><a href="#Mongo-Shell" class="headerlink" title="Mongo Shell"></a>Mongo Shell</h1><p><strong>mongo shell</strong>是一个交互式的JavaScript结构的MongoDB。使用mongo shell来查询和更新数据以及执行管理操作。</p><h2 id="mongo-shell基础知识"><a href="#mongo-shell基础知识" class="headerlink" title="mongo shell基础知识"></a>mongo shell基础知识</h2><h3 id="启动monso-shell"><a href="#启动monso-shell" class="headerlink" title="启动monso shell"></a>启动monso shell</h3><p>启动mongo shell前确保MongoDB实例正在运行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mongo [option] [db address] [.js]</div><div class="line"></div><div class="line"><span class="comment">#以默认配置启动</span></div><div class="line">mongo</div><div class="line"></div><div class="line"><span class="comment">#以特定配置启动</span></div><div class="line">mongo --port 27018</div><div class="line"></div><div class="line"><span class="comment">#连接远程mongo shell</span></div><div class="line">mongo --host <span class="variable">$host</span> --port <span class="variable">$port</span> -u <span class="variable">$user</span> -p <span class="variable">$passwd</span></div><div class="line"></div><div class="line">mongo &lt;db&gt;</div><div class="line">mongo &lt;host&gt;/&lt;db&gt;</div><div class="line">mongo &lt;hsot:port&gt;/&lt;db&gt;</div></pre></td></tr></table></figure><p><br><br><strong>.mongorc.js文件</strong><br>mongo shell开始运行时，mongo将在用户主目录下检查<code>.mongorc.js</code>的js文件。如果找到，mongo将在首次命令行之前解释执行.mongorc.js的内容。<br>如果你使用mongo shell执行一个js或表达式，无论是通过<code>mongo --eval</code>，或指定一个.js文件，mongo都将在js处理完成之后读取.mongorc.js文件。可使用 <code>--norc</code>选项禁止加载.mongorc.js。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ll /root/.mongorc.js</div><div class="line"><span class="comment"># -rw------- 1 root root 0 Dec 27  2016 /root/.mongorc.js</span></div></pre></td></tr></table></figure><p><br></p><h3 id="使用mongo-shell"><a href="#使用mongo-shell" class="headerlink" title="使用mongo shell"></a>使用mongo shell</h3><p>可能在启动mongo shell的时候会警告:</p><ul><li>WARNING: /sys/kernel/mm/transparent_hugepage/defrag is ‘always’. We suggest setting it to ‘never’.</li><li>WARNING: /sys/kernel/mm/transparent_hugepage/defrag is ‘always’. We suggest setting it to ‘never’</li><li>WARNING: Access control is not enabled for the database.</li></ul><p>hugepage(大内存页面)，是Linux操作系统一种管理内存的方式。和通常方式相比，hugepage模式下内存分配管理会有所差异。<br>MongoDB显然不希望这个特定被启用。<br>新版MongoDB增加了安全性设计，推荐用户创建使用数据库时进行验证。所以我们需要创建用户认证。</p><p>关闭hugepage:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vim /etc/rc.d/rc.local</div><div class="line"></div><div class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</div><div class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/defrag</div><div class="line"></div><div class="line">chmox a+x /etc/rc.d/rc.local</div></pre></td></tr></table></figure><p>创建用户认证:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;use admin</div><div class="line">&gt;db.createUser(</div><div class="line">&#123;</div><div class="line">user: <span class="string">"zhang"</span>,</div><div class="line">    <span class="built_in">pwd</span>: <span class="string">"zhang"</span>,</div><div class="line">    roles: [&#123; role: <span class="string">"root"</span>, db: <span class="string">"admin"</span>&#125;]</div><div class="line">&#125;</div><div class="line">)</div><div class="line"></div><div class="line">mongo -u zhang -p zhang --authenticationDatabase admin</div><div class="line"><span class="comment">#或</span></div><div class="line">mongo</div><div class="line">use admin</div><div class="line">db.auth(<span class="string">"zhang"</span>, <span class="string">"1314520"</span>)</div></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mongo</div><div class="line"></div><div class="line"><span class="comment">#显示当前使用数据库</span></div><div class="line">&gt;db</div><div class="line"></div><div class="line"><span class="comment">#切换数据库</span></div><div class="line">&gt;use &lt;database&gt;</div><div class="line"></div><div class="line"><span class="comment">#查看所有数据库</span></div><div class="line">&gt;show dbs</div></pre></td></tr></table></figure><p><br><br>你可以切换到一个并不存在的数据库。当你第一次向数据库存储数据，如创建一个集合，MongoDB将自动创建数据库。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">use nodb</div><div class="line"></div><div class="line">db.nocollestion.insert(&#123;x:1&#125;);</div></pre></td></tr></table></figure><p><br></p><h3 id="格式化打印结果"><a href="#格式化打印结果" class="headerlink" title="格式化打印结果"></a>格式化打印结果</h3><p><code>db.collection.find()</code>方法返回一个<code>cursor</code>(游标)。如果返回的游标未使用var关键字指定变量，则游标将自动迭代最多20次，以打印出与查询匹配的前20个<code>documents</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#在操作中添加`.pretty()`，以格式化打印结果</span></div><div class="line"><span class="comment">#使用.pretty显示结果很舒服</span></div><div class="line">db.collection.find().pretty()</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">print</span>()<span class="comment">#无格式打印</span></div><div class="line">printjson() <span class="comment">#用JSON打印</span></div></pre></td></tr></table></figure><p><br></p><h3 id="mongo-shell中的多行操作"><a href="#mongo-shell中的多行操作" class="headerlink" title="mongo shell中的多行操作"></a>mongo shell中的多行操作</h3><p>mongo shell中如果你以<code>( , { , [</code>开始，那么知道你输入了对应的<code>) , } , ]</code>才算结束命令。</p><p><br></p><h3 id="Tab命令补全和键盘快捷键"><a href="#Tab命令补全和键盘快捷键" class="headerlink" title="Tab命令补全和键盘快捷键"></a>Tab命令补全和键盘快捷键</h3><p>mongo shell支持键盘快捷键，例如：</p><ul><li>使用 <code>上/下箭头</code> 进行历史命令切换；</li><li>使用 <code>Tab键</code> 自动补全命令。</li></ul><p><br></p><h3 id="mongo-shell批量操作"><a href="#mongo-shell批量操作" class="headerlink" title="mongo shell批量操作"></a>mongo shell批量操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mongo -u xxx -p xxx --authenticationDatabase=xxx &lt;&lt; EOF</div><div class="line">show dbs</div><div class="line">use zhang</div><div class="line">db.coll01.drop()</div><div class="line">db.coll02.update( &#123; _id: <span class="string">"xxx"</span> &#125;, &#123; name: <span class="string">"zhang"</span> &#125;)</div><div class="line">EOF</div></pre></td></tr></table></figure><p><br></p><h3 id="退出mongo-shell"><a href="#退出mongo-shell" class="headerlink" title="退出mongo shell"></a>退出mongo shell</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">quit()</div><div class="line"></div><div class="line"><span class="built_in">exit</span></div><div class="line"></div><div class="line">Ctrl+c</div></pre></td></tr></table></figure><p><br></p><h2 id="配置mongo-shell"><a href="#配置mongo-shell" class="headerlink" title="配置mongo shell"></a>配置mongo shell</h2><p>可在mongo shell中设置变量<code>prompt</code>的值来修改提示符内容。<br>prompt变量可以存储字符串以及JavaScript代码。</p><p>也可以在<code>.mongorc.js</code>文件中增加提示符的逻辑操作来设置每次启动mongo shell的提示符。</p><p><br></p><h3 id="自定义提示符"><a href="#自定义提示符" class="headerlink" title="自定义提示符"></a>自定义提示符</h3><p><strong>自定义提示符展示操作符：</strong></p><p>在mongo shell中定义一下变量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cmdCount = 1;</div><div class="line">prompt = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> (cmdCount++) + <span class="string">'&gt; '</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#效果</span></div><div class="line">1&gt;</div><div class="line">2&gt;</div><div class="line">...</div></pre></td></tr></table></figure><p><br><br><strong>自定义提示符显示数据库和主机名：</strong></p><p>形式为：<database>@<hostname>$</hostname></database></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">host = db.serverStatus().host;</div><div class="line">prompt = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> db+<span class="string">'@'</span>+host+<span class="string">'$'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#效果</span></div><div class="line"><span class="built_in">test</span>@localhost$</div></pre></td></tr></table></figure><p><br><br><strong>自定义提示符展示服务器启动时间和文档数：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">prompt = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> <span class="string">'Uptime:'</span> + db.serverStatus().uptime + <span class="string">'Documents:'</span> + db.stats().objects + <span class="string">'&gt; '</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#效果</span></div><div class="line">Uptime:1234 Documents:5 &gt;</div></pre></td></tr></table></figure><p><br><br><strong>注意：</strong><br>在mongo shell里面定义的<code>prompt</code>变量知识临时生效的，退出shell后便没有。<br>如果想要当前用户永久生效，可写入<code>~/.mongorc.js</code>文件。则此用户每次启动mongo shell前都会执行这个文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vim ~/.mongorc.js</div><div class="line"></div><div class="line">host = db.serverStatus().host;</div><div class="line">prompt = <span class="function"><span class="title">function</span></span>() &#123;</div><div class="line">             <span class="built_in">return</span> db+<span class="string">"@"</span>+host+<span class="string">"&gt; "</span>;</div><div class="line">         &#125;</div></pre></td></tr></table></figure><p><br></p><h3 id="在mongo-shell中使用外部编辑器"><a href="#在mongo-shell中使用外部编辑器" class="headerlink" title="在mongo shell中使用外部编辑器"></a>在mongo shell中使用外部编辑器</h3><p>可在启动mongo shell之前设置<code>EDITOR</code>环境变量来在mongo shell中使用自己的编辑器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> EDITOR=vim</div><div class="line">mongo</div><div class="line"></div><div class="line"><span class="comment">#edit &lt;variable&gt;|&lt;function&gt;</span></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">myfunc</span></span>()&#123;&#125;</div><div class="line"></div><div class="line">edit myfunc</div><div class="line"><span class="comment">#此时是edit使用vim编辑myfunc</span></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">myfunc</span></span>()&#123;</div><div class="line"><span class="built_in">print</span>(<span class="string">"It was edited by vim!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">myfunc()</div></pre></td></tr></table></figure><p><br></p><h3 id="修改mongo-shell批处理大小"><a href="#修改mongo-shell批处理大小" class="headerlink" title="修改mongo shell批处理大小"></a>修改mongo shell批处理大小</h3><p><code>db.collection.find()</code>是一种JavaScript方法，返回一个<code>cursor</code>(游标)。如果返回的游标未使用var关键字指定变量，则游标将自动迭代最多20次，以打印出与查询匹配的前20个<code>documents</code>。<br>可以设置<code>DBQuery.shellBatchSize</code>属性来修改默认20篇文档。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DBQuery.shellBatchSize = 10;</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="获取mongo-shell帮助"><a href="#获取mongo-shell帮助" class="headerlink" title="获取mongo shell帮助"></a>获取mongo shell帮助</h2><p>合理运用<code>Tab键</code>补全命令！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###命令行帮助</span></div><div class="line">mongo --<span class="built_in">help</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###mongo shell里查看帮助列表</span></div><div class="line"><span class="built_in">help</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###数据库帮助</span></div><div class="line"><span class="comment">#db.&lt;method&gt;</span></div><div class="line">show dbs</div><div class="line">db.help()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###集合帮助</span></div><div class="line"><span class="comment">#db.&lt;collection&gt;.&lt;method&gt;</span></div><div class="line">show collections</div><div class="line">db.collections.help()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###游标帮助</span></div><div class="line">db.collection.find().<span class="built_in">help</span>()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###封装对象帮助</span></div><div class="line"><span class="built_in">help</span> misc</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="给mongo-shell写脚本"><a href="#给mongo-shell写脚本" class="headerlink" title="给mongo shell写脚本"></a>给mongo shell写脚本</h2><p>可使用JavaScript为mongo shell编写脚本，用于处理MongoDB中的数据或执行管理操作。</p><p><br></p><h3 id="打开新连接"><a href="#打开新连接" class="headerlink" title="打开新连接"></a>打开新连接</h3><p>在mongo shell或JavaScript文件中，可使用<code>Mongo()</code>构造函数来实例化数据库连接：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">new Mongo()</div><div class="line">new Mongo(&lt;host&gt;)</div><div class="line">new Mongo(&lt;host:port&gt;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">conn = new Mongo();</div><div class="line">db = conn.getDB(<span class="string">'mydb'</span>);<span class="comment">#将全局db变量设置为mydb</span></div><div class="line"></div><div class="line"><span class="comment">#连接</span></div><div class="line">db = connect(<span class="string">'localhost:27017/mydb'</span>);</div><div class="line"></div><div class="line"><span class="comment">#认证</span></div><div class="line">db.auth(&lt;user&gt;, &lt;passwd&gt;)</div><div class="line"></div><div class="line">db.auth(&#123;</div><div class="line">user: &lt;user&gt;,</div><div class="line">    <span class="built_in">pwd</span>: &lt;passed&gt;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><br></p><h3 id="交互式和脚本化mongo的区别"><a href="#交互式和脚本化mongo的区别" class="headerlink" title="交互式和脚本化mongo的区别"></a>交互式和脚本化mongo的区别</h3><p>mongo shell中的帮助与JavaScript中帮助不一样！</p><table><thead><tr><th>mongo shell帮助</th><th>JavaScript等量</th></tr></thead><tbody><tr><td>show dbs</td><td>db.adminCommand(‘listDatabases’)</td><td></td></tr><tr><td>use <db></db></td><td>db = db.getSiblingDB(‘<db>‘)</db></td><td></td></tr><tr><td>show collections</td><td>db.getCollectionNames()</td><td></td></tr><tr><td>show users</td><td>db.getUsers()</td><td></td></tr><tr><td>show log <logname></logname></td><td>db.adminCommand({‘getLog’ : ‘<logname>‘})</logname></td><td></td></tr></tbody></table><p><br></p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>使用mongo shell来计算JavaScript的值。</p><p><br><br><strong>–eval <javascript></javascript></strong><br><code>mongo</code>执行 <code>--eval</code>后的js命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongo test --eval &quot;printjson(db.getCollectionNames())&quot;</div></pre></td></tr></table></figure><p><br><br><strong>执行JavaScript文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mongo localhost:27017/<span class="built_in">test</span> myjs.js</div><div class="line"></div><div class="line"><span class="comment">#在shell中执行.js</span></div><div class="line">&gt;load(<span class="string">"myjs.js"</span>)</div><div class="line">&gt;loca(<span class="string">"/root/mongo/myjs.js"</span>)</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="mongo-shell中的数据类型"><a href="#mongo-shell中的数据类型" class="headerlink" title="mongo shell中的数据类型"></a>mongo shell中的数据类型</h2><p>MongoDB BSON提供了除JSON之外的其它数据类型的支持。Driver提供了对这些数据类型在主机语言的本地化支持，mongo shell也提供了一些帮助类来支持这些数据类型在mongo javascript shell中的使用。</p><p><br></p><h3 id="日期-1"><a href="#日期-1" class="headerlink" title="日期"></a>日期</h3><p>mongo shell提供了多种方法返回日期:</p><ul><li><code>Date()</code> 方法返回当前日期为一个字符串；</li><li><code>new Date()</code> 构造函数返回一个使用ISODate()包装返回的Date对象；</li><li><code>ISODate()</code> 构造函数返回一个使用ISODate()包装返回的Date对象。</li></ul><p><br><br>返回一个日期为字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myDateString = Date();</div><div class="line">#查看变量值</div><div class="line">myDateString</div></pre></td></tr></table></figure><p><br><br>验证类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typeof myDateString()</div><div class="line">#string</div></pre></td></tr></table></figure><p><br><br>返回Date：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var myDate = new Date();</div><div class="line">myDate</div><div class="line">#ISODate(&quot;2017-12-12T08:43:31.405Z&quot;)</div><div class="line"></div><div class="line">#验证</div><div class="line">myDate instanceof Date</div></pre></td></tr></table></figure><p><br></p><h3 id="ObjectId-1"><a href="#ObjectId-1" class="headerlink" title="ObjectId"></a>ObjectId</h3><p>mongo shell对objectid数据类型提供objectId()包装类。</p><p><code>new ObjectId</code></p><p><br></p><h3 id="NumberLong"><a href="#NumberLong" class="headerlink" title="NumberLong"></a>NumberLong</h3><p>mongo shell默认将所有数字处理为浮点值。</p><p>用<code>numberlong()</code>包装来处理64位整数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NumberLong(<span class="string">"2090845886852"</span>)</div></pre></td></tr></table></figure><p><br></p><h3 id="NumberInt"><a href="#NumberInt" class="headerlink" title="NumberInt"></a>NumberInt</h3><p>用<code>NumberInt()</code>构造函数来显式指定32位整数。</p><p><br></p><h3 id="NumberDecimal"><a href="#NumberDecimal" class="headerlink" title="NumberDecimal"></a>NumberDecimal</h3><p><code>mongo shell</code>默认将所有的数字处理为64位浮点的<code>double</code>值。<code>mongo shell</code>提供了<code>NumberDecimal()</code>构造函数限制指定128位基于十进制的浮点值，能够以精确的精度仿效十进制近似值。<br>这个功能在金融、税务以及科学计算等方面应用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;NumberDecimal(<span class="string">'1000.55'</span>)</div><div class="line"><span class="comment">#强烈建议加上引号，没加引号可能会存在精度丢失的情况</span></div></pre></td></tr></table></figure><p><br></p><p>###　在mongo shell中检查类型</p><p><code>instanceof</code>返回一个bool值来验证一个值是否为某些类型的实例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mydoc._id instanceof ObjectId</div><div class="line"><span class="comment">#true</span></div></pre></td></tr></table></figure><p><code>typeof</code>返回一个字段的类型。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typeof mydoc._id</div><div class="line"><span class="comment">#object</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="mongo-shell快速参考"><a href="#mongo-shell快速参考" class="headerlink" title="mongo shell快速参考"></a>mongo shell快速参考</h2><h3 id="mongo-shell-历史命令"><a href="#mongo-shell-历史命令" class="headerlink" title="mongo shell 历史命令"></a>mongo shell 历史命令</h3><p>mongo shell历史命令保存在<code>~/.dbshell</code>文件中，<code>cat ~/.dbshell</code>。也可以使用<strong>上/下键</strong>切换历史命令。</p><p><br></p><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><table><thead><tr><th>option</th><th>description</th></tr></thead><tbody><tr><td><code>--help</code></td><td>显示命令行选项</td></tr><tr><td><code>--nodb</code></td><td>启动mongo shell而不连接到数据库</td></tr><tr><td><code>--shell</code></td><td>执行文件后运行mongo shell</td></tr></tbody></table><p><br></p><h3 id="mongo-shell命令助手"><a href="#mongo-shell命令助手" class="headerlink" title="mongo shell命令助手"></a>mongo shell命令助手</h3><table><thead><tr><th>help methods and commands</th><th>description</th></tr></thead><tbody><tr><td><code>help</code></td><td>显示帮助</td></tr><tr><td><code>db.help</code></td><td>显示数据库方法的帮助</td></tr><tr><td><code>db.collection.help()</code></td><td>显示集合方法的帮助</td></tr><tr><td><code>show dbs</code></td><td>打印服务器上的所有数据库列表</td></tr><tr><td><code>show databases</code></td><td>打印所有可获取的数据库列表</td></tr><tr><td><code>use &lt;db&gt;</code></td><td>切换数据库</td></tr><tr><td><code>show collections</code></td><td>打印当前数据库上的所有集合列表</td></tr><tr><td><code>show users</code></td><td>打印当前数据库的用户列表</td></tr><tr><td><code>show roles</code></td><td>打印当前数据库的所有角色(user-define and built-in)列表</td></tr><tr><td><code>show profile</code></td><td>打印花费1ms或更多时间的五个最近的操作</td></tr><tr><td><code>load()</code></td><td>在shell中执行一个JavaScript文件，建议使用绝对路径</td></tr></tbody></table><p><br></p><h3 id="mongo-shell的基本JavaScript操作"><a href="#mongo-shell的基本JavaScript操作" class="headerlink" title="mongo shell的基本JavaScript操作"></a>mongo shell的基本JavaScript操作</h3><p>mongo shell为数据库操作提供了一个JavaScript API。<br>db引用当的是前数据库的变量。</p><table><thead><tr><th>JavaScript db-operation</th><th>description</th></tr></thead><tbody><tr><td><code>db.auth()</code></td><td>在安全模式下认证用户</td></tr><tr><td><code>coll = db.&lt;collection&gt;</code></td><td>将当前db中的特定collection设置为coll，可在此变量上执行操作，如<code>coll.find();</code></td></tr><tr><td><code>db.collection.find()</code></td><td>查找集合中的所有文档，并返回一个游标</td></tr><tr><td><code>db.collection.insert()</code></td><td>插入一个新文档到集合中</td></tr><tr><td><code>db.collection.update()</code></td><td>更新集合中一个存在的文档</td></tr><tr><td><code>db.collection.save()</code></td><td>插入或更新 集合中的文档</td></tr><tr><td><code>db.collection.remove()</code></td><td>从集合中删除文档</td></tr><tr><td><code>db.collection.drop()</code></td><td>删除整个集合</td></tr><tr><td><code>db.collection.createIndex()</code></td><td>在集合中创建索引</td></tr><tr><td><code>db.getSiblingDB()</code></td><td>跨数据库查询</td></tr></tbody></table><p><br></p><h3 id="键盘快捷键"><a href="#键盘快捷键" class="headerlink" title="键盘快捷键"></a>键盘快捷键</h3><table><thead><tr><th>keysrtoke</th><th>function</th></tr></thead><tbody><tr><td>Up/Down arrow</td><td>前/后 历史命令</td></tr><tr><td>Left/Right arrow</td><td>左右移动</td></tr><tr><td>Home/End</td><td>行首/行尾</td></tr><tr><td>Tab</td><td>自动补全</td></tr><tr><td>ctrl+c</td><td>退出</td></tr><tr><td>ctrl+L</td><td>清屏</td></tr></tbody></table><p><br></p><h3 id="mongo-shell查询方法"><a href="#mongo-shell查询方法" class="headerlink" title="mongo shell查询方法"></a>mongo shell查询方法</h3><p>在mongo shell中，使用<code>find()</code>和<code>findOne()</code>方法执行读操作。</p><table><thead><tr><th>read-operations</th><th>description</th></tr></thead><tbody><tr><td><code>db.collection.find(&lt;query&gt;)</code></td><td>查找集合中与<query>匹配的文档，如果未指定<query>或为空，则读取操作会选择集合中的所有文档</query></query></td></tr><tr><td><code>db.collection.find(&lt;query&gt;, &lt;projection&gt;)</code></td><td>查找与<query>匹配的文档，返回<projection>特定字段</projection></query></td></tr><tr><td><code>db.collection.find().sort(&lt;sort order&gt;)</code></td><td>返回<sort order="">排序结果</sort></td></tr><tr><td><code>db.collection.find(&lt;query&gt;).sort(&lt;sort order&gt;)</code></td><td>返回匹配<query>和<sort order="">排序结果</sort></query></td></tr><tr><td><code>db.collection.find(...).limit(&lt;n&gt;)</code></td><td>限制输出结果为<n>行</n></td></tr><tr><td><code>db.collection.find().pretty().limit()</code></td><td>匹配，格式化，限制输出</td></tr><tr><td><code>db.collection.find().limit().pretty()</code></td><td>同上</td></tr><tr><td><code>db.collection.find(...).skip(&lt;n&gt;)</code></td><td>跳过前<n>行</n></td></tr><tr><td><code>db.collection.count()</code></td><td>返回集合中文档总数</td></tr><tr><td><code>db.collection.find().count()</code></td><td>返回匹配文档总数</td></tr><tr><td><code>db.collection.findOne(&lt;query&gt;)</code></td><td>查找并返回单一的文档，null表示未找到</td></tr></tbody></table><p><br></p><h3 id="管理命令助手"><a href="#管理命令助手" class="headerlink" title="管理命令助手"></a>管理命令助手</h3><table><thead><tr><th>js db-administrative-methods</th><th>description</th></tr></thead><tbody><tr><td><code>db.cloneDatabase(&lt;host&gt;)</code></td><td>从指定主机克隆当前数据库，noauth mode</td></tr><tr><td><code>db.copyDatabase(&lt;from&gt;, &lt;to&gt;, &lt;host&gt;)</code></td><td>copy <from>db to <to>db</to></from></td></tr><tr><td><code>db.fromColl.renameCollection(&lt;toColl&gt;)</code></td><td>rename collection</td></tr><tr><td><code>db.repairDatabase()</code></td><td>修复当前db</td></tr><tr><td><code>db.dropDatabases()</code></td><td>删除当前数据库</td></tr></tbody></table><p><br></p><h3 id="打开附加连接"><a href="#打开附加连接" class="headerlink" title="打开附加连接"></a>打开附加连接</h3><p>可以在mongo shell中创建一个新连接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;db = connect(<span class="string">"&lt;host&gt;:&lt;port&gt;/&lt;db&gt;"</span>)</div><div class="line">#db = connect("192.168.1.11/admin")</div><div class="line"></div><div class="line">&gt;conn = <span class="keyword">new</span> Mongo()</div><div class="line">&gt;db = conn.getDB(<span class="string">"dbname"</span>)</div></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="MongoDB-CRUD操作"><a href="#MongoDB-CRUD操作" class="headerlink" title="MongoDB CRUD操作"></a>MongoDB CRUD操作</h1><p><code>CRUD</code>操作就是<em>创建(create)，读取(read)，更新(update)，删除(delete)</em>文档(document)!</p><p><br><br><strong>创建(create)操作</strong><br>创建或插入， 即是向 collection 添加新的 document。如果插入时集合不存在，插入操作会创建该集合。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.collection.insert()</div><div class="line">db.collection.insertOne()</div><div class="line">db.collection.insertMany()</div></pre></td></tr></table></figure><p><br><br><strong>读取(read)操作</strong><br>读操作，获取 collection 中的 document。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.collection.find()</div></pre></td></tr></table></figure><p><br><br><strong>更新(update)操作</strong><br>更新操作，修改 collection 中已经存在的 document。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.collection.update()</div><div class="line">db.collection.updateOne()</div><div class="line">db.collection.updateMany()</div><div class="line">db.collection.replaceOne()</div></pre></td></tr></table></figure><p><br><br><strong>删除(delete)操作</strong><br>删除操作，是从一个 collection 中删除 document 的操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.collection.remove()</div><div class="line">db.collection.deleteOne()</div><div class="line">db.collection.deleteMany()</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="插入文档-Insert"><a href="#插入文档-Insert" class="headerlink" title="插入文档(Insert)"></a>插入文档(Insert)</h2><p><br></p><h3 id="插入方法"><a href="#插入方法" class="headerlink" title="插入方法"></a>插入方法</h3><p>MongoDB提供了如下插入方法向collection中插入document：</p><ul><li><code>db.collection.insert()</code>, 向集合中插入一个或多个文档;</li><li><code>db.collection.insertOne()</code>, 向集合中插入一个文档;</li><li><code>db.collection.insertMany()</code>, 向集合中插入多个文档.</li></ul><p><br></p><h4 id="db-collection-insert"><a href="#db-collection-insert" class="headerlink" title="db.collection.insert()"></a>db.collection.insert()</h4><p><code>db.collection.insert()</code>,向collection中插入一个或多个document。<br>要想插入一个document，传递<strong>一个文档</strong>给该方法；要想插入多个documents，传递<strong>文档数组</strong>给该方法。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#插入一个文档</span></div><div class="line">db.user.insert(</div><div class="line">&#123;</div><div class="line">    _id: <span class="string">"ZhangTest"</span>,</div><div class="line">    name: <span class="string">"zhang"</span>,</div><div class="line">        age: 2017,</div><div class="line">        sex: <span class="string">"man"</span></div><div class="line">    &#125;</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#插入多个文档</span></div><div class="line">db.user.insert(</div><div class="line">[</div><div class="line">    &#123; name: <span class="string">"AAA"</span>, age: 20, status: <span class="string">"A"</span> &#125;,</div><div class="line">        &#123; name: <span class="string">"BBB"</span>, age: 21, status: <span class="string">"B"</span> &#125;,</div><div class="line">        &#123; name: <span class="string">"CCC"</span>, age: 22, status: <span class="string">"C"</span> &#125;</div><div class="line">    ]</div><div class="line">)</div></pre></td></tr></table></figure><p><br></p><h4 id="db-collection-insertOne"><a href="#db-collection-insertOne" class="headerlink" title="db.collection.insertOne()"></a>db.collection.insertOne()</h4><p><code>db.collection.insertOne()</code>,向collection中插入单个document。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">db.user.insertOne(</div><div class="line">&#123;</div><div class="line">name: <span class="string">"zhang"</span>,</div><div class="line">        age: <span class="string">"2017"</span>,</div><div class="line">        sex: <span class="string">"man"</span>,</div><div class="line">        education: <span class="string">"bachelor"</span></div><div class="line">&#125;</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">#此处并未自定义_id字段，因此它会自动添加_id字段</span></div></pre></td></tr></table></figure><p><br></p><h4 id="db-collection-insertMany"><a href="#db-collection-insertMany" class="headerlink" title="db.collection.insertMany()"></a>db.collection.insertMany()</h4><p><code>db.collection.insertMany()</code>,向collection插入多个documents。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.user.insertMany(</div><div class="line">[</div><div class="line">    &#123; name: <span class="string">"AAA"</span>, age: <span class="string">"20"</span>, status: <span class="string">"A"</span> &#125;,</div><div class="line">        &#123; name: <span class="string">"BBB"</span>, age: <span class="string">"21"</span>, status: <span class="string">"B"</span> &#125;,</div><div class="line">        &#123; name: <span class="string">"CCC"</span>, age: <span class="string">"22"</span>, status: <span class="string">"C"</span> &#125;</div><div class="line">    ]</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">#自动生成3个document的_id字段</span></div></pre></td></tr></table></figure><p><br></p><h3 id="插入操作的行为表现"><a href="#插入操作的行为表现" class="headerlink" title="插入操作的行为表现"></a>插入操作的行为表现</h3><p><strong>创建集合</strong><br>插入的时候如果collection不存在，那么插入操作会创建collection。</p><p><strong>_id字段</strong><br>在MongoDB中，存储于collection中的每一个document都需要一个唯一的<code>_id</code>字段作为<code>primary_key</code>。如果一个插入的document操作遗漏了<code>_id</code>字段，则<code>MongoDB driver</code>会自动生成一个<code>ObjectId</code>。</p><p><strong>原子性</strong><br>MongoDB中所有的写操作在单一文档层级上是原子的。</p><p><br><br><br></p><h2 id="查询文档-Read"><a href="#查询文档-Read" class="headerlink" title="查询文档(Read)"></a>查询文档(Read)</h2><p>MongoDB提供了<code>db.collection.find()</code>方法从collection中读取document。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.collection.find( &lt;query filter&gt;, &lt;projection&gt; )</div><div class="line"></div><div class="line"><span class="comment">#&lt;query filter&gt;指明返回哪些document</span></div><div class="line"><span class="comment">#&lt;projection&gt;指明返回匹配document的那些filed</span></div></pre></td></tr></table></figure><p><br></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">db.user.insertMany(</div><div class="line">  [</div><div class="line">  &#123;</div><div class="line">_id: 1,</div><div class="line">name: <span class="string">"A"</span>,</div><div class="line">favorites: &#123; artist: <span class="string">"Picasso"</span>, food: <span class="string">"pizza"</span> &#125;,</div><div class="line">        finished: [ 11, <span class="string">"AA"</span> ],</div><div class="line">        points: [ &#123; points: 85, bonus: 30 &#125;, &#123; points: 85, bonus: 10 &#125; ]</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">    _id: 2,</div><div class="line">        name: <span class="string">"B"</span>,</div><div class="line">    favorites: &#123; artist: <span class="string">"Miro"</span>, food: <span class="string">"merigue"</span> &#125;,</div><div class="line">        finished: [ 22, <span class="string">"BB"</span> ],</div><div class="line">        points: [ &#123; points: 85, bonus: 20 &#125;, &#123; points: 64, bonus: 12 &#125; ]</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">    _id: 3,</div><div class="line">        name: <span class="string">"C"</span>,</div><div class="line">        favorites: &#123; artist: <span class="string">"Gaogeng"</span>, food: <span class="string">"cake"</span> &#125;,</div><div class="line">        finished: [ 33, <span class="string">"CC"</span> ],</div><div class="line">        points: [ &#123; points: 67, bonus: 8 &#125;, &#123; points: 55, bonus: 21 &#125; ]</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">)</div></pre></td></tr></table></figure><p><br></p><h3 id="查询和规划操作符"><a href="#查询和规划操作符" class="headerlink" title="查询和规划操作符"></a>查询和规划操作符</h3><p><strong>Comparison:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$eq</div><div class="line">$gt</div><div class="line">$gte</div><div class="line">$lt</div><div class="line">$ne</div><div class="line">$in</div><div class="line">$nin</div></pre></td></tr></table></figure><p><strong>Logical：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$or</div><div class="line">$and</div><div class="line">$not</div><div class="line">$nor</div></pre></td></tr></table></figure><p><strong>Element:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$exists</div><div class="line">$type</div></pre></td></tr></table></figure><p><strong>Evaluation:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$mod</div><div class="line">$regex</div><div class="line">$text</div><div class="line">$where</div></pre></td></tr></table></figure><p><strong>Geospatial:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$geoWithin</div><div class="line">$geoIntersects</div><div class="line">$near</div><div class="line">$nearSphere</div></pre></td></tr></table></figure><p><strong>Array:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$all</div><div class="line">$eleMatch</div><div class="line">$size</div></pre></td></tr></table></figure><p><strong>Bitwise:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$bitsAllSet</div><div class="line">$bitsAnySet</div><div class="line">$bitsAllClear</div><div class="line">$bitsAnyClear</div></pre></td></tr></table></figure><p><strong>Comments:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$comment</div></pre></td></tr></table></figure><p><strong>Projection Operators:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$</div><div class="line">$eleMatch</div><div class="line">$meta</div><div class="line">$slice</div></pre></td></tr></table></figure><p><br></p><h4 id="选择collectino中所有document"><a href="#选择collectino中所有document" class="headerlink" title="选择collectino中所有document"></a>选择collectino中所有document</h4><p>一个空的<code>query filter</code>会选择集合汇总所有文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.users.find(&#123;&#125;)</div><div class="line">db.user.find()</div></pre></td></tr></table></figure><p><br></p><h4 id="指定查询过滤条件"><a href="#指定查询过滤条件" class="headerlink" title="指定查询过滤条件"></a>指定查询过滤条件</h4><p><strong>1. 指定等于条件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; &lt;field1&gt;: &lt;value1&gt;, ...&#125;</div><div class="line"></div><div class="line">#栗子</div><div class="line">db.user.find( &#123; name: &quot;C&quot; &#125; )</div></pre></td></tr></table></figure><p><strong>2. 使用查询操作符指定条件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; &lt;field1&gt;: &#123; &lt;operator1&gt;: &lt;value1&gt; &#125;, ... &#125;</div><div class="line"></div><div class="line">#栗子</div><div class="line">db.user.find( &#123; name: &#123; $in: [ &quot;A&quot;, &quot;B&quot; ] &#125; &#125; )</div></pre></td></tr></table></figure><p><strong>3. 指定逻辑查询条件条件</strong><br>逻辑查询(AND, OR, NOT)。符合查询可以在集合文档的多个字段上指定条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#AND</div><div class="line">db.user.find( &#123; name: &quot;A&quot;, age: &#123; $lt: 30&#125; &#125; )</div><div class="line"></div><div class="line"></div><div class="line">#OR</div><div class="line">db.user.find( &#123;</div><div class="line">$or: [ &#123; name: &quot;A&quot; &#125;, &#123; age: &#123; $lt: 30 &#125; &#125; ]</div><div class="line">&#125; )</div><div class="line"></div><div class="line"></div><div class="line">#AND和OR</div><div class="line">db.user.find( &#123;</div><div class="line">name: &quot;A&quot;,</div><div class="line">    $or: [ &#123;age: &#123; $lt: 30 &#125; &#125;, &#123; type: 1 &#125; ]</div><div class="line">&#125; )</div></pre></td></tr></table></figure><p><br></p><h4 id="嵌入式文档的查询"><a href="#嵌入式文档的查询" class="headerlink" title="嵌入式文档的查询"></a>嵌入式文档的查询</h4><p>当字段中包含嵌入文档时，查询可以指定嵌入文档中的精确匹配或使用<code>圆点(.)表示法</code>对嵌入文档的单个字段指定匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#精确匹配</div><div class="line">db.user.find(&#123;</div><div class="line">favorites: &#123; artist: &quot;Picasso&quot;, food: &quot;pizza&quot; &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">#圆点.表示法，记得加引号</div><div class="line">db.user.find( &#123; &quot;favorites.artist&quot;: &quot;Picasso&quot; &#125; )</div></pre></td></tr></table></figure><p><br></p><h4 id="数组上的查询"><a href="#数组上的查询" class="headerlink" title="数组上的查询"></a>数组上的查询</h4><p>当字段包含数组，可查询精确的匹配数组或数组中特定的值。如果数组包含嵌入文档，可使用<code>圆点表示法</code>查询内嵌文档中特定的字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#精确匹配</div><div class="line">db.user.find(&#123; finished: [ 11, &quot;AA&quot; ] &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#匹配一个数组元素，会显示整个文档</div><div class="line">db.user.find(&#123; finished: &quot;BB&quot; &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#匹配数组中指定元素，会返回整个文档</div><div class="line">db.user.find(&#123; &quot;finished.1&quot;: &quot;CC&quot; &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#指定数组中的多个查询条件</div><div class="line">db.user.find(&#123; finished: &#123; $elemMatch: &#123;$gte: 11, $lt: 33&#125; &#125; &#125;)</div><div class="line"></div><div class="line">db.user.find(&#123; finished: &#123; $gt: 11, $lt: 33 &#125; &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#嵌入文档数组</div><div class="line">db.user.find(&#123; &apos;points.points&apos;: &#123;$lte: 80 &#125; &#125;)</div><div class="line">db.user.find(&#123; &quot;points.0.points&quot;: &#123;$lte: 80&#125; &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#元素组合满足查询条件</div><div class="line">db.user.find(&#123;</div><div class="line">&quot;points.points&quot;: &#123;$lte: 80&#125;, &quot;points.bouns&quot;: 20</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><br></p><h3 id="返回查询的映射字段"><a href="#返回查询的映射字段" class="headerlink" title="返回查询的映射字段"></a>返回查询的映射字段</h3><p>默认地，MongoDB中的查询返回匹配文档中的所有字段。为了限制MongoDB发送给应用的数据量，我们可以在查询操作中包括一个<code>projection</code>文档。</p><p><br></p><h4 id="映射文档"><a href="#映射文档" class="headerlink" title="映射文档"></a>映射文档</h4><p>映射文档限制了返回所有匹配文档的字段。映射文档可以致命包括哪些字段或排除哪些字段。<br>这个就很不错了，可以过滤掉我们不需要的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.users.find( &#123;name: &quot;AAA&quot;&#125; ,&#123;_id: 0, name: 1, age: ture&#125; )</div><div class="line">db.user.find( &#123; name: &quot;BBB&quot;&#125;, &#123;_id: false&#125; )</div><div class="line"></div><div class="line">1或true，表示在返回的文档中包含字段；</div><div class="line">0或false，排除该字段；</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="更新文档-Update"><a href="#更新文档-Update" class="headerlink" title="更新文档(Update)"></a>更新文档(Update)</h2><p><strong>更新方法：</strong></p><ul><li><code>db.collection.updateOne()</code>, 更新一个文档</li><li><code>db.collection.updateMany()</code>, 更新多个文档</li><li><code>db.replaceOne()</code>, 替换一个文档</li><li><code>db.collection.update()</code>, 更新或替换一个文档</li></ul><p><br></p><h3 id="更新的行为表现"><a href="#更新的行为表现" class="headerlink" title="更新的行为表现"></a>更新的行为表现</h3><ul><li><p>原子性：<br>MongoDB中所有的写操作在单一文档层级上是原子的。</p></li><li><p>_id字段：<br>不能更新<code>_id</code>字段的值，也不能用不同<code>_id</code>字段值的替换文档来替换已存在的文档。</p></li><li><p>文档大小：<br>当执行更新操作增加的文档大小超过了为该文档分配的空间时，更新操作会在磁盘上重定位该文档。</p></li><li><p>字段顺序：<br>MongoDB按照文档写入的顺序整理文档字段。但<code>_id</code>字段始终是文档中第一个字段；<code>renaming</code>操作可能会导致文档中的字段重新排序。</p></li></ul><p><br></p><h3 id="Update-Operator"><a href="#Update-Operator" class="headerlink" title="Update Operator"></a>Update Operator</h3><p><strong>Fields</strong></p><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody><tr><td>$currentDate</td><td>将字段值设置为当前日期(date or timestamp)</td></tr><tr><td>$inc</td><td>按指定的数字递增字段的值</td></tr><tr><td>$min</td><td>指定的值小于字段的值时才更新</td></tr><tr><td>$max</td><td>指定的值大于字段的值时才更新</td></tr><tr><td>$mul</td><td>将字段的值乘以指定的数字</td></tr><tr><td>$rename</td><td>重命名一个字段</td></tr><tr><td>$set</td><td>设置文档中字段的值</td></tr><tr><td>$setOnInsert</td><td>如果更新导致文档插入，则设置字段的值</td></tr><tr><td>$unset</td><td>从文档中删除指定的字段，</td></tr></tbody></table><p><br></p><p><strong>Array</strong></p><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody><tr><td>$</td><td>用作更新与查询条件匹配的第一个元素的占位符</td></tr><tr><td>$[]</td><td>用作更新与查询条件匹配的文档的数组的所有元素的占位符</td></tr><tr><td>$[<identifier>]</identifier></td><td>xxx</td></tr><tr><td>$addToSet</td><td>在集合中不存在元素时添加元素到数组</td></tr><tr><td>$pop</td><td>移除数组中的第一项或最后一项</td></tr><tr><td>$pull</td><td>删除所有匹配指定查询的数组元素</td></tr><tr><td>$push</td><td>向数组中添加项</td></tr><tr><td>$pullAll</td><td>从数组中删除所有匹配的值</td></tr></tbody></table><p><br></p><p><strong>Modifiers</strong></p><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody><tr><td>$each</td><td>修饰$push and $addToSet， 向数组中添加多个项</td></tr><tr><td>$position</td><td>修饰$push，在数组中指定位置添加元素</td></tr><tr><td>$slice</td><td>修饰$push，限制更新数组的大小</td></tr><tr><td>$sort</td><td>修饰$push，重新排列存储在数组中的文档</td></tr></tbody></table><p><br></p><p><strong>BitWise</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$bit执行按位AND,OR,XOR更新</div></pre></td></tr></table></figure><p><br></p><h3 id="更新文档字段中指定字段"><a href="#更新文档字段中指定字段" class="headerlink" title="更新文档字段中指定字段"></a>更新文档字段中指定字段</h3><p>为了修改文档中的字段，MongoDB提供了<code>update operators</code>，如用来修改值的<code>$set</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&lt;update operator&gt;: &#123; &lt;field&gt;: &lt;value&gt;, ...&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">#更改指定字段的值</div><div class="line">db.user.update(</div><div class="line">&#123; _id: 1 &#125;,</div><div class="line">    &#123; $set: &#123;name: &quot;SET&quot;&#125; &#125;</div><div class="line">)</div><div class="line"></div><div class="line">#删除指定字段，文档中其他字段还在</div><div class="line">db.user.update(</div><div class="line">&#123; _id: 1 &#125;,</div><div class="line">    &#123; $unset: &#123;name: &quot;SET&quot;&#125; &#125;</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line">#</div><div class="line">db.user.updateMany(</div><div class="line">&#123; _id: 2&#125;,</div><div class="line">    &#123; $set: &#123;name: &quot;AAA&quot;, age: 222&#125; &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p><br></p><h3 id="文档替换-Replace"><a href="#文档替换-Replace" class="headerlink" title="文档替换(Replace)"></a>文档替换(Replace)</h3><p>当替换文档时，替换的文档必须仅仅有 <code>&lt;field&gt;: &lt;value&gt;</code>组成。<br>替换文档可以有不同于源文档的字段，但<code>_id</code>字段是不变的。</p><p>**建议使用<code>_id</code>作为过滤条件，因为它是唯一的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">db.collection.replaceOne()</div><div class="line"></div><div class="line"></div><div class="line">db.user.replaceOne(</div><div class="line">&#123; name: &quot;AAA&quot; &#125;,</div><div class="line">    &#123; name: &quot;A&quot;, age: 2, sex: &quot;man&quot;, favorites: &#123; artist: &quot;Dali&quot;, food: &quot;banana&quot; &#125; &#125;</div><div class="line">)</div><div class="line"></div><div class="line">db.user.update(</div><div class="line">&#123; _id: 1&#125;,</div><div class="line">    &#123; name: &quot;A&quot;, age: 2, sex: &quot;man&quot;, favorites: &#123; artist: &quot;Dali&quot;, food: &quot;banana&quot; &#125; &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="删除文档-Delete"><a href="#删除文档-Delete" class="headerlink" title="删除文档(Delete)"></a>删除文档(Delete)</h2><p><strong>方法：</strong></p><ul><li><code>db.collection.remove()</code>, 删除一个文档，或所有满足匹配的文档;</li><li><code>db.collection.deleteOne()</code>, 删除匹配最多条件的单个文档，即使可能有多个文档可能与指定过滤条件匹配;</li><li><code>db.collection.deleteMany()</code>, 删除所有匹配指定过滤条件的文档。</li></ul><p><br></p><h3 id="删除的行为表现"><a href="#删除的行为表现" class="headerlink" title="删除的行为表现"></a>删除的行为表现</h3><ul><li><p>Indexes<br>删除操作不会删除索引，即使从集合中删除了所有的文档。</p></li><li><p>原子性<br>MongoDB中所有的写操作在单一文档层级上是原子的。</p></li></ul><p><br></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#删除所有文档</div><div class="line">db.collectin.deleteMany(&#123;&#125;)</div><div class="line">db.collection.remove(&#123;&#125;)</div><div class="line"></div><div class="line"></div><div class="line">#删除所有满足条件的文档</div><div class="line">db.user.remove( &#123; name: &quot;A&quot; &#125; )</div><div class="line">db.user.deleteMany( &#123; name: &quot;A: &#125; )</div><div class="line"></div><div class="line"></div><div class="line">#仅删除一个满足条件最多的文档</div><div class="line">db.user.deleteOne( &#123; name: &quot;A&quot; &#125; )</div><div class="line"></div><div class="line">db.users.remove( &#123; name: &quot;A&quot;&#125;, 1)</div></pre></td></tr></table></figure><p><br></p><hr><p><br></p><h1 id="聚合-Agrregation"><a href="#聚合-Agrregation" class="headerlink" title="聚合(Agrregation)"></a>聚合(Agrregation)</h1><p>聚合操作处理数据记录并返回计算的结果。聚合操作将多个文档中的值(value)分组，并对分组的数据进行各类操作以返回单个结果。</p><p>MongoDB提供了三种方式进行聚合：</p><ul><li>aggregation pipeline(聚合管道);</li><li>map-reduce function(映射化简);</li><li>single aggregation methods(聚合指南)</li></ul><p><br></p><p><strong>Aggregation Pipeline(聚合管道)</strong></p><p>MongoDB的聚合框架(aggregation framework)是仿照数据处理管道的概念(concept)。Document输入多级管道，它将Document转换为聚合结果。</p><p>最基本的pipeline stage提供了：类似查询(query)操作的过滤器(filter)和类似修改(modify)输出文档格式的文档转换。</p><p>其他pipeline operation提供了按特定字段对文档进行分组和排序的工具，以及聚合数组内容(包括文档数组)的字段或工具。此外，pipeline stage可以使用运算符(operators)来处理任务。(如计算平均值和连接等…)</p><p>pipeline通过在MongoDB中使用本地操作，从而提供了高效的数据聚合。所以也是MongoDB中数据聚合的首选方法。</p><p>aggregation pipeline能够在一个共享的集合上操作。</p><p>aggregation pipeline可以使用索引来提高某些阶段的性能(performance)。另外，管道聚合还有一个内部优化阶段(optimization phase)。</p><p><img src="/images/MongoDB/aggregation-pipeline.png" alt="aggregation-pipeline"></p><p><br></p><p><strong>Map-Reduce(映射化简)</strong></p><p>一般来说，map-reduce操作有两个阶段：</p><ul><li>map stage: 处理每个文档并未每个输入文档发出一个或多个对象(object)；</li><li>reduce stage: 结合映射操作的输出。</li></ul><p>可选地，map-reduce有一个对结果做最后修改的最后阶段。与aggregation-operation类似，map-reduce可以指定查询条件来选择一个输入文档，以及对结果进行排序和限制。</p><p>map-reduce使用自定义的JavaScript函数执行映射和化简操作，以及可选的最终操作。与聚合管线相比，自定义的JavaScript提供了很大的灵活性。一般来说，map-reduce比aggregation pipeline效率更低，更复杂。</p><p>map-reduce能够在一个共享的集合上操作，同样也可以输出到共享集合。</p><p><img src="/images/MongoDB/map-reduce.png" alt="map-reduce"></p><p><br></p><p><strong>Single Purpose Aggregation Operations(聚合指南)</strong></p><p>MongoDB同样提供了<code>db.collection.count()</code>和<code>db.collection.distinct()</code>。</p><p>所有这些操作都从单个集合中聚合文档，虽然这些操作提供了对常见聚合过程的简单访问，但它们缺少aggregation pipeline和map-reduce的灵活性和功能。</p><p><img src="/images/MongoDB/distinct.png" alt="distinct"></p><p><br><br><br></p><h2 id="Aggregation-Pipeline-聚合管道"><a href="#Aggregation-Pipeline-聚合管道" class="headerlink" title="Aggregation Pipeline(聚合管道)"></a>Aggregation Pipeline(聚合管道)</h2><p>MongoDB的聚合框架是仿照数据处理管道的概念。文档输入多级管道，它将文档转换为聚合结果。</p><p>当map-reduce的复杂性可能是没有保证的，aggregation pipeline为map-reduce提供了一个可选也可能是聚合任务的首选解决方案。<br>aggregation pipeline对key value和result size有一些限制。</p><p><br><br><br></p><h2 id="映射化简"><a href="#映射化简" class="headerlink" title="映射化简"></a>映射化简</h2><p><br><br><br></p><h2 id="聚合指南"><a href="#聚合指南" class="headerlink" title="聚合指南"></a>聚合指南</h2><p><br></p><hr><p><br></p><h1 id="MongoDB文本索引"><a href="#MongoDB文本索引" class="headerlink" title="MongoDB文本索引"></a>MongoDB文本索引</h1><p>MongoDB支持在字符串内容上执行文本检索(text search)的查询操作。视图不支持文本检索。<br>为了执行文本检索，MongoDB使用<code>text index</code>和<code>$text</code>操作符。text索引可以包括任何值为字符串或字符串元素数组的字段。</p><p>栗子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.sample.insert(</div><div class="line">[</div><div class="line">&#123; _id: 1, name: <span class="string">"A"</span>, description: <span class="string">"AAA"</span> &#125;,</div><div class="line">        &#123; _id: 2, name: <span class="string">"B"</span>, description: <span class="string">"BBB"</span> &#125;,</div><div class="line">        &#123; _id: 3, name: <span class="string">"C"</span>, description: <span class="string">"CCC"</span> &#125;</div><div class="line">]</div><div class="line">)</div></pre></td></tr></table></figure><p>为了执行文本检索查询，你必须在集合有一个text索引，一个集合只能有<strong>一个</strong>文本检索索引，但是这个索引可以覆盖多个字段。</p><p>启动在<code>name</code>和<code>description</code>字段上的文本检索：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.sample.createIndex(</div><div class="line">&#123; name: <span class="string">"text"</span>, description: <span class="string">"text"</span> &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p>使用<code>$text</code>查询操作符在一个有<code>text index</code>的集合上执行文本检索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">db.sample.find(&#123;</div><div class="line">$text: &#123; $search: &quot;A B&quot; &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">#精确检索</div><div class="line">db.sample.find(&#123;</div><div class="line">$text: &#123; $search: &quot;A \&quot;B\&quot;&quot; &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"></div><div class="line">#词语排除</div><div class="line">db.sample.find(&#123;</div><div class="line">$text: &#123; $search: &quot;A B -AAA&quot; &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>MongoDB默认返回没排序的结果。然而文本检索将会对每个文档计算一个相关性分数，表明该文档与查询的匹配程度。<br>为了使用相关性分数进行排序，你必须使用 <code>$meta textScore</code>字段进行映射然后基于该字段进行排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.sample.find(</div><div class="line">&#123; $text: &#123; $search: &quot;A AAA B&quot; &#125; &#125;,</div><div class="line">    &#123; score: &#123; $meta: &quot;textScore&quot; &#125; &#125;</div><div class="line">).sort( &#123; score: &#123; $meta: &quot;textScore&quot; &#125; &#125;)</div></pre></td></tr></table></figure><p>文本检索可以在聚合管道中使用。</p><p><br><br><br></p><h2 id="文本索引"><a href="#文本索引" class="headerlink" title="文本索引"></a>文本索引</h2><p><br><br><br></p><h2 id="文本检索操作符"><a href="#文本检索操作符" class="headerlink" title="文本检索操作符"></a>文本检索操作符</h2><p><br><br><br></p><h2 id="在管道聚合中使用文本索引"><a href="#在管道聚合中使用文本索引" class="headerlink" title="在管道聚合中使用文本索引"></a>在管道聚合中使用文本索引</h2><p><br><br><br></p><h2 id="使用基本技术Rosette语义平台的文本索引"><a href="#使用基本技术Rosette语义平台的文本索引" class="headerlink" title="使用基本技术Rosette语义平台的文本索引"></a>使用基本技术Rosette语义平台的文本索引</h2><p><br><br><br></p><h2 id="文本检索语言"><a href="#文本检索语言" class="headerlink" title="文本检索语言"></a>文本检索语言</h2><p><br></p><hr><p><br></p><h1 id="MongoDB数据模型"><a href="#MongoDB数据模型" class="headerlink" title="MongoDB数据模型"></a>MongoDB数据模型</h1><p>MongoDB的数据具有灵活的模式，集合本身没有对文档结构的规则性校验。</p><p><br></p><h2 id="数据模型设计介绍"><a href="#数据模型设计介绍" class="headerlink" title="数据模型设计介绍"></a>数据模型设计介绍</h2><p>关系型数据库要求你再插入数据之前必须先定义好一个表的模式结构，而MongoDB的集合并不限制文档结构。<br>这种灵活性让对象和数据库文档之间的映射变得很容易。即使数据记录之间有很大的变化，每个文档也可以很好的映射到各条不同的记录。<br>当然，在实际使用中，同一个集合中的文档往往都有一个比较类似的结构。</p><p>数据模型设计中最具挑战性的是在应用程序需求，数据库引擎性能要求和数据读写模式之间的权衡考量。</p><p><br></p><h3 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h3><p><strong>引用(reference)</strong><br>引用方式通过<strong>存储链接</strong>或<strong>引用信息</strong>来实现两个不同文档之间的关联。<br>应用程序可以通过解析这些数据库引用来访问相关数据。简单来讲，这就是规范化的数据模型。</p><p><img src="/images/MongoDB/data-model-normalized.png" alt="规范化数据模型"></p><p><strong>内嵌(embedded data)</strong><br>内嵌方式指把相关联的数据保存在同一个文档之内。<br>MongoDB的文档结构允许一个字段或一个数组内的值为一个嵌套的文档。这种<strong>冗余</strong>的数据模型可以让应用程序在一个数据库内完成对相关数据的读取或修改。</p><p><img src="/images/MongoDB/data-model-denormalized.png" alt="内嵌式数据模型"></p><p><br></p><h3 id="写操作的原子性"><a href="#写操作的原子性" class="headerlink" title="写操作的原子性"></a>写操作的原子性</h3><p>在MongoDB中，写操作在文档级别是原子的(atomic)，没有一个单独的写操作可以原子地影响多个文档或多个集合。但，对原子性写操作利好的内嵌数据模型会限制应用程序对数据的使用场景。</p><ul><li>嵌入(embdded)数据的非规格化(denormalized)数据模型将单个文档所表示的实体(entity)的所有相关数据组合在一起。这有利于原子写操作，因为单个写操作可以插入或更新实体的数据；</li><li>规格化(normalizing)数据通过多个集合拆分数据，并需要多个不是原子集合的写操作。</li></ul><p><br></p><h3 id="文档的增长"><a href="#文档的增长" class="headerlink" title="文档的增长"></a>文档的增长</h3><p>如果文档的大小超出分配给文档的原空间大小，那么MongoDB就需要把文档从磁盘上的现有位置移动到一个新的位置以存放更多的数据。这种数据增长的情况也会影响到是否要使用规范化或非规范化。</p><p><br></p><h3 id="数据的使用和性能"><a href="#数据的使用和性能" class="headerlink" title="数据的使用和性能"></a>数据的使用和性能</h3><p>设计文档模型时，一定要考虑应用程序会如何使用你的数据。</p><p>例如：</p><ul><li>假如应用程序通常只会使用最近插入的文档，那么可以考虑使用限制集；</li><li>假如应用会做大量的读操作，那么可以加多一些索引的方法来提升常见查询的性能。</li></ul><p><br><br><br></p><h2 id="文档验证"><a href="#文档验证" class="headerlink" title="文档验证"></a>文档验证</h2><p>MongoDB提供了在更新和插入期间验证(validate)文档的功能(capability)。验证规则是在每个集合中指定使用验证符(validator)选项，利用一个文档指定验证堆栈或表达式。</p><ul><li>通过<code>collMod</code>命令附带验证符选项向一个已经存在的集合添加文档验证；</li><li>利用<code>db.createCollection()</code>命令附带验证符选项来创建文档验证规则。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.createCollection( <span class="string">"contacts"</span>,</div><div class="line">   &#123; validator: &#123; <span class="variable">$or</span>:</div><div class="line">      [</div><div class="line">         &#123; phone: &#123; <span class="variable">$type</span>: <span class="string">"string"</span> &#125; &#125;,</div><div class="line">         &#123; email: &#123; <span class="variable">$regex</span>: /@mongodb\.com$/ &#125; &#125;,</div><div class="line">         &#123; status: &#123; <span class="variable">$in</span>: [ <span class="string">"Unknown"</span>, <span class="string">"Incomplete"</span> ] &#125; &#125;</div><div class="line">      ]</div><div class="line">   &#125;</div><div class="line">&#125; )</div></pre></td></tr></table></figure><p>MongoDb同样提供了<code>validationLevel</code>选项，它确定了MongoDb在更新期间如何将验证规则应用到已有文档，以及验证操作选项。它确定MongoDB是否错误并<strong>拒绝</strong>违反验证规则的文档，或者<strong>警告</strong>日志中的违规，但允许无效的文档。</p><p><br></p><h3 id="行为-1"><a href="#行为-1" class="headerlink" title="行为"></a>行为</h3><p>验证发生在更新和插入期间。当向一个文档添加验证，在修改之前，现有文档不会进行验证检查。</p><p><br></p><p><strong>现有文档</strong></p><p>可使用<code>validationLevel</code>选项来控制MongoDB怎样处理现有文档。</p><p>默认情况下，<code>MongoDB</code>是严格的，并且将验证规则应用于所有插入和更新操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#moderate level</span></div><div class="line"><span class="comment">#在中等级别下，对不符合验证标准的现有文档更新将不会检查有效性</span></div><div class="line"></div><div class="line">db.runCommand(&#123;</div><div class="line">collMod: <span class="string">"contacts"</span>,</div><div class="line">    validator: &#123; <span class="variable">$or</span>: [ &#123; phone: &#123; <span class="variable">$exists</span>: <span class="literal">true</span> &#125; &#125;, &#123; email: &#123; <span class="variable">$exists</span>: <span class="literal">true</span>&#125;&#125; ] &#125;,</div><div class="line">    validationLevel: <span class="string">"moderate"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>设置<code>validationLevel</code>为<code>off</code>以禁用验证功能。</p><p><br></p><p><strong>接受或拒绝无效文档</strong></p><p><code>validationAction</code>选项决定了MongoDB如何处理违反(violate)验证规则的文档。</p><p>默认情况下，<code>validationAction</code>是错误的，并且拒绝任何违反验证条件的插入和更新操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#当validationAction为warn时，MongoDB记录所有违反行为，但允许插入或更新操作。</span></div><div class="line"></div><div class="line">db.createCollection( <span class="string">"contacts"</span>,</div><div class="line">   &#123;</div><div class="line">      validator: &#123; <span class="variable">$or</span>:</div><div class="line">         [</div><div class="line">            &#123; phone: &#123; <span class="variable">$type</span>: <span class="string">"string"</span> &#125; &#125;,</div><div class="line">            &#123; email: &#123; <span class="variable">$regex</span>: /@mongodb\.com$/ &#125; &#125;,</div><div class="line">            &#123; status: &#123; <span class="variable">$in</span>: [ <span class="string">"Unknown"</span>, <span class="string">"Incomplete"</span> ] &#125; &#125;</div><div class="line">         ]</div><div class="line">      &#125;,</div><div class="line">      validationAction: <span class="string">"warn"</span></div><div class="line">   &#125;</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#如下违规操作将会报警，并由于是warn，所以写入成功</span></div><div class="line">db.contacts.insert( &#123; name: <span class="string">"Amanda"</span>, status: <span class="string">"Updated"</span> &#125; )</div></pre></td></tr></table></figure><p><br></p><p><strong>约束(restriction)</strong></p><p>无法在<code>admin</code>,<code>local</code>,<code>config</code>数据库的集合 和 <code>system.*</code>集合 里面指定验证符(validator)。</p><p><br></p><p><strong>绕过文档验证</strong></p><p>通过<code>bypassDocumentValidation</code>选项来绕过文档验证。</p><p><br><br><br></p><h2 id="数据建模理论"><a href="#数据建模理论" class="headerlink" title="数据建模理论"></a>数据建模理论</h2><h3 id="数据模型设计"><a href="#数据模型设计" class="headerlink" title="数据模型设计"></a>数据模型设计</h3><p>一个高效的数据模型能够很好的满足应用程序的需求。设计一个文档数据结构最关键的考量就是决定是使用<strong>嵌套(embdded)</strong>还是<strong>引用(reference)</strong>。</p><p><br></p><h4 id="内嵌式数据模型-非规范化"><a href="#内嵌式数据模型-非规范化" class="headerlink" title="内嵌式数据模型(非规范化)"></a>内嵌式数据模型(非规范化)</h4><p>在MongoDB里面，可以把相关的数据包括在一个单个的结构或者文档下面。这样的数据模型也叫作<strong>非规范化</strong>模式。</p><p>内嵌数据可以让应用程序把相关的数据保存在同一条数据记录里面，这样，应用程序就可以发送较少的请求给MongoDB来完成常用的查询和更新请求。</p><p><br></p><p>一般来说，下述情况建议使用内嵌数据模型：</p><ul><li>数据对象之间有包含(contain)关系；</li><li>数据对象间有一对多的关系。</li></ul><p>通常情况下，内嵌数据会对读操作有比较好的性能提高，可以使应用程序在一个单个操作就可以完成对数据的读取。同时，内嵌数据也对更新相关数据提供了一个原子性写操作。</p><p><br></p><h4 id="规范化数据模型"><a href="#规范化数据模型" class="headerlink" title="规范化数据模型"></a>规范化数据模型</h4><p>一般来说，下述情况可以使用规范化模型：</p><ul><li>内嵌数据会导致很多数据的重复，并且读性能的优势又不足与盖过数据重复的弊端时；</li><li>需要表达比较复杂的多对多关系时；</li><li>大型多层次结构数据集。</li></ul><p><br></p><h3 id="MongoDB特性和数据模型的关系"><a href="#MongoDB特性和数据模型的关系" class="headerlink" title="MongoDB特性和数据模型的关系"></a>MongoDB特性和数据模型的关系</h3><p>MongoDB的数据建模不仅仅取决于应用程序的数据需求，也要考虑MongoDB本身的一些特性。</p><p><br></p><h4 id="文档增长性-increase"><a href="#文档增长性-increase" class="headerlink" title="文档增长性(increase)"></a>文档增长性(increase)</h4><p>如果更新操作导致文档大小增加，那么可能需要重新设计数据模型，在不同文档之间使用引用的方式而非内嵌、冗余的数据结构。<br>MongoDB会自动调整空白填充的大小以尽可能的减小文档迁移。你也可以使用一个<strong>预分配策略</strong>来防止文档的增长。</p><p><br></p><h4 id="原子性-atomic"><a href="#原子性-atomic" class="headerlink" title="原子性(atomic)"></a>原子性(atomic)</h4><p>在MongoDB中，所有在文档级别的操作都具有原子性。一个单个写操作最多只可以修改一个文档。即使是一个会改变同一个集合中多个文档的命令，在同一时间也只会操作一个文档。即便是涉及多个子文档的多个操作，只要是在同一文档之内，这些操作仍旧是有原子性的。</p><p>尽可能保证那些需要在一个原子操作内进行修改的字段定义在同一个文档里面。如果你的应用程序允许对两个数据的非原子性更新操作，那么可把这些数据定义在不同的文档内。</p><p>把相关数据定义到同一个文档里的内嵌方式有利于这种原子性操作。对于那些使用引用来关联相关数据的数据模型，应用程序必须再用额外的读和写操作去取回和修改相关的数据。</p><p><br></p><h4 id="分片-sharding"><a href="#分片-sharding" class="headerlink" title="分片(sharding)"></a>分片(sharding)</h4><p>MongoDB使用分片来实现水平扩展。使用分片的集群可以支持海量的数据和高并发读写。使用分片技术把一个数据库内的某一个集合的数据进行分区，从而达到把数据分到多个mongod实例(或分片上)的目的。</p><p>MongoDB依据<strong>分片键</strong>分发数据和应用程序的事务请求。选择一个合适的分片键对性能有很大的影响，也会促进或阻碍MongoDB的定向分片查询和增强的写性能。所以在选择分片键的时候要仔细考量分片键所用的字段。</p><p><br></p><h4 id="索引-index"><a href="#索引-index" class="headerlink" title="索引(index)"></a>索引(index)</h4><p>对常用操作可以使用索引来提高性能。对查询条件中常见的字段，以及需要排序的字段创建索引。<br>MongoDB会对<code>_id</code>自动创建唯一索引。</p><p>创建索引时，需要考虑索引的下述特征：</p><ul><li>每个索引要求至少8KB的数据空间；</li><li>每增加一个索引，就会对写操作性能有一些影响。对于一个写多读少的集合，索引会变得很费时。因为每个插入必须要更新所有索引；</li><li>每个索引都会占一定的硬盘空间和内存(对于活跃的索引)。索引可能会用到很多这样的资源，因此对这些资源要进行管理和规划，特别是在计算热点数据大小的时候。</li></ul><p><br></p><h4 id="集合的数量"><a href="#集合的数量" class="headerlink" title="集合的数量"></a>集合的数量</h4><p>某些情况下，可能需要把相关的数据保存到多个集合里面。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; log: &quot;dev&quot;, ts:..., info: ... &#125;</div><div class="line">&#123; log: &quot;debug&quot;, ts:..., info: ... &#125;</div></pre></td></tr></table></figure><p>一般来说，很大的集合数量对性能没有什么影响，反而在某些场景下有不错的性能。使用不同的集合在高并发批处理场景下会有很好的帮助。</p><p>当使用有大量集合的数据模型时，请注意：</p><ul><li>每个集合有几KB的额外开销；</li><li>每个索引(包含<code>_id</code>)，需要至少8KB的数据空间；</li><li>每个MongoDB的数据库有且仅有一个命名文件(namespace file)(<db>.ns)。这个命名文件保存了数据库的所有元数据，每个索引和集合在这个文件里都有一条记录；</db></li><li>MongoDB的命名文件有大小的限制(默认16MB)。利用<code>db.system.namespaces.count()</code>查看。</li></ul><p><br></p><h4 id="包含大量小文档的集合"><a href="#包含大量小文档的集合" class="headerlink" title="包含大量小文档的集合"></a>包含大量小文档的集合</h4><p>如果你有一个包含大量小文档的集合，则应该考虑为了性能而嵌入。如果你可以通过一些逻辑关系将这些小文档分组，并且你经常通过这个分组来检索文档，那么你应该考虑将小文档”卷起来”成为包含一系列嵌入式文档的大文档。</p><p>将这些小文档“卷起来”成为逻辑分组，意味着检索一组文档的查询设计顺序读取和较少的随机磁盘访问。此外，将文档“卷起”并将公共字段移动到较大的文档会使字段上的索引受益。公共字段的副本将会减少，并且相应索引中的关联键条目也会减少。</p><p>然而，如果你通常只需要检索分组中的一个文档的子集，那么“滚动”文档可能无法提供更好的性能。此外，如果晓得，独立的文档代表数据的自然模型，那你应该维护改模型。</p><p><br></p><h4 id="小文档的存储优化-storage-optimization"><a href="#小文档的存储优化-storage-optimization" class="headerlink" title="小文档的存储优化(storage optimization)"></a>小文档的存储优化(storage optimization)</h4><p>每个MongoDB文档都包含一定的开销(overhead)，这些开销通常是无关紧要的。但如果文档只有几个字节，那就相当重要了。</p><p>考虑以下有关优化这些集合的存储利用率的建议：</p><ul><li>显示地使用<code>_id</code>字段；</li><li>使用较短的字段名称；</li><li>嵌套文档。</li></ul><p><br></p><h4 id="数据生命周期管理"><a href="#数据生命周期管理" class="headerlink" title="数据生命周期管理"></a>数据生命周期管理</h4><p>数据模型决策应考虑数据生命周期管理。</p><p>集合的<em>*TTL功能</em>在一段时间后标识文档到期。如果应用程序需要一些数据才能在数据库中持久化一段有限的时间，请考虑使用TTL特性。</p><p>此外，你的应用程序仅使用最近插入的文档，请考虑限制集。</p><p><br><br><br></p><h2 id="数据模型例子与范式"><a href="#数据模型例子与范式" class="headerlink" title="数据模型例子与范式"></a>数据模型例子与范式</h2><h3 id="文档关系建模"><a href="#文档关系建模" class="headerlink" title="文档关系建模"></a>文档关系建模</h3><h4 id="一对一关系建模：内嵌文档模型"><a href="#一对一关系建模：内嵌文档模型" class="headerlink" title="一对一关系建模：内嵌文档模型"></a>一对一关系建模：内嵌文档模型</h4><p>用内嵌文档方式实现一对一关系。</p><h4 id="一对多关系建模：内嵌文档模型"><a href="#一对多关系建模：内嵌文档模型" class="headerlink" title="一对多关系建模：内嵌文档模型"></a>一对多关系建模：内嵌文档模型</h4><p>用内嵌文档方式实现一对多关系。</p><h4 id="一对多关系建模：文档引用模式"><a href="#一对多关系建模：文档引用模式" class="headerlink" title="一对多关系建模：文档引用模式"></a>一对多关系建模：文档引用模式</h4><p>用文档引用实现一对多关系。</p><p><br></p><h3 id="树结构建模"><a href="#树结构建模" class="headerlink" title="树结构建模"></a>树结构建模</h3><h4 id="父文档引用"><a href="#父文档引用" class="headerlink" title="父文档引用"></a>父文档引用</h4><p>父文档引用模式用一个文档来表示树的一个节点。每一个文档除了存储节点的信息，同时也保存该节点父节点文档的id值。</p><p><img src="/images/MongoDB/data-model-tree.png" alt="data-model-tree"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, parent: <span class="string">"Databases"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, parent: <span class="string">"Programming"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Programming"</span>, parent: <span class="string">"Books"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Books"</span>, parent: null &#125;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查询父节点</span></div><div class="line">db.test.findOne(&#123; _id: <span class="string">"MongoDB"</span> &#125;).parent</div><div class="line"></div><div class="line"><span class="comment">#对parent字段创建索引，这样可以快速的按照父节点查找</span></div><div class="line">db.test.createIndex(&#123; parent: 1 &#125;)</div><div class="line"></div><div class="line"><span class="comment">#查询一个父节点的所有子节点</span></div><div class="line">db.test.find(&#123; parent: <span class="string">"Databases"</span> &#125;)</div></pre></td></tr></table></figure><p><br></p><h4 id="子文档引用"><a href="#子文档引用" class="headerlink" title="子文档引用"></a>子文档引用</h4><p>子文档引用模式用一个文档来表示树的一个节点。每一个文档除了存储节点信息外，同时也用一个数组来保存该节点的所有子节点的id值。</p><p><img src="/images/MongoDB/data-model-tree.png" alt="data-model-tree"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, children: [] &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, children: [ <span class="string">"MongoDB"</span>, <span class="string">"dbm"</span> ]&#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Programming"</span>, children: [ <span class="string">"Languages"</span>, <span class="string">"Databases"</span> ]&#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Books"</span>, children: [ <span class="string">"Programming"</span> ]&#125;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查询子节点</span></div><div class="line">db.test.findOne(&#123; _id: <span class="string">"Databases"</span>&#125;).children</div><div class="line"></div><div class="line"><span class="comment">#对children字段创建索引，这样就可以快速按照子节点查找</span></div><div class="line">db.test.createIndex(&#123; children: 1 &#125;)</div><div class="line"></div><div class="line"><span class="comment">#查找一个子节点的父节点和同级节点</span></div><div class="line">db.test.find(&#123; children: <span class="string">"MongoDB"</span> &#125;)</div></pre></td></tr></table></figure><p><br></p><h4 id="祖先数组-ancestors-array"><a href="#祖先数组-ancestors-array" class="headerlink" title="祖先数组(ancestors array)"></a>祖先数组(ancestors array)</h4><p>祖先数组模式用一个文档来表示树的一个节点。每一个文档除了存储节点的信息，同时也存储了对父文档及祖先文档的id值。</p><p><img src="/images/MongoDB/data-model-tree.png" alt="data-model-tree"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, ancestors: [ <span class="string">"Books"</span>, <span class="string">"Programming"</span>, <span class="string">"Databases"</span> ], parent: <span class="string">"Databases"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, ancestors: [ <span class="string">"Books"</span>, Programming<span class="string">" ], parent: [ "</span>MongoDB<span class="string">", "</span>dbm<span class="string">" ]&#125;)</span></div><div class="line"><span class="string">db.test.insert(&#123; _id: "</span>Programming<span class="string">", ancestors: [ "</span>Books<span class="string">" ], parent: "</span>Books<span class="string">" &#125;)</span></div><div class="line"><span class="string">db.test.insert(&#123; _id: "</span>Books<span class="string">", ancestors: [ ], parent: null &#125;)</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#查询一个节点的祖先节点</span></div><div class="line"><span class="string">db.test.findOne(&#123; _id: "</span>MongoDB<span class="string">" &#125;).ancestors</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#对ancestors创建索引</span></div><div class="line"><span class="string">db.test.createIndex(&#123; ancestors: 1 &#125;)</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#利用ancestors字段来查找某个节点的所有子代节点</span></div><div class="line"><span class="string">db.test.find(&#123; ancetors: "</span>Programmming<span class="string">" &#125;)</span></div></pre></td></tr></table></figure><p><br></p><h4 id="物化路径-materialized-path"><a href="#物化路径-materialized-path" class="headerlink" title="物化路径(materialized path)"></a>物化路径(materialized path)</h4><p>物化路径模式将每个树节点存储在文档中。除了存储节点信息外，同时也存储了祖先文档或路径的id值。</p><p><img src="/images/MongoDB/data-model-tree.png" alt="data-model-tree"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"Books"</span>, path: null &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Programming"</span>, path: <span class="string">",Books,"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, path: <span class="string">",Books,Programming,"</span> &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, path: <span class="string">",Books,Programming,Databases,"</span> &#125;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查询整个树的所有节点并按path排序</span></div><div class="line">db.test.find().sort(&#123; path: 1 &#125;)</div><div class="line"></div><div class="line"><span class="comment">#可以在path字段上使用re来查询</span></div><div class="line">db.test.find(&#123; path: /,Programming,/ &#125;)</div><div class="line">db.test.find(&#123; path: /^,Books,/ &#125;)</div><div class="line"></div><div class="line"><span class="comment">#在path字段上创建索引</span></div><div class="line">db.test.createIndex(&#123; path: 1 &#125;)</div></pre></td></tr></table></figure><p><br></p><h4 id="嵌套集合-nested-set"><a href="#嵌套集合-nested-set" class="headerlink" title="嵌套集合(nested set)"></a>嵌套集合(nested set)</h4><p>嵌套集合模式对整个树结构进行一次深度优先的遍历。遍历时候对每个节点的压栈和出栈作为两个不同的步骤记录下来。每一个节点就是一个文档，除了节点信息外，文档还保存父节点的id以及遍历的两个步骤编号。压栈是的步骤保存到<strong>left字段</strong>里，而出栈时的步骤编号则保存到<strong>right字段</strong>里。</p><p><img src="/images/MongoDB/data-model-example-nested-set.png" alt="data-model-example-nested-set"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">db.test.insert(&#123; _id: <span class="string">"Books"</span>, parent: 0, left: 1, right: 12 &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Programming"</span>, parent: <span class="string">"Books"</span>, left: 2, right: 11 &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"Databases"</span>, parent: <span class="string">"Programming"</span>, left: 5, right: 10 &#125;)</div><div class="line">db.test.insert(&#123; _id: <span class="string">"MongoDB"</span>, parent: <span class="string">"Databases"</span>, left: 6, right: 7 &#125;)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查询摸个节点的子代节点</span></div><div class="line">db.test.find(&#123; left: &#123; <span class="variable">$gt</span>: db.test.findOne(&#123; _id: <span class="string">"Databases"</span> &#125;), right: &#123; <span class="variable">$lt</span>: db.test.findOne(&#123;<span class="string">"_id: "</span>Databases<span class="string">"&#125;) &#125; &#125;)</span></div></pre></td></tr></table></figure><p><br></p><h3 id="具体应用模型举例"><a href="#具体应用模型举例" class="headerlink" title="具体应用模型举例"></a>具体应用模型举例</h3><h4 id="原子性事务建模"><a href="#原子性事务建模" class="headerlink" title="原子性事务建模"></a>原子性事务建模</h4><p>如何使用内嵌技术来保证同一文档内相关字段更新操作的原子性。</p><p>举例来说，假设你在设计一个图书馆的借书系统，你需要管理书的库存量以及出借记录。一本书的可借数量加上借出数量的和必须等于总的保有量，那么对这两个字段的更新必须是原子性的。</p><p><br></p><h4 id="关键词搜索建模"><a href="#关键词搜索建模" class="headerlink" title="关键词搜索建模"></a>关键词搜索建模</h4><p>描述了一种把关键词保存在数组里并使用多键索引来实现关键词搜索功能的方法。</p><p>为实现关键词搜索，在文档内增加一个数组字段并把每一个关键词加到数组里。然后你可以对该字段建一个 多键索引。这样你就可以对数组里面的关键词进行查询了。</p><p><br></p><h4 id="货币数据建模"><a href="#货币数据建模" class="headerlink" title="货币数据建模"></a>货币数据建模</h4><p>处理货币数据的应用程序通常需要捕获小数(franctional)货币单位，并在执行算术时需要精确地模拟十进制四舍五入。许多现代系统(float,double)使用的基于二级制的浮点运算不能精确地表示小数，而且需要某种程度的近似，因而不适合于货币运算。因此，在货币数据建模时，这一约束是一个重要的考虑因素。</p><ul><li><p>数字模型<br>如果需要查询数据库中精确、数学书有效匹配或需要执行Server端算术，则数字模型可能是适合的。</p></li><li><p>非数字模型<br>如果需要在Server端做一些对货币数值的数学计算，那么严格精度可能会更合适一些。</p></li></ul><p><br></p><h4 id="时间数据模型"><a href="#时间数据模型" class="headerlink" title="时间数据模型"></a>时间数据模型</h4><p>MongoDB默认存储UTC时间，并将任何本地时间转换成这种形式。</p><p><br></p><hr><p><br></p><h1 id="MongoDB管理"><a href="#MongoDB管理" class="headerlink" title="MongoDB管理"></a>MongoDB管理</h1><p>administration</p><p><br></p><p>The administration 文档说明了MongoDB实例和部署正在进行的操作和维护。本文档包括这些问题的高级概述，以及涵盖操作MongoDB的特定过程的教程。</p><p><br><br><br></p><h2 id="操作清单-operation-checklist"><a href="#操作清单-operation-checklist" class="headerlink" title="操作清单(operation checklist)"></a>操作清单(operation checklist)</h2><p>如下清单，提供了帮助你避免在MongoDB部署中出现问题的建议。</p><p><br></p><h3 id="文件系统-file-system"><a href="#文件系统-file-system" class="headerlink" title="文件系统(file system)"></a>文件系统(file system)</h3><ul><li>将磁盘分区与RAID配置对齐；</li><li>避免对<code>dbpath</code>使用NFS。使用NFS会导致性能下降和不稳定；</li><li>针对Linux/Unix的文件格式，建议使用XFS或EXT4。如果可能的话，对MongoDB使用XFS性能会更好；</li><li>对于WiredTiger存储引擎，强烈建议使用XFS来避免使用EXT4时发现的性能问题；</li><li>针对Windows，不要使用FAT(FAT16/32/exFAT)文件系统，请使用NTFS文件系统。</li></ul><p><br></p><h3 id="复制-replication"><a href="#复制-replication" class="headerlink" title="复制(replication)"></a>复制(replication)</h3><ul><li>验证所有非隐藏副本集成员的RAM, CPU, 磁盘, 网络设置, 配置等方面是否相同；</li><li>配置<code>oplog</code>的大小来适合你的用例；</li><li>确保副本集包好至少3个以journaling方式运行的数据承载节点；</li><li>在配置副本集成员时使用主机名(hostname)，而不是IP地址；</li><li>确保所有的mongod实例之间使用全双工网络；</li><li>确保每台主机都能解析它自己；</li><li>确保副本集包含奇数个投票的成员(voting members)，确保票数不会相等则一定会有主被选举出来；</li><li>确保mongod实例有0或1票；</li><li>为了高可用(high availability)，副本集集群最少部署3台数据中心。</li></ul><p><br></p><h3 id="分片-sharding-1"><a href="#分片-sharding-1" class="headerlink" title="分片(sharding)"></a>分片(sharding)</h3><ul><li>将配置服务器放置于专用硬件，以便在大型集群中实现最佳性能。确保硬件有足够的RAM来讲数据文件完全存储到内存中，并且有专门的存储；</li><li>使用NTP同步分片集群上所有组件的时钟；</li><li>确保Mongod, mongos和配置服务器之间的全双工网络连接；</li><li>使用CNAME将配置服务器标识到集群中，以便可以在不停机的情况下重命名和重新编号配置服务器。</li></ul><p><br></p><h3 id="Journaling"><a href="#Journaling" class="headerlink" title="Journaling"></a>Journaling</h3><ul><li>确保所有实例都使用journaling；</li><li>将journal放置于低延迟(low-latency)磁盘上，用于编写密集的工作负载。注意，这将影响快照式备份(snapshot)，因为构成数据库状态的文件将驻留在单独的volume上。</li></ul><p><br></p><h3 id="硬件-hardware"><a href="#硬件-hardware" class="headerlink" title="硬件(hardware)"></a>硬件(hardware)</h3><ul><li>使用RAID10和SSD能够获得最佳性能；</li><li>确保每个mongod为它的dbpath提供了IOPS；</li><li>在虚拟环境中运行时，避免动态内存功能；</li><li>避免将所有副本集成员放置于相同的SAN(存储区网络)中。</li></ul><p><br></p><h3 id="部署到云上"><a href="#部署到云上" class="headerlink" title="部署到云上"></a>部署到云上</h3><ul><li>AWS;</li><li>Azure;</li><li>Aliyun;</li><li>Tencent.</li></ul><p><br></p><h3 id="操作系统配置"><a href="#操作系统配置" class="headerlink" title="操作系统配置"></a>操作系统配置</h3><p><strong>Linux</strong></p><ul><li>关闭<code>hugepages</code>和<code>defrag</code>；</li><li>调整存储数据库文件设备上的readahead设置，以适应用例；</li><li>在虚拟环境中的RHEL7/CENTOS7上禁用优化工具；</li><li>为SSD驱动使用<code>noop</code>或<code>deadline</code>磁盘调度；</li><li>禁用<code>NUMA</code>或将<code>vm.zone_reclaim_mode</code>设置为0，并运行<code>node interleaving</code>的mongod实例；</li><li>调整硬件的<code>ulimit</code>值以适应实例；</li><li>对dbpath挂载点使用<code>noatime</code>；</li><li>对你的部署配置足够的文件句柄(fs.file-max value of 98000)，内核pid限制(kernel.pid_max value of 64000)，每个进程的最大线程数(kernel.threads-max value 0f 64000)；</li><li>确保你的系统配置有swap交换分区；</li><li>确保系统默认TCP keepalived设置正确。</li></ul><p><strong>Windows</strong></p><ul><li>考虑禁用NTFS的最后访问时间更新。这类似与在Unix-like系统上禁用atime。</li></ul><p><br></p><h3 id="备份-backup"><a href="#备份-backup" class="headerlink" title="备份(backup)"></a>备份(backup)</h3><ul><li>安排备份和恢复过程的定期测试，以便手头有时间估计，并恢复其功能。</li></ul><p><br></p><h3 id="监控-monitor"><a href="#监控-monitor" class="headerlink" title="监控(monitor)"></a>监控(monitor)</h3><ul><li>监视Server的硬件统计信息(磁盘使用，CPU，可用磁盘空间…)</li><li>监视mongodb的状态。</li></ul><p><br></p><h3 id="负载均衡-load-balance"><a href="#负载均衡-load-balance" class="headerlink" title="负载均衡(load balance)"></a>负载均衡(load balance)</h3><ul><li>配置负载均衡启用”sticky session”或“client affinity”，对现有连接有足够的超时时间；</li><li>避免放置负载均衡器在MongoDb集群或副本集组件。</li></ul><p><br><br><br></p><h2 id="开发清单-development-checklist"><a href="#开发清单-development-checklist" class="headerlink" title="开发清单(development checklist)"></a>开发清单(development checklist)</h2><p>如下清单，提供了帮助你避免在MongoDB部署期间出现的问题的建议。</p><p><br></p><h3 id="数据持久性-data-durability"><a href="#数据持久性-data-durability" class="headerlink" title="数据持久性(data durability)"></a>数据持久性(data durability)</h3><ul><li>确保副本集至少包含3个(带有w:majority)数据承载节点，这3个数据承载节点需要为副本集的高数据持久性；</li><li>确保所有实例都是用了journaling。</li></ul><p><br></p><h3 id="架构设计-schema-design"><a href="#架构设计-schema-design" class="headerlink" title="架构设计(schema design)"></a>架构设计(schema design)</h3><p>MongoDB中的数据具有动态结构。collection并不要求document结构。这有助于迭代开发和多态性。然而，集合中的文档通常具有高度的同类结构。</p><ul><li>确保你需要的集合集中的索引(indexes)支持你的查询(query)。除了<code>_id</code>索引，你必须显式的创建所有索引；</li><li>确保你的架构设计支持你的开发类型；</li><li>确保你的架构设计不依赖于长度不受绑定的索引数组；</li><li>再架构设计时考虑文档大小限制。</li></ul><p><br></p><h3 id="复制-replication-1"><a href="#复制-replication-1" class="headerlink" title="复制(replication)"></a>复制(replication)</h3><ul><li>使用奇数个副本集成员以确保选举顺利进行。如果有偶数个成员，请使用仲裁者(arbiter)以确保级数的选票；</li><li>确保使用监控工具和适当的写关注来保持从库数据最新；</li><li>不要使用从库读取来扩展整体读取吞吐量。</li></ul><p><br></p><h3 id="分片-sharding-2"><a href="#分片-sharding-2" class="headerlink" title="分片(sharding)"></a>分片(sharding)</h3><ul><li>确保你的<code>sharded key</code>将负载均匀地分配到分片上；</li><li>对需要按分片数进行缩放的工作负载(workload)使用有针对性的操作；</li><li>对非目标(non-targeted)查询，总是从主节点读取可能对陈旧或孤立的数据很敏感；</li><li>当向新的非散列(hash)分片集合中插入大数据集时，Pre-split and manually balance chunks。</li></ul><p><br></p><h3 id="驱动-drivers"><a href="#驱动-drivers" class="headerlink" title="驱动(drivers)"></a>驱动(drivers)</h3><ul><li>使用连接池(connection pooling)；</li><li>确保你的应用程序在复制集选举期间还能够处理瞬时写入(transient write)和错误读取；</li><li>确保你的应用程序处理失败的请求并适时地重试它们；</li><li>使用指数退避逻辑重试数据库请求；</li><li>如果需要计算数据库操作的编译执行时间，对读操作使用<code>cursor.maxTimeMS()</code>，对写操作使用<code>wtimeout</code>。</li></ul><p><br><br><br></p><h2 id="性能-MongoDB-Perfomance"><a href="#性能-MongoDB-Perfomance" class="headerlink" title="性能(MongoDB Perfomance)"></a>性能(MongoDB Perfomance)</h2><ul><li>当遇到性能下降时，通常与数据库的访问策略、硬件可用性和开放的数据库连接数相关；</li><li>一些用户可能由于不适当的索引策略或结果不足而经历性能限制，或由于架构设计模式差；</li><li>性能问题可能表明数据库正以最大限度运行，是时候给数据库添加额外的容量(capacity)了。尤其是，应用程序的工作集应该有足够的物理内存。</li></ul><p><br></p><h3 id="锁紧性能-lock-performance"><a href="#锁紧性能-lock-performance" class="headerlink" title="锁紧性能(lock performance)"></a>锁紧性能(lock performance)</h3><ul><li>MongoDB使用锁系统来确保数据集的一致性。如果某些操作需要长时间运行(long-running)，或队列窗体，随着请求和操作等待<code>lock</code>，性能将会下降；</li><li>锁相关的减速是可以间歇的，可查看<code>lock</code>部分是否影响了性能；</li><li><code>locak.deadlockCount</code>提供了遭遇死锁(deadlocks)的次数；</li><li>如果<code>globalLock.currentQueue.total</code>很高，则可能有大量的请求在等待<code>lock</code>。这表明并发问题(concurrency issue)可能影响性能；</li><li>如果<code>globalLock.totalTime</code>时间比<code>uptime</code>高，那么数据库在锁定状态中存在了大量时间；</li><li>长查询(long query)可能会导致索引无效使用、非最佳(non-optimal)建构设计、差的查询结构、系统体系结构问题、RAM不足导致页面错误(page fault)和磁盘读取。</li></ul><p><br></p><h3 id="连接数-number-of-connections"><a href="#连接数-number-of-connections" class="headerlink" title="连接数(number of connections)"></a>连接数(number of connections)</h3><p>在某些情况下，应用程序和数据库之间的连接数量可能超出服务器处理请求的能力。<code>serverStatus</code>文档中的以下字段可以提供观察：</p><ul><li><code>globalLock.activeClients</code>包含正在进行或排队的活动操作的客户端总数；</li><li><code>connnections</code>由以下两个字段组成： 1，<code>connections.current</code>连接到数据库实例的当前客户端总数； 2，<code>connections.available</code>可用的连接总数。</li></ul><p>如果有大量的并发程序请求，则数据库可能无法满足需求。那么就需要增加部署的容量。</p><p>对于读操作巨大(read-heavy)的应用程序，增加你的副本集大小并将读操作分发给SECONDARY。<br>对于写操作巨大(write-heavy)的应用程序，部署分片并将一个或多个分片添加到分片集群中，以便在mongod实例之间分配负载。</p><p>连接数到达峰值也可能是应用程序或驱动错误所导致的结果。</p><p>除非收到系统范围的限制，否则MongoDB对传入连接没有限制。在基于Unix系统上，可使用<code>ulimit</code>命令或修改<code>/etc/sysctl</code>系统文件来修改系统限制。</p><p><br></p><h3 id="数据库性能分析-database-profiling"><a href="#数据库性能分析-database-profiling" class="headerlink" title="数据库性能分析(database profiling)"></a>数据库性能分析(database profiling)</h3><p>MongoDB的<strong>profiler</strong>是一种数据库分析系统，可以帮助识别低效的查询和操作。</p><p>有如下分析级别(profiling-level)可用：</p><table><thead><tr><th>Level</th><th>Settiing</th></tr></thead><tbody><tr><td>0</td><td>Off.No profiling</td></tr><tr><td>1</td><td>On.Only includes “slow” operations</td></tr><tr><td>2</td><td>On.Includes all operations</td></tr></tbody></table><p>在mongo shell中运行如下命令来配置性能分析器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#dbsetProfilingLever()</span></div><div class="line"></div><div class="line">db.setProfilingLevel(1)</div></pre></td></tr></table></figure><p><code>slowOpThresholdMs</code>的设置定义了什么是一个<code>slow</code>操作，要设置一个慢操作的阈值(threshold)，可以在运行时作为<code>db.setProfilingLevel()</code>操作的一个参数来配置<code>slowOpThresholdMs</code>。</p><p>默认情况下，mongod将会把所有的慢查询(slow query)记录到日志，这是由<code>slowOpThresholdMs</code>定义的。</p><p>通过在mongo shell中使用<code>show profile</code>，你可以在数据库中的<code>system.profile</code>集合中查看性能分析器的输出。<br>或者执行如下操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#返回超过100ms的所有操作，这个值请高于阈值`slowOpThresholdMs`</span></div><div class="line"></div><div class="line">db.system.profile.find(</div><div class="line">&#123; millis: &#123; <span class="variable">$gt</span>: 100 &#125; &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p>你必须使用查询操作符去访问<code>system.profile</code>文档中的查询字段。</p><p><br></p><h3 id="数据库性能分析器-databases-profiler"><a href="#数据库性能分析器-databases-profiler" class="headerlink" title="数据库性能分析器(databases profiler)"></a>数据库性能分析器(databases profiler)</h3><p>数据库性能分析器(db profiler)收集有关MongoDB的<strong>写操作、游标和运行在mongod实例上的命令</strong>的细微数据，你可以在每个数据库或每个实例基础上启用性能分析(profiling)。默认情况系，分析器是关闭的。启用profiling的时候需要配置<code>profiling leverl</code>。</p><p>The <code>database profiler</code>将所有的数据收集到<code>system.profile</code>集合中，它是一个限制集(capped collection)。</p><p><br></p><h4 id="分析等级-Profiling-levels"><a href="#分析等级-Profiling-levels" class="headerlink" title="分析等级(Profiling levels)"></a>分析等级(Profiling levels)</h4><ul><li>0， 关闭分析器，不收集任何数据。<code>mongod</code>总是将操作时间长于<code>slowOpThresholdMs</code>的值写入日志。这是默认分析器级别；</li><li>1， 只收集慢操作的分析数据。默认是以100ms；</li><li>2， 收集所有数据库操作的分析数据。</li></ul><p><br></p><h4 id="启用分析器-profiling-和设置分析级别-profiling-level"><a href="#启用分析器-profiling-和设置分析级别-profiling-level" class="headerlink" title="启用分析器(profiling)和设置分析级别(profiling level)"></a>启用分析器(profiling)和设置分析级别(profiling level)</h4><p>当启用<code>profiling</code>，也要设置<code>profiling level</code>，分析器将数据记录到<code>system.profile</code>集合。当你在数据库中启用profiling后，MongoDB会在数据库中创建<code>system.profile</code>集合。</p><p>使用<code>db.setProfilingLevel()</code>来设置<code>profiling level</code>和启用profiling。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.setProfilingLevel(1)</div></pre></td></tr></table></figure><p><br></p><p><strong>指定慢操作的阈值(the Threshold for slow operations)</strong></p><p>慢操作的阈值(threshold)应用于整个mongod实例。当你修改了阈值，那你就对所有的数据库实例进行了修改。修改了数据库慢操作的阈值同样也会影响整个mongod实例性能分析子系统的慢操作阈值。<br>默认情况下，慢操作的阈值为100ms。性能分析<code>level-1</code>将会记录长于阈值的慢操作到日志。</p><p>要更改阈值，请将两个参数(parameter)在<code>mongo shell</code>传递给<code>db.setProfilingLevel()</code>。第一个参数是为当前的数据库设置<code>profiling level</code>，第二个参数是为整个mongod实例设置默认的慢操作阈值。</p><p>栗子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mongo</div><div class="line"></div><div class="line">&gt;use zhang</div><div class="line">&gt;db.serProfilingLevel(1,100)</div><div class="line"></div><div class="line"><span class="comment">#会在zhang数据库下生产system.profile集合</span></div></pre></td></tr></table></figure><p><br></p><p><strong>检查分析等级(check profiling level)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.getProfilingStatus()</div><div class="line">#default</div><div class="line">#&#123; &quot;was&quot; : 0, &quot;slowms&quot; : 100 &#125;</div><div class="line"></div><div class="line"></div><div class="line">db.getProfilingLevel()</div><div class="line">#0</div></pre></td></tr></table></figure><p><br></p><p><strong>为一个完整的mongod实例启用profiling</strong></p><p>在测试环境中，处于开发目的，你可以为一个完整的mongod实例启用profiling功能。性能分析等级应用于mongod实例中的所有数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#设置level：1，slowOpThresholdMs: 50</div><div class="line">mongod --profile 1 --slowms 50</div></pre></td></tr></table></figure><p><br></p><p><strong>数据库分析和分片</strong></p><p>无法对mongos实例启用profiling。要对分片集群启用profiling功能，你必须对分片集群中的每个mongod实例启用profiling功能才行。</p><p><br></p><h4 id="查看性能分析器的数据-profiler-data"><a href="#查看性能分析器的数据-profiler-data" class="headerlink" title="查看性能分析器的数据(profiler data)"></a>查看性能分析器的数据(profiler data)</h4><p>数据库性能分析器关于数据库操作的日志信息放置于<code>system.profile</code>集合中。如需查看性能信息，请查询该集合。</p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">db.system.profile.find()</div><div class="line"></div><div class="line">db.system.profile.find().limit(10).sort(&#123; ts: -1 &#125;).pretty()</div><div class="line"></div><div class="line">#指定时间</div><div class="line">db.system.profile.find( &#123; millis: &#123; $gt: 5 &#125; &#125; ).pretty()</div><div class="line"></div><div class="line"></div><div class="line">#除了某个命令外</div><div class="line">db.system.profile.find(&#123; op: &#123; $ne: &apos;cmd&apos; &#125; &#125;).pretty</div><div class="line"></div><div class="line">#某个特定集合</div><div class="line">db.system.profile.find( &#123; ns: &apos;db.collection&apos; &#125; ).pretty()</div><div class="line"></div><div class="line"></div><div class="line">#显示最近的事件</div><div class="line">show profile</div></pre></td></tr></table></figure><p><br></p><h4 id="分析器开销-profiler-overhead"><a href="#分析器开销-profiler-overhead" class="headerlink" title="分析器开销(profiler overhead)"></a>分析器开销(profiler overhead)</h4><p>分析器对性能影响很小。<code>system.profile</code>集合是一个默认大小为1MB的限制集。这样大小的集合通常可以存储上千份分析文档，但一些应用程序可能在每次操作中只使用或多或少的分析数据。</p><p><br></p><p><strong>在Primary上面修改<code>system.profile</code>集合的大小</strong></p><ol><li>停止profiling；</li><li>删除(drop)<code>system.profile</code>集合；</li><li>新建一个<code>system.profile</code>集合；</li><li>重启profiling。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">use db</div><div class="line">db.serProfilingLevel(0)</div><div class="line">db.system.profile.drop()</div><div class="line">db.createCollection( &quot;system.profile&quot;, &#123; capped: true, size: 4000000 &#125; )</div><div class="line">db.setProfilingLevel(1)</div></pre></td></tr></table></figure><p><br></p><p><strong>在Secondary上修改<code>system.profile</code>集合的大小</strong></p><p>在Secondary上修改<code>system.profile</code>集合的大小，你必须停止Secondary，然后以standalone模式运行它，之后执行修改步骤。当做完上述步骤之后，以一个副本集成员的方式使用standalone模式重启它。</p><p><br><br><br></p><h3 id="禁用显见的大页面-Disable-Transparent-Huge-Pages"><a href="#禁用显见的大页面-Disable-Transparent-Huge-Pages" class="headerlink" title="禁用显见的大页面(Disable Transparent Huge Pages)"></a>禁用显见的大页面(Disable Transparent Huge Pages)</h3><p>Transpatent Huge Pages(THP)是一个Linux的内存管理系统，通过使用更大的内存页，减少了在具有大量内存的机器上进行Translation Lookaside Buffer(TLB)查找的开销。</p><p>然而，数据库工作负载(workload)在THP中的性能往往很差，因为它们往往具有稀疏的(sparse)而不是连续的(contiguous)内存访问模式。你应该在Linux机器上禁用THP来确保MongoDB获得最佳的性能。</p><p><br></p><p><strong>1. 创建<code>init.d</code>脚本</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment">### BEGIN INIT INFO</span></div><div class="line"><span class="comment"># Provides:          disable-transparent-hugepages</span></div><div class="line"><span class="comment"># Required-Start:    $local_fs</span></div><div class="line"><span class="comment"># Required-Stop:</span></div><div class="line"><span class="comment"># X-Start-Before:    mongod mongodb-mms-automation-agent</span></div><div class="line"><span class="comment"># Default-Start:     2 3 4 5</span></div><div class="line"><span class="comment"># Default-Stop:      0 1 6</span></div><div class="line"><span class="comment"># Short-Description: Disable Linux transparent huge pages</span></div><div class="line"><span class="comment"># Description:       Disable Linux transparent huge pages, to improve</span></div><div class="line"><span class="comment">#                    database performance.</span></div><div class="line"><span class="comment">### END INIT INFO</span></div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></div><div class="line">  start)</div><div class="line">    <span class="keyword">if</span> [ -d /sys/kernel/mm/transparent_hugepage ]; <span class="keyword">then</span></div><div class="line">      thp_path=/sys/kernel/mm/transparent_hugepage</div><div class="line">    <span class="keyword">elif</span> [ -d /sys/kernel/mm/redhat_transparent_hugepage ]; <span class="keyword">then</span></div><div class="line">      thp_path=/sys/kernel/mm/redhat_transparent_hugepage</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="built_in">return</span> 0</div><div class="line">    <span class="keyword">fi</span></div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">'never'</span> &gt; <span class="variable">$&#123;thp_path&#125;</span>/enabled</div><div class="line">    <span class="built_in">echo</span> <span class="string">'never'</span> &gt; <span class="variable">$&#123;thp_path&#125;</span>/defrag</div><div class="line"></div><div class="line">    re=<span class="string">'^[0-1]+$'</span></div><div class="line">    <span class="keyword">if</span> [[ $(cat <span class="variable">$&#123;thp_path&#125;</span>/khugepaged/defrag) =~ <span class="variable">$re</span> ]]</div><div class="line">    <span class="keyword">then</span></div><div class="line">      <span class="comment"># RHEL 7</span></div><div class="line">      <span class="built_in">echo</span> 0  &gt; <span class="variable">$&#123;thp_path&#125;</span>/khugepaged/defrag</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="comment"># RHEL 6</span></div><div class="line">      <span class="built_in">echo</span> <span class="string">'no'</span> &gt; <span class="variable">$&#123;thp_path&#125;</span>/khugepaged/defrag</div><div class="line">    <span class="keyword">fi</span></div><div class="line"></div><div class="line">    <span class="built_in">unset</span> re</div><div class="line">    <span class="built_in">unset</span> thp_path</div><div class="line">    ;;</div><div class="line"><span class="keyword">esac</span></div></pre></td></tr></table></figure><p><strong>2. 使之可执行</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 755 /etc/init.d/<span class="built_in">disable</span>-transparent-hugepages</div></pre></td></tr></table></figure><p><strong>3. 配置操作系统以在开机的时候运行它</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Debian系列</span></div><div class="line">update-rc.d <span class="built_in">disable</span>-transparent-hugepages defaults</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#RedHat系列</span></div><div class="line">chkconfig --add <span class="built_in">disable</span>-transparent-hugepages</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#SUSE</span></div><div class="line">insserv /etc/init.d/<span class="built_in">disable</span>-transparent-hugepages</div></pre></td></tr></table></figure><p><strong>4. 如果适用，覆盖(override)tuned和ktune</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#RedHat/CentOS7</span></div><div class="line">mkdir /etc/tuned/no-thp</div><div class="line"></div><div class="line"></div><div class="line">vim /etc/tuned/no-thp/tuned.conf</div><div class="line"></div><div class="line">[main]</div><div class="line">include=virtual-guest</div><div class="line">[vm]</div><div class="line">transparent_hugepages=never</div><div class="line"></div><div class="line"></div><div class="line">tuned-adm profile no-thp</div></pre></td></tr></table></figure><p><strong>5. 测试你做的改变</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cat /sys/kernel/mm/redhat_transparent_hugepage/enabled</div><div class="line">cat /sys/kernel/mm/redhat_transparent_hugepage/defrag</div><div class="line"></div><div class="line"><span class="comment">#always madvise [never]</span></div></pre></td></tr></table></figure><p><br></p><p><strong>另一种简便的方式来禁用THP</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vim /etc/rc.d/rc.local</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">'never'</span> &gt; /sys/kernel/mm/transparent_hugepage/enabled</div><div class="line"><span class="built_in">echo</span> <span class="string">'never'</span> &gt; /sys/kernel/mm/transparent_hugepage/defrag</div><div class="line"></div><div class="line">chmod u+x /etc/rc.d/rc.local</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Unix系统下的ulimit的设置"><a href="#Unix系统下的ulimit的设置" class="headerlink" title="Unix系统下的ulimit的设置"></a>Unix系统下的<code>ulimit</code>的设置</h3><p>大多Unix-Like系统，都提供了限制每个进程和每个基本用户使用线程，文件和网络连接等系统资源的一些方法。<br><strong>ulimits</strong>防止单个用户使用太多的系统资源。有时，这些限制的默认值太小，这会导致MongoDB操作过程中出现一系列问题。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#限制文件</span></div><div class="line"><span class="comment">#/etc/security/limits.conf</span></div><div class="line"><span class="comment">#/etc/security/limits.d/</span></div></pre></td></tr></table></figure><p><br></p><h4 id="资源利用"><a href="#资源利用" class="headerlink" title="资源利用"></a>资源利用</h4><p>mongod和mongos每次使用线程和文件描述符来跟踪连接和管理内部操作。</p><p>通常情况下，所有的mongod和mongos实例：</p><ul><li>利用每一个文件描述符和线程来跟踪每个即将到来的连接；</li><li>将每个内部线程或pthread作为一个系统进程来跟踪。</li></ul><p><br></p><p><strong>mongod</strong></p><ul><li>mongod实例使用的每个数据文件都有一个文件描述符；</li><li>当<code>storage.journal.enabled</code>为true是，mongod进程实例使用的每个日志文件都有一个文件描述符；</li><li>在复制集中，每个mongod保持一个连接复制集中所有其他集合成员的连接。</li></ul><p><strong>mongos</strong></p><ul><li>mongos实例与每个分片都保持一个连接池，所有mongos可以重用连接，这样因为不用建立新连接，从而能快速的满足请求；</li><li>通过限制连接数，可以防止mongos因在mongod实例上创建太多连接而产生级联效应。</li></ul><p><br></p><h4 id="资源限制的设置"><a href="#资源限制的设置" class="headerlink" title="资源限制的设置"></a>资源限制的设置</h4><p><code>ulimit</code>是指每个user使用各种资源的限制值。因此，无论你的mongod实例是以单个用户多进程执行还是以多mongod进程执行，都可以看到对这些资源的连接。</p><p>ulimits有<strong>hard</strong>和<strong>soft</strong>两个方式。</p><ul><li>hard：是指用户在任何时候都可以活动的进程的最大数量，这是上限。没有任何non-root进程能够增加hard ulimit；</li><li>soft：是对会话或进程实际执行的限制，但任何进程都可以将其增加到hard ulimit的最大值。</li></ul><p>较低的soft limit可能无法创建新线程(thread)，如果连接数太高，则关闭错误连接。因此，将soft和hard的值都设置为推荐值是非常重要的。</p><p>修改<code>ulimit</code>设置之后，要重启程序修改值才会有效。可通过<code>/proc</code>文件系统查看运行进程当前的限制值。</p><p>使用<code>ulimit</code>对系统限制的改变在系统重启后都会恢复到默认值。需要修改其它文件来确保修改一直生效。</p><p><strong>ulimit</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">ulimit</span> -a</div><div class="line"></div><div class="line">core file size          (blocks, -c) 0</div><div class="line">data seg size           (kbytes, -d) unlimited</div><div class="line">scheduling priority             (-e) 0</div><div class="line">file size               (blocks, -f) unlimited</div><div class="line">pending signals                 (-i) 7170</div><div class="line">max locked memory       (kbytes, -l) 64</div><div class="line">max memory size         (kbytes, -m) unlimited</div><div class="line">open files                      (-n) 1024</div><div class="line">pipe size            (512 bytes, -p) 8</div><div class="line">POSIX message queues     (bytes, -q) 819200</div><div class="line">real-time priority              (-r) 0</div><div class="line">stack size              (kbytes, -s) 8192</div><div class="line">cpu time               (seconds, -t) unlimited</div><div class="line">max user processes              (-u) 7170</div><div class="line">virtual memory          (kbytes, -v) unlimited</div><div class="line">file locks                      (-x) unlimited</div></pre></td></tr></table></figure><p><br></p><p><strong>修改ulimit</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-f (文件大小)</span></div><div class="line"><span class="comment">#-t (cpu 时间)</span></div><div class="line"><span class="comment">#-v (虚拟内存)</span></div><div class="line"><span class="comment">#-n (单个进程文件打开数)</span></div><div class="line"><span class="comment">#-m (memory size)</span></div><div class="line"><span class="comment">#-u (可打开的进程/线程)</span></div><div class="line"></div><div class="line"><span class="built_in">ulimit</span> -t unlimited</div><div class="line"><span class="built_in">ulimit</span> -u 64000</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="配置和维护-maintenance"><a href="#配置和维护-maintenance" class="headerlink" title="配置和维护(maintenance)"></a>配置和维护(maintenance)</h2><h3 id="Run-time-databases-configuration"><a href="#Run-time-databases-configuration" class="headerlink" title="Run-time databases configuration"></a>Run-time databases configuration</h3><p>command line和configuration file interfaces为MongoDB管理员提供了控制数据库系统操作的大量选项和设置。</p><p>使用配置文件启动MongoDB实例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mongod --config /etc/mongod.conf</div><div class="line">mongod -f /etc/mongod.conf</div></pre></td></tr></table></figure><p><br></p><h4 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h4><p>mongodb的配置文件从MongoDB3.0以后使用YAML格式。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line"></div><div class="line">processManagement:</div><div class="line">   fork: <span class="literal">true</span></div><div class="line">net:</div><div class="line">   bindIp: 127.0.0.1</div><div class="line">   port: 27017</div><div class="line">storage:</div><div class="line">   dbPath: /var/lib/mongodb</div><div class="line">systemLog:</div><div class="line">   destination: file</div><div class="line">   path: <span class="string">"/var/log/mongodb/mongod.log"</span></div><div class="line">   logAppend: <span class="literal">true</span></div><div class="line">storage:</div><div class="line">   journal:</div><div class="line">      enabled: <span class="literal">true</span></div></pre></td></tr></table></figure><p>对于大多数以standalone模式运行的servers，以上是一个足够的基本配置。<br>Unix-Like操作系统需要以超级用户(root)权限才能运行端口小于1024的程序。</p><p><br></p><h4 id="安全考虑-security-consideration"><a href="#安全考虑-security-consideration" class="headerlink" title="安全考虑(security consideration)"></a>安全考虑(security consideration)</h4><p>下面的配置选项集合对于限制对于mongod实例的访问非常有用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">net:</div><div class="line">   port: 27017</div><div class="line">   bindIp: 127.0.0.1,192.168.1.11</div><div class="line"></div><div class="line">security:</div><div class="line">   authorization: enabled</div></pre></td></tr></table></figure><p><br></p><h4 id="复制集和分片配置-replication-and-sharding-configuration"><a href="#复制集和分片配置-replication-and-sharding-configuration" class="headerlink" title="复制集和分片配置(replication and sharding configuration)"></a>复制集和分片配置(replication and sharding configuration)</h4><p>复制集的配置非常简单，只需要replSetName在集合中的所有成员具有一致的副本集名字。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">replication:</div><div class="line">  replSetName: zhang</div></pre></td></tr></table></figure><p>开启副本集认证：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#利用openssl生成keyFile</span></div><div class="line">openssl rand -base64 256 &gt; /dir/path/mongodb/keyFile</div><div class="line"></div><div class="line"></div><div class="line">security:</div><div class="line">  replSetName: zhang</div><div class="line">  keyFile: /dir/path/mongodb/keyfile</div><div class="line"></div><div class="line"></div><div class="line">chown -R mongod:mongod /dir/path/mongodb</div></pre></td></tr></table></figure><p>设置<code>keyFile</code>启用身份认证，并为复制集成员在相互身份认证时使用的认证文件指定一个密钥文件。密钥文件的内容是任意的，但在复制集中的所有成员和连接到该集合的mongos实例之间必须相同。不然怎么能认证通过呢。<br>秘钥文件的大小必须<strong>小于1KB</strong>，并且只能包含<strong>base64集</strong>中的字符，并且此密钥文件在Unix系统上必须<strong>not have group</strong>或<strong>not have world permissions</strong>。</p><p><br></p><h4 id="分片配置-sharding-configuration"><a href="#分片配置-sharding-configuration" class="headerlink" title="分片配置(sharding configuration)"></a>分片配置(sharding configuration)</h4><p>分片要求配置服务器和分片服务器的Mongod实例具有不同的mongod配置文件。配置服务器存储集群的元数据(metadata)，而分片服务器存储数据(data)。</p><p>在配置文件中给mongod实例配置<strong>配置服务器(config-server)</strong>，给<code>sharding.clusterRole</code>指定配置服务器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#配置config-server</span></div><div class="line"></div><div class="line">net:</div><div class="line">  bindIp: 192.168.1.11</div><div class="line">  port:27001</div><div class="line">replication:</div><div class="line">  replSetName: zhang</div><div class="line">sharding:</div><div class="line">  clusterRole: configserver</div><div class="line"><span class="comment">#configserver必须要是一个部署的副本集</span></div></pre></td></tr></table></figure><p><br></p><h4 id="在同一个系统上运行多个数据库实例-multiple-database-instances"><a href="#在同一个系统上运行多个数据库实例-multiple-database-instances" class="headerlink" title="在同一个系统上运行多个数据库实例(multiple database instances)"></a>在同一个系统上运行多个数据库实例(multiple database instances)</h4><p><strong>在许多情况下，在单个系统(single system)上运行多个数据库实例是不推荐的。</strong></p><p>但可能由于一些部署或者测试的目的，你需要在单个系统上运行多个mongod实例。在这些情况下，请为每一个mongod实例使用一个基本的配置文件，但要额外配置如下值：</p><ul><li>dbpath(必须);</li><li>pidFilePath(必须);</li><li>systemLog(非必须，但建议开启);</li></ul><p>栗子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#mongod_27017实例</span></div><div class="line">vim /etc/mongod_27017.conf</div><div class="line"></div><div class="line">systemLog:</div><div class="line">  path: /var/<span class="built_in">log</span>/mongod_27017.log</div><div class="line">storage:</div><div class="line">  dbPath: /var/lib/mongodb27017</div><div class="line">processManagement:</div><div class="line">  pidFilePath: /var/lib/mongodb27017/mongod_27017.pid</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#mongod_27018实例</span></div><div class="line">vim /etc/mongod_27018.conf</div><div class="line"></div><div class="line">systemLog:</div><div class="line">  path: /var/<span class="built_in">log</span>/mongod_27018.log</div><div class="line">storage:</div><div class="line">  dbPath: /var/lib/mongodb27018</div><div class="line">processManagement:</div><div class="line">  pidFilePath: /var/lib/mongodb27018/mongod_27018.pid</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##启动实例</span></div><div class="line">mongod -f /etc/mongod_27017.conf</div><div class="line">mongod -f /etc/mongod_27018.conf</div></pre></td></tr></table></figure><p><br></p><h4 id="诊断配置-diagnostic-configuration"><a href="#诊断配置-diagnostic-configuration" class="headerlink" title="诊断配置(diagnostic configuration)"></a>诊断配置(diagnostic configuration)</h4><p>以下配置选项可控制各种mongod行为，用以诊断的目的：</p><ul><li><code>operationProfiling.mode</code>设置<code>database profiler level</code>。profiler在默认情况下不处于活动状态，因为它本身可能会影响性能。除非启用它，否则不会对查询进行分析；</li><li><code>operationProfiling.slowOpThresholdMs</code>配置慢操作的阈值以确定查询是否<strong>慢</strong>，用以作为分析器记录日志的目的。默认阈值是100ms；</li><li><code>systemLog.verbosity</code>控制mongod写入日志的日志输出量。只有在遇到未在正常日志记录级别中反映的问题是才启用此选项。</li></ul><p><br><br><br></p><h3 id="升级-upgrade-到最新的MongoDB"><a href="#升级-upgrade-到最新的MongoDB" class="headerlink" title="升级(upgrade)到最新的MongoDB"></a>升级(upgrade)到最新的MongoDB</h3><p>修订(revisions)提供了security patches、bug fixes以及不包含任何反向破坏更改的新的或更改的功能。但是，最新版本也可能存在一些兼容性问题，请注意。</p><p><br></p><h4 id="升级之前-before-upgrading"><a href="#升级之前-before-upgrading" class="headerlink" title="升级之前(before upgrading)"></a>升级之前(before upgrading)</h4><ul><li>确保备份了最新的数据集；</li><li>有关特定MongoDb版本的特殊事项和兼容性问题，请注意查看；</li><li>如果你的安装包包括了复制集，在升级期间预定维护窗口(maintanence window)。</li></ul><p><br></p><h4 id="升级程序-upgrade-procedure"><a href="#升级程序-upgrade-procedure" class="headerlink" title="升级程序(upgrade procedure)"></a>升级程序(upgrade procedure)</h4><p><strong>在升级之前请一定要备份所有数据！</strong></p><p>按照如下步骤升级：</p><ol><li>对于使用认证的部署，首先升级所有的MongoDB drivers；</li><li>升级分片集群；</li><li>升级任一standalone实例；</li><li>升级不属于分片集群的任一副本集。</li></ol><p><br></p><h4 id="升级一个MongoDB实例"><a href="#升级一个MongoDB实例" class="headerlink" title="升级一个MongoDB实例"></a>升级一个MongoDB实例</h4><p>要升级mongod或mongos实例，使用如下方法之一：</p><ul><li>使用操作系统的包管理工具和官方MongoDB包进行升级(推荐的方法)；</li><li>使用新二进制文件替换现有二进制文件来升级实例。</li></ul><p><br></p><h4 id="替换现有二级制文件-replace-the-existing-binaries"><a href="#替换现有二级制文件-replace-the-existing-binaries" class="headerlink" title="替换现有二级制文件(replace the existing binaries)"></a>替换现有二级制文件(replace the existing binaries)</h4><p><strong>在升级MongoDB前请一定备份你的所有数据！</strong></p><p>首选的升级方式是使用包管理工具和官方的MongoDB包。</p><p>通过替换现有二进制文件来升级mongod或mongos实例，执行如下操作：</p><ol><li>下载最新MongoDB二进制文件到本地，并解压缩到MongoDB安装目录；</li><li>关闭实例；</li><li>替换二进制文件；</li><li>重启实例。</li></ol><p><br></p><h4 id="升级分片集群"><a href="#升级分片集群" class="headerlink" title="升级分片集群"></a>升级分片集群</h4><ol><li>禁用分片集群的平衡器(blancer)；</li><li>升级配置服务器(config-server)；</li><li>升级每个分片；</li><li>升级每个mongos实例；</li><li>重新启用平衡器。</li></ol><p><br></p><h4 id="升级复制集"><a href="#升级复制集" class="headerlink" title="升级复制集"></a>升级复制集</h4><p>若要升级复制集，请单独升级每个副本集成员。从Secondary开始，最后以Primary结束。</p><p><br></p><p><strong>升级SECONDARY</strong></p><ol><li>升级SECONDARY的mongod实例；</li><li>升级一个Secondary之后，在升级下一个实例之前，请等待Secondary恢复(recover)到SECONDARY state。使用<code>rs.status()</code>命令来检查复制集成员的状态。</li></ol><p><strong>升级PRIMARY</strong></p><ol><li>使用<code>rs.stepDown</code>命令来退出primary，以启动正常的故障转移过程；</li><li>查看是否有另外的SECONDARY节点成为了PRIMARY节点；</li><li>关闭并升级实例。</li></ol><p><br><br><br></p><h3 id="管理mongod进程"><a href="#管理mongod进程" class="headerlink" title="管理mongod进程"></a>管理mongod进程</h3><h4 id="开启mongod进程"><a href="#开启mongod进程" class="headerlink" title="开启mongod进程"></a>开启mongod进程</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mongod</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定数据目录</span></div><div class="line">mongod --dbpath /dir/mongodb/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#指定TCP端口</span></div><div class="line">mondod --port 12345</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#将mongod以守护进程的方式启动</span></div><div class="line">mongod --fork --logpath /var/<span class="built_in">log</span>/mongod.log</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#其他选项</span></div><div class="line">mongod --<span class="built_in">help</span></div></pre></td></tr></table></figure><p><br></p><h4 id="停止mongod进程"><a href="#停止mongod进程" class="headerlink" title="停止mongod进程"></a>停止mongod进程</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#使用shutdownServer()</span></div><div class="line">use admin</div><div class="line">db.shutdownServer()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#使用--shutdown</span></div><div class="line">mongod --shutdown</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#使用ctrl+c</span></div><div class="line">ctrl+c</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#使用kill</span></div><div class="line"><span class="comment">#千万不要使用kill -9(SIGKILL)来终止mongod</span></div><div class="line"><span class="built_in">kill</span> mongod_pid</div><div class="line"><span class="built_in">kill</span> -2 mongod_pid</div></pre></td></tr></table></figure><p><br></p><h4 id="停止一个复制集"><a href="#停止一个复制集" class="headerlink" title="停止一个复制集"></a>停止一个复制集</h4><p>步骤：</p><ol><li>检查SECONDARY的oplog的时间戳；</li><li>如果从节点的时间戳落后于主节点10s内，mongod将会返回不会被关闭的消息。你可以传递一个<code>timeoutSecs</code>参数给shutdown命令来等待从节点追上主节点；</li><li>一旦从节点追上进度或60s后，主节点将会关闭。</li></ol><p>强制关闭复制集：<code>db.adminCommand( { shutdown: 1, force: true } )</code></p><p>如果没有节点能立刻更新到最新的数据，发送<code>shutdown</code>加上<code>timeoutSecs</code>参数来在指定的时间内保持对从节点的检查。如果在分配的时间内有任意的一个从节点追上，主节点将会关闭。反之，主节点不会关闭。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.adminCommand(&#123; <span class="attr">shutdown</span>: <span class="number">1</span>, <span class="attr">timeoutSecs</span>: <span class="number">5</span> &#125;)</div><div class="line"></div><div class="line">#或</div><div class="line">db.shutdownServer(&#123; <span class="attr">timeoutSecs</span>: <span class="number">5</span>&#125;)</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="终止-Terminate-运行的操作"><a href="#终止-Terminate-运行的操作" class="headerlink" title="终止(Terminate)运行的操作"></a>终止(Terminate)运行的操作</h3><p>MongoDB提供了两种方法来终止正在运行的操作。</p><ul><li><code>maxTimeMS()</code></li><li><code>db.killOp()</code></li></ul><p><br></p><h4 id="maxTimeMS"><a href="#maxTimeMS" class="headerlink" title="maxTimeMS()"></a>maxTimeMS()</h4><p><code>maxTimeMS()</code>方法给一个操作(operation)设置了时间限制(time limit)。这个时间单位默认是毫秒(ms)。当这个操作达到了指定的时间限制时，MongoDB将在下一个中断点(interrupt point)中断这个操作。</p><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">db.location.find(</div><div class="line">  &#123;</div><div class="line"><span class="string">"town"</span>: &#123; <span class="string">"$regex"</span>: <span class="string">"(Pine Lumber)"</span>,</div><div class="line">    <span class="string">"$options"</span>: <span class="string">'i'</span> &#125;</div><div class="line">  &#125; ).maxTimeMS(<span class="number">30</span>)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">db.runCommand(</div><div class="line">  &#123;</div><div class="line">distinct: <span class="string">"collection"</span>,</div><div class="line">    key: <span class="string">"city"</span>,</div><div class="line">    maxTimeMS: <span class="number">45</span></div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p><br></p><h4 id="killOp"><a href="#killOp" class="headerlink" title="killOp"></a>killOp</h4><p><code>killOp()</code>方法将在下一个中断节点中断正在运行的操作。<code>killOp()</code>方法通过<strong>操作ID</strong>(operation ID)来标识目标操作。</p><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.killOp(&lt;opID&gt;)</div><div class="line"></div><div class="line"></div><div class="line">#查看正在运行的操作</div><div class="line">db.currentOp()</div></pre></td></tr></table></figure><p><strong>注意：</strong><br>终止正在运行的操作时一定要谨慎！只使用<code>db.killOp()</code>方法来终止由客户端发起的操作，而不要终止内部数据库(internal database)的操作。</p><p><br><br><br></p><h3 id="轮询-rotate-日志文件"><a href="#轮询-rotate-日志文件" class="headerlink" title="轮询(rotate)日志文件"></a>轮询(rotate)日志文件</h3><p>当使用<code>--logpath</code>选项或<code>systemLog.path</code>设置时，mongod或mongos实例会将所有活动和操作的实时账户报告给日志文件。默认情况下，只有当使用了<code>logRotate</code>命令，或者mongod或mongos进程从操作系统接收到一个<code>SIGUSR1</code>信号时，才会进行日志轮询响应。</p><p>MongoDB的标准日志轮询方法会存档当前日志文件并启动一个新的日志文件。为此，mongod或mongos实例将通过ISODate日期格式的UTC时间戳来重命名当前日志文件。然后它会打开一个新的日志文件，关闭旧的日志文件，并将所有新的日志发送到新的日志文件。</p><p>你也可以通过配置MongoDB的<code>systemLog.logRatate</code>或<code>--logRotate</code>选项，来支持Unix/Linux的日志轮询功能。<br>最后，你可以使用<code>--syslog</code>选项来配置mongod发送日志数据到系统日志。在这种情况下，你可以选用其他的日志轮询工具。</p><p><br></p><h4 id="默认日志轮询行为"><a href="#默认日志轮询行为" class="headerlink" title="默认日志轮询行为"></a>默认日志轮询行为</h4><p><strong>在mongo shell中轮询日志：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#开启一个实例</span></div><div class="line">mongod -v --logpath /var/<span class="built_in">log</span>/mongodb/test01.log</div><div class="line"></div><div class="line"><span class="comment">#列出日志文件</span></div><div class="line">ls /var/<span class="built_in">log</span>/mongodb/test01.log*</div><div class="line"></div><div class="line"><span class="comment">#轮询日志文件</span></div><div class="line">mongo</div><div class="line">&gt;use admin</div><div class="line">&gt;db.runCommand(&#123; logRotate: 1 &#125;)</div><div class="line"></div><div class="line"><span class="comment">#查看新的日志文件</span></div><div class="line">ls /var/<span class="built_in">log</span>/mongodb/test01.log*</div><div class="line"><span class="comment">#new: test01.log</span></div><div class="line"><span class="comment">#old: test01.log-2018-01-11T08-22-50</span></div></pre></td></tr></table></figure><p><strong>使用<code>--logRotate reopen</code>选项轮询日志：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mongod -v --logpath /var/<span class="built_in">log</span>/mongodb/test01.log --logRotate reopen --logapend</div><div class="line"></div><div class="line">ls /var/<span class="built_in">log</span>/mongodb/test01.log*</div><div class="line"></div><div class="line">mongo</div><div class="line">&gt;use admin</div><div class="line">&gt;db.runCommand(&#123; logRotate: 1 &#125;)</div></pre></td></tr></table></figure><p><br></p><h4 id="系统日志轮询-Syslog-log-rotate"><a href="#系统日志轮询-Syslog-log-rotate" class="headerlink" title="系统日志轮询(Syslog log rotate)"></a>系统日志轮询(Syslog log rotate)</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod --syslog</div></pre></td></tr></table></figure><p><br></p><h4 id="使用SIGUSR1强制日志轮询"><a href="#使用SIGUSR1强制日志轮询" class="headerlink" title="使用SIGUSR1强制日志轮询"></a>使用SIGUSR1强制日志轮询</h4><p>对于基于Unix/Linux的系统，可以使用<strong>SIGUSR1</strong>信号来轮询单个进程的日志。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">kill</span> -SIGUSR1 &lt;mongod-pid&gt;</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="数据中心意识-data-center-awareness"><a href="#数据中心意识-data-center-awareness" class="headerlink" title="数据中心意识(data center awareness)"></a>数据中心意识(data center awareness)</h2><h3 id="MongoDB部署中的分离-segregation-操作"><a href="#MongoDB部署中的分离-segregation-操作" class="headerlink" title="MongoDB部署中的分离(segregation)操作"></a>MongoDB部署中的分离(segregation)操作</h3><p>MongoDB拥有许多特性，包括允许数据库管理员和开发者在部署数据库的过程中通过一些功能或地理组群对数据库应用进行分割操作。</p><p>MongoDB支持跨越不同维度的操作的分段，这可能包括了在单个数据中心(single data center)的部署中的多数据中心(multi-date center)部署、机架、网络或电源电路的多个数据中心和地理区域。</p><p>MongoDB还支持基于功能或操作参数的数据库分离操作，以确保某些mongod实例仅用于报告工作负载，或只在特定的分片上分离集合的某些高频部分。</p><p><br></p><p>特别是在MongoDB中你可以：</p><ul><li>确保写操作传播到复制集的特定成员；</li><li>确保复制集中的特定成员响应了查询操作；</li><li>确保分片键在具体范围上的平衡，并且驻留在特定的分片上。</li></ul><p><br></p><h3 id="区域-zone"><a href="#区域-zone" class="headerlink" title="区域(zone)"></a>区域(zone)</h3><h4 id="管理分片区域-manage-shard-zones"><a href="#管理分片区域-manage-shard-zones" class="headerlink" title="管理分片区域(manage shard zones)"></a>管理分片区域(manage shard zones)</h4><p><br></p><h4 id="按位置分割数据-segementing-data-by-location"><a href="#按位置分割数据-segementing-data-by-location" class="headerlink" title="按位置分割数据(segementing data by location)"></a>按位置分割数据(segementing data by location)</h4><p><br></p><h4 id="为SLA或SLO改变分层硬件"><a href="#为SLA或SLO改变分层硬件" class="headerlink" title="为SLA或SLO改变分层硬件"></a>为SLA或SLO改变分层硬件</h4><p><br></p><h4 id="按应用程序或客户分割数据"><a href="#按应用程序或客户分割数据" class="headerlink" title="按应用程序或客户分割数据"></a>按应用程序或客户分割数据</h4><p><br></p><h4 id="Distributed-Local-Writes-for-Insert-Only-Workloads"><a href="#Distributed-Local-Writes-for-Insert-Only-Workloads" class="headerlink" title="Distributed Local Writes for Insert Only Workloads"></a>Distributed Local Writes for Insert Only Workloads</h4><p><br></p><h4 id="管理分片区域"><a href="#管理分片区域" class="headerlink" title="管理分片区域"></a>管理分片区域</h4><p><br><br><br></p><h2 id="MongoDB备份方案-backup-methods"><a href="#MongoDB备份方案-backup-methods" class="headerlink" title="MongoDB备份方案(backup methods)"></a>MongoDB备份方案(backup methods)</h2><p><strong>在生存中部署MongoDB时，如果发生数据丢失的事件，你应该指定一个捕获和恢复备份的策略(strategy)。</strong></p><p><br></p><p><strong>back up with MongoDB cloud manager or Ops manager</strong></p><ul><li>MongoDB Cloud Manager</li><li>Ops Manager</li></ul><p><br></p><p><strong>复制底层数据文件进行备份(back up by copying underlying data files)</strong></p><ul><li>使用文件系统快照备份(back up with filesystem snapshots)</li></ul><p>你可以通过复制MongoDB的底层数据文件来创建MongoDB部署的备份。<br>如果MongoDB储存其数据文件的卷(volume)支持时间点快照(point-in-time snapshots)，则可以使用这些快照在某个时刻创建MongoDB系统的备份。<br>文件系统的快照是一个操作系统的卷管理器的功能，并没有具体到MongoDB。通过文件系统快照，操作系统将卷的快照用作数据备份的基准。快照的机制取决于底层的存储系统。<br>例如，在Linux上，逻辑卷管理器(LVM)可以创建快照。</p><p>要获得运行中的MongoDB进程的正确快照，必须启用日志记录(jorunaling)，并且日志必须与其它MongoDB数据文件存储在相同的逻辑卷上。如果没有启用日志记录，则无法保证快照将是一致有效地。</p><p>为了获得分片集群一致的快照，你必须禁用平衡器(balancer)和捕捉每一个分片的快照以及大约在同一时刻的配置服务器。</p><ul><li>使用<code>cp</code>或<code>scp</code>备份</li></ul><p>如果你的系统不支持快照功能，则可以使用<code>cp</code>，<code>rsync</code>或类似的工具直接复制文件。<br>由于复制多个文件不是原子操作，因此你必须在复制文件之前停止对mongod的所有写入。否则，你将复制处于无效状态的文件。</p><p>复制底层数据而产生的备份不支持复制集的时间恢复节点，并且难以管理更大的共享集群。此外，这些备份很大。因为它们包括索引和复制底层存储填充和分片。<br>相反，<code>mongodump</code>会创建较小的备份。</p><ul><li>使用<code>mongodump</code>备份</li></ul><p>如果在<code>mongodump</code>创建备份的同时，应用程序对数据进行修改，那么<code>mongodump</code>将会与这些应用竞争资源。</p><p><code>mongodump</code>从一个MongoDB数据库中读取数据，并创建高保真度(high fidelity)的BSON文件。<code>mongorestore</code>工具可使用这个文件来进行MongoDB数据库恢复。<br><code>mongodump</code>和<code>mongorestore</code>是用于备份和恢复小型MongoDB部署的简单和高效的工具，但对于捕获较大的系统并不理想。</p><p><code>mongodump</code>和<code>mongorestore</code>针对正在运行的mongod进程进行操作，可以直接操纵底层的数据文件。默认情况下，<code>mongodump</code>不会捕获<code>local database</code>数据库的内容。</p><p><code>mongodump</code>只捕获数据库中的文档(documents)，用以给备份节省空间，但<code>mongorestore</code>或mongod必须在恢复数据之后重建索引。</p><p>当连接到MongoDB实例时，<code>mongodump</code>可能会对MongoDB的性能产生不利影响。如果你的数据大小大于系统内存，查询可能会将工作单元从内存中推开，从而导致页面错误。</p><p>当<code>mongodump</code>在捕获输出时，应用程序可以继续修改数据。对于复制集来说，<code>mongodump</code>提供了<code>--oplog</code>选项来用以在<code>mongodump</code>操作期间包含数据的oplog条目。这允许相应的<code>mongorestore</code>操作去还原所捕获的oplog。</p><p>然而，对于复制集来说，请考虑使用MongoDB Cloud Manager 或 Ops Manager来备份。</p><p><br><br><br></p><h3 id="使用文件系统快照进行备份和恢复-back-up-and-restore-with-filesystem-snapshots"><a href="#使用文件系统快照进行备份和恢复-back-up-and-restore-with-filesystem-snapshots" class="headerlink" title="使用文件系统快照进行备份和恢复(back up and restore with filesystem snapshots)"></a>使用文件系统快照进行备份和恢复(back up and restore with filesystem snapshots)</h3><p>使用系统工具创建MongoDB系统的备份，诸如<strong>LVM</strong>，或<strong>block-level</strong>备份方法。使用系统工具来创建MongoDB数据文件的设备的副本。这些方法完成迅速、工作可靠，但是需要在MongoDB之外进行额外的系统配置。</p><p><br></p><h4 id="快照综述-snapshots-overview"><a href="#快照综述-snapshots-overview" class="headerlink" title="快照综述(snapshots overview)"></a>快照综述(snapshots overview)</h4><p>快照的工作方式是在实时数据(live data)和一个特定快照卷之间创建指针(pointer)。这个指针在理论上等同于<strong>硬链接(hard link)</strong>。作为工作数据偏离的快照，快照过程使用<strong>写时复制</strong>(copy-on-write)策略。结果，快照又只存储修改的数据。</p><p>创建快照后，在文件系统上挂载(mount)快照镜像，并从中复制数据。生成的备份包含所有数据的完整副本。</p><p><br></p><p><strong>Valid database at the time of snapshot</strong></p><p>当快照生成时数据库必须有效。这就意味着数据库所接收的所有写入(write)都需要完整的写入磁盘————无论是<code>journal</code>还是数据文件。<br>如果备份发生时磁盘上没有写入(write)，备份将不反映这些更改。</p><p>对于WiredTiger storage engine，数据文件反映了最后一个检查点(last checkpoint)的一致状态。每2GB的数据或每分钟就会出现检查点。</p><p><br></p><p><strong>Entire disk image</strong></p><p>快照创建一个整个磁盘镜像的镜像。除非你需要备份你的整个系统，否则考虑隔离(isolate)你的MongoDB数据文件、journal，并配置一个不包含任何其他数据的逻辑磁盘。<br>或者，将所有的MongoDB数据文件保存在一个专用的设备上，这样你就可以在没有重复(duplicating)和无关(extraneous)数据的情况下进行备份。</p><p><br></p><p><strong>Site failure precaution</strong></p><p>确保将数据从快照复制到其他系统。这确保了在站点故障(site failure)的时候数据是安全的。</p><p><br></p><p><strong>No incremental backups</strong></p><p>本教程不包含增量备份(incremental backups)的过程。虽然不同的快照方法提供了不同的功能，但下面列出的LVM方法不提供捕获增量备份的任何容量。</p><p><br></p><p><strong>Snapshots with journaling</strong></p><p>如果你的mongod实例启用了journaling，则可以使用任何类型的文件系统和volume/block level快照工具来创建备份。</p><p>如果你在基于Linux的系统上管理你自己的基础架构，请使用LVM配置你的系统以提供磁盘包并提供快照功能。</p><p><br></p><h4 id="在Linux上使用LVM进行备份和还原"><a href="#在Linux上使用LVM进行备份和还原" class="headerlink" title="在Linux上使用LVM进行备份和还原"></a>在Linux上使用LVM进行备份和还原</h4><p>生产备份系统必须考虑一些特定环境的应用程序特定需求和因素。</p><p><br></p><p><strong>Crete a snapshot</strong></p><ul><li>确保你创建的快照具有足够的空间来考虑数据的增长；</li><li>如果快照超出了空间，快照镜像将无法使用。请放弃这个逻辑卷并创建另外一个；</li><li>命令执行完毕时快照将存在。你可以随时直接从快照进行还原，也可以创建新的逻辑卷并从此快照还原到备用镜像；</li><li>虽然快照对于快速创建高质量的备份非常好，但它们并不是理想的作为存储备份数据的格式；</li><li>快照通常取决于并位于与原始磁盘镜像相同的存储基础架构上。因此，将这些快照存档并将其存储在别处至关重要。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#下面的这个vg-name指卷组名，这个卷组首先需要建立</span></div><div class="line"><span class="comment">#系统卷组和设备的位置和路径可能因LVM的配置二略有不同</span></div><div class="line"><span class="comment">#此大小不反映数据大小</span></div><div class="line"></div><div class="line">lvcreate --size 1G --snapshot --name mongodb-snap20180111 /dev/vg-name/mongodb</div></pre></td></tr></table></figure><p><br></p><p><strong>Archive a snapshot</strong></p><p>创建好snapshot之后，挂载<code>mount</code>快照并将数据复制到单独的存储中。</p><p>压缩快照：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">umount /dev/vg-name/mongodb-snap01</div><div class="line">dd <span class="keyword">if</span>=/dev/vg-name/mongodb-snap01 | gzip &gt; mongodb-snap01.gz</div></pre></td></tr></table></figure><p><br></p><p><strong>Restore a snapshot</strong></p><p>同样适用LVM进行还原。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#lv-mongodb, vg0-vgname</span></div><div class="line"></div><div class="line">lvcreate --size 1G --name mongodb vg0</div><div class="line">gzip -d -c mongodb-snap01.gz | dd of=/dev/vg0/mongodb</div><div class="line">mount /dev/bg0/mongodb /dir/path</div></pre></td></tr></table></figure><p>还原的快照中有一个陈旧的<code>mongo.lock</code>文件，如果你没有从快照中删除此文件，那么MongoDB可能会认为锁文件指示的是不正常的关闭。如果你开启了<code>storage.journal.enabled</code>，但没有使用<code>db.fsyncLock()</code>的话，那不需要删除<code>mongo.lock</code>文件，反之，删除它。</p><p><br></p><p><strong>Restore directly form a snapshot</strong></p><p>不使用gz压缩文件下还原备份。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">umount /dev/vg-name/mongodb-snap01</div><div class="line">lvcreate --size 1G --name mongodb vg0</div><div class="line">dd <span class="keyword">if</span>=/dev/vg0/mongodb-snap01 of=/dev/vg0/mongodb</div><div class="line">mount /dev/vg0/mongodb /dir/path</div></pre></td></tr></table></figure><p><br></p><p><strong>Remote backup storage</strong></p><p>可以使用组合的进程和SSH实施离线备份。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">umount /dev/vg-name/mongodb-snap01</div><div class="line">dd <span class="keyword">if</span>=/dev/vg0/mongodb-snap01 | ssh user@host gzip &gt; /dir/path/mongodb-snap01.gz</div><div class="line">lvcreate --size 1G --name mongodb vg0</div><div class="line">ssh user@host gzip -d -c /dir/path/mongodb-snap-01.gz | dd of =/dev/vg0/mongodb</div><div class="line">mount /dev/vg0/mongodb /dir/path</div></pre></td></tr></table></figure><p><br></p><h4 id="使用单独卷上的Journal日志文件或没有Journal日志文件进行备份实例"><a href="#使用单独卷上的Journal日志文件或没有Journal日志文件进行备份实例" class="headerlink" title="使用单独卷上的Journal日志文件或没有Journal日志文件进行备份实例"></a>使用单独卷上的Journal日志文件或没有Journal日志文件进行备份实例</h4><p>从MongoDB3.2开始，为了使用WiredTiger对MongoDB实例进行volume-level备份，数据文件和Journal日志文件不再要求驻留在一个卷上。</p><p>如果你的mongod实例没有使用Journal，或者启用了将Journal志文件放置于一个单独的卷上，则必须刷新(flush)对磁盘的所有写入，并在备份期间锁住数据库用以阻止写操作。<br>如果有复制集(replica set)配置，那么你可以在SECONDARY上不接收读取用以备份数据。</p><p><br></p><p><strong>1. 刷新写入磁盘并锁定数据库以防止进一步的写入：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#锁住数据库</div><div class="line">db.fsyncLock();</div></pre></td></tr></table></figure><p><strong>2. 使用快照备份数据库：</strong></p><p><strong>3. 解锁数据库：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#解锁数据库</div><div class="line">db.fsyncUnlock();</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用MongoDB工具进行备份和恢复-back-up-and-restore-with-MongoDB-tools"><a href="#使用MongoDB工具进行备份和恢复-back-up-and-restore-with-MongoDB-tools" class="headerlink" title="使用MongoDB工具进行备份和恢复(back up and restore with MongoDB tools)"></a>使用MongoDB工具进行备份和恢复(back up and restore with MongoDB tools)</h3><p>使用MongoDB提供的备份还原工具——<code>mongodump</code>和<code>mongorestore</code>来处理BSON data，对于创建小型部署的备份是很有用的。<br>对于弹性(resilient)备份和非破坏性(non-disruptive)备份，使用文件系统或块级磁盘快照。</p><p>因为<code>mongodump</code>和<code>mongorestore</code>操作通过与正在运行中的<code>mongod</code>实例进行交互(interacting)，它们会影响正在运行的数据库的性能(performance)。这些工具不仅会为正在运行的数据库实例创建流量，还会强制数据库通过内存读取所有的数据。当MongoDB读取不经常(infrequently)使用的数据时，它会驱逐(evict)频繁(frequently)访问的数据，导致数据库正常工作负载的性能下降。</p><p><br></p><p>当使用MongoDB’s tools 来备份你的数据时，考虑如下建议：</p><ul><li>标签文件(label file)，以便你可以识别备份的内容以及备份所反映的时间点</li><li>如果对你来说，<code>mongodump</code>和<code>mongorestore</code>对性能的影响是不可接受的，请使用替代备份策略——filesystem snapshot或MongoDB CloudManager</li><li>使用<code>--oplog</code>去捕获在<code>mongodump</code>期间的传入写(write)操作，以确保备份一致性的数据状态</li><li>通过将备份文件还原到测试环境中，以确认备份是可用的</li></ul><p><br></p><h4 id="MongoDB-tools"><a href="#MongoDB-tools" class="headerlink" title="MongoDB tools"></a>MongoDB tools</h4><p><strong>MongoDB工具介绍及区别：</strong></p><ul><li><p>mongoexport<br><code>mongoexport</code> is a utility that produces a <strong>JSON or CSV</strong> export of data stored in a MongoDB instance.</p></li><li><p>mongoimport<br>The <code>mongoimport</code> tool imports content from an <strong>Extended JSON, CSV, or TSV</strong> export created by mongoexport, or potentially, another third-party export tool.</p></li><li><p>mongodump<br><code>mongodump</code> is a utility for creating a <strong>binary export of the contents of a database</strong>. mongodump can export data from either mongod or mongos instances.<br>mongodump excludes the content of the local database in its output.<br>The mongodump utility backs up data by connecting to a running mongod or mongos instance.</p></li><li><p>mongorestore<br>The <code>mongorestore</code> program writes data from a <strong>binary database dump</strong> created by mongodump to a MongoDB instance.</p></li></ul><p><br></p><h4 id="步骤-Procedures"><a href="#步骤-Procedures" class="headerlink" title="步骤(Procedures)"></a>步骤(Procedures)</h4><h5 id="使用mongodump备份"><a href="#使用mongodump备份" class="headerlink" title="使用mongodump备份"></a>使用mongodump备份</h5><ul><li>`mongodump·备份数据库，如果数据库启用了访问控制，则必须拥有每个备份的数据库查询的权限。内置的备份角色提供了执行任何和数据库备份有关所需的权限。</li><li>这就意味着你使用<code>mongodump</code>的user必须要对所备份的数据库有读取权限。</li><li><code>mongodump</code>能够为<strong>整个服务器、数据库或集合</strong>创建备份，或者使用查询仅备份集合的一部分。</li><li><code>mongodump</code>默认排除<code>local</code>数据库。</li><li><code>mongodump</code>必须要能够连接到正在运行的mongod或mongos实例。默认连接为127.0.0.1:27017。</li><li><code>mongodump</code>默认创建在当前目录下创建./dump备份文件。</li><li>如果<code>mongodump</code>备份目录中已经存在备份数据目录，那么<code>mongodump</code>将会覆盖它们。</li><li>指定认证库来认证你的用户名和密码。</li></ul><p><br></p><p><strong>使用oplog进行时间点操作</strong></p><ul><li>在<code>mongodump</code>中使用<code>--oplog</code>选项来收集oplog条目，用以在副本集中构建数据库的实时快照。</li><li>使用<code>--oplog</code>，<code>mongodump</code>会从源数据库复制所有的数据，包括备份开始到结束这段时间所有的oplog记录。</li><li>在<code>mongorestore</code>还原时使用<code>--oplogReplay</code>选项，允许你还原特定时间节点的备份。这就对应在<code>mongodump</code>期间oplog的记录。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#127.0.0.1:27017 ./dump</span></div><div class="line">mongodump</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--host,-h  --port</span></div><div class="line">mongodump -h mongodb.example.net --port 27107</div><div class="line">mongudump -h 127.0.0.1 --port 27018</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#-o, --out</span></div><div class="line">mongoodump -o /var/mongodb_backup/</div><div class="line">mongodump --host 127.0.0.1 --port 27017 --out /var/mongodb_backup/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--collection, --db</span></div><div class="line">mongodump --db zhang --out /var/mongodb_backup/zhang</div><div class="line">mongodump --db zhang --collection <span class="built_in">test</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--authenticationDatabase</span></div><div class="line">mongodump --port 27018 -u zhang -p <span class="string">"passwd"</span>  --authenticationDatabase admin -d zhang -o /var/mongodb_backup/zhang</div></pre></td></tr></table></figure><p><br></p><h4 id="使用mongorestore还原"><a href="#使用mongorestore还原" class="headerlink" title="使用mongorestore还原"></a>使用mongorestore还原</h4><p>若要将数据还原到启用了访问控制的MongoDB部署，如果备份数据不包括<code>system.profile</code>集合数据，则restore角色提供了对数据库的访问权限。</p><p>如果备份数据包含了<code>system.profile</code>集合并且目标数据库不包含<code>system.profile</code>集合，那么<code>mongorestore</code>会去创建这个集合即使<code>mongorestore</code>并没有还原<code>system.profile</code>文档。因此，用户就需要额外的权限才能在<code>system.profile</code>集合中上执行<code>createCollection</code>和<code>convertToCapped</code>。</p><p>如果使用<code>--oplogReplay</code>，这个restore角色还不足以重放oplog。所以如果需要重放oplog，请使用一个能够重放oplog的角色。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mongorestore /var/mnogodb_backup</div><div class="line"></div><div class="line"></div><div class="line">mongorestore /var/mnogodb_backup --oplogReplay</div><div class="line"></div><div class="line"></div><div class="line">mongorestore --port 27018 -u zhang -p <span class="string">"passwd"</span> --authecticationDatabase admin -d zhang /var/mongodb_back/zhang</div></pre></td></tr></table></figure><p><br></p><h4 id="批量化操作mongo-shell-EOF"><a href="#批量化操作mongo-shell-EOF" class="headerlink" title="批量化操作mongo shell(EOF)"></a>批量化操作mongo shell(<code>EOF</code>)</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> coll <span class="keyword">in</span> &#123;collection1,collection2,...&#125;</div><div class="line"><span class="keyword">do</span></div><div class="line">mongo host:port/db -u x -p xx &lt;&lt; EOF</div><div class="line">    use db</div><div class="line">    db.<span class="variable">$coll</span>.drop()</div><div class="line">    EOF</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="从MongoDB备份中还原副本集"><a href="#从MongoDB备份中还原副本集" class="headerlink" title="从MongoDB备份中还原副本集"></a>从MongoDB备份中还原副本集</h3><p>你不能将单个数据集(data set)还原为三个新的mongod实例，然后为此创建一个副本集(replication set)。<br>如果你将数据集复制到每个mongod实例，然后创建副本集，则MongoDB将强制SECONDARY执行<code>initial sync</code>。</p><p><br></p><h4 id="向一个单一副本集节点中还原数据-Restore-Database-into-a-Single-Node-Replica-Set"><a href="#向一个单一副本集节点中还原数据-Restore-Database-into-a-Single-Node-Replica-Set" class="headerlink" title="向一个单一副本集节点中还原数据(Restore Database into a Single Node Replica Set)"></a>向一个单一副本集节点中还原数据(Restore Database into a Single Node Replica Set)</h4><ol><li><p>获取备份数据库文件</p></li><li><p>使用备份数据库文件作为数据库路径启动一个mongod实例</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#方法1，直接启动</span></div><div class="line">mongod --dbpath /dir/path/mongodump --replSet &lt;replName&gt;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#方法2，使用配置文件启动，推荐</span></div><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">storage:</div><div class="line">  dbPath: /dir/path/mongodump</div><div class="line">replication:</div><div class="line">  replSetName: zhang</div></pre></td></tr></table></figure><ol><li><p>连接到mongo shell</p></li><li><p>初始化这个新的副本集</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#对于有且仅有一个成员的副本集使用rs.initiate()</div><div class="line">rs.initiate()</div></pre></td></tr></table></figure><p><br></p><h4 id="向副本集中添加成员-Add-Members-to-the-Replica-Set"><a href="#向副本集中添加成员-Add-Members-to-the-Replica-Set" class="headerlink" title="向副本集中添加成员(Add Members to the Replica Set)"></a>向副本集中添加成员(Add Members to the Replica Set)</h4><p>MongoDB对于还原副本集SECONDARY节点提供了两种选择：</p><ol><li>手动复制数据库文件到数据目录</li><li>允许<code>initial sync</code></li></ol><p><strong>建议：</strong></p><blockquote><p>如果备份的数据库文件很大，那么<code>initial sync</code>可能需要很长的时间才能完成。对于大型数据库，最好将数据库文件复制到每台主机上。</p></blockquote><p><br></p><h5 id="Copy-Database-File-and-Restart-mongod-Instance"><a href="#Copy-Database-File-and-Restart-mongod-Instance" class="headerlink" title="Copy Database File and Restart mongod Instance"></a>Copy Database File and Restart mongod Instance</h5><ol><li>Shut down the mongod instance that you restored</li></ol><blockquote><p>使用 <code>--shutdown</code> 或 <code>db.shutdownServer()</code>来确保一个正常干净的关闭</p></blockquote><ol><li><p>复制Primary的数据目录到每个从节点</p></li><li><p>Start the mongod instance that you restorerd</p></li><li><p>Add the secondaries to the replica set</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PRIMARY&gt;rs.add()</div></pre></td></tr></table></figure><p><br></p><h5 id="Update-Secondaries-using-Initial-Sync"><a href="#Update-Secondaries-using-Initial-Sync" class="headerlink" title="Update Secondaries using Initial Sync"></a>Update Secondaries using Initial Sync</h5><ol><li>确保副本集成员的数据目录为空</li><li>将每个潜在成员添加到副本集</li></ol><p><br><br><br></p><h3 id="备份和还原分片集群-sharded-cluster"><a href="#备份和还原分片集群-sharded-cluster" class="headerlink" title="备份和还原分片集群(sharded cluster)"></a>备份和还原分片集群(sharded cluster)</h3><p><br></p><h4 id="通过文件系统快照-fs-snapshots-备份一个分片集群"><a href="#通过文件系统快照-fs-snapshots-备份一个分片集群" class="headerlink" title="通过文件系统快照(fs snapshots)备份一个分片集群"></a>通过文件系统快照(fs snapshots)备份一个分片集群</h4><p><br></p><h4 id="通过Database-Dumps备份一个分片集群"><a href="#通过Database-Dumps备份一个分片集群" class="headerlink" title="通过Database Dumps备份一个分片集群"></a>通过Database Dumps备份一个分片集群</h4><p><br></p><h4 id="Schedule-Backup-Window-for-Sharded-Clusters"><a href="#Schedule-Backup-Window-for-Sharded-Clusters" class="headerlink" title="Schedule Backup Window for Sharded Clusters"></a>Schedule Backup Window for Sharded Clusters</h4><p><br></p><h4 id="还原一个分片集群"><a href="#还原一个分片集群" class="headerlink" title="还原一个分片集群"></a>还原一个分片集群</h4><p><br><br><br></p><h3 id="从意外关闭中恢复-Recover-a-standalone-after-an-unexpected-shutdow"><a href="#从意外关闭中恢复-Recover-a-standalone-after-an-unexpected-shutdow" class="headerlink" title="从意外关闭中恢复(Recover a standalone after an unexpected shutdow)"></a>从意外关闭中恢复(Recover a standalone after an unexpected shutdow)</h3><p>当一个standalone模式的mongod实例关闭了journaling功能后，一个unclean的shutdown可能会导致数据处于不一致的状态。<br>当unclean shutdown之后，如果在dbPath下存在一个非空的<code>mongod.lock</code>文件，则mongod实例会记录如下信息：</p><blockquote><p>Dectected unclean shutdown - mongod.lock is not empty</p></blockquote><p>这样的话你必须要修复你的数据库，才能正常的启动mongod。</p><blockquote><p><strong>警告：</strong><br>不要用如下方法处理副本集 unclean shutdown。相反，你应该从备份或者从另一个副本集的成员恢复。</p></blockquote><p>默认情况下，MongoDB在启用journaling的情况下运行，以防止发生unclean shutdown时数据不一致的问题。</p><p>使用运行mongod实例的那个用户来进行修复，避免由权限不一致而导致的新问题。</p><ol><li>Create a backup of the data files</li><li>Start mongod with –repair</li></ol><p><br><br><br></p><h2 id="监控-Monitoring-MongoDB"><a href="#监控-Monitoring-MongoDB" class="headerlink" title="监控(Monitoring)MongoDB"></a>监控(Monitoring)MongoDB</h2><p>监控是数据库管理的重要组成部分，充分了解MongoDB的运行状态，并在没有危机的情况下维护和部署。此外，了解MongoDB的正常操作参数将允许你在问题升级成为故障前诊断他们。</p><p><br></p><h3 id="Monitoring-for-MongoDB"><a href="#Monitoring-for-MongoDB" class="headerlink" title="Monitoring for MongoDB"></a>Monitoring for MongoDB</h3><p><br></p><h4 id="Monitoring-Strategies-策略"><a href="#Monitoring-Strategies-策略" class="headerlink" title="Monitoring Strategies(策略)"></a>Monitoring Strategies(策略)</h4><p>有三种方法可以从运行中的MongoDB实例中收集状态信息：</p><ol><li>MongoDB提供的一组实时上报程序，提供数据库活动的实时报告；</li><li>数据库命令以更大的保真度返回有关当前数据库状态的统计信息；</li><li>MongoDB Atlas，MongoDB Cloud Manager；</li></ol><p>每个策略在不同的情况下都是很有用的，所以它们能够很好地进行互补。</p><p><br></p><h4 id="MongoDB-Reporting-Tools"><a href="#MongoDB-Reporting-Tools" class="headerlink" title="MongoDB Reporting Tools"></a>MongoDB Reporting Tools</h4><p><strong>Utilities</strong></p><p>MongoDB提供了许多可以返回活动统计信息的实用工具，这对于诊断问题和评估操作非常有用。</p><ul><li><code>mongostat</code><br>  <code>mongostat</code>按类型捕获并返回数据库操作的计数(insert,query,update,delete…)</li></ul><p><img src="/images/MongoDB/mongostat.png" alt="mongostat"></p><ul><li><code>mongotop</code><br>  <code>mongotop</code>通过类型捕获和返回数据库操作(insert,query,update,delete)</li></ul><p><img src="/images/MangoDB/mongotop.png" alt="mongotop"></p><p><br></p><h4 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h4><p>MongoDB包含了许多上报数据库状态的命令。这些命令可以提供比上面的实用程序更精细的粒度级别。考虑在脚本和程序中使用它们的输出来开发自定义警报。<br><code>db.currentOp</code>方法是一个识别当前数据库实例正在进行的操作。</p><ul><li><p><code>db.serverStatus()</code><br>  <code>db.serverStatus()</code>，返回数据库状态的一般概述，详细的磁盘使用，内存使用，连接，journaling日志和索引访问。它返回快速并不影响MongoDB性能。</p></li><li><p><code>db.stats()</code><br>  <code>db.stats()</code>，提供了database上的统计信息。返回使用的存储量，数据库包含的数据量及对象，collection和索引计数器。</p></li></ul><p><img src="/images/MongoDB/dbstats.png" alt="dbStats"></p><ul><li><p><code>db.collection.stats()</code><br>  <code>db.collection.stats()</code>，提供了collection上的统计信息。包含集合中的对象数量，结合大小，集合磁盘空间用量，索引信息。</p></li><li><p><code>rs.status()</code><br>  <code>rs.status()</code>，返回一个复制集状态的概述。</p></li></ul><p><br></p><h4 id="第三方工具"><a href="#第三方工具" class="headerlink" title="第三方工具"></a>第三方工具</h4><p>许多第三方(third party)工具支持对MongoDB的监控。</p><ul><li>Nagios</li><li>Zabbix</li><li>Ganglia</li><li>Motop</li><li>…</li></ul><p><br><br><br></p><h3 id="Monitor-MongoDB-with-SNMP-on-Linux"><a href="#Monitor-MongoDB-with-SNMP-on-Linux" class="headerlink" title="Monitor MongoDB with SNMP on Linux"></a>Monitor MongoDB with SNMP on Linux</h3><p><strong>SNMP is only available in MongoDB Enterprise</strong></p><p><br></p><h3 id="Monitor-MongoDB-Windows-with-SNMP"><a href="#Monitor-MongoDB-Windows-with-SNMP" class="headerlink" title="Monitor MongoDB Windows with SNMP"></a>Monitor MongoDB Windows with SNMP</h3><p><br></p><hr><p><br></p><h1 id="MongoDB索引"><a href="#MongoDB索引" class="headerlink" title="MongoDB索引"></a>MongoDB索引</h1><p>Indexes</p><p><br></p><p>索引支持在MongoDB中高效地(effecient)执行查询。没有索引，MongoDB就必须采取collection scan。扫描每个集合中的每个文档，用以匹配查询。如果查询存在适当的索引，则MongoDB可以使用该索引来限制它必须检查的文档数量。</p><p>索引是特殊的数据结构，将集合数据集中的一小部分以易于遍历(traverse)的形式存储。索引存储特定字段或字段集的值，按字段值排序。索引条目的排序支持高效的相等匹配和基于范围的查询操作。除此之外，MongoDB可以使用索引中的排序返回排序后的结果。</p><p><img src="/images/MongoDB/index_sort.png" alt="栗子"></p><p><br></p><p>从根本上来说(fundamentally)，MongoDB中的索引类似于其他数据库的索引。MongoDB在collection级别定义索引，并支持集合的文档的任何字段或子字段上的索引。</p><p><br></p><p><strong>默认<code>_id</code>索引</strong><br>    在创建一个collection期间，MongoDB在<code>_id</code>字段上创建一个唯一的索引。你也可以自定义<code>_id</code>的值。你不能在<code>_id</code>字段上删除此索引。</p><p><strong>创建一个索引</strong><br>    <code>db.collection.createIndex</code>方法只有在同一规范不存在时才创建索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.collection.createIndex(&lt;key and index type&gt;, option)</div></pre></td></tr></table></figure><p><strong>索引类型</strong><br>MongoDB提供了许多不同的索引类型来支持特定类型的数据和查询。</p><ul><li><p>Single Field<br>  除了MongoDB定义的<code>_id</code>索引，MongoDB还支持在文档的单个字段上创建用户自定义的升序(ascending)/降序(descending)索引。<br>  对于单字段索引和排序操作，MongoDB可以在任何方向遍历索引。<br><img src="/images/MongoDB/SingleField.png" alt="单字段索引"></p></li><li><p>Compound(复合) Index<br>  MongoDB也支持多个字段的用户自定义索引。<br><img src="/images/MongoDB/CompundIndex.png" alt="复合索引"></p></li><li><p>Multikey Index<br>  MongoDB使用多键索引来索引存储在数组中的内容。<br><img src="/images/MongoDB/MultikeyIndex.png" alt="多键索引"></p></li><li><p>Geospatial(地理空间) Index<br>  为了支持对地理空间坐标数据的有效查询，MongoDB提供了两个特殊的索引：<code>2d index</code>返回平面几何的2D索引；<code>2dsphere index</code>返回球形几何结果。</p></li><li><p>Text Index<br>  MongoDB提供了一个文本(text)类型索引，用以支持搜索集合中的字符串内容(string content)。</p></li><li><p>Hashed(散列) Index<br>  为了支持基于散列的分片，MongoDB提供了散列索引类型，它索引字段值的散列值。但只支持相等的匹配，而不能支持基于范围的查询。</p></li></ul><p><br></p><p><strong>Index Properties(特性)</strong></p><ul><li><p>Unique Index<br>  索引的唯一性是MongoDB拒绝索引字段的重复值。</p></li><li><p>Partial Index<br>  部分索引仅索引复合指定过滤器表达式的集合中的文档。</p></li><li><p>Sparse(稀疏) Index<br>  索引的稀疏属性确保索引仅包含具有索引字段的文档的条目，跳过没有索引字段的文档。</p></li><li><p>TTL Index<br>  TTL索引是MongoDB可以用来在一定时间后自动从集合中删除文档的特殊索引。对于某些类型的消息，如机器生成的事件数据，日志和会话信息等，只需在数据库库中保存有限的时间，这是非常理想的。</p></li></ul><p><br></p><p><strong>Index Use</strong><br>索引能够提高读操作的效率。</p><p><br></p><p><strong>Index and Collation</strong><br>要使用索引进行字符串比较，操作还必须指定相同的排序规则。</p><p><br><br><strong>Coverd Query</strong><br>当查询条件和查询投影仅包含索引字段时，MongoDB将直接从索引返回结果，而不扫描任何文档或将文档带入内存。</p><p><br></p><h2 id="Single-Filed-Index"><a href="#Single-Filed-Index" class="headerlink" title="Single Filed Index"></a>Single Filed Index</h2><p><br><br><br></p><h2 id="Compound-Index"><a href="#Compound-Index" class="headerlink" title="Compound Index"></a>Compound Index</h2><p><br><br><br></p><h2 id="Multikey-Index"><a href="#Multikey-Index" class="headerlink" title="Multikey Index"></a>Multikey Index</h2><p><br><br><br></p><h2 id="Text-Index"><a href="#Text-Index" class="headerlink" title="Text Index"></a>Text Index</h2><p><br></p><h2 id="2dsphere-Index"><a href="#2dsphere-Index" class="headerlink" title="2dsphere Index"></a>2dsphere Index</h2><p><br><br><br></p><h2 id="2d-Index"><a href="#2d-Index" class="headerlink" title="2d Index"></a>2d Index</h2><p><br><br><br></p><h2 id="geoHaystack-Index"><a href="#geoHaystack-Index" class="headerlink" title="geoHaystack Index"></a>geoHaystack Index</h2><p><br><br><br></p><h2 id="Hashed-Index"><a href="#Hashed-Index" class="headerlink" title="Hashed Index"></a>Hashed Index</h2><p><br><br><br></p><h2 id="Index-Property"><a href="#Index-Property" class="headerlink" title="Index Property"></a>Index Property</h2><p><br><br><br></p><h2 id="Index-Build-Operation-on-a-Populated-Collection"><a href="#Index-Build-Operation-on-a-Populated-Collection" class="headerlink" title="Index Build Operation on a Populated Collection"></a>Index Build Operation on a Populated Collection</h2><p><br><br><br></p><h2 id="Index-Intersection"><a href="#Index-Intersection" class="headerlink" title="Index Intersection"></a>Index Intersection</h2><p><br><br><br></p><h2 id="Manage-Index"><a href="#Manage-Index" class="headerlink" title="Manage Index"></a>Manage Index</h2><p><br><br><br></p><h2 id="Measure-Index-Use"><a href="#Measure-Index-Use" class="headerlink" title="Measure Index Use"></a>Measure Index Use</h2><p><br><br><br></p><h2 id="Indexing-Strategy"><a href="#Indexing-Strategy" class="headerlink" title="Indexing Strategy"></a>Indexing Strategy</h2><p><br><br><br></p><h2 id="Index-Reference"><a href="#Index-Reference" class="headerlink" title="Index Reference"></a>Index Reference</h2><p><br></p><hr><p><br></p><h1 id="MongoDB存储"><a href="#MongoDB存储" class="headerlink" title="MongoDB存储"></a>MongoDB存储</h1><p>Storage</p><p><br></p><p>FAQ: MongoDB Storage: <a href="https://docs.mongodb.com/v3.4/faq/storage/" target="_blank" rel="noopener">https://docs.mongodb.com/v3.4/faq/storage/</a></p><p><br></p><p>存储引擎(storage engine)是MongoDB管理数据库主要的组件。</p><p>journal日志，用于数据库不正常关闭时修复数据库。有几种可选的配置项，用以平衡数据库的性能和可用性。</p><p><strong>GridFS</strong>是一个适合处理大文件的多功能的存储系统，例如那些超过16MB文档大小限制的文件。</p><p><br><br><br></p><h2 id="Storage-Engine"><a href="#Storage-Engine" class="headerlink" title="Storage Engine"></a>Storage Engine</h2><p>存储引擎是数据库的组件，负责管理数据库在内存(in-memory)和磁盘中(on-disk)两种存储方式。<br>由于不同的存储引擎在特定的工作负载下有更好的性能，所以，为你的应用程序选择一个适当的存储引擎会提高性能。</p><p><br></p><p><strong><a href="#WiredTiger存储引擎">WiredTiger</a></strong>是从MongoDB3.2开始的默认存储引擎。它非常适合大多数工作负载，并推荐使用它来进行部署。WiredTiger提供了文档级并发模型，检查点和要说等特性。</p><p><strong><a href="#MMAPv1存储引擎">MMAPv1</a></strong>是一个原始的MongoDB存储引擎，它是MongoDB3.2以前的默认存储引擎。它在大量读取和写入以及更新方面的工作负载表现良好。</p><p><strong><a href="#In-Memory存储引擎">In-Memory</a></strong>要在MongoDB Enterprise中才能获取。它不是将文档保存在磁盘上，而是将它们保留在内存中，以获得可预测的数据延迟。</p><p><br><br><br></p><h3 id="WiredTiger存储引擎"><a href="#WiredTiger存储引擎" class="headerlink" title="WiredTiger存储引擎"></a>WiredTiger存储引擎</h3><p>MongoDB3.2以后使用WiredTiger存储引擎作为默认存储引擎。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mongod --storageEngine wiredTiger</div><div class="line"></div><div class="line"></div><div class="line">#或</div><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">storage:</div><div class="line">  engine:  wriedTiger</div></pre></td></tr></table></figure><p><br></p><h4 id="文档级别并发-currency"><a href="#文档级别并发-currency" class="headerlink" title="文档级别并发(currency)"></a>文档级别并发(currency)</h4><p>WiredTiger使用文档级并发来控制写操作。因此，多个客户端可以同时修改一个集合中的不同文档。</p><p>对于大多数读写操作，WiredTiger使用乐观的并发控制。WiredTiger仅在global、database和collection-levels使用intent lock。<br>当存储引擎检测到两个操作之间的冲突时，其中一个操作将引发写冲突，从而导致MongoDB透明地重试该操作。</p><p><br></p><h4 id="快照和检查点"><a href="#快照和检查点" class="headerlink" title="快照和检查点"></a>快照和检查点</h4><p>WiredTiger users multiVersion Concurrency Control(MVCC).在操作开始时，WiredTiger向事务提供数据的实时快照。快照显示内存中数据的一致性视图。</p><p>当写入磁盘时，WiredTiger将快照中的所有数据以一致性的方式跨越所有数据文件写入磁盘。持久(durable)的数据充当数据文件中的检查点。检查点确保数据文件与最后一个检查点保持一致性，并包括最后一个检查点。</p><p>MongoDB配置WiredTiger来创建检查点(即将快照数据写入磁盘)，间隔时间为60s，或2G日志数据。</p><p>在写入新检查点期间，前一个检查点仍然有效。</p><p>当WiredTiger的元数据表被原子地更新以引用新的检查点，新的检查点将变得可访问和永久。一旦新检查点可以访问，WiredTiger就会从旧的检查点这种释放页面(free page)。</p><p><br></p><h4 id="Journal"><a href="#Journal" class="headerlink" title="Journal"></a>Journal</h4><p>WiredTiger采用预写事务日志联合检查点，用以确保数据的持久性(durability)。<br>你也可以关闭journal功能来减少维护日志的开销。</p><p>WiredTiger日志坚持在检查点之间修改所有数据。如果MongoDB在检查点之间退出，它将使用日志重放自上一个检查点以来修改的所有数据。</p><p>WiredTiger journal使用snappy compression Library来进行压缩。</p><p><strong>WiredTiger最小日志记录的大小是128Byte，如果日志记录小于等于128Byte，则WiredTiger不会压缩日志文件。</strong></p><p>对于以standalone模式运行的mongo实例，关闭journal日志功能意味着当MongoDB意外地在检查点之前退出时，你将丢失一些数据修改。对于复制集成员，复制过程和恒提供足够的持久性保证。</p><p><br></p><h4 id="Compression"><a href="#Compression" class="headerlink" title="Compression"></a>Compression</h4><p>使用WiredTiger，MongoDB支持压缩所有的collections和indexes。通过使用CPU进行压缩，减少了储存空间的使用。</p><p>默认地，WiredTiger使用snappy compression library对所有的collections进行block压缩，对所有索引进行前缀(prefix)压缩。</p><p>对于collection，也可以使用zlib进行block压缩。可通过<code>storage.wiredTiger.collectionConfig.blockCompressor</code>设置压缩方法。<br>对于index，使用<code>storage.wiredTiger.indexConfig.prefixCompression</code>关闭prefix压缩。</p><p>对于大多数工作负载，默认压缩设置平衡了存储效率和处理要求。</p><p><br></p><h4 id="Memory-Use"><a href="#Memory-Use" class="headerlink" title="Memory Use"></a>Memory Use</h4><p>对于WiredTiger，MongodB使用WiredTiger内部缓存和文件缓存。</p><p>从MongoDB3.4开始，WiredTiger内部缓存将使用一下两种类型中更大的一种：</p><ul><li>50% of RAM minus 1GB</li><li>256MB</li></ul><p><br></p><p>WiredTiger内部缓存中的数据与磁盘上格式的数据使用不同的表现形式：</p><ul><li>文件系统缓存的数据与磁盘上的格式相同，包括了对数据文件进行压缩的好处。操作系统使用文件系统缓存来减少磁盘I/O</li><li>指标加载在WiredTiger内部缓存有一个不同的磁盘上的数据表示格式，但仍然可利用 prefix index compression来减少内存使用。索引前缀压缩重复数据删除常用前缀的索引字段。</li><li>WiredTiger内存缓存的collection数据是未压缩的，并使用与磁盘格式不同的表现形式。block compression能够节省大量磁盘空间，但必须解压缩数据后服务器才能操作。</li></ul><p><strong>通过文件系统缓存，MongoDB自动使用 (WiredTiger缓存或其他进程不使用)空闲内存。</strong></p><p>调整WiredTiger内部缓存的大小，避免将WiredTiger的内初缓存值增加到默认值之上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#命令行</div><div class="line">--wiredTigerCacheSizeGB</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#配置文件</div><div class="line">storage.wiredTiger.engineConfig.cacheSizeGB</div></pre></td></tr></table></figure><p><br></p><h4 id="Change-Standalone-to-wiredTiger"><a href="#Change-Standalone-to-wiredTiger" class="headerlink" title="Change Standalone to wiredTiger"></a>Change Standalone to wiredTiger</h4><p>MongoDB version 3.0 or later in order to use wiredTiger storage engine!</p><p>过程：</p><ol><li>mongod is running</li><li>export data using mongodump</li><li>create a data directory for the new mongod running with wiredTiger</li><li>start mongod with wiredTiger</li><li>upload the dumpdata using mongorestore</li></ol><p><br></p><h4 id="Change-Replica-Set-to-wiredTiger"><a href="#Change-Replica-Set-to-wiredTiger" class="headerlink" title="Change Replica Set to wiredTiger"></a>Change Replica Set to wiredTiger</h4><p>Replica sets can have members with different storage engines.<br>因此，你可以把所有成员的存储引擎更换为WiredTiger。<br>MongoDB version 3.0 or later in order to use wiredTiger storage engine!</p><p>过程：</p><ol><li>shutdown the secondary member.–<code>db.shutdownServer</code></li><li>prepare a data directory for the new mongod running with wiredTiger</li><li>start mongod with wiredTiger</li><li>repeat the procedure for other replica set secodaries you wish to upgrade</li></ol><p><br></p><h4 id="Change-Sharded-Cluster-to-wiredTiger"><a href="#Change-Sharded-Cluster-to-wiredTiger" class="headerlink" title="Change Sharded Cluster to wiredTiger"></a>Change Sharded Cluster to wiredTiger</h4><p>if the shard is a standalone, see <a href="#Change Standalone to wiredTiger">Change Standalone to wiredTiger</a>;<br>if the shard is a replica set, see <a href="#Change Replica Set to wiredTiger">Change Replica Set to wiredTiger</a>.</p><p><br></p><h5 id="Change-config-server-to-wriedTiger"><a href="#Change-config-server-to-wriedTiger" class="headerlink" title="Change config server to wriedTiger"></a>Change config server to wriedTiger</h5><p>如果你打算更新config server使用WiredTiger，那么必须全部更新！</p><p>过程：</p><ol><li>disable the balancer–<code>sh.disableBalancer()</code></li><li>shutdown the third config server to ensure read-only metadata.–<code>db.shutdownServer()</code></li><li>export the data of the second config server with mongodump</li><li>For the second config server, create a new data directory for use with WiredTiger.</li><li>Stop the second config server.–<code>db.shutdownServer()</code></li><li>Start the second config server mongod with the WiredTiger storage engine option.</li><li>Upload the exported data using mongorestore to the second config server.</li><li>Shut down the second config server to ensure read-only metadata.–<code>db.shutdownServer()</code></li><li>Restart the third config server to prepare for its upgrade.</li><li>Export the data of the third config server with mongodump</li><li>For the third config server, create a new data directory for use with WiredTiger.</li><li>Stop the third config server.</li><li>Start the third config server with the WiredTiger storage engine option.</li><li>Upload the exported data using mongorestore to the third config server.</li><li>Export data of the first config server with mongodump.</li><li>For the first config server, create a new data directory for use with WiredTiger.</li><li>Stop the first config server.</li><li>Start the first config server with the WiredTiger storage engine option.</li><li>Upload the exported data using mongorestore to the first config server.</li><li>Restart the second config server to enable writes to the sharded cluster’s metadata</li><li>Re-enable the balancer.–<code>sh.startBalancer()</code></li></ol><p><br><br><br></p><h3 id="MMAPv1存储引擎"><a href="#MMAPv1存储引擎" class="headerlink" title="MMAPv1存储引擎"></a>MMAPv1存储引擎</h3><p><br><br><br></p><h3 id="In-Memory存储引擎"><a href="#In-Memory存储引擎" class="headerlink" title="In-Memory存储引擎"></a>In-Memory存储引擎</h3><p><br><br><br></p><h2 id="Journaling-1"><a href="#Journaling-1" class="headerlink" title="Journaling"></a>Journaling</h2><p><strong>为了在发生故障时提供持久性，MongoDB使用了县写日志记录到磁盘的日志文件。</strong><br>To provide durability in the event of a failure, MongoDB uses write ahead logging to on-disk journal files.</p><p><br></p><h3 id="journaling-and-the-wiredTiger-storage-engine"><a href="#journaling-and-the-wiredTiger-storage-engine" class="headerlink" title="journaling and the wiredTiger storage engine"></a>journaling and the wiredTiger storage engine</h3><p>本节所指的log指的是WiredTiger的 write-ahead log(journal)，而不是MongoDB日志文件。</p><p>WiredTiger使用checkpoints在磁盘上提供一致的数据视图，并允许MongoDB从上一个checkpoint修复。然而，如果MongoDB在检查点之间以外退出，则需要使用journaling来修复上次检查点之后发生的信息。</p><p>使用journaling的修复过程：</p><ol><li>在数据文件中查找上一个检查点的标识符(identifier)</li><li>在journaling文件中搜索与上一个检查点标识符匹配的记录</li><li>应用自上一个检查节点依赖journal文件中的操作</li></ol><p><br></p><h4 id="journal-process"><a href="#journal-process" class="headerlink" title="journal process"></a>journal process</h4><p>通过journaling，WiredTiger为每个客户端启动的写操作创建一个journal记录。journal record包括有初始写入引起的任何内部写入操作。</p><p>例如，集合中文档的更新可能导致对index的修改，WiredTiger创建一个包含update操作及其相关index修改的单独的journal record。</p><p>MongoDB将WiredTiger配置为in-memory的buffering来存储日志记录。线程坐标来分配和复制到他们的缓冲区的一部分。所有日志记录高达128KB是缓存的。<br>WiredTiger根据如下条件将journal record同步到磁盘。</p><ul><li>每50ms</li><li>MongoDB在WiredTiger中设置60s为间隔的用户数据检查点或2GBjournal数据已被写入，以先发生为准。</li><li>如果写操作包含有<code>j:true</code>的写关注点，则WiredTiger强制对journal文件进行同步。</li><li>MongoDB限制了journal文件大小为100MB，因此WiredTiger每100MB就会创建一个新的journal文件。当创建了一个新的journal文件时，WiredTiger会同步上一个journal文件。</li></ul><p><strong>在写操作之间，虽然日志记录保留在WiredTiger缓冲区中，但在mongod实例hard shutdown之后可能会丢失更新。</strong></p><p><img src="/images/Zabbix/journalSize.png" alt="Journal大小"></p><p><br></p><h4 id="Journal-File"><a href="#Journal-File" class="headerlink" title="Journal File"></a>Journal File</h4><p>MongoDB在数据库目录下创建一个<code>journal</code>子目录存放journal文件。名字为<code>WiredTigerLog.&lt;sequence&gt;</code>，从<code>0000000001</code>开始。如上图所示。</p><p>Journal文件包含对每一个写操作的记录。每个记录都有唯一的标识符。</p><p>MongoDB将WiredTiger配置为对journal数据使用快速压缩。最小日志大小为128KB，如果小于此，WiredTiger不会压缩此记录。最大大小为100MB，超过此，WiredTiger会创建一个新的journal文件。</p><p>MongoDB自动删除旧日志文件，以维护从上一个检查点恢复所需的文件。</p><p><br><br><br></p><h3 id="Journaling-and-the-MMAPv1-Storage-Engine"><a href="#Journaling-and-the-MMAPv1-Storage-Engine" class="headerlink" title="Journaling and the MMAPv1 Storage Engine"></a>Journaling and the MMAPv1 Storage Engine</h3><p><br><br><br></p><h3 id="Journaling-and-the-In-Memory-Storage-Engine"><a href="#Journaling-and-the-In-Memory-Storage-Engine" class="headerlink" title="Journaling and the In-Memory Storage Engine"></a>Journaling and the In-Memory Storage Engine</h3><p><br><br><br></p><h2 id="Manage-Journaling"><a href="#Manage-Journaling" class="headerlink" title="Manage Journaling"></a>Manage Journaling</h2><p>MongoDB uses write ahead logging to an on-disk journal to guarantee write operation durability.</p><p>启用journal后，如果MongodB意外退出，则程序可以恢复写入了journal日志文件的所有内容。MongoDB将在重启时重新应用写操作，并保持一致性。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><br></p><h4 id="Enable-journaling"><a href="#Enable-journaling" class="headerlink" title="Enable journaling"></a>Enable journaling</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mongod --jouranl</div><div class="line"></div><div class="line"></div><div class="line">##或</div><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">storage:</div><div class="line">  journal:</div><div class="line">    enabled: true</div></pre></td></tr></table></figure><p><br></p><h4 id="Disable-journaling"><a href="#Disable-journaling" class="headerlink" title="Disable journaling"></a>Disable journaling</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mongod --noJournal</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###或</span></div><div class="line">修改配置文件</div></pre></td></tr></table></figure><blockquote><p><strong>警告</strong><br>不要在生产系统上禁用日记功能。<br>如果在一个副本集上使用<code>--noJournal</code>关闭了journal日志，则还应该修改副本集配置文件。</p></blockquote><p><br></p><h4 id="Monitor-journal-status"><a href="#Monitor-journal-status" class="headerlink" title="Monitor journal status"></a>Monitor journal status</h4><ul><li><code>serverStatus</code></li></ul><p><br></p><h4 id="Recover-data-after-unexpected-shutdown"><a href="#Recover-data-after-unexpected-shutdown" class="headerlink" title="Recover data after unexpected shutdown"></a>Recover data after unexpected shutdown</h4><p>在奔溃后重启时，MongoDB会在服务器可用之前replay journal日志记录中的所有日志文件。</p><p><br><br><br></p><h2 id="GridFS"><a href="#GridFS" class="headerlink" title="GridFS"></a>GridFS</h2><p>GridFS是一种用于存储和检索超过BSON文档大小限制值16MB的文件规范。</p><p>GridFS没有将单个文件存储到单个的文档中，而是将文件分割成部分(parts)或块(chunks)，并将每个块存储到单独的文档中。默认情况下，GridFS的块大小为255KB。也就是说，GridFS将文件分成255KB的块，最后一块大小就不确定了。</p><p>GridFS使用两个集合来存储文件。一个存储文件块(chunks)，另一个存储文件元数据(metadata)。</p><p>当你查询(query)GridFS文件时，驱动程序会根据需要重新组装这些块。你可对通过GridFS存储的文件执行范围查询。还可以从任意文件部分访问信息。</p><p>GridFS不仅可用于存储超过16MB的文件，还可用于存储需要访问的任何文件，而不必将整个文件加载到内存中。</p><p><br></p><h3 id="何时使用GridFS"><a href="#何时使用GridFS" class="headerlink" title="何时使用GridFS"></a>何时使用GridFS</h3><p>在MongoDB中，使用GridFS存储大于16MB的文件。</p><p>某些情况下，在MongoDB数据库中存储大文件可能比在系统级文件系统上更有效。</p><ul><li>如果文件系统限制了一个目录中的文件数量，则可使用GridFS存储所需的文件</li><li>当你想要访问大文件的部分信息时而不想将整个文件加载到内存中时，可使用GridFS收回文件的各个部分，而不必将整个文件读入内存</li><li>当你希望文件和元数据自动同步并部署在多个系统和设施中时，可使用GridFS</li></ul><p>如果需要原子地(atomically)更新整个文件的内容，请不要使用GridFS。作为一种选择，你可以为每个文件存储多个版本，并在元数据中指定该文件的当前版本。</p><p>此外，如果文件都是小于16MB的BSON文件大小限制，则考虑手动存储在一个单文档中，而不必使用GridFS。</p><p><br><br><br></p><h3 id="使用GridFS"><a href="#使用GridFS" class="headerlink" title="使用GridFS"></a>使用GridFS</h3><p>使用GridFS存储和检索文件，请使用如下任何一项：</p><ul><li>A MongoDB Driver</li><li>The mongofile cmd-line tool</li></ul><p><br><br><br></p><h3 id="GridFS集合"><a href="#GridFS集合" class="headerlink" title="GridFS集合"></a>GridFS集合</h3><p>GridFS把文件存储在两个集合里：</p><ol><li>chunks collection<ul><li>stores the binary chunks</li></ul></li><li>files collection<ul><li>stores the file’s metadata</li></ul></li></ol><p>GridFS将这些集合放在一个普通的存储区(bucket)中，每个存储区前面加上名称。默认地，GridFS使用两个名为<code>fs</code>的存储区集合：</p><ol><li>fs.files</li><li>fs.chunks</li></ol><p>币可以选择一个不同的存储区名字，也可以在一个数据库中创建多个存储区。</p><p><br></p><h4 id="The-chunks-collection"><a href="#The-chunks-collection" class="headerlink" title="The chunks collection"></a>The chunks collection</h4><p>块集合中的每个文档都表示一个独立的文件块。格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;_id&quot;: &lt;ObjectId&gt;,</div><div class="line">    &quot;files_id&quot;: &lt;ObjectId&gt;,</div><div class="line">    &quot;n&quot;: &lt;num&gt;,</div><div class="line">    &quot;data&quot;: &lt;binary&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>块集合中的文档包含如下字段：</p><ul><li>chunks._id<ul><li>The unique ObjectId of the chunk</li></ul></li><li>chunks.files_id<ul><li>The _id of the “parent” document</li></ul></li><li>chunks.n<ul><li>The sequence number of the chunk，GridFS从0开始标号所有块</li></ul></li><li>chunks.data<ul><li>BSON Binary type</li></ul></li></ul><p><br></p><h4 id="file集合"><a href="#file集合" class="headerlink" title="file集合"></a>file集合</h4><p>GridFS的file集合，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;_id&quot;: &lt;ObjectId&gt;,</div><div class="line">    &quot;length&quot;: &lt;num&gt;,</div><div class="line">    &quot;chunkSize&quot;: &lt;num&gt;,</div><div class="line">    &quot;uploadData&quot;: &lt;timestamp&gt;,</div><div class="line">    &quot;md5&quot;: &lt;hash&gt;,</div><div class="line">    &quot;filename&quot;: &lt;string&gt;,</div><div class="line">    &quot;contentType&quot;: &lt;string&gt;,</div><div class="line">    &quot;aliases&quot;: &lt;string array&gt;,</div><div class="line">    &quot;metadata&quot;: &lt;any&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>files._id<ul><li>The unique identifier for this document</li></ul></li><li>files.length<ul><li>The size of the document in bytes</li></ul></li><li>files.chunSize<ul><li>The size of each chunk in bytes</li></ul></li><li>files.uploadDate<ul><li>The date the document was first stored by GridFS</li></ul></li><li>files.md5<ul><li>An MD5 hash of the complete file</li></ul></li><li>file.filename<ul><li>Optional. A human-readable name for the GridFS file</li></ul></li><li>file.contentType<ul><li>Optional. A valid MIME type for the GridFS file</li></ul></li><li>files.aliases<ul><li>Optional. An array of alias strings</li></ul></li><li>files.metadata<ul><li>Optional. The metadata field may be of any data type and can hold any additional information you want to store</li></ul></li></ul><p><br></p><h3 id="GridFS索引"><a href="#GridFS索引" class="headerlink" title="GridFS索引"></a>GridFS索引</h3><p>为了提高效率，GridFS在每个chunks and files collections上使用索引。</p><p><br></p><h4 id="chunks索引"><a href="#chunks索引" class="headerlink" title="chunks索引"></a>chunks索引</h4><p>GridFS使用一个唯一的、混合的索引。在chunks集合上使用<code>files_id</code>和<code>n</code>字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.fs.chunks.find( &#123; files_id: myFileID &#125; ).sort( &#123; n:1 &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#创建索引</div><div class="line">db.fs.chunks.createIndex(&#123; files_id: 1, n:1 &#125;, &#123; unique: true &#125;);</div></pre></td></tr></table></figure><p><br></p><h4 id="files索引"><a href="#files索引" class="headerlink" title="files索引"></a>files索引</h4><p>GridFS使用索引，在files集合上使用<code>filename</code>和<code>uploadDate</code>字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.fs.files.find(&#123; filename: myFileName &#125;).sort(&#123; uploadDate: 1 &#125;)</div><div class="line"></div><div class="line"></div><div class="line">#创建索引</div><div class="line">db.fs.files.createIndex(&#123; filename:1, uploadDate: 1 &#125;);</div></pre></td></tr></table></figure><p><br></p><h3 id="分片GridFS"><a href="#分片GridFS" class="headerlink" title="分片GridFS"></a>分片GridFS</h3><p>如果需要分片GridFS数据存储，使用chunks集合设置: <code>{ files_id: 1, n:1}</code> or <code>{ files_id: 1 }</code>作为分片key索引。</p><p>不能对chunks集合使用hash分片。</p><p>files_id是一个ObjectId。</p><p><br><br><br></p><hr><p><br></p><h1 id="MongoDB安全"><a href="#MongoDB安全" class="headerlink" title="MongoDB安全"></a>MongoDB安全</h1><p>Security</p><p><br></p><p>MongoDB提供了各种特性(features)，如身份认证(authentication)、访问控制(access control)、加密(encryption)，以保护MongoDB部署。</p><p><br><br><br></p><h2 id="Security-Checklist"><a href="#Security-Checklist" class="headerlink" title="Security Checklist"></a>Security Checklist</h2><ul><li>启用访问控制和强制认证<ul><li>Enable Access Control and Enforce Authentication</li><li>可使用默认的MongoDB认证机制或现有的外部框架</li></ul></li><li>配置基于角色的访问控制<ul><li>Configure Role-Based Access Control</li><li>首先创建administrator，接着在创建其他用户</li><li>创建角色，定义一组用户所需的确切访问权限</li></ul></li><li>加密通信<ul><li>Encrypt Communication</li><li>配置MongoDB使用TLS/SSL加密连接</li></ul></li><li>加密和保护数据<ul><li>Encrypt and Protect Data</li></ul></li><li>限制网络曝光<ul><li>Limit Network Exposure</li><li>确保MongoDB运行在一个受信任的网络环境上，并限制MongoDB的监听接口</li></ul></li><li>审计系统活动<ul><li>Audit System Activity</li><li>跟踪对数据库配置和数据的访问和更改</li></ul></li><li>使用专用用户运行MongoDB<ul><li>Run MongoDB with a Dedicated User</li><li>使用专用的操作系统用户账户运行MongoDB进程</li></ul></li><li>使用安全配置选项运行MongoDB<ul><li>Run MongoDB with Secure Configuration Options</li><li>MongoDB为了支持某些服务端操作执行：<code>mapReduce</code>,<code>group</code>,<code>$where</code></li><li>如果你不使用这些操作，请关闭服务器端脚本执行<code>--noscripting</code></li></ul></li><li>请求一个安全技术执行指南<ul><li>Request a Security Technical Implementation Guide</li></ul></li><li>考虑安全标准合格性<ul><li>Consider Security Standards Compliance</li></ul></li></ul><p><br><br><br></p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>Authentication</p><p><br></p><p>要作为用户进行身份认证，必须提供用户名(username)，密码(password)和与用户关联的身份验证数据库(authentication database)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mongo --host --username --password --authenticationDatabase</div><div class="line"></div><div class="line"></div><div class="line">#Or</div><div class="line">mongo</div><div class="line">&gt;use &lt;authenticationDatabase&gt;</div><div class="line">&gt;db.auth(&apos;username&apos;,&apos;password&apos;)</div></pre></td></tr></table></figure><p><br></p><ul><li>认证机制<ul><li>Authentication Mechanisms</li><li>MongoDB支持多种认证机制<ul><li>SCRAM-SHA-1</li><li>MongoDB Challenge and Response (MONGODB-CR)</li><li>x.509 Certificate Authentication</li><li>LDAP proxy authentication(MongoDB Enterprise)</li><li>Kerberos authentication(MongoDB Enterprise)</li></ul></li></ul></li><li>内部认证<ul><li>Internal Authentication</li><li>除了验证客户端的身份外。MongoDB还可以要求副本集和分片集的成员对其各自的成员进行认证</li></ul></li></ul><p><br></p><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>Users</p><p><br></p><p>要在MongoDB中验证客户端，必须向MongoDB添加相应的用户。</p><ul><li>用户管理接口<ul><li>User Management Interface</li><li>使用<code>db.createUser()</code>方法创建用户</li><li>添加用户时，可为用户分配角色以授予权限</li><li>在数据库管理中创建的第一个用户应该是具有管理其他用户权限的administrator</li><li>也可以更新/删除一个已经存在的用户的权限</li></ul></li><li>认证数据库<ul><li>Authentication Database</li><li>在特定的数据库中创建用户，这个数据库是用户的认证库</li><li>用户名和认证库充当该用户的唯一标识符。如果两个用户具有相同的用户名，但是在不同的数据库中创建，则它们是两个单独的用户</li><li>用户可拥有不同数据库的权限，而不限于认证库</li><li>通过数据库角色给用户分配相应的权限</li></ul></li><li>认证一个用户<ul><li>Authentication Database</li><li>使用用户名、密码、认证库验证一个用户</li></ul></li><li>集中的用户数据<ul><li>Centralized User Data</li><li>MongoDB将所有的用户名、密码和认证库信息，保存到admin库的syste.users集合中</li><li>使用用户管理命令而不要直接访问这个集合</li></ul></li><li>分片集群用户<ul><li>Sharded Cluster Users</li></ul></li></ul><p><br></p><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><p>Add Users</p><p><br></p><p>MongoDB使用基于角色的访问控制(RBAC)来确定用户的访问权限。用户被授予一个或多个角色，这些角色确定用户对MongoDB资源的访问或权限，以及用户可以执行的操作。<br>用户应该只具有确保系统最小权限所需要的最小权限。</p><p><br></p><p><strong>前提(Prerequisites)</strong></p><p>对于用户创建，你必须拥有以下权限</p><ul><li>在数据库中创建一个新用户，必须在数据库资源上有<code>createUser</code>操作</li><li>对一个用户授权角色，必须在角色数据库中有<code>grantRole</code>操作</li></ul><p><br></p><p><strong>栗子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">use admin</div><div class="line">db.createUser(</div><div class="line">&#123;</div><div class="line">user: &apos;zhang&apos;,</div><div class="line">        pwd: &apos;passwd123&apos;,</div><div class="line">        roles: [</div><div class="line">        &#123; role: &apos;root&apos; &#125;,</div><div class="line">            &#123; db: &apos;admin&apos; &#125;</div><div class="line">        ]</div><div class="line">&#125;</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line">#在配置文件中开启用户认证</div><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">security:</div><div class="line">    authorization: enabled</div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="认证机制"><a href="#认证机制" class="headerlink" title="认证机制"></a>认证机制</h3><p>Authentication Mechanisms</p><p><br></p><h4 id="SCRAM-SHA-1"><a href="#SCRAM-SHA-1" class="headerlink" title="SCRAM-SHA-1"></a>SCRAM-SHA-1</h4><p><br></p><h4 id="MONGODB-CR"><a href="#MONGODB-CR" class="headerlink" title="MONGODB-CR"></a>MONGODB-CR</h4><p><br></p><h4 id="x-509"><a href="#x-509" class="headerlink" title="x.509"></a>x.509</h4><p>MongoDB对于客户端身份认证和副本集、分片集成员的内部认证支持x.509证书认证。</p><p>x.509证书认证需要安全的TLS/SSL连接。</p><p><br></p><p><strong>证书授权(Certificate Authority)</strong></p><p>在生产使用中，MongoDB的部署应该使用由认证机构签名和生成的有效证书。</p><p><br></p><p><strong>Client x.509 Certificates</strong></p><p>要想服务器验证身份，客户端可以使用x.509证书而不是用户名和密码。</p><p>Client Certificate Requirements：</p><ul><li>单个证书颁发机构(CA)必须同时为客户端和服务器颁发证书</li><li><p>客户端证书必须包含如下字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">keyUsage = digitalSignature</div><div class="line">extendedKeyUsage = clientAuth</div></pre></td></tr></table></figure></li><li><p>每个唯一的MongoDB用户必须有一个唯一的证书</p></li><li>一个客户端x.509证书的主题，包含了可辨识名称(DN)。必须不同于成员x.509证书</li></ul><p><br></p><p>MongoDB user and $external database</p><p>若要使用客户端证书进行认证，必须先将客户端证书中的subject值添加为MongoDB用户。每个唯一的x.509客户端证书对因孤独一个MongoDB用户。</p><p>在$external database中添加用户，认证库便是外部数据库。</p><p><br></p><p>Authenticate</p><p>使用x.509客户端进行身份验证，请通过TLS/SSL连接到MongoDB。<code>--ssl</code> and <code>--sslPEMKeyFile</code></p><p><br></p><p><strong>Member x.509 Certificates</strong></p><p>对于内部认证，分片集和副本集的成员可以使用x.509证书来代替使用SCRAM-SHA-1认证机制的keyfile。</p><p><strong>Member Certificate Requirements</strong></p><ul><li>CA必须为所有分片集，副本集成员颁发x.509证书</li><li>成员证书的主题中找到Distinguished Name(DN)必须为以下至少一个属性指定非空值：Organization(O)，Organization Unit(OU)，Domain Component(DC)</li><li>组织属性，组织单元属性和域组件必须与其他集群成员的证书相匹配。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CN=host1,OU=Dept1,O=MongoDB,ST=NY,C=US</div><div class="line">C=US, ST=CA, O=MongoDB, OU=Dept1, CN=host2</div></pre></td></tr></table></figure></li></ul><p><br></p><p><strong>MongoDB Configuration</strong></p><ul><li>配置文件：security.clusterAuthMode and net.ssl.clusterFile</li><li>cmd-line options: –clusterAuthMode and –sslClusterFile</li></ul><p><br></p><p><strong>Member Certificate and PEMKeyFile</strong></p><ul><li>配置文件： net.ssl.PEMKeyFile</li><li>cmd-line option: –sslPEMKeyFile</li></ul><p><br><br><br></p><h3 id="Enterprise-Authentication-Mechanisms"><a href="#Enterprise-Authentication-Mechanisms" class="headerlink" title="Enterprise Authentication Mechanisms"></a>Enterprise Authentication Mechanisms</h3><p><br><br><br></p><h3 id="MongoDB认证和角色"><a href="#MongoDB认证和角色" class="headerlink" title="MongoDB认证和角色"></a>MongoDB认证和角色</h3><p>要想了解MongoDB的权限必须先了解如下一些关键字：</p><ul><li>user<ul><li>用户，用于提供客户端连接MongoDB的认证账户</li></ul></li><li>role<ul><li>角色，数据权限的集合，创建用户的时候必须要指定对应的角色，否则用户无法操作数据库</li></ul></li><li>resource<ul><li>资源，包括database或collection 也可以是database和collection的组合</li></ul></li><li>actions<ul><li>权限操作，定义了 user 能够对 resource document 执行的操作。如 增、删、改、查</li></ul></li><li>privilege<ul><li>权限，privilege 是一组 resource 和 action的组合，对资源拥有什么操作称为权限</li></ul></li><li>authenticationDatabase<ul><li>认证库，即创建角色或用户时所在的库</li></ul></li></ul><p><br></p><h4 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h4><p>MondoDB支持基于角色的访问控制（RBAC）来管理对MongoDB系统的访问。一个用户可以被授权一个或多个角色以决定该用户对数据库资源和操作的访问权限。在权限以外，用户是无法访问系统的。</p><p>数据库角色在创建用户的role参数中设置。角色分为內建角色和自定义角色。</p><p><br></p><p><strong>内建角色</strong></p><ul><li>数据库用户角色<ul><li>read：允许用户读取指定数据库</li><li>readWrite：允许用户读写指定数据库</li></ul></li><li>数据库管理员角色<ul><li>dbAdmin：允许用户进行索引创建、删除，查看统计或访问system.profile，但没有角色和用户管理的权限</li><li>userAdmin：提供了在当前数据库中创建和修改角色和用户的能力</li><li>dbOwner：提供对数据库执行任何操作的能力。这个角色组合了readWrite、dbAdmin和userAdmin角色授权的特权</li></ul></li><li>集群管理角色<ul><li>hostManager：提供监视和管理服务器的能力</li><li>clusterManager：在集群上提供管理和监视操作。可以访问配置和本地数据库，这些数据库分别用于分片和复制</li><li>clusterMonitor：提供对监控工具的只读访问</li><li>clusterAdmin：提供最强大的集群管理访问(副本集、分片、主从等)。组合了clusterManager、clusterMonitor和hostManager角色的能力，还提供了dropDatabase操作</li></ul></li><li>备份恢复角色<ul><li>backup：提供备份数据所需的能力</li><li>restore： 提供使用mongorestore恢复数据的能力</li></ul></li><li>所有数据库角色<ul><li>readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限</li><li>readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限</li><li>userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</li><li>dbAdminAnyDataBase：只在admin数据库中可用，赋予用户所有数据库的adAdmin权限</li></ul></li><li>超级用户角色<ul><li>root：超级权限，只能针对admin库</li></ul></li><li>内部角色<ul><li>__system：提供对数据库中任何对象的任何操作的特权</li></ul></li></ul><p><br></p><p><strong>自定义角色</strong></p><p>MongoDB内置角色一般来说都是够用的，但当内置角色不满足需求时就可以自定义角色了。使用 db.createRole() 方法来自定义角色。</p><p>只能在admin库中创建角色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">use admin</div><div class="line">db.createRole(</div><div class="line">    &#123;</div><div class="line">        role:&lt;role_name&gt;,#定义角色名称</div><div class="line">        privilege:[    #权限集</div><div class="line">            &#123; resource:&#123;cluster:true, actions:[&lt;action_name&gt;] &#125;,</div><div class="line">            &#123; resource: &#123;db:&lt;db_name&gt;, collection:&lt;coll_name&gt; &#125;,</div><div class="line">        &#123; actions:[&lt;action_name&gt;] &#125;    #定义对这个库或集合可进行的权限操作，这是一个数组</div><div class="line">        ],</div><div class="line">        roles:[ &#123; role:&lt;role_name&gt;, db:&lt;db_name&gt; &#125; ]    #是否继承其他的角色</div><div class="line">    &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p>角色创建完毕后MongoDB会在系统库admin下创建一个collection名叫 system.roles，里面存储的即是角色相关的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.system.roles.find()</div></pre></td></tr></table></figure><p><br></p><h4 id="操作角色"><a href="#操作角色" class="headerlink" title="操作角色"></a>操作角色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#查看角色</div><div class="line">db.getRole()</div><div class="line"></div><div class="line"></div><div class="line">#角色继承</div><div class="line"></div><div class="line">#角色授权</div><div class="line">db.grantRolesToRole()</div><div class="line"></div><div class="line">#角色移权</div><div class="line">db.revokeRolesfromRole()</div></pre></td></tr></table></figure><p><br></p><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p><strong>创建用户</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">db.createUser(&#123;</div><div class="line">    user:&quot;xxx&quot;, pwd:&quot;xxxx&quot;, customDate:&quot;xxx&quot;,</div><div class="line">    roles:[&#123;    #指定角色名称以及认证库</div><div class="line">        role:&quot;xxx&quot;, db:&quot;xxxx&quot;</div><div class="line">    &#125;]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><br></p><p><strong>开启认证</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">vim /etc/mongo.conf</div><div class="line"></div><div class="line">security:</div><div class="line">    authorization：enabled</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">db.auth(&quot;user&quot;,&quot;passwd&quot;)    #在use db后</div><div class="line">或</div><div class="line">mongo -u user -p passwd --authenticationDatabase xxx</div><div class="line">#在哪个库创建的用户就需要使用哪个库进行认证</div></pre></td></tr></table></figure><p><br></p><p><strong>查看用户</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.getUser(&quot;user&quot;)</div><div class="line">db.system.users.find()</div></pre></td></tr></table></figure><p><br></p><p><strong>删除用户</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.dropUser(&quot;user&quot;)</div><div class="line">db.dropAllUsers()</div></pre></td></tr></table></figure><p><br></p><p><strong>添加用权限</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.grantRolesToUser()</div></pre></td></tr></table></figure><p><br></p><p><strong>修改用户密码</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.changeUserPassword(&quot;user&quot;,&quot;new_passwd&quot;)</div></pre></td></tr></table></figure><p><br></p><p>在MongoDB中删除库和集合并不会级联删除对应的角色和用户。因此如果想彻底删除对应的业务应该先删除库与其对应的角色和用户。</p><p>如果既想实现精细化权限控制又想简化用户管理，原则上建议只给开发创建一个账户，并且使用admin做认证库，这样可以避免清理过期业务库而导致无法登陆的问题。</p><p><br><br><br></p><h3 id="内部认证"><a href="#内部认证" class="headerlink" title="内部认证"></a>内部认证</h3><p>Internal Authentication</p><p><br></p><p>可以对副本集和分片集成员进行验证。<br>对于成员的内部认证，MongoDB可以使用keyfile或x.509证书。</p><p><br></p><p><strong>KeyFile</strong></p><p>keyfiles的内容作为成员的共享密码，其长度必须在6-1024个字符之间，只能包含base64 set中的字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">openssl rand -base64 512 &gt; /etc/mongodb.keyfile</div><div class="line">chmod 600 /etc/mongodb.keyfile</div><div class="line">chown mongod:mongod /etc/mongodb.keyfile</div><div class="line"></div><div class="line"></div><div class="line">#配置文件：security.keyFile</div><div class="line">#cmd-line option: --keyFile</div><div class="line"></div><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">security:</div><div class="line">  authorization: enabled</div><div class="line">  keyFile: &quot;/etc/mongodb.keyfile&quot;</div><div class="line">  clusterAuthMode: &quot;keyFile&quot;</div></pre></td></tr></table></figure><p><br></p><p><strong>x.509</strong></p><p>内部认证使用x.509进行验证。</p><ul><li>CA必须为所有分片集，副本集成员颁发x.509证书</li><li>成员证书的主题中找到Distinguished Name(DN)必须为以下至少一个属性指定非空值：Organization(O)，Organization Unit(OU)，Domain Component(DC)</li><li>组织属性，组织单元属性和域组件必须与其他集群成员的证书相匹配。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CN=host1,OU=Dept1,O=MongoDB,ST=NY,C=US</div><div class="line">C=US, ST=CA, O=MongoDB, OU=Dept1, CN=host2</div></pre></td></tr></table></figure></li></ul><p><br></p><p><strong>MongoDB Configuration</strong></p><ul><li>配置文件：security.clusterAuthMode and net.ssl.clusterFile</li><li>cmd-line options: –clusterAuthMode and –sslClusterFile</li></ul><p><br></p><h4 id="在副本集中强制秘钥文件访问控制"><a href="#在副本集中强制秘钥文件访问控制" class="headerlink" title="在副本集中强制秘钥文件访问控制"></a>在副本集中强制秘钥文件访问控制</h4><p>Enforce Keyfile Access Control in a Replica Set</p><p><br></p><p>对副本集执行访问控制需要配置：</p><ul><li>使用内部身份验证副本集成员之间的安全性</li><li>使用用户访问控制连接客户端和副本集间的安全性</li></ul><p>步骤：</p><ol><li>创建一个密钥文件</li></ol><p>Create a keyfile</p><p>通过密钥文件进行身份验证，副本集中的每个mongod实例都使用密钥文件的内容作为共享密码，用于验证部署中的其它成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#yum install -y openssl</div><div class="line"></div><div class="line">openssl rand -base64 756 &gt; &lt;path-to-keyfile&gt;</div><div class="line">chmod 400 &lt;path-to-keyfile&gt;</div><div class="line">chown &lt;owner&gt;:&lt;owner&gt;</div></pre></td></tr></table></figure><p><br></p><ol><li>复制密钥文件到每个副本集成员</li></ol><p>Copy the keyfile to each replica set member</p><p>将密钥文件复制到每一台主机的副本集成员中。<br>确保运行mongod实例的用户就是keyfile的所有者，并可以访问密钥文件。</p><p><br></p><ol><li>关闭所有的副本集成员</li></ol><p>Shut down all members of the replica set</p><p>关闭每个副本集中的mongod，从Secondary开始。知道所有的成员都脱机为止，包括任何仲裁者(Arbiter)。Primary是最后一个关闭的成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use admin</div><div class="line">db.shutdownServer()</div></pre></td></tr></table></figure><p><br></p><ol><li>启动访问控制并重启副本集成员</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">security:</div><div class="line">  keyFile: &lt;path-to-keyfile&gt;</div><div class="line">  clusterAuthMode: keyfile</div><div class="line">replication:</div><div class="line">  replSetName: &lt;replcaSetName&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#cmd-line</div><div class="line">mongod --keyFile &lt;path-to-keyfile&gt; --clusterAuthMode keyfile --replSet &lt;replicaSetName&gt;</div></pre></td></tr></table></figure><p><br></p><ol><li>连接到mongo shell</li></ol><p>在Primary上使用<code>rs.status()</code>来标识副本集成员。</p><p><br></p><ol><li>创建一个administrator</li></ol><p>Create the user administrator</p><p>必须在Primary上创建用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">admin = db.getSiblingDB(&quot;admin&quot;)</div><div class="line">admin.createUser(</div><div class="line">  &#123;</div><div class="line">user: &apos;zhang&apos;,</div><div class="line">    pwd: &apos;password&apos;,</div><div class="line">    roles: [&#123; role: &apos;userAdminAnyDatabase&apos;, db: &apos;admin&apos; &#125;]</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p><br></p><ol><li>开启用户认证</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vim /etc/mongod.conf</div><div class="line"></div><div class="line">security:</div><div class="line">  authorization: enabled</div><div class="line">  keyFile: &lt;path-to-keyfile&gt;</div><div class="line">  clusterAuthMode: keyfile</div><div class="line">replication:</div><div class="line">  replSetName: &lt;replcaSetName&gt;</div></pre></td></tr></table></figure><p><br></p><ol><li>以管理员身份进行认证</li></ol><p>Authenticate as the User Administrator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mogno</div><div class="line">&gt;db.getSiblingDB(&quot;admin&quot;).auth(&apos;zhang&apos;,&apos;password&apos;)</div><div class="line"></div><div class="line"></div><div class="line">#or</div><div class="line">mongo -u &apos;zhang&apos; -p &apos;password&apos; --authenticationDatabase &apos;admin&apos;</div></pre></td></tr></table></figure><p><br></p><ol><li>创建集群管理员(可选)</li></ol><p>Create the cluster administrator (Optional)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.getSiblingDB(&quot;admin&quot;).createUser(</div><div class="line">  &#123;</div><div class="line">    &quot;user&quot; : &quot;ravi&quot;,</div><div class="line">    &quot;pwd&quot; : &quot;changeme2&quot;,</div><div class="line">    roles: [ &#123; &quot;role&quot; : &quot;clusterAdmin&quot;, &quot;db&quot; : &quot;admin&quot; &#125; ]</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.mongodb.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MongoDB官方文档&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mongoing.com/docs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MongoDB中文文档&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/MongoDB&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/wiki/MongoDB&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ywnds.com/?p=5635&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ywnds.com/?p=5635&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.centos.bz/2017/08/mongodb-secure-intro-user-auth/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.centos.bz/2017/08/mongodb-secure-intro-user-auth/&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.03sec.com/3176.shtml&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.03sec.com/3176.shtml&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ywnds.com/?p=6502&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ywnds.com/?p=6502&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/the-little-mongodb-book/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://wiki.jikexueyuan.com/project/the-little-mongodb-book/&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS7_x64；&lt;/li&gt;
&lt;li&gt;MongoDB3.4；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="https://zhang21.github.io/categories/Database/"/>
    
    
      <category term="MongoDB" scheme="https://zhang21.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>HTTP请求方法和状态码</title>
    <link href="https://zhang21.github.io/2017/12/01/HTTP-method-status/"/>
    <id>https://zhang21.github.io/2017/12/01/HTTP-method-status/</id>
    <published>2017-12-01T05:53:20.000Z</published>
    <updated>2017-12-04T06:42:32.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见HTTP请求方法"><a href="#常见HTTP请求方法" class="headerlink" title="常见HTTP请求方法"></a>常见HTTP请求方法</h1><p>HTTP协议的请求方法有：<code>GET, POST, HEAD PUT DELETE, OPTIONS, TRACE, CONNECT</code></p><a id="more"></a><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>GET</td><td>向Server请求文件</td></tr><tr><td>POST</td><td>向Server发送数据并让Server进行处理</td></tr><tr><td>PUT</td><td>向Server发送数据并存储在Server端</td></tr><tr><td>HEAD</td><td>检查一个对象是否存在</td></tr><tr><td>DELETE</td><td>从Server上删除一个文件</td></tr><tr><td>CONNECT</td><td>对通道提供支持</td></tr><tr><td>TRACE</td><td>跟踪到Server的路径</td></tr><tr><td>OPTION</td><td>查询Server的性能</td></tr></tbody></table><p><br><br><br></p><h1 id="HTTP-Status-Code"><a href="#HTTP-Status-Code" class="headerlink" title="HTTP Status Code"></a>HTTP Status Code</h1><p>当我们从Client向Server发送请求时，Server会向我们返回StatusCode。<br>StatusCode会告诉我们Server的响应的状态，通过它，我们就可以知道当前请求是成功还是出现了问题。</p><p>HTTP StatusCode放置在HTTP  Response报文中。</p><p>StatusCode由三位数字组成，第一个数字定义了响应类型，有五种可能值：</p><table><thead><tr><th>状态码</th><th>响应类别</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td>指示信息</td><td>服务器正在处理请求</td></tr><tr><td>2xx</td><td>成功</td><td>请求以正常处理完毕</td></tr><tr><td>3xx</td><td>重定向</td><td>需要进行额外操作以完成请求</td></tr><tr><td>4xx</td><td>客户端错误</td><td>客户端原因导致服务器无法处理请求</td></tr><tr><td>5xx</td><td>服务器错误</td><td>服务器原因导致处理请求出错</td></tr></tbody></table><p><br></p><h2 id="常见HTTP状态码"><a href="#常见HTTP状态码" class="headerlink" title="常见HTTP状态码"></a>常见HTTP状态码</h2><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>200-OK</td><td>服务器成功返回网页，这是成功的HTTP请求返回的标准状态码</td></tr><tr><td>301 - Moved Permanently</td><td>永久跳转，所有请求的网页将永久跳转到被设定的新位置</td></tr><tr><td>400 - Bad Request</td><td>客户端请求有语法错误，不能被服务器理解</td></tr><tr><td>403 - Forbidden</td><td>禁止访问，这个请求时合法的，但是服务器端因为匹配了预先设置的规则而拒绝响应客户端的请求，此类问题一般为服务器权限配置不当所致</td></tr><tr><td>404 - Not Found</td><td>服务器找不到客户端请求的指定页面，可能是客户端请求了服务器不存在的资源所导致</td></tr><tr><td>500 - Internal Server Error</td><td>内部服务器错误，服务器遇到了意料不到的情况，不能完成客户的请求。这是一个较为笼统的报错，一般为服务器的设置或内部程序问题所致</td></tr><tr><td>502 - Bad Gateway</td><td>坏的网关，一般是代理服务器请求后端服务器时，后端服务不可用或没有完成响应网关服务器。一般为代理服务器下面的节点出了问题</td></tr><tr><td>503 - Service Unavailable</td><td>服务当前不可用，可能为服务器超载或停机维护所致，或者是代理服务器后面没有可以提供服务的节点</td></tr><tr><td>504 - Gateway Timeout</td><td>网关超时，一般是网关代理服务器请求后端服务时，后端服务没有在特定的时间内完成处理请求，一般为服务器过载所致，没有在指定的时间内返回数据给代理服务器</td></tr></tbody></table><p><br></p><h2 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h2><p>1xx（临时响应），表示临时响应并需要请求者继续执行操作。</p><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>100 - Continue</td><td>请求者应当继续提出请求</td></tr><tr><td>101 - Switching Protocols</td><td>请求者要求服务器更换协议，服务器已确认并准备更换</td></tr></tbody></table><p><br></p><h2 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h2><p>2xx（成功），表示成功处理了请求。</p><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>200 - OK</td><td>Server已成功处理了请求</td></tr><tr><td>201 - Created</td><td>请求成功并且Server创建了新的资源</td></tr><tr><td>202 - Accepted</td><td>Server以接受请求，但尚未处理</td></tr><tr><td>203 - Non-Authoritative Information</td><td>Server已成功处理了请求，但返回的信息可能来自另一个来源</td></tr><tr><td>204 - No Content</td><td>Server成功处理了请求，但没有返回任何内容</td></tr><tr><td>205 - Reset Content</td><td>没有新的内容，但浏览器应该重置它所显示的内容</td></tr><tr><td>206 - Partial Content</td><td>服务器成功处理了部分GET请求</td></tr></tbody></table><p><br></p><h2 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h2><p>3xx（重定向），表示要完成请求需要进一步操作。</p><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>300 - Multiple Choices</td><td>针对请求，Server可执行多种操作</td></tr><tr><td>301 - Moved Permanently</td><td>请求的网页已移动到新位置</td></tr><tr><td>302 - Found</td><td>Server目前从不同位置的网页响应请求</td></tr><tr><td>303 - See Other</td><td>请求者对不同位置使用单独的GET请求来检索时</td></tr><tr><td>304 - Not Modified</td><td>自从上次请求后，请求的网页内容未修改过</td></tr><tr><td>305 - Use Proxy</td><td>请求者只能使用代理访问请求的网页</td></tr><tr><td>307 - Temporary Redirect</td><td>Server从不同位置的网页响应请求，但请求者继续使用原有位置进行请求</td></tr></tbody></table><p><br></p><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>4xx（请求错误），表示请求可能出错，妨碍了Server的处理。</p><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>400 - Bad Request</td><td>Server不理解请求的语法</td></tr><tr><td>401 - Unauthorized</td><td>请求要求身份认证</td></tr><tr><td>403 - Forbidden</td><td>Server拒绝请求</td></tr><tr><td>404 - Not Found</td><td>Server找不到请求的网页</td></tr><tr><td>405 - Method Not Allowed</td><td>请求方法不被允许</td></tr><tr><td>406 - Not Acceptable</td><td>无法使用请求的恩日工特性响应请求的网页</td></tr><tr><td>407 - Proxy Authentication Required</td><td>请求需要代理授权</td></tr><tr><td>408 - Request Timeout</td><td>Server等候请求时超时</td></tr><tr><td>409 - Conflict</td><td>Server在完成请求时发生冲突</td></tr><tr><td>410 - Gone</td><td>请求的资源以永久删除</td></tr><tr><td>411 - Length Required</td><td>Server不接受不含有效内容长度Header的请求</td></tr><tr><td>412 - Precondition Failed</td><td>Server为满足请求者在请求中设置的一个前提条件</td></tr><tr><td>413 – Request Entity Too Large</td><td>请求实体太大，Server无法处理</td></tr><tr><td>414 - Request URI Too Long</td><td>请求的URI过长，Server无法处理</td></tr><tr><td>415 – 不支持的媒体类型</td><td>请求的格式不受支持</td></tr><tr><td>416 – Requested Range Not Satisfiable</td><td>页面无法提供请求的范围</td></tr><tr><td>417 – 执行失败</td><td>Server未满足期望请求Header的要求</td></tr><tr><td>451</td><td>基于法律上的的原因，不能像请求者展示网页内容</td></tr></tbody></table><p><br></p><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p>5xx（服务器错误），表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</p><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>500 - Internal Server Error</td><td>Server遇到错误，无法完成请求</td></tr><tr><td>501 - Not Implemented</td><td>Server不具备完成请求的功能</td></tr><tr><td>502 - Bad Gateway</td><td>Server作为网关或代理时，从upstream收到无效响应</td></tr><tr><td>503 - Service Unavailable</td><td>Server暂时无法使用</td></tr><tr><td>504 - Gateway Timeout</td><td>Server作为网关或代理时，没有及时从upstream收到请求</td></tr><tr><td>505 - HTTP Version Not Supported</td><td>Server不支持请求中所用的HTTP版本</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常见HTTP请求方法&quot;&gt;&lt;a href=&quot;#常见HTTP请求方法&quot; class=&quot;headerlink&quot; title=&quot;常见HTTP请求方法&quot;&gt;&lt;/a&gt;常见HTTP请求方法&lt;/h1&gt;&lt;p&gt;HTTP协议的请求方法有：&lt;code&gt;GET, POST, HEAD PUT DELETE, OPTIONS, TRACE, CONNECT&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="https://zhang21.github.io/categories/Network/"/>
    
    
      <category term="HTTP" scheme="https://zhang21.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Filesystem Hierarchy Standard</title>
    <link href="https://zhang21.github.io/2017/11/27/FHS/"/>
    <id>https://zhang21.github.io/2017/11/27/FHS/</id>
    <published>2017-11-27T08:42:33.000Z</published>
    <updated>2017-12-08T06:54:59.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FHS介绍"><a href="#FHS介绍" class="headerlink" title="FHS介绍"></a>FHS介绍</h1><p>FHS(Filesystem Hierarchy Standard)，文件系统层次化标准：<a href="http://www.pathname.com/fhs" target="_blank" rel="noopener">http://www.pathname.com/fhs</a></p><p><br><br>FHS主要目的是希望让用户了解安装文件通常放置的目录。所以希望软件开发商、系统制定者以及维护系统的用户，都能够遵循FHS的标准。</p><p><strong>FHS-compliant system：</strong></p><table><thead><tr><th>-</th><th>可分享的(shareable)</th><th>不可分享的(unshareable)</th></tr></thead><tbody><tr><td>不变的(static)</td><td>/usr <br> /opt</td><td>/etc <br> /boot</td></tr><tr><td>可变的(variable)</td><td>/var/mail <br> /var/spool/news</td><td>/var/run <br> /var/lock</td></tr></tbody></table><a id="more"></a><ul><li>shareable： 可分享给其他系统(主机)挂载使用；</li><li>unshareable： 不适合分享给其他主机；</li><li>static： 有些数据基本是不会变化的；</li><li>variable： 进程变更的数据。</li></ul><p><br><br>FHS针对目录树架构仅定义出三层目录下应该放置什么数据，这三个目录下所应该放置的目录也都有特定规定。</p><ul><li><code>/</code>： The root filesystem, 与开机系统有关；</li><li><code>/usr</code>: The /usr hierarchy, Unix software resource；</li><li><code>/var</code>: The /var hierarchy, 与系统运行过程有关。</li></ul><p><br><br><br></p><h1 id="The-Root-Filesystem"><a href="#The-Root-Filesystem" class="headerlink" title="The Root Filesystem"></a>The Root Filesystem</h1><p><strong>根目录(/)</strong>是系统最重要的一个目录。不但所有目录都是由根目录衍生出来，同时根目录还与<strong>系统的启动、还原、修复</strong>等操作相关。<br>若系统出现问题，根目录必须要包含能够修复文件系统的程序才行。<br>破坏根文件系统上的数据的错误比破坏其他任何分区都要严重！</p><p>为了平衡这些考虑，建议尽可能保持根分区小。<br>应用程序不应在根目录中创建特殊文件或子目录！</p><p><br><br>The following dirs or symbolic-links, are required in /</p><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td><code>/bin</code></td><td>必要的二进制命令</td></tr><tr><td><code>/boot</code></td><td>boot-loader的静态文件</td></tr><tr><td><code>/dev</code></td><td>设备文件</td></tr><tr><td><code>/etc</code></td><td>主机特定的系统配置文件</td></tr><tr><td><code>/lib</code></td><td>基本的共享库(shared libraries)和内核模块(kernel modules)</td></tr><tr><td><code>/media</code></td><td>可移除媒体的挂载点</td></tr><tr><td><code>/mnt</code></td><td>临时挂载文件系统的挂载点</td></tr><tr><td><code>/opt</code></td><td>第三方软件包放置目录</td></tr><tr><td><code>/sbin</code></td><td>必要的系统二进制命令</td></tr><tr><td><code>/srv</code></td><td>系统提供的服务数据</td></tr><tr><td><code>/tmp</code></td><td>临时文件</td></tr><tr><td><code>/usr</code></td><td>/usr层次结构</td></tr><tr><td><code>/var</code></td><td>/var层次结构</td></tr></tbody></table><p><br><br>除了上面列出必须存在的目录，下面这些目录很也很重要。</p><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td><code>/lost+found</code></td><td>在ext文件系统里，当文件系统发生错误时，将一些遗失的片段放置到此目录下</td></tr><tr><td><code>/home</code></td><td>用户家目录</td></tr><tr><td><code>/root</code></td><td>root用户家目录</td></tr><tr><td><code>/proc</code></td><td>虚拟文件系统，放置的数据都在内存当中，不占磁盘空间</td></tr><tr><td><code>/sys</code></td><td>虚拟文件系统，记录内核相关信息，不占磁盘空间</td></tr></tbody></table><p><br><br>另外需要注意的是，因为根目录与开机有关，开机过程中仅有根目录被挂载。其他分区则是在开机完成后才会持续进行挂载。<br>因此，根目录下与开机过程有关的目录就不能放到不同的分区中去。</p><p>如：</p><ul><li><code>/etc</code></li><li><code>/bin</code></li><li><code>/sbin</code></li><li><code>/dev</code></li><li><code>/lib</code></li></ul><p><br></p><h2 id="bin"><a href="#bin" class="headerlink" title="/bin"></a>/bin</h2><p><code>/bin</code>, 基本用户二进制命令文件，供所有用户（系统管理员和用户）使用。</p><p><code>/bin</code>下不能有子目录(subdirectory)。</p><p><br><br>The following commands or symbolic-links to commands, are required in /bin</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>cat</code></td><td>将文件连接到stdout的实用程序(Utility)</td></tr><tr><td><code>chgrp</code></td><td>更改文件所有权</td></tr><tr><td><code>chmod</code></td><td>更改文件访问权限</td></tr><tr><td><code>chown</code></td><td>更改文件所有者和和组</td></tr><tr><td><code>cp</code></td><td>复制文件和目录</td></tr><tr><td><code>date</code></td><td>打印或设置系统数据和时间</td></tr><tr><td><code>dd</code></td><td>转换和复制文件</td></tr><tr><td><code>df</code></td><td>磁盘使用情况</td></tr><tr><td><code>dmesg</code></td><td>打印或控制kernel消息缓冲区</td></tr><tr><td><code>echo</code></td><td>显示一行文本</td></tr><tr><td><code>false</code></td><td>do nothing, 不成功</td></tr><tr><td><code>true</code></td><td>do nothing, 成功</td></tr><tr><td><code>hostname</code></td><td>系统主机名</td></tr><tr><td><code>kill</code></td><td>发送信号到进程</td></tr><tr><td><code>ln</code></td><td>在文件之间创建链接</td></tr><tr><td><code>login</code></td><td>在系统上开始会话</td></tr><tr><td><code>ls</code></td><td>列出目录内容</td></tr><tr><td><code>mkdir</code></td><td>创建目录</td></tr><tr><td><code>mknod</code></td><td>创建block或character特殊文件</td></tr><tr><td><code>more</code></td><td>文本翻页</td></tr><tr><td><code>mount</code></td><td>挂载文件系统</td></tr><tr><td><code>umount</code></td><td>解挂文件系统</td></tr><tr><td><code>mv</code></td><td>move/rename文件</td></tr><tr><td><code>ps</code></td><td>报告进程状态</td></tr><tr><td><code>pwd</code></td><td>打印当前工作目录</td></tr><tr><td><code>rm</code></td><td>remove文件或目录</td></tr><tr><td><code>sed</code></td><td>sed流编辑器</td></tr><tr><td><code>sh</code></td><td>Bourne command shell</td></tr><tr><td><code>stty</code></td><td>更改或打印终端设置</td></tr><tr><td><code>su</code></td><td>change uid</td></tr><tr><td><code>sync</code></td><td>刷新文件系统缓冲区</td></tr><tr><td><code>uname</code></td><td>打印系统信息</td></tr></tbody></table><p><br><br>The following programs or symbolic-links to programs, must be in /bin if the corresponding-system is installed:</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>csh</code></td><td>The C shell(可选)</td></tr><tr><td><code>ed</code></td><td>编辑器(可选)</td></tr><tr><td><code>tar</code></td><td>tar归档(可选)</td></tr><tr><td><code>cpio</code></td><td>cpio归档(可选)</td></tr><tr><td><code>gzip</code></td><td>GNU压缩工具(可选)</td></tr><tr><td><code>gunzip</code></td><td>GNU解压缩工具(可选)</td></tr><tr><td><code>netstat</code></td><td>网络统计(可选)</td></tr><tr><td><code>ping</code></td><td>ICMP网络测试(可选)</td></tr></tbody></table><p><br></p><h2 id="boot"><a href="#boot" class="headerlink" title="/boot"></a>/boot</h2><p><code>/boot</code> :static file of the boot-loader</p><p>该目录包含引导过程所需所有内容，处理引导是不需要的配置文件和映射安装文件外。<br>因此，/boot储存kernel开始执行用户模式之前使用的数据。</p><p><strong><br>操作系统kernel必须位于 / or /boot</strong></p><p><br></p><h2 id="dev"><a href="#dev" class="headerlink" title="/dev"></a>/dev</h2><p><code>/dev</code> :device files</p><p><code>/dev</code> 目录是特殊或设备文件的位置。</p><p><br></p><h2 id="etc"><a href="#etc" class="headerlink" title="/etc"></a>/etc</h2><p><code>/etc</code> :host-specific system configuration</p><p>配置文件是用来控制程序操作的本地静态文件，不能是可执行的二进制文件。</p><p><br><br>The following files or symbolic-links to files, must be in /etc if the corresponding-subsystem is installed.</p><table><thead><tr><th>文件</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>csh.login</td><td>C shell登录的系统范围初始化文件</td><td>Optional</td></tr><tr><td>exports</td><td>NFS文件系统访问控制列表</td><td>Optional</td></tr><tr><td>fstab</td><td>文件系统静态信息</td><td>Optional</td></tr><tr><td>ftpusers</td><td>FTP守护进程用户访问控制列表</td><td>Optional</td></tr><tr><td>gateways</td><td>路由网关文件</td><td>Optional</td></tr><tr><td>gettydefs</td><td>getty终端设置</td><td>Optional</td></tr><tr><td>group</td><td>用户组文件</td><td>Optional</td></tr><tr><td>passwd</td><td>密码文件</td><td>Optional</td></tr><tr><td>host.conf</td><td>解析器配置文件</td><td>Optional</td></tr><tr><td>hosts</td><td>主机域名的静态信息</td><td>Optional</td></tr><tr><td>hosts.allow</td><td>Tcp-wrapper的主机访问文件</td><td>Optional</td></tr><tr><td>hosts.deny</td><td>Tcp-wrapper的主机禁止文件</td><td>Optional</td></tr><tr><td>hosts.equiv</td><td>rlogin, rsh, rcp的可信主机列表</td><td>Optional</td></tr><tr><td>hosts.lpd</td><td>lpd的可信主机列表</td><td>Optional</td></tr><tr><td>inetd.conf</td><td>inetd配置文件</td><td>Optional</td></tr><tr><td>inittab</td><td>init配置文件</td><td>inittab is no longer used when using systemd</td></tr><tr><td>id.so.conf</td><td>搜索共享库的额外目录</td><td>Optional</td></tr><tr><td>issue</td><td>预登录消息和</td><td>CentOS Linux 7(core) kernel \r on an \m</td></tr><tr><td>motd</td><td>登录后信息</td><td>Welcome to $host</td></tr><tr><td>mtab</td><td>文件系统动态信息</td><td>Optional</td></tr><tr><td>mtools.conf</td><td>mtools配置文件</td><td>Optional</td></tr><tr><td>networks</td><td>网络名称的静态信息</td><td>Optional</td></tr><tr><td>printcap</td><td>lpd打印机功能数据库</td><td>Optional</td></tr><tr><td>profile</td><td>sh shell login的系统范围初始化文件</td><td>Optional</td></tr><tr><td>protocols</td><td>IP协议列表</td><td>Optional</td></tr><tr><td>resolv.conf</td><td>域名服务器解析文件</td><td>Optional</td></tr><tr><td>rpc</td><td>RPC协议列表</td><td>Optional</td></tr><tr><td>securetty</td><td>root登录的TTY访问控制</td><td>Optional</td></tr><tr><td>shells</td><td>有效登录shell的路径名</td><td>Optional</td></tr><tr><td>syslog.conf</td><td>syslogd配置文件</td><td>Optional</td></tr></tbody></table><p><br></p><h2 id="etc-opt"><a href="#etc-opt" class="headerlink" title="/etc/opt"></a>/etc/opt</h2><p>/etc/opt :/opt的配置文件</p><p>第三方应用程序软件的特定主机配置文件，必须安装在/etc/opt/<subdir> 中。</subdir></p><p><br></p><h2 id="etc-xml"><a href="#etc-xml" class="headerlink" title="/etc/xml"></a>/etc/xml</h2><p><code>/etc/xml</code> :XML的配置文件</p><p>这里安装和定义XML系统的高级参数同通用配置文件。</p><p><br></p><h2 id="home-Optional"><a href="#home-Optional" class="headerlink" title="/home (Optional)"></a>/home (Optional)</h2><p><code>/home</code> :用户主目录</p><p><code>/home</code>是一个相当标准的概念，但它显然是一个特定于站点的文件系统。设置会因主机而异。<br>因此，任何程序都不应该依赖这个目录。</p><p><br></p><h2 id="lib"><a href="#lib" class="headerlink" title="/lib"></a>/lib</h2><p><code>/lib</code> :基本的共享库和内核模块</p><p><code>/lib</code>目录中包含引导系统和运行在根文件系统的命令，即<code>/bin</code>和<code>/sbin</code>中的命令。</p><p><br><br>至少需要包含以下文件(链接)：</p><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td><code>libc.so.*</code></td><td>动态链接C库</td></tr><tr><td><code>ld*</code></td><td>执行时间 链接器/加载器</td></tr></tbody></table><p><br></p><h2 id="lib-Optional"><a href="#lib-Optional" class="headerlink" title="/lib (Optional)"></a>/lib<qual> (Optional)</qual></h2><p><code>/lib&lt;qual&gt;</code> : 不同格式的基本共享函数库<br>如：64位的<code>/lib64</code>; 32位的<code>/lib32</code>。</p><p>用来存放与/lib不同格式的二进制函数库，如支持64位的/lib64函数库等。</p><p><br></p><h2 id="media"><a href="#media" class="headerlink" title="/media"></a>/media</h2><p><code>/media</code> :可移除媒体的挂载点</p><p>此目录包含的子目录，可作为各移动介质(USB,cdrom,floppy…)的挂载点。</p><p>尽管在 /mnt 中使用子目录作为挂载点已经很常见了，但与直接使用/mnt作为临时挂载点的传统相去甚远。</p><p><br></p><h2 id="mnt"><a href="#mnt" class="headerlink" title="/mnt"></a>/mnt</h2><p><code>/mnt</code> :临时挂载文件系统的挂载点</p><p><br></p><h2 id="opt"><a href="#opt" class="headerlink" title="/opt"></a>/opt</h2><p><code>/opt</code> :为第三方软件包保留的目录</p><p>要安装在<code>/opt</code>中的软件包必须将其静态文件放置在单独的<code>/opt/&lt;packge&gt;</code>目录树中。</p><p>目录/opt/bin, /opt/doc, /opt/include, /opt/info, /opt/lib, /opt/man 是保留给本地系统管理员使用。<br>如果第三方软件包含Unix手册，而手册必须放置于/opt/<package>/share/man/，必须使用与/usr/share/man相同的子结构。</package></p><p><br></p><h2 id="root-Optional"><a href="#root-Optional" class="headerlink" title="/root (Optional)"></a>/root (Optional)</h2><p><code>/root</code> :root用户的主目录</p><p><br></p><h2 id="sbin"><a href="#sbin" class="headerlink" title="/sbin"></a>/sbin</h2><p><code>/sbin</code> :系统二进制文件</p><p>系统管理的实用程序(命令)，存储在<code>/sbin, /usr/sbin, /usr/local/sbin</code>中。<br><code>/sbin</code>包含<strong>启动，恢复，修复</strong>系统，以及<code>/bin</code>中二进制文件所必须的二进制文件。<br>本地安装的系统管理程序应放置在<code>/usr/local/sbin</code>中。</p><p><br><br>The following commands or symbolic-links to commands are required in /sbin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shutdown#关闭系统</div></pre></td></tr></table></figure></p><p><br><br>The following files or symbolic-links to files，must be in /sbin if the corresponding subsystem is installed</p><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>fastboot</code></td><td>重启系统而不检查磁盘</td><td>Optional</td></tr><tr><td><code>fasthalt</code></td><td>停止系统而不检查磁盘</td><td>Optional</td></tr><tr><td><code>fdisk</code></td><td>分区表操作器</td><td>Optional</td></tr><tr><td><code>fsck</code></td><td>文件系统检查和修理工具</td><td>Optional</td></tr><tr><td><code>fsck.*</code></td><td>针对特定文件系统检查和修复</td><td>Optional<br>eg：fsck.ext3</td></tr><tr><td><code>getty</code></td><td>getty程序</td><td>Optional</td></tr><tr><td><code>half</code></td><td>停止系统</td><td>Optional</td></tr><tr><td><code>ifconfig</code></td><td>配置网络接口</td><td>Optional</td></tr><tr><td><code>init</code></td><td>初始化进程</td><td>Optional</td></tr><tr><td><code>mkfs</code></td><td>创建文件系统</td><td>Optional</td></tr><tr><td><code>mkfs.*</code></td><td>创建特定文件系统</td><td>OPtional<br>eg: mkfs.ext4</td></tr><tr><td><code>mkswap</code></td><td>设置swap分区</td><td>OPtional</td></tr><tr><td><code>reboot</code></td><td>重启系统</td><td>OPtional</td></tr><tr><td><code>route</code></td><td>IP路由表实用程序</td><td>OPtional</td></tr><tr><td><code>swapon</code></td><td>启用分页和交换</td><td>OPtional</td></tr><tr><td><code>swapoff</code></td><td>Disable paging and swapping</td><td>Optional</td></tr><tr><td><code>update</code></td><td>守护进程定期刷新文件系统缓冲区</td><td>Optional</td></tr></tbody></table><p><br></p><h2 id="srv"><a href="#srv" class="headerlink" title="/srv"></a>/srv</h2><p><code>/srv</code> :系统提供的服务(service)的数据</p><p><br></p><h2 id="tmp"><a href="#tmp" class="headerlink" title="/tmp"></a>/tmp</h2><p><code>/tmp</code> :临时文件</p><p><code>/tmp</code>目录为临时需要文件的程序提供。<br>程序不能在程序的调用之间保留/tmp中的任何文件或目录。<br>尽管/tmp中数据可能会以某种特定方式删除，但建议在系统启动时删除/tmp中所有文件。</p><p><br><br><br></p><h1 id="The-usr-Hierarchy"><a href="#The-usr-Hierarchy" class="headerlink" title="The /usr Hierarchy"></a>The /usr Hierarchy</h1><p><code>/usr</code> 里面放置的数据是可分享与不可变动的。<br>这就意味着可在各种符合FHS的主机之间共享，但不能写入。<br>大型软件包不应在/usr层次结构下使用直接子目录。</p><p><br><br>The following dirs of symbolic-links to dirs are required in /usr</p><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td><code>/usr/bin</code></td><td>大多数用户命令</td></tr><tr><td><code>/usr/include</code></td><td>C程序包含的头文件</td></tr><tr><td><code>/usr/lib</code></td><td>库文件</td></tr><tr><td><code>/usr/local</code></td><td>本地层次结构</td></tr><tr><td><code>/usr/sbin</code></td><td>非重要的系统二进制文件</td></tr><tr><td><code>/usr/share</code></td><td>独立于架构的数据</td></tr></tbody></table><p>其他选项：</p><table><thead><tr><th>目录</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>/usr/lib&lt;qual&gt;</code></td><td>可选格式库</td><td>Optional</td></tr><tr><td><code>/usr/src</code></td><td>源代码</td><td>OPtional</td></tr><tr><td><code>/usr/games</code></td><td>游戏和教育二进制文件</td><td>OPtional</td></tr></tbody></table><p><br></p><h2 id="usr-bin"><a href="#usr-bin" class="headerlink" title="/usr/bin"></a>/usr/bin</h2><p><code>/usr/bin</code> :大多数用户命令<br>这是系统上可执行命令的主要目录。</p><p><br><br>The following files or symbolic-links to files must be in /usr/bin, if the corresponding subsystem is installed</p><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>perl</code></td><td>实用提取和报告语言</td><td>OPtional</td></tr><tr><td><code>python</code></td><td>python解释语言</td><td>Optional</td></tr><tr><td><code>tclsh</code></td><td>tcl解释器的简单shell</td><td>OPtional</td></tr><tr><td><code>wish</code></td><td>简单 tcl/tk windowing shell</td><td>Optional</td></tr><tr><td><code>expect</code></td><td>程序交互式对话</td><td>Optional</td></tr></tbody></table><p>因为shell script解释器(在shell script脚本的第一行 #!<path></path>)不能依赖路径，所以标准化它们的位置是有利的。<br>Bourne shell 和 C-shell解释器已经被固定在/bin中，但 perl,python,tcl经常在许多不同的地方。</p><p><br></p><h2 id="usr-include"><a href="#usr-include" class="headerlink" title="/usr/include"></a>/usr/include</h2><p><code>/usr/include</code> :标准C包含文件的目录</p><p>这是C语言所有系统的通用包含文件应该被放置的地方。</p><p><br></p><h2 id="usr-lib"><a href="#usr-lib" class="headerlink" title="/usr/lib"></a>/usr/lib</h2><p><code>/usr/lib</code> :编程和包的所需要的库</p><p><code>/usr/lib</code>包括 不打算由用户或shell script直接执行的目标文件、库和内部二进制文件。</p><p><br></p><h2 id="usr-lib-Optional"><a href="#usr-lib-Optional" class="headerlink" title="/usr/lib (Optional)"></a>/usr/lib<qual> (Optional)</qual></h2><p><code>/usr/lib&lt;qual&gt;</code> :可选格式库</p><p><br></p><h2 id="usr-local"><a href="#usr-local" class="headerlink" title="/usr/local"></a>/usr/local</h2><p><code>/usr/local</code> :本地层次结构</p><p><code>/usr/local</code>是给系统管理员安装本地软件使用。当系统软件更新时，需保证安全。<br>它可以用于在一组主机之间共享，但在 <code>usr</code>中找不到的程序和数据。</p><p>本地安装软件必须放在 <code>/usr/local</code> 而不是 <code>/usr</code>，除非安装它来升级或替换<code>usr</code>的软件</p><p><br><br>The following dirs or symbolic-links to dis must be in <code>/usr/local</code></p><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td><code>/usr/local/bin</code></td><td>本地二进制文件</td></tr><tr><td><code>/usr/local/etc</code></td><td>本地二进制文件的特定配置文件</td></tr><tr><td><code>/usr/local/games</code></td><td>本地游戏二进制文件</td></tr><tr><td><code>/usr/local/include</code></td><td>本地C头文件</td></tr><tr><td><code>/usr/local/lib</code></td><td>本地库</td></tr><tr><td><code>/usr/local/man</code></td><td>本地在线手册</td></tr><tr><td><code>/usr/local/sbin</code></td><td>本地系统二进制文件</td></tr><tr><td><code>/usr/local/share</code></td><td>本地独立架构层次结构</td></tr><tr><td><code>/usr/local/src</code></td><td>本地源码</td></tr></tbody></table><p><code>/usr/local/share</code>目录内容的要求应与<code>/usr/share</code>相同，唯一附加约束是<code>/usr/local/share/man</code>和<code>/usr/local/man</code>目录必须是同步的。（基本上就是符号链接了！）</p><p><br></p><h2 id="usr-sbin"><a href="#usr-sbin" class="headerlink" title="/usr/sbin"></a>/usr/sbin</h2><p><code>/usr/sbin</code> :非必要的标准系统二进制文件</p><p>该目录包含系统管理员专门使用的任何非必要的二进制文件。<br>系统修复、恢复、挂载/usr等其他重要必要功能必须放在/sbin中。</p><p><br></p><h2 id="usr-share"><a href="#usr-share" class="headerlink" title="/usr/share"></a>/usr/share</h2><p><code>/usr/share</code> :独立于架构的数据</p><p><code>/usr/share</code>层次 是为了所有只读架构独立数据。<br>该层次可以在给定OS的所有体系架构平台之间共享。如具有i386和PPC平台站点可能会维护一个集中安装的/usr/share目录。<br>但<code>/usr/share</code>一般不打算由不同的操作系统共享，或由同一操作系统的不同版本共享。</p><p><br><br>The following dis or symbolic-links to dirs must be in /usr/share</p><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td>man</td><td>在线手册</td></tr><tr><td>misc</td><td>其他独立于架构的数据</td></tr></tbody></table><p><br><br>The following dis or symbolic-links to dirs must be in /usr/share, if the corresponding subsystem is installed</p><table><thead><tr><th>目录</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>dict</td><td>单词列表</td><td>Optional</td></tr><tr><td>doc</td><td>各种文档</td><td>Optional</td></tr><tr><td>games</td><td>/usr/games的静态文件</td><td>Optional</td></tr><tr><td>info</td><td>GNU Info system’s primary dir</td><td>Optional</td></tr><tr><td>locale</td><td>支持的区域信息</td><td>Optional</td></tr><tr><td>zoneinfo</td><td>Timezone info and conf</td><td>Optional</td></tr><tr><td>NLS</td><td>Native language support</td><td>Optional</td></tr><tr><td>sgml</td><td>SGML数据</td><td>Optional</td></tr><tr><td>terminfo</td><td>terminfo数据库目录</td><td>Optional</td></tr><tr><td>xml</td><td>xml数据</td><td>Optional</td></tr></tbody></table><p><br></p><h3 id="usr-share-dict"><a href="#usr-share-dict" class="headerlink" title="/usr/share/dict"></a>/usr/share/dict</h3><p><code>/usr/share/dict</code> :单词列表<br>这个目录是系统上单词列表的家目录，只包含英文单词，它们由<code>look</code>和各种拼写程序使用。<br>它们是所有拼写检查器唯一通用的文件。</p><table><thead><tr><th>文件</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>words</td><td>单词列表</td><td>Optional</td></tr><tr><td>linu.words</td><td>linux可用单词列表</td><td>Optional</td></tr></tbody></table><p><br></p><h3 id="usr-share-man"><a href="#usr-share-man" class="headerlink" title="/usr/share/man"></a>/usr/share/man</h3><p><code>/usr/share/man</code> :手册页<br>它包含了<code>/</code>, <code>/usr</code>文件系统下的命令和数据的手册信息</p><p>手册页存储在 <code>/usr/share/man/&lt;locale&gt;/man&lt;section&gt;/&lt;arch&gt;</code>中。</p><p>每个部分的描述：</p><ul><li>man1: 可公开访问的命令的手册页，用户需要使用的大多数程序文档放置于此；</li><li>man2: 系统调用部分，描述所有的系统调用(请求内核执行操作)；</li><li>man3: 函数库和子例程部分，描述不直接调用内核服务的程序库例程；</li><li>man4: 特定文件部分，描述系统中特定文件，相关驱动程序和网络支持。通常，这包含/dev中找到的设备以及网络协议支持的内核接口；</li><li>man5: 文件格式部分，许多数据文件的格式记录在此；</li><li>man6: 游戏，演示和一般小程序；</li><li>man7: 各种难以分类的手册页；</li><li>man8: 系统管理员用于操作和维护系统的程序记录在这。</li></ul><p><br><br>The following dirs or symboli-link to dirs must be in <code>/usr/share/man/&lt;locale&gt;</code>, unless they are empty</p><table><thead><tr><th>目录</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>man1</td><td>用户程序</td><td>Optional</td></tr><tr><td>man2</td><td>系统调用</td><td>Optional</td></tr><tr><td>man3</td><td>函数库调用</td><td>Optional</td></tr><tr><td>man4</td><td>特定文件</td><td>Optional</td></tr><tr><td>man5</td><td>文件格式</td><td>Optional</td></tr><tr><td>man6</td><td>游戏</td><td>Optional</td></tr><tr><td>man7</td><td>混杂的手册页</td><td>Optional</td></tr><tr><td>man8</td><td>系统管理</td><td>Optional</td></tr></tbody></table><p><br><br>必须在<code>/usr/share/man</code>结构中作出规定，以支持用不同语言编写的手册页。这些规定必须考虑到手册页的存储和参考，相关因素包括语言和字符编码集。</p><p>栗子：</p><table><thead><tr><th>Language</th><th>Country</th><th>CharacterSet</th><th>Dir</th></tr></thead><tbody><tr><td>English</td><td>-</td><td>ASCII</td><td>/usr/share/man/en</td></tr><tr><td>English</td><td>United Kingdom</td><td>ISO 8859-15</td><td>/usr/share/man/en_GB</td></tr><tr><td>English</td><td>United States</td><td>ASCII</td><td>/usr/share/man/en_US</td></tr></tbody></table><p><br></p><h3 id="usr-share-misc"><a href="#usr-share-misc" class="headerlink" title="/usr/share/misc"></a>/usr/share/misc</h3><p><code>/usr/share/misc</code> :与架构无关的数据</p><p><br></p><h3 id="usr-share-sgml"><a href="#usr-share-sgml" class="headerlink" title="/usr/share/sgml"></a>/usr/share/sgml</h3><p><code>/usr/share/sgml</code> :SGML数据</p><p><br></p><h3 id="usr-share-xml"><a href="#usr-share-xml" class="headerlink" title="/usr/share/xml"></a>/usr/share/xml</h3><p><code>/usr/share/xml</code> :XML数据</p><p><br></p><h2 id="usr-src"><a href="#usr-src" class="headerlink" title="/usr/src"></a>/usr/src</h2><p><code>/usr/src</code> :源代码<br>Source Code可能放置在此目录的子目录中，仅供参考。</p><p><br><br><br></p><h1 id="var-Hierarchy"><a href="#var-Hierarchy" class="headerlink" title="/var Hierarchy"></a>/var Hierarchy</h1><p><code>/var</code> 包含可变数据文件，包括假脱机目录和文件，系统管理和登录数据，以及临时文件。</p><p>如果<code>/var</code>不能成为一个单独的分区，最好将<code>/var</code>移出<code>/</code>分区并移入<code>/usr</code>分区。（为了减小根分区大小或当根分区空间不足时）<br>也可将<code>/var</code>链接到<code>/usr/var</code>。</p><p><br><br>The following dirs or symbolic-link to dirs are required in <code>/var</code>.</p><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td><code>/var/cache</code></td><td>应用程序缓存数据</td></tr><tr><td><code>/var/lib</code></td><td>可变状态信息</td></tr><tr><td><code>/var/local</code></td><td>/usr/local的可变数据</td></tr><tr><td><code>/var/lock</code></td><td>锁文件</td></tr><tr><td><code>/var/log</code></td><td>日志文件</td></tr><tr><td><code>/var/opt</code></td><td>/opt的可变数据</td></tr><tr><td><code>/var/run</code></td><td>与运行进程相关的数据</td></tr><tr><td><code>/var/spool</code></td><td>应用程序队列数据</td></tr><tr><td><code>/var/tmp</code></td><td>为系统重启保留的临时文件</td></tr></tbody></table><p><br><br>The following dirs or symbolic-link to dir must be in /var,if the corresponding subsystem is installed.</p><table><thead><tr><th>目录</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>/var/account</code></td><td>进程账户日志</td><td>可选</td></tr><tr><td><code>/var/crash</code></td><td>系统奔溃转储</td><td>可选</td></tr><tr><td><code>/var/games</code></td><td>可变游戏数据</td><td>可选</td></tr><tr><td><code>/var/mail</code></td><td>用户邮箱文件</td><td>可选</td></tr><tr><td><code>/var/yp</code></td><td>网络信息服务数据库文件</td></tr></tbody></table><p><br></p><h2 id="var-account"><a href="#var-account" class="headerlink" title="/var/account"></a>/var/account</h2><p><code>/var/account</code> :该目录保存当前活动的进程记账日志和复合进程数据。</p><p><br></p><h2 id="var-cache"><a href="#var-cache" class="headerlink" title="/var/cache"></a>/var/cache</h2><p><code>/var/cache</code> :保存应用程序缓存的数据。应用程序必须能够重新生成或回复数据。<br>与<code>/var/spool</code>不同，删除了缓存文件不会丢失数据。数据必须在应用程序调用和系统重启间保持有效。<br>缓存目录的数据格式没有其他要求。</p><p>对于缓存数据单独存在的目录，系统管理员可从<code>/var</code>下其他目录设备不同的磁盘和备份策略。</p><table><thead><tr><th>目录</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>/var/cache/fonts</code></td><td>本地生成的字体</td><td>可选</td></tr><tr><td><code>/var/cache/man</code></td><td>本地格式化的手册页</td><td>可选</td></tr><tr><td><code>/var/cache/www</code></td><td>www代理或缓存数据</td><td>可选</td></tr><tr><td><code>/var/cache/&lt;package&gt;</code></td><td>特定包缓存数据</td><td>可选</td></tr></tbody></table><p><br></p><h2 id="var-lib"><a href="#var-lib" class="headerlink" title="/var/lib"></a>/var/lib</h2><p><code>/var/lib</code> :可变状态信息。目录保存于应用程序或系统有关的状态信息。<br>状态信息(state infofmation)，是程序在运行时修改的数据，属于一个特定的主机。</p><p>应用程序必须为其数据使用<code>/var/lib/&lt;subdir&gt;</code>，有一个必须的子目录<code>/var/lib/misc</code>用于不需要子目录的状态文件。</p><p><br></p><h2 id="var-lock"><a href="#var-lock" class="headerlink" title="/var/lock"></a>/var/lock</h2><p><code>/var/lock</code> :锁文件，锁文件应该存储在此目录中。<br>锁文件锁定多个应用程序共享的设备和其他资源。</p><p>这种锁文件内容的格式必须是HDB UUCP锁文件格式。<br>HDB格式是将进程标识符(PID)存储为ASCII十进制数，并带有换行符。</p><p><br></p><h2 id="var-log"><a href="#var-log" class="headerlink" title="/var/log"></a>/var/log</h2><p><code>/var/log</code> :日志文件和目录，大多数日志必须写入此目录或适当子目录。</p><p><br><br>The following file or symbolic-link to file must be in /var/log.</p><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td>lastlog</td><td>每个用户上次登录信息的记录</td></tr><tr><td>message</td><td>syslogd的系统信息</td></tr><tr><td>wtmp</td><td>所有登录和注销的记录</td></tr></tbody></table><p><br></p><h2 id="var-mail"><a href="#var-mail" class="headerlink" title="/var/mail"></a>/var/mail</h2><p>邮件缓存区必须通过<code>/var/mail</code>访问，邮件缓冲区文件必须采用<username>的形式。</username></p><p><br></p><h2 id="var-run"><a href="#var-run" class="headerlink" title="/var/run"></a>/var/run</h2><p><code>/var/run</code> :运行时变化数据，此目录包含系统信息数据，描述系统启动以来的情况。<br>此目录下的文件必须在引导过程开始时被清除。<br>进程标识符(PID)文件放置于此目录或下的子目录里面。</p><p><br></p><h2 id="var-spool"><a href="#var-spool" class="headerlink" title="/var/spool"></a>/var/spool</h2><p><code>/var/spool</code> :应用程序队列数据。<br>此目录包含正在等待某种稍后处理的数据，/var/spool中的数据表示工作将在将来执行(通过程序，用户或管理员)，数据通常会在工作处理后被删除。</p><p><br><br>The following dirs or symbolic-link to dirs must be in /var/spool,if the corresponding subsystem is installed.</p><table><thead><tr><th>目录</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>lpd</td><td>打印机队列目录</td><td>可选</td></tr><tr><td>mqueue</td><td>发送邮件队列</td><td>可选</td></tr><tr><td>news</td><td>新闻假脱机目录</td><td>可选</td></tr><tr><td>rwho</td><td>rwhod文件</td><td>可选</td></tr><tr><td>uucp</td><td>uucp的假脱机目录</td><td>可选</td></tr></tbody></table><p><br></p><h2 id="var-tmp"><a href="#var-tmp" class="headerlink" title="/var/tmp"></a>/var/tmp</h2><p><code>/var/tmp</code> :在系统重启之间保存的临时文件。存储在<code>/var/tmp</code>的数据比<code>/tmp</code>中的数据更持久。</p><p><br><br><br></p><h1 id="OS-Specific-Annex"><a href="#OS-Specific-Annex" class="headerlink" title="OS Specific Annex"></a>OS Specific Annex</h1><p>本节是针对仅适用于特定OS的其他建议和要求。</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>Linux操作系统的附件</p><h3 id="根目录"><a href="#根目录" class="headerlink" title="/ :根目录"></a>/ :根目录</h3><p>在Linux系统上，如果内核位于<code>/</code>，建议使用Linux内核源代码包中使用的名称<strong>vmlinux或vmlinuz</strong>。</p><p>我的<code>CentOS7</code>中，内核文件默认是<code>/boot/vmlinuz-$kernel-version.$arch</code></p><p><br></p><h3 id="bin-基本用户命令二进制文件-供多有用户使用"><a href="#bin-基本用户命令二进制文件-供多有用户使用" class="headerlink" title="/bin :基本用户命令二进制文件(供多有用户使用)"></a>/bin :基本用户命令二进制文件(供多有用户使用)</h3><p><br></p><h3 id="dev-设备和特殊文件"><a href="#dev-设备和特殊文件" class="headerlink" title="/dev :设备和特殊文件"></a>/dev :设备和特殊文件</h3><ol><li><code>/dev/null</code> :<br> 写入该设备的所有数据都被丢弃。从这个设备读取将返回一个EOF条件。</li><li><code>/dev/zero</code> :<br> 该设备是归零数据的来源，写入该设备的所有数据被丢弃。从这个设备读取将返回包含zero的请求的字节数。</li><li><code>/dev/tty</code> :<br> 该设备类似于进程控制终端。一旦这个设备被打开，所有读写操作就好像实际的控制终端以及被打开一样。</li></ol><p><br></p><h3 id="etc-主机的特定系统配置"><a href="#etc-主机的特定系统配置" class="headerlink" title="/etc :主机的特定系统配置"></a>/etc :主机的特定系统配置</h3><p>Linux系统要将附件文件放置到<code>/etc</code>中。</p><p><br></p><h3 id="lib64-和-lib32-64-32位库-依赖于体系结构"><a href="#lib64-和-lib32-64-32位库-依赖于体系结构" class="headerlink" title="/lib64 和 /lib32 :64/32位库(依赖于体系结构)"></a>/lib64 和 /lib32 :64/32位库(依赖于体系结构)</h3><p>64位体系结构PPC64,AMD64,x86_64必须将64位库放置于<code>/lib64</code>中，将32位库放置于<code>/lib</code>中；<br>64位体系结构IA64必须将64位库放置于<code>/lib</code>中。</p><p><br></p><h3 id="proc-内核和进程信息虚拟文件系统"><a href="#proc-内核和进程信息虚拟文件系统" class="headerlink" title="/proc :内核和进程信息虚拟文件系统"></a>/proc :内核和进程信息虚拟文件系统</h3><p>PROC文件系统是用于处理进程和系统信息的标准Linux方法，而不是/dev/kmem和其它类似方法。<br>强烈建议使用PROC文件系统获取 存储，进程，内存，内核等信息。</p><p><br></p><h3 id="sbin-基本系统二进制文件"><a href="#sbin-基本系统二进制文件" class="headerlink" title="/sbin :基本系统二进制文件"></a>/sbin :基本系统二进制文件</h3><p>Linux系统将这些附加文件放置于<code>/sbin</code>中：</p><p><strong>第二扩展文件系统命令（可选）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">badblocks</div><div class="line">dumpe2fs</div><div class="line">e2fsck</div><div class="line">mke2fs</div><div class="line">mklost+found</div><div class="line">tune2fs</div></pre></td></tr></table></figure><p><strong>boot-loader 映射安装程序（可选）：</strong><br><code>lilo</code></p><p><strong>静态二进制文件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ldconfig</div><div class="line">sln(static ln)</div><div class="line">ssync(static sync)</div></pre></td></tr></table></figure><blockquote><p>出现问题时，sln（静态ln）和ssync（静态同步）非常有用；<br>idconfig程序可以作为升级知道的手段；<br>sln的主要用途，修复不良协调升级后/lib中不正确的符号链接动态库。</p></blockquote><p>对于/sbin, idconfig二进制文件是可选的。因为站点可能会在启动时选择运行idconfig而不是仅在升级共享库时。<br>以下是一些常见问题：</p><ul><li>我刚刚删除了/lib/<file>；</file></li><li>我无法找到库的名称，因为<code>ls</code>是动态链接。我使用的shell没有内置<code>ls</code>，我也不知道使用<code>echo *</code>作为替换；</li><li>我有一个静态ln，但我不知道怎么称呼这个链接。</li></ul><p><strong>杂项：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#ctrl+alt+del</div><div class="line">ctrlaltdel</div><div class="line"></div><div class="line">#keyboard rate</div><div class="line">kbdrate</div></pre></td></tr></table></figure><p>为了应对某些键盘出现如此高的重复速率一致无法使用,<code>kbdrate</code>可以安装在某些系统上的<code>/sbin</code>中；</p><p>由于<code>ctrl+alt+del</code>组合键在内核中的默认操作是<strong>硬重启</strong>，因此通常建议在将根文件系统挂在到读写模式之前禁用该行为。这就可能需要<code>ctrlaltdel</code>程序，它可以安装在系统的<code>/sbin</code>中。</p><p><br></p><h2 id="usr-include-C程序包含的头文件"><a href="#usr-include-C程序包含的头文件" class="headerlink" title="/usr/include :C程序包含的头文件"></a>/usr/include :C程序包含的头文件</h2><p>如果安装了C或C++编译器，则只有非 基于glibc的系统才需要这些链接符号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/usr/include/asm  -&gt; /usr/src/linux/include/asm-&lt;arch&gt;</div><div class="line">/usr/include/linux  -&gt; /usr/src/linux/include/linux</div></pre></td></tr></table></figure><p><br></p><h2 id="usr-src-源代码"><a href="#usr-src-源代码" class="headerlink" title="/usr/src :源代码"></a>/usr/src :源代码</h2><p>对于基于glibc的系统，此目录没有具体指导。</p><p>对于glibc之前基于linux libc修订版的系统： <code>/usr/src/linux</code>是唯一放置Linux内核源代码的位置。</p><p><br></p><h2 id="usr-spool-cron-cron和jobs"><a href="#usr-spool-cron-cron和jobs" class="headerlink" title="/usr/spool/cron :cron和jobs"></a>/usr/spool/cron :cron和jobs</h2><p>此目录包含了cron和程序的可变数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;FHS介绍&quot;&gt;&lt;a href=&quot;#FHS介绍&quot; class=&quot;headerlink&quot; title=&quot;FHS介绍&quot;&gt;&lt;/a&gt;FHS介绍&lt;/h1&gt;&lt;p&gt;FHS(Filesystem Hierarchy Standard)，文件系统层次化标准：&lt;a href=&quot;http://www.pathname.com/fhs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.pathname.com/fhs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;FHS主要目的是希望让用户了解安装文件通常放置的目录。所以希望软件开发商、系统制定者以及维护系统的用户，都能够遵循FHS的标准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FHS-compliant system：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;可分享的(shareable)&lt;/th&gt;
&lt;th&gt;不可分享的(unshareable)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;不变的(static)&lt;/td&gt;
&lt;td&gt;/usr &lt;br&gt; /opt&lt;/td&gt;
&lt;td&gt;/etc &lt;br&gt; /boot&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可变的(variable)&lt;/td&gt;
&lt;td&gt;/var/mail &lt;br&gt; /var/spool/news&lt;/td&gt;
&lt;td&gt;/var/run &lt;br&gt; /var/lock&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="FHS" scheme="https://zhang21.github.io/tags/FHS/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix</title>
    <link href="https://zhang21.github.io/2017/11/14/Zabbix/"/>
    <id>https://zhang21.github.io/2017/11/14/Zabbix/</id>
    <published>2017-11-14T02:18:09.000Z</published>
    <updated>2018-02-07T11:31:35.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zabbix简介"><a href="#Zabbix简介" class="headerlink" title="Zabbix简介"></a>Zabbix简介</h1><p>参考：</p><p><a href="https://www.zabbix.com/" target="_blank" rel="noopener">Zabbix官方网站</a><br><a href="https://www.zabbix.com/documentation/3.4/zh/manual/" target="_blank" rel="noopener">Zabbix中文文档</a><br>Zabbix-repo仓库: <a href="http://repo.zabbix.com" target="_blank" rel="noopener">http://repo.zabbix.com</a> , 阿里云镜像: <a href="https://mirrors.aliyun.com/zabbix/zabbix/" target="_blank" rel="noopener">https://mirrors.aliyun.com/zabbix/zabbix/</a> .</p><p>环境：</p><p>CentOS7x86_64, Zabbix 3.4。</p><a id="more"></a><p>Zabbix （音同 zæbix），是由 Alexei Vladishev 开发的一种网络监视、管理系统，基于 Server-Client 架构。Zabbix 的授权是属于 GPLv2。<br>Zabbix可用于监视各种网络服务、服务器和网络机器等状态。是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。<br>Zabbix也可经由SNMP、TCP、ICMP、SSH等对目标进行监视。</p><p><br></p><h2 id="Zabbix的系统构成"><a href="#Zabbix的系统构成" class="headerlink" title="Zabbix的系统构成"></a>Zabbix的系统构成</h2><p>Zabbix系统由以下各独立模块组成：</p><ul><li>Zabbix Server，服务端(以C开发)。Server端通过收集SNMP和Agent发送的数据，写入数据库，再通过PHP+Apache在Web端展示；</li><li>Zabbix Agent，客户端(基本支持所有操作系统)，并将监控主机数据发送给Server；</li><li>Zabbix Frontend，Web管理端(以PHP和JavaScript构成)；</li><li>Zabbix Proxy(可选组件)。用于分布式监控。</li></ul><p><br></p><h2 id="Zabbix的特点"><a href="#Zabbix的特点" class="headerlink" title="Zabbix的特点"></a>Zabbix的特点</h2><p>Zabbix是一个高度集成的网络监控解决方案，一个简单的安装包中提供多样性功能。</p><ul><li>数据收集；</li><li>灵活的阀值(触发器)定义；</li><li>高度可配置化的告警；</li><li>实现图表绘制；</li><li>Web监控功能；</li><li>丰富的可视化选项；</li><li>历史数据存储；</li><li>配置简单；</li><li>使用模板；</li><li>网络发现；</li><li>Zabbix API；</li><li>权限管理系统；</li><li>功能强大并易于扩展的监控代理。</li></ul><p><br><br><br></p><hr><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Zabbix的常用术语含义。</p><p><strong>主机(host)：</strong></p><p>一台你想监控的网络设备，用IP或域名表示。主机名不能使用中文创建，会报错。</p><p><strong>主机组(host group):</strong><br>主机的逻辑组，它包含主机和模板。组名可以使用中文。</p><p><strong>监控项(item):</strong><br>你想要接收的主机的特定数据，一个度量数据。</p><p><strong>触发器(trigger):</strong><br>一个被用于定义问题阀值和评估监控项接收到的数据的逻辑表达式。</p><p><strong>事件(event):</strong><br>单次发生的需要注意的事情。</p><p><strong>异常(problem):</strong><br>一个处在异常状态的触发器。</p><p><strong>动作(action):</strong><br>一个对事件作出反应的预定义的操作。</p><p><strong>升级(escalation):</strong><br>一个在动作内执行操作的自定义场景。</p><p><strong>媒介(media):</strong><br>发送报警通知的手段。</p><p><strong>通知(notification):</strong><br>利用已选择的媒体途径把事情相关信息发送给用户。</p><p><strong>远程命令(remote command):</strong><br>预先定义好的，满足一定条件后，可在被监控主机上自动执行的命令。</p><p><strong>模板(template):</strong><br>一组可以被应用到一个或多个主机上的实体的集合。</p><p><strong>应用(application):</strong><br>一组监控项组成的逻辑分组。</p><p><strong>Web场景(Web scenario):</strong><br>利用一个或多个HTTP请求来检查网站的可用性。</p><p><strong>前端(frontend):</strong><br>Zabbix提供的Web界面。</p><p><strong>Zabbix API:</strong><br>Zabbix API允许你使用JSON RPC协议来创建、更新和获取Zabbix对象信息或执行任何其他的自定义的任务。</p><p><strong>Zabbix server:</strong><br>Zabbix软件监控的核心程序，主要功能是与Zabbix proxies和agent进行交互、触发器计算、发送告警通知，并将数据集中保存等。</p><p><strong>Zabbix agent:</strong><br>部署在监控对象上，能够主动监控本地资源和应用。</p><p><strong>Zabbix proxy:</strong><br>帮助Zabbix server收集数据，分担Zabbix server的负载。</p><p><br><br><br></p><hr><h1 id="Zabbix进程"><a href="#Zabbix进程" class="headerlink" title="Zabbix进程"></a>Zabbix进程</h1><h2 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h2><p>zabbix agent部署在监控的目标上，主动监测本地的资源和应用（硬件驱动，内存，处理器统计等）。<br>zabbix agent手机本地的操作信息并将数据报告给zabbix server用于进一步处理。</p><p>zabbix agent有被动(passive)和主动(active)两种检查方式。</p><p><br></p><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>zabbix server是zabbix软件的核心程序。它通过轮询和捕获数据，计算是否满足触发器条件，向用户发送通知。<br>它是zabbix监控代理和Proxy代理报告系统可用性和完整性数据的核心组件。zabbix server自身可以通过简单远程检查网络服务(如Web服务器和邮件服务器)。</p><p>server是一个包含了被存储了所有配置，统计方面的和可操作数据的中央仓库，它是监控系统问题升级以致于激活警告管理器的zabbix中的实体。</p><p>基本的zabbix server分三个不同的组件：<strong>zabbix server，web前端，数据库存储</strong>。<br>zabbix的所有配置信息都存储在服务器和web前端进行交互的数据库中。</p><p>zabbix server进程是以守护进程（Daemon）运行的。</p><p><br></p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>zabbix proxy是一个可以从一个或多个受监控的设备设备收集监控数据，并将信息发送到zabbix server的进程，基本上是代表server工作。<br>所有收集的数据都在本地进行缓存，然后传送到proxy所属的zabbix server。</p><p>zabbix proxy是完成远程区域、分支机构、没有本地管理员的网络的集中监控的理想解决方案。</p><p>zabbix proxy需要使用独立的数据库，以守护进程的方式运行。</p><p><br></p><h2 id="Java-gateway"><a href="#Java-gateway" class="headerlink" title="Java gateway"></a>Java gateway</h2><p>zabbix守护进程原生支持监控JMX程序，它被称为zabbix java gateway。zabbix gateway是用Java语言写成。</p><p>要查得一台主机特定的JMX计数器值，zabbix server向zabbix java gateway发送请求，后者使用JMX管理API去请求远程的有关应用。应用不许额外安装软件，只需要启动时在命令行指定 <code>-Dcom.sun.management.jmxremote</code>即可（是在java程序）。</p><p>每个zabbix server或zabbix agent只能配置一个java gateway。</p><p><br></p><h2 id="Sender"><a href="#Sender" class="headerlink" title="Sender"></a>Sender</h2><p>zabbix sender是一种命令行应用，它可以将性能数据发送到zabbix server进行处理。该应用通常用在长时间运行的用户脚本，用于定期发送可用性和性能数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">zabbix_sender -z zabbix -s &quot;xxx&quot; -k db.connections -0 43</div><div class="line"></div><div class="line">-z :server主机</div><div class="line">-s :受监控主机的技术名称</div><div class="line">-k :监控项的键</div><div class="line">-o :要发送的值</div></pre></td></tr></table></figure><p><br></p><h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p>zabbix get也是一种命令行应用，用于与zabbix agent进行通信，并从agent那里获取所需的信息。<br>该应用通常被用于zabbix agent故障排除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">zabbix_get -s $host -p xxx -k system.cpu.load[all,avg15]</div><div class="line"></div><div class="line">-s  --host</div><div class="line">-p --port</div><div class="line">-I --source-address</div><div class="line">-k --key</div><div class="line">-h --help</div><div class="line">-V --version</div></pre></td></tr></table></figure><p><br><br><br></p><hr><h1 id="安装Zabbix"><a href="#安装Zabbix" class="headerlink" title="安装Zabbix"></a>安装Zabbix</h1><h2 id="Zabbix安装要求"><a href="#Zabbix安装要求" class="headerlink" title="Zabbix安装要求"></a>Zabbix安装要求</h2><p><strong>硬件：</strong></p><ul><li>内存，最小128MB；</li><li>磁盘，最小256MB；</li><li>CPU，可能需要大量CPU资源；</li><li>SMS(短信)通知服务，串行通讯口(serial communication port)和串口GSM调制解调器(serial GSM modem)。可选项。</li></ul><p><strong>支持平台：</strong></p><ul><li>Linux;</li><li>IBM AIX;</li><li>FreeBSD;</li><li>NetBSD;</li><li>OpenBSD;</li><li>Mac OS X;</li><li>Solaris;</li><li>Windows(Only Agent).</li></ul><p><strong>软件：</strong><br>Zabbix基于Apache Web服务器、领先的数据库引擎和PHP脚本语言进行构建。</p><p><strong>数据库管理系统：</strong></p><ul><li>MySQL 5.0.3 及以上；</li><li>Oracle 10g 及以上；</li><li>PostgreSQL 8.1 及以上；</li><li>SQLite 3.5及以上；</li><li>IBM DB2 9.7 及以上。</li></ul><p><strong>前端：</strong></p><ul><li>Apache 1.3.12 及以上；</li><li>PHP 5.4.0及以上；</li></ul><p><strong>PHP-Extension:</strong></p><table><thead><tr><th>软件</th><th>版本</th><th>备注</th></tr></thead><tbody><tr><td>gd</td><td>2.0及以上</td><td>PHP GD扩展包必须支持PNG图片</td></tr><tr><td>bcmatch</td><td></td><td>php-bcmatch</td></tr><tr><td>ctype</td><td></td><td>php-ctype</td></tr><tr><td>libXML</td><td>2.6.15及以上</td><td>php-xml</td></tr><tr><td>xmlreader</td><td></td><td>php-xmlreader</td></tr><tr><td>xmlwrite</td><td></td><td>php-xmlwriter</td></tr><tr><td>session</td><td></td><td>php-session</td></tr><tr><td>sockets</td><td></td><td>php-net-socket</td></tr><tr><td>mbstring</td><td></td><td>php-mbstring</td></tr><tr><td>gettext</td><td></td><td>php-gettext</td></tr><tr><td>ldap</td><td></td><td>php-ldap</td></tr><tr><td>mysqli</td><td></td><td>使用MySQL作为Zabbix后端数据库所需的组件</td></tr><tr><td>pgsql</td><td></td><td>使用PostgreSQL作为Zabbix后端数据库所需的组件</td></tr><tr><td>sqlite3</td><td></td><td>使用SQLite作为Zabbix后端数据库所需的组件</td></tr></tbody></table><p><strong>客户端浏览器：</strong><br>必须启用Cookie和JavaScript功能。</p><p><strong>服务器：</strong></p><table><thead><tr><th>要求</th><th>描述</th></tr></thead><tbody><tr><td>OpenlPMI</td><td>支持IPMI功能所需组件</td><td></td></tr><tr><td>libssh2</td><td>支持SSH功能</td><td></td></tr><tr><td>fping</td><td>支持ICMP ping功能</td><td></td></tr><tr><td>libcurl</td><td>支持Web监控，VMware监控及SMTP认证</td><td></td></tr><tr><td>libiksemel</td><td>支持Jabber功能</td><td></td></tr><tr><td>libxml2</td><td>支持VMware监控</td><td></td></tr><tr><td>net-snmp</td><td>支持SNMP监控</td><td></td></tr></tbody></table><p><strong>Java网关：</strong><br>Java gateway编译和运行在Java 1.6 及以上版本。</p><p><strong>数据库容量：</strong><br>Zabbix配置数据需要使用固定的磁盘空间，而这个空间不会过多增长。</p><p>Zabbix数据库容量主要依赖于以下参数：</p><ul><li>每秒处理值的数量(Number of processed values per second);</li><li>历史(History)数据的回收清理设置(Housekeeper);</li><li>趋势(Trends)数据的回收清理设置(Housekeeper);</li><li>事件(Events)数据的回收清理设置(Housekeeper)。</li></ul><p><strong>时钟同步：</strong><br>对于Zabbix稳定运行而言，服务获取精确的系统时间是非常重要的。对于所有运行Zabbix组件的系统，强烈建议这些系统的时间保持同步。<br><code>ntpd</code>是一个临幸的用于同步主机和其他服务器之间的时间的后台程序。</p><p><br></p><h2 id="安装、启动、配置Zabbix"><a href="#安装、启动、配置Zabbix" class="headerlink" title="安装、启动、配置Zabbix"></a>安装、启动、配置Zabbix</h2><p>Zabbix-repo仓库：<a href="repo.zabbix.com">repo.zabbix.com</a><br>该仓库服务器同时提供<code>yum</code>和<code>apt</code>源码库。</p><h3 id="配置源码库"><a href="#配置源码库" class="headerlink" title="配置源码库"></a>配置源码库</h3><p><strong>1. 从官方下载源码库</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#rpm -ivh http://repo.zabbix.com/zabbix/$version/rhel/7/$arch/$zabbix-release.rpm</span></div><div class="line">rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.centos.noarch.rpm</div><div class="line"></div><div class="line"><span class="comment">#阿里云镜像</span></div><div class="line"><span class="comment">#rpm -ivh http://mirrors.aliyun.com/zabbix/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.noarch.rpm</span></div><div class="line"></div><div class="line"><span class="comment">#镜像失效的话自己去官网找</span></div></pre></td></tr></table></figure><p><strong>2. 手动配置zabbix.repo</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vim /etc/yum.repos.d/zabbix.repo</div><div class="line"></div><div class="line">[zabbix]</div><div class="line">name=Zabbix-Repo</div><div class="line">baseurl=http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/</div><div class="line">gpgcheck=0</div><div class="line"><span class="built_in">enable</span>=1</div></pre></td></tr></table></figure><p><br></p><h3 id="安装Zabbix部署包"><a href="#安装Zabbix部署包" class="headerlink" title="安装Zabbix部署包"></a>安装Zabbix部署包</h3><p>使用MySQL数据库安装Zabbix Server、Web前端：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y zabbix-server-mysql zabbix-get</div></pre></td></tr></table></figure></p><p><strong>注意：此处Zabbix数据库使用MySQL，请自行安装MySQL。</strong></p><p>安装Zabbix Agent：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y zabbix-agent</div></pre></td></tr></table></figure></p><p><br></p><h3 id="安装初始化数据库"><a href="#安装初始化数据库" class="headerlink" title="安装初始化数据库"></a>安装初始化数据库</h3><p>查看刚刚安装的 <strong>zabbix-server-mysql</strong>：<br>解压得到的sql脚本<code>create.sql</code>只会在对应的数据库中初始化zabbix所需要的数据库表，但是不会创建zabbix数据库。所以后面我们还需要手动创建<code>zabbix</code>数据库。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">rpm -ql zabbix-server-mysql</div><div class="line"></div><div class="line"><span class="built_in">cd</span> /usr/share/doc/zabbix-server-mysql-3.x.xx/</div><div class="line"></div><div class="line"><span class="comment">#有一个create.sql.gz的压缩文件</span></div><div class="line">gunzip create.sql.gz</div><div class="line"><span class="comment">#得到create.sql</span></div></pre></td></tr></table></figure></p><p><strong>在MySQL中创建zabbix数据库：</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">msyql -uxxx -p</div><div class="line"></div><div class="line">mysql&gt;CREATE DATABASE <span class="string">'zabbix'</span> DEFAULT CHARACTER SET <span class="string">'utf8'</span>;</div><div class="line">mysql&gt;SHOW DATABASES;</div><div class="line">mysql&gt;GRANT ALL ON zabbix.* TO <span class="string">'zabbix'</span>@<span class="string">'localhost'</span> identified by <span class="string">'zabbix'</span>;</div><div class="line">mysql&gt;FLUSH PRIVILEGES;</div><div class="line"></div><div class="line"><span class="comment">#导入sql脚本</span></div><div class="line">mysql -uroot -p -Dzabbix &lt; ./create.sql</div><div class="line"></div><div class="line">USE zabbix;</div><div class="line">SHOW TABLES;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#mysql限制IP</span></div><div class="line">vim /etc/my.cnf</div><div class="line"></div><div class="line">[mysqld]</div><div class="line"><span class="built_in">bind</span>-address=127.0.0.1</div></pre></td></tr></table></figure></p><p><br><br><img src="/images/zabbix_database.png" alt="zabbix-database alt=&quot;zabbix-database&quot;"></p><p><br></p><h3 id="配置zabbix-server并启动"><a href="#配置zabbix-server并启动" class="headerlink" title="配置zabbix server并启动"></a>配置zabbix server并启动</h3><p>编辑zabbix server配置文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">vim /etc/zabbix/zabbix_server.conf</div><div class="line"></div><div class="line"><span class="comment">#常会修改的参数</span></div><div class="line"></div><div class="line"><span class="comment">#数据库配置</span></div><div class="line">DBHost=localhost</div><div class="line">DBName=zabbix</div><div class="line">DBUser=zabbix</div><div class="line">DBPassword=zabbix</div><div class="line">DBPort=3306</div><div class="line">DBSocket=/var/lib/mysql/mysql.sock</div><div class="line"></div><div class="line"><span class="comment">#服务监听端口</span></div><div class="line">ListenPort=10051</div><div class="line"></div><div class="line"><span class="comment">#服务端源IP</span></div><div class="line">SourceIP=</div><div class="line"></div><div class="line"><span class="comment">#日志记录方式，file使用指定文件作为日志文件，system将日志发往syslog，console将日志发送控制台</span></div><div class="line">LogType=file</div><div class="line">LogFile=/var/<span class="built_in">log</span>/zabbix/zabbix_server.log</div></pre></td></tr></table></figure></p><p>启动zabbix服务端：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">systemctl start zabbix-server</div><div class="line"></div><div class="line"><span class="comment">#此处可能由于没有关闭SELinux而报错</span></div><div class="line">tail /var/<span class="built_in">log</span>/zabbix/zabbix_server.log</div><div class="line">cannot <span class="built_in">set</span> resource <span class="built_in">limit</span>: [13] Permission denied</div><div class="line"></div><div class="line"><span class="comment">#关闭SELinux</span></div><div class="line">setenforce=0</div><div class="line"></div><div class="line">vim /etc/selinux/config</div><div class="line">SELINUX=disabled</div><div class="line"></div><div class="line"><span class="comment">#查看zabbix-server默认监听的10051端口</span></div><div class="line">netstat -nltp</div></pre></td></tr></table></figure></p><p><br></p><h3 id="安装zabbix-web"><a href="#安装zabbix-web" class="headerlink" title="安装zabbix web"></a>安装zabbix web</h3><p>zabbix web可以安装在单独的主机上，只要能连接到zabbix database所在数据库就行。但为了方便，都安装在了server上。</p><p>zabbix web需要LAMP环境：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#可能需要自己配置PHP remi源，注意PHP及扩展版本问题</span></div><div class="line">yum install -y httpd php php-mysql php-mbstring php-gd php-bcmatch php-ldap php-xml</div><div class="line"></div><div class="line"><span class="comment">#指定php版本</span></div><div class="line"><span class="comment">#yum --enablerepo=remi-php56 install php-mysql php-mbstring php-gd php-bcmatch php-ldap php-xml</span></div></pre></td></tr></table></figure></p><p>安装zabbix web所需的两个包：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">yum install -y zabbix-web zabbix-web-mysql</div><div class="line"><span class="comment">#此处默认使用php5.4</span></div><div class="line"><span class="comment">#因为我的环境是php5.6,会报错</span></div><div class="line"><span class="comment">#此时就需要指定php版本来安装</span></div><div class="line">yum --enablerepo=remi-php56 install zabbix-web zabbix-web-mysql</div><div class="line"></div><div class="line"></div><div class="line">rpm -ql zabbix-web</div><div class="line"><span class="comment">#zabbix-web位于/usr/share/zabbix/</span></div></pre></td></tr></table></figure></p><h3 id="编辑zabbix的前端Apach-PHP配置文件"><a href="#编辑zabbix的前端Apach-PHP配置文件" class="headerlink" title="编辑zabbix的前端Apach-PHP配置文件"></a>编辑zabbix的前端Apach-PHP配置文件</h3><p>zabbix前端的Apache配置文件位于 /etc/httpd/conf.d/zabbix.conf:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">vim /etc/httpd/conf.d/zabbix.conf</div><div class="line"></div><div class="line"><span class="comment">#需修改时区</span></div><div class="line">php_value max_execution_time 300</div><div class="line">php_value memory_limit 128M</div><div class="line">php_value post_max_size 16M</div><div class="line">php_value upload_max_filesize 2M</div><div class="line">php_value max_input_time 300</div><div class="line">php_value always_populate_raw_post_data -1</div><div class="line">php_value date.timezone Asia/Shanghai</div><div class="line"></div><div class="line"><span class="comment">#建议顺便修改/etc/php.ini的时区</span></div><div class="line">vim /etc/php.ini</div><div class="line"></div><div class="line">date.timezone = Asia/Shanghai</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#添加httpd的虚拟主机访问zabbix web</span></div><div class="line">&lt;VirtualHost IP:80&gt;</div><div class="line">servername zabbix.me</div><div class="line">documentroot /usr/share/zabbix</div><div class="line"></div><div class="line">默认数据</div><div class="line"></div><div class="line">&lt;/VirtualHost&gt;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#开启httpd服务</span></div><div class="line">systemctl start httpd</div></pre></td></tr></table></figure></p><p><br><br><img src="/images/Zabbix/zabbix_conf.png" alt="/etc/httpd/conf.d/zabbix.conf"></p><p><br><br>添加hosts后就可以利用域名访问zabbix-web端了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> -e <span class="string">"192.168.1.9 \t zabbix.me"</span> &gt;&gt; /etc/hosts</div></pre></td></tr></table></figure><p><br></p><h3 id="在web端配置zabbix"><a href="#在web端配置zabbix" class="headerlink" title="在web端配置zabbix"></a>在web端配置zabbix</h3><p>在浏览器访问 <a href="http://zabbix.me" target="_blank" rel="noopener">http://zabbix.me</a> 初始化zabbix配置。<br>配置好后就需要用账号密码进行登录zabbix-web端dashboard。</p><p>默认用户名是：admin，密码是配置文件里面设置的。<br><img src="/images/Zabbix/zabbix_me.png" alt="登录zabbix Dashboard"></p><p><br></p><p>登录进Dashboard后，可修改语言为中文。</p><p><img src="/images/Zabbix/dashboard.jpg" alt="Dashboard"></p><p><br></p><p><strong>如果你的Zabbix无法看到中文选项，那么可能需要如下操作：</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim /usr/share/zabbix/include/locales.inc.php</div><div class="line"></div><div class="line"><span class="comment">#修改</span></div><div class="line"><span class="string">'zh_CN'</span> =&gt; [<span class="string">'name'</span> =&gt; _(<span class="string">'Chinese (zh_CN)'</span>),     <span class="string">'display'</span> =&gt; <span class="literal">true</span>],</div></pre></td></tr></table></figure></p><p><strong>如果又遇到中文乱码的问题，则可以从windows中挑选一些好看的中文字体，将对应字体文件放置到zabbix web的字体目录中。</strong><br>windows中字体后缀.TTF，Linux中为.ttf。注意修改大小写。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/share/zabbix/fonts</div><div class="line"><span class="comment">#只有一个默认字体 graphfont.ttf</span></div><div class="line"><span class="comment">#将新字体放置到此目录下</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#修改配置文件中对应字体名称</span></div><div class="line">vim /usr/share/zabbix/include/define.inc.php</div><div class="line"></div><div class="line"><span class="comment">#将默认字体名字修改为字体目录下 你需要的字体名</span></div><div class="line">define(<span class="string">'ZBX_FONT_NAME'</span>, <span class="string">'graphfont'</span>);</div><div class="line">define(<span class="string">'ZBX_GRAPH_FONT_NAME'</span>,           <span class="string">'graphfont'</span>); // font file name</div><div class="line"></div><div class="line"><span class="comment">#栗子，如perpetua字图PER.ttf</span></div><div class="line">define(<span class="string">'ZBX_FONT_NAME'</span>, <span class="string">'PER'</span>);</div><div class="line">define(<span class="string">'ZBX_GRAPH_FONT_NAME'</span>,           <span class="string">'PER'</span>); // font file name</div></pre></td></tr></table></figure></p><p><br></p><p><strong>图形显示乱码，同样是用以上方法。在windowss上找一个中文字体上传到zabbix字体目录，并修改配置文件就可以了。</strong></p><p><br></p><p>Zabbix Web界面菜单：</p><p><img src="/images/Zabbix/zabbix_menu.png" alt="zabbix菜单"></p><p><br></p><ul><li>管理菜单，用于管理zabbix自身及zabbix相关设置；</li><li>配置菜单，用于配置监控相关设置；</li><li>报表菜单，为管理员生成一段时间内的监控统计信息；</li><li>检测中菜单，用于查看被监控的相关数据；</li><li>资产记录菜单，查看被监控的主机有哪些，以及相关的资产信息。</li></ul><p><br></p><h2 id="安装zabbix-agent"><a href="#安装zabbix-agent" class="headerlink" title="安装zabbix agent"></a>安装zabbix agent</h2><p>Agent端安装也非常方便，直接在Client上安装两个包即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#配置zabbix源</span></div><div class="line">rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.centos.noarch.rpm</div><div class="line"></div><div class="line"><span class="comment">#aliyun镜像</span></div><div class="line"><span class="comment">#rpm -ivh http://mirrors.aliyun.com/zabbix/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.noarch.rpm</span></div><div class="line"></div><div class="line"><span class="comment">#安装</span></div><div class="line">yum install -y zabbix-agent zabbix-sender</div><div class="line"></div><div class="line">rpm -ql zabbix-agent</div><div class="line"><span class="comment">#/etc/zabbix/zabbix_agentd.conf</span></div></pre></td></tr></table></figure><p>zabbix的“主动模式”与“被动模式”都在<code>/etc/zabbix/zabbix_agentd.conf</code>中定义。<br>配置最常用的agent端：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">vim /etc/zabbix/zabbix_agentd.conf</div><div class="line"></div><div class="line"><span class="comment">####GENERAL PARAMETERS 通用配置</span></div><div class="line">PidFile=</div><div class="line">LogFile=</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">####Passive checks related 被动模式配置</span></div><div class="line"><span class="comment">#指定允许哪台服务器拉取本机数据</span></div><div class="line">Server=</div><div class="line"><span class="comment">#指定agent端工作于被动模式时监听的端口号</span></div><div class="line">ListenPort=10050(默认)</div><div class="line"><span class="comment">#指定agent端工作与被动模式时所监听的IP地址</span></div><div class="line">ListenIP=0.0.0.0(默认)</div><div class="line"><span class="comment">#指定预生成的agent进程数量</span></div><div class="line">StartAgents=</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">####Active checks related</span></div><div class="line"><span class="comment">#agent工作于主动模式时，将消息推送到哪台Server上</span></div><div class="line">ServerActive=IP1,IP2...</div><div class="line"><span class="comment">#指定当前主机主机名，Server端通过对应的主机名识别主机</span></div><div class="line">Hostname=</div><div class="line"><span class="comment">#指明agent端每隔多少秒将采集的数据发往Server端</span></div><div class="line">RefreshActiveChecks=</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">Server=192.168.1.9</div><div class="line">ServerActive=192.168.1.9</div><div class="line">Hostname=zabbix.me</div></pre></td></tr></table></figure></p><p><br><br><strong>启动zabbix-agent</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">systemctl zabbix-agent start</div><div class="line"></div><div class="line"><span class="comment">#查看状态,默认端口10050</span></div><div class="line">netstat -nltp</div></pre></td></tr></table></figure></p><p><img src="/images/Zabbix/zabbix-agent.png" alt="zabbix-agent状态"></p><p><br><br><br></p><hr><h1 id="快速开始zabbix-web菜单"><a href="#快速开始zabbix-web菜单" class="headerlink" title="快速开始zabbix-web菜单"></a>快速开始zabbix-web菜单</h1><p>zabbix-web界面中包含有<strong>监测中、资产记录、报表、配置、管理</strong>五项菜单。</p><p><br></p><h2 id="登录和配置用户"><a href="#登录和配置用户" class="headerlink" title="登录和配置用户"></a>登录和配置用户</h2><p>在浏览器输入 <a href="zabbix.me">zabbix.me</a> (修改hosts)，登录zabbix-web后台。</p><p>默认用户名：<strong>Admin</strong>，密码：<strong>zabbix</strong>。它是超级管理员。</p><p>为了防止暴力破解和词典攻击，连续尝试五次登录失败，zabbix界面将暂停30秒。</p><p><br></p><p>可以通过<strong>管理(Management)</strong>菜单下的<strong>用户(User)</strong>，新建、查看、管理用户信息。</p><p>zabbix在安装后自定义了两个用户：</p><ul><li>Admin用户是zabbix的超级管理员，拥有所有权限；</li><li>Guest用户是一个特殊的默认用户。如果你没有登录，你访问zabbix的时候其实就是“guest”权限。guest默认没有任何权限。</li></ul><p>你可以创建一个用户(user)并将其加入特定的用户组(Group)以提升用户权限。<br><img src="/images/Zabbix/user.png" alt="新建用户"></p><p>可以仅用用户信息里面-报警媒介里面，自定义严重性的报警。只有勾选部分的报警信息才会发送过来。这也很棒！</p><p>如果存在严重性则使用：</p><ul><li style="list-style: none"><input type="checkbox"> Not classified</li><li style="list-style: none"><input type="checkbox"> Information</li><li style="list-style: none"><input type="checkbox"> Warning</li><li style="list-style: none"><input type="checkbox"> Average</li><li style="list-style: none"><input type="checkbox"> High</li><li style="list-style: none"><input type="checkbox"> Disaster</li></ul><p><img src="/images/Zabbix/Useifseverity.png" alt="Use if severity"></p><p><br><br><br></p><h2 id="新建主机"><a href="#新建主机" class="headerlink" title="新建主机"></a>新建主机</h2><p>zabbix中的主机(host)是一个你想要监控的网络实体(物理的、虚拟的)。对于主机的定义非常灵活。它可以是一台物理服务器，一个网络交换机，一个虚拟机或一些应用。</p><p><br><br>可以通过<strong>配置(Configuration)</strong>菜单下的<strong>主机(Host)</strong>，查看已配置主机相关信息。<br>默认有一个“Zabbix Server”的定义好的主机。</p><p>点击<strong>创建主机(Create host)</strong>后，填写对应的主机名称、添加对应的主机群组，zabbix-agent的IP地址和端口，以及其它信息。</p><p><img src="/images/Zabbix/host.png" alt="创建主机"></p><p><br><br><br></p><h2 id="新建监控项"><a href="#新建监控项" class="headerlink" title="新建监控项"></a>新建监控项</h2><p>监控项是zabbix中获得数据的基础。没有监控项，就没有数据。因为一个主机中只有监控项定义了”单一的指标“或者”需要获得的数据“。</p><p><br><br>可以通过<strong>配置(Configuration)</strong>菜单下的<strong>主机(Item)</strong>，找到需要配置<strong>监控项(Item)</strong>的主机，然后创建监控项。<br>主机默认是没有定义任何监控项的。</p><p>填写对应的监控名称、类型、键值、主机接口、信息类型等等信息。<br><img src="/images/Zabbix/create-item.png" alt="添加监控项"></p><p><br><br>可在<strong>监控(Monitoring)</strong>菜单中<strong>最新数据(Latest data)</strong>查看之前定义的监控项和获得的值。<br>还可选择以<strong>图形(Graph)</strong>或<strong>值</strong>来查看监控项的相关信息。<br><img src="/images/Zabbix/upload.png" alt="upload监控信息"></p><p>同样也还以在Zabbix-Server端获得数据信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#zabbix_get -s $ip -k $value</span></div><div class="line">zabbix_get -s 192.168.1.9 -k system.cpu.load</div></pre></td></tr></table></figure></p><p><br><br><br></p><h2 id="新建触发器"><a href="#新建触发器" class="headerlink" title="新建触发器"></a>新建触发器</h2><p>监控项只用于收集数据。如果要自动评估收到的数据，我们则需要定义触发器(trigger)。<br>触发器包含了一个表达式，这个表达式定义了数据的可接受的阈值级别。</p><p>如果收到的数据超过了定义好的级别，触发器将被<strong>触发</strong>，或者进入<strong>异常状态</strong>(problem)。<br>从而引起我们的注意，让我们知道有问题发生。如果数据再次恢复到合理范围，触发器将会转到<strong>正常状态</strong>(OK)。</p><p><br></p><p>可以通过<strong>配置(Configuration)</strong>菜单下的<strong>主机(Hosts)</strong>选项，找到某主机的<strong>触发器(Triggers)</strong>创建触发器。</p><p>填写对应的触发器名称、表达式、描述等信息。<br><img src="/images/Zabbix/create-trigger.png" alt="创建触发器"></p><p><br><br><br></p><h2 id="获取问题通知"><a href="#获取问题通知" class="headerlink" title="获取问题通知"></a>获取问题通知</h2><p>当监控项收集了数据后，触发器会根据异常状态触发报警。根据一些报警机制，它也会通知我们一些重要的事情，而不是直接在zabbix-web端进行查看。<br>这就是<strong>通知(Notification)</strong>的功能。<br><strong>E-mail</strong>是最常用的异常通知发送方式。当然还有<strong>SMS（短信），脚本</strong>等媒体类型。</p><p><br></p><p>可以通过<strong>管理(Administration)</strong>菜单中的<strong>报警媒体类型(Media types)</strong>，点击预定义媒体类型列表中的Email，来配置Email。<br><img src="/images/Zabbix/create-email.png" alt="创建Email通知"></p><p>为了建立一个通知，我们需要在<strong>配置</strong>菜单下<strong>动作</strong>中，创建<strong>动作(Create action)</strong>。<br><img src="/images/Zabbix/create-action.png" alt="创建动作"></p><p>一旦满足了触发器的条件，变回触发执行动作。如收到E-mail等…</p><p><br><br><br></p><h2 id="新建模板"><a href="#新建模板" class="headerlink" title="新建模板"></a>新建模板</h2><p>如果我们配置上前台主机，一些自动化操作会带来更多便利性。没错，<strong>模板(templates)</strong>功能就可以实现。<br>模板允许对有用的监控项、触发器和其他对象进行分组，只需要一步就可以对监控主机应用模板，已达到反复重用的目的。</p><p>当一个模板链接到一个主机后，主机会继承这个模板中的所有对象。简单而言，一组预先定义好的检查会被快速应用到主机上。</p><p>Zabbix为各种操作系统、设备以及应用准备好了一些预定义的模板。你可以快速部署使用他们。<br><strong>但是请注意，一些模板需要根据你的实际情况和使用环境进行适当俄调整。</strong> 比如，一些检查项是不需要的，一些轮询周期过于频繁等。</p><p><br><br>在<strong>配置</strong>菜单下的<strong>模板(Templates)</strong>下，点击<strong>创建模板(Create template)</strong>。填写对应的模板名称，群组等信息。<br><img src="/images/Zabbix/create-template.png" alt="创建模板"></p><p>创建模板完毕后，可将模板链接到主机。之后，模板及其所有对象被添加到了主机。</p><p><br><br><br></p><hr><h1 id="配置-Configuration"><a href="#配置-Configuration" class="headerlink" title="配置(Configuration)"></a>配置(Configuration)</h1><p><br></p><h2 id="主机和主机组-Hosts-and-groups"><a href="#主机和主机组-Hosts-and-groups" class="headerlink" title="主机和主机组(Hosts and groups)"></a>主机和主机组(Hosts and groups)</h2><p>一般来讲，zabbix主机是指你希望监控的那些设备。如服务器、工作站、交换机等。<br>创建主机是使用zabbix过程的首要任务。</p><p>我们可以把主机组想象成项目组。根据不同的功能将主机划分到主机组是非常重要的，这样可以对以后创建的用户和用户组在定义权限的时候，不用给他们zabbix admin权限，而只需要根据主机组(项目组)给予用户和用户组对应项目(主机组)的权限即可。<br>这样很大程度上方便了Zabbix监控多个项目，也利于管理。同样，报警的时候也只会收到权限内的相关报警信息。</p><p><br></p><h3 id="配置一台主机"><a href="#配置一台主机" class="headerlink" title="配置一台主机"></a>配置一台主机</h3><p>配置–主机–创建主机–填写相关参数信息。</p><p>可以在已经存在的主机上使用 <strong>Clone</strong>或<strong>Full Clone</strong>创建一个新主机。</p><blockquote><p>Clone将保留所有的主机参数和模板链接；<br>Full Clone将额外保留指数实体(应用集、监控项、触发器、视图、规则、Web场景)。</p></blockquote><p><strong>新建主机下：</strong></p><ol><li>主机(Host)：包含了通用的主机属性；</li><li>模板(Template)：允许将模板链接诶到主机，所有实体将从模板继承；</li><li>IPMI：包含IPMI管理属性；</li><li>宏(Macros)：允许定义主机级别的<strong>用户宏</strong>；</li><li>主机资产记录(Host inventory)：允许为主机收工输入库存信息；</li><li>允许你请求与主机的加密的连接。</li></ol><p><br></p><h3 id="资产管理-Inventory"><a href="#资产管理-Inventory" class="headerlink" title="资产管理(Inventory)"></a>资产管理(Inventory)</h3><p>你可以将联网设备的资产信息保存在zabbix里。<br>资产信息实在配置主机时人工录入建立的资产信息数据，或者通过使用某些自动填充选项完成的录入。</p><p><strong>构建资产库：</strong></p><ul><li>手动模式： 在配置一台主机的时候，手动输入资产信息；</li><li>自动模式： 在配置主机的时候，选择自动。</li></ul><p>之后便可以在<strong>资产记录</strong>菜单中的<strong>概述，主机</strong>项中查看相关信息。</p><p><br></p><h3 id="批量更新-Mass-update"><a href="#批量更新-Mass-update" class="headerlink" title="批量更新(Mass update)"></a>批量更新(Mass update)</h3><p>有时候可能需要一次更改多个主机的某些属性，使用<strong>批量更新(mass update)</strong>功能来代替打开每个主机进行编辑。</p><p><img src="/images/Zabbix/mass-update.png" alt="批量更新"></p><p>可批量处理<strong>主机、模板、IPMI、资产、加密</strong>相关信息。</p><p><br><br><br></p><h2 id="监控项-Items"><a href="#监控项-Items" class="headerlink" title="监控项(Items)"></a>监控项(Items)</h2><p><strong>监控项</strong>是从主机收集的数据信息。<br>配置主机后，需要添加一些监控项以开始获取数据。快速添加多个监控项的一种方法是将预定义的模板附加到主机。</p><p>在单个监控项中，可指定从主机收集哪些数据信息。<br>为此，可使用<strong>监控项key</strong>。 如<strong>system.cpu.load</strong>将收集处理器负载的数据。<br>要给 key 指定更过参数，请在后面添加<strong>方括号[]</strong>。 如<strong>system.cpu.load[avg5]</strong>， 返回最近5分钟的CPU负载平均值。</p><p><br></p><h3 id="创建一个监控项"><a href="#创建一个监控项" class="headerlink" title="创建一个监控项"></a>创建一个监控项</h3><p>可在主机中新建一个监控项。<br>不支持的监控项：如果由于某种原因无法检索该值，则该监控项可能不被支持。这些监控项仍然以固定的间隔重新检查。</p><p><strong>监控项的key:</strong></p><ol><li>key名称允许使用字符： 0-9a-zA-Z_-.</li><li>key参数，用 逗,号 分隔： xxx[par1,par2…]</li><li>key参数也可以为空，此时使用默认值： key</li><li>key参数带引号，则允许任何Unicode字符，如果包含双引号则需要 \反斜杠 转义</li><li>key参数是一个数组，它需要包含在方括号中</li></ol><p><br></p><p><strong>自定义间隔(Custom intervals)</strong></p><p>创建关于监控项的自定义时间规则。<br>灵活间隔被设计为重新定义默认监控项的的更新间隔，但调度间隔用于指定独立执行的检查计划。</p><p><strong>灵活的间隔(Flexible intervals)：</strong>允许重定义特定时间段的默认间隔。</p><ul><li>间隔(Interval)： 指定时间段的更新间隔；</li><li>期间(Period)： 灵活间隔有效的时间段；</li><li>举个栗子： 60(interval), 1-7,00-24(period)。监控项每隔60s检查一次。</li></ul><p><br></p><p><strong>调度间隔(Scheduling intervals)：</strong>用于在特定时间检查监控项。</p><p>调度间隔定义为， <code>md&lt;filter&gt;wd&lt;filter&gt;h&lt;filter&gt;m&lt;filter&gt;s&lt;filter&gt;</code>。</p><ul><li>md: month days(1-31)</li><li>wd: week days(1-7)</li><li>h:  hours(0-23)</li><li>m:  minutes(0-59)</li><li>s:  seconds(0-58)</li><li><filter>: 指定其前缀的值—-[from-to/step]。</filter></li></ul><p>其实类似于Linux中定时任务的写法，只不过这里把单位(md,wd,h,m,s)写在了数值的前面。</p><p>举个栗子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">md1-15<span class="comment">#1-15号</span></div><div class="line"></div><div class="line">wd3<span class="comment">#星期三</span></div><div class="line"></div><div class="line">h0-12<span class="comment">#上半天</span></div><div class="line"></div><div class="line">m1,3,5,7,9<span class="comment">#每个1,3,5,7,9分钟</span></div><div class="line"></div><div class="line">s/10<span class="comment">#每个10s</span></div><div class="line"></div><div class="line"><span class="comment">#组合体</span></div><div class="line">wd1-5h9-18m/10<span class="comment">#每个工作日的上班时间每个10分钟</span></div></pre></td></tr></table></figure><p><br></p><h3 id="监控项类型-Items-type"><a href="#监控项类型-Items-type" class="headerlink" title="监控项类型(Items type)"></a>监控项类型(Items type)</h3><p>监控项类型包含从系统获取数据的多种方式。每个监控项类型都有一组自己支持的监控项key和所需的参数。</p><p>zabbix提供的监控项类型：</p><ol><li>zabbix代理检查(agent checks)</li><li>SNMP代理检查</li><li>SNMP traps</li><li>IPMI检查</li><li>简单检查(simple checks)</li><li>VMware监控(monitoring)</li><li>日志文件监控</li><li>计算监控项(Calculated items)</li><li>zabbix内部检查(internal checks)</li><li>SSH检查</li><li>Telnet检查</li><li>外部检查(External checks)</li><li>汇总检查(Aggregate checks)</li><li>捕捉器监控项(Trapper items)</li><li>JMX监控</li><li>ODBC监控</li></ol><p><br></p><p><strong>zabbix代理(zabbix agent)：</strong><br>这些检查与zabbix代理进行通信实现数据的采集。</p><ol><li>zabbix agent-passive： 被动模式，Server向Agent索要数据；</li><li>zabbix agent-active： 主动模式，Agent主动上报数据给Server。</li></ol><p>可支持的监控项，可在新建监控项是在键值里面查看。</p><p><br></p><p><strong>SNMP代理(SNMP agent)：</strong></p><p>在启用SNMP的设备(如打印机，交换机，路由器…)上使用SNMP监控，为了能够监控SNMP代理在这些设备上提供的数据，zabbix服务器初始化配置时必须具有SNMP支持。<br>仅通过UDP协议执行SNMP检查。</p><p><strong>配置SNMP监控：</strong></p><ol><li>使用SNMP接口为设备创建一个主机；</li><li>找出要监控项目的SNMP字符串；</li><li>创建一个监控项。</li></ol><p><br></p><p><strong>IPMI检查：</strong></p><p>你可以在zabbix中监控 <strong>智能平台管理接口(IPMI)</strong> 设备的运行状况和可用性。<br>要执行IPMI检查，zabbix服务器必须首先配置IPMI支持。</p><p><br></p><p><strong>简单检查：</strong></p><p>简单检查通常用于远程无代理监控服务。</p><p><br></p><p><strong>日志文件监控：</strong></p><p>zabbix可用于集中监控和分析 具有/不具有 日志转动能力的日志文件。<br>当日志文件包含某些字符串或字符串模式时，通知信息可用于警告用户。</p><p><br></p><p><strong>计算监控项：</strong></p><p>计算监控项是创建虚拟数据源的一种方式。这些值将根据算术表达式定期计算。所有计算都由Server完成。</p><p><br><br><strong>内部检查：</strong><br>内部检查可以监控zabbix的内部检查。即Server或Agent Server的运行情况。</p><p><br><br><strong>SSH检查：</strong></p><p>运行SSH检查是作为无代理监控的，SSH检查不需要zabbix代理。<br>执行SSH检查zabbix服务器必须初始化配置为SSH2支持。</p><p>SSH检查提供两种身份验证方法，一种是用户/密码，另一种是基于密钥文件。</p><p>zabbix SSH 密钥配置:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">vim /etc/zabbix/zabbix_server.conf</div><div class="line"></div><div class="line"><span class="comment">#SSHKeyLocation=</span></div><div class="line">SSHKeyLocation=/home/zabbix/.ssh</div><div class="line"></div><div class="line">usermod -m -d /home/zabbix zabbix</div><div class="line">chown zabbix:zabbix /home/zabbix</div><div class="line">chmod 700 /home/zabbix</div><div class="line"><span class="built_in">cd</span> /home/zabbix &amp;&amp; su zabbix</div><div class="line"></div><div class="line">ssh-keygen -t rsa</div></pre></td></tr></table></figure><p><br></p><p><strong>外部检查：</strong></p><p>外部检查是由zabbix Server通过运行shell脚本或二进制的检查。<br>外部检查不需要再被监控的主机上运行任何代理。</p><p><br></p><p><strong>汇总检查：</strong></p><p>在汇总检查中，zabbix通过直接从数据库中查询监控信息，然后进行信息聚合。<br>聚合检查不需要再被监控的主机上运行任何代理。</p><p><br></p><p><strong>捕捉器监控项：</strong></p><p>捕捉器监控项接收传入的数据，而不是查询它。对于想要推送到zabbix的任何数据都是适用的。</p><p>要使用捕捉器监控项，需要在zabbix中建立一个捕捉器监控项，将数据送给zabbix。</p><p><br></p><p><strong>JMX监控项：</strong></p><p>JMX监控可用于监视Java应用程序的JMX计数器。<br>JMX监视器以zabbix守护进程方式运行，名为zabbix java gateway。</p><p><br></p><p><strong>ODBC监控：</strong></p><p>ODBC监控对应于zabbix web管理端中的数据库监控器监控项类型。<br>ODBC是用于访问 数据库管理系统(DBMS) 的C语言中间件API。</p><p>zabbix可以查询ODBC支持的任何数据库。为了实现监控，zabbix不直接连接到数据库，而是使用ODBC中设置的ODBC接口和驱动。<br>该功能允许为多个目的更加有效地监控不同的数据库。</p><p><br></p><h3 id="历史与趋势-history-and-trends"><a href="#历史与趋势-history-and-trends" class="headerlink" title="历史与趋势(history and trends)"></a>历史与趋势(history and trends)</h3><p>历史与趋势是zabbix中存储数据的两种方式。<br>历史保持每个收集的值，而趋势是每小时的平均信息。</p><p>建议保持的历史数据尽可能少，但可以保留更多的趋势数据。</p><p><br></p><h3 id="用户自定义参数-user-parameter"><a href="#用户自定义参数-user-parameter" class="headerlink" title="用户自定义参数(user parameter)"></a>用户自定义参数(user parameter)</h3><p>有时你想运行一个代理检查，但它不是zabbix预定义的。这时就能用到<strong>用户参数</strong>。<br>用户参数是由zabbix代理之星的命令，最多可以返回512KB的数据。<br><strong>key</strong> 是唯一的。</p><p>用户参数用法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">UserParameter=&lt;key&gt;,&lt;<span class="built_in">command</span>&gt;</div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">UserParameter=ping,<span class="built_in">echo</span> 1</div><div class="line"><span class="comment">#使用ping键为一个监控项返回 1</span></div><div class="line"></div><div class="line"><span class="comment">#复杂栗子</span></div><div class="line">UserParameter=mysql.ping,mysqladmin -uroot -ppwd ping | grep -c <span class="string">'alive'</span></div><div class="line"><span class="comment">#mysqld状态为alive返回1，否则0</span></div><div class="line"></div><div class="line"><span class="comment">#灵活的用户参数</span></div><div class="line">UserParameter=key[*],<span class="built_in">command</span></div><div class="line"><span class="comment">#[*]定义该key接受括号内的参数</span></div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">UserParameter=ping[*],<span class="built_in">echo</span> <span class="variable">$1</span></div><div class="line"></div><div class="line">UserParameter=mysql.ping[*],mysqladmin -u<span class="variable">$1</span> -p<span class="variable">$2</span> ping | grep -c <span class="string">'alive'</span></div><div class="line"><span class="comment">#mysql.ping[zabbix,passwd]</span></div><div class="line"></div><div class="line">UserParameter=wc[*],grep -c <span class="string">"<span class="variable">$2</span>"</span> <span class="variable">$1</span></div><div class="line"><span class="comment">#wc[/etc/passwd,root]</span></div></pre></td></tr></table></figure><p><br><br><strong>用户自定义参数扩展zabbix代理：</strong><br>是将key添加到被监控的主机哦！<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#编写命令--SQL查询总数</span></div><div class="line">mysqladmin -uxxx -pxxx status | cut -f4 -d<span class="string">":"</span> | cut -f1 -d<span class="string">"S"</span></div><div class="line"></div><div class="line"><span class="comment">#将命令添加到zabbix_agentd.conf</span></div><div class="line">vim /etc/zabbix/zabbix_agentd.conf</div><div class="line"></div><div class="line"><span class="comment">#找到如下字段</span></div><div class="line"><span class="comment">### Option: UserParameter</span></div><div class="line">UserParameter=mysql.totalquery,mysqladmin -uroot -pxxx status | cut -f4 -d<span class="string">":"</span> | cut -f1 -d<span class="string">"S"</span></div><div class="line"><span class="comment">#mysql.totalquery这个key是唯一的标识符</span></div><div class="line"></div><div class="line"><span class="comment">#测试此参数</span></div><div class="line"><span class="comment">##测试参数可用与否很重要哈</span></div><div class="line">zabbix_agentd -t mysql.totalquery</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#重启zabbix-agent，将重新加载配置</span></div><div class="line">zabbix_get -s <span class="variable">$host</span> -k mysql.totalquery</div></pre></td></tr></table></figure></p><p><br></p><h3 id="可加载模块-loadable-modules"><a href="#可加载模块-loadable-modules" class="headerlink" title="可加载模块(loadable modules)"></a>可加载模块(loadable modules)</h3><p>可加载模块提供了一种关于zabbix性能扩展的选项。</p><p>可加载模块基本上只zabbix守护程序使用的共享库，并在启动时加载。<br>可加载模块具有很多优点，卓越的性能和可实现任何逻辑的能力，更重要的是使用和共享了zabbix模块的开发能力。</p><p><br></p><h3 id="windows性能计数器-windows-perfomance-counter"><a href="#windows性能计数器-windows-perfomance-counter" class="headerlink" title="windows性能计数器(windows perfomance counter)"></a>windows性能计数器(windows perfomance counter)</h3><p>使用perf_counter[]key有效的监控windows性能计数器</p><p><br></p><h3 id="批量更新-mass-update"><a href="#批量更新-mass-update" class="headerlink" title="批量更新(mass update)"></a>批量更新(mass update)</h3><p>使用批量更新功能，可一次更改多个监控属性。</p><p><br></p><h3 id="值映射-value-mapping"><a href="#值映射-value-mapping" class="headerlink" title="值映射(value mapping)"></a>值映射(value mapping)</h3><p>对于接收值更人性化的表示，可以使用包含数值和字符串之间的映射的<strong>值映射</strong>。</p><p>如：</p><ul><li>0 —&gt; error</li><li>1 —&gt; true</li><li>F —&gt; Full</li><li>D —&gt; Differential</li><li>I —&gt; Incremental</li><li>…</li></ul><p><br></p><h3 id="应用集-Application"><a href="#应用集-Application" class="headerlink" title="应用集(Application)"></a>应用集(Application)</h3><p><strong>应用集</strong>对逻辑组中的监控项进行分组。</p><p>如，对MongoDB的可用性，空间，负载，慢查询，执行命令…，可归于 MongoDB应用于中。</p><p><br></p><h3 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h3><p><strong>队列</strong>显示正在等待刷新的监控项。<br>队列只是一个逻辑表达的数据。</p><p>队列显示的统计信息是zabbix服务器性能是否健康的指标。<br>在 管理–队列 下对去队列。</p><p><br></p><h3 id="值缓存-value-cache"><a href="#值缓存-value-cache" class="headerlink" title="值缓存(value cache)"></a>值缓存(value cache)</h3><p>为了计算触发表达式，以及让计算/聚合监控项和一些宏更快，zabbix服务器支持值的缓存选项。</p><p>在内存中的缓存可用于访问历史数据，而不用之间调用数据库。如果缓存中不存在历史值，则从数据库请求缺少的值，并相应地跟新缓存。</p><p>要启用值缓存功能，修改zabbix_server.conf中可选的ValueCacheSize参数。</p><p><br><br><br></p><h2 id="触发器-Trigger"><a href="#触发器-Trigger" class="headerlink" title="触发器(Trigger)"></a>触发器(Trigger)</h2><p>触发器是评估有项目采集的数据并表示当前系统状况的逻辑表达式。<br>触发器表达式允许定义一个什么状况的数据是“可接受”的阈值。如果超过了可接受状态，则触发器会被触发。</p><p><br></p><h3 id="配置一个触发器-configuring-a-trigger"><a href="#配置一个触发器-configuring-a-trigger" class="headerlink" title="配置一个触发器(configuring a trigger)"></a>配置一个触发器(configuring a trigger)</h3><p>在主机里面配置触发器。</p><p><br></p><h3 id="触发器表达式-trigger-expression"><a href="#触发器表达式-trigger-expression" class="headerlink" title="触发器表达式(trigger expression)"></a>触发器表达式(trigger expression)</h3><p>一个简单有效的表达式看起来像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;&lt;server&gt;:&lt;key&gt;.&lt;<span class="keyword">function</span>&gt;(&lt;parameter&gt;)&#125;&lt;operator&gt;&lt;constant&gt;</div><div class="line"></div><div class="line"><span class="comment">#如</span></div><div class="line">&#123;192.168.1.7:agent.ping.time()&#125;=0</div></pre></td></tr></table></figure><p><strong>函数参数(function parameters)：</strong></p><p>大多数数字型的函数接受秒数来作为参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#600s内所有值的总和</div><div class="line">sum(600)</div><div class="line"></div><div class="line">#随后5个值总和</div><div class="line">sum(#5)</div><div class="line"></div><div class="line">avg()</div><div class="line">count()</div><div class="line">last()</div><div class="line">min()</div><div class="line">max()</div><div class="line"></div><div class="line">#5m 可被 300s 代替</div><div class="line">#1k 代表 1024bytes</div></pre></td></tr></table></figure><p><strong>运算符(operators)：</strong></p><table><thead><tr><th>优先级</th><th>运算符</th><th>定义</th></tr></thead><tbody><tr><td>1</td><td>-</td><td>负号(minus)</td></tr><tr><td>2</td><td>not</td><td>逻辑非(NOT)</td></tr><tr><td>3</td><td>*, /</td><td>乘，除</td></tr><tr><td>4</td><td>+, -</td><td>加，减</td></tr><tr><td>5</td><td>&lt;, &lt;=, &gt;, &gt;=</td><td>-</td></tr><tr><td>6</td><td>=, &lt;&gt;</td><td>相等，不等于</td></tr><tr><td>7</td><td>and</td><td>逻辑与</td></tr><tr><td>8</td><td>or</td><td>逻辑或</td></tr></tbody></table><p><strong>触发器示例：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;www.zabbix.com:system.cpu.load[all,avg1].last()&#125;&gt;5</div><div class="line"></div><div class="line">&#123;www.zabbix.com:system.cpu.load[all,avg1].last()&#125;&gt;5 or &#123;www.zabbix.com:system.cpu.load[all,avg1].min(10m)&#125;&gt;2</div><div class="line"></div><div class="line">&#123;www.zabbix.com:net.if.in[eth0,bytes].min(5m)&#125;&gt;100k</div><div class="line"></div><div class="line">&#123;<span class="variable">$url1</span>:net.tcp.service[smtp].last()&#125;=0 and &#123;<span class="variable">$url2</span>:net.tcp.service[smtp].last()&#125;=0</div><div class="line"></div><div class="line">&#123;<span class="variable">$host</span>:icmpping.count(30m,0)&#125;&gt;5</div><div class="line"></div><div class="line">&#123;<span class="variable">$host</span>:system.cpu.load[all,avg1].min(5m)&#125;&gt;2 and &#123;<span class="variable">$hsot</span>:system.cpu.load[all,avg1].time()&#125;&gt;000000 and &#123;<span class="variable">$host</span>:system.cpu.load[all,avg1].time)()&#125;&lt;060000</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure><p><strong>滞后(Hysteresis):</strong></p><p>有时候需要一个触发器状态OK和PROBLEM之间的间隔，而不是简单的阈值。</p><p>要做到这一点，我们首先定义一个PROBLEM事件的触发器表达式，然后为OK选择 ‘Recovery expression’，并未OK事件书如不同的表达式</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#Problem expression</div><div class="line">&#123;server:temp.last()&#125;&gt;20</div><div class="line"></div><div class="line">#Recovery expression</div><div class="line">&#123;server:temp.last()&#125;&lt;=15</div><div class="line"></div><div class="line">#两者之间便有了几个滞后值</div></pre></td></tr></table></figure><p><br></p><h3 id="触发器依赖-trigger-dependency"><a href="#触发器依赖-trigger-dependency" class="headerlink" title="触发器依赖(trigger dependency)"></a>触发器依赖(trigger dependency)</h3><p>有时候，一台主机的可用性取决于另一台主机。如一台路由器后的上网设备。<br>这就是主机之间某些依赖关系可能有用的地方，依赖关系设置的通知可能会被抑制，而只发送根本问题的通知。</p><p>zabbix中触发器的依赖，一个触发器可能有多个依赖于它的触发器。</p><p>路由器和路由器后的Server同时宕机，如果有依赖关系，则zabbix不会执行服务器的触发动作。<br>值得注意的是，如果触发器所依赖的触发器被禁用，则次触发器的事件和动作将不会被抑制。</p><p><br></p><h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>使用批量更新，可一次更改一些触发器的某些属性。</p><p><br></p><h3 id="触发器严重性-trigger-severity"><a href="#触发器严重性-trigger-severity" class="headerlink" title="触发器严重性(trigger severity)"></a>触发器严重性(trigger severity)</h3><p>触发器严重性定义了触发器的重要程度:</p><ol><li>未分类(not classified), 灰色</li><li>信息(information), 淡蓝</li><li>警告(warning), 黄色</li><li>一般严重(average), 橙色</li><li>严重(High), 淡红</li><li>灾难(disaster), 红色</li></ol><p><br></p><h3 id="自定义触发器严重性-customising-trigger"><a href="#自定义触发器严重性-customising-trigger" class="headerlink" title="自定义触发器严重性(customising trigger)"></a>自定义触发器严重性(customising trigger)</h3><p>在 管理 – 一般 – 触发器严重性，里面自定义触发器严重性。</p><p><br></p><h3 id="预测触发功能-predictive-trigger-function"><a href="#预测触发功能-predictive-trigger-function" class="headerlink" title="预测触发功能(predictive trigger function)"></a>预测触发功能(predictive trigger function)</h3><p>有时候有即将到来的问题的迹象。可以发现这些迹象，以便提前采取行动，以减小影响。</p><p>zabbix具有基于历史数据预测受监视系统的未来行为的工具，这些工具通过预测触发功能实现。</p><p><br></p><h3 id="事件标签-event-tag"><a href="#事件标签-event-tag" class="headerlink" title="事件标签(event tag)"></a>事件标签(event tag)</h3><p>在zabbix中可以自定义事件标签，在触发器级别上定义事件标签。在事件标签定以后，相应的新事件被标记为时间标签数据。<br>在拥有自定义时间标签的情况下，可以变得更加灵活。</p><p>例如：</p><ol><li>识别日志文件中的问题并单独关闭他们；</li><li>用它来过滤通知；</li><li>查看前端的事件标签信息；</li><li>从项目值中提取的信息作为标签值；</li><li>在通知中更好地识别问题；</li><li>通过使用模板级别的标签来建华配置任务；</li><li>使用低级别发现的标签创建触发器。</li></ol><p><br><br><br></p><h2 id="事件-Events"><a href="#事件-Events" class="headerlink" title="事件(Events)"></a>事件(Events)</h2><p>zabbix可以生成一下几种类型的事件：</p><ol><li>trigger events-触发器事件；</li><li>discovery events-发现事件；</li><li>auto registration events-自动注册事件；</li><li>internal events-内部事件；</li></ol><p>事件以时间戳，并可以发送Email等基础动作。<br>在 监控-问题 里面查看信息信息。</p><p><br></p><h3 id="触发器事件生成-trigger-events-generation"><a href="#触发器事件生成-trigger-events-generation" class="headerlink" title="触发器事件生成(trigger events generation)"></a>触发器事件生成(trigger events generation)</h3><p>触发器状态的变化是事件最常见和最重要的来源。每次触发器的状态改变时，都会生成一个事件。<br>改时间包含了触发器状态变更的详细信息、发生时间以及信息的状态。</p><p>触发器会创建两种类型的事件：问题(problem)和正常(OK)</p><p><br></p><h3 id="手动关闭问题事件-manual-closing-of-problems"><a href="#手动关闭问题事件-manual-closing-of-problems" class="headerlink" title="手动关闭问题事件(manual closing of problems)"></a>手动关闭问题事件(manual closing of problems)</h3><p>当触发器状态从“问题(problem)”变成“正常(OK)”时，很难判断是通过触发器表达式的方式解决。这时就需要手动解决。</p><p>只有在触发器中启用 “允许手动关闭” 选项，问题事件才可以被手动关闭。</p><p><br></p><h3 id="其他事件来源-other-event-source"><a href="#其他事件来源-other-event-source" class="headerlink" title="其他事件来源(other event source)"></a>其他事件来源(other event source)</h3><p>zabbix定期扫描网络发现规则中定义的IP范围，可以为每个规则单独配置检查频率。一旦发现主机或服务，就会生成一个发现事件。</p><p>zabbix可以生成以下事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Service Up/Down</div><div class="line">Host Up/Down</div><div class="line">Service Discovered/Lost</div><div class="line">Host Discovered/Lost</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="事件关联-event-correlation"><a href="#事件关联-event-correlation" class="headerlink" title="事件关联(event correlation)"></a>事件关联(event correlation)</h2><p>通常，在zabbix中正常事件会关闭所有的问题事件，但在某些情况下需要更细致的方法。可以根据<strong>事件标签</strong>关联问题事件。<br>如，当监控日志文件时，在日志文件中想要发现某些问题，并将它们单独关闭，而不是一起关闭。</p><p><br><br><br></p><h2 id="可视化-visualisation"><a href="#可视化-visualisation" class="headerlink" title="可视化(visualisation)"></a>可视化(visualisation)</h2><h3 id="图形-graphs"><a href="#图形-graphs" class="headerlink" title="图形(graphs)"></a>图形(graphs)</h3><p>大量的监控数据被采集到zabbix中，如果能用可视化的表现形式来查看，那就直观和容易多了。</p><p>zabbix为用户提供了如下图形：</p><ol><li>监控项数据的内置简单图形 “simple graphs”；</li><li>创建更复杂的自定义图形 “customised graphs”；</li><li>特定图形 “ad-hosc graphs”快速访问几个监控项的数据比较。</li></ol><p><strong>简单图形(simple graphs)：</strong><br>zabbix提供的简单图形，用来可视化显示监控项采集到的数据。并不需要配置就可以查看。</p><p>通过 监控-最新数据-图形 来展示图形。</p><p><strong>自定义图形(customised graphs)：</strong><br>自定义图形，提供定制功能。这就有点厉害了。这个是手动配置的。<br>可以为单个主机、多个主机、单个模板、多个模板创建自定义图形。</p><p>在 配置-主机-图形-创建图形 里编辑图形属性；<br>图形编辑后可点击预览。</p><p><strong>特设图形(ad-hoc graphs)：</strong><br>简单图形和自定义图形都不允许快速创建多个监控项目数据的比较图形，工作量小且没有维护。</p><p>在 检测-最新数据-旋转监控项前复选框-显示数据图(显示堆叠数据图) 下， 里面也包含了 正常和层积 的图形风格。</p><p><br></p><h3 id="拓扑图-networking-maps"><a href="#拓扑图-networking-maps" class="headerlink" title="拓扑图(networking maps)"></a>拓扑图(networking maps)</h3><p>运维人员如果想要了解网络环境的基础设施状况，可以在zabbix中创建网络拓扑图。</p><p><strong>配置拓扑图(configurating network maps):</strong></p><p>在 监控-拓扑图 下，可以创建拓扑图。点击拓扑图中的 构造函数 选项，来打开编辑区域。<br>然后在编辑区域中添加元素和链接元素。</p><p><strong>链接指示器(link indicators):</strong><br>可以为网络拓扑图中的元素之间的链接分配一些触发器，当这些触发器状况为“Problem”时，可以在链接上体现出来。<br>如果多个触发器进入”Problem”状态，则严重程度最高的将决定链接的颜色和样式。</p><p><br></p><h3 id="聚合图形-screen"><a href="#聚合图形-screen" class="headerlink" title="聚合图形(screen)"></a>聚合图形(screen)</h3><p>在zabbix的聚合图形页面上，你可把各种来源的信息聚集到一起，一边在单个屏幕上快速查看。<br>在 监测-图形聚合 下，对其进行创建、配置、管理和查看。</p><p>基本上，聚合图形是一个表格，你选择把每个表格有多少单元格以及其中要显示的元素。<br>元素如下：</p><ul><li>简单图形；</li><li>简单图形原型；</li><li>用户自定义图形；</li><li>自定义图形原型；</li><li>拓扑图；</li><li>其他聚合图形；</li><li>纯文本信息；</li><li>服务器信息；</li><li>触发器信息；</li><li>主机/主机组信息；</li><li>系统状态；</li><li>数据概述；</li><li>时钟；</li><li>事件历史；</li><li>动作历史；</li><li>URL。</li></ul><p><br></p><h3 id="幻灯片演示-slide-shows"><a href="#幻灯片演示-slide-shows" class="headerlink" title="幻灯片演示(slide shows)"></a>幻灯片演示(slide shows)</h3><p>在幻灯片演示中，可以配置多个聚合图形以设定的间隔逐个显示。<br>在 监测-聚合图形-幻灯片演示 下。</p><p><br><br><br></p><h2 id="模板-template"><a href="#模板-template" class="headerlink" title="模板(template)"></a>模板(template)</h2><p>模板是可以方便地应用于多个主机的一组实体。</p><p><strong>配置模板(configuring a template)：</strong><br>配置模板需要首先通过定义一些参数来创建模板，然后添加实例。<br>在 配置-模板-创建模板</p><p><strong>链接模板(linking)：</strong><br>链接是将模板应用于主机的过程，之后主机将拥有模板的所有实体。</p><p><strong>嵌套(nesting)：</strong><br>嵌套是一种包含一个或多个其它模板的模板方式。<br>可以在一个嵌套模板中奖一些模板链接在一起。</p><p>嵌套的好处在于，您只需要讲一个模板链接到主机，并且主机会自动继承链接的模板的所有实体。</p><p><br><br><br></p><h2 id="事件通知-notifications-upon-events"><a href="#事件通知-notifications-upon-events" class="headerlink" title="事件通知(notifications upon events)"></a>事件通知(notifications upon events)</h2><p>当配置了一些项目和触发器，并且由于触发器改变状态，现在正在发生一些事件，之后就要考虑 action。<br>发送通知是zabbix提供的主要操作之一。</p><p>为了能够发送和接收通知，必须：</p><ol><li>定义一些media；</li><li>配置action，向指定的media发送消息。</li></ol><p>action由condition和operation组成。当条件满足是，执行操作。<br>操作主要是 <strong>发送消息</strong>和<strong>执行远程命令</strong>。</p><p><br></p><h3 id="media类型"><a href="#media类型" class="headerlink" title="media类型"></a>media类型</h3><p>媒体是zabbix中发送通知和警报的传送通道。</p><p><strong>E-mail:</strong></p><p>在 管理-媒体类型 下，配置Email。</p><p><strong>SMS：</strong></p><p>zabbix支持使用连接到zabbix-server的串行端口的串行GSM调制解调器发送SMS消息。</p><p>确保：</p><ul><li>串行设备的速度(在Linux下通常为/dev/ttyS0) 与 GSM调制解调器的速度相匹配。zabbix没有设置串行链路的速度，它使用默认设置。</li><li>zabbix用户对串行设备有读写访问权限。</li><li>GSM调制解调器输入PIN码，并在电源复位后保留PIN码。或者在SIM卡上禁用PIN。</li></ul><p>管理-媒体类型下<br>要为用户分配电话号码：管理-用户-报警媒介，添加报警媒介(如电话号码等)</p><p><strong>Jabber：</strong></p><p>zabbix支持发送jabber消息。</p><p><strong>Ez Texting：</strong></p><p>可以使用 zabbix技术合作伙伴 Ez Texting发送信息。</p><p><strong>脚本：</strong></p><p>警报脚本在zabbix服务器上执行，这些脚本位于服务器配置文件中定义的目录中(AlertScriptsPath)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cat /etc/zabbix/zabbix_server.conf</div><div class="line"></div><div class="line">AlertScriptsPath=/usr/lib/zabbix/alertscripts</div><div class="line"></div><div class="line"></div><div class="line">#创建报警脚本</div><div class="line">vim /usr/lib/zabbix/alertscripts/zabbix_test.sh</div><div class="line"></div><div class="line">#!/bin/bash</div><div class="line">to=$1</div><div class="line">subject=$2</div><div class="line">body=$3</div><div class="line"></div><div class="line"></div><div class="line">#可以同时给多个用户发送，用空格隔开</div><div class="line">cat &lt;&lt;EOF | mail -s &quot;$subject&quot; &quot;to&quot;</div><div class="line">$body</div><div class="line">EOF</div></pre></td></tr></table></figure></p><p>然后我们在创建脚本媒体的时候，写入相关参数。</p><p><br></p><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>可以根据所有支持的类型的时间定义操作：</p><ul><li>触发事件：当trigger的状态从OK转到Problem或回转时；</li><li>发现事件；</li><li>自动注册事件；</li><li>内部事件；</li></ul><p>配置-动作-创建动作</p><h4 id="条件-condition"><a href="#条件-condition" class="headerlink" title="条件(condition)"></a>条件(condition)</h4><p>只有在事件与定义的条件匹配的情况下才执行操作。</p><p>注意运算类型：似与非似</p><h4 id="操作-operation"><a href="#操作-operation" class="headerlink" title="操作(operation)"></a>操作(operation)</h4><p>操作：发送信息，执行远程命令。</p><h5 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h5><h5 id="远程命令"><a href="#远程命令" class="headerlink" title="远程命令"></a>远程命令</h5><p>(不支持在zabbix-agent上执行远程命令，需要在zabbix-server到代理的命令才能直接连接。远程命令限制255字符，可以将过个命令放置于新行上来执行过个命令。及时目标主机处于维护状态，也会执行远程命令).</p><p>配置-动作-操作，在操作细节中修改操作类型为远程命令。</p><p>在Zabbix代理（自定义脚本）上执行的那些远程命令必须首先在相应的命令中启用 zabbix_agentd.conf.确保 EnableRemoteCommands 参数设置为 1 并取消注释。 如果更改此参数，请重新启动代理守护程序。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">vim /etc/zabbix/zabbix_agentd.conf</div><div class="line"></div><div class="line"></div><div class="line">EnableRemoteCommands=1</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">cd</span> /usr/lib/zabbix/alertscripts</div><div class="line"><span class="comment">#或修改zabbix-server.conf中的文件位置</span></div><div class="line">vi sendmail.sh</div><div class="line"></div><div class="line"></div><div class="line">chown zabbix.zabbix ./sendmail.sh &amp;&amp; chmod a+x ./sendmail.sh</div></pre></td></tr></table></figure><p>接下来在动作中选择为执行远程命令，并在相应位置输入命令。</p><p><img src="/images/Zabbix/remotecommand.png" alt=""></p><p>支持自定义脚本、SSH、Telnet等方式。</p><p><strong>在信息中使用宏(using macros in messages)：</strong><br>在消息主题和消息文本中，可使用宏来更有效的问题报告。</p><p><strong>恢复操作(recovery operation):</strong><br>恢复操作允许在问题解决时通知我们。<br>恢复操作支持消息和远程命令。</p><p><br><br><br></p><h2 id="宏-macros"><a href="#宏-macros" class="headerlink" title="宏(macros)"></a>宏(macros)</h2><p>官方支持的宏的完整列表：<a href="https://www.zabbix.com/documentation/3.4/manual/appendix/macros/supported_by_location" target="_blank" rel="noopener">https://www.zabbix.com/documentation/3.4/manual/appendix/macros/supported_by_location</a></p><p>zabbix支持许多在多种情况下使用的宏。宏是一个变量，由如下特殊语法标识。</p><p>宏类似于全局变量，宏是特别有用的，特别是在报警动作中。对于不同的细节加上特定的宏，能够使报警信息更加详细。</p><p><code>{MACRO}</code></p><p>根据在上下文汇总，宏解析为一个特殊的值。有效地使用宏可以节省时间，并使zabbix更加高效。</p><p>宏可以在监控项键值参数中使用。宏只能用在监控项键值参数的一部分中。<br>如<code>item.key[server_{HOST.HOST}_local]</code> 。</p><p><img src="/images/Zabbix/MACRO.png" alt="宏"></p><p><br></p><h3 id="宏函数-macro-function"><a href="#宏函数-macro-function" class="headerlink" title="宏函数(macro function)"></a>宏函数(macro function)</h3><p>宏函数能提供自定义宏值的功能。</p><p>宏函数语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;&lt;macro&gt;.&lt;func&gt;(&lt;params&gt;)&#125;</div><div class="line"></div><div class="line">#&lt;macro&gt;, 要定义的宏</div><div class="line">#&lt;func&gt;, 要应用的函数</div><div class="line">#&lt;params&gt;, 以逗号分隔的函数参数列表</div><div class="line"></div><div class="line">#栗子</div><div class="line">&#123;&#123;ITEM.VALUE&#125;.regsub&#123;pattern, output&#125;&#125;</div></pre></td></tr></table></figure></p><p><br></p><h3 id="用户宏-user-macro"><a href="#用户宏-user-macro" class="headerlink" title="用户宏(user macro)"></a>用户宏(user macro)</h3><p>除了支持开箱即用的宏之外，zabbix还支持更灵活的用户宏。</p><p>用户宏可在全局、模板和主机级别进行定义。有一个特殊语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;$MACRO&#125;</div></pre></td></tr></table></figure></p><p>用户宏可用于：</p><ul><li>监控项名称；</li><li>监控项键值参数；</li><li>触发器名称和描述；</li><li>触发器表达式参数和常量；</li><li>许多其他位置。</li></ul><h3 id="自动发现宏-LLD"><a href="#自动发现宏-LLD" class="headerlink" title="自动发现宏(LLD)"></a>自动发现宏(LLD)</h3><p>有一种自动发现(LLD)函数中使用的宏类型，可用于创建监控项、触发器和图形原型。然后，当发现真实的文件系统、网络接口等，这些宏将替换为真实的值，并且以这些值来创建真实的监控项、触发器和图形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;#MACRO&#125;</div></pre></td></tr></table></figure></p><p><br></p><h2 id="用户和用户组-user-and-group"><a href="#用户和用户组-user-and-group" class="headerlink" title="用户和用户组(user and group)"></a>用户和用户组(user and group)</h2><p>zabbix中所有用户都通过web前端去访问zabbix应用程序。并为每一个用户分配唯一的登录名和密码，被加密储存于zabbix数据库中。</p><p><strong>配置用户(configuring user)</strong><br>管理-用户，创建和管理用户。</p><p><strong>权限(permission)</strong><br>可定义相应的用户类型，如用户，管理员和超级管理员。</p><p><strong>用户组(groups)</strong><br>管理-用户组，创建和配置用户组。</p><p><br><br><br></p><hr><h1 id="服务监控-service-monitoring"><a href="#服务监控-service-monitoring" class="headerlink" title="服务监控(service monitoring)"></a>服务监控(service monitoring)</h1><p>服务监控，旨在帮助那些想要高级业务监控的人。<br>在很多情况下，我们关注的不是底层细节，而是提供的可用性服务。</p><p>服务是分层表示监控数据。</p><blockquote><p>IT</p><blockquote><p>Workstations</p><blockquote><p>workstation1<br>workstation2</p></blockquote><p>Services</p></blockquote></blockquote><p>配置-服务，最高节点的服务是’root’。<br>你可以通过添加低级服务节点和各个节点服务创建下层层次结构。</p><p><br></p><hr><p><br></p><h1 id="Web监控-web-monitoring"><a href="#Web监控-web-monitoring" class="headerlink" title="Web监控(web monitoring)"></a>Web监控(web monitoring)</h1><p>配置-主机-web监测，创建或修改web监测信息。<br>可使用zabbix检查几个网站可用性方面。(zabbix中包含libcurl库才行)</p><p>要使用web监控，需要定义web场景。包括一个或多个HTTP请求或步骤。Zabbix-Server根据预定义的命令周期性的执行这些步骤。</p><p>Web监测中的<strong>要求的字段(required string)</strong>支持正则表达式，所以这对于检索页面信息很有用。这个真的很有用！</p><p>所有web场景会收集下列数据：</p><ul><li>整个场景中所有步骤的平均下载速度；</li><li>失败的步骤数量；</li><li>最后一次错误信息</li></ul><p>web场景的所有步骤，都会收集下列数据：</p><ul><li>平均下载速度；</li><li>响应时间</li><li>HTTP状态吗</li></ul><p><br></p><h2 id="Web监控项-web-monitoring-items"><a href="#Web监控项-web-monitoring-items" class="headerlink" title="Web监控项(web monitoring items)"></a>Web监控项(web monitoring items)</h2><p>在创建web场景时，会自动添加一些新监控项进行监控。</p><p>创建场景后，zabbix会自动添加以下监控项进行监控，将它们链接到所选的应用程序。</p><ul><li>场景<scenario>的下载速度；</scenario></li><li>场景<scenario>的失败步骤；</scenario></li><li>场景<scenario>的最后一个错误消息；</scenario></li></ul><p><br></p><p><strong>举个栗子：</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">##创建Web监测</span></div><div class="line"><span class="comment">#配置-主机-Web监测-创建web监测</span></div><div class="line"></div><div class="line">URL：web.zabbix.me/monitor.php</div><div class="line">要求的状态码：200</div><div class="line">超时：20s</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##创建web监测触发器</span></div><div class="line"><span class="comment">#配置-主机-触发器-创建触发器</span></div><div class="line"></div><div class="line">严重性：一般严重</div><div class="line"><span class="comment">#触发条件：状态码!=200</span></div><div class="line">表达式：N&lt;&gt;200</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##创建触发报警对应的动作</span></div><div class="line"><span class="comment">#配置-动作-创建动作</span></div><div class="line"></div><div class="line"><span class="comment">#触发条件</span></div><div class="line">触发器示警度=一般严重 or 触发器=web.zabbix.me</div><div class="line"></div><div class="line"><span class="comment">#操作：发送Email</span></div><div class="line">发送给zabbix administrator用户群组</div><div class="line">仅送到Email</div><div class="line">默认信息/自定义信息</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##在媒体类型中定义Email相关信息</span></div><div class="line"><span class="comment">#管理-报警媒体类型-Email</span></div><div class="line"></div><div class="line">SMTP服务器：smtp.xxx.com</div><div class="line">smtp端口：465</div><div class="line">SMTP电邮：发件人Email</div><div class="line">安全链接：SSL/TLS</div><div class="line">认证：Usernameand passwd</div><div class="line">用户名：xxx</div><div class="line">密码： xxx</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##接下来就可以测试接收报警Email了</span></div></pre></td></tr></table></figure></p><p><br><br><br></p><hr><h1 id="虚拟机监控-VM-monitoring"><a href="#虚拟机监控-VM-monitoring" class="headerlink" title="虚拟机监控(VM monitoring)"></a>虚拟机监控(VM monitoring)</h1><p>zabbix支持对VMware的监控，使用low-levle-discovery(LLD)自动发现VMware hypervisors和虚拟机，并根据事先定义的主机原型，为这些虚拟机建立主机，添加监控。</p><p>zabbix中提供了几个模板，可以直接用来解控VMware vCenter 或 ESX hypervisor。</p><p><br><br>虚拟机监控分为两个步骤：</p><ul><li>首先，zabbix是通过VMware collector进程来监控虚拟机。这些进程通过SOAP协议从VMware服务获取必要的信息，对其进行预处理并储存到zabbix-server共享内存中；</li><li>然后，zabbix-pollers通过zabbix简单检查VMware keys来检索这些数据。</li></ul><p>要使虚拟机监控正常工作，需要libxml2库和libcurl库的支持。</p><blockquote><p>配置-自动发现-创建自动发现<br>配置-主机-自动发现</p></blockquote><p><br><br><br></p><hr><h1 id="维护-maintenance"><a href="#维护-maintenance" class="headerlink" title="维护(maintenance)"></a>维护(maintenance)</h1><p>可在zabbix中为主机和主机组定义维护周期。<br>有两种维护类型：“继续对目标进行监控数据的收集” 和 “停止对目标进行监控数据的收集”</p><p>要在维护期间正常接收问题通知，必须在动作配置中的选项中取消选择暂停操作。<br>为了确保定期维护按照预期的时间进行，需要对zabbix的所有部分使用通用时区。</p><blockquote><p>配置-维护-创建维护期</p></blockquote><p>维护期的主机显示的是橙色背景！</p><p><br><br><br></p><hr><h1 id="事件确认-event-acknowledgment"><a href="#事件确认-event-acknowledgment" class="headerlink" title="事件确认(event acknowledgment)"></a>事件确认(event acknowledgment)</h1><p>zabbix中的问题事件可以由用户确认。</p><p>如果用户获得了有关问题时间的通知，可以访问zabbix前端，从时间导航到确认屏幕并确认问题。<br>当他们确认时，可输入评论或其他一些相关描述。<br>这样其他系统用户同样的问题，他们便会立即看到是否已被解决和目前的评论。</p><p>以这种方式，可以更协调的进行解决多个系统用户的问题的工作流程。</p><p>要确认事件，用户必须至少要有对相应触发器的读取权限。</p><p><br><br>在Dashboard下，在出现的问题里，点击确认，进入确认事件。<br>也可在监控-问题下查看问题详细信息。</p><p><br><br><br></p><hr><h1 id="配置导出-导入-Configuration-export-import"><a href="#配置导出-导入-Configuration-export-import" class="headerlink" title="配置导出/导入(Configuration export/import)"></a>配置导出/导入(Configuration export/import)</h1><p>zabbix导入/导出功能，使得可以在一个zabbix系统与另一个zabbix系统之间交换各种配置实体。<br>类似于数据库的导入导出。即也可以对zabbix做备份。</p><p>可导出/导入的对象有：主机组； 模板； 主机； 拓扑； 图片； 聚合图形； 值映射。</p><p>数据也可导出：</p><ul><li>XML - 在前端</li><li>XML or JSON - 在zabbix API</li></ul><p>导出的详细信息：</p><ul><li>所有支持的元素都导出到一个文件中；</li><li>不导出从连链接模板继承的主机和模板实体；</li><li>由低级别发现创建的实体依赖于他们的任何实体不会导出。</li></ul><p>导入详细信息：</p><ul><li>第一次遇到错误停止导入；</li><li>导入支持XML和JSON文件；</li><li>使用“删除缺失”选项导入主机/模板时，导入的XML文件中不存在主机/模板宏也将被删除。</li></ul><p><br><br><br></p><hr><h1 id="将Zabbix展现在Nginx上"><a href="#将Zabbix展现在Nginx上" class="headerlink" title="将Zabbix展现在Nginx上"></a>将Zabbix展现在Nginx上</h1><p>毕竟现在Nginx用的多，那就把Apache换成Nginx吧！</p><p>Nginx仓库:<a href="http://nginx.org/packages/" target="_blank" rel="noopener">http://nginx.org/packages/</a></p><p>自己安装Nginx:</p><ol><li>下载<code>nginx-release-xx.rmp</code>仓库源来安装；</li><li>手动创建<code>/etc/yum.repo.d/nginx.repo</code>；</li><li>直接下载<code>ngix.rpm</code>来安装；</li><li>直接下载源码来安装。</li></ol><p>相较于Apache，Nginx也只是配置个server就行了。优化什么的自己弄。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">vim /etc/nginx/conf.d/zabbix.conf</div><div class="line"></div><div class="line">server &#123;</div><div class="line">listen 80;</div><div class="line">    server_name zabbix.me;</div><div class="line">    root /usr/share/zabbix;</div><div class="line"></div><div class="line">    access_log  /var/<span class="built_in">log</span>/nginx/zabbix.access.log  main;</div><div class="line"></div><div class="line">allow 127.0.0.1;</div><div class="line">allow Your-IP;</div><div class="line">    deny all;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">    <span class="keyword">if</span> (!-f <span class="variable">$request_filename</span>) &#123;</div><div class="line">        rewrite ^([^\?]+)$ /index.php?1=<span class="variable">$1</span> last;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location ~ \.php$ &#123;</div><div class="line">    root /usr/share/zabbix;</div><div class="line">        fastcgi_pass 127.0.0.1:9000;</div><div class="line">        fastcgi_index index.php;</div><div class="line">        fastcgi_param SCRIPT_FILENAME <span class="variable">$document_root</span>/<span class="variable">$fastcgi_script_name</span>;</div><div class="line">        include fastcgi_params;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">nginx -t</div><div class="line">systemctl start nginx</div></pre></td></tr></table></figure></p><p>下载就可以正常访问<code>zabbix-web</code>端了!</p><p><br><br><br></p><hr><h1 id="Zabbix监控"><a href="#Zabbix监控" class="headerlink" title="Zabbix监控"></a>Zabbix监控</h1><p>Zabbix自带的templates基本涵盖了大部分监控信息。</p><p>大部分操作系统：</p><ul><li>OS Linux;</li><li>OS AIx;</li><li>OS FreeBSD;</li><li>OS Solaris;</li><li>OS Windows;</li><li>…</li></ul><p>大部分服务：</p><ul><li>CPU;</li><li>Filesystems;</li><li>HTTP/HTTPS service;</li><li>Memory;</li><li>Network interfaces;</li><li>Processes;</li><li>Secutity;</li><li>Zabbix server/agent/Proxy;</li><li>SMTP,POP,SSH,NTP, service;</li><li>ICMP Ping;</li><li>SNMP;</li><li>…</li></ul><p>虚拟机：</p><ul><li>VM VMware;</li><li>VM WMware Hypervisor;</li><li>…</li></ul><p>网络设备：</p><ul><li>Cisco;</li><li>Huawei;</li><li>TPLink;</li><li>HP;</li><li>…</li></ul><p><br><br>除了Zabbix自带的templates，你还可以下载templates并导入zabbix-server。</p><p>例如PHP-FPM, MongoDB, Apache, Nginx, Redis等额外软件的监控就需要下载额外templates。</p><p><br><br><br></p><h2 id="监控MySQL"><a href="#监控MySQL" class="headerlink" title="监控MySQL"></a>监控MySQL</h2><h3 id="使用Zabbix自带模板监控MySQL"><a href="#使用Zabbix自带模板监控MySQL" class="headerlink" title="使用Zabbix自带模板监控MySQL"></a>使用Zabbix自带模板监控MySQL</h3><p>Zabbix默认带有MySQL的监控和模板，所以无需再去下载。不过需要配置用户，密码，主机，端口等信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">vim /etc/zabbix/zabbix-agentd.d/userparameter_mysql.conf</div><div class="line"></div><div class="line"><span class="comment">#For all the following commands HOME should be set to the directory that has .my.cnf file with password information.</span></div><div class="line"><span class="comment">#这句话叫我们新建一个带有mysql密码信息的.my.cnf文件</span></div><div class="line"><span class="comment">#并把此配置文件里面的HOME改为.my.cnf所的在目录</span></div><div class="line"><span class="comment">#.my.cnf文件里面的用户要对MySQL数据库有权限才行，没有权限请记得加</span></div><div class="line"></div><div class="line">[mysql]</div><div class="line">host=localhost</div><div class="line">user=zabbix</div><div class="line">password=zabiix</div><div class="line">socket=/var/lib/mysql/mysql.sock</div><div class="line"></div><div class="line">[mysqladmin]</div><div class="line">host=localhost</div><div class="line">user=root</div><div class="line">password=password</div><div class="line">socket=/var/lib/mysql/mysql.sock</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#测试</span></div><div class="line">zabbix_get -s 127.0.0.1 -k mysql.ping</div><div class="line"><span class="comment">#1</span></div></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用Percona插件监控MySQL"><a href="#使用Percona插件监控MySQL" class="headerlink" title="使用Percona插件监控MySQL"></a>使用Percona插件监控MySQL</h3><p>Zabbix默认带有MySQL的监控和模板，所以无需再去下载。不过需要配置用户，密码，主机，端口等信息。<br>但是Zabbix自带的MySQL监控太简陋了。<br>所以使用Percona提供的模板及监控。</p><p><br></p><p>Percona Monitoring Plugins-URL:  <a href="https://www.percona.com/downloads/percona-monitoring-plugins/LATEST/" target="_blank" rel="noopener">https://www.percona.com/downloads/percona-monitoring-plugins/LATEST/</a><br>Percona Monitoring Plugins for Zabbix- Instructions:  <a href="https://www.percona.com/doc/percona-monitoring-plugins/LATEST/zabbix/index.html" target="_blank" rel="noopener">https://www.percona.com/doc/percona-monitoring-plugins/LATEST/zabbix/index.html</a></p><p>此插件地址需要我们选择Percona-Version和Software平台。</p><p><img src="/images/Zabbix/mysql01.png" alt="Percona Monitoring Plugins"></p><p>选择平台后，我们只需安装zabbix的rpm包就好：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#安装rpm包</span></div><div class="line">yum install -y https://www.percona.com/downloads/percona-monitoring-plugins/percona-monitoring-plugins-1.1.7/binary/redhat/7/x86_64/percona-zabbix-templates-1.1.7-2.noarch.rpm</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#安装软件</span></div><div class="line"><span class="comment">#注意php版本问题</span></div><div class="line">yum install -y percona-zabbix-templates</div><div class="line"></div><div class="line">ls /var/lib/zabbix/percona</div><div class="line"><span class="comment">#scripts目录有.sh脚本文件</span></div><div class="line"><span class="comment">#templates目录有配置文件和模板文件</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#复制配置文件</span></div><div class="line">cp /var/lib/zabbix/percona/templates/userparameter_percona_mysql.conf /etc/zabbix/zabbix_agentd.d/</div><div class="line"><span class="comment">#我看了一下，这个配置文件和zabbix自带的MySQL配置文件一样</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#添加MySQL的相关信息</span></div><div class="line">vim /var/lib/zabbix/percona/scripts/ss_get_mysql_stats.php</div><div class="line"></div><div class="line"><span class="variable">$mysql_user</span> = <span class="string">'root'</span>;</div><div class="line"><span class="variable">$mysql_pass</span> = <span class="string">'password'</span>;</div><div class="line"><span class="variable">$mysql_port</span> = 3306;</div><div class="line"><span class="variable">$mysql_socket</span> = <span class="string">'/var/lib/mysql/mysql.sock'</span>;</div><div class="line"><span class="variable">$mysql_flags</span> = 0;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#测试脚本</span></div><div class="line">/var/lib/zabbix/percona/scripts/get_mysql_stats_wrapper.sh gg</div><div class="line"><span class="comment">#10</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#创建.my.cnf文件</span></div><div class="line">vim /etc/zabbix/zabbix_agentd.d/.my.cnf</div><div class="line"></div><div class="line">[mysql]</div><div class="line">host=localhost</div><div class="line">user=root</div><div class="line">password=password</div><div class="line">socket=/var/lib/mysql/mysql.sock</div><div class="line"></div><div class="line">[mysqladmin]</div><div class="line">host=localhost</div><div class="line">user=root</div><div class="line">password=password</div><div class="line">socket=/var/lib/mysql/mysql.sock</div><div class="line"></div><div class="line">[client]</div><div class="line">host=localhost</div><div class="line">user=root</div><div class="line">password=password</div><div class="line">socker=/var/lib/mysql/mysql.sock</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#重启服务</span></div><div class="line">systemctl restart zabbix-agent</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#测试</span></div><div class="line">sudo -u zabbix -H /var/lib/zabbix/percona/scripts/get_mysql_stats_wrapper.sh running-slave</div><div class="line"><span class="comment">#0/1</span></div></pre></td></tr></table></figure><p>导入模板，模板文件位于：<code>/var/lib/zabbix/percona/templates/zabbix_agent_template_percona_mysql_server_ht_2.0.9-sver1.1.7.xml</code></p><p>但我直接导入模板时报错——标签无效 “/zabbix_export/date”: “YYYY-MM-DDThh:mm:ssZ” 预计。<br>此模板需要先导入Zabbix2.4后再导出，然后再导入到Zabbix3.4。太麻烦。<br><img src="/images/Zabbix/mysql02.png" alt="导入percona模板"></p><p>所以需要下载修改过的模板： <a href="http://jaminzhang.github.io/soft-conf/Zabbix/zbx_percona_mysql_template.xml" target="_blank" rel="noopener">http://jaminzhang.github.io/soft-conf/Zabbix/zbx_percona_mysql_template.xml</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://jaminzhang.github.io/soft-conf/Zabbix/zbx_percona_mysql_template.xml</div></pre></td></tr></table></figure><p>下载之后导入模板，然后链接主机。<br>链接之后可以部分监控可能显示不支持的。</p><p>如：Received value [rm: 无法删除”/tmp/localhost-mysql_cacti_stats.txt”: 不允许的操作0] is not suitable for value type [Numeric (float)]<br>没有权限。<br><img src="/images/Zabbix/mysql03.png" alt=""></p><p>解决办法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /tmp</div><div class="line">chown -R zabbix:zabbix localhost-mysql_cacti_stats.txt</div><div class="line"></div><div class="line">systemcet restart zabbix-agent</div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="监控MongoDB"><a href="#监控MongoDB" class="headerlink" title="监控MongoDB"></a>监控MongoDB</h2><p><strong>感谢大神：</strong></p><ul><li>MongoDB-templates: <a href="https://share.zabbix.com/databases/mongodb/mongodb-for-zabbix-3-2" target="_blank" rel="noopener">https://share.zabbix.com/databases/mongodb/mongodb-for-zabbix-3-2</a> ;</li><li>GitHub: <a href="https://github.com/oscm/zabbix/tree/master/mongodb" target="_blank" rel="noopener">https://github.com/oscm/zabbix/tree/master/mongodb</a></li><li>此github-repo中还包含了<code>Oracle</code>, <code>php-fpm</code>, <code>postfix</code>, <code>redis</code>, <code>Nginx</code>。可参看README.md来配置zabbix对它们的监控。</li></ul><p><br></p><p><img src="/images/Zabbix/zabbix_master.png" alt="./master"></p><p><br></p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p><strong>1. 在zabbix-agent安装<code>jq</code></strong><br>jq - Command-line JSON processor;</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y jq</div></pre></td></tr></table></figure><p><br><br><strong>2. 在zabbix-agent的MongoDB中创建用于监控的账号</strong><br>创建用于读取MongoDB相关信息的账户及其权限。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">mongo</div><div class="line"></div><div class="line">&gt;use admin</div><div class="line"></div><div class="line">&gt;db.createUser(</div><div class="line">  &#123;</div><div class="line">user:<span class="string">'zabbix'</span>,</div><div class="line"><span class="built_in">pwd</span>:<span class="string">'zabbix'</span>,</div><div class="line">roles:[&#123;</div><div class="line">role:<span class="string">'clusterMonitor'</span>,</div><div class="line">db:<span class="string">'admin'</span>&#125;]</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p><br><br><strong>3. 在agent下载github仓库的MongoDB模板等文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">wget https://codeload.github.com/oscm/zabbix/zip/master -O master.zip</div><div class="line"><span class="comment">#这里面不仅仅有mongodb，还有redis,php等。</span></div><div class="line"><span class="comment">#我们只需要进入mongodb目录就好</span></div><div class="line"></div><div class="line">unzip master.zip</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">cd</span> ./zabbix-master/mongodb</div><div class="line">ls</div><div class="line"></div><div class="line"><span class="comment">#mongodb.sh , 执行脚本</span></div><div class="line"><span class="comment">#userparameter_mongodb.conf ，配置脚本</span></div><div class="line"><span class="comment">#zbx_export_templates.xml，zabbix模板文件</span></div></pre></td></tr></table></figure><p><img src="/images/Zabbix/zabbix_mongodb1.png" alt="./master/mongodb"></p><p><br><br><strong>4. 移动并配置mongodb.sh</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">cp ./mongodb.sh /etc/zabbix</div><div class="line"></div><div class="line">chmod a+x /etc/zabbix/mongodb.sh</div><div class="line"></div><div class="line"></div><div class="line">vi mongodb.sh</div><div class="line"></div><div class="line"><span class="comment">#如果HOST,PORT不是默认，请修改</span></div><div class="line">DB_HOST=127.0.0.1</div><div class="line">DB_PORT=27017</div><div class="line">DB_USERNAME=zabbix</div><div class="line">DB_PASSWORD=zabbix</div></pre></td></tr></table></figure><p><img src="/images/Zabbix/zabbix_mongodb2.png" alt="mongodb.sh"></p><p><br><br><strong>5. 移动并修改userparameter_mongodb.conf</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cp ./zabbix-master/userparameter_mongodb.conf /etc/zabbix/zabbix_agentd.d</div><div class="line"></div><div class="line">vi ./userparameter_mongodb.conf</div><div class="line"></div><div class="line">UserParameter=mongodb.status[*],/etc/zabbix/mongodb.sh <span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span> <span class="variable">$4</span> <span class="variable">$5</span></div><div class="line"><span class="comment">#修改为mongdb.sh真实位置</span></div><div class="line"><span class="comment">#这个是用户自定义的参数，可以之间写入到zabbix_agent.conf里面</span></div></pre></td></tr></table></figure><p><img src="/images/Zabbix/zabbix_mongodb3.png" alt="userparameter_mongodb.conf"></p><p><br><br><strong>6. 重启zabbix-agent</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart zabbix-agent</div></pre></td></tr></table></figure><p><br><br><strong>7. 在zabbix-web导入mongodb模板</strong></p><ul><li>配置-模板-导入模板；</li><li>选择<code>./master/mongodb/zbx_export_templates.xml</code>模板文件，并导入；</li><li>接下来便可以在 templates中看到”Template App MongoDB”这个模板；</li><li>可将此模板链接到某个主机上监控，并到最新数据里查看相关MongoDB信息；</li><li>如果相对此模板就行修改，可编辑zbx_export_templates.xml文件。</li></ul><p><br></p><p><img src="/images/Zabbix/zabbix_web_import_mongodb1.png" alt="导入mongodb模板"><br><img src="/images/Zabbix/zabbix_web_import_mongodb2.png" alt="选择导入文件"><br><img src="/images/Zabbix/zabbix_web_import_mongodb3.png" alt="查看MongoDB模板"><br><img src="/images/Zabbix/zabbix_web_import_mongodb4.png" alt="在主机中关联MongoDB模板"><br><img src="/images/Zabbix/zabbix_web_import_mongodb5.png" alt="查看最新MongoDb数据"></p><p><br></p><h3 id="监控一台主机上的额外mongod实例"><a href="#监控一台主机上的额外mongod实例" class="headerlink" title="监控一台主机上的额外mongod实例"></a>监控一台主机上的额外mongod实例</h3><p>由于可能一台主机上运行的mongod实例不止一个，所以我们需要修改一下前面下载的配置文件，用以监控其它端口的mongod实例。</p><ul><li>此处假设默认的mongod实例运行在27017端口上</li><li>另外还有一个mongod实例运行在27018端口上</li><li>此处假设我们已经完成了前面对27017mongodb的监控了</li></ul><p>操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /etc/zabbix</div><div class="line">cp mongodb.sh mongodb_27018.sh</div><div class="line"></div><div class="line">vim ./mongodb_27018.sh</div><div class="line"><span class="comment">#配置监控的mongodb账号和端口</span></div><div class="line"></div><div class="line">DB_HOST=127.0.0.1</div><div class="line">DB_PORT=27018</div><div class="line">DB_USERNAME=zabbix</div><div class="line">DB_PASSWORD=zabbix</div><div class="line"></div><div class="line"><span class="comment">#现在就有了提取27017/27018两个mongodb实例的脚本</span></div><div class="line"><span class="comment">#mongodb.sh</span></div><div class="line"><span class="comment">#mongodb_27018.sh</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">cd</span> ./zabbxi-agentd.d</div><div class="line"></div><div class="line">vim userparameter_mongodb.conf</div><div class="line"><span class="comment">#在默认的27017下面添加一行提取mongodb_27018信息的脚本</span></div><div class="line"></div><div class="line">UserParameter=mongodb.status[*],/etc/zabbix/mongodb.sh <span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span> <span class="variable">$4</span> <span class="variable">$5</span></div><div class="line">UserParameter=mongodb_27018.status[*],/etc/zabbix/mongodb_27018.sh <span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span> <span class="variable">$4</span> <span class="variable">$5</span></div><div class="line"></div><div class="line"><span class="comment">#现在zabbix-server端就可以同时获取27017/27018两个mongodb实例的信息</span></div><div class="line"><span class="comment">#但是Web界面还不能直接显示出来，因为27018的键值和默认不相同</span></div><div class="line"><span class="comment">#没错，就是上面我们修改的 mongodb_27018.status[*]</span></div></pre></td></tr></table></figure><p><br></p><p><img src="/images/Zabbix/mongodb_27018.png" alt="mongodb_27018.sh"></p><p><img src="/images/Zabbix/mongodb_27018_02.png" alt="mongodb_27018.sh"></p><p><br></p><p><strong>接下来要在Zabbix-Web端配置监控项用以提取信息</strong></p><p>我们先找到一个默认的MongoDB自带的配置模板，如<code>MongoDB Connections current</code>，点进去查看它的键值对为<code>mongodb.status[connections,current]</code></p><p>因此我们只需要修改为我们配置文件里面的<code>mongodb_27018.status[*]</code>就可以了。</p><p><img src="/images/Zabbix/mongodb_27018_03.png" alt="mongodb_27018.sh"></p><p><img src="/images/Zabbix/mongodb_27018_04.png" alt="mongodb_27018.sh"></p><p><br></p><p>其余个监控项以此类推，我觉得其他服务也应该可以如此。</p><p><strong>你也可以对此建立一个单独的模板，如MongoDB_27108 templates。在此监控模板下创建上面的监控项。这样就可以对所有主机生效了。也可以批量化操作，更方便一些。</strong></p><p>下面是我的参考<strong>Template App MongoDB</strong>模板建立的<strong>Template App MongoDB_27018</strong></p><p><img src="/images/Zabbix/mongodb_27018_05.png" alt="mongodb_27018.sh"></p><p><img src="/images/Zabbix/mongodb_27018_06.png" alt="mongodb_27018.sh"></p><p><br><br><br></p><h2 id="监控PHP-FPM"><a href="#监控PHP-FPM" class="headerlink" title="监控PHP-FPM"></a>监控PHP-FPM</h2><p>同样使用上面大神的模板。</p><p>步骤和监控MongoDB类似：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#进入下载的文件目录</span></div><div class="line"><span class="built_in">cd</span> ./zabbix-master/php-fpm</div><div class="line">cp ./php-fpm.xml.sh /etc/zabbix</div><div class="line">chmod a+x /etc/zabbix/php-fpm.xml.sh</div><div class="line">vim /etc/zabbix/php-fpm.xml.sh</div><div class="line"></div><div class="line"><span class="comment">#如果这三个参数修改了，请修改</span></div><div class="line"><span class="comment">#因为是使用culr，所以请允许此IP能够访问此页面</span></div><div class="line"><span class="comment">#另外还要Nginx允许Server-IP访问哦，不然无法读取数据</span></div><div class="line"><span class="comment">#我测试的时候用IP无法获取数据，所以用的域名</span></div><div class="line"><span class="comment">#如果没做域名解析，请加本地hosts</span></div><div class="line"><span class="comment">#php-fpm_status使用我修改的</span></div><div class="line"></div><div class="line">HOST=<span class="string">"localhost"</span></div><div class="line">PORT=<span class="string">"80"</span></div><div class="line"><span class="comment">#status="status"</span></div><div class="line">status=<span class="string">"php-fpm_status"</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">cp ./userparameter_php-fpm.conf /etc/zabbix/zabbix_agent.d/</div><div class="line"><span class="comment">#当然也可以把这个用户自定义参数写入zabbix_agent.conf</span></div><div class="line"><span class="comment">#修改自定义参数里面的文件位置</span></div><div class="line">vim /etc/zabbix/zabbix_agent.d/userparameter_php-fpm.conf</div><div class="line"></div><div class="line">UserParameter=php-fpm.status[*],/etc/zabbix/php-fpm.xml.sh <span class="variable">$1</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#php-fpm，nginx的状态必须用Nginx展现，Zabbix-Server是使用curl提取状态页面的信息</span></div><div class="line">vim /etc/nginx/conf.d/zabbix.conf</div><div class="line"></div><div class="line">server &#123;</div><div class="line">listen 80;</div><div class="line">    server_name zabbix.me localhost;</div><div class="line"><span class="comment">#如果localhost与其他配置文件冲突，那就用IP</span></div><div class="line"><span class="comment">#server_name zabbix.me 127.0.0.1 Private-IP Public-IP;</span></div><div class="line">    root /usr/share/zabbix;</div><div class="line"></div><div class="line">    access_log  /var/<span class="built_in">log</span>/nginx/zabbix.access.log  main;</div><div class="line"></div><div class="line"><span class="comment">#allow无法使用localhost，所有内外网要分开写</span></div><div class="line">allow 127.0.0.1;</div><div class="line">allow Private-IP;</div><div class="line">allow Public-IP;</div><div class="line">allow Zabbix-Server-IP;</div><div class="line">allow Remote-View-IP;</div><div class="line">deny all;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">    <span class="keyword">if</span> (!-f <span class="variable">$request_filename</span>) &#123;</div><div class="line">rewrite ^([^\?]+)$ /index.php?1=<span class="variable">$1</span> last;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#Nignx_Status</span></div><div class="line">    location /nginx_status &#123;</div><div class="line">        stub_status on;</div><div class="line">        <span class="comment">#开启nginx自带的状态检查功能</span></div><div class="line">        access_log off;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#php-fpm_Status</span></div><div class="line"><span class="comment">#php-fpm的默认状态页面是/status,/ping。我修改了一下。</span></div><div class="line">    location ~ ^/php-fpm_(status|ping)$ &#123;</div><div class="line">    access_log off;</div><div class="line">        fastcgi_pass 127.0.0.1:9000;</div><div class="line">        fastcgi_index index.php;</div><div class="line">        fastcgi_param SCRIPT_FILENAME <span class="variable">$document_root</span>/<span class="variable">$fastcgi_script_name</span>;</div><div class="line">        include fastcgi_params;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    location ~ \.php$ &#123;</div><div class="line">    root /usr/share/zabbix;</div><div class="line">        fastcgi_pass 127.0.0.1:9000;</div><div class="line">        fastcgi_index index.php;</div><div class="line">        fastcgi_param SCRIPT_FILENAME <span class="variable">$document_root</span>/<span class="variable">$fastcgi_script_name</span>;</div><div class="line">        include fastcgi_params;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="/images/Zabbix/zabbix-master_php-fpm.png" alt="监控php-fpm"></p><p><br></p><p><strong>php-fpm状态页面的配置文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line">vim /etc/php-fpm.d/www.conf</div><div class="line"></div><div class="line"><span class="comment">#说明和用法如下，我做简单修改</span></div><div class="line"><span class="comment">#修改默认值</span></div><div class="line">;pm.status_path = /status</div><div class="line">pm.status_path = /php-fpm_status</div><div class="line"></div><div class="line">;ping.path = /ping</div><div class="line">ping.path = /php-fpm_ping</div><div class="line">;ping.response = pong</div><div class="line">ping.response = 200</div><div class="line"></div><div class="line"><span class="comment">#用法</span></div><div class="line">zabbix.me/php-fpm_status</div><div class="line">zabbix.me/php-fpm_ping</div><div class="line"></div><div class="line"><span class="comment">#配置文件提供了格式化输出</span></div><div class="line">zabbix.me/php-fpm_status?html</div><div class="line">zabbix.me/php-fpm_status?html&amp;full</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">; output syntax. Example:</div><div class="line">;   http://www.foo.bar/status</div><div class="line">;   http://www.foo.bar/status?json</div><div class="line">;   http://www.foo.bar/status?html</div><div class="line">;   http://www.foo.bar/status?xml</div><div class="line">;   http://www.foo.bar/status?full</div><div class="line">;   http://www.foo.bar/status?json&amp;full</div><div class="line">;   http://www.foo.bar/status?html&amp;full</div><div class="line">;   http://www.foo.bar/status?xml&amp;full</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#修改完毕后重启服务</span></div><div class="line">systemctl restart php-fpm nginx</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#具体看下面描述</span></div><div class="line"><span class="comment">##这下面是说明</span></div><div class="line"></div><div class="line">; The URI to view the FPM status page. If this value is not <span class="built_in">set</span>, no URI will be</div><div class="line">; recognized as a status page. It shows the following informations:</div><div class="line">;   pool                 - the name of the pool;</div><div class="line">;   process manager      - static, dynamic or ondemand;</div><div class="line">;   start time           - the date and time FPM has started;</div><div class="line">;   start since          - number of seconds since FPM has started;</div><div class="line">;   accepted conn        - the number of request accepted by the pool;</div><div class="line">;   listen queue         - the number of request <span class="keyword">in</span> the queue of pending</div><div class="line">;                          connections (see backlog <span class="keyword">in</span> listen(2));</div><div class="line">;   max listen queue     - the maximum number of requests <span class="keyword">in</span> the queue</div><div class="line">;                          of pending connections since FPM has started;</div><div class="line">;   listen queue len     - the size of the socket queue of pending connections;</div><div class="line">;   idle processes       - the number of idle processes;</div><div class="line">;   active processes     - the number of active processes;</div><div class="line">;   total processes      - the number of idle + active processes;</div><div class="line">;   max active processes - the maximum number of active processes since FPM</div><div class="line">;                          has started;</div><div class="line">;   max children reached - number of <span class="built_in">times</span>, the process <span class="built_in">limit</span> has been reached,</div><div class="line">;                          when pm tries to start more children (works only <span class="keyword">for</span></div><div class="line">;                          pm <span class="string">'dynamic'</span> and <span class="string">'ondemand'</span>);</div><div class="line">; Value are updated <span class="keyword">in</span> real time.</div><div class="line">; Example output:</div><div class="line">;   pool:                 www</div><div class="line">;   process manager:      static</div><div class="line">;   start time:           01/Jul/2011:17:53:49 +0200</div><div class="line">;   start since:          62636</div><div class="line">;   accepted conn:        190460</div><div class="line">;   listen queue:         0</div><div class="line">;   max listen queue:     1</div><div class="line">;   listen queue len:     42</div><div class="line">;   idle processes:       4</div><div class="line">;   active processes:     11</div><div class="line">;   total processes:      15</div><div class="line">;   max active processes: 12</div><div class="line">;   max children reached: 0</div><div class="line">;</div><div class="line">; By default the status page output is formatted as text/plain. Passing either</div><div class="line">; <span class="string">'html'</span>, <span class="string">'xml'</span> or <span class="string">'json'</span> <span class="keyword">in</span> the query string will <span class="built_in">return</span> the corresponding</div><div class="line">; output syntax. Example:</div><div class="line">;   http://www.foo.bar/status</div><div class="line">;   http://www.foo.bar/status?json</div><div class="line">;   http://www.foo.bar/status?html</div><div class="line">;   http://www.foo.bar/status?xml</div><div class="line">;</div><div class="line">; By default the status page only outputs short status. Passing <span class="string">'full'</span> <span class="keyword">in</span> the</div><div class="line">; query string will also <span class="built_in">return</span> status <span class="keyword">for</span> each pool process.</div><div class="line">; Example:</div><div class="line">;   http://www.foo.bar/status?full</div><div class="line">;   http://www.foo.bar/status?json&amp;full</div><div class="line">;   http://www.foo.bar/status?html&amp;full</div><div class="line">;   http://www.foo.bar/status?xml&amp;full</div><div class="line">; The Full status returns <span class="keyword">for</span> each process:</div><div class="line">;   pid                  - the PID of the process;</div><div class="line">;   state                - the state of the process (Idle, Running, ...);</div><div class="line">;   start time           - the date and time the process has started;</div><div class="line">;   start since          - the number of seconds since the process has started;</div><div class="line">;   requests             - the number of requests the process has served;</div><div class="line">;   request duration     - the duration <span class="keyword">in</span> µs of the requests;</div><div class="line">;   request method       - the request method (GET, POST, ...);</div><div class="line">;   request URI          - the request URI with the query string;</div><div class="line">;   content length       - the content length of the request (only with POST);</div><div class="line">;   user                 - the user (PHP_AUTH_USER) (or <span class="string">'-'</span> <span class="keyword">if</span> not <span class="built_in">set</span>);</div><div class="line">;   script               - the main script called (or <span class="string">'-'</span> <span class="keyword">if</span> not <span class="built_in">set</span>);</div><div class="line">;   last request cpu     - the %cpu the last request consumed</div><div class="line">;                          it<span class="string">'s always 0 if the process is not in Idle state</span></div><div class="line"><span class="string">;                          because CPU calculation is done when the request</span></div><div class="line"><span class="string">;                          processing has terminated;</span></div><div class="line"><span class="string">;   last request memory  - the max amount of memory the last request consumed</span></div><div class="line"><span class="string">;                          it'</span>s always 0 <span class="keyword">if</span> the process is not <span class="keyword">in</span> Idle state</div><div class="line">;                          because memory calculation is <span class="keyword">done</span> when the request</div><div class="line">;                          processing has terminated;</div><div class="line">; If the process is <span class="keyword">in</span> Idle state, <span class="keyword">then</span> informations are related to the</div><div class="line">; last request the process has served. Otherwise informations are related to</div><div class="line">; the current request being served.</div><div class="line">; Example output:</div><div class="line">;   ************************</div><div class="line">;   pid:                  31330</div><div class="line">;   state:                Running</div><div class="line">;   start time:           01/Jul/2011:17:53:49 +0200</div><div class="line">;   start since:          63087</div><div class="line">;   requests:             12808</div><div class="line">;   request duration:     1250261</div><div class="line">;   request method:       GET</div><div class="line">;   request URI:          /test_mem.php?N=10000</div><div class="line">;   content length:       0</div><div class="line">;   user:                 -</div><div class="line">;   script:               /home/fat/web/docs/php/test_mem.php</div><div class="line">;   last request cpu:     0.00</div><div class="line">;   last request memory:  0</div><div class="line">;</div><div class="line">; Note: There is a real-time FPM status monitoring sample web page available</div><div class="line">;       It<span class="string">'s available in: @EXPANDED_DATADIR@/fpm/status.html</span></div><div class="line"><span class="string">;</span></div><div class="line"><span class="string">; Note: The value must start with a leading slash (/). The value can be</span></div><div class="line"><span class="string">;       anything, but it may not be a good idea to use the .php extension or it</span></div><div class="line"><span class="string">;       may conflict with a real PHP file.</span></div><div class="line"><span class="string">; Default Value: not set</span></div><div class="line"><span class="string">;pm.status_path = /status</span></div><div class="line"><span class="string">pm.status_path = /php-fpm_status</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">; The ping URI to call the monitoring page of FPM. If this value is not set, no</span></div><div class="line"><span class="string">; URI will be recognized as a ping page. This could be used to test from outside</span></div><div class="line"><span class="string">; that FPM is alive and responding, or to</span></div><div class="line"><span class="string">; - create a graph of FPM availability (rrd or such);</span></div><div class="line"><span class="string">; - remove a server from a group if it is not responding (load balancing);</span></div><div class="line"><span class="string">; - trigger alerts for the operating team (24/7).</span></div><div class="line"><span class="string">; Note: The value must start with a leading slash (/). The value can be</span></div><div class="line"><span class="string">;       anything, but it may not be a good idea to use the .php extension or it</span></div><div class="line"><span class="string">;       may conflict with a real PHP file.</span></div><div class="line"><span class="string">; Default Value: not set</span></div><div class="line"><span class="string">;ping.path = /ping</span></div><div class="line"><span class="string">ping.path = /php-fpm_ping</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">; This directive may be used to customize the response of a ping request. The</span></div><div class="line"><span class="string">; response is formatted as text/plain with a 200 response code.</span></div><div class="line"><span class="string">; Default Value: pong</span></div><div class="line"><span class="string">;ping.response = pong</span></div><div class="line"><span class="string">ping.response = 200</span></div></pre></td></tr></table></figure><p><br></p><p>效果图：</p><p><img src="/images/Zabbix/zabbix-master_php-fpm2.png" alt="将php-fpm状态展现在Nginx上"></p><p><br></p><p>展现的话是在Agent端的Nginx上，这个更直观一些。<br>而Zabbix-Server就是通过<code>curl -s zabbix.me</code>来获取数据的，并通过对数据的提取来返回给Zabbix-Server。<br>所以收集php-fpm，nginx的信息状态，都是基于这个页面的。</p><p>现在导入PHP-FPM模板，导入操作同MongoDB。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#就是这个文件</div><div class="line">zbx_export_templates.xml</div></pre></td></tr></table></figure><p>导入模板后，直接链接模板就可以啦。<br>然后就可以使用了。</p><p><br><br><br></p><h2 id="监控Nginx"><a href="#监控Nginx" class="headerlink" title="监控Nginx"></a>监控Nginx</h2><p>Zabbix是通过<code>stub_status</code>模块实现对Nginx的监控。<br>Nginx的ngx_http_stub_status_module模块提供了基本的Nginx状态信息，源码安装的话需要加上–with-http_stub_status_module编译参数，如果是epel源yum安装的话，已经默认启用该模块。</p><p>在Nginx配置文件中加入如下配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">location /nginx_status &#123;</div><div class="line">allow IP;</div><div class="line">deny all;</div><div class="line">stub_status on;</div><div class="line">    access_log off;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#栗子</span></div><div class="line">Active connections: 14</div><div class="line">server accepts handled requests</div><div class="line"> 22889 22889 72510</div><div class="line">Reading: 0 Writing: 2 Waiting: 12</div></pre></td></tr></table></figure><p><img src="/images/Zabbix/nginx_status.png" alt="nginx_status栗子"></p><p><br></p><p>以上数据是通过Web端查看。<br>但，我们需要把数据收集到Zabbix-Server。还需要使用之前下载同MongoDB，php-fpm一起的那个包。</p><p><strong>操作，基本还是类似MongoDB，php-fpm。只是个别参数需要修改一下。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">cd ./zabbix-master/nginx/</div><div class="line">cp ./nginx.sh /etc/zabbix/</div><div class="line">chmod a+x /etc/zabbix/nginx.sh</div><div class="line"></div><div class="line">cp ./userparameter_nginx.conf /etc/zabbix/zabbix_agentd.d</div><div class="line"></div><div class="line"></div><div class="line">vim /etc/zabbix/nginx.sh</div><div class="line"></div><div class="line">#HOST=&quot;localhost&quot;</div><div class="line">PORT=&quot;80&quot;</div><div class="line">#stub_status=stub_status</div><div class="line">stub_status=nginx_status</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">vim /etc/zabbix/zabbix_agentd.d/userparameter_nginx.conf</div><div class="line"></div><div class="line">#修改成脚本对应的位置</div><div class="line">UserParameter=nginx.status[*],/etc/zabbix/nginx.sh $1</div></pre></td></tr></table></figure><p>现在想以前一样导入模板。<br>然后在链接模板就可以了。</p><p><br><br><br></p><h2 id="监控Redis"><a href="#监控Redis" class="headerlink" title="监控Redis"></a>监控Redis</h2><p>监控Redis，也是把包里面对应的文件复制过去就行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ./zabbix-master/redis</div><div class="line">cp ./userparameter_redis.conf /etc/zabbix/zabbix_agentd.d/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#如果redis设置有密码，请加上密码</span></div><div class="line"><span class="comment">#如果是不同的端口，请修改</span></div><div class="line">UserParameter=redis.local[*],redis-cli -h 127.0.0.1 -p 6379 info|grep <span class="variable">$1</span>|grep -v _human|cut -d : -f2</div><div class="line"><span class="comment">#UserParameter=redis.local[*],redis-cli -h 127.0.0.1 -p 6379 -a Password info|grep $1|grep -v _human|cut -d : -f2</span></div><div class="line">UserParameter=redis.status[*],redis-cli -h <span class="variable">$1</span> -p <span class="variable">$2</span> -a Password info|grep <span class="variable">$3</span>|grep -v _human|cut -d : -f2</div><div class="line">UserParameter=redis.proc,pidof redis-server | wc -l</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#重启服务</span></div><div class="line">systemctl restart redis</div></pre></td></tr></table></figure><p>导入模板，链接主机，OK。</p><p><br></p><hr><p><br></p><h1 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h1><p><br></p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU的性能状态信息：</p><table><thead><tr><th>简写</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td>us</td><td>user cpu tim</td><td>用户使用CPU时间</td></tr><tr><td>sy</td><td>system cpu time</td><td>系统使用CPU时间</td></tr><tr><td>id</td><td>idle cpu time</td><td>CPU的空闲时间</td></tr><tr><td>wa</td><td>io wait cpu time</td><td>CPU等待IO时间</td></tr><tr><td>ni</td><td>user nice cpu time</td><td>用nice调整进程优先级的CPU时间</td></tr><tr><td>st</td><td>steal time</td><td>虚拟机偷取的CPU时间比，被强制等待虚拟CPU的时间</td></tr><tr><td>si</td><td>softirq time</td><td>系统处理软件中断所花费的CPU时间</td></tr><tr><td>hi</td><td>hard time</td><td>系统硬中断所花费的CPU时间</td></tr><tr><td>interrupt</td><td>中断</td><td>被处理过的中断数</td></tr><tr><td>cs</td><td>Context switches</td><td>上下文切换</td></tr><tr><td>ql</td><td>processor queue length</td><td>队列长度</td></tr><tr><td>processor load</td><td>processor load</td><td>处理器负载，几核乘以几</td></tr></tbody></table><p><br></p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>当我们要监控并报警CPU使用率时，我们可以反过来用CPU空闲时间来定义</li><li>cpu idle tiem%  + cpu usage time% = 1</li><li>(CPU usage time% gt 80%) == (CPU idel time% lt 20%)</li><li>(CPU usage time% gt 90%) == (CPU idel time% &lt; 10%)</li><li>所以监控CPU使用率就可以监控CPU空闲时间，并依据这个报警</li></ul><p><br><br><br></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>Zabbix中自带的Linux OS模板提供了<code>Total memory</code>和<code>Available memory</code>选项，这两者直接用模板就可以了。<br>但没有提供内存使用率的选项，因此需要我们自定义。</p><ul><li>内存使用率 = 可用内存 / 总内存</li><li>ast(vm.memory.size[available])/last(vm.memory.size[total])</li></ul><h3 id="自定义内存使用率"><a href="#自定义内存使用率" class="headerlink" title="自定义内存使用率"></a>自定义内存使用率</h3><p>我们只需要在Linux OS模板下配置内存使用率，就可以一劳永逸。</p><ol><li>配置(Configuration)</li><li>模板(Templates)</li><li>OS Linux模板的监控项(Items)</li><li>创建监控项</li><li>监控项名称: Available memory percent</li><li>类型： 可计算的</li><li>键值： vm.memory.size[percent]</li><li>公式： 100*last(vm.memory.size[available])/last(vm.memory.size[total])</li><li>记得将其加入Memory应用集，这样便于查找和管理</li><li>可加入单位： %</li></ol><p><br></p><p><img src="/images/Zabbix/custom_memorypercent.png" alt="自定义可用内存率"></p><p><img src="/images/Zabbix/custom_memorypercent2.png" alt="自定义可用内存率"></p><p><img src="/images/Zabbix/custom_memorypercent3.png" alt="效果图"></p><p><img src="/images/Zabbix/custom_memorypercent4.png" alt="效果图"></p><p><br></p><h3 id="添加触发器"><a href="#添加触发器" class="headerlink" title="添加触发器"></a>添加触发器</h3><ol><li>配置</li><li>模板</li><li>OS Linux模板</li><li>触发器</li><li>创建触发器，当可用内存率在三分钟内的平均值小于20%时报警</li><li>名字：Available memory percent lt 20% on {HOST.NAME}</li><li>严重性：一般严重</li><li>表达式： {Template OS Linux:vm.memory.size[percent].avg(3)}&lt;20</li></ol><p><br></p><p><img src="/images/Zabbix/custom_memorypercent5.png" alt="自定义可用内存率报警"></p><p><img src="/images/Zabbix/custom_memorypercent6.png" alt="效果图"></p><p><br><br><br></p><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>由于Zabbix-Server自带的Linux OS模板中的filesystem的监控是一个自动发现规则，而在应用集中的filesystem是没有监控项的。所有对于磁盘的监控和触发要在自动发现规则中去定义。</p><p><br></p><p><img src="/images/Zabbix/custom_disk1.png" alt="监控项"></p><p><img src="/images/Zabbix/custom_disk2.png" alt="触发器"></p><p><img src="/images/Zabbix/custom_disk3.png" alt="触发器"></p><p><img src="/images/Zabbix/custom_disk4.png" alt="触发器"></p><p><br><br><br></p><h2 id="进程和端口"><a href="#进程和端口" class="headerlink" title="进程和端口"></a>进程和端口</h2><p>Zabbix-Server自带有检测进程和端口的键值对。</p><h3 id="检测进程数"><a href="#检测进程数" class="headerlink" title="检测进程数"></a>检测进程数</h3><p><code>proc.num[&lt;name&gt;,&lt;user&gt;,&lt;state&gt;,&lt;cmdline&gt;]</code></p><ul><li>name: 进程名；</li><li>user: 运行该进程的用户；</li><li>state:<ol><li>run</li><li>sleep</li><li>zomb</li></ol></li><li>cmdline: ps -ef的最后那项，如/usr/bin/mongod -f /etc/mongod.conf</li></ul><p>现在Zabbix-Server端测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#zabbix-get --host hostname --key proc.num[&lt;name&gt;,&lt;user&gt;,&lt;state&gt;,&lt;cmdline&gt;]</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#检测mongd进程数量</span></div><div class="line">zabbix-get --host 192.168.1.11 --key proc.num[mongod,,,]</div><div class="line"></div><div class="line"><span class="comment">#2，因为我开了两个mongd实例</span></div><div class="line"></div><div class="line"></div><div class="line">zabbix-get --host 192.168.1.11 --key proc.num[mongod,root,,]</div><div class="line"><span class="comment">#1，只有一个是以root运行的，有一个是以mongod运行的</span></div></pre></td></tr></table></figure><p><br></p><p>由于我们上面使用的MongoDB监控模板没有判断mongod进程存活与否的判断，此处我们在MongoDB模板中增加一个检查<code>mongod</code>进程的监控项，并创建对应的触发器。</p><p><img src="/images/MongoDB/checkmongod.png" alt=""></p><p><img src="/images/MongoDB/checkmongod2.png" alt=""></p><p><br></p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p><code>net.tcp.listen[port]</code>    检查 TCP 端口 是否处于侦听状态。返回 0 - 未侦听；1 - 正在侦听</p><p>此处我也用Mongod举例。我的两个mongod实例分别监听在27017,27018/tcp。</p><p><br></p><p>在Zabbix-Server端先测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#net.tcp.listen[port]</span></div><div class="line"></div><div class="line">zabbix-get --host 192.168.1.11 --key net.tcp.listen[27017]</div><div class="line"><span class="comment">#1</span></div><div class="line">zabbix-get --host 192.168.1.11 --key net.tcp.listen[27018]</div><div class="line"><span class="comment">#1</span></div></pre></td></tr></table></figure><p>在Web端创建监控项和触发器与上面类似。</p><p><br></p><hr><p><br></p><h1 id="用户自定义参数-user-parameter-1"><a href="#用户自定义参数-user-parameter-1" class="headerlink" title="用户自定义参数(user parameter)"></a>用户自定义参数(user parameter)</h1><p>我也是参考了上述大神的脚本，进行参考而来。</p><p>由于公司需要监控大量的Web页面和API接口的状态，并通过页面判断相关key-value的正确性，用以判断状态。此处可能由模拟登录等操作，Zabbix自带的Web监控不太够用，所以此处自定义用户参数来实现。</p><p>此处，我叫公司开发人员帮忙将全部接口以及Web页面内容都生成到一个json文件里，如 <a href="http://zhang21.cn/test.json" target="_blank" rel="noopener">http://zhang21.cn/test.json</a>。然后用<code>jq</code>命令解析json文件，里面key一一对应value，这样取值就很方便了。</p><p><br><br><br></p><h2 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h2><p>jq 是一款命令行下处理 JSON 数据的工具。真的很好用！</p><p>jq官网：<a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">https://stedolan.github.io/jq/</a><br>GitHub: <a href="https://github.com/stedolan/jq" target="_blank" rel="noopener">https://github.com/stedolan/jq</a></p><p><br></p><p><strong>安装jq</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y jq</div></pre></td></tr></table></figure><p><br></p><p><strong>使用jq</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">jq --<span class="built_in">help</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看所有键键值</span></div><div class="line">curl --silent http://zhang21.cn/test.json | jq .</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">###栗子</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"collapsectimes"</span>: 130,</div><div class="line">  <span class="string">"collapsectimes"</span>: 0,</div><div class="line">  <span class="string">"bootfailtimes"</span>: 23,</div><div class="line">  <span class="string">"failrate"</span>: 0.3623,</div><div class="line">  <span class="string">"bootrate"</span>: 0.3324,</div><div class="line">  <span class="string">"time"</span>: <span class="string">"2018-01-25 15:03:30"</span>,</div><div class="line">  <span class="string">"db_error"</span>: <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看某个键值</span></div><div class="line">curl --silent http://zhang21.cn/test.json | jq <span class="string">'.time'</span></div><div class="line">curl --silent http://zhang21.cn/test.json | jq <span class="string">'.bootrate'</span></div><div class="line"></div><div class="line"><span class="comment">###</span></div><div class="line">2018-01-25 15:03:30</div><div class="line">0.3324</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#查看某个不存在的值，会返回null</span></div><div class="line">curl --silent http://zhang21.cn/test.json | jq <span class="string">'.zhang'</span></div><div class="line"></div><div class="line"><span class="comment">###</span></div><div class="line">null</div></pre></td></tr></table></figure><p><img src="/images/Zabbix/jq01.png" alt=""></p><p><br></p><p><strong>json嵌套解析</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cat test.json | jq <span class="string">'.location.city'</span></div><div class="line"></div><div class="line"><span class="comment">###</span></div><div class="line"><span class="string">"Chengdu"</span></div></pre></td></tr></table></figure><p><br></p><p><strong>json解析数组</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cat test.json | jq <span class="string">'.array[1].name'</span></div><div class="line"></div><div class="line"><span class="comment">###</span></div><div class="line"><span class="string">"Zhang"</span></div></pre></td></tr></table></figure><p><br></p><p><strong>内建函数</strong></p><p>jq还有一些内建函数，如<code>key</code>,<code>hss</code>。</p><p>key用来获取json中的key元素：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">curl --silent http://zhang21.cn/test.json | jq <span class="string">'keys'</span></div><div class="line"></div><div class="line"><span class="comment">###</span></div><div class="line">[</div><div class="line">collapsectimes,</div><div class="line">collapsectimes,</div><div class="line">bootfailtimes,</div><div class="line">failrate,</div><div class="line">bootrate,</div><div class="line">time,</div><div class="line">db_error</div><div class="line">]</div></pre></td></tr></table></figure><p>has用来判断是否存在某个key:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl --silent http://zhang21.cn/test.json | jq <span class="string">'has("time")'</span></div><div class="line"></div><div class="line"><span class="comment">###</span></div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure><p><br></p><h3 id="jq的select语句"><a href="#jq的select语句" class="headerlink" title="jq的select语句"></a>jq的select语句</h3><p>使用select函数来完成jq的过滤操作。<br>jq的select语句太好了!</p><p>select 接受一个条件表达式作为参数。其输入可以是迭代器，或者和 map 函数配合使用来处理数组。当输入中的某个元素使 select 参数中的条件表达式结果为真时，则在结果中保留该元素，否则不保留该元素。</p><p>对json文件的值是数组的，根据数据里面的key在取值，厉害厉害。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">cat zhang.json</div><div class="line"></div><div class="line"><span class="string">"array"</span>: [</div><div class="line">&#123;</div><div class="line"><span class="string">"ip"</span>: <span class="string">"192.168.1.11"</span>,</div><div class="line"><span class="string">"loads"</span>: 1234</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line"><span class="string">"ip"</span>: <span class="string">"192.168.1.22"</span>,</div><div class="line">    <span class="string">"loads"</span>: 567</div><div class="line">&#125;</div><div class="line">]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">####栗子</span></div><div class="line">cat /etc/zabbix/zhang.json | jq <span class="string">".array[] | select(.ip == \"192.168.1.11\")"</span></div><div class="line">&#123;</div><div class="line"><span class="string">"ip"</span>: <span class="string">"192.168.1.11"</span>,</div><div class="line"><span class="string">"loads"</span>: 1234</div><div class="line">&#125;</div><div class="line"></div><div class="line">cat /etc/zabbix/zhang.json | jq <span class="string">".array[] | select(.ip == \"192.168.1.11\").loads"</span></div><div class="line">1234</div><div class="line"></div><div class="line">我们在自定义用户参数的时候便可以将ip作为参数传入</div><div class="line">cat /etc/zabbix/zhang.json | jq <span class="string">".array[] | select(.ip == \"<span class="variable">$1</span>\").loads"</span></div></pre></td></tr></table></figure><p><br><br><br></p><h2 id="编写自定义参数和脚本"><a href="#编写自定义参数和脚本" class="headerlink" title="编写自定义参数和脚本"></a>编写自定义参数和脚本</h2><p>将脚本放置于<code>/etc/zabbix</code>，可将自定义参数写入zabbix-agentd.conf文件，也可单独写入<code>/etc/zabbix/zabbix_agentd.d/</code>(推荐)，这样修改更方便。</p><p><br></p><h3 id="编写脚本文件"><a href="#编写脚本文件" class="headerlink" title="编写脚本文件"></a>编写脚本文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /etc/zabbix</div><div class="line"></div><div class="line">vim xbreport.sh</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##########</span></div><div class="line"></div><div class="line"><span class="comment"># Zabbix3.4</span></div><div class="line"><span class="comment"># Zhang21</span></div><div class="line"><span class="comment"># Thu Jan 25 15:20:44 CST 2018</span></div><div class="line"></div><div class="line"><span class="comment">###########</span></div><div class="line"></div><div class="line">url=<span class="string">"http://zhang21.cn/test.json"</span></div><div class="line"></div><div class="line">JQ=`<span class="built_in">which</span> jq`</div><div class="line">CURL=`<span class="built_in">which</span> curl`</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">XBREPORT</span></span>() &#123;</div><div class="line">        <span class="variable">$CURL</span> --silent <span class="variable">$url</span> | <span class="variable">$JQ</span> <span class="string">".<span class="variable">$1</span>"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> == 0 ]; <span class="keyword">then</span></div><div class="line">        <span class="built_in">echo</span> $<span class="string">"Usage <span class="variable">$0</span> &#123;browsercollapsectimes|servercollapsectimes|xiaobaibootfailtimes|terminaldesktopfailrate|competebootrate|db_error&#125;"</span></div><div class="line">        <span class="built_in">exit</span></div><div class="line"><span class="keyword">else</span></div><div class="line">        XBREPORT <span class="string">"<span class="variable">$1</span>"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure><p><img src="/images/Zabbix/jq02.png" alt=""></p><p><br></p><h3 id="编写自定义参数文件"><a href="#编写自定义参数文件" class="headerlink" title="编写自定义参数文件"></a>编写自定义参数文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /etc/zabbix/zabbix_agentd.d</div><div class="line"></div><div class="line">vim userparameter_XBreport.conf</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">##########</span></div><div class="line"><span class="comment"># Zabbix3.4</span></div><div class="line"><span class="comment"># Zhang21</span></div><div class="line"><span class="comment"># Thu Jan 25 15:45:19 CST 2018</span></div><div class="line"><span class="comment">##########</span></div><div class="line"></div><div class="line">UserParameter=XBreport[*],/etc/zabbix/xbreport.sh <span class="variable">$1</span></div></pre></td></tr></table></figure><p><img src="/images/Zabbix/jq03.jpg" alt=""></p><p><br></p><h3 id="测试自定义参数"><a href="#测试自定义参数" class="headerlink" title="测试自定义参数"></a>测试自定义参数</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">zabbix_get --host host --key XBreport[time]</div><div class="line"></div><div class="line"><span class="comment">###</span></div><div class="line"><span class="string">"2018-01-25 17:03:18"</span></div></pre></td></tr></table></figure><p><br></p><h3 id="自定义用户参数额外"><a href="#自定义用户参数额外" class="headerlink" title="自定义用户参数额外"></a>自定义用户参数额外</h3><p>由于我的json文件key对应的value中内嵌有数组，所以我需要再提取数组内的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">curl http://zhang21.cn/test.json | jq &apos;.array&apos;</div><div class="line"></div><div class="line"></div><div class="line">###</div><div class="line">[</div><div class="line">  &#123;</div><div class="line">    &quot;ip&quot;: &quot;1.1.1.1&quot;,</div><div class="line">    &quot;loads&quot;: 1051</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    &quot;ip&quot;: &quot;2.2.2.2&quot;,</div><div class="line">    &quot;loads&quot;: 356</div><div class="line">  &#125;</div><div class="line">]</div><div class="line"></div><div class="line"></div><div class="line">#array[],array[1],array[2],array[n]</div><div class="line">#array[].ip, array[1].ip</div><div class="line">#array[].loads, array[2].loads</div></pre></td></tr></table></figure><p>上面的数据中包含有zabbix无法解析的特殊符号，所以需要改变策略。</p><p><br></p><p>由于zabbix对UserParameter中包含<strong>\’”`*?[]{}~$?&amp;;()&lt;&gt;|#@</strong>这些特殊字符无法进行处理，此处有两种方法来解决。</p><ol><li>在<code>zabbix_agentd.conf</code>中开启参数<code>UnsafeUserParameters</code>，将其值设置为1</li><li>或者，使用多个变量<code>$1 $2 $3...</code>来解决我这个数组值的问题</li></ol><p><br></p><p>我是使用多个变量来解决我这个情况的。<br>看下脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">cd /etc/zabbix</div><div class="line"></div><div class="line">vim ./zhang.sh</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">url=&apos;http://www.zhang21.cn/test.json&apos;</div><div class="line">JQ=`which jq`</div><div class="line">CURL=`which curl`</div><div class="line"></div><div class="line">function ZHANG() &#123;</div><div class="line">        $CURL --silent $url | $JQ &quot;.$1&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if [ $# == 0 ]; then</div><div class="line">        echo $&quot;Usage $0 &#123;aaa|bbb|ccc|...&#125;&quot;</div><div class="line">        exit</div><div class="line">elif [ $# ==1 ]; then</div><div class="line">ZHANG &quot;$1&quot;</div><div class="line">elif [ $# == 2 ]; then</div><div class="line">        ZHANG &quot;$1[$2]&quot;</div><div class="line">else</div><div class="line">        ZHANG &quot;$1[$2].$3&quot;</div><div class="line">fi</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">cd /etc/zabbix/zabbix_agentd.d/userparameter_Zhang.conf</div><div class="line"></div><div class="line">UserParameter=Zhangxx[*],/etc/zabbix/zhang.sh $1 $2 $3</div></pre></td></tr></table></figure><p>测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">systemctl restart zabbix-agentd</div><div class="line"></div><div class="line">zabbix_get --host host --key Zhangxx[array]</div><div class="line">zabbix_get --host host --key Zhangxx[array,0]</div><div class="line">zabbix_get --host host --key Zhangxx[array,0,loads]</div><div class="line">zabbix_get --host host --key Zhangxx[array,1,ip]</div></pre></td></tr></table></figure><p><br></p><p>测试正确能取到值的话，在Web端设置相对应的监控项。注意自己定义的<code>key</code>不要写错了。</p><p>数组的<code>key</code>栗子：</p><ul><li>Zhangxx[array]</li><li>Zhangxx[array,0]或Zhangxx[array,1]</li><li>Zhangxx[array,0,ip], Zhangxx[array,0,loads]</li></ul><p><br></p><h3 id="在Web端添加监控项"><a href="#在Web端添加监控项" class="headerlink" title="在Web端添加监控项"></a>在Web端添加监控项</h3><p>由于这个参数是我们自定义的，所以在填写监控项key的时候需要我们手动填写自己定义的参数。<br>注意监控项的参数和信息类型。</p><p><img src="/images/Zabbix/userparameter.png" alt=""></p><p><img src="/images/Zabbix/userparameter02.png" alt=""></p><p><img src="/images/Zabbix/userparameter03.png" alt=""></p><p><br></p><p>这里我遇到一个问题，我自定义key的执行脚本在Web端报超时问题，无法取值。这是由于zabbix默认的脚本执行超时时间为3s，所以我们需要修改超时时间30s(最大值)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vim /etc/zabbix/zabbix_server.conf</div><div class="line">vim /etc/zabbix/zabbix_agentd.conf</div></pre></td></tr></table></figure><p><br></p><h3 id="设置触发器和报警"><a href="#设置触发器和报警" class="headerlink" title="设置触发器和报警"></a>设置触发器和报警</h3><p>这个就根据你个人项目实际情况设置对于的触发器和报警。</p><p><br></p><hr><p><br></p><h1 id="短信报警"><a href="#短信报警" class="headerlink" title="短信报警"></a>短信报警</h1><h2 id="腾讯短信服务"><a href="#腾讯短信服务" class="headerlink" title="腾讯短信服务"></a>腾讯短信服务</h2><p>由于公司使用的是腾讯企业邮箱，可以将邮箱直接与微信绑定，从而在微信中实时显示邮件消息，所以不用微信报警！</p><p>此处使用的腾讯短信SMS服务： <a href="https://cloud.tencent.com/product/sms" target="_blank" rel="noopener">https://cloud.tencent.com/product/sms</a></p><ul><li>短信文档： <a href="https://cloud.tencent.com/document/product/382/13445" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/382/13445</a></li><li>API文档： <a href="https://cloud.tencent.com/document/product/382/13297" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/382/13297</a></li><li>SDK文档： <a href="https://cloud.tencent.com/document/product/382/5804" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/382/5804</a></li><li>Python SDK: <a href="https://cloud.tencent.com/document/product/382/11672" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/382/11672</a></li></ul><p>由于腾讯提供了程序SDK，所以我选择了linux自带的Python SDK。<br>这里面有详细的Python使用方法，做一些小修改就可以使用了。</p><p><img src="/images/Zabbix/SDK.png" alt=""></p><p><br><br><br></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="获取Python-SDK"><a href="#获取Python-SDK" class="headerlink" title="获取Python SDK"></a>获取Python SDK</h3><p>获取Python SDK</p><p><br></p><h3 id="申请SDK-AppID和App-Key"><a href="#申请SDK-AppID和App-Key" class="headerlink" title="申请SDK AppID和App Key"></a>申请SDK AppID和App Key</h3><p>申请SDK AppID以及APP Key。</p><p>申请完毕后，效果如下：</p><p><img src="/images/Zabbix/SDK02.png" alt=""></p><p><br></p><h3 id="申请短信签名"><a href="#申请短信签名" class="headerlink" title="申请短信签名"></a>申请短信签名</h3><p>下发短信必须携带短信签名。<br>短信签名需要上传公司证件进行认证，大概十分钟左右！</p><p>效果如下：</p><p><img src="/images/Zabbix/SDK03.png" alt=""></p><p><br></p><h3 id="申请短信模板"><a href="#申请短信模板" class="headerlink" title="申请短信模板"></a>申请短信模板</h3><p>下发短信内容必须经过审核。<br>在此短信模板中，我们必须要定义相关变量<code>{n}</code>，其他都是不会变化的常量。此处我定义了五个变量，分别为了带入Zabbix中的宏：</p><ul><li>问题名，{TRIGGER.NAME}</li><li>主机名，{HOST.NAME}</li><li>事件事件，{EVENT.TIME}</li><li>事件日期，{EVENT.DATE}</li><li>URL，{TRIGGER.URL}</li></ul><p><img src="/images/Zabbix/SDK04.png" alt=""></p><p><br></p><h3 id="SDK配置"><a href="#SDK配置" class="headerlink" title="SDK配置"></a>SDK配置</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">yum install -y eple-realse</div><div class="line">yum install -y python-pip</div><div class="line"></div><div class="line">pip install qcloudsms</div></pre></td></tr></table></figure><p><br></p><h3 id="Python代码配置"><a href="#Python代码配置" class="headerlink" title="Python代码配置"></a>Python代码配置</h3><p>腾讯文档：<a href="https://cloud.tencent.com/document/product/382/11672" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/382/11672</a></p><p>由于我是向多人发送短信，所以做了小修改：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#zabbix-server</span></div><div class="line">cd /usr/lib/zabbis/alartscripts</div><div class="line"></div><div class="line"></div><div class="line">vim sendSms.py</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#!/bin/python</span></div><div class="line"><span class="comment">#coding: utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> qcloudsms_py <span class="keyword">import</span> SmsSingleSender</div><div class="line"><span class="keyword">from</span> qcloudsms_py.httpclient <span class="keyword">import</span> HTTPError</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"></div><div class="line">appid = App ID</div><div class="line">appkey = App Key</div><div class="line">phone_numbers = [<span class="string">"12345"</span>, <span class="string">"1234567"</span>]</div><div class="line"><span class="comment">#params = ["Problem", "Hostname", "Time", "Date","Url"]</span></div><div class="line">params = [sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>], sys.argv[<span class="number">4</span>], sys.argv[<span class="number">5</span>]]</div><div class="line"></div><div class="line"></div><div class="line">msender = SmsSingleSender(appid, appkey)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> phone_numbers:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        result = msender.send_with_param(<span class="number">86</span>, i, 短信内容模板ID, params)</div><div class="line">    <span class="keyword">except</span> HTTPError <span class="keyword">as</span> e:</div><div class="line">        print(e)</div><div class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">        print(e)</div><div class="line">    print(result)</div></pre></td></tr></table></figure><p>要给sendSms.py加上可执行权限哈！<code>chmod a+x ./sendSms.py</code>。</p><p><br></p><p><code>sys.argv</code>变量是一个字符串的列表。特别地，<code>sys.argv</code>包含了命令行参数 的列表，即使用命令行传递给你的程序的参数。<br>使用Python的<code>sys.argv[n]</code>可以像shell一样将放在文件后的变量传入文件执行。此处对于在Zabbix-Web端将宏放在脚本后，作为变量传入，非常重要。</p><ul><li><code>sys.argv[0]</code>代表sendSms.py文件</li><li><code>sys.argv[1]</code>才代表第一个参数。</li></ul><p><img src="/images/Zabbix/SDK05.jpg" alt=""></p><p><br><br><br></p><h2 id="Zabbix-Web端配置"><a href="#Zabbix-Web端配置" class="headerlink" title="Zabbix Web端配置"></a>Zabbix Web端配置</h2><p>配置-动作-创建动作-操作</p><p>注意事项：</p><ul><li>建议针对触发器示警度最高就行短信报警，其它交给Email</li><li>操作类型，选择远程命令</li><li>目标列表，选择当前主机</li><li>类型，自定义脚本</li><li>执行在，这个一定是放在Zabbix-Server上来执行哈</li><li>命令，文件名SendSms.py后面接的宏一定要加上<strong>双引号(“”)</strong></li></ul><p><img src="/images/Zabbix/SDK06.png" alt=""></p><p><img src="/images/Zabbix/SDK07.png" alt=""></p><p>最后根据不同的内容，设置不同的报警机制。后台的脚本也修改为对应的名称，修改里面对应的手机号码。</p><ul><li>首先根据不同报警设置不同的触发条件</li><li>运维组，SendSms_dev.py，修改运维对应的号码</li><li>开发组，SendSms_develop.py，修改对于的号码</li></ul><p><br></p><p>其实这个发送短信，就是在执行远程命令。</p><p>你命令里是发送短信就发送短信，你命令里是发送邮件就发送邮件。这个还是挺不错的。</p><p><br></p><hr><p><br></p><h1 id="针对不同业务向不同人员报警"><a href="#针对不同业务向不同人员报警" class="headerlink" title="针对不同业务向不同人员报警"></a>针对不同业务向不同人员报警</h1><p>有时候我们只需要关心我们自己那部分就可以了，没必要所有报警都发送给所有人，这样很不方便。</p><p>所以，我们可以根据业务相关，组别权限等，分别向不同的人报警不同的信息。</p><p>如下我的一个栗子图：</p><p><img src="/images/Zabbix/action.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Zabbix简介&quot;&gt;&lt;a href=&quot;#Zabbix简介&quot; class=&quot;headerlink&quot; title=&quot;Zabbix简介&quot;&gt;&lt;/a&gt;Zabbix简介&lt;/h1&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zabbix.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Zabbix官方网站&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zabbix.com/documentation/3.4/zh/manual/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Zabbix中文文档&lt;/a&gt;&lt;br&gt;Zabbix-repo仓库: &lt;a href=&quot;http://repo.zabbix.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://repo.zabbix.com&lt;/a&gt; , 阿里云镜像: &lt;a href=&quot;https://mirrors.aliyun.com/zabbix/zabbix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mirrors.aliyun.com/zabbix/zabbix/&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;p&gt;CentOS7x86_64, Zabbix 3.4。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://zhang21.github.io/categories/Linux/"/>
    
    
      <category term="Zabbix" scheme="https://zhang21.github.io/tags/Zabbix/"/>
    
  </entry>
  
</feed>
