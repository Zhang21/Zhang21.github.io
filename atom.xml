<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风继续吹</title>
  
  <subtitle>Yesterday, you said tomorrow!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhang21.github.io/"/>
  <updated>2020-08-25T11:50:18.404Z</updated>
  <id>https://zhang21.github.io/</id>
  
  <author>
    <name>Leslie Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go</title>
    <link href="https://zhang21.github.io/2020/07/22/Go/"/>
    <id>https://zhang21.github.io/2020/07/22/Go/</id>
    <published>2020-07-22T11:02:32.000Z</published>
    <updated>2020-08-25T11:50:18.404Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>github: <a href="https://github.com/golang/go" target="_blank" rel="noopener">https://github.com/golang/go</a></li><li>Docs: <a href="https://golang.org/doc/" target="_blank" rel="noopener">https://golang.org/doc/</a></li><li>awesome-go: <a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">https://github.com/avelino/awesome-go</a></li></ul><p><br></p><p>版本:</p><ul><li>go v1.14</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Go编程语言是一个开源项目，使开发人员更高效。</p><p>Go是传神，简洁，干净，高效的。它的并发机制(concurrency mechanisms)可充分利用多核和网络机器编写程序，它的新颖类型系统允许灵活和模块化结构。它是一个快速、静态类型、编译型语言，像一个动态类型、解释型语言。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下载对应平台的二进制包，解压，添加路径。</p><p><br></p><p>测试安装:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"hello, world\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 编译</span><br><span class="line">go build hello.go</span><br><span class="line"># 执行</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p><br></p><p>安装其它版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org/dl/go1.10.7</span><br><span class="line"></span><br><span class="line">go1.10.7 version</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p><br></p><h2 id="旅程"><a href="#旅程" class="headerlink" title="旅程"></a>旅程</h2><p>Tour: <a href="https://tour.go-zh.org/list" target="_blank" rel="noopener">https://tour.go-zh.org/list</a></p><p><br></p><p>交互式地分三部分介绍Go：</p><ul><li>基本语法和数据结构</li><li>方法和接口</li><li>并发原语(concurrency primitives)</li></ul><p>可在线上或本地开启旅程：</p><ul><li>线上: <a href="https://tour.golang.org/welcome/1" target="_blank" rel="noopener">https://tour.golang.org/welcome/1</a></li><li>本地: <code>go get golang.org/x/tour</code>，会在go path的<code>bin/tour</code>。</li></ul><p><br></p><p><code>sandbox.go</code>测试程序显示时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Welcomt to the playground!"</span>)</span><br><span class="line">  fmt.Println(<span class="string">"The time is"</span>, time.Now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>学习go程序的基本结构。</p><p><br></p><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>每个go程序都是由包构成。程序从<code>main</code>包开始运行。</p><p>按照约定，包名与导入路径的最后一个元素一致。例如，<code>math/rand</code>包中的源码均以<code>package rand</code>语句开始。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入两个包</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"My favorite number is"</span>, rand.Intn(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>使用圆括号进行分组导入，也可以编写多个导入语句。分组导入语句是更好的形式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分组导入</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="导出名"><a href="#导出名" class="headerlink" title="导出名"></a>导出名</h4><p>在Go中，如果一个名字以大写字母，那么它就是已导出的。</p><p>在导入一个包时，你只能引用其中已导出的名字。任何未导出的名字在该包外均无法访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exporter-nams.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(math.pi)</span><br><span class="line">    <span class="comment">//fmt.Println(math.Pi)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行math.pi会报错</span><br><span class="line">./prog.go:9:14: cannot refer to unexported name math.pi</span><br><span class="line">./prog.go:9:14: undefined: math.pi</span><br><span class="line"></span><br><span class="line">运行math.Pi</span><br><span class="line">3.141592653589793</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数可以没有参数或接受多个参数。注意类型在变量名之后。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functions.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略模式: x, y int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(add(<span class="number">42</span>, <span class="number">13</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="多值返回"><a href="#多值返回" class="headerlink" title="多值返回"></a>多值返回</h4><p>函数可以返回任意数量的返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiple-results.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := swap(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h4><p>go的返回值可被命名，它们会被视作定义在函数顶部的变量。返回值的名称应当具有一定的意义。</p><p>没有参数的<code>return</code>语句返回已命名的返回值，也就是<strong>直接</strong>返回。直接返回语句应当仅在短函数中，在长函数中会影响代码的可读性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name-result.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum -x</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(split(<span class="number">17</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><code>var</code>语句用于声明一个变量列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// variables.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    fmt.Println(i, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><p>变量声明可以包含初始值。<br>如果初始化值已存在，则可以省略类型，变量会从初始值中获得类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var-ini.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">impoort <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i, j, <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"no!"</span></span><br><span class="line">    fmt.Println(i, j, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数中，简洁赋值语句<code>:=</code>可在类型明确的地方代替<code>var</code>声明。</p><p>函数外的每个语句都必须以关键字(var, func…)开始，因此<code>:=</code>结构不能在函数外使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// short-var-declarations.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i, j <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    k := <span class="number">3</span></span><br><span class="line">    c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"no!"</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(i, j, k, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>go的基本类型有：</p><ul><li>bool</li><li>string</li><li>int, int8, int16, int32, int64</li><li>unit, uint8, uint16, uint32, uint64, uintptr</li><li>byte(unit8的别名)</li><li>rune(int32的别名，表示一个unicode码点)</li><li>float32, float64</li><li>complex64, complex128</li></ul><p>int, uint 和 uintptr 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 int 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basic-types.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/cmplx"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ToBe <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line">    MaxInt <span class="keyword">uint64</span> = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">    x <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> ++ <span class="number">12i</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Type: %T Value: %v\n"</span>, ToBe, ToBe)</span><br><span class="line">    fmt.Printf(<span class="string">"Type: %T Value: %v\n"</span>, MaxInt, MaxInt)</span><br><span class="line">    fmt.Printf(<span class="string">"Type: %T Value: %v"</span>, z, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h4><p>没有明确初始值的变量声明会被赋予它们的<strong>零值</strong>。</p><p>零值是:</p><ul><li>数值类型为 <code>0</code></li><li>布尔类型为 <code>false</code></li><li>字符串为空字符串</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zero.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> f <span class="keyword">float64</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v %v %v %q\n"</span>, i, f, b, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><code>T(v)</code>将v转换为T类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type-conversions.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x, y <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">    <span class="keyword">var</span> f <span class="keyword">float64</span> = math.Sqrt(<span class="keyword">float64</span>(x*x + y*y))</span><br><span class="line">    <span class="keyword">var</span> z unit = unit(f)</span><br><span class="line">    fmt.Println(x, y, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>在声明一个变量而不指定其类型时，变量的类型由右值推导而出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type-inference.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := <span class="number">42</span> <span class="comment">// int</span></span><br><span class="line">    fmt.Printf(<span class="string">"v is of type %T\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量的声明与变量类似，只不过使用<code>const</code>关键字。</p><p>常量可以是字符、字符串、布尔值、数值。</p><p>常量不能用<code>:=</code>语法声明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> World = <span class="string">"世界"</span></span><br><span class="line">    fmt.Println(<span class="string">"Hello"</span>, World)</span><br><span class="line">    fmt.Println(<span class="string">"Happy"</span>, Pi, <span class="string">"Day"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Truth = <span class="literal">true</span></span><br><span class="line">    fmt.Println(<span class="string">"Go rules?"</span> Truth)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h4><p>数值常量是高精度的<strong>值</strong>。一个未指定类型的常量由上下文来决定其类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nemeric-constants.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 将1左移100位来创建一个非常大的数字，即这个数的二进制是1后面跟着100个0</span></span><br><span class="line">    Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line">    <span class="comment">// 再往右移99位，即Small = 1 &lt;&lt; 1，或Small = 2</span></span><br><span class="line">    Small = Big &gt;&gt; <span class="number">99</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needInt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x*<span class="number">10</span> + <span class="number">1</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needFloat</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;<span class="keyword">return</span> x * <span class="number">0.1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(needInt(Small))</span><br><span class="line">    fmt.Println(needFloat(Small))</span><br><span class="line">    fmt.Println(needFloat(Big))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>flowcontrol: <a href="https://tour.go-zh.org/flowcontrol" target="_blank" rel="noopener">https://tour.go-zh.org/flowcontrol</a></p><p>学习如何使用条件、循环、分支和推迟语句来控制代码的流程。</p><p><br></p><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>go只有一种循环结构: <code>for</code>循环。它由三部分组成：</p><ul><li>初始化语句： 在第一次迭代前执行</li><li>条件表达式：在每次迭代前求值</li><li>后置语句： 在每次迭代的结尾执行</li></ul><p>初始化语句和后置语句是可选的。</p><p>初始化语句通常为一句短变量声明，该变量声明仅在for语句的作用域中可见。一旦条件表达式的布尔值为false，循环迭代就会终止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        sum += i</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for-continued.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sum := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">        sum += sum</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="for是while"><a href="#for是while" class="headerlink" title="for是while"></a>for是while</h4><p>go的for就是while。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for-is-while.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sum := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">        sum += sum</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>如果省略循环条件，该循环就不会结束，因此无限循环可以写的很紧凑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forever.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(-x) + <span class="string">"i"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(sqrt(<span class="number">2</span>), sqrt(<span class="number">-4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="简短的if"><a href="#简短的if" class="headerlink" title="简短的if"></a>简短的if</h4><p>if语句可在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在if之内。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if-short.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(</span><br><span class="line">        pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">        pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="else"><a href="#else" class="headerlink" title="else"></a>else</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// else.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%g &gt;= %g\n"</span>, v, lim)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(</span><br><span class="line">        pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">        pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>switch是一连串的if-else语句的简单写法。它运行第一个值等于条件表达式的case语句。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">"Go runs on "</span>)</span><br><span class="line">    <span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Linux."</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%s. \n"</span>, os)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>switch的case语句从上到下依次执行，知道匹配成功时停止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch-order.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"When's Saturday?"</span>)</span><br><span class="line">    today := time.NOw().Weekday()</span><br><span class="line">    <span class="keyword">switch</span> time.Saturday &#123;</span><br><span class="line">    <span class="keyword">case</span> today + <span class="number">0</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Today."</span>)</span><br><span class="line">    <span class="keyword">case</span> today + <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Tomorrow."</span>)</span><br><span class="line">    <span class="keyword">case</span> today + <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">"In two days."</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Too far away."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>没有条件的switch同<code>switch true</code>一样。这种形式能将一长串if-then-else写得更加清晰。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch-no-condition.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := Now()</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">        fmt.Pringln(<span class="string">"Good morning!"</span>)</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Good afternoon."</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Good evening."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>defer语句会将函数推迟到外层函数返回之后执行。</p><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defer.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Pringln(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照<strong>后进先出</strong>的顺序调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defer-multi.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Pringln(<span class="string">"counting"</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Pringln(i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="更多类型"><a href="#更多类型" class="headerlink" title="更多类型"></a>更多类型</h3><p>学习如何基于现有类型定义新的类型，包含结构体、数组、切片和映射。</p><p><br></p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>go拥有指针。指针保存了值的内存地址。类型<code>*T</code>是指向T类型值的指针。其零值位nil。<code>&amp;</code>操作符会生成一个指向其操作数的指针。<code>*</code>操作符表示指针指向的底层值。这也就是常说的间接引用和重定向。</p><p>与C不同，go没有指针运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pointers.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i, j := <span class="number">42</span>, <span class="number">2701</span></span><br><span class="line"></span><br><span class="line">    p := &amp;i <span class="comment">// 指向i</span></span><br><span class="line">    fmt.Pringln(*p) <span class="comment">// 通过指针读取i的值</span></span><br><span class="line">    *p = <span class="number">21</span> <span class="comment">// 通过指针设置i的值</span></span><br><span class="line">    fmt.Pringln(i)</span><br><span class="line"></span><br><span class="line">    p = &amp;j</span><br><span class="line">    *p = *p /<span class="number">37</span></span><br><span class="line">    fmt.Pringln(j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>一个结构体(struct)就是一组字段(field)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// structs.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>结构体字段使用点号来访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct-fields.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    v.X = <span class="number">4</span></span><br><span class="line">    fmt.Println(v.X)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>结构体字段可以通过结构体指针来访问。</p><p>如果有一个指向结构体的指针P，那么可通过<code>(*p).X</code>来访问其字段X。不过这样写太啰嗦，可隐式间接引用，直接写<code>p.X</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct-pointers.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    p :=  &amp;v <span class="comment">// 指针</span></span><br><span class="line">    p.X = <span class="number">1e9</span></span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>结构体文法通过直接列出字段的值来新分配一个结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct-literals.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个Vertex类型的结构体</span></span><br><span class="line">    v2 = Vertex&#123;X: <span class="number">1</span>&#125; <span class="comment">// Y:0被隐式地赋予</span></span><br><span class="line">    v3 = Vertex&#123;&#125; <span class="comment">// X:0 Y:0</span></span><br><span class="line">    p = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个*Vertex类型的结构体(指针)</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(v1, p, v2, v3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>类型<code>[n]T</code>表示拥有n个T类型的值的数组。</p><p>数组的长度是其类型的一部分，因此数组不能改变大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">    a[<span class="number">0</span>] = “Hello<span class="string">"</span></span><br><span class="line"><span class="string">    a[1] = "</span>World<span class="string">"</span></span><br><span class="line"><span class="string">    fmt.Pringln(a[0], a[1])</span></span><br><span class="line"><span class="string">    fmt.Println(a)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125;</span></span><br><span class="line"><span class="string">    fmt.Println(primes)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>每个数组大小都是固定的，而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p><p>类型<code>[]T</code>表示一个元素类型为T的切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slices.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片并不存储任何数据，它只是描述了底层数组中的一段。更改切片的元素会修改其底层数组中对应的元素。与它共享底层数组的切片都会观测到这些修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slices-pointers.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    names := [<span class="number">4</span>]<span class="keyword">string</span>&#123;<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="string">"George"</span>, <span class="string">"Ringo"</span>,&#125;</span><br><span class="line">    fmt.Println(names)</span><br><span class="line"></span><br><span class="line">    a := names[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    b := names[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Pringln(a, b)</span><br><span class="line"></span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">"XXX"</span></span><br><span class="line">    fmt.Pringln(a, b)</span><br><span class="line">    fmt.Pringln(names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>切片文法类似于没有长度的数组文法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slice-literals.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125; <span class="comment">// 创建一个数组，并构建一个引用数组的切片</span></span><br><span class="line">    fmt.Pringln(q)</span><br><span class="line"></span><br><span class="line">    r := []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>&#125;</span><br><span class="line">    fmt.Pringln(r)</span><br><span class="line"></span><br><span class="line">    s := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        i <span class="keyword">int</span></span><br><span class="line">        b <span class="keyword">bool</span></span><br><span class="line">    &#125; &#123;</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">        &#123;<span class="number">11</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">        &#123;<span class="number">13</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Pringln(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p><p>切片拥有长度和容量。切片的长度就是它所包含的元素个数。切片的容量从第一个元素开始数，到元素末尾的个数。</p><p>可通过<code>len()</code>和<code>cap()</code>来获取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slice-len-cap.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取切片使其长度为0</span></span><br><span class="line">    s = s[:<span class="number">0</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展长度</span></span><br><span class="line">    s = s[:<span class="number">4</span>]</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 舍弃前两个值</span></span><br><span class="line">    s = s[<span class="number">2</span>:]</span><br><span class="line">    printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"len=%d cap=%d %v\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>切片的零值<code>nil</code>。nil切片的长度和容量为0且没有底层数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nil-slices.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Pringln(<span class="string">"nil!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>切片可以使用内建函数<code>make</code>来创建，这也是创建动态数组的方式。<code>make</code>函数会分配一个元素为零值的数组并返回一个引用了它的切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// making-slices.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    PrintSlice(<span class="string">"a"</span>, a)</span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    printSlice(<span class="string">"b"</span>, b)</span><br><span class="line"></span><br><span class="line">    c := b[:<span class="number">2</span>]</span><br><span class="line">    printSlice(<span class="string">"c"</span>, c)</span><br><span class="line"></span><br><span class="line">    d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">    printSlice(<span class="string">"d"</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="keyword">string</span>, x []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s lend=%d cap=%d %v\n"</span>,</span><br><span class="line">        s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>切片可包含任何类型，甚至包括其他切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slices-of-slices.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"STRINGS"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个井字板</span></span><br><span class="line">    board := [][]<span class="keyword">string</span>&#123;</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>, <span class="string">"_"</span>&#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>, <span class="string">"_"</span>&#125;,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"_"</span>, <span class="string">"_"</span>, <span class="string">"_"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个玩家轮流打上 x和o</span></span><br><span class="line">    board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">"X"</span></span><br><span class="line">    board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">"O"</span></span><br><span class="line">    board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line">    board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">"O"</span></span><br><span class="line">    board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(board); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, strings.Join(board[i], <span class="string">" "</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>向切片追加新的元素是常用的操作，为此go提供了内建的<code>append</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个空切片</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">    printSlice(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性添加多个元素</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"len=%d cap=%d %v\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>for循环的range形式可以遍历切片或映射。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 下标，元素副本</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"2**%d = %d\n"</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>可将下标或值赋予下划线(<code>_</code>)来忽略它。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pow</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> pow</span><br><span class="line"></span><br><span class="line"># 若只要索引，忽略第二个变量即可</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range-continued.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pow := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        pow[i] = <span class="number">1</span> &lt;&lt; <span class="keyword">uint</span>(i) <span class="comment">// == 2**i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>映射将键映射到值。映射的零值为<code>nil</code>。nil映射既没有键，也不能添加键。<code>make</code>函数会返回给定类型的映射，并将其初始化备用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maps.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">    m[<span class="string">"Bell Labs"</span>] = Vertex&#123;</span><br><span class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(m[<span class="string">"Bell Labs"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>映射的文法与结构体类似，不过必须有键名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map-literals.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">"Bell Labs"</span>: Vertex&#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>,&#125;,</span><br><span class="line">    <span class="string">"Google"</span>: Vertex&#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>若顶级类型只有一个类型名，可以在文法的元素中省略它。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map-literals-continued.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">"Bell Labs"</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line">    <span class="string">"Google"</span>: &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>可对映射进行增删查改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 插入或修改</span><br><span class="line">m[key] = elem</span><br><span class="line"># 获取</span><br><span class="line">elem = m[key]</span><br><span class="line"># 删除</span><br><span class="line"><span class="built_in">delete</span>(m, key)</span><br><span class="line"></span><br><span class="line"># 通过双赋值检测某个键是否存在</span><br><span class="line">elem, ok = m[key]</span><br><span class="line"># 若 key 在 m 中，ok 为 <span class="literal">true</span> ；否则，ok 为 <span class="literal">false</span>。</span><br><span class="line"># 若 key 不在映射中，那么 elem 是该映射元素类型的零值。</span><br><span class="line"># 当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutating-maps.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    m[<span class="string">"Answer"</span>] = <span class="number">42</span></span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    m[<span class="string">"Answer"</span>] = <span class="number">48</span></span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">"Answer"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, m[<span class="string">"Answer"</span>])</span><br><span class="line"></span><br><span class="line">    v, ok := m[<span class="string">"Answer"</span>]</span><br><span class="line">    fmt.Println(<span class="string">"The value:"</span>, v, <span class="string">"Present?"</span>, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h4><p>函数也是值。它们可以像其它值一样传递。</p><p>函数值可以用作函数的参数或返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function-values.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(compute(hypot))</span><br><span class="line">    fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h4><p>go函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量绑定在一起。</p><p>例如，函数adder返回一个闭包。每个闭包都被绑定在其各自的sum变量上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functtion-closures.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        sum += x</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pos, neg := adder(), adder()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(</span><br><span class="line">            pos(i),</span><br><span class="line">            neg(<span class="number">-2</span>*i),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>斐波那契闭包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fibonacci-closure.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个int函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := fibonacci()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h3><p>docs: <a href="https://tour.go-zh.org/methods/1" target="_blank" rel="noopener">https://tour.go-zh.org/methods/1</a></p><p>包含方法和接口，可以用这种构造来定义对象及其行为。</p><p><br></p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>go没有类。</p><p>不过你可以为结构体类型定义方法。方法就是一类带特殊的接收者参数的函数。方法接收者在它自己的参数列表内，位于func关键字和方法名之间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methods.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Abs方法拥有一个名为v，类型为Vertex的接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>方法只是个带接收者参数的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// metheods-funcs.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y float</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>也可以为非结构体类型声明方法。接收者的类型定义和方法声明必须在同一包内，不能为内建类型声明方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methods-continued.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">    fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h4><p>可以为指针接收者声明方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methods-pointers.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v, Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    v.Scale(<span class="number">10</span>)</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methods-pointers-explained.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span><span class="params">(v *Vertex, f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    x.Y = x.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    Scale(&amp;v, <span class="number">10</span>)</span><br><span class="line">    fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="方法与指针重定向"><a href="#方法与指针重定向" class="headerlink" title="方法与指针重定向"></a>方法与指针重定向</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// indirection.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    x.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScaleFunc</span><span class="params">(v *Vertex, f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = V.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    v.Scale(<span class="number">2</span>)</span><br><span class="line">    ScaleFunc(&amp;v, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">    p.Scale(<span class="number">3</span>)</span><br><span class="line">    ScaleFunc(p, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(v, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// indirection-values.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AbsFunc</span><span class="params">(v Vertex)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(v.Abs())</span><br><span class="line">    fmt.Println(AbsFunc(v))</span><br><span class="line"></span><br><span class="line">    p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(p.Abs())</span><br><span class="line">    fmt.Println(AbsFunc(*p))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="选择值或指针作为接收者"><a href="#选择值或指针作为接收者" class="headerlink" title="选择值或指针作为接收者"></a>选择值或指针作为接收者</h4><p>使用指针接收者的原因有二：</p><ul><li>方法能够修改其接收者指向的值</li><li>可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// methods-pointer-receivers.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    v.X = v.X * f</span><br><span class="line">    v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Before scaling: %+v, Abs: %v\n"</span>, v, v.Abs())</span><br><span class="line">    v.Scale(<span class="number">5</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"After scaling: %+v, Abs: %v\n"</span>, v, v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口类型是由一组方法签名定义的集合。接口类型的变量可以保存任何实现了这些方法的值。</p><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有<code>implements</code>关键字。隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces-implicitly.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法表示类型T实现了接口I，但我们无需显式声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i I = T&#123;<span class="string">"Hello"</span>&#125;</span><br><span class="line">    i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>接口也是值。它们可以像其它值一样传递。接口值可以用作函数的参数或返回值。</p><p>在内部，接口值可以看做包含值和具体类型的元组：<code>(value, type)</code>。接口值保存了一个具体底层类型的具体值。接口值调用方法时会执行其底层类型的同名方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface-values.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line">    i = &amp;T[<span class="string">"Hello"</span>]</span><br><span class="line">    describe(i)</span><br><span class="line">    i.M()</span><br><span class="line"></span><br><span class="line">    i = F(math.Pi)</span><br><span class="line">    describe(i)</span><br><span class="line">    i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"(%v, %T)\n"</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>底层值为nil的接口值。</p><p>即便接口内的具体值为nil， 方法仍然会被nil接收者调用。注意，保存了nil具体值的接口其自身并不为nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface-values-nil.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    S tring</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"&lt;nil&gt;"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t *T</span><br><span class="line">    i = t</span><br><span class="line">    describe(i)</span><br><span class="line">    i.M()</span><br><span class="line"></span><br><span class="line">    i = &amp;T&#123;<span class="string">"hello"</span>&#125;</span><br><span class="line">    describe(i)</span><br><span class="line">    i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"(%v, %T)\n"</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="nil接口值"><a href="#nil接口值" class="headerlink" title="nil接口值"></a>nil接口值</h4><p>nil接口值既不保存值也不保存具体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nil-interface-values.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i I</span><br><span class="line">    describe(i)</span><br><span class="line">    i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"(%v, %T)\n"</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p>指定了零个方法的接口值被称为<strong>空接口</strong>: <code>interface{}</code></p><p>空接口可保存任何类型的值，因为每个类型都至少实现了零个方法。空接口被用来处理未知类型的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// empty-interface.go</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var i interface&#123;&#125;</span><br><span class="line">    describe(i)</span><br><span class="line"></span><br><span class="line">    i = 42</span><br><span class="line">    describe(i)</span><br><span class="line"></span><br><span class="line">    i = &quot;hello&quot;</span><br><span class="line">    describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func describe(i interface&#123;&#125;) &#123;</span><br><span class="line">    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>类型断言提供了访问接口值底层具体值的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 该语句断言接口值i保存了具体类型T，并将其底层类型为T的值赋予变量t</span><br><span class="line">t := i.(T)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 类型断言可返回两个值</span><br><span class="line">// 底层值以及一个报告断言是否成功的布尔值</span><br><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type-assertions.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">    s := i.(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Pringln(s)</span><br><span class="line"></span><br><span class="line">    s, ok := i.(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">    f, ok := i.(<span class="keyword">float64</span>)</span><br><span class="line">    fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">    f = i.(<span class="keyword">float64</span>) <span class="comment">// 报错(panic)</span></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h4><p>类型选择是一种按顺序从几个类型断言中选择分支的结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type-switches.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Twice $v is %v\n"</span>, v, v*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%q is %v bytes long\n"</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"I don't how about type %T!\n"</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do(<span class="number">21</span>)</span><br><span class="line">    do(<span class="string">"hello"</span>)</span><br><span class="line">    do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h4><p><code>fmt</code>包中定义的<code>Stringer</code>是最普遍的接口之一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// stringer.go</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">    Age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p Person) String() string &#123;</span><br><span class="line">    return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a := Person&#123;&quot;Arthur Dent&quot;, 42&#125;</span><br><span class="line">    z := Person&#123;&quot;Zaphod Beeb12brox&quot;, 9001&#125;</span><br><span class="line">    fmt.Println(a, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>go程序使用<code>error</code>值来表示错误状态，它是一个内建接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// errors.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    When time.Time</span><br><span class="line">    What <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"at %v, %s"</span>,</span><br><span class="line">        e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">        time.Now(),</span><br><span class="line">        <span class="string">"it didn't work"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p><code>io</code>包指定了<code>io.Reader</code>接口，它表示从数据流的末尾进行读取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reader.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := strings.NewReader(<span class="string">"Hello, Reader!"</span>)</span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := r.Read(b)</span><br><span class="line">        fmt.Printf(<span class="string">"n = %v err = %v b = %v\n"</span>, n, err, b)</span><br><span class="line">        fmt.Printf(<span class="string">"b[:n] = %q\n"</span>, b[:n])</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><p><code>image</code>包定义了<code>Image</code>接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// images.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"image"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := image.NewRGBA(image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line">    fmt.Println(m.Bounds())</span><br><span class="line">    fmt.Println(m.At(<span class="number">0</span>, <span class="number">0</span>).RGBA())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>doc: <a href="https://tour.go-zh.org/concurrency/1" target="_blank" rel="noopener">https://tour.go-zh.org/concurrency/1</a></p><p>作为语言的核心部分，go提供了并发的特性。这一部分概览了goroutine和channel，以及如何使用它们来实现不同的并发模式。</p><p><br></p><h4 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h4><p>go程(goroutine)是由go运行时管理的轻量级线程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> f(x, y, z)</span><br><span class="line"># 会启动一个新的goroutine并执行</span><br><span class="line">f(x, y, z)</span><br><span class="line"># f, x, y, z的求值发生在goroutine中</span><br><span class="line"># 而f的执行发生在新的goroutine中</span><br></pre></td></tr></table></figure><p>goroutine在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goroutines.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">"world"</span>)</span><br><span class="line">    sqy(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h4><p>信道是带有类型的管道，通过它用信道操作符<code>&lt;-</code>来发送或接收值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信道在使用前必须创建</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头就是数据流的方向</span></span><br><span class="line">ch &lt;- v   <span class="comment">// 将v发送至信道ch</span></span><br><span class="line">v := &lt;-ch <span class="comment">// 从ch接收值并赋予v</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// channels.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- sum <span class="comment">// 将和送入c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c <span class="comment">// 从c中接收</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="带缓冲的信道"><a href="#带缓冲的信道" class="headerlink" title="带缓冲的信道"></a>带缓冲的信道</h4><p>将缓冲长度作为第二个参数提供给<code>make</code>来初始化一个带缓冲的信道，仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buffered-channels.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    <span class="comment">// ch &lt;- 3 填满缓冲区</span></span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p>发送者可通过<code>close</code>关闭一个信道来表示没有需要发送的值。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭。</p><p>只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌(panic)。信道与文件不同，通常情况下不需要关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个range循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若没有值可接收且信道已关闭，在执行完后,ok会被设置为false</span></span><br><span class="line">v, ok := &lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环for i := range c会不断从信道接收值，直到它关闭</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range-and-close.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x+y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select语句使一个go routine可以等待多个通信操作。<br>它会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">                x, y = y, x+y</span><br><span class="line">            <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">                fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>当select中的其它分支都没有转杯好时，default分支就会执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default-selection.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tick := time.Tick(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    boom := time.After(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tick:</span><br><span class="line">            fmt.Println(<span class="string">"tick."</span>)</span><br><span class="line">        <span class="keyword">case</span> &lt;-boom:</span><br><span class="line">            fmt.Println(<span class="string">"BOOM!"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"    ."</span>)</span><br><span class="line">            time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>信道非常适合在各个Go routine间进行通信。但如果并不需要通信，只想保证每次只有一个go routine能够访问一个共享的变量，从而避免冲突。</p><p>这里面涉及的概念就做<strong>互斥</strong>(mutual exclusion)，通常使用<strong>互斥锁</strong>(Mutex)这一数据结构来提供这种机制。go标准库提供了<code>sync.Mutex</code>互斥锁及其两个方法: <code>Lock</code>, <code>Unlock</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutex-counter.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter 的并发使用是安全的</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">    v <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 增加给定 key 的计数器的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Inc</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    <span class="comment">// Lock 之后同一时刻只有一个 go routine 能访问c.v</span></span><br><span class="line">    c.v[key]++</span><br><span class="line">    c.mux.Unlocak</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 返回给定key的计数器的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    c.mux.Lock()</span><br><span class="line">    <span class="comment">// Lock之后同一时刻只有一个 go routine 能访问c.v</span></span><br><span class="line">    <span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> c.Inc(<span class="string">"somekey"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(c.Value(<span class="string">"somekey"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="如何编写go代码"><a href="#如何编写go代码" class="headerlink" title="如何编写go代码"></a>如何编写go代码</h2><p>doc: <a href="https://golang.org/doc/code.html" target="_blank" rel="noopener">https://golang.org/doc/code.html</a></p><p><br></p><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>本文介绍如何开发一个模块内的一组简单的go包集合，并使用go工具，以标准的方式去fetch, build, install go modules, packages, commands。</p><blockquote><p>注意:<br><br>本文使用go <code>v1.13+</code>，并且没有设置<code>GO111MODULE</code>环境变量。</p></blockquote><p><br><br><br></p><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p>go程序被组织到包。包是编译在同一目录中的源文件的集合。定义在一个源文件中的函数、类型、变量、常量对同一个包中的其它源文件可见。</p><p>一个仓库(repo)包含一个或多个模块。模块是发布到一起关联go包的集合。一个go仓库通常只包含一个模块，位于该库的根目录。<code>go.mod</code>文件声明了模块路径，该模块内所有包的导入路径前缀。该模块包含了<code>go.mod</code>文件此目录及其子目录的包。</p><p>注意，在你可以构建之前，你并不需要将代码发布到远程仓库。一个模块可以定义在本地而不属于一个仓库。然而，如果你某天希望发布你的代码，那么组织你的代码是一个很好的习惯。</p><p>每个模块的路径不仅作为其包的导入路径前缀，也预示着go命令在哪里下载它。例如，要下载<code>golang.org/x/tools</code>模块，go命令会通过协商表示<code>https://golang.org/x/tools</code>。</p><p>导入路径是用来导入包的字符串。一个包的导入路径是它和模块内子目录的加入模块的路径。例如，模块<code>github.com/google/go-cmp</code>在<code>cmp/</code>目录下包含一个包，这个包的导入路径是<code>github.com/google/go-cmp/cmp</code>。标准库中的包没有模块路径前缀。</p><p><br><br><br></p><h3 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h3><p>要编译和运行一个简单的程序，首先要选择一个模块路径（如<code>example.com/user/hello</code>）并创建一个<code>go.mod</code>文件来声明它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">make hello</span><br><span class="line">cd hello</span><br><span class="line"></span><br><span class="line">go mod init example.com/user/hello</span><br><span class="line">go: creating new go.mod: module example.com/user/hello</span><br><span class="line"></span><br><span class="line">cat go.mod</span><br><span class="line">module example.com/user/hello</span><br><span class="line"></span><br><span class="line">go 1.14</span><br></pre></td></tr></table></figure><p><br></p><p>go源文件的第一个语句必须是包名(package name)。可执行命令必须使用<code>package main</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello, world."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在你可以使用go工具来构建和安装程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install example/user/hello</span><br></pre></td></tr></table></figure><p>此命令构建<code>hello</code>命令，产生一个可执行二进制文件，安装此二进制到<code>$HOME/go/bin/hello</code>。</p><p>安装目录由<code>GOPATH</code>和<code>GOBIN</code>环境变量控制。如果<code>GOBIN</code>有设置，则安装到它这个目录。如果<code>GOPATH</code>有设置，二进制被安装到<code>$GOPATH/bin/</code>下。否则，二进制文件被安装到默认<code>$GOPATH/bin</code>目录下。</p><p>可以使用<code>go env</code>命令来设置和取消环境变量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 设置</span><br><span class="line">go env -w GOBIN=/somewhere/else/bin</span><br><span class="line"></span><br><span class="line"># 取消</span><br><span class="line">go env -u GOBIN</span><br></pre></td></tr></table></figure><p><br></p><p>像<code>go install</code>这样的命令应用在包含当前工作目录的模块上下文内。如果当前工作目录不在<code>example.com/user/hell</code>模块内，则<code>go install</code>命令可能会失败。</p><p>为了方便，如果没有给定其它路径，go命令接收相对于当前工作目录的路径，默认为包的当前路径。因此，在当前工作目录下，下面的命令是等效的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go install example.com/user/hello</span><br><span class="line"></span><br><span class="line">go install .</span><br><span class="line"></span><br><span class="line">go install</span><br></pre></td></tr></table></figure><p><br></p><p>接下来，让我们运行此程序以确保它工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:$(dirname $(go list -f &apos;&#123;&#123;.Target&#125;&#125;&apos; .))</span><br><span class="line">hello</span><br><span class="line">Hello, world</span><br></pre></td></tr></table></figure><p><br></p><p>如果你在使用版本控制，那现在是初始化仓库，添加文件并提交你的第一个变化的好时机。这一步是可选的，你不需要使用版本控制编写go代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go init</span><br><span class="line"></span><br><span class="line">git add go.mod hello.go</span><br><span class="line">git commit -m &quot;initial commit&quot;</span><br></pre></td></tr></table></figure><p>go命令通过请求HTTPS URL和从HTML响应中读取元数据来定位仓库包含的模块路径(<code>go help importpath</code>)。许多托管服务已经提供了包含go代码的元数据，使你的模块对其他人可用的最简单的方法通常是——使模块路径匹配仓库URL。</p><p><br><br><br></p><h4 id="从你的模块导入包"><a href="#从你的模块导入包" class="headerlink" title="从你的模块导入包"></a>从你的模块导入包</h4><p>Importing packages from your module</p><p>让我们编写一个<code>morestrings</code>包，并从<code>hello</code>程序来使用它。首先，为包创建一个目录<code>$HOME/hello/morestrings</code>，并在目录下编写<code>reverse.go</code>源文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package morestrings implements additional functions to manipulate UTF-8</span></span><br><span class="line"><span class="comment">// encoded strings, beyond what is provided in the standard "strings" package.</span></span><br><span class="line"><span class="keyword">package</span> morestrings</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReverseRunes returns its argument string reversed rune-wise left to right.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseRunes</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">r := []<span class="keyword">rune</span>(s)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">r[i], r[j] = r[j], r[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试并使用<code>go build</code>来编译包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd hello/morestrings</span><br><span class="line"></span><br><span class="line">go build</span><br></pre></td></tr></table></figure><p>这不会生成一个输出文件。相反，它在本地构建缓存(local build cache)中保存编译包(compiled package)。</p><p>在确认了<code>morestrings</code>包构建之后，让我们修改<code>hello.go</code>来使用morestrings包:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"example.com/usr/hello/morestrings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(morestrings.ReverseRunes(<span class="string">"!oG ,0lleH"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// install hello</span><br><span class="line">go install example.com/user/hello</span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line">Hello, Go!</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="从远程模块导入包"><a href="#从远程模块导入包" class="headerlink" title="从远程模块导入包"></a>从远程模块导入包</h4><p>Importing packages from remote modules</p><p>导入路径可以描述如何使用版本控制获得源代码。go工具使用该属性从远程仓库自动获取包。比如，在程序中使用<code>github.com/google/go-cmp/cmp</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"example.com/user/hello/morestrings"</span></span><br><span class="line">    <span class="string">"github.com/google/go-cmp/cmp"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(morestrings.ReverseRunes(<span class="string">"!oG ,olleH"</span>))</span><br><span class="line">fmt.Println(cmp.Diff(<span class="string">"Hello World"</span>, <span class="string">"Hello Go"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你运行<code>go install</code>, <code>go build</code>, <code>go run</code>这些命令时，go命令会自动下载远程模块并在<code>go.mod</code>文件中记录版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go install example.com/user/hello</span><br><span class="line">go: finding module for package github.com/google/go-cmp/cmp</span><br><span class="line">go: downloading github.com/google/go-cmp v0.4.0</span><br><span class="line">go: found github.com/google/go-cmp/cmp in github.com/google/go-cmp v0.4.0</span><br><span class="line">$ hello</span><br><span class="line">Hello, Go!</span><br><span class="line">  string(</span><br><span class="line">- &quot;Hello World&quot;,</span><br><span class="line">+ &quot;Hello Go&quot;,</span><br><span class="line">  )</span><br><span class="line">$ cat go.mod</span><br><span class="line">module example.com/user/hello</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line">require github.com/google/go-cmp v0.4.0</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>模块依赖关系自动下载到<code>$GOPATH/pkg/mod</code>目录。一个模块的特定版本的下载内容，要求该版本与所有其它模块之间共享，因此go命令标记目录和文件为只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除所有下载的模块</span><br><span class="line">go clean --modcache</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>go有一个轻量测试框架<code>go test</code>命令和<code>testing</code>包。</p><p>你可以通过创建一个以<code>_test.go</code>名称结尾的文件来编写一个测试，此测试文件包含以<code>func (t *testing.T)</code>签名的<code>TestXXX</code>函数。测试框架运行每个这样的函数，如果此函数调用一个失败的函数（如<code>t.Error</code>或<code>t.Fail</code>），则测试被认为失败。</p><p>通过创建包含以下代码的<code>morestrings/reverse_test.go</code>文件，对<code>morestrings</code>包添加一个测试。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"test"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverseRunes</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        in, want <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">"Hello, world"</span>, <span class="string">"dlrow ,olleH"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Hello, 世界"</span>, <span class="string">"界世 ,olleH"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">""</span>, <span class="string">""</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">        got := ReverseRunes(c.in)</span><br><span class="line">        <span class="keyword">if</span> got != c.want &#123;</span><br><span class="line">            t.Errorf(<span class="string">"ReverseRunes(%q) == %q, want %q, c.in, got, c.want"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着使用<code>go test</code>运行测试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go test</span><br><span class="line">PASS</span><br><span class="line">ok  example.com/user/morestrings 0.165s</span><br><span class="line">$</span><br><span class="line"></span><br><span class="line"># 帮助</span><br><span class="line">go help test</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="ide和插件"><a href="#ide和插件" class="headerlink" title="ide和插件"></a>ide和插件</h2><p>doc: <a href="https://golang.org/doc/editors.html" target="_blank" rel="noopener">https://golang.org/doc/editors.html</a></p><ul><li>vim-go: <a href="https://github.com/fatih/vim-go" target="_blank" rel="noopener">https://github.com/fatih/vim-go</a></li><li>Visual Studio Code: <a href="https://marketplace.visualstudio.com/items?itemName=golang.Go" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=golang.Go</a></li></ul><p><br></p><p>我是用的k-vim已经添加了vim-go，只需要将<code>let g:bundle_groups=</code>中添加golang即可。</p><p><br><br><br><br><br></p><h2 id="高效go编程"><a href="#高效go编程" class="headerlink" title="高效go编程"></a>高效go编程</h2><p>Effective Go: <a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">https://golang.org/doc/effective_go.html</a></p><p><br></p><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>Go是一门新语言。要把go写好，了解其性质和惯用语法是很重要的。同样重要的是要知道在go中程序所建立的约定。如命名、格式、项目建设等，让你写的程序会很容易为其他go程序员所理解。</p><p>此文档对编写清晰、惯用的go代码给出了一些技巧。</p><p><br><br><br></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="https://golang.org/src/" target="_blank" rel="noopener">go package sources</a> 不仅作为核心库，而且为如何使用语言做了示例。</p><p><br><br><br></p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>格式问题最具争议，但却始终没有形成统一的定论。若所有人都遵循相同的编码风格，在这类问题上浪费的时间将会更少。</p><p>在go中我们另辟蹊跷，让机器来处理大部分的格式问题。<code>gofmt</code>程序将go程序安装标准风格 进行缩进、对齐，保留注释并在需要时重新格式化。</p><p>举例来说，你无需花时间将结构体中的字段对其，<code>gofmt</code>将会为你代劳。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="keyword">string</span> <span class="comment">// 对象名</span></span><br><span class="line">        value <span class="keyword">int</span> <span class="comment">// 对象值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gofmt</code>会将它按列对齐：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">        name    <span class="keyword">string</span> <span class="comment">// 对象名</span></span><br><span class="line">        value   <span class="keyword">int</span>    <span class="comment">// 对象值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准包中的所有go代码都已经用<code>gofmt</code>格式化过了。一些关于格式化的细节：</p><ul><li><p>缩进(Indentation)<br>使用制表符<code>tab</code>，<code>gofmt</code>也默认使用它。在你认为有必要的时候使用空格符(space)。</p></li><li><p>行长度(Line length)<br>go对行长度没有限制。如果一行实在太长，可以拆行并插入适当的tab缩进。</p></li><li><p>括号(Parentheses)<br>比起C和Java，Go所需的括号更少。控制结构(<code>if, for, switch</code>)在语法上并不需要圆括号。此外，操作符优先级处理变得更加简洁：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&lt;&lt;<span class="number">8</span> + y&lt;&lt;<span class="number">16</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>go提供了C风格的块注释(<code>/* */</code>)和c++风格的行注释(<code>//</code>)。</p><p>godoc既是一个程序，又是一个Web服务器，它对go源码进行处理，并提取包中的文档内容。出现在顶级声明之前，且与该声明之间没有空行的注释，将与该声明一起被提取出来，作为该条目的说明文档。让我想起了Python的文档字符串(docstring)。</p><p>每个包都应包含一个包说明(package comment)——即放置在包子句前的一个块注释。对于包含多个文件的包，包注释只需出现在其中的任一文件中即可。包注释应在整体上对该包进行介绍，并提供包的相关信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">regexp 包为正则表达式实现了一个简单的库。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">它接受的正则表达式语法为：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    正则：</span></span><br><span class="line"><span class="comment">        串联 &#123; '|' 串联&#125;</span></span><br><span class="line"><span class="comment">    串联：</span></span><br><span class="line"><span class="comment">        &#123; 闭包 &#125;</span></span><br><span class="line"><span class="comment">    闭包：</span></span><br><span class="line"><span class="comment">        条目 [ '*' | '+' | '?' ]</span></span><br><span class="line"><span class="comment">    条目：</span></span><br><span class="line"><span class="comment">        '^'</span></span><br><span class="line"><span class="comment">        '$'</span></span><br><span class="line"><span class="comment">        '.'</span></span><br><span class="line"><span class="comment">        字符</span></span><br><span class="line"><span class="comment">        '[' [ '^' ] 字符遍历 ']'</span></span><br><span class="line"><span class="comment">        '(' 正则表达式 ')'</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> regexp</span><br></pre></td></tr></table></figure><p>如果包比较简单，包说明可以简洁些：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package path implements utility routines for</span></span><br><span class="line"><span class="comment">// manipulating slash-separated filename paths.</span></span><br></pre></td></tr></table></figure><p>注释无需额外的格式化。<code>godoc</code>会像<code>gofmt</code>一样处理好一切。注释是不会被解析的纯文本，因此特定的格式不会被渲染。<code>godoc</code>是否会重新格式化注释取决于上下文，因此必须确保它看起来清晰易辨：使用正确的拼写、标点、句子结构以及折叠长行等。</p><p>在包中，任何顶级声明前的注释都作为该声明的文档说明。每个可导出名称的程序(首字母大写)都有该用文档说明。这让我想起了Python的类。</p><p>文档注释最好是完整的句子，这样它才能适应各种自动化的展示。 第一句应当以被声明的东西开头，并且是单句的摘要。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compile parses a regular expression and returns, if successful,</span></span><br><span class="line"><span class="comment">// a Regexp that can be used to match against text.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(*Regexp, error)</span></span> &#123;</span><br></pre></td></tr></table></figure><p>若注释总是以名称开头，<code>godoc</code>的输出就能通过<code>grep</code>变得更加有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go doc -all regexp | grep -i parse</span><br></pre></td></tr></table></figure><p>go的声明语法允许成组声明。单个文档注释应介绍一组相关的常量或变量。 由于是整体声明，这种注释往往较为笼统。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error codes returned by failures to parse an expression.</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrInternal      = errors.New(<span class="string">"regexp: internal error"</span>)</span><br><span class="line">    ErrUnmatchedLpar = errors.New(<span class="string">"regexp: unmatched '('"</span>)</span><br><span class="line">    ErrUnmatchedRpar = errors.New(<span class="string">"regexp: unmatched ')'"</span>)</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>即便是对于私有名称，也可通过成组声明来表明各项间的关系，例如某一组由互斥体保护的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    countLock   sync.Mutex</span><br><span class="line">    inputCount  <span class="keyword">uint32</span></span><br><span class="line">    outputCount <span class="keyword">uint32</span></span><br><span class="line">    errorCount  <span class="keyword">uint32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>names</p><p>命名在编程语言中很重要！</p><p><br></p><h4 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h4><p>package names</p><p>当一个包被导入后，包名就会成为内容的访问器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"bytes</span></span><br></pre></td></tr></table></figure><p>包的名称应该简洁明了以便于理解。按照惯例，包应当以小写的单个单词来命名，且不应该使用下划线或驼峰记法(mixedCaps)。包名是就是导入时所需的默认名称，它并不需要在所有源码中保持唯一，即使在少数发生冲突的情况下，也可为导入的包选择一个别名来局部使用。无论如何，通过文件名来判定使用的包，基本不会产生混淆。</p><p>另一个约定就是包名应为其源码目录的基本名称。在<code>src/encoding/base64</code>中的包应作为<code>encoding/base64</code>导入，其包名为<code>base64</code>，而非<code>encoding_base64</code>或<code>encodingBase64</code>。</p><p>包的导入者可通过包名来引用其内容，因此包中的可导出名称可以此来避免冲突。请勿使用<code>import .</code>记法，它可以简化必须在被测试包外运行的测试， 除此之外应尽量避免使用。</p><p>另一个简短的例子是<code>once.Do</code>，<code>once.Do(setup)</code>表述足够清晰， 使用<code>once.DoOrWaitUntilDone(setup)</code>完全就是画蛇添足。 长命名并不会使其更具可读性。一份有用的说明文档通常比额外的长名更有价值。</p><p><br><br><br></p><h4 id="获取器"><a href="#获取器" class="headerlink" title="获取器"></a>获取器</h4><p>Getters</p><p>Go并不对获取器（getter）和设置器（setter）提供自动支持。 你应当自己提供获取器和设置器，通常很值得这样做，但若要将 Get 放到获取器的名字中，既不符合习惯，也没有必要。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">owner := obj.Owner()</span><br><span class="line"><span class="keyword">if</span> owner != user &#123;</span><br><span class="line">obj.SetOwner(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="接口名"><a href="#接口名" class="headerlink" title="接口名"></a>接口名</h4><p>Interface names</p><p>按照约定，只包含一个方法的接口应当以该方法的名称加上<code>-er</code>后缀来命名，如<code>Reader</code>、<code>Writer</code>、 <code>Formatter</code>、<code>CloseNotifier</code>等。</p><p><br><br><br></p><h4 id="驼峰记法"><a href="#驼峰记法" class="headerlink" title="驼峰记法"></a>驼峰记法</h4><p>MixedCaps</p><p>最后，go中约定使用<code>MexedCaps</code>或<code>mixedCaps</code>而不是下划线来编写多个词的名字。</p><p><br><br><br></p><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>Semicolons</p><p>和C一样，Go的正式语法使用分号(<code>;</code>)来结束语句。但和C不同的是，这些分号不会出现在源码中。取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此大部分输入文本是自由的。</p><p>若在新行前的最后一个标记为一个标识符(包括<code>int</code>, <code>float64</code>)，数值或字符串常量的基本字面或以下标记之一:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break continue fallthrough return ++ -- ) &#125;</span><br></pre></td></tr></table></figure><p>词法分析器将始终在该标记后面插入一个分号。这可以概括为：<strong>如果新行前的标记为语句的末尾，则插入一个分号</strong>。</p><p>分号也可以在关闭括号之前直接省略，因此一个语句像如下这样，不需要分号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go func() &#123; for &#123; dst &lt;- &lt;-src &#125; &#125;()</span><br></pre></td></tr></table></figure><p>通常go程序只在诸如<code>for</code>循环子句这样的地方使用分号。如果在一行中写多个语句，也需要使用分号分隔。</p><p>无论如何，你都不应该将控制结构(<code>if, for, switch, select</code>)的左括号放到下一行。你应该这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &lt; f() &#123;</span><br><span class="line">    g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不是这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &lt; f() <span class="comment">// wrong!</span></span><br><span class="line">&#123;          <span class="comment">// wrong!</span></span><br><span class="line">    g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><p>Control structures</p><p>go的控制结构与C有许多相似之处，但其不同才是独到之处。go不使用<code>do</code>或<code>while</code>循环，只有一个更通用的<code>for</code>；<code>switch</code>要更灵活些；<code>if</code>和<code>switch</code>像<code>for</code>一样接受一个可选的初始化语句；<code>break</code>和<code>continue</code>语句有一个可选的标签来确定那些break或continue；此外，还有一个包含类型选择和多路通信复用器的新控制结构——<code>select</code>。它们的语法也有些许不同，没有圆括号，主体必须始终使用大括号括住。</p><p><br></p><h4 id="if-1"><a href="#if-1" class="headerlink" title="if"></a>if</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>if</code>和<code>switch</code>可接收初始化语句，因此用它们来设置局部变量很常见。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := file.Chmod(<span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Print(err)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="重新声明和重新赋值"><a href="#重新声明和重新赋值" class="headerlink" title="重新声明和重新赋值"></a>重新声明和重新赋值</h4><p>Redeclaration and reassignment</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line"></span><br><span class="line">d, err := f.Stat()</span><br></pre></td></tr></table></figure><p>满足下列条件时，已被声明的变量可出现在<code>:=</code>声明中：</p><ul><li>本次声明与已声明的变量出于同一作用域（若变量已在外层作用域中声明过，则此次声明会创建一个新的变量<code>§</code>）</li><li>在初始化中与其类型相应的值才能赋予变量，且在此次声明中至少另有一个变量是新声明的</li></ul><p><br><br><br></p><h4 id="for-1"><a href="#for-1" class="headerlink" title="for"></a>for</h4><p>go的<code>for</code>循环统一了for和while。它有三种形式，但只有一种需要分号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Like a C for</span></span><br><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like a C while</span></span><br><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like a C for(;;)</span></span><br><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>简短的声明使得更容易在循环中声明下标变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若你想遍历数组、切片、字符串、映射，或从信道中读取消息，<code>range</code>子句能够帮你轻松实现循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要遍历下标，去掉第二个</span></span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m &#123;</span><br><span class="line">    <span class="keyword">if</span> key.expired() &#123;</span><br><span class="line">        <span class="built_in">delete</span>(m, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要值，使用空白标识符(_)来丢弃下标</span></span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> array &#123;</span><br><span class="line">        sum += value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="switch-1"><a href="#switch-1" class="headerlink" title="switch"></a>switch</h4><p>go的<code>switch</code>比C更通用。其表达式无需为常量或整数，<code>case</code>语句会自上而下逐一进行求值直到匹配为止。如果<code>switch</code>后面没有表达式，它将匹配<code>true</code>。因此，我们可以将<code>if-else-if-else</code>链写成一个<code>switch</code>，这也更符合go的风格。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unhex</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'0'</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'f'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="number">10</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'F'</span>:</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code>并不会自动下溯，但<code>case</code>可通过逗号分隔来列举相同的处理条件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shouldEscape</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> c &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">' '</span>, <span class="string">'?'</span>, <span class="string">'&amp;'</span>, <span class="string">'='</span>, <span class="string">'#'</span>, <span class="string">'+'</span>, <span class="string">'%'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>break</code>语句可以使<code>switch</code>提前终止。不仅是<code>switch</code>，有时候也需要打破层层的循环。在go中，只需将标签(label)放置到循环外，然后break到标签。下例展示了两者的用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Loop:</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="built_in">len</span>(src); n += size &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> src[n] &lt; sizeOne:</span><br><span class="line"><span class="keyword">if</span> validateOnly &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">size = <span class="number">1</span></span><br><span class="line">update(src[n])</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> src[n] &lt; sizeTwo:</span><br><span class="line"><span class="keyword">if</span> n+<span class="number">1</span> &gt;= <span class="built_in">len</span>(src) &#123;</span><br><span class="line">err = errShortInput</span><br><span class="line"><span class="keyword">break</span> Loop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> validateOnly &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">size = <span class="number">2</span></span><br><span class="line">update(src[n] + src[n+<span class="number">1</span>]&lt;&lt;shift)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<code>continue</code>语句也能接受一个可选的标签，不过它只能应用在循环中。</p><p>作为这一节的结束，下例使用两个switch语句对字节切片进行比较：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compare returns an integer comparing the two byte slices,</span></span><br><span class="line"><span class="comment">// lexicographically.</span></span><br><span class="line"><span class="comment">// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compare</span><span class="params">(a, b []<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a) &amp;&amp; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> a[i] &gt; b[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> a[i] &lt; b[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">len</span>(a) &gt; <span class="built_in">len</span>(b):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">len</span>(a) &lt; <span class="built_in">len</span>(b):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="类型选择-1"><a href="#类型选择-1" class="headerlink" title="类型选择"></a>类型选择</h4><p>type switch</p><p><code>switch</code>也可用于判断接口变量的动态类型。如type switch通过括号中的关键字<code>type</code>使用类型断言。若<code>switch</code>在表达式中声明了一个变量，那么该变量的每个子句中都将有该变量对应的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"unexpected type %T\n"</span>, t)     <span class="comment">// %T prints whatever type t has</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"boolean %t\n"</span>, t)             <span class="comment">// t has type bool</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"integer %d\n"</span>, t)             <span class="comment">// t has type int</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"pointer to boolean %t\n"</span>, *t) <span class="comment">// t has type *bool</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"pointer to integer %d\n"</span>, *t) <span class="comment">// t has type *int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>function</p><p><br></p><h4 id="多值返回-1"><a href="#多值返回-1" class="headerlink" title="多值返回"></a>多值返回</h4><p>multiple return values</p><p>以下简单的函数可从字节数组中的特定位置获取其值，并返回该数值和下一个位置。</p><p>func nextInt(b []byte, i int) (int, int) {<br>    for ; i &lt; len(b) &amp;&amp; !isDigit(b[i]); i++ {<br>    }<br>    x := 0<br>    for ; i &lt; len(b) &amp;&amp; isDigit(b[i]); i++ {<br>        x = x*10 + int(b[i]) - ‘0’<br>    }<br>    return x, i<br>}</p><p>获取多值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); &#123;</span><br><span class="line">    x, i = nextInt(b, i)</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="命名结果形参"><a href="#命名结果形参" class="headerlink" title="命名结果形参"></a>命名结果形参</h4><p>Named result parameters</p><p>go函数的返回值(return)或结果(result)<strong>行参</strong>可被命名，并作为常规变量使用。就像传入的形参一样。命名后，一旦该函数开始执行，它们就会被初始化为与其类型相应的零值；若该函数执行了一条不带参数的<code>return</code>语句，则结果形参的当前值将作为返回值。</p><p>此名称不是强制性的，但它们能使代码更加简洁明了：它们就是文档。如果我们命名了nextInt的结果，那么它返回的int就值如其意了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextInt</span><span class="params">(b []<span class="keyword">byte</span>, pos <span class="keyword">int</span>)</span> <span class="params">(value, nextPos <span class="keyword">int</span>)</span></span> &#123;</span><br></pre></td></tr></table></figure><p>由于被命名的结果已经初始化，且已经关联至无参数的返回，它们就能让代码简单而清晰。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFull</span><span class="params">(r Reader, buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(buf) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nr <span class="keyword">int</span></span><br><span class="line">        nr, err = r.Read(buf)</span><br><span class="line">        n += nr</span><br><span class="line">        buf = buf[nr:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h4><p>go的<code>defer</code>语句用于预设一个函数调用(即推迟执行函数(deferred function))，该函数会在执行<code>defer</code>的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是解锁互斥和关闭文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Contents returns the file's contents as a string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contents</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()  <span class="comment">// f.Close will run when we're finished.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">byte</span></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := f.Read(buf[<span class="number">0</span>:])</span><br><span class="line">        result = <span class="built_in">append</span>(result, buf[<span class="number">0</span>:n]...) <span class="comment">// append is discussed later.</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>, err  <span class="comment">// f will be closed if we return here.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(result), <span class="literal">nil</span> <span class="comment">// f will be closed if we return here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推迟如<code>Close</code>之类的函数调用有两个好处。第一， 它能确保你不会忘记关闭文件。如果你以后又为该函数添加了新的返回路径时，这种情况往往就会发生。第二，它意味着<strong>关闭</strong>离<strong>打开</strong>很近， 这总比将它放在函数结尾处要清晰明了。</p><p>推迟函数（如果函数是一个方法则还包括接收者）的实参在推迟执行时就会求值，而不是在调用执行时才求值。这样不仅无需担心变量值在函数执行时被改变， 同时还意味着单个已推迟的调用可推迟多个函数的执行。一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">"%d "</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被推迟的函数会按照<strong>后见先出(LIFO)</strong>的顺序执行，因此上述返回为<code>4 3 2 1 0</code>。一个更具实际意义的例子，让程序跟踪函数的运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="keyword">string</span>)</span></span>   &#123; fmt.Println(<span class="string">"entering:"</span>, s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">untrace</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123; fmt.Println(<span class="string">"leaving:"</span>, s) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use them like this:</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    trace(<span class="string">"a"</span>)</span><br><span class="line">    <span class="keyword">defer</span> untrace(<span class="string">"a"</span>)</span><br><span class="line">    <span class="comment">// do something....</span></span><br><span class="line">    fmt.Println(<span class="string">"---"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entering: a</span><br><span class="line">---</span><br><span class="line">leaving: a</span><br></pre></td></tr></table></figure><p>我们可以充分利用这个特点，即被推迟函数的实参在<code>defer</code>执行时才会求值。跟踪go程可针对反跟踪go程设置实参。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"entering:"</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">un</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"leaving:"</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">"a"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"in a"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> un(trace(<span class="string">"b"</span>))</span><br><span class="line">    fmt.Println(<span class="string">"in b"</span>)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entering: b</span><br><span class="line">in b</span><br><span class="line">entering: a</span><br><span class="line">in a</span><br><span class="line">leaving: a</span><br><span class="line">leaving: b</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>Data</p><p><br></p><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>go有两种分配原语，即内建函数<code>new</code>和<code>make</code>。<code>new</code>用来分配内存，但与其它同名函数不同，它不会初始化内存，只会将内存置零(zero)。<code>new(T)</code>会为类型T的新项分配已置零的内存控制，并返回它的地址，也即是类型<code>*T</code>的值。用go的术语，它返回一个指针，该指针指向新分配的类型为T的零值。</p><p>既然<code>new</code>返回的内存已置零，那么当你设计数据结构时，每种类型的零值就不必进一步初始化，这意味着该数据结构的使用者只需用<code>new</code>创建一个新的对象就能正常工作。</p><p>零值属性有各种好处，考虑以下声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncedBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock    sync.Mutex</span><br><span class="line">    buffer  bytes.Buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SyncedBuffer</code>类型的值也是在声明时就分配好内存就绪了。后续代码中， p和v无需进一步处理即可正确工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(SyncedBuffer)  <span class="comment">// type *SyncedBuffer</span></span><br><span class="line"><span class="keyword">var</span> v SyncedBuffer      <span class="comment">// type  SyncedBuffer</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="构造函数与复合字面"><a href="#构造函数与复合字面" class="headerlink" title="构造函数与复合字面"></a>构造函数与复合字面</h4><p>Constructors and composite literals</p><p>有时零值还不够好，这时就需要一个初始化构造函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    f := <span class="built_in">new</span>(File)</span><br><span class="line">    f.fd = fd</span><br><span class="line">    f.name = name</span><br><span class="line">    f.dirinfo = <span class="literal">nil</span></span><br><span class="line">    f.nepipe = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里显得代码过于冗长。我们可通过复合字面来简化它， 该表达式在每次求值时都会创建新的实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，返回一个局部变量的地址完全没有问题，这点与C不同。该局部变量对应的数据 在函数返回后依然有效。实际上，每当获取一个复合字面的地址时，都将为一个新的实例分配内存， 因此我们可以将上面的最后两行代码合并：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>复合字面的字段必须按顺序全部列出。但如果以<code>k:v</code>对的形式明确地标出元素，初始化字段时就可以按任何顺序出现，未给出的字段值将赋予零值。 因此，我们可以用如下形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;File&#123;fd: fd, name: name&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="make"><a href="#make" class="headerlink" title="make"></a>make</h4><p>再回到内存分配上来。不同于<code>new</code>，<code>make</code>只用于创建切片、映射和信道，并返回类型为T的一个已初始化的值。出现这种差异的原因在于，这三种类型本质上为引用数据类型，它们在使用前必须初始化。对于切片、映射和信道，<code>make</code>用于初始化其内部的数据结构并准备好将要使用的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ew([]int) 会返回一个指向新分配的，已置零的切片结构， 即一个指向 nil 切片值的指针</span></span><br><span class="line"><span class="comment">// 会分配一个具有100个int的数组空间，接着创建一个长度为10， 容量为100并指向该数组中前10个元素的切片结构</span></span><br><span class="line"><span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><br></p><p><code>new</code>和<code>make</code>的区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *[]<span class="keyword">int</span> = <span class="built_in">new</span>([]<span class="keyword">int</span>)       <span class="comment">// allocates slice structure; *p == nil; rarely useful</span></span><br><span class="line"><span class="keyword">var</span> v  []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>) <span class="comment">// the slice v now refers to a new array of 100 ints</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unnecessarily complex:</span></span><br><span class="line"><span class="keyword">var</span> p *[]<span class="keyword">int</span> = <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br><span class="line">*p = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Idiomatic:</span></span><br><span class="line">v := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>请记住，<code>make</code>只适用于映射、切片和信道且不返回指针。若要获得明确的指针， 请使用<code>new</code>分配内存。</p><p><br><br><br></p><h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><p>在详细规划内存布局时，数组非常有用，有时还能避免过多的内存分配，但它们主要用作切片的构件。</p><p>Go中数组：</p><ul><li>数组是值。将一个数组赋予另一个数组会复制其所有元素。</li><li>若将某个数组传入某个函数，它将接收到该数组的一份副本而非指针。</li><li>数组的大小是其类型的一部分。类型<code>[10]int</code>和<code>[20]int</code>是不同的。</li></ul><p>数组为值的属性很有用，但代价高昂。若你想要C那样的行为和效率，你可以传递一个指向该数组的指针。但这并不是Go的习惯用法，切片才是。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(a *[3]<span class="keyword">float64</span>)</span> <span class="params">(sum <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> *a &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array := [...]<span class="keyword">float64</span>&#123;<span class="number">7.0</span>, <span class="number">8.5</span>, <span class="number">9.1</span>&#125;</span><br><span class="line">x := Sum(&amp;array)  <span class="comment">// Note the explicit address-of operator</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h4><p>切片通过对数组进行封装，为数据序列提供了更通用、强大而方便的接口。 除了矩阵变换这类需要明确维度的情况外，Go中的大部分数组编程都是通过切片来完成的。</p><p>切片保存了对底层数组的引用，若你将某个切片赋予另一个切片，它们会引用同一个数组。只要切片不超出底层数组的限制，它的长度就是可变的。尽管<code>append</code>可修改切片的元素，但切片自身（其运行时数据结构包含指针、长度和容量）是通过值传递的。</p><p><br><br><br></p><h4 id="二维切片"><a href="#二维切片" class="headerlink" title="二维切片"></a>二维切片</h4><p>Two-dimensional slices</p><p>Go的数组和切片都是一维的。要创建等价的二维数组或切片，就必须定义一个数组的数组， 或切片的切片。像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transform [<span class="number">3</span>][<span class="number">3</span>]<span class="keyword">float64</span>  <span class="comment">// A 3x3 array, really an array of arrays.</span></span><br><span class="line"><span class="keyword">type</span> LinesOfText [][]<span class="keyword">byte</span>     <span class="comment">// A slice of byte slices.</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><p>映射是方便而强大的内建数据结构，它可以关联不同类型的值。其键可以是任何相等性操作符支持的类型， 如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构以及数组。 切片不能用作映射键，因为它们的相等性还未定义。与切片一样，映射也是引用类型。 若将映射传入函数中，并更改了该映射的内容，则此修改对调用者同样可见。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeZone = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"UTC"</span>:  <span class="number">0</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">"EST"</span>: <span class="number">-5</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">"CST"</span>: <span class="number">-6</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">"MST"</span>: <span class="number">-7</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">    <span class="string">"PST"</span>: <span class="number">-8</span>*<span class="number">60</span>*<span class="number">60</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赋值和获取映射值的语法类似于数组，不同的是映射的索引不必为整数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset := timeZone[<span class="string">"EST"</span>]</span><br></pre></td></tr></table></figure><p>有时你需要区分某项是不存在还是其值为零值。可以使用多重赋值的形式来分辨这种情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> seconds <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">seconds, ok = timeZone[tz]</span><br></pre></td></tr></table></figure><p>若仅需判断映射中是否存在某项而不关心实际的值，可使用空白标识符(<code>_</code>)来代替该值的一般变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, present := timeZone[tz]</span><br></pre></td></tr></table></figure><p>要删除映射中的某项，可使用内建函数 delete，它以映射及要被删除的键为实参。 即便对应的键不在该映射中，此操作也是安全的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(timeZone, <span class="string">"PDT"</span>)  <span class="comment">// Now on Standard Time</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Printing"><a href="#Printing" class="headerlink" title="Printing"></a>Printing</h4><p>Go采用的格式化打印风格和C的<code>printf</code>族类似，但却更加丰富而通用。这些函数位于<code>fmt</code>包中，且函数名首字母均为大写：如<code>fmt.Printf</code>、<code>fmt.Fprintf</code>，<code>fmt.Sprintf</code>等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"Hello %d\n"</span>, <span class="number">23</span>)</span><br><span class="line">fmt.Fprint(os.Stdout, <span class="string">"Hello "</span>, <span class="number">23</span>, <span class="string">"\n"</span>)</span><br><span class="line">fmt.Println(<span class="string">"Hello"</span>, <span class="number">23</span>)</span><br><span class="line">fmt.Println(fmt.Sprint(<span class="string">"Hello "</span>, <span class="number">23</span>))</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><p>内建函数<code>append</code>像这个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []T, elements ...T)</span> []<span class="title">T</span></span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Initialization</p><p>尽管从表面上看，Go的初始化过程与C或C++并不算太大，但它确实更为强大。 在初始化过程中，不仅可以构建复杂的结构，还能正确处理不同包对象间的初始化顺序。</p><p><br></p><h4 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h4><p>Constants</p><p>Go中的常量就是不变量。它们在编译时创建，即便它们可能是函数中定义的局部变量。 常量只能是数字、字符（符文）、字符串或布尔值。由于编译时的限制， 定义它们的表达式必须也是可被编译器求值的常量表达式。</p><p><br><br><br></p><h4 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h4><p>变量的初始化与常量类似，但其初始值也可以是在运行时才被计算的一般表达式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    home   = os.Getenv(<span class="string">"HOME"</span>)</span><br><span class="line">    user   = os.Getenv(<span class="string">"USER"</span>)</span><br><span class="line">    gopath = os.Getenv(<span class="string">"GOPATH"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p>The init function</p><p>最后，每个源文件都可以通过定义自己的无参数<code>init</code>函数来设置一些必要的状态。而它的结束就意味着初始化结束： 只有该包中的所有变量声明都通过它们的初始化器求值后<code>init</code>才会被调用， 而那些<code>init</code>只有在所有已导入的包都被初始化后才会被求值。</p><p>除了那些不能被表示成声明的初始化外，init 函数还常被用在程序真正开始执行前，检验或校正程序的状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Besides initializations that cannot be expressed as declarations, a common use of init functions is to verify or repair correctness of the program state before <span class="built_in">real</span> execution begins.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">""</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"$USER not set"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> home == <span class="string">""</span> &#123;</span><br><span class="line">        home = <span class="string">"/home/"</span> + user</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> gopath == <span class="string">""</span> &#123;</span><br><span class="line">        gopath = home + <span class="string">"/go"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// gopath may be overridden by --gopath flag on command line.</span></span><br><span class="line">    flag.StringVar(&amp;gopath, <span class="string">"gopath"</span>, gopath, <span class="string">"override default GOPATH"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>Methods</p><p><br></p><h4 id="指针与值"><a href="#指针与值" class="headerlink" title="指针与值"></a>指针与值</h4><p>Pointers vs. Values</p><p>以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用。</p><p><br><br><br></p><h3 id="接口和其它类型"><a href="#接口和其它类型" class="headerlink" title="接口和其它类型"></a>接口和其它类型</h3><p><br></p><h4 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h4><p>Go中的接口为指定对象的行为提供了一种方法：如果某样东西可以完成这个， 那么它就可以用在这里。</p><p>每种类型都能实现多个接口。</p><p><br><br><br></p><h4 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h4><p>Conversions</p><p><br><br><br></p><h4 id="接口转换与类型断言"><a href="#接口转换与类型断言" class="headerlink" title="接口转换与类型断言"></a>接口转换与类型断言</h4><p>Interface conversions and type assertions</p><p>类型选择是类型转换的一种形式：它接受一个接口，在选择中根据其判断选择对应的情况， 并在某种意义上将其转换为该种类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Value provided by caller.</span></span><br><span class="line"><span class="keyword">switch</span> str := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">case</span> Stringer:</span><br><span class="line">    <span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型断言接受一个接口值， 并从中提取指定的明确类型的值。</p><p><br><br><br></p><h4 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h4><p>Generality</p><p>若某种现有的类型仅实现了一个接口，且除此之外并无可导出的方法，则该类型本身就无需导出。 仅导出该接口能让我们更专注于其行为而非实现，其它属性不同的实现则能镜像该原始类型的行为。 这也能够避免为每个通用接口的实例重复编写文档。</p><p>在这种情况下，构造函数应当返回一个接口值而非实现的类型。</p><p><br><br><br></p><h4 id="接口和方法"><a href="#接口和方法" class="headerlink" title="接口和方法"></a>接口和方法</h4><p>Interfaces and methods</p><p>由于几乎任何类型都能添加方法，因此几乎任何类型都能满足一个接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个很直观的例子就是 http 包中定义的 Handler 接口。任何实现了 Handler 的对象都能够处理HTTP请求</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符"></a>空白标识符</h3><p>The blank identifier</p><p>空白标识符(<code>_</code>)可被赋予或声明为任何类型的任何值，而其值会被无害地丢弃。它有点像Unix中的<code>/dev/null</code>文件：它表示只写的值，在需要变量但不需要实际值的地方用作占位符。</p><p><br></p><h4 id="多重赋值中的空白标识符"><a href="#多重赋值中的空白标识符" class="headerlink" title="多重赋值中的空白标识符"></a>多重赋值中的空白标识符</h4><p>The blank identifier in multiple assignment</p><p><code>for range</code>循环中对空表标识符的用法是一种具体情况，更一般的情况即为多重赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := os.Stat(path); os.IsNotExist(err) &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s does not exist\n"</span>, path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="未使用的导入和变量"><a href="#未使用的导入和变量" class="headerlink" title="未使用的导入和变量"></a>未使用的导入和变量</h4><p>Unused imports and variables</p><p>若导入某个包或声明某个变量而不使用它就会产生错误。未使用的包会让程序膨胀并拖慢编译速度， 而已初始化但未使用的变量不仅会浪费计算能力，还有可能暗藏着更大的Bug。</p><p>要让编译器停止关于未使用导入的抱怨，需要空白标识符来引用已导入包中的符号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = fmt.Printf <span class="comment">// For debugging; delete when done.</span></span><br><span class="line"><span class="keyword">var</span> _ io.Reader    <span class="comment">// For debugging; delete when done.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fd, err := os.Open(<span class="string">"test.go"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> use fd.</span></span><br><span class="line">    _ = fd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="为副作用而导入"><a href="#为副作用而导入" class="headerlink" title="为副作用而导入"></a>为副作用而导入</h4><p>Import for side effect</p><p>有时导入某个包只是为了其副作用， 而没有任何明确的使用。只为了其副作用来导入该包， 只需将包重命名为空白标识符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"net/http/pprof"</span></span><br></pre></td></tr></table></figure><p>这种导入格式能明确表示该包是为其副作用而导入的，因为没有其它使用该包的可能： 在此文件中，它没有名字。（若它有名字而我们没有使用，编译器就会拒绝该程序。）</p><p><br><br><br></p><h4 id="接口检查"><a href="#接口检查" class="headerlink" title="接口检查"></a>接口检查</h4><p>Interface checks</p><p>一个类型无需显式地声明它实现了某个接口。取而代之，该类型只要实现了某个接口的方法， 其实就实现了该接口。在实践中，大部分接口转换都是静态的，因此会在编译时检测。</p><p>若只需要判断某个类型是否是实现了某个接口，而不需要实际使用接口本身 （可能是错误检查部分），就使用空白标识符来忽略类型断言的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> _, ok := val.(json.Marshaler); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"value %v of type %T implements json.Marshaler\n"</span>, val, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种结构中出现空白标识符，即表示该声明的存在只是为了类型检查。 不过请不要为满足接口就将它用于任何类型。作为约定， 仅当代码中不存在静态类型转换时才能这种声明，毕竟这是种罕见的情况。</p><p><br><br><br></p><h3 id="内嵌"><a href="#内嵌" class="headerlink" title="内嵌"></a>内嵌</h3><p>Embedding</p><p>Go并不提供典型的，类型驱动的子类化概念，但通过将类型内嵌到结构体或接口中， 它就能借鉴部分实现。</p><p><br><br><br></p><h3 id="并发-1"><a href="#并发-1" class="headerlink" title="并发"></a>并发</h3><p>Concurrency</p><p><br></p><h4 id="通过通信共享内存"><a href="#通过通信共享内存" class="headerlink" title="通过通信共享内存"></a>通过通信共享内存</h4><p>Share by communicating</p><p>并发编程是个很大的话题。这里只讨论一些go特有的东西。</p><p>在并发编程中，为实现对共享变量的正确访问需要精确的控制，这在多数环境下都很困难。 Go语言另辟蹊径，它将共享的值通过信道传递，实际上，多个独立执行的线程从不会主动共享。 在任意给定的时间点，只有一个Go程能够访问该值。数据竞争从设计上就被杜绝了。</p><p>为了提倡这种思考方式，我们将它简化为一句口号： <strong>不要通过共享内存来通信，而应通过通信来共享内存(Do not communicate by sharing memory; instead, share memory by communicating)。</strong></p><p>这种方法意义深远。例如，引用计数通过为整数变量添加互斥锁来很好地实现。 但作为一种高级方法，通过信道来控制访问能够让你写出更简洁，正确的程序。</p><p><br><br><br></p><h4 id="go程"><a href="#go程" class="headerlink" title="go程"></a>go程</h4><p>Goroutines</p><p>称它为<strong>GO程</strong>是因为现有的术语——线程(threads), 协程(coroutines), 进程(process)无法准确表达它的含义。Go程具有简单的模型：它是与其它Go程并发运行在同一地址空间的函数。它是轻量级的， 所有小号几乎就只有栈空间的分配。而且栈最开始是非常小的，所以它们很廉价， 仅在需要时才会随着堆空间的分配（和释放）而变化。</p><p>Go程在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待I/O， 那么其它的线程就会运行。Go程的设计隐藏了线程创建和管理的诸多复杂性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数或方法前添加go关键字能够在新的Go程中调用它。当调用完成后， 该Go程也会安静地退出</span></span><br><span class="line"><span class="comment">// 效果有点像Unix Shell中的 &amp; 符号，它能让命令在后台运行</span></span><br><span class="line"><span class="keyword">go</span> list.Sort() <span class="comment">// run list.Sort concurrently; don't wait for it.</span></span><br></pre></td></tr></table></figure><p>函数字面在Go程调用中非常有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Announce</span><span class="params">(message <span class="keyword">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(delay)</span><br><span class="line">        fmt.Println(message)</span><br><span class="line">    &#125;()  <span class="comment">// Note the parentheses - must call the function.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go中，函数字面都是闭包(closures)：其实现在保证了函数内引用变量的生命周期与函数的活动时间相同。这些函数没什么实用性，因为它们没有实现完成时的信号处理。因此，我们需要信道。</p><p><br><br><br></p><h4 id="信道-1"><a href="#信道-1" class="headerlink" title="信道"></a>信道</h4><p>Channels</p><p>信道与映射一样，也需要通过<code>make</code>来分配内存，其结果充当了对底层数据结构的引用。若提供了一个可选的整数形参，它就会为该信道设置缓冲区大小。默认值是零，表示不带缓冲(unbuffered)的或同步(synchronous)的信道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ci := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)            <span class="comment">// unbuffered channel of integers</span></span><br><span class="line">cj := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>)         <span class="comment">// unbuffered channel of integers</span></span><br><span class="line">cs := <span class="built_in">make</span>(<span class="keyword">chan</span> *os.File, <span class="number">100</span>)  <span class="comment">// buffered channel of pointers to Files</span></span><br></pre></td></tr></table></figure><p>无缓冲信道在通信时会同步交换数据，它能确保（goroutine）计算处于确定状态。</p><p>信道有很多惯用方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)  <span class="comment">// Allocate a channel.</span></span><br><span class="line"><span class="comment">// Start the sort in a goroutine; when it completes, signal on the channel.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list.Sort()</span><br><span class="line">    c &lt;- <span class="number">1</span>  <span class="comment">// Send a signal; value does not matter.</span></span><br><span class="line">&#125;()</span><br><span class="line">doSomethingForAWhile()</span><br><span class="line">&lt;-c   <span class="comment">// Wait for sort to finish; discard sent value.</span></span><br></pre></td></tr></table></figure><p>接收者在收到数据前会一直阻塞。若信道是不带缓冲的，那么在接收者收到值前， 发送者会一直阻塞；若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞； 若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。</p><p>带缓冲的信道可被用作信号量，例如限制吞吐量。</p><p>回到编写服务器的一般问题上来。另一种管理资源的好方法就是启动固定数量的<code>handle</code>Go程，一起从请求信道中读取数据。Go程的数量限制了同时调用<code>process</code>的数量。Serve同样会接收一个通知退出的信道， 在启动所有Go程后，它将阻塞并暂停从信道中接收消息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(queue <span class="keyword">chan</span> *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> r := <span class="keyword">range</span> queue &#123;</span><br><span class="line">        process(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(clientRequests <span class="keyword">chan</span> *Request, quit <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Start handlers</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; MaxOutstanding; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> handle(clientRequests)</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;-quit  <span class="comment">// Wait to be told to exit.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="信道中的信道"><a href="#信道中的信道" class="headerlink" title="信道中的信道"></a>信道中的信道</h4><p>Channels of channels</p><p>Go最重要的特性就是信道是一等值，它可以被分配并像其它值到处传递。 这种特性通常被用来实现安全(safe)、并行(parallel)的多路分解(demultiplexing)。</p><p><br><br><br></p><h4 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h4><p>Parallelization</p><p>这些设计的另一个应用是在多CPU核心上实现并行计算。如果计算过程能够被分为几块 可独立执行的过程，它就可以在每块计算结束时向信道发送信号，从而实现并行处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numCPU = <span class="number">4</span> <span class="comment">// number of CPU cores</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vector)</span> <span class="title">DoAll</span><span class="params">(u Vector)</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, numCPU)  <span class="comment">// Buffering optional but sensible.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCPU; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> v.DoSome(i*<span class="built_in">len</span>(v)/numCPU, (i+<span class="number">1</span>)*<span class="built_in">len</span>(v)/numCPU, u, c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Drain the channel.</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCPU; i++ &#123;</span><br><span class="line">        &lt;-c    <span class="comment">// wait for one task to complete</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// All done.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前Go运行时的实现默认并不会并行执行代码，它只为用户层代码提供单一的处理核心。 任意数量的Go程都可能在系统调用中被阻塞，而在任意时刻默认只有一个会执行用户层代码。 它应当变得更智能，而且它将来肯定会变得更智能。但现在，若你希望CPU并行执行， 就必须告诉运行时你希望同时有多少Go程能执行代码。除了为CPU数量创建一个创建，还有两种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> numCPU = runtime.NumCPU()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> numCPU = runtime.GOMAXPROCS(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><br></p><p>注意不要混淆并发(concurrency)和并行(parallelism)的概念。并发是用可独立执行的组件构造程序的方法， 而并行则是为了效率在多CPU上平行地进行计算。</p><p>尽管Go的并发特性能够让某些问题更易构造成并行计算， 但Go仍然是种并发而非并行的语言，且Go的模型并不适合所有的并行问题。</p><p><br><br><br></p><h4 id="泄露的缓冲区"><a href="#泄露的缓冲区" class="headerlink" title="泄露的缓冲区"></a>泄露的缓冲区</h4><p>A leaky buffer</p><p>并发编程的工具甚至能很容易地表达非并发的思想。</p><p>这里有个提取自RPC包的例子。 客户端Go程从某些来源，可能是网络中循环接收数据。为避免分配和释放缓冲区， 它保存了一个空闲链表，使用一个带缓冲信道表示。若信道为空，就会分配新的缓冲区。 一旦消息缓冲区就绪，它将通过serverChan被发送到服务器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> freeList = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> serverChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">client</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> b *Buffer</span><br><span class="line">        <span class="comment">// Grab a buffer if available; allocate if not.</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> b = &lt;-freeList:</span><br><span class="line">            <span class="comment">// Got one; nothing more to do.</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// None free, so allocate a new one.</span></span><br><span class="line">            b = <span class="built_in">new</span>(Buffer)</span><br><span class="line">        &#125;</span><br><span class="line">        load(b)              <span class="comment">// Read next message from the net.</span></span><br><span class="line">        serverChan &lt;- b      <span class="comment">// Send to server.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器从客户端循环接收每个消息，处理它们，并将缓冲区返回给空闲列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        b := &lt;-serverChan    <span class="comment">// Wait for work.</span></span><br><span class="line">        process(b)</span><br><span class="line">        <span class="comment">// Reuse buffer if there's room.</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> freeList &lt;- b:</span><br><span class="line">            <span class="comment">// Buffer on free list; nothing more to do.</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Free list full, just carry on.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端试图从freeList中获取缓冲区；若没有缓冲区可用， 它就将分配一个新的。服务器将b放回空闲列表freeList中直到列表已满，此时缓冲区将被丢弃，并被垃圾回收器回收。依靠带缓冲的信道和垃圾回收器的记录， 我们仅用短短几行代码就构建了一个可能导致缓冲区槽位泄露的空闲列表。</p><p><br><br><br></p><h3 id="错误-1"><a href="#错误-1" class="headerlink" title="错误"></a>错误</h3><p>error</p><p>库例程通常需要向调用者返回某种类型的错误提示。之前提到过，Go语言的多值返回特性， 使得它在返回常规的值时，还能轻松地返回详细的错误描述。</p><p>按照约定，错误的类型通常为<code>error</code>，这是一个内建的简单接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>库的编写者通过更丰富的底层模型可以轻松实现这个接口，这样不仅能看见错误， 还能提供一些上下文。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PathError records an error and the operation and</span></span><br><span class="line"><span class="comment">// file path that caused it.</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op <span class="keyword">string</span>    <span class="comment">// "open", "unlink", etc.</span></span><br><span class="line">    Path <span class="keyword">string</span>  <span class="comment">// The associated file.</span></span><br><span class="line">    Err error    <span class="comment">// Returned by the system call.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Op + <span class="string">" "</span> + e.Path + <span class="string">": "</span> + e.Err.Error()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的错误信息例子</span></span><br><span class="line"><span class="comment">// open /etc/passwx: no such file or directory</span></span><br></pre></td></tr></table></figure><p>错误字符串应尽可能地指明它们的来源，例如产生该错误的包名前缀。若调用者关心错误的完整细节，可使用类型选择或者类型断言来查看特定错误，并抽取其细节。</p><p><br><br><br></p><h4 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h4><p>向调用者报告错误的一般方式就是将<code>error</code>作为额外的值返回。但如果错误时不可恢复的呢？有时程序就是不能继续运行。为此，我们提供了内建的<code>panic</code>函数，它会产生一个运行时错误并终止程序。该函数接受一个任意类型的实参（一般为字符串），并在程序终止时打印。 它还能表明发生了意料之外的事情，比如从无限循环中退出了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A toy implementation of cube root using Newton's method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CubeRoot</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    z := x/<span class="number">3</span>   <span class="comment">// Arbitrary initial value</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1e6</span>; i++ &#123;</span><br><span class="line">        prevz := z</span><br><span class="line">        z -= (z*z*z-x) / (<span class="number">3</span>*z*z)</span><br><span class="line">        <span class="keyword">if</span> veryClose(z, prevz) &#123;</span><br><span class="line">            <span class="keyword">return</span> z</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A million iterations has not converged; something is wrong.</span></span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"CubeRoot(%g) did not converge"</span>, x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的库函数应避免<code>panic</code>。若问题可以被屏蔽或解决， 最好就是让程序继续运行而不是终止整个程序。</p><p><br><br><br></p><h4 id="Recover"><a href="#Recover" class="headerlink" title="Recover"></a>Recover</h4><p>当<code>panic</code>被调用后，程序将立刻终止当前函数的执行，并开始回溯Go程的栈，运行任何被推迟的函数。 若回溯到达Go程栈的顶端，程序就会终止。不过我们可以用内建的<code>recover</code>函数来重新或来取回Go程的控制权限并使其恢复正常执行。</p><p>调用<code>recover</code>将停止回溯过程，并返回传入<code>panic</code>的实参。 由于在回溯时只有被推迟函数中的代码在运行，因此<code>recover</code>只能在被推迟的函数中才有效。</p><p>recover的一个应用就是在服务器中终止失败的Go程而无需杀死其它正在执行的Go程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(workChan &lt;-<span class="keyword">chan</span> *Work)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> work := <span class="keyword">range</span> workChan &#123;</span><br><span class="line">        <span class="keyword">go</span> safelyDo(work)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safelyDo</span><span class="params">(work *Work)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"work failed:"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    do(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此例中，若<code>do(work)</code>触发了Panic，其结果就会被记录， 而该Go程会被干净利落地结束，不会干扰到其它Go程。我们无需在推迟的闭包中做任何事情， <code>recover</code>会处理好这一切。</p><p>通过恰当地使用恢复模式，do函数（及其调用的任何代码）可通过调用 panic 来避免更坏的结果。我们可以利用这种思想来简化复杂软件中的错误处理。 让我们看看regexp包的理想化版本，它会以局部的错误类型调用 panic 来报告解析错误。以下是一个error类型的 Error方法和一个Compile函数的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error is the type of a parse error; it satisfies the error interface.</span></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Error)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error is a method of *Regexp that reports parsing errors by</span></span><br><span class="line"><span class="comment">// panicking with an Error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(regexp *Regexp)</span> <span class="title">error</span><span class="params">(err <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(Error(err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile returns a parsed representation of the regular expression.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(regexp *Regexp, err error)</span></span> &#123;</span><br><span class="line">    regexp = <span class="built_in">new</span>(Regexp)</span><br><span class="line">    <span class="comment">// doParse will panic if there is a parse error.</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            regexp = <span class="literal">nil</span>    <span class="comment">// Clear return value.</span></span><br><span class="line">            err = e.(Error) <span class="comment">// Will re-panic if not a parse error.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> regexp.doParse(str), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便一提，这种重新触发Panic的惯用法会在产生实际错误时改变Panic的值。 然而，不管是原始的还是新的错误都会在崩溃报告中显示，因此问题的根源仍然是可见的。 这种简单的重新触发Panic的模型已经够用了，毕竟他只是一次崩溃。 但若你只想显示原始的值，也可以多写一点代码来过滤掉不需要的问题，然后用原始值再次触发Panic。</p><p><br><br><br></p><h3 id="A-web-server"><a href="#A-web-server" class="headerlink" title="A web server"></a>A web server</h3><p>让我们以一个完整的Go程序作为结束吧，一个Web服务器。该程序其实只是个Web服务器的重用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"html/template"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addr = flag.String(<span class="string">"addr"</span>, <span class="string">":1718"</span>, <span class="string">"http service address"</span>) <span class="comment">// Q=17, R=18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> templ = template.Must(template.New(<span class="string">"qr"</span>).Parse(templateStr))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    http.Handle(<span class="string">"/"</span>, http.HandlerFunc(QR))</span><br><span class="line">    err := http.ListenAndServe(*addr, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QR</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    templ.Execute(w, req.FormValue(<span class="string">"s"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> templateStr = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">&lt;title&gt;QR Link Generator&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;if .&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;img src="http://chart.apis.google.com/chart?chs=300x300&amp;cht=qr&amp;choe=UTF-8&amp;chl=&#123;&#123;.&#125;&#125;" /&gt;</span></span><br><span class="line"><span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;.&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">&lt;br&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;form action="/" name=f method="GET"&gt;</span></span><br><span class="line"><span class="string">    &lt;input maxLength=1024 size=70 name=s value="" title="Text to QR Encode"&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=submit value="Show QR" name=qr&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>Go语言强大到能让很多事情以短小精悍的方式解决。</p><p><br><br><br><br><br></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>Diagnostics: <a href="https://golang.org/doc/diagnostics.html" target="_blank" rel="noopener">https://golang.org/doc/diagnostics.html</a></p><p>总结工具和方法来诊断Go程序</p><p><br></p><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>Go生态提供了一套API和工具来诊断go程序的逻辑和性能问题。本章总结了可用的工具，帮助用户去选择正确的工具来解决问题。</p><p>调试方案可分为一下几组：</p><ul><li><strong>Profiling</strong>： 分析工具分析go程序的复杂性和成本，如内存使用和调用函数的频率，以确定go程序的昂贵的部分；</li><li><strong>Tracing</strong>： 追踪是分析整个延迟和调用或用户请求的生命周期的一种方法；</li><li><strong>Debugging</strong>： 调试可以让我们暂停go程序，检查并执行。程序的状态和流程可通过调试进行验证；</li><li><strong>Runtime statistics and events</strong>： 收集和分析运行时状态和事件，提供go程序运行状态的高度概括。</li></ul><p><br><br><br></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>Profiling</p><p>对于识别昂贵的或频繁调用的代码部分，分析很有用。go runtime通过<code>pprof</code>可视化工具以格式化形式提供了分析数据。可通过<code>go test</code>或<code>net/http/pprof</code>包来收集分析数据。用户需要在代码顶级路径使用<code>pprof</code>工具来收集分析路径。</p><p>由<code>runtime/pprof</code>包预分析：</p><ul><li><strong>cpu</strong>: cpu porfile，报告程序花费的CPU时间。</li><li><strong>heap</strong>： heap profile，报告内存分配样本，监控当前和历史的内存使用，并检查内存泄漏。</li><li><strong>threadcreate</strong>： thread profile，报告程序的操作系统的线程创建部分。</li><li><strong>goroutine</strong>： goroutine profile，报告当前所有goroutine的栈追踪(stack trace)。</li><li><strong>block</strong>： block profile，报告goroutine在哪里等待同步原语(synchronization primitives)阻塞。此功能默认关闭，使用<code>runtime.SetBlockProfileRate</code>开启。</li><li><strong>mutex</strong>： mutex profile，报告锁的争用情况。当你认为由于互斥锁争用，CPU没有得到充分利用时，使用此功能。此功能默认关闭，使用<code>runtime.SetMutexProfileFraction</code>启用。</li></ul><p><br><br><br></p><h3 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h3><p>Tracing</p><p>追踪是一种来分析整个调用链的生命周期的延迟的方法。go提供了<code>golang.org/x/net/trace</code>包作为每个go节点的最小化追踪后端，并使用一个简单的面板来提供一个小型的仪器库。go还提供了一个可执行的追踪程序在内部追踪运行时事件。</p><p>追踪使我们能够：</p><ul><li>在go程序内工具和分析应用延迟。</li><li>衡量一个长链调用的特定调用的开销。</li><li>计算使用率和性能优化。</li></ul><p>go的生态提供了多种追踪库。</p><p><br><br><br></p><h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>Debugging</p><p>调试是识别一个程序行为不端的过程。调试器让我们了解程序的执行流程和当前状态。有几种调试风格，本章节将仅聚焦于一个调试器附加到一个程序和核心转储(core dump)调试。</p><p>go用户大多使用以下调试器：</p><ul><li><strong>(Delve)[<a href="https://github.com/go-delve/delve" target="_blank" rel="noopener">https://github.com/go-delve/delve</a>]</strong>： Delve是一个go lang调试器。它支持go runtime和内建类型。它正努力成为一个go程序的全功能可靠的调试器。</li><li><strong>(GDB)[<a href="https://golang.org/doc/gdb" target="_blank" rel="noopener">https://golang.org/doc/gdb</a>]</strong>： go通过标准的go编译器和Gccgo提供了GDB支持。尽管GDB可以用来调试go程序，但这不理想，可能导致混乱。</li></ul><p><br><br><br></p><h3 id="运行时统计数据和事件"><a href="#运行时统计数据和事件" class="headerlink" title="运行时统计数据和事件"></a>运行时统计数据和事件</h3><p>Runtime statistics and events</p><p>运行时(runtime)提供了统计信息和内部事件的报告，为用户在运行时级别诊断性能和利用率的问题。</p><p>用户可以监控这些数据，以便于更好地了解go程序的总体运行状况和性能。一些常用的监控统计数据和状态：</p><ul><li><code>runtime.ReadMemStats</code>： 报告与堆分配(heap allocation)和垃圾回收(garbage collection)相关的指标。内存统计数据对监控进程消耗了多少内存资源是有用的，进程是否能很好地利用内存，并捕捉到内存泄漏。</li><li><code>debug.ReadGCStats</code>： 阅读关于垃圾回收的统计数据。查看多少资源都花在了垃圾回收阶段也是很有用的。它还报告垃圾回收暂停和暂停事件百分数的时间线。</li><li><code>debug.Stack</code>： 返回当前的栈追踪。栈追踪对于查看有多少goroutine正在运行，它们在做什么，它们是否阻塞很有用。</li><li><code>debug.WriteHeapDump</code>： 中止所有goroutine的执行，并允许转存(dump)堆(heap)到文件。一个堆转存是go程序在特定时间内存的快照。它包含所有分配的对象，以及goroutine, finalizers…</li><li><code>runtime.NumGoroutine</code>： 返回当前的goroutine数量。该值可以被监测、以了解是否有足够的goroutine被利用，或检测goroutine泄漏。</li></ul><p><br><br><br></p><h4 id="执行追踪"><a href="#执行追踪" class="headerlink" title="执行追踪"></a>执行追踪</h4><p>Execution tracer</p><p>go使用runtime execution tracer来捕获广泛的运行时事件。调度、系统调用、垃圾回收、堆大小和其它收集的事件。执行追踪器是一个检测延迟和使用率问题的工具。你可以检查CPU如何利用，网络或系统调用时，抢占对goroutine的原因。</p><p>追踪器对这些有用：</p><ul><li>理解你的goroutine如何执行</li><li>理解一些核心(core)的运行时事件，如垃圾回收</li><li>确定不佳的并行执行</li></ul><p><br></p><p>然而，它不是很大用于识别热点（如分析内存溢出或CPU使用的原因）。使用分析工具而不是先定位它们。</p><p>详细信息查看<code>go tool trace</code>，来收集和分析运行时追踪。</p><p><br><br><br></p><h4 id="GODEBUG"><a href="#GODEBUG" class="headerlink" title="GODEBUG"></a>GODEBUG</h4><p>如果<code>GODEBUG</code>环境变量相应地设置，运行时也会发出事件和信息。</p><ul><li><code>GODEBUG=gctrace=1</code>： 在每个收集中打印垃圾回收器事件，汇总内存收集量和停顿的长度。</li><li><code>GODEBUG=schedtrace=X</code>： 每个x毫秒打印调度事件。</li></ul><p>GODEBUG环境变量可用于在标准库和运行时中禁用指令集扩展。</p><ul><li><code>GODEBUG=cpu.all=off</code>： 禁止使用所有可选的扩展指令集。</li><li><code>GODEBUG=cpu.extension=off</code>： 禁止从指定的指令集扩展中使用指令。</li></ul><p><br><br><br><br><br></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>docs: <a href="https://golang.org/doc/faq" target="_blank" rel="noopener">https://golang.org/doc/faq</a></p><p>有关go的常见问答。</p><p><br><br><br><br><br></p><h2 id="Go-wiki"><a href="#Go-wiki" class="headerlink" title="Go wiki"></a>Go wiki</h2><p>docs: <a href="https://github.com/golang/go/wiki" target="_blank" rel="noopener">https://github.com/golang/go/wiki</a></p><p>由GO社区维护的wiki。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>References</p><p><br><br><br></p><h2 id="包-1"><a href="#包-1" class="headerlink" title="包"></a>包</h2><p>Package Documentation: <a href="https://golang.org/pkg/" target="_blank" rel="noopener">https://golang.org/pkg/</a></p><p>Go标准库文档。</p><p><br><br><br><br><br></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>Command Documentation: <a href="https://golang.org/doc/cmd" target="_blank" rel="noopener">https://golang.org/doc/cmd</a></p><p>Go工具文档。</p><p><br><br><br><br><br></p><h2 id="语言规范"><a href="#语言规范" class="headerlink" title="语言规范"></a>语言规范</h2><p>Language Specification: <a href="https://golang.org/ref/spec" target="_blank" rel="noopener">https://golang.org/ref/spec</a></p><p>官方Go语言规范。</p><p><br><br><br></p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>The Go Memory Model: <a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github: &lt;a href=&quot;https://github.com/golang/go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/golang/go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docs: &lt;a href=&quot;https://golang.org/doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://golang.org/doc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;awesome-go: &lt;a href=&quot;https://github.com/avelino/awesome-go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/avelino/awesome-go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;版本:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;go v1.14&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Go" scheme="https://zhang21.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://zhang21.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://zhang21.github.io/2020/03/16/JavaScript/"/>
    <id>https://zhang21.github.io/2020/03/16/JavaScript/</id>
    <published>2020-03-16T08:02:10.000Z</published>
    <updated>2020-03-29T03:51:41.966Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>wiki: <a href="https://zh.wikipedia.org/zh-cn/JavaScript" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/JavaScript</a></li><li>W3school: <a href="https://www.w3school.com.cn/js/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/js/index.asp</a></li><li>廖雪峰：<a href="https://www.liaoxuefeng.com/wiki/1022910821149312" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1022910821149312</a></li></ul><p><br></p><p>环境：</p><ul><li>ELRH7x86_64</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Introduction</p><p>JavaScript(JS)是一种解释型的高级编程语言。JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。它提供语法来操控文本、数组、日期以及正则表达式等，不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。它已经由ECMA（欧洲电脑制造商协会）通过ECMAScript实现语言的标准化。它被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、IE、Firefox、Safari、Opera）支持。</p><p>虽然JavaScript与Java这门语言不管是在名字上，或是在语法上都有很多相似性，但这两门编程语言从设计之初就有很大的不同。为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。</p><p>JavaScript是世界上最流行的脚本语言，因为你在电脑、手机、平板上浏览的所有的网页，以及无数基于HTML5的手机App，交互逻辑都是由JavaScript驱动的。随着HTML5在PC和移动端越来越流行，JavaScript变得更加重要了。并且，新兴的Node.js把JavaScript引入到了服务器端，JavaScript已经变成了全能型选手。</p><p><br><br><br></p><h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><p>为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript标准。</p><p>所以简单说来就是，ECMAScript是一种语言标准，而JavaScript是网景公司对ECMAScript标准的一种实现。 JavaScript的标准是ECMAScript 。ECMAScript第一版标准发布于1997年。</p><p>那为什么不直接把JavaScript定为标准呢？因为JavaScript是网景的注册商标。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JS代码放到<code>&lt;head&gt;</code>中。由<code>&lt;script&gt;...&lt;/script&gt;</code>包含的代码就是JS代码，它将直接被浏览器执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    alert("hello, world");</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种方法是把JavaScript放到单独的<code>.js</code>文件，然后在HTML中通过<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>来引入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/static/js/hello.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将JS代码放入单独的文件中更有利于维护代码，并且多个页面可以复用。</p><p>在同一个页面中引入多个JS文件（或编写多个JS代码），浏览器将按照顺序依次执行。</p><p>有时会看到<code>&lt;script&gt;</code>有一个<code>type</code>属性。但其实这是没有必要的，以你为默认的<code>type</code>就是<code>javascript</code>，所以不必显式指定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">...</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p><code>console.log()</code>代替<code>alert()</code>的好处是可以避免弹出烦人的对话框。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在chrome中console中查看</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="如何运行JS"><a href="#如何运行JS" class="headerlink" title="如何运行JS"></a>如何运行JS</h2><p>要让浏览器运行JavaScript，必须先有一个HTML页面，在HTML页面中引入JavaScript。然后，然浏览器加载该HTML页面，就可以执行JavaScript代码。</p><p><br><br><br></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>每个语句以分号<code>;</code>结束，语句块使用花括号<code>{}</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不建议一行写多个语句</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 缩进不是JS语法要求所必须，但有助于我们理解代码层次。</span></span><br><span class="line"><span class="comment">   缩进通常是4个空格 */</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">    x = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>数字(Number)</li><li>字符串(String)</li><li>布尔(Bool)</li><li>空(Null)</li><li>未定义(Undefined)</li><li>Symbol: 独一无二的值</li><li>数组(Array)</li><li>对象(Object)</li><li>函数(Function)</li></ul><p><br></p><p>JS不区分整数和浮点数，统一用Number表示。<br><code>NaN</code>这个特殊的数字与所有其它值都不相等，包括它自己。</p><p>字符串以单引号或双引号括起来的任意文本。可通过转义字符()进行转义。</p><p>布尔值只有<code>true</code>和<code>false</code>两种值。</p><p><code>null</code>表示一个空值，如Python的<code>None</code>。<code>undefined</code>表示未定义。大多数情况下，我们都应该使用<code>null</code>，<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。<br><code>&#39;&#39;</code>表示长度为0的字符串。</p><p>数组使用<code>[]</code>表示，元素间用逗号<code>,</code>分隔。类似于Python的List，包括所索引、切片等操作。</p><p>对象是一组由键值组成的无序集合。类似于Python的Dictionary。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'A'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    tags: [<span class="string">'js'</span>, <span class="string">'html'</span>, <span class="string">'css'</span>],</span><br><span class="line">    hasCar: <span class="literal">true</span>,</span><br><span class="line">    zipCode: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h3><p>JavaScript的默认对象表示方式<code>{}</code>可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。</p><p>为了解决这个问题，最新的ES6规范引入了新的数据类型<code>Map</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'A'</span>: <span class="number">90</span>], [<span class="string">'b'</span>: <span class="number">80</span>]]);</span><br><span class="line">m.get(<span class="string">'A'</span>);</span><br><span class="line">m.set(<span class="string">'A'</span>, <span class="number">99</span>);</span><br><span class="line">m.has(<span class="string">'B'</span>);</span><br><span class="line">m.delete(<span class="string">'B'</span>);</span><br></pre></td></tr></table></figure><p><br></p><p>Set和Map类似，也是一组Key的集合，但不存储Value。没有重复的键。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="string">'A'</span>])</span><br><span class="line">s2.add(<span class="number">4</span>)</span><br><span class="line">s2.delete(<span class="string">'A'</span>)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><p>JavaScript拥有动态类型，这意味着相同的变量可哦你工作不同的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;  <span class="comment">// x为unfefined</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;  <span class="comment">// x为数字</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">"John"</span>;  <span class="comment">// x为字符串</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><code>&amp;&amp;</code></li><li><code>||</code></li><li><code>!</code></li><li><code>&gt;</code>, <code>&lt;</code></li><li><code>&gt;=</code>, <code>&lt;=</code></li><li><code>==</code>: 会自动转换数据类型再比较</li><li><code>===</code>: 不会自动转换数据类型，如果数据类型不一致，返回false；如果一致，再比较</li></ul><p>由于JS这个设计缺陷，不要使用<code>==</code>，始终坚持使用<code>===</code>。</p><p><br><br><br><br><br></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、<code>$</code>和<code>_</code>的组合，且不能用数字开头。变量名也不能是JavaScript的关键字。变量名也可以用中文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，只能用var申明一次</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">a = <span class="string">'ABC'</span>;</span><br><span class="line"><span class="comment">/* 变量本身类型不固定的语言称为动态语言</span></span><br><span class="line"><span class="comment">   与之相反的是静态语言，在定义变量时必须指定变量类型，如果类型不匹配，则会报错</span></span><br><span class="line"><span class="comment">   动态语言更灵活 */</span></span><br></pre></td></tr></table></figure><p>可使用关键字<code>new</code>来声明变量类型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="keyword">new</span> <span class="built_in">String</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Number</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Boolean</span>;</span><br><span class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> <span class="built_in">Array</span>;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>JavaScript在设计之初，为了便于学习，并不强制要求使用<code>var</code>声明变量。这个设计错误带来了严重的后果：如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为全局变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i现在是全局变量</span></span><br><span class="line">i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>在同一个页面的不同的JavaScript文件中，如果都不用<code>var</code>申明，恰好都使用了变量i，将造成变量i互相影响，产生难以调试的错误结果。<br>使用<code>var</code>申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内，同名变量在不同的函数体内互不冲突。</p><p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了严格(strict)模式，在strict模式下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。<br>不用<code>var</code>申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。我们在后面编写的JavaScript代码将全部采用strict模式。</p><p>启用strict模式的方法是在JavaScript代码的第一行写上：<code>&#39;use strict&#39;;</code></p><p><br><br><br><br><br></p><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> () &#123;</span><br><span class="line">    xxx;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    xxxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    xx;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (conditon) &#123;</span><br><span class="line">    xxx;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    xxxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (age&gt;=<span class="number">18</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'adult'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'kid'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'teenager'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>JavaScript把<code>null</code>, <code>undefined</code>, <code>0</code>, <code>NaN</code>, <code>&#39;&#39;</code>视为<code>fasle</code>，其它一概视为<code>true</code>。</p><p><br></p><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于alert的弹窗输入</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="built_in">parseFloat</span>(prompt(<span class="string">'请输入身高(m):'</span>));</span><br><span class="line"><span class="keyword">var</span> weight = <span class="built_in">parseFloat</span>(prompt(<span class="string">'请输入体重(kg):'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bmi = weight / height*height;</span><br><span class="line"><span class="built_in">console</span>.log(bmi);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bmi &lt; <span class="number">18.5</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"过轻"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">25</span> &gt; bmi &gt;= <span class="number">18.5</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"正常"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">32</span> &gt; bmi &gt;= <span class="number">25</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"过重"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"肥胖"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul><li><code>for</code></li><li><code>while</code></li><li><code>do...while</code></li></ul><p><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">    x = x + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// for 索引</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>];</span><br><span class="line"><span class="keyword">var</span> i, x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">    x = arr[i];</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;for in</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    <span class="built_in">console</span>.log(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    x = x + n;</span><br><span class="line">    n = n <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x)</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do...while</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (n &lt; <span class="number">100</span>);  <span class="comment">// &gt;哈哈</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(n);</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h2><p>遍历<code>Array</code>可以采用下标循环，遍历<code>Map</code>和<code>Set</code>就无法使用下标。为了统一集合类型，ES6标志引入了新的<code>iterable</code>类型，Array, Map, Set都属于<code>iterable</code>类型。</p><p>具有<code>iterable</code>类型的集合可以通过新的<code>for...of</code>循环来遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123; <span class="comment">// 遍历Array</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123; <span class="comment">// 遍历Set</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123; <span class="comment">// 遍历Map</span></span><br><span class="line">    <span class="built_in">console</span>.log(x[<span class="number">0</span>] + <span class="string">'='</span> + x[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Function</p><p>借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。</p><p><br><br><br></p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>JavaScript中，定义函数的方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="comment">// 注意赋值语句结束需要;</span></span><br><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">abs(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由于JS允许传入任意个参数而不影响调用，</span></span><br><span class="line"><span class="comment">   因此传入的参数比定义的参数多也没有问题。</span></span><br><span class="line"><span class="comment">   虽然函数内部并不需要这些参数。 */</span></span><br><span class="line">abs(<span class="number">10</span>, <span class="string">'haha'</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><br></p><p>JS还有一个免费赠送的关键字<code>arguments</code>，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。<br>实际上<code>arguments</code>最常用于判断传入参数的个数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x : -x :</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>ES6标准引入了<code>rest</code>参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Array [3, 4]</span></span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// Array []</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>在JavaScript中，用<code>var</code>申明的变量实际上是有作用域的。<br>如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量。</p><p><br><br><br></p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>虽然JavaScript的函数有一个<strong>变量提升</strong>的特点，它会先扫描整个函数体的语句，把所有申明的变量提升到函数顶部。但我们在函数内部定义变量时，请在函数内部首先申明所有变量。</p><p><br><br><br></p><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象<code>window</code>，全局作用域实际上被绑定到<code>window</code>的一个属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> course = <span class="string">'JavaScript'</span>;</span><br><span class="line">alert(course);</span><br><span class="line">alert(<span class="built_in">window</span>.course);</span><br></pre></td></tr></table></figure><p>这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报<code>ReferenceError</code>错误。</p><p><br><br><br></p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>全局变量会绑定到<code>window</code>上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p><p>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唯一的全局变量MYAPP</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">MYAPP.name = <span class="string">'myapp'</span>;</span><br><span class="line">MYAPP.version = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把自己的代码全部放入唯一的命名空间<code>MYAPP</code>中，会大大减少全局变量冲突的可能。<br>许多著名的JS库都是这么做的：jQuery, YUI等等。</p><p><br><br><br></p><h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>由于JavaScript的变量作用域实际上是函数内部，我们在<code>for</code>循环等语句块中是无法定义具有局部作用域的变量的。</p><p>为了解决块级作用域，ES6引入了新的关键字<code>let</code>，用<code>let</code>替代<code>var</code>可以申明一个块级作用域的变量。</p><p><br><br><br></p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>由于<code>var</code>和<code>let</code>申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示这是一个常量，不要修改它的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><p>ES6标准引入了新的关键字<code>const</code>来定义常量，<code>const</code>和<code>let</code>都具有块级作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">3</span>; <span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。</p><p>使用解构赋值可以减少代码量，但是，需要在支持ES6解构赋值特性的现代浏览器中才能正常运行。</p><p><br><br><br><br><br></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在一个对象中绑定函数，称为这个对象的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'Ming'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">        <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，有一个<code>this</code>关键字。在一个方法内部，<code>this</code>是一个特殊变量，它始终指向当前对象，也就是<code>xiaoming</code>这个变量。</p><p><br></p><p>我们可以控制<code>this</code>的指向。要确定函数的<code>this</code>指向哪个对象，可以用函数本身的<code>apply</code>方法，它接收两个参数，第一个参数就是需要绑定的<code>this</code>变量，第二个参数是<code>Array</code>，表示函数本身的参数。</p><p>另一个与<code>apply()</code>类似的方法是<code>call()</code>，唯一区别是：</p><ul><li><code>apply()</code>把参数打包成<code>Array</code>再传入；</li><li><code>call()</code>把参数按顺序传入。</li></ul><p>栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Math.max(3, 5, 4)</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>对普通函数调用，我们通常把<code>this</code>绑定为<code>null</code>。</p><p><br><br><br></p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>利用<code>apply()</code>，我们还可以动态改变函数的行为。</p><p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。</p><p><br><br><br><br><br></p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数(Higher order function)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f(x) + f(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">-5</span>, <span class="number">6</span>, <span class="built_in">Math</span>.abs)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p><code>map()</code>方法定义在JS的<code>Array</code>中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x * x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.map(pow); <span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><p><br></p><p><code>reduce()</code>把结果继续和序列的下一个元素做累积计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;); <span class="comment">// 17</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter()</code>它用于把<code>Array</code>的某些元素过滤掉，然后返回剩下的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保留奇数</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x % <span class="number">2</span> !== <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>JavaScript的<code>Array</code>的<code>sort()</code>方法就是用于排序的，但它默认把所有元素先转换为String再排序，如果不知道这个，那么用它直接对数字排序会栽进坑里。</p><p><br><br><br></p><h3 id="其它高阶函数"><a href="#其它高阶函数" class="headerlink" title="其它高阶函数"></a>其它高阶函数</h3><p><code>Array</code>对象还提供了许多非常实用的高阶函数：</p><ul><li><code>every()</code>: 判断数组的所有元素是否满足测试条件</li><li><code>find()</code>: 查找符合条件的第一个元素，如果找到了，返回这个元素；否则，返回<code>undefined</code></li><li><code>findIndex()</code>: 它返回查找元素的索引</li><li><code>forEach</code>: 把每个元素依次作用于传入的函数，但不会返回新的数组。常用于遍历数组</li></ul><p><br><br><br><br><br></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。直观的说就是形成一个不销毁的栈环境。</p><p><br><br><br><br><br></p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6新增了一种新的函数：<strong>箭头函数(Arrow Function)</strong>。<br>感觉有点类似于Python的lambda。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrow function</span></span><br><span class="line">x =&gt; x * x</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>其它用法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数</span></span><br><span class="line">(x, y) =&gt; (x * x) + (y * y)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数</span></span><br><span class="line">() =&gt; <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">    xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象</span></span><br><span class="line">x =&gt; (&#123;<span class="attr">foo</span>: x&#125;)</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p><strong>生成器(generator)</strong>是ES6标准引入的新的数据类型。一个生成器看上去像一个函数，但可以返回多次。<br>同样类似于Python的生成器，还记得<code>next</code>和<code>yield</code>吗？哈哈。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator 斐波那契数列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fib</span>(<span class="params">max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span></span><br><span class="line">         t,</span><br><span class="line">         a = <span class="number">0</span>,</span><br><span class="line">         b = <span class="number">1</span>,</span><br><span class="line">         n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; max) &#123; <span class="comment">//&gt;haha</span></span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a+b];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用生成器和调用函数不一样，仅仅是创建了一个生成器对象，还没有去执行它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 第一种方法：不断调用生成器对象的next()方法，需要判断是否done</span><br><span class="line">var f = fib(5);</span><br><span class="line">f.next();</span><br><span class="line">f.next();</span><br><span class="line">...</span><br><span class="line">f.next()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 第二种方法：for ... of循环迭代生成器对象</span><br><span class="line">for (var x of fib(10)) &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h1><p>在JavaScript的世界里，一切都是对象。但某些对象还是和其它对象不一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof 获取对象类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure><p>JS还提供了包装对象，熟悉Java的小伙伴肯定很清楚<code>int</code>和<code>Integer</code>这种暧昧关系。<br>虽然包装对象看上去和原来的值一摸一样，但是它们的类型已经变为<code>object</code>了。所以，闲的蛋疼也不要使用包装对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包装对象用 new 创建</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) === <span class="number">123</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>在JavaScript中，<code>Date</code>对象用来表示日期和时间。<br>注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。</p><blockquote><p>JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></span><br><span class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></span><br><span class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个日期对象</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">123</span>);</span><br><span class="line">d; <span class="comment">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或ISO 8601格式</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Date</span>.parse(<span class="string">'2015-06-24T19:49:22.875+08:00'</span>);</span><br><span class="line">d; <span class="comment">// 1435146562875</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或时间戳</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1435146562875</span>);</span><br><span class="line">d; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">d.getMonth(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>时区</strong></p><p><code>Date</code>对象表示的时间总是按浏览器所在的时区显示，不过我们既可以显示本地时间，也可以显示调整后的UTC时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1435146562875</span>);</span><br><span class="line">d.toLocaleString(); <span class="comment">// '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关</span></span><br><span class="line">d.toUTCString(); <span class="comment">// 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><p>强大的正则表达式！</p><p>了解了基本的RE知识，我们就可以在JavaScript中使用正则表达式了。JS有两种方式创建一个正则表达式：</p><ul><li><code>/正则表达式/</code></li><li><code>new RegExp(&#39;正则表达式&#39;)</code>，创建一个RegExp对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ABC\-001/</span>;</span><br><span class="line"><span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ABC\\-001'</span>); <span class="comment">// 使用了转义字符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试正则</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^$d&#123;3&#125;\-\d&#123;3, 8&#125;$/</span>;</span><br><span class="line">re.test(<span class="string">'010-12345'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>切分字符串</strong></p><p>用正则表达式切分字符串比用固定的字符更灵活。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a b   c'</span>.split(<span class="string">' '</span>); <span class="comment">// ['a', 'b', '', '', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="string">'a b   c'</span>.split(<span class="regexp">/\s+/</span>); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>分组</strong></p><p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是要提取的分组（Group）。</p><p>如果正则表达式中定义了组，就可以在RegExp对象上用<code>exec()</code>方法提取出子串来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span>;</span><br><span class="line">re.exec(<span class="string">'010-12345'</span>); <span class="comment">// ['010-12345', '010', '12345']</span></span><br><span class="line">re.exec(<span class="string">'010 12345'</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>贪婪匹配</strong></p><p>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪婪匹配</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '102300', '']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非贪婪匹配</span></span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '1023', '00']</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>全局搜索</strong></p><p>JavaScript的正则表达式还有几个特殊的标志，最常用的是<code>g</code>，表示全局匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/test/g</span>;</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'test'</span>, <span class="string">'g'</span>);</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是JavaScript Object Notation的缩写，它是一种轻量级的数据交换格式。</p><p>在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。</p><p>JSON实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型：</p><ul><li>number</li><li>boolean</li><li>string</li><li>null</li><li>array</li><li>object</li></ul><p>JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。为了统一解析，JSON的字符串规定必须用双引号<code>&quot;&quot;</code>，Object的键也必须用双引号<code>&quot;&quot;</code>。</p><p>由于JSON非常简单，很快就风靡Web世界，并且成为ECMA标准。几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。</p><p>把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。<br>如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。</p><p><br></p><p><strong>序列化</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript object to JSON</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'xiaoming'</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    skills: [<span class="string">'JS'</span>, <span class="string">'Java'</span>, <span class="string">'Python'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringift(xiaoming);</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure><p><br></p><p><strong>反序列化</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON to JavaScript object</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>); <span class="comment">// Object &#123;name: '小明', age: 14&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>JavaScript的面向对象编程和大多数其他语言如Java、C#的面向对象编程都不太一样。面向对象的两个基本概念：</p><ul><li>类：类是对象的模板</li><li>实例：根据类创建的对象</li></ul><p>所以，类和实例是大多数面向对象编程语言的基本概念。</p><p>不过，在JavaScript中，这个概念需要改一改。JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。<br>JavaScript没有类的概念，所有对象都是实例。所谓继承关系不过是把一个对象的原型指向另一个对象而已。</p><p><br><br><br></p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。</p><p>当我们用<code>obj.xxx</code>访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到<code>Object.prototype</code>对象，最后，如果还没有找到，就只能返回<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Array对象</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链</span></span><br><span class="line">arr ----&gt; <span class="built_in">Array</span>.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>构造函数</strong></p><p>JavaScript还可以用一种构造函数的方法来创建对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这确实是一个普通函数，但在JavaScript中，可以用关键字new来调用这个函数，并返回一个对象</span></span><br><span class="line"><span class="comment">// 写了new， 它就变成了一个构造函数</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'小明'</span>);</span><br><span class="line">xiaoming.name;</span><br><span class="line">xiaoming.hello();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// xiaoming的原型链</span></span><br><span class="line">xiaoming ----&gt; Student.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>要让创建的对象共享一个函数，根据对象的属性查找规则，我们只需要把此函数移动到这些对象的原型上就可以了，也就是<code>xxx.prototype</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写。</p><p><br><br><br></p><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>在传统的基于类的语言中，继承的本质是扩展一个已有的类(class)，并生成新的子类(subclass)。</p><p>但是，由于JavaScript采用原型继承，我们无法直接扩展一个类，因为根本不存在类。</p><p>JavaScript的原型继承方式是：</p><ul><li>定义新的构造函数，并在内部用<code>call()</code>调用希望继承的构造函数，并绑定<code>this</code></li><li>借助中间函数<code>F</code>实现原型继承，最好通过封装的<code>inherits</code>函数完成</li><li>继续在新的构造函数的原型上定义新方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = props.name || <span class="string">'Unnamed'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// PrimaryStudent构造函数:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    Student.call(<span class="keyword">this</span>, props);</span><br><span class="line">    <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空函数F:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把F的原型指向Student.prototype:</span></span><br><span class="line">F.prototype = Student.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:</span></span><br><span class="line">PrimaryStudent.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:</span></span><br><span class="line">PrimaryStudent.prototype.constructor = PrimaryStudent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：</span></span><br><span class="line">PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建xiaoming:</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> PrimaryStudent(&#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    grade: <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line">xiaoming.name; <span class="comment">// '小明'</span></span><br><span class="line">xiaoming.grade; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证原型:</span></span><br><span class="line">xiaoming.__proto__ === PrimaryStudent.prototype; <span class="comment">// true</span></span><br><span class="line">xiaoming.__proto__.__proto__ === Student.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证继承关系:</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> PrimaryStudent; <span class="comment">// true</span></span><br><span class="line">xiaoming <span class="keyword">instanceof</span> Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h2><p>JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。</p><p>但有更简单的写法。在ES6标准中，新的关键字<code>class</code>正式被引入到JavaScript中。它的目的就是让定义类更简单。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class的定义包含了构造函数constructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    hello() &#123;</span><br><span class="line">        alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'小明'</span>);</span><br><span class="line">xiaoming.hello();</span><br></pre></td></tr></table></figure><p>用<code>class</code>定义对象的另一个巨大好处是继承更方便了。不需要写大量的中间对象，直接通过<code>extends</code>来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, grade) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name); <span class="comment">// 记得用super调用父类的构造方法!</span></span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">    myGrade() &#123;</span><br><span class="line">        alert(<span class="string">'I am at grade '</span> + <span class="keyword">this</span>.grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意浏览器是不是支持ES6的class。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>由于JavaScript的出现就是为了能在浏览器中运行，所以，浏览器自然是JavaScript开发者必须要关注的。</p><p>目前，主流浏览器分这几种：</p><ul><li>IE 6-11：从IE 10开始支持ES6；</li><li>Chrome：Google出品的基于Webkit内核，内置非常强悍的JS引擎——V8。支持ES6；</li><li>Safari：Mac自带的基于Webkit内核，支持ES6；</li><li>Firefox：Mozilla研制的Gecko内核和JS引擎OdinMonkey。支持ES6；</li><li>移动设备(IOS/Android)：支持ES6</li></ul><p><br></p><p>不同的浏览器对JavaScript支持的差异主要是，有些API的接口不一样，比如AJAX，File接口。对于ES6标准，不同的浏览器对各个特性支持也不一样。</p><p>在编写JavaScript的时候，就要充分考虑到浏览器的差异，尽量让同一份JavaScript代码能运行在不同的浏览器中。</p><p><br><br><br></p><h2 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h2><p>JavaScript可以获取浏览器提供的很多对象，并进行操作。</p><p><br></p><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p><code>window</code>对象不但充当全局作用域，而且表示浏览器窗口。属性：</p><ul><li><code>innerWidth</code>：浏览器窗口的内部宽度</li><li><code>innerHeight</code>：内部高度</li><li><code>outerWidth</code>: 浏览器窗口整个宽度</li><li><code>outerHeight</code>: 整个高度</li></ul><p>内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以调整浏览器窗口大小，进行测试</span></span><br><span class="line">cosole.log(<span class="string">'window inner size: '</span> + <span class="built_in">window</span>.innerWidth + <span class="string">'x'</span> + <span class="built_in">window</span>.innerHeight);</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h3><p><code>navigator</code>表示浏览器的信息，最常用的属性包括：</p><ul><li><code>appName</code>：浏览器名称；</li><li><code>appVersion</code>：浏览器版本；</li><li><code>language</code>：浏览器设置的语言；</li><li><code>platform</code>：操作系统类型；</li><li><code>userAgent</code>：浏览器设置的User-Agent字符；</li></ul><p>请注意，navigator的信息可以轻易的被用户修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'appName = '</span> + navigator.appName);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'appVersion = '</span> + navigator.appVersion);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'language = '</span> + navigator.language);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'platform = '</span> + navigator.platform);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'userAgent = '</span> + navigator.userAgent);</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p><code>screen</code>对象表示屏幕的信息，常用的属性有：</p><ul><li><code>width</code>：屏幕宽度(px)；</li><li><code>height</code>：屏幕高度(px)；</li><li><code>colorDepth</code>：颜色位数；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Screen size = '</span> + screen.width + <span class="string">' x '</span> + screen.height);</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p><code>location</code>对象表示当前页面的URL信息。</p><ul><li><code>href</code>：完整的URL</li><li><code>protocol</code>：协议</li><li><code>host</code>: 主机名</li><li><code>port</code>：端口</li><li><code>pathname</code>： 路径</li><li><code>search</code>： 参数</li><li><code>hash</code>：</li><li><code>assign()</code>：加载一个新页面</li><li><code>reload()</code>：重载当前页面</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (confirm(<span class="string">'重新加载当前页'</span> + location.href + <span class="string">'?'</span>)) &#123;</span><br><span class="line">    location.reload();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    location.assign(<span class="string">'/'</span>); <span class="comment">// 设置一个新的URL地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="document"><a href="#document" class="headerlink" title="document"></a>document</h3><p><code>document</code>对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，<code>document</code>对象就是整个DOM树的根节点。</p><ul><li><code>title</code></li><li><code>getElementById()</code>：按id获得一个DOM节点；</li><li><code>getElementsByTagName()</code>：按tag获得一个DOM节点；</li><li><code>getElementsByClassName()</code></li><li><code>cookie</code>：为了确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// document.title属性从HTML文档中&lt;title&gt;xxx&lt;/title&gt;读取，但可以动态改变</span></span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">'DOM title'</span>;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p><code>history</code>保存了浏览器的历史记录，JavaScript可以调用<code>history()</code>对象的<code>back()</code>或<code>forward()</code>。<br>这个对象属于历史遗留问题，任何情况，你都不应该使用<code>history</code>这个对象。</p><p><br><br><br><br><br></p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p><strong>DOM(文档对象模型, document object model)</strong>，是W3C(万维网联盟)的标准。它定义了访问HTML和XML文档的标准。</p><p>由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。</p><p><br></p><p>DOM节点有几个操作：</p><ul><li>更新</li><li>遍历</li><li>添加</li><li>删除</li></ul><p>在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。常用的方法：</p><ul><li><code>document.getElementById()</code>：由于ID在HTML文档中是唯一的，所以可以直接定位唯一的一个DOM节点。</li><li><code>document.getElementsByTagName()</code>：返回一组DOM节点</li><li><code>document.getElementsByClassName()</code>：要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围</li><li><code>document.querySelector()</code></li><li><code>document.queryAelectorAll()</code></li></ul><p><br><br><br></p><h3 id="更新DOM"><a href="#更新DOM" class="headerlink" title="更新DOM"></a>更新DOM</h3><p>拿到DOM节点后，我们可以对它进行更新。可以直接修改节点文本，方法有两种：</p><p>一种是修改<code>innerHTML</code>属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树。<br>用innerHTML时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.innerHTML = <span class="string">'ABC'</span>; <span class="comment">// &lt;p id="p-id"&gt;ABC&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.innerHTML = <span class="string">'ABC &lt;span style="color:red"&gt;RED&lt;/span&gt; XYZ'</span>;</span><br><span class="line"><span class="comment">// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</span></span><br></pre></td></tr></table></figure><p>第二种是修改<code>innerText</code>或<code>textContent</code>属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置文本:</span></span><br><span class="line">p.innerText = <span class="string">'&lt;script&gt;alert("Hi")&lt;/script&gt;'</span>;</span><br><span class="line"><span class="comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span></span><br><span class="line"><span class="comment">// &lt;p id="p-id"&gt;&amp;lt;script&amp;gt;alert("Hi")&amp;lt;/script&amp;gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><p>两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本。因为CSS允许<code>font-size</code>这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名<code>fontSize</code>。</p><p><br></p><p>修改CSS也是经常需要的操作。DOM节点的<code>style</code>属性对应所有的CSS，可以直接获取或设置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置CSS:</span></span><br><span class="line">p.style.color = <span class="string">'#ff0000'</span>;</span><br><span class="line">p.style.fontSize = <span class="string">'20px'</span>;</span><br><span class="line">p.style.paddingTop = <span class="string">'2em'</span>;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="插入DOM"><a href="#插入DOM" class="headerlink" title="插入DOM"></a>插入DOM</h3><p>如果DOM节点是空的，那么，直接使用<code>innerHTML = &lt;x&gt;aaa&lt;/x&gt;</code>就可以修改DOM节点的内容，相当于插入了新的DOM节点。</p><p>如果DOM节点不是空，则不能这样做。有两个新办法。</p><p>一个是使用<code>appendChild</code>：把一个子节点添加到父节点的最后一个子节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    js = <span class="built_in">document</span>.getElementById(<span class="string">'js'</span>),</span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list);</span></span><br><span class="line"><span class="string">list.append(js);</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更多的时候，我们会从零创建一个新的节点，然后插入到指定位置</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">haskell.id = <span class="string">'haskell'</span>;</span><br><span class="line">haskell.innerText = <span class="string">'Haskell'</span>;</span><br><span class="line">list.appendChild(haskell);</span><br></pre></td></tr></table></figure><p>动态创建一个节点，然后田间道DOM树中，可以实现很多功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line">d.setAttribute(<span class="string">'type'</span>, <span class="string">'text/css'</span>);</span><br><span class="line">d.innerHTML = <span class="string">'p &#123;color: red&#125;'</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(d);</span><br></pre></td></tr></table></figure><p>这个栗子更改了颜色。可在浏览器的console上执行来看效果。</p><p><br></p><p><strong>insertBefore</strong></p><p>使用<code>parentElement.insertBefore(newElement, referenceElement);</code>，子节点会插入到<code>referenceElement</code>之前。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>),</span><br><span class="line">    ref = <span class="built_in">document</span>.getElementById(<span class="string">'python'</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">haskell.id = <span class="string">'haskell'</span>;</span><br><span class="line">haskell.innerText = <span class="string">'Haskell'</span>;</span><br><span class="line">list.insertBefore(haskell, ref);</span><br></pre></td></tr></table></figure><p>可见，使用<code>insertBefore</code>重要的是拿到一个参考子节点的引用。很多时候，需要循环一个父节点的所有字节嗲，可以通过<code>children</code>属性实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    i, c,</span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; list.children.length; i++) &#123; <span class="comment">//&gt;haha</span></span><br><span class="line">    c = list.children[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="删除DOM"><a href="#删除DOM" class="headerlink" title="删除DOM"></a>删除DOM</h3><p>要删除一个节点，首先要获得该节点本身以及它的父节点。然后，调用父节点的<code>removeChild</code>把自己删掉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到待删除节点:</span></span><br><span class="line"><span class="keyword">var</span> self = <span class="built_in">document</span>.getElementById(<span class="string">'to-be-removed'</span>);</span><br><span class="line"><span class="comment">// 拿到父节点:</span></span><br><span class="line"><span class="keyword">var</span> parent = self.parentElement;</span><br><span class="line"><span class="comment">// 删除:</span></span><br><span class="line"><span class="keyword">var</span> removed = parent.removeChild(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意，删除后的节点虽不在文档树中，但其实它还在内存中，可以随时在此被添加到别的位置。</p><p>当你遍历一个父节点的子节点并进行删除操作时，要注意，<code>children</code>属性是一个只读属性，并且它在子节点变化时会实时更新。因此，删除多个节点时，要注意<code>children</code>属性时刻都在变化。</p><p><br><br><br><br><br></p><h2 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h2><p>用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。</p><p>不过，表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。</p><p>HTML表单的输入控件主要有以下几种：</p><ul><li>文本框：<code>&lt;input type=&quot;text&quot;&gt;</code>;</li><li>口令框：<code>&lt;input type=&quot;password&quot;&gt;</code>;</li><li>单选框：<code>&lt;input type=&quot;radio&quot;&gt;</code>;</li><li>复选框：<code>&lt;input type=&quot;checkbox&quot;&gt;</code>;</li><li>下拉框：<code>&lt;select&gt;</code>;</li><li>隐藏文本，用户不可见，但表单提交时会把隐藏文本发送到服务器: <code>input type=&quot;hidden&quot;&gt;</code>。</li></ul><p><br><br><br></p><h3 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h3><p>如果我们获取了一个<code>&lt;input&gt;</code>节点的引用，就可以调用<code>value</code>获得对应的用户输入值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type="text" id="email"&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'email'</span>);</span><br><span class="line">input.value; <span class="comment">// '用户输入的值'</span></span><br></pre></td></tr></table></figure><p>这种方式可以用于text, password, hidden, select。但是，对于单选框和复选框，<code>value</code>属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否勾上了选项，所以应该用<code>checked</code>判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;label&gt;&lt;input type="radio" name="weekday" id="monday" value="1"&gt; Monday&lt;/label&gt;</span></span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type="radio" name="weekday" id="tuesday" value="2"&gt; Tuesday&lt;/label&gt;</span></span><br><span class="line"><span class="keyword">var</span> mon = <span class="built_in">document</span>.getElementById(<span class="string">'monday'</span>);</span><br><span class="line"><span class="keyword">var</span> tue = <span class="built_in">document</span>.getElementById(<span class="string">'tuesday'</span>);</span><br><span class="line">mon.value; <span class="comment">// '1'</span></span><br><span class="line">tue.value; <span class="comment">// '2'</span></span><br><span class="line">mon.checked; <span class="comment">// true或者false</span></span><br><span class="line">tue.checked; <span class="comment">// true或者false</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h3><p>对于text, password, hidden, select，直接设置<code>value</code>就可以。对于单/复选框，设置<code>checked</code>为<code>true</code>或<code>false</code>即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type="text" id="email"&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'email'</span>);</span><br><span class="line">input.value = <span class="string">'test@example.com'</span>; <span class="comment">// 文本框的内容已更新</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="HTML5控件"><a href="#HTML5控件" class="headerlink" title="HTML5控件"></a>HTML5控件</h3><p>HTML5新增了大量标准空间，常用的包括date, datetime, datetime-local, color…，它们都使用<code>&lt;input&gt;</code>标签。</p><p>不支持HTML5的浏览器无法识别新的控件，会把它们当做<code>type=&quot;text&quot;</code>来显示。支持HTML5的浏览器将获得格式化的字符串。</p><p><br><br><br></p><h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><p>最后，JavaScript可以以两种方式来处理表单的提交（AJAX方式在后面介绍）。</p><p>一是通过<code>&lt;form&gt;</code>元素的<code>submit()</code>方法提交一个表单。这种方式的缺点是扰乱了浏览器对form的正常提交。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test-form"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"doSubmitForm()"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">doSubmitForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可在此修改form的input</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 提交form</span></span></span><br><span class="line"><span class="undefined">    form.submit();</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种方式是响应<code>&lt;form&gt;</code>本身的<code>onsubmit</code>事件，在提交form时作修改：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test-form"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-id'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意要<code>return true</code>来告诉浏览器继续提交，如果<code>return false</code>，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。</p><p>在检查和修改<code>&lt;input&gt;</code>时，要充分利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>来传递数据。例如，很多登录表单希望用户输入的口令（出于安全考虑）在提交表单时不传输明文口令，而是口令的MD5。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"login-form"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> pwd = <span class="built_in">document</span>.getElementById(<span class="string">'password'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// to MD5</span></span></span><br><span class="line"><span class="undefined">    pwd.value = toMD5(pwd.value);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样做看上去没问题，但用户输入了口令提交时，口令框突然会从几个<code>*</code>变为32个<code>**</code>（MD5有32个字符）。若不想改变用户的输入，可利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"login-form"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"input-password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">id</span>=<span class="string">"md5-password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'input-password'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> md5_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'md5-password'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 把用户输入的明文变为MD5:</span></span></span><br><span class="line"><span class="undefined">    md5_pwd.value = toMD5(input_pwd.value);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>没有<code>name</code>属性的<code>&lt;input&gt;</code>的数据不会被提交。</p><p><br><br><br><br><br></p><h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><p>在HTML表单中，可以上传文件的唯一控件就是<code>&lt;input type=&quot;file&quot;&gt;</code>。</p><blockquote><p>注意：当一个表单包含<code>&lt;input type=&quot;file&quot;&gt;</code>时，表单的<code>enctype</code>必须指定为<code>multipart/form-data</code>，<code>method</code>必须指定为<code>post</code>，浏览器才能正确编码并以<code>multipart/form-data</code>格式发送表单的数据。</p></blockquote><p>处于安全考虑，浏览器只允许用户点击<code>&lt;input type=&quot;file&quot;&gt;</code>来选择本地文件，用JavaScript对<code>&lt;input type=&quot;file&quot;&gt;</code>的<code>value</code>赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径。</p><p>通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件的扩展名做检查，以便防止用户上传无效格式的文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.getElementById(<span class="string">'file-upload'</span>);</span><br><span class="line"><span class="keyword">var</span> filename = f.value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!filename || !(filename.endsWith(<span class="string">'.jpg'</span>)) || filename.endsWith(<span class="string">'.png'</span>) || filename.endsWith(<span class="string">'.gif'</span>)) &#123;</span><br><span class="line">    alert(<span class="string">"Can only upload image file."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>File API</strong></p><p>由于JavaScript对用户上传的文件操作非常有限，尤其是无法读取文件内容，使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现。</p><p>随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。HTML5的File API提供了<code>File</code>和<code>FileReader</code>两个主要对象，可以获得文件信息并读取文件。</p><p><br></p><p><strong>回调</strong></p><p>在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。</p><p>你可能会问，单线程模式执行的JavaScript，如何处理多任务？在JavaScript中，执行多任务实际上都是异步调用。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 操作完成后，自动调用此函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>AJAX(Asynchronous JavaScript and XML)不是JavaScript的规范，意思是用JavaScript执行异步网络请求。</p><p>如果仔细观察一个Form的提交，你就会发现，一旦用户点击Submit按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p><p>这就是Web的运作原理：一次HTTP请求对应一个页面。</p><p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p><p>最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。</p><p>用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'response-text'</span>);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'response-text'</span>);</span><br><span class="line">    textarea.value = <span class="string">'Error code: '</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 新建XMLHttpRequest对象</span></span><br><span class="line"></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (rquest.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断相应结果</span></span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/api/categories'</span>);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">'请求已发送，请等待响应...'</span>);</span><br></pre></td></tr></table></figure><p><br></p><p><strong>安全限制</strong></p><p>上面代码的URL使用的是相对路径。如果你把它改为<code>http://xxx.com/</code>，再运行，肯定会报错。在console里，还可以看到错误信息。</p><p>这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。</p><p>那是不是JavaScript无法请求外域（其它网站）的URL了呢？方法还是有的：</p><ul><li>一是通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。</li><li>二是通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器。代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。</li><li>三是JSONP。它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源。</li></ul><p><br></p><p><strong>CORS</strong></p><p>如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS(Cross-Origin Resource Sharing)，它是HTML5规范定义的如何跨域访问资源。</p><p>了解CORS前，我们先搞明白概念。Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域发起请求后，浏览器收到响应后，首先检查<code>Access-Control-Allow-Origin</code>是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p><p>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的<code>Access-Control-Allow-Origin</code>，决定权始终在对方手中。</p><p><br><br><br><br><br></p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>在JavaScript的世界中，所有代码都是单线程执行的。由于这个缺陷，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。</p><p>异步执行可以用回调函数实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Done'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"before setTimeout()"</span>);</span><br><span class="line">setTimeout(callback, <span class="number">1000</span>); <span class="comment">// 1s后调用callback</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"after setTimeout()"</span>);</span><br></pre></td></tr></table></figure><p>可见，异步操作会在将来某个时间点触发一个函数调用。</p><p>Promise有各种开源实现，在ES6中被统一规范，由浏览器直接支持。</p><p>Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清洗地分离。</p><p>Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。<br>要串行执行这样的异步任务，不用Promise需要些一层一层的嵌套代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// job 1, 2, 3都是Promise对象</span></span><br><span class="line">job1.then(job2).then(job3).catch(handleError);</span><br></pre></td></tr></table></figure><p><br></p><p>除了串行执行若干异步任务外，Promise还可以并行执行异步任务。</p><p>如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。</p><p><br><br><br><br><br></p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图标、动画等。没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。</p><p>一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=<span class="string">"test-canvas"</span> width=<span class="string">"300"</span> height=<span class="string">"200"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>绘制形状</strong></p><p>我们可以在Canvas上绘制各种形状。在绘制前，我们需要了解以下Canvas的坐标系统。Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。</p><p><br></p><p><strong>绘制文本</strong></p><p>绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致。</p><p><br></p><p>Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：</p><ul><li>通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；</li><li>尽量使用整数坐标而不是浮点数；</li><li>可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；</li><li>背景图片如果不变可以直接用<code>&lt;img&gt;</code>标签并放到最底层。</li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h1><p>你可能听说过jQuery，它名字起得很土，但却是JavaScript世界中使用最广泛的一个库。<br>江湖传言，全世界大约有80~90%的网站直接或间接地使用了jQuery。鉴于它如此流行，又如此好用，所以每一个入门JavaScript的前端工程师都应该了解和学习它。</p><p>JQuery的理念是<strong>Write Less, Do More</strong>，让你写更少的代码，完成更多的工作。</p><p>JQuery能帮助解决一些很重要的问题：</p><ul><li>消除浏览器差异</li><li>简洁的操作DOM的方法：写<code>$(&#39;#test&#39;)</code>肯定比<code>document.getElementById(&#39;test&#39;)</code>来的简洁</li><li>轻松实现动画、修改CSS等各种操作。</li></ul><p><br></p><p><strong>JQuery版本</strong></p><p>JQuery有1.x和2.x两个主要版本，区别在于2.x移除了对古老的IE6、7、8的支持，因此2.x的代码更精简。</p><p>JQuery只是一个<code>jquery-xxx.js</code>文件，但你会看到有compressed（已压缩）和uncompressed（未压缩）两种版本，使用时完全一样，但如果你想深入研究jQuery源码，那就用uncompressed版本。</p><p><br></p><p><strong>使用JQuery</strong></p><p>使用JQuery只需要在页面的<code>&lt;head&gt;</code>引入JQuery文件即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"code.jquery.com/jquery-2.1.4.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>$符号</strong></p><p><code>$</code>符号是著名的JQuery符号。实际上，Jquery把所有功能全部封装在一个全局变量<code>JQuery</code>中，而<code>$</code>也是一个合法的变量名，它是<code>JQuery</code>的别名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line"><span class="built_in">window</span>.$; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line">$ === jQuery; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span>($); <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><p><code>$</code>本质上是一个函数，但函数也是对象。于是<code>$</code>除了可以直接调用外，也可以有很多其它属性。</p><blockquote><p>注意：你看到的<code>$</code>函数名可能不是<code>JQuery(selector, context)</code>，因为很多JavaScript压缩工具可以对函数名和参数改名，所以压缩过的JQuery源码<code>$</code>函数可能变成<code>a(b, c)</code>。</p></blockquote><p>绝大多数时候，我们都直接用<code>$</code>。但是，如果<code>$</code>这个变量不幸地被占用了，而且还不能改，那我们只能让<code>JQuery</code>把<code>$</code>变量交出来，然后就只能使用<code>JQuery</code>这个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line">jQuery.noConflict();</span><br><span class="line">$; <span class="comment">// undefined</span></span><br><span class="line">jQuery; <span class="comment">// jQuery(selector, context)</span></span><br></pre></td></tr></table></figure><p>这种黑魔法的原理是JQuery在占用<code>$</code>之前，现在内部保存了原来的<code>$</code>，调用<code>JQuery.noConflict()</code>时会把原来保存的变量还原。</p><p><br><br><br></p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>选择器是JQuery的核心，一个选择器写出来大概是这样：<code>$(&#39;#dom-id&#39;)</code>。</p><p>为什么JQuery要发明选择器？来回顾一下DOM操作中经常使用的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按ID查找</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">'dom-id'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按tag查找</span></span><br><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure><p>这些代码实在太过繁琐。并且在层级关系中，很多时候需要递归查找所有子节点。<br>JQuery的选择器就是帮助我们快速定位到一个或多个DOM节点。</p><p><br></p><p><strong>按id查找</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不存在，则返回 []</span></span><br></pre></td></tr></table></figure><p>它返回JQuery对象。JQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。</p><p>JQuery的选择器不会返回<code>undefined</code>或<code>null</code>，这样的好处是不必在下一行判断<code>if (div === undefined)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JQuery对象和DOM对象直接可以互相转化</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>); <span class="comment">//JQuery对象</span></span><br><span class="line"><span class="keyword">var</span> divDom = div.get(<span class="number">0</span>); <span class="comment">// 假设存在div，获取第1个DOM元素</span></span><br><span class="line"><span class="keyword">var</span> another = $(divDom); <span class="comment">// 重新把DOM包装为JQuery对象</span></span><br></pre></td></tr></table></figure><p>通常情况下你不需要获取DOM对象，直接使用jQuery对象更加方便。如果你拿到了一个DOM对象，那可以简单地调用$(aDomObject)把它变成jQuery对象，这样就可以方便地使用jQuery的API了。</p><id><p><strong>按tag查找</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ps = $(<span class="string">'p'</span>); <span class="comment">// 返回所有&lt;p&gt;节点</span></span><br><span class="line">ps.length; <span class="comment">// 数一数页面有多少个&lt;p&gt;节点</span></span><br></pre></td></tr></table></figure><id><p><strong>按class查找</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">'.red'</span>); <span class="comment">// 所有节点包含`class="red"`都将返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个class</span></span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">'.red.green'</span>); <span class="comment">// 注意没有空格！</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>按属性查找</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> email= $(<span class="string">'[name=email]'</span>); <span class="comment">// 找出所有name属性为email的DOM</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可使用前缀/后缀查找</span></span><br><span class="line"><span class="keyword">var</span> icons = $(<span class="string">'[name^=icon]'</span>); <span class="comment">// 找出所有name属性以icon开头的DOM</span></span><br><span class="line"><span class="keyword">var</span> names = $(<span class="string">'[name$=with]'</span>); <span class="comment">// 找出所有name属性以with结尾的DOM</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>组合查找</strong></p><p>组合查找就是把上述简单选择器组合起来使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emailInput = $(<span class="string">'input[name=email]'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tag and class</span></span><br><span class="line"><span class="keyword">var</span> tr = $(<span class="string">'tr.red'</span>); <span class="comment">// 找出&lt;tr class='red ...'&gt;...&lt;/tr&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>多项选择器</strong></p><p>多项选择器就是把多个选择器用逗号<code>,</code>组合起来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'p,div'</span>); <span class="comment">// 把&lt;p&gt;和&lt;div&gt;都选出来</span></span><br><span class="line">$(<span class="string">'p.red, p.green'</span>);</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><p>除了基本的选择器外，jQuery的层级选择器更加灵活，也更强大。因为DOM的结构就是层级结构，所以我们经常要根据层级关系进行选择。</p><p><br></p><p><strong>层级选择器(Descendant Selector)</strong></p><p>如果两个DOM元素具有层级关系，就可以用<code>$(&#39;ancestor descendant&#39;)</code>来选择，层级之间用空格隔开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang li.lang-javascript'</span>);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'div.testing li.lang-python'</span>);</span><br></pre></td></tr></table></figure><p>这种层级选择器相比单个的选择器好处在于，它缩小了选择范围，因为首先要定位父节点，才能选择相应的子节点，这样避免了页面其他不相关的元素。</p><p><br></p><p><strong>子选择器(Child Selector)</strong></p><p>子选择器<code>$(&#39;parent&gt;child&#39;)</code>是限定了父子关系的层级选择器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang&gt;li.lang-javascript'</span>);</span><br></pre></td></tr></table></figure><p><br></p><p><strong>过滤器(Filter)</strong></p><p>过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang li'</span>);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'ul.lang li:first-child'</span>);</span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(2)'</span>);</span><br></pre></td></tr></table></figure><p><br></p><p><strong>表单相关</strong></p><p>针对表单元素，jQuery还有一组特殊的选择器:</p><ul><li><code>:input</code>，可选择input, textarea, select, button</li><li><code>:file</code>，可选择<code>&lt;input type=&quot;file&quot;&gt;</code>，和<code>input[type=file]</code>一样</li><li><code>:checkbox</code></li><li><code>:radio</code></li><li><code>:focus</code></li><li><code>:checked</code></li><li><code>:enabled</code></li><li><code>:disabled</code></li></ul><p><br><br><br></p><h3 id="查找和过滤"><a href="#查找和过滤" class="headerlink" title="查找和过滤"></a>查找和过滤</h3><p>通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find()查找</span></span><br><span class="line"><span class="keyword">var</span> ul = $(<span class="string">'ul.lang'</span>); <span class="comment">// 获得&lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> dy = ul.find(<span class="string">'.dy'</span>); <span class="comment">// 获得JavaScript, Python, Scheme</span></span><br><span class="line"><span class="keyword">var</span> swf = ul.find(<span class="string">'#swift'</span>); <span class="comment">// 获得Swift</span></span><br><span class="line"><span class="keyword">var</span> hsk = ul.find(<span class="string">'[name=haskell]'</span>); <span class="comment">// 获得Haskell</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要从当前节点开始向上查找，使用parent()方法</span></span><br><span class="line"><span class="keyword">var</span> swf = $(<span class="string">'#swift'</span>); <span class="comment">// 获得Swift</span></span><br><span class="line"><span class="keyword">var</span> parent = swf.parent(); <span class="comment">// 获得Swift的上层节点&lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = swf.parent(<span class="string">'.red'</span>); <span class="comment">// 获得Swift的上层节点&lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空jQuery对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于位于同一层级的节点，可以通过next()和prev()</span></span><br><span class="line"><span class="keyword">var</span> swift = $(<span class="string">'#swift'</span>);</span><br><span class="line"></span><br><span class="line">swift.next(); <span class="comment">// Scheme</span></span><br><span class="line">swift.next(<span class="string">'[name=haskell]'</span>); <span class="comment">// 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]</span></span><br><span class="line">swift.prev(); <span class="comment">// Python</span></span><br><span class="line">swift.prev(<span class="string">'.dy'</span>); <span class="comment">// Python，因为Python同时符合过滤器条件.dy</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter()方法可以过滤不符合选择器条件的节点</span></span><br><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到JavaScript, Python, Swift, Scheme和Haskell</span></span><br><span class="line"><span class="keyword">var</span> a = langs.filter(<span class="string">'.dy'</span>); <span class="comment">// 拿到JavaScript, Python, Scheme</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h2><p>jQuery的选择器很强大，用起来又简单又灵活，但是搞了这么久，我拿到了jQuery对象，到底要干什么？</p><p>当然是操作对应的DOM节点啦！</p><p>回顾一下修改DOM的CSS、文本、设置HTML有多么麻烦，而且有的浏览器只有innerHTML，有的浏览器支持innerText，有了jQuery对象，不需要考虑浏览器差异了，全部统一操作！</p><p><br></p><p><strong>修改Text和HTML</strong></p><p>jQuery对象的<code>text()</code>和<code>html()</code>方法分别获取节点的文本和原始HTML文本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取</span></span><br><span class="line">$(<span class="string">'#ul li[name=book]'</span>).text();</span><br><span class="line">$(<span class="string">'#ul li[name=book]'</span>).html();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="keyword">var</span> j1 = $(<span class="string">'#test-ul li.js'</span>);</span><br><span class="line"><span class="keyword">var</span> j2 = $(<span class="string">'#test-ul li[name=book]'</span>);</span><br><span class="line"></span><br><span class="line">j1.html(<span class="string">'&lt;span style="color: red"&gt;JavaScript&lt;/span&gt;'</span>);</span><br><span class="line">j2.text(<span class="string">'JavaScript &amp; ECMAScript'</span>);</span><br></pre></td></tr></table></figure><p><br></p><p><strong>修改CSS</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// css('name', 'value')</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.css(<span class="string">'color'</span>); <span class="comment">// '#000033', 获取CSS属性</span></span><br><span class="line">div.css(<span class="string">'color'</span>, <span class="string">'#336699'</span>); <span class="comment">// 设置CSS属性</span></span><br><span class="line">div.css(<span class="string">'color'</span>, <span class="string">''</span>); <span class="comment">// 清除CSS属性</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>显示和隐藏DOM</strong></p><p>考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供<code>show()</code>和<code>hide()</code>方法。</p><blockquote><p>注意，隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">'a[target=_blank]'</span>);</span><br><span class="line">a.hide(); <span class="comment">// 隐藏</span></span><br><span class="line">a.show(); <span class="comment">// 显示</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>获取DOM信息</strong></p><p>利用jQuery对象的若干方法，我们直接可以获取DOM的许多信息，而无需针对不同浏览器编写特定代码。</p><ul><li><code>width()</code></li><li><code>height()</code></li><li><code>attr()</code>：获取或修改属性</li><li><code>removeAttr()</code></li><li><code>prop()</code></li><li>…</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).width();</span><br><span class="line">$(<span class="built_in">window</span>).height();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.width(<span class="number">400</span>);</span><br><span class="line">div.height(<span class="string">'200px'</span>);</span><br><span class="line"></span><br><span class="line">div.attr(<span class="string">'name'</span>);</span><br><span class="line">div.attr(<span class="string">'name'</span>, <span class="string">'Hello'</span>);</span><br><span class="line">div.removeAttr(<span class="string">'name'</span>);</span><br></pre></td></tr></table></figure><p><br></p><p><strong>操作表单</strong></p><p>对于表单元素，jQuery对象统一提供<code>val()</code>方法获取和设置对应的<code>value</code>属性。一个<code>val()</code>就统一了各种输入框的取值和赋值的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    input = $(<span class="string">'#input'</span>),</span><br><span class="line">    select = $(<span class="string">'#select'</span>),</span><br><span class="line">    textarea = $(<span class="string">'#textarea'</span>);</span><br><span class="line">input.val();</span><br><span class="line">input.val(<span class="string">'xxx@example.com'</span>);</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="修改DOM结构"><a href="#修改DOM结构" class="headerlink" title="修改DOM结构"></a>修改DOM结构</h3><p>有了jQuery，我们就专注于操作jQuery对象本身，底层的DOM操作由jQuery完成就可以了，这样一来，修改DOM也大大简化了。</p><p><br></p><p><strong>添加DOM</strong></p><p>除了<code>html()</code>这种暴力方法外，还可以用<code>append()</code>方法。<code>append()</code>把DOM添加到最后，<code>prepend()</code>则把DOM添加到最前。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = $(<span class="string">'#test-div&gt;ul'</span>);</span><br><span class="line">ul.append(<span class="string">'&lt;li&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;/li&gt;'</span>);</span><br></pre></td></tr></table></figure><p>除了接受字符串，<code>append()</code>还可以传入原始的DOM对象、jQuery对象和函数对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建DOM对象:</span></span><br><span class="line"><span class="keyword">var</span> ps = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">ps.innerHTML = <span class="string">'&lt;span&gt;Pascal&lt;/span&gt;'</span>;</span><br><span class="line"><span class="comment">// 添加DOM对象:</span></span><br><span class="line">ul.append(ps);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加jQuery对象:</span></span><br><span class="line">ul.append($(<span class="string">'#scheme'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加函数对象:</span></span><br><span class="line">ul.append(<span class="function"><span class="keyword">function</span> (<span class="params">index, html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;li&gt;&lt;span&gt;Language - '</span> + index + <span class="string">'&lt;/span&gt;&lt;/li&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同级节点可以用<code>after()</code>或者<code>before()</code>方法。</p><p><br></p><p><strong>删除节点</strong></p><p>要删除DOM节点，拿到jQuery对象后直接调用<code>remove()</code>方法就可以了。如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点。</p><p><br><br><br><br><br></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>因为JavaScript在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的JavaScript代码被执行完后，就只能依赖触发事件来执行JavaScript代码。</p><p>浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的DOM节点上触发相应的事件。如果该节点已经绑定了对应的JavaScript处理函数，该函数就会自动调用。由于不同的浏览器绑定事件的代码都不太一样，所以用jQuery来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栗子：点击超链接弹出提示框，用jQuery绑定一个click事件</span></span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">'#test-link'</span>);</span><br><span class="line">a.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello!'</span>;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// on方法用来绑定一个事件，需要传入事件名称和对应的处理函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一种更简化的写法</span></span><br><span class="line">a.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p>jQuery能够绑定的事件主要有：</p><ul><li>鼠标事件<ul><li>click：鼠标单击时触发；</li><li>dblclick：鼠标双击时触发；</li><li>mouseenter：鼠标进入时触发；</li><li>mouseleave：鼠标移出时触发；</li><li>mousemove：鼠标在DOM内部移动时触发；</li><li>hover：鼠标进入和退出时触发两个函数（相当于mouseenter+mouseleave）。</li></ul></li><li>键盘事件：仅作用在当前焦点的DOM上<ul><li>keydown：键盘按下时触发；</li><li>keyup：键盘松开时触发；</li><li>keypress：按一次键后触发。</li></ul></li><li>其它事件<ul><li>focus：当DOM获得焦点时触发；</li><li>blur：当DOM失去焦点时触发；</li><li>change：当input, select, textarea的内容改变时触发；</li><li>submit：当form提交时触发；</li><li>ready：当页面被载入并且DOM树完成初始化后触发。</li></ul></li></ul><p><br></p><p><strong>取消绑定</strong></p><p>一个已被绑定的事件可以解除绑定，通过<code>off(&#39;click&#39;, function)</code>实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.click(hello); <span class="comment">// 绑定事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10秒钟后解除绑定:</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    a.off(<span class="string">'click'</span>, hello);</span><br><span class="line">&#125;, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p>需要特别注意，以下这种写法无效：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ 绑定事件:</span><br><span class="line">a.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 解除绑定:</span></span><br><span class="line">a.off(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是因为两个匿名函数虽然长得一模一样，但是它们是两个不同的函数对象，<code>off(&#39;click&#39;, function () {...})</code>无法移除已绑定的第一个匿名函数。</p><p>为了实现移除效果，可以使用<code>off(&#39;click&#39;)</code>一次性移除已绑定的<code>click</code>事件的所有处理函数。<br>同理，无参数调用<code>off()</code>一次性移除已绑定的所有类型的事件处理函数。</p><p><br></p><p><strong>事件触发条件</strong></p><p>一个需要注意的问题是，事件的触发总是由用户操作引发的。</p><p><br></p><p><strong>浏览器安全限制</strong></p><p>在浏览器中，有些JavaScript代码只有在用户触发下才能执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如window.open()函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法弹出新窗口，将被浏览器屏蔽:</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.open(<span class="string">'/'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>用JavaScript实现动画，原理非常简单：我们只需要以固定的时间间隔（例如，0.1秒），每次把DOM元素的CSS样式修改一点（例如，高宽各增加10%），看起来就像动画了。</p><p>但是要用JavaScript手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。</p><p>使用jQuery实现动画，代码就非常简单了。</p><p><br></p><p><strong>jQuery内置的几种动画样式</strong></p><ul><li><code>show()</code>：显示DOM元素，从左上角展开；</li><li><code>hiden()</code>：隐藏DOM元素，从左上角收缩；</li><li><code>sideUp()</code>：在垂直方向展开；</li><li><code>sideDown()</code>：在垂直反向收缩；</li><li><code>fadeIn()</code>：动画效果淡入；</li><li><code>fadeOut()</code>：动画效果淡出。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-show-hide'</span>);</span><br><span class="line">div.hide(<span class="number">3000</span>); <span class="comment">// 在3秒钟内逐渐消失</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-show-hide'</span>);</span><br><span class="line">div.show(<span class="string">'slow'</span>); <span class="comment">// 在0.6秒钟内逐渐显示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-slide'</span>);</span><br><span class="line">div.slideUp(<span class="number">3000</span>); <span class="comment">// 在3秒钟内逐渐向上消失</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-fade'</span>);</span><br><span class="line">div.fadeOut(<span class="string">'slow'</span>); <span class="comment">// 在0.6秒内淡出</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>自定义动画</strong></p><p>使用<code>animate()</code>可实现任意动画效果，需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到设定的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-animate'</span>);</span><br><span class="line">div.animate(&#123;</span><br><span class="line">    opacity: <span class="number">0.25</span>,</span><br><span class="line">    width: <span class="string">'256px'</span>,</span><br><span class="line">    height: <span class="string">'256px'</span></span><br><span class="line">&#125;, <span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'动画已结束'</span>);</span><br><span class="line">    <span class="comment">// 恢复至初始状态:</span></span><br><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">'opacity'</span>, <span class="string">'1.0'</span>).css(<span class="string">'width'</span>, <span class="string">'128px'</span>).css(<span class="string">'height'</span>, <span class="string">'128px'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p><strong>串行动画</strong></p><p>jQuery的动画效果还可以串行执行，通过<code>delay()</code>方法还可以实现暂停，这样我们可以实现更复杂的动画效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-animates'</span>);</span><br><span class="line"><span class="comment">// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小</span></span><br><span class="line">div.slideDown(<span class="number">2000</span>)</span><br><span class="line">   .delay(<span class="number">1000</span>)</span><br><span class="line">   .animate(&#123;</span><br><span class="line">       width: <span class="string">'256px'</span>,</span><br><span class="line">       height: <span class="string">'256px'</span></span><br><span class="line">   &#125;, <span class="number">2000</span>)</span><br><span class="line">   .delay(<span class="number">1000</span>)</span><br><span class="line">   .animate(&#123;</span><br><span class="line">       width: <span class="string">'128px'</span>,</span><br><span class="line">       height: <span class="string">'128px'</span></span><br><span class="line">   &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="AJAX-1"><a href="#AJAX-1" class="headerlink" title="AJAX"></a>AJAX</h2><p>jQuery在全局对象<code>jQuery</code>(也就是<code>$</code>)绑定了<code>ajax()</code>函数，可以处理AJAX请求。<code>ajax(url, settings)</code>常用的选项如下：</p><ul><li>async：是否异步执行AJAX请求，默认true，千万不要指定为false；</li><li>method：缺省为GET；</li><li>content type：发送POST请求的格式，默认为<code>application/x-www-form-urlencoded; charset=UTF-8</code>，也可指定为<code>text/plain</code>, <code>application/json</code>；</li><li>data：发送的数据，可以是字符串、数组、对象；</li><li>headers：发送的额外HTTP头，必须是一个对象；</li><li>dataType：接收的数据格式，可指定为html, xml, json, text等。</li></ul><p><br></p><p><strong>get</strong></p><p>对常用的AJAX操作，jQuery提供了一些辅助方法。由于GET请求最常见，所以jQuery提供了<code>get()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.get(<span class="string">'/path/to/resource'</span>, &#123;</span><br><span class="line">    name: <span class="string">'xxx'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际URL：/path/to/resource?name=Bob%20Lee&amp;check=1</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>post</strong></p><p>与get类似，但传入的第二个参数默认被序列化为<code>application/x-www-form-urlencoded</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.post(<span class="string">'/path/to/resource'</span>, &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际构造数据：name=Bob%20Lee&amp;check=1</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>getJSON</strong></p><p>由于json越来越普遍，所以jQuery也提供了<code>getJSON()</code>方法来快速通过GET获取一个json对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.getJSON(<span class="string">'/path/to/resource'</span>, &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// data已经被解析为JSON对象了</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><p><strong>安全限制</strong></p><p>jQuery的AJAX完全封装的是JavaScript的AJAX操作，所以它的安全限制和前面讲的用JavaScript写AJAX完全一样。</p><p><br><br><br><br><br></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>当我们使用jQuery对象的方法时，由于jQuery对象可以操作一组DOM，而且支持链式操作，所以用起来非常方便。但是jQuery内置的方法永远不可能满足所有的需求。</p><p>我们可以扩展jQuery来实现自定义方法。我们可以扩展jQuery来实现自定义方法。</p><p><br></p><h3 id="编写jQuery插件"><a href="#编写jQuery插件" class="headerlink" title="编写jQuery插件"></a>编写jQuery插件</h3><p>给jQuery对象绑定一个新方法是通过扩展<code>$.fn</code>对象实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this已绑定为当前jQuery对象，所以函数内部代码可以正常调用所有jQuery对象的方法</span></span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, <span class="string">'#fffceb'</span>).css(<span class="string">'color'</span>, <span class="string">'#d85030'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 因为jQuery对象支持链式操作，我们自己写的扩展方法也要能继续链式下去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以给方法加个参数，让用户自己把参数用对象传进去</span></span><br><span class="line">$.fn.highlight2 = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 要考虑到各种情况:</span></span><br><span class="line">    <span class="comment">// options为undefined</span></span><br><span class="line">    <span class="comment">// options只有部分key</span></span><br><span class="line">    <span class="keyword">var</span> bgcolor = options &amp;&amp; options.backgroundColor || <span class="string">'#fffceb'</span>;</span><br><span class="line">    <span class="keyword">var</span> color = options &amp;&amp; options.color || <span class="string">'#d85030'</span>;</span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, bgcolor).css(<span class="string">'color'</span>, color);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>另一种方法是使用jQuery提供的辅助方法<code>$.extend(target, obj1, obj2, ...)</code>，它把多个对象的属性合并到第一个target对象中，遇到同名属性，总是使用靠后的对象的值，也就是越往后优先级越高。</p><p>紧接着用户对<code>highlight2()</code>提出了意见：每次调用都需要传入自定义的设置，能不能让我自己设定一个缺省值，以后的调用统一使用无参数的<code>highlight2()</code>？也就是说，我们设定的默认值应该能允许用户修改。那默认值放哪比较合适？放全局变量肯定不合适，最佳地点是<code>$.fn.highlight2</code>这个函数对象本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.fn.highlight = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 合并默认值和用户设定值:</span></span><br><span class="line">    <span class="keyword">var</span> opts = $.extend(&#123;&#125;, $.fn.highlight.defaults, options);</span><br><span class="line">    <span class="keyword">this</span>.css(<span class="string">'backgroundColor'</span>, opts.backgroundColor).css(<span class="string">'color'</span>, opts.color);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定默认值:</span></span><br><span class="line">$.fn.highlight.defaults = &#123;</span><br><span class="line">    color: <span class="string">'#d85030'</span>,</span><br><span class="line">    backgroundColor: <span class="string">'#fff8de'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>最终，我们得出编写一个jQuery插件的原则：</p><ul><li>给<code>$.fn</code>绑定函数，实现插件的代码逻辑；</li><li>插件函数最后要<code>return this;</code>以支持链式调用；</li><li>插件函数要有默认值，绑定在<code>$.fn.&lt;pluginName&gt;.defaults</code>上；</li><li>用户在调用时可传入设定值以便覆盖默认值。</li></ul><p><br><br><br></p><h3 id="针对特定元素的扩展"><a href="#针对特定元素的扩展" class="headerlink" title="针对特定元素的扩展"></a>针对特定元素的扩展</h3><p>我们还知道jQuery对象的有些方法只能作用在特定的DOM元素上，比如<code>submit()</code>方法只能针对<code>form</code>。如果我们编写的扩展只能针对某些类型的DOM元素，应该怎么写？</p><p>还记得jQuery的选择器支持<code>filter()</code>方法来过滤吗？我们可以借助这个方法来实现针对特定元素的扩展。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>错误分两种：</p><ul><li>一种是程序逻辑写的不对，导致代码执行异常；</li><li>一种是执行过程中，程序可能遇到无法预测的异常情况而报错。</li></ul><p>错误处理是程序设计时必须要考虑的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似于Python的try</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>错误类型</strong></p><p>JavaScript有一个标准的<code>Error</code>对象表示错误，还有从<code>Error</code>派生的<code>TypeError</code>, <code>FeferenceError</code>等错误对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">TypeError</span>) &#123;</span><br><span class="line">        alert(<span class="string">'Type error!'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">        alert(e.message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'Error: '</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>抛出错误</strong></p><p>程序也可以主动抛出一个错误，让执行流程直接跳转到<code>catch</code>块。抛出错误使用<code>throw</code>语句。</p><p><br><br><br></p><h2 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h2><p>如果代码发生了错误，有没有被<code>try...catch</code>捕获，那么程序执行流程会跳转到哪呢？</p><p>如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。</p><p><br><br><br></p><h2 id="异步错误处理"><a href="#异步错误处理" class="headerlink" title="异步错误处理"></a>异步错误处理</h2><p>编写JavaScript代码时，我们要时刻牢记，JavaScript引擎是一个事件驱动的执行引擎，代码总是以单线程执行，而回调函数的执行需要等到下一个满足条件的事件出现后，才会被执行。</p><p>所以，涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。类似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="underscore"><a href="#underscore" class="headerlink" title="underscore"></a>underscore</h1><p>正如jQuery统一了不同浏览器之间的DOM操作的差异，让我们可以简单地对DOM进行操作，underscore则提供了一套完善的函数式编程的接口，让我们更方便地在JavaScript中实现函数式编程。</p><p>jQuery在加载时，会把自身绑定到唯一的全局变量<code>$</code>上，underscore与其类似，会把自身绑定到唯一的全局变量<code>_</code>上，这也是为啥它的名字叫underscore的原因。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><p>从本章开始，我们就正式开启JavaScript的后端开发之旅。</p><p>Node.js是目前非常火热的技术，但是它的诞生经历却很奇特。</p><p>Google认为要运行现代Web应用，浏览器必须有一个性能非常强劲的JavaScript引擎，于是Google自己开发了一个高性能JavaScript引擎，名字叫V8，以BSD许可证开源。</p><p>话说有个叫Ryan Dahl的歪果仁，他的工作是用C/C++写高性能Web服务。对于高性能，异步IO、事件驱动是基本原则，但是用C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发Web服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步IO和异步IO，但是开发人员一旦用了同步IO，他们就再也懒得写异步IO了，所以，最终，Ryan瞄向了JavaScript。</p><p>因为JavaScript是单线程执行，根本不能进行同步IO操作，所以，JavaScript的这一缺陷导致了它只能使用异步IO。</p><p>选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为V8就是开源的JavaScript引擎。让Google投资去优化V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。</p><p>于是在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。</p><p>在Node上运行的JavaScript相比其他后端开发语言有何优势？最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。</p><p>其次，JavaScript语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉JavaScript就是个“玩具语言”。但是，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。</p><p><br></p><p>Node.js是一个开源和跨平台的JavaScript runtime environment。</p><p><br><br><br></p><h2 id="安装Node-js和npm"><a href="#安装Node-js和npm" class="headerlink" title="安装Node.js和npm"></a>安装Node.js和npm</h2><p>由于Node.js平台是在后端运行JavaScript代码，所以需要在本机按照Node环境。</p><p><br><br><br></p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>详情请看官网文档。</p><p><br><br><br></p><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>npm is the standard package manager for Node.js.</p><p>npm其实是Node.js的包管理工具。<br>为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。</p><p>更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p><p>讲了这么多，npm究竟在哪？其实npm已经在Node.js安装的时候顺带装好了。</p><p><br><br><br></p><h2 id="第一个Node程序"><a href="#第一个Node程序" class="headerlink" title="第一个Node程序"></a>第一个Node程序</h2><p>在前面的章节中，编写的JavaScript代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。</p><p>从本章开始，我们编写的JavaScript代码将不能在浏览器环境中执行了，而是在Node环境中执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strics'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello, world.'</span>)</span><br></pre></td></tr></table></figure><p>执行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node hello.js</span><br><span class="line"><span class="comment"># Hello, world.</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>严格模式</strong></p><p>在服务器环境下，如果有很多JavaScript文件，每个文件都写上<code>&#39;use strict&#39;;</code>很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --use_strict</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个<code>.js</code>文件就称之为一个模块（module）。</p><p>使用模块有什么好处？最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s + <span class="string">', '</span> + name + <span class="string">'!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了</span></span><br><span class="line"><span class="built_in">module</span>.exports = greet;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用模块</span></span><br><span class="line"><span class="comment">// 使用require引入模块，请注意路径</span></span><br><span class="line"><span class="keyword">var</span> greet = <span class="built_in">require</span>(<span class="string">'./hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'Michael'</span>;</span><br><span class="line"></span><br><span class="line">greet(s);</span><br></pre></td></tr></table></figure><p><br></p><p><strong>CommonJS规范</strong></p><p>这种模块加载机制被称为CommonJS规范。在这个规范下，每个<code>.js</code>文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突。</p><p>一个模块想要对外暴露变量（函数也是变量），可以用<code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用<code>var ref = require(&#39;module_name&#39;);</code>就拿到了引用模块的变量。</p><p><br><br><br><br><br></p><h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2></id></id>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wiki: &lt;a href=&quot;https://zh.wikipedia.org/zh-cn/JavaScript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh.wikipedia.org/zh-cn/JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;W3school: &lt;a href=&quot;https://www.w3school.com.cn/js/index.asp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.w3school.com.cn/js/index.asp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;廖雪峰：&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1022910821149312&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.liaoxuefeng.com/wiki/1022910821149312&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ELRH7x86_64&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Web" scheme="https://zhang21.github.io/tags/Web/"/>
    
      <category term="JavaScript" scheme="https://zhang21.github.io/tags/JavaScript/"/>
    
      <category term="JS" scheme="https://zhang21.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Ansible</title>
    <link href="https://zhang21.github.io/2019/12/26/Ansible/"/>
    <id>https://zhang21.github.io/2019/12/26/Ansible/</id>
    <published>2019-12-26T09:40:11.000Z</published>
    <updated>2020-08-26T11:16:38.117Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>Ansible docs: <a href="https://docs.ansible.com" target="_blank" rel="noopener">https://docs.ansible.com</a></li></ul><p><br></p><p>环境:</p><ul><li>RHELx86_64</li><li>Ansible v2.9</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>About Ansible: <a href="https://docs.ansible.com/ansible/latest/index.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/index.html</a></p><p>Ansible是一个IT自动化工具。它可以配置系统，部署软件和编排更先进的IT任务。Ansible的主要目标是简单和易于使用。它也专注于安全性和可靠性。</p><p>Ansible以无代理(agent-less)方式管理机器。Ansible是分散的，它依赖于现有操作系统的平局来控制访问到远程主机。如果需要，Ansible可以很容易地使用Kerberos, LDAP等集中认证管理系统连接。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h1><p><a href="https://docs.ansible.com/ansible/latest/reference_appendices/glossary.html" target="_blank" rel="noopener">Glossary</a></p><ul><li><p><strong>Action</strong><br>动作(action)是任务的一部分，用于指定要运行的模块和传递给该模块的参数。每个任务只能有一个动作，但也可能有其它参数。</p></li><li><p><strong>Ad Hoc</strong><br>指使用<code>/usr/bin/ansible</code>运行Ansible执行一些快速命令，而不是编排语言，即<code>/usr/bin/ansible-play-book</code>。ad hoc命令的示例可能是重新启动基础结构中的50台计算机。你可以通过编写playbook来完成你可以做的任何事情，而playbook也可以将许多其它操作粘合在一起。</p></li><li><p><strong>Async</strong><br>指配置为在后台运行而不是等待完成的任务。如果你的进程时间长度超过了SSH超时时间，那么以异步(async)模式启动该任务是有意义的。异步模式可以每隔很多秒轮询完成，或者可配置为’fire and  forget’，在这种情况下，Ansible甚至不会再次检查任务，它将开始并继续进行未来的步骤。异步模式使用<code>/usr/bin/ansible</code>和<code>/usr/bin/ansible-playbook</code>。</p></li><li><p><strong>Callback Plugin</strong><br>指一些用户编写的代码，可拦截Ansible的结构并对它们执行某些操作。GitHub中提供的一些示例执行自定义日志记录，发送电子邮件…</p></li><li><p><strong>Check Mode</strong><br>值运行带有<code>--check</code>选项的Ansible，它不会对远程系统进行任何更改，但仅输出在没有此标志的情况下运行时才有可能发生的更改。</p></li><li><p><strong>Connection Plugin</strong><br>默认情况下，Ansible通过pluggable libraries与远程计算机通信。Ansible支持原生OpenSSH或称为paramiko的Python实现。如果您使用的是最新版本，则首选OpenSSH，并启用Kerberos和jump host等功能。还有其它连接类型，如<code>accelerate</code>模式，必须通过一种基于SSH的连接类型进行引导，但速度非常快，而本地模式则作用于本地系统。用户还可以编写自己的连接插件。</p></li></ul><ul><li><p><strong>Conditionals</strong><br>条件是一个表达式，其计算结果为<code>true</code>或<code>false</code>，用于决定给定任务是否在给定计算机上执行。</p></li><li><p><strong>Declarative</strong><br>实现使用最终状态描述的任务的方法，而不是实现该状态所需的步骤序列的描述。对于真实世界的栗子，任务的声明规范将是: “put me in California”。根据你当前的位置，前往加州的步骤顺序可能会有所不同，如果你已在加州，则根本不需要做任何事情。Ansible的资源是声明性的；它确定了实现最终状态所需的步骤。它还可让你知道是否需要采取任何步骤才能到达最终状态。</p></li><li><p><strong>Diff Mode</strong><br>将<code>--diff</code>标志传递给Ansible，以显示支持它的模块。</p></li><li><p><strong>Executor</strong><br>Ansible的核心软件组件，它是<code>/usr/bin/ansible</code>背后的力量——并且对应于剧本中每个任务的调用。</p></li><li><p><strong>Facts</strong><br>事实是发现的有关远程节点的事情。通过在远程节点上执行内部设置模块来运行，Ansible会自动发现事实。</p></li><li><p><strong>Filter Plugin</strong><br>这允许创建新的Jinja2过滤器，这只适用于知道Jinja2过滤器的人。</p></li><li><p><strong>Fork</strong><br>Ansible并行地与远程节点通信，并且可通过传递<code>--forks</code>或编辑配置文件中的默认值来设置并行级别。</p></li><li><p><strong>Gather Facts (Boolean)</strong><br>有时，当运行多重playbook时，如果不需要利用任何这些值，则希望有一些不打扰事实计算的playbook。</p></li><li><p><strong>Globbing</strong><br>通配符是一种选择大量主机，或它们所在组的名称的方法</p></li><li><p><strong>Group</strong><br>一组主机</p></li><li><p><strong>Group Vars</strong><br>这是将提供给指定组的变量，尤其是复杂的数据结构，这样这些变量就不必嵌入到库存文件或playbook中。</p></li><li><p><strong>Handlers</strong><br>处理程序就像Ansible playbook中的常规任务，但只有在任务包含<code>notify</code>指定并且还指示它已更改某些内容时才会运行。</p></li><li><p><strong>Host</strong><br>主机是Ansible管理的远程机器。</p></li><li><p><strong>Host Specifier</strong><br>Ansible中的每个<code>play</code>都将一系列任务映射到一组系统。每个<code>play</code>中的<code>hosts:</code>指令通常称为主机说明符。它可以选择一个或多个系统，一个或多个组，甚至一个组中的一些主机，而不是另一个组中的主机。</p></li><li><p><strong>Host Vars</strong><br>主机变量类似与组变量。</p></li><li><p><strong>Idempotency</strong><br>如果执行一次的结果与在没有任何干预动作的情况下重复执行它的结果完全相同，则操作是幂等的。</p></li><li><p><strong>Includes</strong><br>playbook文件可以包括其它play list，任务列表可以外部化其它文件中的任务列表，类似于处理程序。</p></li><li><p><strong>Inventory</strong><br>用于描述Ansible中的主机和组的文件。</p></li><li><p><strong>Inventory Script</strong><br>一个程序，用于查找主机，主机的组关系以及外部资源的变量信息——无论是SQL数据库，CMDB方案，还是LDAP等。</p></li><li><p><strong>Jinja2</strong><br>Jinja2是Ansible模板模块的首选语言。它是一种非常简单的Python模板语言，可读且易于编写。</p></li><li><p><strong>JSON</strong><br>Ansible使用JSON从远程模块返回数据。这允许用任何语言编写。</p></li><li><p><strong>Lazy Evaluation</strong><br>通常，Ansible会在最后一秒评估playbook内容中的任何变量。</p></li><li><p><strong>Library</strong><br>Ansible的模块集合。</p></li><li><p><strong>Limit Groups</strong><br>通过将<code>--limit somegroup</code>传递给Ansible或ansible-playbook可以限制主机的子集。</p></li><li><p><strong>Local Action</strong><br>针对远程计算机的playbook中的本地活动指令意味着给定的步骤实际上将在本地计算机上发生，但是可以传入变量<code></code>以引用该步骤中引用的远程主机名。</p></li><li><p><strong>Local Connection</strong><br>通过在playbook中使用<code>connection: local</code>，或将<code>-c local</code>传递给<code>/usr/bin/ansible</code>，这表明我们正在管理本地主机而不是远程主机。</p></li><li><p><strong>Lookup Plugin</strong><br>查找插件是一种从外部获取数据到Ansible的方法。</p></li><li><p><strong>Loops</strong><br>通常，Ansible不是一种编程语言。它更喜欢声明性，尽管循环这样的各种结构允许对列表中的多个项重复特定任务。</p></li><li><p><strong>Modules</strong><br>模块是Ansible发送到远程机器的工作单元。</p></li><li><p><strong>Multi-Tier</strong><br>IT系统不是一次管理一个系统的概念，而是通过明确定义的订单中多个系统和系统组之间的交互。</p></li><li><p><strong>Notify</strong><br>任务注册更改事件并通知处理程序任务需要在play结束时运行另一个操作的行为。</p></li><li><p><strong>Orchestration</strong><br>许多软件自动化系统使用这个词来表示不同的东西。Ansible使用它作为编排的指挥。</p></li><li><p><strong>paramiko</strong><br>默认情况下，Ansible通过SSH管理机器。Ansible默认使用的库是一个名为paramiko的Python驱动库。</p></li><li><p><strong>Playbooks</strong><br>playbook是Ansible编排，配置，管理或部署系统的语言。它被称为剧本，部分原因在于它是一种运动类比，并且使用它们应该很有趣。</p></li><li><p><strong>Plays</strong><br>A playbook is a list of plays。剧本最小是由主机说明符选择的一组主机之间的映射，以及在这些主机上运行定义这些系统将执行的角色的任务。</p></li><li><p><strong>Pull Mode</strong><br>默认情况下，Ansible以<code>push</code>模式运行，这使得它可以在与每个系统进行通信时进行非常精细的控制。当你希望在特定计划时间点检查节点时，可以使用<code>pull</code>模式。</p></li><li><p><strong>Push Mode</strong></p></li><li><p><strong>Register Variable</strong><br>在Ansible中运行任何任务的结果可以存储在变量中，以便在模板或条件语句中使用。</p></li><li><p><strong>Resource Model</strong><br>Ansible模块在资源方面起作用。</p></li><li><p><strong>Roles</strong><br>角色是Ansible的组织单位。</p></li><li><p><strong>Rolling Update</strong><br>一次解决组中的多个节点的行为，以避免一次更新所有节点并使系统脱机。</p></li><li><p><strong>Sudo</strong></p></li><li><p><strong>SSH (Native)</strong></p></li><li><p><strong>Tags</strong><br>Ansible允许使用任意关键字标记剧本中的资源，然后仅运行与这些关键字对应的剧本部分。</p></li><li><p><strong>Task</strong><br>任务将操作(模块及其参数)与名称和可选的其他关键字(如循环指令)组合在一起。</p></li><li><p><strong>Templates</strong><br>Ansible可以轻松地将文件传输到远程系统，但通常需要在其它文件中替换变量。</p></li><li><p><strong>Transport</strong><br>Ansible使用<code>term:</code>连接插件来定以可用传输的类型。</p></li><li><p><strong>When</strong><br>一个可选的条件语句。</p></li><li><p><strong>Vars (Variables)</strong><br>与事实相反，变量是值的名称(int, bool, string)或复杂的数据(dict, hash, lists)。它是声明的东西，而不是从远程系统获取的东西。</p></li><li><p><strong>YAML</strong><br>Ansible不想强迫人们编写程序代码来自动化基础设施，因此使用YAML来定义剧本配置语言和变量文件。</p></li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h1><p>Installtion Guide: <a href="https://docs.ansible.com/ansible/latest/installation_guide/index.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/installation_guide/index.html</a></p><p><br></p><h2 id="安装Ansible"><a href="#安装Ansible" class="headerlink" title="安装Ansible"></a>安装Ansible</h2><p>Installing Ansible: <a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html</a></p><p>Ansible是一个默认通过SSH协议管理机器的无代理(agentless)的自动化工具。一旦安装，Ansible不添加数据库，并且不需要启动守护进程。你只需要在一台机器上安装它，它可以从该中心点管理远程所有机器。</p><p><br></p><p><br></p><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>Prerequisite</p><p>在控制节点上安装Ansible，然后使用SSH(默认)与管理的节点通信。</p><p><br></p><p><strong>控制节点的依赖</strong><br>Control node requirements</p><p>目前，Ansible可以从任何安装了Python2.7或Python3.5+的机器上运行。不支持Windows。</p><p><br></p><p><strong>被管理节点的依赖</strong></p><p>Managed node requirements</p><p>在被管理的节点上，你需要一种方法来通信（通常是SSH）。</p><p><br><br><br></p><h3 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a>选择版本</h3><p>Selecting an Ansible version to install</p><p>选择自己需要的Ansible版本进行安装，可选择一下几种方式：</p><ul><li>使用操作系统包管理器进行安装</li><li>使用pip进行安装</li><li>使用源码进行安装</li></ul><p><br><br><br></p><h3 id="在RHEL上安装"><a href="#在RHEL上安装" class="headerlink" title="在RHEL上安装"></a>在RHEL上安装</h3><p>Installing Ansible on RHEL, CentOS, or Fedora</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum search ansible</span><br><span class="line"></span><br><span class="line">sudo yum install ansible</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用pip安装"><a href="#使用pip安装" class="headerlink" title="使用pip安装"></a>使用pip安装</h3><p>Installing Ansible with pip</p><p>使用Python的包管理工具pip来安装Ansible。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># env</span></span><br><span class="line"><span class="comment"># python -m virtualenv ansible</span></span><br><span class="line"><span class="comment"># source ansible/bin/activate</span></span><br><span class="line">pip install --user ansible</span><br><span class="line">pip install --user paramiko</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Ansible-command-shell-completion"><a href="#Ansible-command-shell-completion" class="headerlink" title="Ansible command shell completion"></a>Ansible command shell completion</h3><p>Ansible 2.9的命令行工具由称为<code>argcomplete</code>的依赖提供。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install python-argcomplete</span><br><span class="line"></span><br><span class="line"><span class="comment"># pip</span></span><br><span class="line"><span class="comment"># pip install argcomplete</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置argcomplete</strong></p><p>有两种方式来配置Ansible的命令行工具argcomplete：</p><ul><li>全局(Globally)</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global completion requires bash 4.2.</span></span><br><span class="line">sudo activate-global-python-argcomplete</span><br></pre></td></tr></table></figure><ul><li>每个命令(Per command)</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If you do not have bash 4.2, you must register each script independently.</span></span><br><span class="line"><span class="comment"># 可将这些写入.profile里</span></span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-config)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-console)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-doc)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-galaxy)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-inventory)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-playbook)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-pull)</span><br><span class="line"><span class="built_in">eval</span> $(register-python-argcomplete ansible-vault)</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="配置Ansible"><a href="#配置Ansible" class="headerlink" title="配置Ansible"></a>配置Ansible</h2><p>Configuring Ansible: <a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_configuration.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/installation_guide/intro_configuration.html</a></p><p><br></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Configuration file</p><p>Ansible将按照一下顺序搜索配置文件：</p><ul><li><code>ANSIBLE_CONFIG</code>环境变量</li><li><code>ansible.cfg</code>当前目录</li><li><code>~/.ansible.cfg</code></li><li><code>/etc/ansible/ansible.cfg</code></li></ul><p><br></p><p><a href="https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings" target="_blank" rel="noopener">Ansible配置参考</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Ansible移植指南"><a href="#Ansible移植指南" class="headerlink" title="Ansible移植指南"></a>Ansible移植指南</h1><p>Ansible Porting Guides: <a href="https://docs.ansible.com/ansible/latest/porting_guides/porting_guides.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/porting_guides/porting_guides.html</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="用户指南"><a href="#用户指南" class="headerlink" title="用户指南"></a>用户指南</h1><p>User Guide: <a href="https://docs.ansible.com/ansible/latest/user_guide/index.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/index.html</a></p><p>本指南介绍如何使用Ansible工作，包括CLI, invetory, playbooks。</p><p><br><br><br></p><h2 id="Quickstart"><a href="#Quickstart" class="headerlink" title="Quickstart"></a>Quickstart</h2><p>Ansible Quickstart Guide: <a href="https://docs.ansible.com/ansible/latest/user_guide/quickstart.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/quickstart.html</a></p><p><br><br><br></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Ansible concepts: <a href="https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/basic_concepts.html</a></p><ul><li><strong>Controle node</strong>：按照Ansible的任意机器。Windows机器无法作为控制节点。可以有多个控制节点。</li><li><strong>Managed nodes</strong>：使用Ansible管理的网络设备。通常称为主机，Ansible未安装在管理节点上。</li><li><strong>Inventory</strong>：一组管理节点的列表。清单文件有时称为主机文件(hostfile)。</li><li><strong>Modules</strong>：Ansible执行代码单元。<a href="https://docs.ansible.com/ansible/latest/modules/modules_by_category.html#modules-by-category" target="_blank" rel="noopener">Ansible模块列表</a></li><li><strong>Tasks</strong>：Ansible中的动作单元。可使用<code>ad-hoc</code>命令执行单一任务一次。</li><li><strong>Playbooks</strong>：任务的有序列表。可按照顺序反复执行这些任务。剧本可以包含变量和任务。它以YAML格式编写。</li></ul><p><br><br><br></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>Getting Started: <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html</a></p><p>一个基本的Ansible命令或playbooks：</p><ul><li>从清单中选择机器来执行</li><li>连接到这些机器（通常是SSH）</li><li>复制一个或多个模块到远程机器，并执行</li></ul><p>Ansible可以做很多事。一旦你理解了Ansible是如何工作的，你可以阅读有关的<code>ad-hoc</code>命令的详细信息，使用清单组织你的基础架构，并利用Ansible强大的playbooks。</p><p><br><br><br></p><h3 id="从清单选择机器"><a href="#从清单选择机器" class="headerlink" title="从清单选择机器"></a>从清单选择机器</h3><p>Ansible从你的清单中读取管理的机器的信息。虽然你可以通过IP地址和<code>ad-hoc</code>命令，你也需要清单来增加Ansible的灵活性和重复性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个基本的清单</span><br><span class="line"># 在此文件中添加远程系统</span><br><span class="line">vim /etc/ansible/hosts</span><br><span class="line">192.0.2.50</span><br><span class="line">aserver.example.org</span><br><span class="line">bserver.example.org</span><br></pre></td></tr></table></figure><p>也可以使用别名(aliases)，主机变量(host vars)，组变量(group vars)。</p><p><br><br><br></p><h3 id="连接到远程节点"><a href="#连接到远程节点" class="headerlink" title="连接到远程节点"></a>连接到远程节点</h3><p>Ansible与远程机器通过SSH协议进行通信。默认情况下，Ansible使用原生的OpenSSH连接到远程机器。</p><p>确认用户名可使用SSH进行连接。如有必要，将SSH公钥添加到系统的<code>authorized_keys</code>文件。</p><p><br><br><br></p><h3 id="复制和执行模块"><a href="#复制和执行模块" class="headerlink" title="复制和执行模块"></a>复制和执行模块</h3><p>一旦建立连接，Ansible传输你的命令或剧本需要的模块到远程机器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 运行第一个ansible命令</span><br><span class="line">ansible all -m ping</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 运行一个节点上的命令</span><br><span class="line">ansible all -a &quot;/bin/echo hell&quot;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="如何构建清单"><a href="#如何构建清单" class="headerlink" title="如何构建清单"></a>如何构建清单</h2><p>How to build your inventory: <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html</a></p><p>Ansible对多个被管理的节点使用被称为清单的列表或组列表。一旦清单定义，你可以选择主机或组来运行。</p><p>清单的默认位置是<code>/etc/ansible/hosts</code>。可以通过<code>-i</code>选项来指定不同的清单文件。也可以同时使用多个清单文件。从动态或云拉取清单。</p><p><br><br><br></p><h3 id="清单基本"><a href="#清单基本" class="headerlink" title="清单基本"></a>清单基本</h3><p>formats, hosts, groups。</p><p>清单文件有多种形式。最常用的是INI和YAML。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># INI格式</span></span><br><span class="line">mail.example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组名</span></span><br><span class="line"><span class="section">[webservers]</span></span><br><span class="line">a.example.com</span><br><span class="line">b.example.com</span><br><span class="line"></span><br><span class="line"><span class="section">[dbserver]</span></span><br><span class="line">db1.example.com</span><br><span class="line">db2.example.com</span><br><span class="line">db3.example.com</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># YAML格式</span></span><br><span class="line"><span class="attr">all:</span></span><br><span class="line"><span class="attr">  hosts:</span></span><br><span class="line">    <span class="string">mail.example.com:</span></span><br><span class="line"><span class="attr">  children:</span></span><br><span class="line"><span class="attr">    webserver:</span></span><br><span class="line"><span class="attr">      hosts:</span></span><br><span class="line">        <span class="string">a.example.com:</span></span><br><span class="line">        <span class="string">b.example.com:</span></span><br><span class="line"><span class="attr">    dbservers:</span></span><br><span class="line"><span class="attr">      hosts:</span></span><br><span class="line">        <span class="string">db1.example.com:</span></span><br><span class="line">        <span class="string">db2.example.com:</span></span><br><span class="line">        <span class="string">db3.example.com:</span></span><br></pre></td></tr></table></figure><p><br></p><p>默认组(default groups)，有两个默认组。</p><ul><li><code>all</code>：包含每个主机</li><li><code>ungrouped</code>：all中没有组的主机</li></ul><p><br></p><p>在多个组中的主机(Hosts in multiple groups)。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">all:</span></span><br><span class="line"><span class="attr">  hosts:</span></span><br><span class="line">    <span class="string">mail.example:</span></span><br><span class="line"><span class="attr">  children:</span></span><br><span class="line"><span class="attr">    webservers:</span></span><br><span class="line"><span class="attr">      hosts:</span></span><br><span class="line">        <span class="string">f.example.com:</span></span><br><span class="line">        <span class="string">b.example.com:</span></span><br><span class="line"><span class="attr">    dbservers:</span></span><br><span class="line"><span class="attr">      hosts:</span></span><br><span class="line">        <span class="string">one.example.com:</span></span><br><span class="line">        <span class="string">two.example.com:</span></span><br><span class="line"><span class="attr">    east:</span></span><br><span class="line"><span class="attr">      hosts:</span></span><br><span class="line">        <span class="string">f.example.com:</span></span><br><span class="line">        <span class="string">one.example.com:</span></span><br><span class="line"><span class="attr">    west:</span></span><br><span class="line"><span class="attr">      hosts:</span></span><br><span class="line">        <span class="string">b.example.com:</span></span><br><span class="line">        <span class="string">two.example.com:</span></span><br><span class="line"><span class="attr">    prod:</span></span><br><span class="line"><span class="attr">      children:</span></span><br><span class="line"><span class="attr">        east:</span></span><br><span class="line"><span class="attr">    test:</span></span><br><span class="line"><span class="attr">      hosts:</span></span><br><span class="line">        <span class="string">b.example.com:</span></span><br></pre></td></tr></table></figure><p><br></p><p>添加主机范围(Adding ranges of hosts)。如果有很多主机有一个类似的模式，可将其添加为一个范围，而不是单独列出每个主机名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">  webservers:</span></span><br><span class="line"><span class="attr">    hosts:</span></span><br><span class="line">      <span class="string">www[01:20].example.com:</span></span><br><span class="line"><span class="attr">  dbservers:</span></span><br><span class="line"><span class="attr">    hosts:</span></span><br><span class="line">      <span class="string">db-[a:f].example.com</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="添加变量到清单"><a href="#添加变量到清单" class="headerlink" title="添加变量到清单"></a>添加变量到清单</h3><p>Adding variables to inventory</p><p>可以在清单中存储涉及到特定主机或组的变量值。</p><p><br><br><br></p><h3 id="主机变量"><a href="#主机变量" class="headerlink" title="主机变量"></a>主机变量</h3><p>Assigning a variable to one machine: host variables</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">atlanta:</span></span><br><span class="line"><span class="attr">  hosts1:</span></span><br><span class="line"><span class="attr">    http_port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    maxRequestPerChild:</span> <span class="number">808</span></span><br><span class="line"><span class="attr">  hosts2:</span></span><br><span class="line"><span class="attr">    http_port:</span> <span class="number">303</span></span><br><span class="line"><span class="attr">    maxRequestPerChild:</span> <span class="number">909</span></span><br></pre></td></tr></table></figure><p><br></p><p>清单别名(Inventory aliases)。在清单中定义别名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">  hosts:</span></span><br><span class="line"><span class="attr">    jumper:</span></span><br><span class="line"><span class="attr">      ansible_port:</span> <span class="number">5555</span></span><br><span class="line"><span class="attr">      ansible_host:</span> <span class="number">192.0</span><span class="number">.2</span><span class="number">.50</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="组变量"><a href="#组变量" class="headerlink" title="组变量"></a>组变量</h3><p>Assigning a variable to many machines: group variables</p><p>在一组的主机中共享变量值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">atlanta:</span></span><br><span class="line"><span class="attr">  hosts:</span></span><br><span class="line"><span class="attr">    hosts1:</span></span><br><span class="line"><span class="attr">    host2:</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    ntp_server:</span> <span class="string">ntp.atlanta.example.com</span></span><br><span class="line"><span class="attr">    proxy:</span> <span class="string">proxy.atlanta.example.com</span></span><br></pre></td></tr></table></figure><p><br></p><p>继承变量值(Inheriting variable values: group variables for groups of groups)。可使用<code>children:</code>(yaml)来构建组的组，同样，可使用<code>vars:</code>来构建组变量的组变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">all:</span></span><br><span class="line"><span class="attr">  children:</span></span><br><span class="line"><span class="attr">    usa:</span></span><br><span class="line"><span class="attr">      children:</span></span><br><span class="line"><span class="attr">        southeast:</span></span><br><span class="line"><span class="attr">          children:</span></span><br><span class="line"><span class="attr">            atlanta:</span></span><br><span class="line"><span class="attr">              hosts:</span></span><br><span class="line"><span class="attr">                hosts1:</span></span><br><span class="line"><span class="attr">                hosts2:</span></span><br><span class="line"><span class="attr">            raleigh:</span></span><br><span class="line"><span class="attr">              hosts:</span></span><br><span class="line"><span class="attr">                hosts2:</span></span><br><span class="line"><span class="attr">                hosts3:</span></span><br><span class="line"><span class="attr">            vars:</span></span><br><span class="line"><span class="attr">              some_server:</span> <span class="string">foo.southeast.example.com</span></span><br><span class="line"><span class="attr">              halon_system_timeout:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">              self_destruct_countdown:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">              escape_pods:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">          northeast:</span></span><br><span class="line"><span class="attr">          norethwest:</span></span><br><span class="line"><span class="attr">          southwest:</span></span><br></pre></td></tr></table></figure><p>子组有几个属性的注意事项：</p><ul><li>子组成员的任何主机自动成为父组的成员</li><li>子组的变量的优先级高于(覆盖)父组的变量</li><li>组可以有多个父亲和孩子</li><li>主机可以在多个组，但只会有一台主机实例，合并来自多个组的数据</li></ul><p><br><br><br></p><h3 id="组织主机和组变量"><a href="#组织主机和组变量" class="headerlink" title="组织主机和组变量"></a>组织主机和组变量</h3><p>Organizing host and group variables</p><p>尽管你可以将变量存储在清单文件，但存储独立的主机和组变量可以帮助您更轻松地阻止你的变量值。主机和组变量文件必须使用YAML语法。</p><p>Ansible通过搜索清单文件或剧本文件的路径来载入主机和组变量文件。</p><p><br><br><br></p><h3 id="变量如何合并"><a href="#变量如何合并" class="headerlink" title="变量如何合并"></a>变量如何合并</h3><p>How variables are merged</p><p>默认情况下，在play运行前变量被合并到特定的主机。这使Ansible集中在主机和任务，因此组并没有真正生存在清单和主机匹配之外。Ansible覆盖变量的顺序：</p><ul><li>all group</li><li>parent group</li><li>child group</li><li>host</li></ul><p>默认情况下Ansible在相同的父/子级按字母顺序合并组，并在最后一组加载覆盖前面的组。你可以通过设置组变量<code>ansible_group_priority</code>来改变同级组合并顺序的行为。数字越大，优先级就越高。默认值是1。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># testvar == a</span></span><br><span class="line"><span class="attr">a_group:</span></span><br><span class="line"><span class="attr">  testvar:</span> <span class="string">a</span></span><br><span class="line"><span class="attr">  ansible_group_priority:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">b_group:</span></span><br><span class="line"><span class="attr">  testvar:</span> <span class="string">b</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="使用多个清单源"><a href="#使用多个清单源" class="headerlink" title="使用多个清单源"></a>使用多个清单源</h3><p>Using multiple inventory sources</p><p>可通过在命令行中或配置<code>ANSIBLE_INVENTORY</code>通过给定多个清单参数在同一时间目标多个清单源（目录，动态清单脚本，清单插件…）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># target 2 sources</span></span><br><span class="line"><span class="string">ansible-playbook</span> <span class="string">get_logs.yml</span> <span class="bullet">-i</span> <span class="string">staging</span> <span class="bullet">-i</span> <span class="string">production</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>以一个目录组合多个清单源(Aggregating inventory sources with a directory)</strong></p><p>还可以通过一个目录下结合多个清单源和原类型来创建清单。这对于动静结合主机和管理它们为一体化清单很有用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">inventory/</span></span><br><span class="line">  <span class="string">openstack.yml</span>          <span class="comment"># configure inventory plugin to get hosts from Openstack cloud</span></span><br><span class="line">  <span class="string">dynamic-inventory.py</span>   <span class="comment"># add additional hosts with dynamic inventory script</span></span><br><span class="line">  <span class="string">static-inventory</span>       <span class="comment"># add static hosts and groups</span></span><br><span class="line">  <span class="string">group_vars/</span></span><br><span class="line">    <span class="string">all.yml</span>              <span class="comment"># assign variables to all hosts</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># target inventory</span></span><br><span class="line">ansible-playbook example.yml -i inventory</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="清单参数"><a href="#清单参数" class="headerlink" title="清单参数"></a>清单参数</h3><p>Connecting to hosts: behavioral inventory parameters</p><p>以下变量控制与远程主机如何与Ansible相互作用。</p><p><br><br><br></p><h3 id="清单配置样例"><a href="#清单配置样例" class="headerlink" title="清单配置样例"></a>清单配置样例</h3><p>Inventory setup examples</p><ul><li>每个环境一个清单(One inventory per environment)</li><li>通过功能分组(Group by function)</li><li>通过地址分组(Group by location)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Example: One inventory per environment</span><br><span class="line"># inventory_test</span><br><span class="line">[dbservers]</span><br><span class="line">db01.test.example.com</span><br><span class="line">db02.test.example.com</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example: Group by function</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">dbservers</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">allow</span> <span class="string">access</span> <span class="string">from</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    iptables:</span></span><br><span class="line"><span class="attr">      chain:</span> <span class="string">INPUT</span></span><br><span class="line"><span class="attr">      jump:</span> <span class="string">ACCEPT</span></span><br><span class="line"><span class="attr">      source:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Example: Group by location</span><br><span class="line">[dc1]</span><br><span class="line">db01.test.example.com</span><br><span class="line">app01.test.example.com</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="动态清单"><a href="#动态清单" class="headerlink" title="动态清单"></a>动态清单</h2><p>Working with dynamic inventory: <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html</a></p><p><br></p><h3 id="cobbler"><a href="#cobbler" class="headerlink" title="cobbler"></a>cobbler</h3><p><br><br><br></p><h3 id="AWS-ec2"><a href="#AWS-ec2" class="headerlink" title="AWS ec2"></a>AWS ec2</h3><p><br><br><br></p><h3 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h3><p><br><br><br></p><h3 id="其它清单脚本"><a href="#其它清单脚本" class="headerlink" title="其它清单脚本"></a>其它清单脚本</h3><p>Other inventory scripts</p><p><br><br><br><br><br></p><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>Patterns: targeting hosts and groups: <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html</a></p><p>当你通过<code>ad-hoc</code>或<code>playbook</code>执行Ansible时，你必须选择要对哪些节点或组执行。模式可以让你针对清单中的特定主机或组执行。一个Ansible Pattern可以指定单个主机、IP地址、清单组、一组组、所有主机…模式非常灵活，可以排除需要的主机子集、使用通配符、正则表达式…Ansible将在包含在模式上的所有清单主机上执行。</p><p><br></p><h3 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h3><p>Using patterns</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ad-hoc</span></span><br><span class="line"><span class="comment"># ansible &#123;pattern&#125; -m &#123;module_name&#125; -a "&#123;module_options&#125;"</span></span><br><span class="line">ansible webservers -m service -a <span class="string">"name=httpd state=restarted"</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># palybook</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">&#123;play_name&#125;</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">&#123;pattern&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">restart</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">webservers</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="常见模式"><a href="#常见模式" class="headerlink" title="常见模式"></a>常见模式</h3><p>Common patterns</p><div class="table-container"><table><thead><tr><th>描述</th><th>模式</th><th>目标</th></tr></thead><tbody><tr><td>All hosts</td><td>all(*)</td><td>-</td></tr><tr><td>One host</td><td>host1</td><td>-</td></tr><tr><td>Multiple hosts</td><td>host1:host2(host1,host2)</td><td>-</td></tr><tr><td>One group</td><td>g1</td><td>-</td></tr><tr><td>Multiple groups</td><td>g1:g2</td><td>all hosts in g1 and g2</td></tr><tr><td>Excluding groups</td><td>g1:!g2</td><td>all hosts in g1 except those in g2</td></tr><tr><td>Intersection of groups</td><td>g1:&amp;g2</td><td>g1和g2的交集</td></tr></tbody></table></div><p><br><br><br></p><h3 id="模式的局限性"><a href="#模式的局限性" class="headerlink" title="模式的局限性"></a>模式的局限性</h3><p>Limitations of patterns</p><p>模式依赖于清单。如果主机或组不在清单中，则不能使用模式来目标它。如果模式中包含清单中不存在的IP地址或主机名，会报错。模式必须匹配清单语法。</p><p><br><br><br></p><h3 id="高级的模式选项"><a href="#高级的模式选项" class="headerlink" title="高级的模式选项"></a>高级的模式选项</h3><p>Advanced pattern options</p><p>常用的模式将满足你的大部分需求，但Ansible提供了几种方法来定义你需要定位(target)的主机和组。</p><p><strong>在模式中使用环境变量</strong><br>Using variables in patterns</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># playbook</span><br><span class="line">webservers:!&#123;&#123; excluded &#125;&#125;:&amp;&#123;&#123; required &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>在模式中使用组位置</strong><br>Using group position in patterns</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[g1]</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">cc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1[0]</span><br><span class="line">g1[-1]</span><br><span class="line">g1[0:2]</span><br><span class="line">g1[1:]</span><br></pre></td></tr></table></figure><p><strong>在模式中使用正则</strong><br>Using regexes in patterns</p><p>以<code>~</code>符号开始使用模式的正则: <code>~(web|db).*\.example\.com</code></p><p><br><br><br></p><h3 id="playbook标志"><a href="#playbook标志" class="headerlink" title="playbook标志"></a>playbook标志</h3><p>Patterns and ansible-playbook flags</p><p>可以使用命令行选项改变playbook中定义的行为。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook site.yml --<span class="built_in">limit</span> datacenter2</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="ad-hoc"><a href="#ad-hoc" class="headerlink" title="ad-hoc"></a>ad-hoc</h2><p>Introduction to ad-hoc commands: <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_adhoc.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/intro_adhoc.html</a></p><p>一个Ansible的<code>ad-hoc</code>命令使用ansible命令行工具在一个或多个管理节点上执行单一任务。<code>ad-hoc</code>命令是快速和容易的，但却无法重复使用。那么为什么首先学习<code>ad-hoc</code>命令呢？它表明Ansible的简单和功能。在这学的内容可直接到playbook里。在执行前，请先阅读构建清单。</p><p><code>ansible</code>命令行实用程序的默认模块是<a href="https://docs.ansible.com/ansible/latest/modules/command_module.html" target="_blank" rel="noopener">command module</a>。</p><p>如果像重复一个命令，可使用playbook中的template module。</p><p><br></p><h3 id="为什么使用它"><a href="#为什么使用它" class="headerlink" title="为什么使用它"></a>为什么使用它</h3><p>Why use ad-hoc commands?</p><p><code>ad-hoc</code>命令针对的是很少会重复的任务。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 栗子</span></span><br><span class="line">ansible [pattern] -m [module] -a <span class="string">"[module options]"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>Use cases for ad-hoc tasks</p><p><code>ad-hoc</code>任务可用来重启服务器、复制文件、管理包和用户…可在<code>ad-hoc</code>任务中使用任意Ansible模块。Ad-hoc tasks与playbooks类似，使用一个声明模型，计算并执行以达到规定的最终状态所需的操作。</p><p><br></p><p><strong>重启服务器</strong></p><p><code>ad-hoc</code>任务调用命令模块。在执行前，确保清单和SSH。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rebooting servers</span></span><br><span class="line">ansible host1 -a <span class="string">"/sbin/reboot"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认是5并发进程</span></span><br><span class="line">ansible host1 -a <span class="string">"/sbin/reboot"</span> -f 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible将默认为你的用户账户</span></span><br><span class="line">ansible host1 -a <span class="string">"/sbin/reboot"</span> -f 10 -u username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务器可能需要特权提升，如从user到root</span></span><br><span class="line">ansible host1 -a <span class="string">"/sbin/reboot"</span> -f 10 -u username --become [--ask-become-pass]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用不同的模块</span></span><br><span class="line">ansible host1 -m shell -a <span class="string">'echo $&#123;TERM&#125;'</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>文件管理</strong></p><p><code>ad-hoc</code>可利用Ansible和scp的力量，并行传输文件到多台机器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制文件</span></span><br><span class="line">ansible atlanta -m copy -a <span class="string">"src=/etc/hosts dest=/tmp/hosts"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># file模块属主和权限，创建目录，递归删除</span></span><br><span class="line">ansible webservers -m file -a <span class="string">"dest=/srv/foo/b.txt mode=600 owner=mdehaan group=mdehaan"</span></span><br><span class="line">ansible webservers -m file -a <span class="string">"dest=/path/to/c mode=755 owner=mdehaan group=mdehaan state=directory"</span></span><br><span class="line">ansible webservers -m file -a <span class="string">"dest=/path/to/c state=absent"</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>包管理</strong></p><p>使用<code>ad-hoc</code>任务使用包管理模块（如yum），来安装、升级、移除包。</p><p>Ansible有许多平台的许多包管理工具的模块，详情请看文档。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装了包不更新</span></span><br><span class="line">ansible webservers -m yum -a <span class="string">"name=acme state=present"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定包版本</span></span><br><span class="line">ansible webservers -m yum -a <span class="string">"name=acme-1.5 state=present"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认包是最新版</span></span><br><span class="line">ansible webservers -m yum -a <span class="string">"name=acme state=latest"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保未安装</span></span><br><span class="line">ansible webservers -m yum -a <span class="string">"name=acme state=absent"</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>管理用户和组</strong></p><p>使用<code>ad-hoc</code>任务在管理的节点上创建、管理、移除用户账户。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m user -a <span class="string">"name=foo password=&#123;crypted password here&#125;"</span></span><br><span class="line"></span><br><span class="line">ansible all -m user -a <span class="string">"name=foo state=absent"</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>服务管理</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保服务已启动</span></span><br><span class="line">ansible webservers -m service -a <span class="string">"name=httpd state=started"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">ansible webservers -m service -a <span class="string">"name=httpd state=restarted"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保服务已停止</span></span><br><span class="line">ansible webservers -m service -a <span class="string">"name=httpd state=stopped"</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>收集事实</strong></p><p>事实代表发现关于系统的变量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有facts</span></span><br><span class="line">ansible all -m setup</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="连接方法和详情"><a href="#连接方法和详情" class="headerlink" title="连接方法和详情"></a>连接方法和详情</h2><p>Connection methods and details: <a href="https://docs.ansible.com/ansible/latest/user_guide/connection_details.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/connection_details.html</a></p><p><br></p><h3 id="ControlPersist和paramiko"><a href="#ControlPersist和paramiko" class="headerlink" title="ControlPersist和paramiko"></a>ControlPersist和paramiko</h3><p>默认情况下，Ansible使用原生的OpenSSH，因为它支持ControlPersist（一个性能特点），Kerberos，和<code>~/.ssh/config</code>中的配置。如果你的控制机使用的旧版本OpenSSH不支持ControlPersist，Ansible将回退到称为<code>paramiko</code>的一个Python实现的OpenSSH。</p><p><br><br><br></p><h3 id="ssh-key配置"><a href="#ssh-key配置" class="headerlink" title="ssh-key配置"></a>ssh-key配置</h3><p>SSH key setup</p><p>默认情况下，Ansible假定您使用SSH keys连接到远程主机。推荐使用key，但可使用<code>--ask-pass</code>选项来使用密码。使用<code>--ask-become-pass</code>选项来使用特权提升。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立ssh agent来避免输入密码</span></span><br><span class="line">ssh-agent bash</span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><p>Running against localhost</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible localhost -m ping -e <span class="string">'ansible_python_interpreter="/usr/bin/env python"'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="主机密钥检查"><a href="#主机密钥检查" class="headerlink" title="主机密钥检查"></a>主机密钥检查</h3><p>Host key checking</p><p>Ansible默认启用主机密钥检查。如果主机重装并在<code>known_hosts</code>中有不同的密钥，这将导致一个错误消息，知道纠正。</p><p>可在<code>/etc/ansible/ansible.cfg</code>或<code>~/.ansible.cfg</code>中禁用它:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[defaults]</span><br><span class="line">host_key_checking = False</span><br></pre></td></tr></table></figure><p>或设置环境变量: <code>export ANSIBLE_HOST_KEY_CHECKING=False</code></p><p><br><br><br></p><h3 id="其它连接方法"><a href="#其它连接方法" class="headerlink" title="其它连接方法"></a>其它连接方法</h3><p>Other connection methods</p><p>除了SSH之外，Ansible还可以使用许多连接方法。</p><p><br><br><br><br><br></p><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>Working with command line tools: <a href="https://docs.ansible.com/ansible/latest/user_guide/command_line_tools.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/command_line_tools.html</a></p><p>大多数用户对<code>ansible</code>和<code>ansilbe-playbook</code>比较熟悉，但它们不是Ansible提供的唯一实用工具。下面是完整的Ansible使用工具列表。</p><ul><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible.html" target="_blank" rel="noopener">ansible</a>: 在一组主机上定义和运行一个单任务playbook</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-config.html" target="_blank" rel="noopener">ansible-config</a>: 查看Ansible配置信息</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-console.html" target="_blank" rel="noopener">ansible-console</a>: REPL控制台执行Ansible任务</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-doc.html" target="_blank" rel="noopener">ansible-doc</a>: 插件文档工具</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-galaxy.html" target="_blank" rel="noopener">ansible-galaxy</a>: 执行各种角色并收集相关的操作</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-inventory.html" target="_blank" rel="noopener">ansible-invotory</a>: 显示或转配置清单</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-playbook.html" target="_blank" rel="noopener">ansible-playbook</a>: 运行Ansible playbook</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-pull.html" target="_blank" rel="noopener">ansible-pull</a>: 从仓库拉playbook并为本地主机执行</li><li><a href="https://docs.ansible.com/ansible/latest/cli/ansible-vault.html" target="_blank" rel="noopener">ansible-valut</a>: Ansible数据文件的加解密工具</li></ul><p><br><br><br><br><br></p><h2 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h2><p>Working With Playbooks: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks.html</a></p><p>Playbooks是Ansible的配置(configuration)、部署(deployment)和编排(orchestration)语言。它可以描述你希望你的远程系统强制执行的策略，或在IT流程的步骤。</p><p>在最基本的级别上，playbook可以被用来管理部署的配置到远程机器。在更高级的，它们可以序列进行涉及多层(mulit-tier)的滚动更新和回滚，并可以委托操作其它主机，与监控服务器进行交互和负载均衡。它有很多功能和信息，详情看文档。</p><p>playbook被设计为人类可读的和基于文本语言开发。有多种方式来组织playbook和它包含的文件。</p><p>你应该看一看<a href="https://github.com/ansible/ansible-examples" target="_blank" rel="noopener">Example Playbooks</a>，并与playbook文档一起阅读。这些说明的最佳实践，以及如何把众多的各种概念混合在一起。</p><p><br></p><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Intro to Playbooks: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html</a></p><p>playbook是比在<code>ad-hoc</code>任务执行模式下的一个完全不同的使用ansible的方式，并且特别强大。</p><p>简单来说，Playbook是一个非常基础的用于配置管理和多机部署系统，不同于任何已存在的，并且非常适合部署复杂的应用程序。</p><p>playbook可以声明配置，但它也可以通过编排任意手动排序进程的步骤，尽管不同的步骤必须来回在特定命令的机器之间。它可以同步(synchronously)或异步(asynchronously)发射任务。</p><p>虽然你为<code>ad-hoc</code>任务运行主要的<code>/usr/bin/ansible</code>程序，playbook更可能被保持在原控制和用于推送配置或保证远程系统上的配置。palybook example中有许多栗子，建议去看一看。</p><p><br></p><h4 id="playbook-language"><a href="#playbook-language" class="headerlink" title="playbook language"></a>playbook language</h4><p>playbook以YAML语法格式表示，故意不设计成一种编程语言或脚本，而是过程或配置的模型。</p><p>每个playbooks由列表中的play组成。play的目标是映射一组主机到一些良好定义的角色(roles)，由ansible调用任务来表示。通过多个paly组成playbook，有可能协调多机部署，在某个组的所有机器上运行某些步骤…你可以由相当多的影响你的系统做不同事情的paly。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅包含一个paly的`verigy-apache.yml`的playbook的栗子</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webserver</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    http_port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    max_clients:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">at</span> <span class="string">the</span> <span class="string">latest</span> <span class="string">version</span></span><br><span class="line"><span class="attr">    yum:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">latest</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">write</span> <span class="string">the</span> <span class="string">apache</span> <span class="string">config</span> <span class="string">file</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">      src:</span> <span class="string">/srv/httpd.j2</span></span><br><span class="line"><span class="attr">      dest:</span> <span class="string">/etc/httpd.conf</span></span><br><span class="line"><span class="attr">    notify:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">running</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">started</span></span><br><span class="line"><span class="attr">  handlers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">      service:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包含多个play的栗子</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">at</span> <span class="string">the</span> <span class="string">lastest</span> <span class="string">version</span></span><br><span class="line"><span class="attr">    yum:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">latest</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">write</span> <span class="string">the</span> <span class="string">apache</span> <span class="string">config</span> <span class="string">file</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">      src:</span> <span class="string">/srv/httpd.j2</span></span><br><span class="line"><span class="attr">      dest:</span> <span class="string">/etc/httpd.conf</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">databases</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ensure</span> <span class="string">pgsql</span> <span class="string">is</span> <span class="string">at</span> <span class="string">the</span> <span class="string">latest</span> <span class="string">version</span></span><br><span class="line"><span class="attr">    yum:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">postgresql</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">latest</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ensure</span> <span class="string">that</span> <span class="string">postgresql</span> <span class="string">is</span> <span class="string">started</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">postgresql</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">started</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><p>Basics</p><p><br></p><p><strong>主机和用户</strong><br>Hosts and Users</p><p>对于playbook中的每个play，你可以选择哪些机器在你的基础设施到目标，什么远程用户完成这些步骤。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hosts行是一个或多个主机或组的模式，以冒号分隔</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">      ping:</span></span><br><span class="line"><span class="attr">      remote_user:</span> <span class="string">username</span> <span class="comment"># 远程用户可在每个用户中定义</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特权提升</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">username</span></span><br><span class="line"><span class="attr">  become:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可在每个paly中使用become</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">g1</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">uername</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - service:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">started</span></span><br><span class="line"><span class="attr">      become:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">      become_method:</span> <span class="string">sudo</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 权限提升为特定用户</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">g1</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">username</span></span><br><span class="line"><span class="attr">  become:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">  become_user:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 控制运行顺序，默认是清单里面的顺序</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  order:</span> <span class="string">sorted</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">False</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        var:</span> <span class="string">inventory_hostname</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>任务列表</strong><br>Tasks list</p><p>每个play包含任务列表。任务在移动到下一个任务之前执行，一次一个，由模式匹配的所有主机。理解在一个play中，所用主机都将得到同样的任务指令是很重要的。这是play映射选择主机到任务的目的。</p><p>当运行playbook时，它从上到下运行，失败任务的主机被从playbook轮转中取出。如果事情失败，只是纠正playbook文件，然后重新运行。</p><p>每个任务的目标是执行带有特定参数的模块，变量可以在参数中传给模块。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个任务的基本栗子</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">make</span> <span class="string">sure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">running</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">started</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># command, shell模块</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">enable</span> <span class="string">selinux</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">/sbin/setenfore</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">run</span> <span class="string">this</span> <span class="string">command</span> <span class="string">and</span> <span class="string">ignore</span> <span class="string">the</span> <span class="string">result</span></span><br><span class="line"><span class="attr">    shell:</span> <span class="string">/usr/bin/somecommand</span> <span class="string">||</span> <span class="string">/bin/true</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">create</span> <span class="string">a</span> <span class="string">virtual</span> <span class="string">host</span> <span class="string">file</span> <span class="string">for</span> <span class="string">&#123;&#123;</span> <span class="string">vhost&#125;&#125;</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">      src:</span> <span class="string">somefile.j2</span></span><br><span class="line"><span class="attr">      dest:</span> <span class="string">/etc/httpd/conf.d/&#123;&#123;</span> <span class="string">vhost&#125;&#125;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="action-shorthand"><a href="#action-shorthand" class="headerlink" title="action shorthand"></a>action shorthand</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ansible prefers listing modules like this:</span></span><br><span class="line"><span class="attr">template:</span></span><br><span class="line"><span class="attr">  src:</span> <span class="string">template/foo.j2</span></span><br><span class="line"><span class="attr">  dest:</span> <span class="string">/etc/foo.conf</span></span><br></pre></td></tr></table></figure><p>早期版本使用以下格式，仍旧有效: <code>action: template src=templates/foo.j2 dest=/etc/foo.conf</code></p><p><br><br><br></p><h4 id="Handlers"><a href="#Handlers" class="headerlink" title="Handlers"></a>Handlers</h4><p>Handlers: Running Operations On Change</p><p>如前所述，当远程系统上做了改变时模块应该是幂等的和可以中继(relay)。playbook认识到了这一点，并有一个基本的事件系统用于应对改变。</p><p>这些play中的<code>notify</code>行动在任务的每个末尾块触发，即使被多个不同任务通知也只能被触发一次。</p><p>例如，多个资源可能表明Apache需要重启，因为配置文件发生了更改，但Apache将跳跃一次，以避免不必要的重启。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当一个文件的内容更改时（仅此文件），重启两个服务的栗子</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">template</span> <span class="string">configuration</span> <span class="string">file</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">template.j2</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">/etc/foo.conf</span></span><br><span class="line"><span class="attr">  notify:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">restart</span> <span class="string">memcached</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">restart</span> <span class="string">apache</span></span><br></pre></td></tr></table></figure><p>在任务的<code>notify</code>中列出的事情的部分被称为处理程序(handlers)。</p><p>处理程序是任务列表，与常规的任务没什么区别，由一个全局唯一的名称进行引用，并通过通知程序(notifier)进行通知。如果没有事情通知一个处理程序，它将不会运行。不管有多少任务通知处理程序，它只能运行一次，在一个特定paly中的所有任务完成之后。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># handlers section</span></span><br><span class="line"><span class="attr">handlers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">restart</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">restarted</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">restart</span> <span class="string">apached</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><p>你可能想让Ansible handlers使用变量。如果handlers name使用的变量不可用，则整个paly将失败。取而代之的是，在handlers的任务参数中使用变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">Set</span> <span class="string">host</span> <span class="string">variables</span> <span class="string">based</span> <span class="string">on</span> <span class="string">distribution</span></span><br><span class="line"><span class="attr">    include_vars:</span> <span class="string">"<span class="template-variable">&#123;&#123; ansible_facts.distribution&#125;&#125;</span>.yml"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">handlers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">restart</span> <span class="string">web</span> <span class="string">service</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">"<span class="template-variable">&#123;&#123; web_service_name | default('httpd') &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><p>Ansible 2.2，handlers可以监听(listen)通用话题(generic topics)，任务可以通知这些话题。以下这种使用使它更容易触发多个处理程序。它还从名称解耦处理程序，使得在playbook和roles之间更容易共享处理程序。（特别是当使用像Galaxy的第三方角色时）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">handlers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">restart</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">restarted</span></span><br><span class="line"><span class="attr">    listen:</span> <span class="string">"restart web service"</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">    service:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">apached</span></span><br><span class="line"><span class="attr">      state:</span> <span class="string">restarted</span></span><br><span class="line"><span class="attr">    listen:</span> <span class="string">"restart web services"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">restart</span> <span class="string">everything</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">echo</span> <span class="string">"this task will restart the web services"</span></span><br><span class="line"><span class="attr">    notify:</span> <span class="string">"resstart web service"</span></span><br></pre></td></tr></table></figure><p><br></p><blockquote><p><strong>注意:</strong><br>Notify handlers are always run in the same order they are defined, not in the order listed in the notify-statement. This is also the case for handlers using listen.<br>Handler names and listen topics live in a global namespace.<br>Handler names are templatable and listen topics are not.<br>Use unique handler names. If you trigger more than one handler with the same name, the first one(s) get overwritten. Only the last one defined will run.<br>You cannot notify a handler that is defined inside of an include. As of Ansible 2.1, this does work, however the include must be static.</p></blockquote><p><br></p><p>角色(Roles)后面会说明，但它值得指出的是：</p><ul><li>handlers notified within <code>pre_tasks</code>, <code>tasks</code>, and <code>post_tasks</code> sections are automatically flushed in the end of section where they were notified</li><li>handlers notified within <code>roles</code> section are automatically flushed in the end of <code>tasks</code> section, but before any <code>tasks</code> handlers</li><li>handlers are play scoped and as such can be used outside of the role they are defined in</li></ul><p><br><br><br></p><h4 id="执行playbook"><a href="#执行playbook" class="headerlink" title="执行playbook"></a>执行playbook</h4><p>Executing A Playbook</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook playbook.yml -f 10</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Ansible-Pull"><a href="#Ansible-Pull" class="headerlink" title="Ansible-Pull"></a>Ansible-Pull</h4><p>节点检查到重要位置，而不是推送配置给它们。<code>ansilbe-pull</code>是一个检查从git指令配置仓库的一个脚本，然后针对改内容运行<code>ansible-playbook</code>。</p><p><br><br><br></p><h4 id="Linting-playbooks"><a href="#Linting-playbooks" class="headerlink" title="Linting playbooks"></a>Linting playbooks</h4><p>你可以在执行前使用<code>ansible-lint</code>来检查playbook的运行情况。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ansible-lint</span> <span class="string">verify-apache.yml</span></span><br><span class="line"><span class="string">[403]</span> <span class="string">Package</span> <span class="string">installs</span> <span class="string">should</span> <span class="string">not</span> <span class="string">use</span> <span class="string">latest</span></span><br><span class="line"><span class="string">verify-apache.yml:8</span></span><br><span class="line"><span class="string">Task/Handler:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">at</span> <span class="string">the</span> <span class="string">latest</span> <span class="string">version</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="其它playbook验证项"><a href="#其它playbook验证项" class="headerlink" title="其它playbook验证项"></a>其它playbook验证项</h4><p>Other playbook verification options</p><p>查看<a href="https://docs.ansible.com/ansible/latest/community/other_tools_and_programs.html#validate-playbook-tools" target="_blank" rel="noopener">验证playbook工具</a>的详情列表，你可以使用它们来验证playbook。这里有些情况你应该考虑：</p><ul><li>要检查playbook语法问题，使用<code>ansible-playbook</code>的<code>--syntax-check</code>标志。</li><li>要查看完整的输出信息，使用<code>--verbose</code>标志。</li><li>要查看playbook会影响哪些主机，可运行: <code>ansible-playbook playbook.yml --list-hosts</code></li></ul><p><br><br><br></p><h3 id="可重复使用的playbook"><a href="#可重复使用的playbook" class="headerlink" title="可重复使用的playbook"></a>可重复使用的playbook</h3><p>Creating Reusable Playbooks: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html</a></p><p>虽然可以在一个非常大的文件里编写playbook，最终你会想重新使用文件和整理东西。在Ansible中，有三种方式可以做到这一点：</p><ul><li>includes</li><li>imports</li><li>roles</li></ul><p>includes和imports允许用户将大型playbook分解为小型文件，可跨多个parent playbook或设置多次在相同的playbook里。<br>roles允许不仅仅是任务可以打包在一起，可以包括变量(variables)，处理程序(handlers)，甚至模块(modules)和其它插件(plugins)。不同于includes和imports，roles也可上传并经由Ansible Galaxy共享。</p><p><br></p><h4 id="including和importing"><a href="#including和importing" class="headerlink" title="including和importing"></a>including和importing</h4><p>Including and Importing: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_includes.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_includes.html</a></p><p>include和import语句相似，但Ansible执行引擎处理它们却非常不同。</p><p><code>import*</code>语句在playbook被解析的时候进行预处理(pre-processed)。<br><code>include*</code>语句在playbook的执行过程中遇到才处理。</p><p>include和import语句可以在任意深度使用。</p><p><br></p><p>在一个master playbook内包含playbook：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- import_playbook:</span> <span class="string">a.yml</span></span><br><span class="line"><span class="attr">- import_playbook:</span> <span class="string">b.yml</span></span><br></pre></td></tr></table></figure><p>每个playbook中列出的plays和tasks将以列出的顺序 执行，就好像它们已经在这里直接定义。</p><p><br></p><p>大型任务划分成不同的文件是组织复杂任务或重用它们的一种好方式。一个任务文件只包含简单的任务列表：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">aaa</span></span><br><span class="line"><span class="attr">  command:</span> <span class="string">/bin/aaa</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">bbb</span></span><br><span class="line"><span class="attr">  command:</span> <span class="string">/bin/bbb</span></span><br></pre></td></tr></table></figure><p>可以使用<code>import_tasks</code>或<code>include_tasks</code>来执行在主任务列表中的文件的任务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">- import_tasks:</span> <span class="string">aaa_tasks.yml</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="attr">- include_tasks:</span> <span class="string">aaa_tasks.yml</span></span><br></pre></td></tr></table></figure><p>你也可以传递变量到imports和includes：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">- import_tasks:</span> <span class="string">aaa.yaml</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    user:</span> <span class="string">aaa</span></span><br><span class="line"><span class="attr">- import_tasks:</span> <span class="string">aaa.yml</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    user:</span> <span class="string">bbb</span></span><br><span class="line"><span class="attr">- import_tasks:</span> <span class="string">aaa.yml</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    user:</span> <span class="string">ccc</span></span><br></pre></td></tr></table></figure><p><br></p><p>include和import同样可以用于<code>handlers:</code>部分。栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># more_handlers.yml</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">  service:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">handlers:</span></span><br><span class="line"><span class="attr">- include_tasks:</span> <span class="string">more_handlers.yml</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="attr">- import_tasks:</span> <span class="string">more_handlers.yml</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h4><p>roles: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html</a></p><p>角色(role)是基于已知的文件架构自动加载某些变量文件、任务和处理程序的方式。按角色分组的内容还可以方便地与其他用户共享。</p><p><br></p><h5 id="角色目录结构"><a href="#角色目录结构" class="headerlink" title="角色目录结构"></a>角色目录结构</h5><p>Role Directory Structure</p><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">site.yml</span></span><br><span class="line"><span class="string">webservers.yml</span></span><br><span class="line"><span class="string">fooservers.yml</span></span><br><span class="line"><span class="string">roles/</span></span><br><span class="line">    <span class="string">common/</span></span><br><span class="line">        <span class="string">tasks/</span></span><br><span class="line">        <span class="string">handlers/</span></span><br><span class="line">        <span class="string">files/</span></span><br><span class="line">        <span class="string">templates/</span></span><br><span class="line">        <span class="string">vars/</span></span><br><span class="line">        <span class="string">defaults/</span></span><br><span class="line">        <span class="string">meta/</span></span><br><span class="line">    <span class="string">webservers/</span></span><br><span class="line">        <span class="string">tasks/</span></span><br><span class="line">        <span class="string">defaults/</span></span><br><span class="line">        <span class="string">meta/</span></span><br></pre></td></tr></table></figure><p>角色在特定目录名下期待文件。角色必须包括这些目录中的至少一个，但它是完全没排除任何未使用。在使用时，每个目录必须包含一个<code>main.yml</code>文件，其中包含的相关内容：</p><ul><li><code>tasks</code>：包含由角色执行的主任务列表</li><li><code>handlers</code>：包含可通过此角色甚至此角色外的任何地方使用的处理程序</li><li><code>defaults</code>：角色的默认变量</li><li><code>vars</code>：角色的其它变量</li><li><code>files</code>：通过此角色可以部署的文件</li><li><code>templates</code>：通过此角色可以部署的模板</li><li><code>meta</code>：为角色定义的元数据</li></ul><p>其它YAML文件可能包含在特定目录。栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># roles/example/tasks/main.yml</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">added</span> <span class="string">in</span> <span class="number">2.4</span><span class="string">,</span> <span class="string">previously</span> <span class="string">you</span> <span class="string">used</span> <span class="string">include</span></span><br><span class="line"><span class="attr">  import_tasks:</span> <span class="string">redhat.yml</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">ansible_facts['os_family']|lower</span> <span class="string">==</span> <span class="string">'redhat'</span></span><br><span class="line"><span class="attr">  import_tasks:</span> <span class="string">debian.yml</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">ansible_facts['os_family']|lower</span> <span class="string">==</span> <span class="string">'debian'</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># roles/example/tasks/redhat.yml</span></span><br><span class="line"><span class="attr">- yum:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">"httpd"</span></span><br><span class="line"><span class="attr">  state:</span> <span class="string">present</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># roles/example/tasks/debian.yml</span></span><br><span class="line"><span class="attr">- pat:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">"apache2"</span></span><br><span class="line"><span class="attr">  state:</span> <span class="string">present</span></span><br></pre></td></tr></table></figure><p>角色还可以包含模块和其它插件类型。</p><p><br><br><br></p><h5 id="角色使用"><a href="#角色使用" class="headerlink" title="角色使用"></a>角色使用</h5><p>使用角色的原始的方式是在play中通过<code>roles:</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">common</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">webservers</span></span><br></pre></td></tr></table></figure><p>这将为每个角色(x)指定以下行为：</p><ul><li>如果<code>roles/x/tasks/main.yml</code>存在，其中列出的任务将被添加到play；</li><li>如果<code>roles/x/handlers/main.yml</code>存在，其中列出的处理程序将被添加到play；</li><li>如果<code>roles/x/vars/main.yml</code>存在，其中列出的变量将被添加到play；</li><li>如果<code>roles/x/defaults/main.yml</code>存在，其中列出的变量将被添加到play；</li><li>如果<code>roles/x/meta/main.yml</code>存在，其中列出的任何角色的依赖都将被添加到角色列表；</li><li>角色中的任意copy, script, template, include tasks，可在<code>roles/x/{files,templates,tasks}/dir</code>进行引用，而不必关心它们的相对或绝对路径。</li></ul><p>当以这种方式使用时，playbook的执行顺序如下：</p><ul><li>play中定义的任意<code>pre_tasks</code></li><li>任意处理程序触发到目前为止将会运行</li><li>在roles中列出的每个角色将依次执行。在角色<code>meta/main.yml</code>中定义的任意角色依赖将首先运行，受标签过滤和条件</li><li>play中定义的任意<code>tasks</code></li><li>任意处理程序触发到目前为止将会运行</li><li>play中定义的任意<code>post_tasks</code></li><li>任意处理程序触发到目前为止将会运行</li></ul><p>可使用<code>import_role</code>或<code>include_role</code>在其它任务中使用角色：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">"before we run our role"</span></span><br><span class="line"><span class="attr">    - import_role:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">example</span></span><br><span class="line"><span class="attr">    - include_role:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">example</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">"after we ran our role"</span></span><br></pre></td></tr></table></figure><p>当角色在原始方式中定义，它们被视为静态导入和在playbook解析时进行处理。</p><p>角色的名称可是很简单，也可以是一个完全合格的路径：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="attr">    - role:</span> <span class="string">'/path/to/roles/common'</span></span><br></pre></td></tr></table></figure><p>角色可以接受其它关键字：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - include_role:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">foo_app_instance</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">"ansible_facts['os_family'] == 'RedHat'"</span></span><br><span class="line"><span class="attr">      vars:</span></span><br><span class="line"><span class="attr">        dir:</span> <span class="string">'/opt/a'</span></span><br><span class="line"><span class="attr">        app_port:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">      tags:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">aaa</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">bbb</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="角色副本和扩展"><a href="#角色副本和扩展" class="headerlink" title="角色副本和扩展"></a>角色副本和扩展</h5><p>Role Duplication and Execution</p><p>Ansible只允许一个角色执行一次，即使多次定义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">foo</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">foo</span></span><br></pre></td></tr></table></figure><p>上面给出的<code>foo</code>角色仅将运行一次。为了使角色多次运行，有两种选择：</p><ol><li>每个角色传递不同的参数</li><li>添加<code>allow_duplicates: true</code>到<code>meta/main.yml</code>文件</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># playbook.yml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">foo</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># roles/foo/meta/main.yml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">allow_duplicates:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="角色默认变量"><a href="#角色默认变量" class="headerlink" title="角色默认变量"></a>角色默认变量</h5><p>Role Default Variables</p><p>角色的默认变量允许你为角色设定默认变量。在角色目录中添加<code>defaults/main.yml</code>文件。这些变量具有最低优先级，可以轻易被覆盖。</p><p><br><br><br></p><h5 id="角色依赖"><a href="#角色依赖" class="headerlink" title="角色依赖"></a>角色依赖</h5><p>Role Dependencies</p><p>角色依赖让你在其它角色使用角色时自动拉取。角色依赖存储在角色目录的<code>meta/main.yml</code>文件。此文件应包含角色和参数列表在指定角色之前插入：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># orles/myapp/meta/main.yml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  - role:</span> <span class="string">common</span></span><br><span class="line"><span class="attr">    vars:</span></span><br><span class="line"><span class="attr">      come_parameter:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  - role:</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">    vars:</span></span><br><span class="line"><span class="attr">      apache_port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  - role:</span> <span class="string">postgres</span></span><br><span class="line"><span class="attr">    vars:</span></span><br><span class="line"><span class="attr">      dbname:</span> <span class="string">blarg</span></span><br><span class="line"><span class="attr">      other_parameter:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="角色中的嵌入模块和插件"><a href="#角色中的嵌入模块和插件" class="headerlink" title="角色中的嵌入模块和插件"></a>角色中的嵌入模块和插件</h5><p>Embedding Modules and Plugins In Roles</p><p><br><br><br></p><h5 id="角色搜索路径"><a href="#角色搜索路径" class="headerlink" title="角色搜索路径"></a>角色搜索路径</h5><p>Ansible将按以下方式为角色搜索：</p><ul><li>相对于playbook文件的<code>roles/</code>目录</li><li>默认情况下，在<code>/etc/ansible/roles</code></li></ul><p><br><br><br></p><h5 id="Galaxy"><a href="#Galaxy" class="headerlink" title="Galaxy"></a>Galaxy</h5><p>Ansible Galaxy是一个用于查找、下载、评级、审查各种社区ansible roles的免费网站。</p><p><code>ansible-galaxy</code>客户端包含在Ansible中。可使用它从Ansible Galaxy下载角色。</p><p><br><br><br></p><h4 id="动态与静态"><a href="#动态与静态" class="headerlink" title="动态与静态"></a>动态与静态</h4><p>Dynamic vs. Static</p><p>Ansible有两种操作模式用于可重用内容：动态与静态。</p><p>如果你使用<code>include*</code>，它将是动态的。如果你使用<code>import*</code>，它是静态的。</p><p><br></p><p><strong>动态与静态的区别</strong></p><p>两种操作模式都非常简单：</p><ul><li>动态包含在遇到任务运行时处理</li><li>静态导入在解析playbook前处理</li></ul><p>当遇到<code>tag</code>或<code>when</code>：</p><ul><li>动态包含仅适用于动态的任务，不会复制到子任务</li><li>静态导入，将被复制到所有子任务</li></ul><p><br><br><br></p><h4 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h4><p>使用<code>include*</code>与<code>import*</code>有一定的优势，权衡两者。</p><p>使用<code>include*</code>语句的最大优势是循环。当在include中使用循环，所包含的将在每个循环中执行。</p><ul><li>tags仅在动态包含内存在</li><li>tasks仅在动态包含内存在</li><li>在动态包含内不能使用<code>notify</code>来触发处理程序</li><li><p>在动态包含内不能使用<code>--start-at-task</code>来开始执行</p></li><li><p>静态导入内循环不能使用</p></li><li>静态导入内不能从库存源使用变量</li><li>静态导入内当通知它们的名字时，使用处理程序将不会触发</li></ul><p><br><br><br></p><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>Using Variables: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html</a></p><p>Ansible中使用变量可以更好地帮助处理各系统之间的差异。</p><p><br></p><h4 id="创建有效的变量名"><a href="#创建有效的变量名" class="headerlink" title="创建有效的变量名"></a>创建有效的变量名</h4><p>Creating valid variable names</p><p>有效的变量名是很重要的。变量名应该是字母 、数字和下划线，且总是以字母开头。</p><p>YAML也支持映射键值对的字典：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">foo:</span></span><br><span class="line"><span class="attr">  field1:</span> <span class="string">one</span></span><br><span class="line"><span class="attr">  field2:</span> <span class="string">two</span></span><br></pre></td></tr></table></figure><p>你可以使用中括号或点来引用特定字段的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo[&apos;field1&apos;]</span><br><span class="line">foo.field2</span><br></pre></td></tr></table></figure><p>请注意，如果使用点来引用，它们属性和Python字典的方法相冲突可能会导致一些问题。如果你使用的键开始和结束有两个下划线，或它们是已知的公共属性，则你应该使用中括号来代替点使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 公共属性</span><br><span class="line">add, append, count, decode...</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="在清单中定义变量"><a href="#在清单中定义变量" class="headerlink" title="在清单中定义变量"></a>在清单中定义变量</h4><p>Defining variables in inventory</p><p>通常，你需要为单独的主机或组设置变量。你可以在清单文件(如hosts)中定义所需的变量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">west:</span></span><br><span class="line"><span class="attr">  host1:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    maxRequest:</span> <span class="number">808</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">east:</span></span><br><span class="line"><span class="attr">  hosts:</span></span><br><span class="line"><span class="attr">    host1:</span> <span class="string">xx</span></span><br><span class="line"><span class="attr">    host2:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="在playbook中定义变量"><a href="#在playbook中定义变量" class="headerlink" title="在playbook中定义变量"></a>在playbook中定义变量</h4><p>Defining variables in a playbook</p><p>你可以直接在playbook中定义变量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="在文件和角色中定义变量"><a href="#在文件和角色中定义变量" class="headerlink" title="在文件和角色中定义变量"></a>在文件和角色中定义变量</h4><p>Defining variables in included files and roles</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="attr">    - role:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">      vars:</span></span><br><span class="line"><span class="attr">        dir:</span> <span class="string">'/opt/a'</span></span><br><span class="line"><span class="attr">    - role:</span> <span class="string">test2</span></span><br><span class="line"><span class="attr">      vars:</span></span><br><span class="line"><span class="attr">        dir:</span> <span class="string">'/opt/b'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="在Jinja2中使用变量"><a href="#在Jinja2中使用变量" class="headerlink" title="在Jinja2中使用变量"></a>在Jinja2中使用变量</h4><p>Using variables with Jinja2</p><p>一旦你定义了变量，便可以在Jinja2的模板系统中引用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ma amp goes to &#123;&#123; max_amp_value &#125;&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用Jinja2过滤器转换变量"><a href="#使用Jinja2过滤器转换变量" class="headerlink" title="使用Jinja2过滤器转换变量"></a>使用Jinja2过滤器转换变量</h4><p>Transforming variables with Jinja2 filters</p><p>Jinja2 filters 让你在模板表达式内转换变量的值。如<code>capitalize</code>大写过滤器，<code>to_yaml</code>和<code>to_json</code>过滤器来转换成对应格式。</p><p>Jinja2包含了许多内置过滤器： <a href="https://jinja.palletsprojects.com/en/2.11.x/templates/#builtin-filters" target="_blank" rel="noopener">https://jinja.palletsprojects.com/en/2.11.x/templates/#builtin-filters</a><br>Ansible也支持许多过滤器： <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#playbooks-filters" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html#playbooks-filters</a></p><p><br><br><br></p><h4 id="YAML疑难杂症"><a href="#YAML疑难杂症" class="headerlink" title="YAML疑难杂症"></a>YAML疑难杂症</h4><p>Hey wait, a YAML gotcha</p><p>YAML语法要求，如果你使用<code></code>值引用整行，它要确保你不是想开始一个YAML字典。所以记得使用双引号。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wrong</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">vars:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">&#123;&#123;</span> <span class="string">dir</span> <span class="string">&#125;&#125;/22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># right</span></span><br><span class="line"><span class="attr">vars:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">"<span class="template-variable">&#123;&#123; dir &#125;&#125;</span>/22"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="系统facts中的变量"><a href="#系统facts中的变量" class="headerlink" title="系统facts中的变量"></a>系统facts中的变量</h4><p>Variables discovered from systems: Facts</p><p>facts是从远程系统获得的信息。你可以从<code>ansible_facts</code>变量中找到。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看facts</span></span><br><span class="line">ansible hostname -m setup</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- debug:</span></span><br><span class="line"><span class="attr">    var:</span> <span class="string">ansible_facts</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; ansible_facts[&apos;devices&apos;][&apos;xvda&apos;][&apos;model&apos;]&#125;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>禁用facts</strong></p><p>如果你不需要fact数据，你可以禁用它。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>Local facts(facts.d)</strong></p><p>facts通常都是由Ansible setup模块自动发现。用户也可以编写自定义的facts模块，请参考API指南。但是，如果你想要一个简单的方法来使用用户提供的数据，而不需要写一个facts模块。</p><p><code>facts.d</code>是一种可让用户控制它们的系统是如果管理的某些方面的机制。</p><p>如果远程管理系统有<code>/etc/ansible/facts.d</code>目录，该目录中的所有<code>.fact</code>文件（JSON, INI…）。可使用<code>fact_path</code> paly 关键字作为可选目录。</p><p><br><br><br></p><h4 id="注册变量"><a href="#注册变量" class="headerlink" title="注册变量"></a>注册变量</h4><p>Registering variables</p><p>另一个主要使用的变量是正在运行一个命令和将此命令的返回的结果注册为一个变量，供其它地方使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - shell:</span> <span class="string">/usr/bin/foo</span></span><br><span class="line"><span class="attr">      register:</span> <span class="string">foo_result</span></span><br><span class="line"><span class="attr">      ignore_errors:</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">    - shell:</span> <span class="string">/usr/bin/bar</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">foo_result.rc</span> <span class="string">==</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="访问复杂的变量数据"><a href="#访问复杂的变量数据" class="headerlink" title="访问复杂的变量数据"></a>访问复杂的变量数据</h4><p>Accessing complex variable data</p><p>有些提供的facts，如网络信息，包含了复杂的嵌套结构。取值会稍微麻烦一些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; ansible_facts[&apos;eth0&apos;][&apos;ipv4&apos;][&apos;address&apos;]&#125;&#125;</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">&#123;&#123; ansible_facts.eth0.ipv4.address &#125;&#125;</span><br><span class="line"></span><br><span class="line"># 访问数组的第一个元素</span><br><span class="line">&#123;&#123; foo[0] &#125;&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用magic变量访问其它主机的信息"><a href="#使用magic变量访问其它主机的信息" class="headerlink" title="使用magic变量访问其它主机的信息"></a>使用magic变量访问其它主机的信息</h4><p>Accessing information about other hosts with magic variables</p><p>无论你是否定义变量，你也可以利用特殊的Ansible变量访问有关主机的信息，包括magic, facts, connection变量。magic变量名称被保留，所以不要使用这些名称来设置变量。<code>enviroment</code>变量也同样被保留。</p><p>最常使用的魔术变量有：<code>hostvars</code>, <code>groups</code>, <code>group_names</code>, <code>inventory_hostname</code>。</p><p><code>host_vars</code>允许你访问其它主机的变量，包括该主机的facts。你可以在playbook中的任意一点访问主机变量。即使你在playbook中并没有连接到此主机，你仍可以得到变量。<br><code>groups</code>是清单中所有组的列表。这可以用于枚举组内的所有主机。<br><code>group_names</code>是所有组中当前主机的列表或数组。<br><code>inventory_hostname</code>是清单主机文件中配置的主机名。使用<code>inventory_hostname_short</code>获取更简短的信息。<br><code>ansible_play_hosts</code>是当前play中仍然活跃的主机列表。<br><code>ansible_play_batch</code>是当前批量paly上可用的主机名列表。<br><code>ansible_playbook_python</code>是python执行调用ansible命令行工具的路径。<br><code>role_path</code>返回当前角色的路径名。这仅在角色里工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; hostvars[&apos;test.example.com&apos;][&apos;ansible_facts&apos;][&apos;distribution&apos;] &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;% for host in groups[&apos;app_servers&apos;] %&#125;</span><br><span class="line">    &#123;&#123; hostvars[host][&apos;ansible_facts&apos;][&apos;eth0&apos;][&apos;ipv4&apos;][&apos;address&apos;] &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if &apos;webserver&apos; in group_names %&#125;</span><br><span class="line">    # xxx</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="在文件中定义变量"><a href="#在文件中定义变量" class="headerlink" title="在文件中定义变量"></a>在文件中定义变量</h4><p>Defining variables in files</p><p>让playbook使用版本控制是很好的想法，但你可能希望让playbook 源公开化，但同时又保证一定的重要的私有变量。</p><p>你可以通过一个外部变量文件来这么做：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    color:</span> <span class="string">blue</span></span><br><span class="line"><span class="attr">  vars_files:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/vars/external_vars.yml</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># external_vars.yml</span></span><br><span class="line"><span class="attr">user:</span> <span class="string">xx</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">xxxx</span></span><br></pre></td></tr></table></figure><p>这消除了分享playbook但避免分享数据的风险。</p><p><br><br><br></p><h4 id="在命令行上传递参数"><a href="#在命令行上传递参数" class="headerlink" title="在命令行上传递参数"></a>在命令行上传递参数</h4><p>Passing variables on the command line</p><p>可在命令行上使用<code>--extra-vars</code>参数来设置变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># k:v格式</span></span><br><span class="line">ansible-playbook release.yml --extra-vars <span class="string">"version=1.23.45 other_variable=foo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># json格式</span></span><br><span class="line">ansible-playbook arcade.yml --extra-vars <span class="string">'&#123;"pacman":"mrs","ghosts":["inky","pinky","clyde","sue"]&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件</span></span><br><span class="line">ansible-playbook release.yml --extra-vars <span class="string">"@some_file.json"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="变量的优先级：我应该把变量放在哪"><a href="#变量的优先级：我应该把变量放在哪" class="headerlink" title="变量的优先级：我应该把变量放在哪"></a>变量的优先级：我应该把变量放在哪</h4><p>Variable precedence: Where should I put a variable?</p><p>同一名称的变量如果在多个地方被定义，则它们会以特定的顺序发生覆盖，所需需要知道Ansible变量的优先级，以及它们的放置位置。下面是从小到大的优先级：</p><ol><li>command line values</li><li>role defaults</li><li>inventory file or script group vars</li><li>inventory group_vars/all</li><li>playbook group_vars/all</li><li>inventory group_vars/*</li><li>playbook group_vars/*</li><li>inventory file or script host vars</li><li>inventory host_vars/*</li><li>playbook host_vars/*</li><li>host facts / cached set_facts</li><li>play vars</li><li>play vars_prompt</li><li>play vars_files</li><li>role vars (defined in role/vars/main.yml)</li><li>block vars (only for tasks in block)</li><li>task vars (only for the task)</li><li>include_vars</li><li>set_facts/registered vars</li><li>role (and include_role) params</li><li>include params</li><li>extra vars (always win precedence)</li></ol><p><br><br><br></p><h3 id="Jinja2模板"><a href="#Jinja2模板" class="headerlink" title="Jinja2模板"></a>Jinja2模板</h3><p>Templating (Jinja2): <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html</a></p><p>Ansible使用Jinja2模板化来实现动态表达式和访问变量。Ansilbe大大扩展的filters和tests数量，以及新增了一个插件类型：lookups。</p><p>请注意，所有模板发生在Ansible控制器上，在任务发送和执行在目标主机之前。</p><p><br></p><h4 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h4><p>Filters: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html</a></p><p><br><br><br></p><h4 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h4><p>Tests: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_tests.html</a></p><p>Jinja中的测试是评估模板表达式并返回True或False。许多内置测试: <a href="https://jinja.palletsprojects.com/en/2.11.x/templates/#builtin-tests" target="_blank" rel="noopener">https://jinja.palletsprojects.com/en/2.11.x/templates/#builtin-tests</a></p><p>测试器和过滤器的主要区别是测试用于比较，而过滤去用于数据操作。测试同样可以在列表处理器中使用，如<code>map()</code>和<code>select()</code>在列表中选择项。</p><p>与所有模板一样，测试始终在Ansible控制器上执行，而不是任务的目标主机。除了这些Jinja2的测试，Ansible支持用户轻松创建自己的测试。</p><p><br><br><br></p><h4 id="Lookups"><a href="#Lookups" class="headerlink" title="Lookups"></a>Lookups</h4><p>Lookups: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_lookups.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_lookups.html</a></p><p>查找插件允许访问外部数据源。与所有模板一样，这些插件在Ansible控制器上进行评估，并且可以包括读取文件系统、对外联络网络数据存储和服务。这些数据使用Ansible标准模板系统提供。</p><p><br></p><blockquote><p><strong>注意</strong><br>查找发生在本地主机，而不是远程主机；<br>它们在包含role或play的目录内执行，而不是与执行脚本的目录执行本地任务；<br>可以传递<code>wantlist=True</code>给lookups来使用Jinja2中的for循环；<br>查找是一个高级的功能，你应该对Ansible有足够的了解。</p></blockquote><p><br><br><br></p><h4 id="Python版本和模板"><a href="#Python版本和模板" class="headerlink" title="Python版本和模板"></a>Python版本和模板</h4><p>Python Version and Templating: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_python_version.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_python_version.html</a></p><p>Jinja2模板利用Python数据类型和标准函数。这使得可对数据进行丰富的操作。然而，这也意味着潜在的Python的某些细节对模板编写者可见。由于Ansible playbook使用Jinja2用于模板与变量，这意味着playbook作者需要了解这些细节。</p><p>除了这些，请注意在Python2和Python3上运行Ansible的不同。</p><p><br><br><br></p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>Conditionals: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html</a></p><p>经常的一个play的结果可能依赖于一个变量的值，或之前的任务的结果。在某些情况下，变量的值可能依赖于其它变量。本主题介绍如何在playbook中使用条件语句。</p><p><br></p><h4 id="When语句"><a href="#When语句" class="headerlink" title="When语句"></a>When语句</h4><p>The When Statement</p><p>有时你会想在某个特定主机上跳过特定的步骤。</p><p>在Ansible中使用<code>when</code>子句很容易达到，它不包含Jinja2中的双花括号表达式。它非常简单：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"shut down CentOS 6 systems"</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">/sbin/shutdown</span> <span class="bullet">-t</span> <span class="string">now</span></span><br><span class="line"><span class="attr">    when:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ansible_facts['distribution']</span> <span class="string">==</span> <span class="string">"CentOS"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ansible_facts['distribution_major_version']</span> <span class="string">==</span> <span class="string">"6"</span></span><br></pre></td></tr></table></figure><p>许多Jinja2的测试器和过滤器都可在<code>when</code>子句中使用，其中某些是由Ansible单独提供的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - command:</span> <span class="string">/bin/false</span></span><br><span class="line"><span class="attr">    register:</span> <span class="string">result</span></span><br><span class="line"><span class="attr">    ignore_errors:</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - command:</span> <span class="string">/bin/something</span></span><br><span class="line"><span class="attr">    when:</span> <span class="string">result</span> <span class="string">is</span> <span class="string">failed</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># In older versions of ansible use ``success``, now both are valid but succeeded uses the correct tense.</span></span><br><span class="line"><span class="attr">  - command:</span> <span class="string">/bin/something_else</span></span><br><span class="line"><span class="attr">    when:</span> <span class="string">result</span> <span class="string">is</span> <span class="string">succeeded</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - command:</span> <span class="string">/bin/still/something_else</span></span><br><span class="line"><span class="attr">    when:</span> <span class="string">result</span> <span class="string">is</span> <span class="string">skipped</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">    - shell:</span> <span class="string">echo</span> <span class="string">"This certainly is epic!"</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">epic</span> <span class="string">or</span> <span class="string">monumental|bool</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">    - shell:</span> <span class="string">echo</span> <span class="string">"I've got '<span class="template-variable">&#123;&#123; foo &#125;&#125;</span>' and am not afraid to use it!"</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">foo</span> <span class="string">is</span> <span class="string">defined</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - fail:</span> <span class="string">msg="Bailing</span> <span class="string">out.</span> <span class="string">this</span> <span class="string">play</span> <span class="string">requires</span> <span class="string">'bar'</span><span class="string">"</span></span><br><span class="line"><span class="string">      when: bar is undefined</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="循环和条件"><a href="#循环和条件" class="headerlink" title="循环和条件"></a>循环和条件</h4><p>Loops and Conditionals</p><p><code>when</code>和<code>loops</code>结合使用，请注意when语句是根据每个项分别处理。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">    - command:</span> <span class="string">echo</span> <span class="string">&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">      loop:</span> <span class="string">[</span> <span class="number">0</span><span class="string">,</span> <span class="number">2</span><span class="string">,</span> <span class="number">4</span><span class="string">,</span> <span class="number">6</span><span class="string">,</span> <span class="number">8</span><span class="string">,</span> <span class="number">10</span> <span class="string">]</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">item</span> <span class="string">&gt; 5</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="在自定义facts中载入"><a href="#在自定义facts中载入" class="headerlink" title="在自定义facts中载入"></a>在自定义facts中载入</h4><p>Loading in Custom Facts</p><p>如果你想提供自己的facts也很简单。要运行它们，只需要在任务顶部调用你自己定义的模块，这里返回的变量将能访问未来的任务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">gather</span> <span class="string">site</span> <span class="string">specific</span> <span class="string">fact</span> <span class="string">data</span></span><br><span class="line"><span class="attr">      action:</span> <span class="string">site_facts</span></span><br><span class="line"><span class="attr">    - command:</span> <span class="string">/usr/bin/thingy</span></span><br><span class="line"><span class="attr">      when:</span> <span class="string">my_custom_fact_just_retrieved_from_the_remote_system</span> <span class="string">==</span> <span class="string">'1234'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Applying-when-to-roles-imports-and-includes"><a href="#Applying-when-to-roles-imports-and-includes" class="headerlink" title="Applying when to roles,imports,and includes"></a>Applying when to roles,imports,and includes</h4><p>在roles, imports, includes中使用when语句：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="attr">     - role:</span> <span class="string">debian_stock_config</span></span><br><span class="line"><span class="attr">       when:</span> <span class="string">ansible_facts['os_family']</span> <span class="string">==</span> <span class="string">'Debian'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="有条件的导入"><a href="#有条件的导入" class="headerlink" title="有条件的导入"></a>有条件的导入</h4><p>Conditional Imports</p><p>一个剧本适用于多个平台和操作系统是很好的栗子。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  vars_files:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"vars/common.yml"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">[</span> <span class="string">"vars/<span class="template-variable">&#123;&#123; ansible_facts['os_family'] &#125;&#125;</span>.yml"</span><span class="string">,</span> <span class="string">"vars/os_defaults.yml"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">make</span> <span class="string">sure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">started</span></span><br><span class="line"><span class="attr">    service:</span> <span class="string">name=&#123;&#123;</span> <span class="string">apache</span> <span class="string">&#125;&#125;</span> <span class="string">state=started</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="基于变量来选择文件和模板"><a href="#基于变量来选择文件和模板" class="headerlink" title="基于变量来选择文件和模板"></a>基于变量来选择文件和模板</h4><p>Selecting Files And Templates Based On Variables</p><p>基于不同的系统来生成不同的配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">template</span> <span class="string">a</span> <span class="string">file</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">      src:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">      dest:</span> <span class="string">/etc/myapp/foo.conf</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; query('first_found', &#123; 'files': myfiles, 'paths': mypaths&#125;) &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    myfiles:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"<span class="template-variable">&#123;&#123;ansible_facts['distribution']&#125;&#125;</span>.conf"</span></span><br><span class="line"><span class="bullet">      -</span>  <span class="string">default.conf</span></span><br><span class="line"><span class="attr">    mypaths:</span> <span class="string">['search_location_one/somedir/',</span> <span class="string">'/opt/other_location/somedir/'</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="注册变量-1"><a href="#注册变量-1" class="headerlink" title="注册变量"></a>注册变量</h4><p>Register Variables</p><p>存储一个给定命令的结果，以便后面来访问它，在playbook中可能很有用。</p><blockquote><p>注意：<br>即使当一个任务由于条件语句跳过，注册也会发生。</p></blockquote><p><code>register</code>关键字决定将结果保存哪个变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">check</span> <span class="string">registered</span> <span class="string">variable</span> <span class="string">for</span> <span class="string">emptiness</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">all</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">list</span> <span class="string">contents</span> <span class="string">of</span> <span class="string">directory</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">ls</span> <span class="string">mydir</span></span><br><span class="line"><span class="attr">        register:</span> <span class="string">contents</span></span><br><span class="line"></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">check</span> <span class="string">contents</span> <span class="string">for</span> <span class="string">emptiness</span></span><br><span class="line"><span class="attr">        debug:</span></span><br><span class="line"><span class="attr">          msg:</span> <span class="string">"Directory is empty"</span></span><br><span class="line"><span class="attr">        when:</span> <span class="string">contents.stdout</span> <span class="string">==</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="常用facts"><a href="#常用facts" class="headerlink" title="常用facts"></a>常用facts</h4><p>Commonly Used Facts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ansible_facts[‘distribution’]</span><br><span class="line"></span><br><span class="line">ansible_facts[‘distribution_major_version’]</span><br><span class="line"></span><br><span class="line">ansible_facts[‘os_family’]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>Loops: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html</a></p><p>常见的Ansible循环包括改变多个文件/目录的权限、创建多个用户、重复轮询…Ansible提供了两个关键字来创建循环：</p><ul><li><code>loop</code></li><li><code>with_&lt;lookup&gt;</code></li></ul><p><br></p><blockquote><p>注意：<br>We added loop in Ansible 2.5. It is not yet a full replacement for <code>with_&lt;lookup&gt;</code>, but we recommend it for most use cases.<br>We have not deprecated the use of <code>with_&lt;lookup&gt;</code><br>We are looking to improve loop syntax</p></blockquote><p><br></p><h4 id="两者比较-1"><a href="#两者比较-1" class="headerlink" title="两者比较"></a>两者比较</h4><p>Comparing <code>loop</code> and <code>with_*</code></p><ul><li><code>with_&lt;lookup&gt;</code>关键字依赖于Lookup插件，即便<code>items</code>也是查找；</li><li><code>loop</code>关键字等于<code>with_list</code>，它是简单循环的最佳选择；</li><li><code>loop</code>关键字不接受字符串作为输入；</li><li>一般来说，任何在Migrating from with_X to loop中使用<code>with_*</code>可以更新为使用<code>loop</code>；</li><li>当更改<code>with_items</code>为<code>loop</code>时请小心，<code>with_items</code>执行单级的。你需要在<code>loop</code>中使用<code>flatten(1)</code>。栗子如下：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">with_items:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">1</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">[2,3]</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># you would need</span></span><br><span class="line"><span class="attr">loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; [1, [2,3] ,4] | flatten(1) &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="标准循环"><a href="#标准循环" class="headerlink" title="标准循环"></a>标准循环</h4><p>Standard loops</p><p><br></p><h5 id="遍历一个简单列表"><a href="#遍历一个简单列表" class="headerlink" title="遍历一个简单列表"></a>遍历一个简单列表</h5><p>Iterating over a simple list</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">add</span> <span class="string">several</span> <span class="string">users</span></span><br><span class="line"><span class="attr">  user:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">    groups:</span> <span class="string">"wheel"</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">testuser1</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">testuser2</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="遍历一个散列列表"><a href="#遍历一个散列列表" class="headerlink" title="遍历一个散列列表"></a>遍历一个散列列表</h5><p>Iterating over a list of hashes</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">add</span> <span class="string">several</span> <span class="string">users</span></span><br><span class="line"><span class="attr">  user:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.name &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">    groups:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.groups &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'testuser1'</span><span class="string">,</span> <span class="attr">groups:</span> <span class="string">'wheel'</span> <span class="string">&#125;</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'testuser2'</span><span class="string">,</span> <span class="attr">groups:</span> <span class="string">'root'</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="遍历一个字典"><a href="#遍历一个字典" class="headerlink" title="遍历一个字典"></a>遍历一个字典</h5><p>Iterating over a dictionary</p><p>使用<code>dict2items</code>字典过滤器来遍历字典：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">create</span> <span class="string">a</span> <span class="string">tag</span> <span class="string">dictionary</span> <span class="string">of</span> <span class="string">non-empty</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  set_fact:</span></span><br><span class="line"><span class="attr">    tags_dict:</span> <span class="string">"<span class="template-variable">&#123;&#123; (tags_dict|default(&#123;&#125;))|combine(&#123;item.key: item.value&#125;) &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; tags|dict2items &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    tags:</span></span><br><span class="line"><span class="attr">      Environment:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">      Application:</span> <span class="string">payment</span></span><br><span class="line"><span class="attr">      Another:</span> <span class="string">"<span class="template-variable">&#123;&#123; doesnotexist|default() &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  when:</span> <span class="string">item.value</span> <span class="string">!=</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="循环与注册变量"><a href="#循环与注册变量" class="headerlink" title="循环与注册变量"></a>循环与注册变量</h4><p>Registering variables with a loop</p><p>你可以将循环的输出注册为变量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- shell:</span> <span class="string">"echo <span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"one"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"two"</span></span><br><span class="line"><span class="attr">  register:</span> <span class="string">echo</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="复杂循环"><a href="#复杂循环" class="headerlink" title="复杂循环"></a>复杂循环</h4><p>Complex loops</p><p><br></p><h5 id="遍历嵌套的列表"><a href="#遍历嵌套的列表" class="headerlink" title="遍历嵌套的列表"></a>遍历嵌套的列表</h5><p>Iterating over nested lists</p><p>你可以使用Jinja2的表达式来遍历复杂的列表：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">give</span> <span class="string">users</span> <span class="string">access</span> <span class="string">to</span> <span class="string">multiple</span> <span class="string">databases</span></span><br><span class="line"><span class="attr">  mysql_user:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"<span class="template-variable">&#123;&#123; item[0] &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    priv:</span> <span class="string">"<span class="template-variable">&#123;&#123; item[1] &#125;&#125;</span>.*:ALL"</span></span><br><span class="line"><span class="attr">    append_privs:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">"foo"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; ['alice', 'bob'] |product(['clientdb', 'employeedb', 'providerdb'])|list &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="重试任务直到满足条件"><a href="#重试任务直到满足条件" class="headerlink" title="重试任务直到满足条件"></a>重试任务直到满足条件</h5><p>Retrying a task until a condition is met</p><p>可以使用<code>until</code>关键字来重试任务直到满足特定条件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- shell:</span> <span class="string">/usr/bin/foo</span></span><br><span class="line"><span class="attr">  register:</span> <span class="string">result</span></span><br><span class="line"><span class="attr">  until:</span> <span class="string">result.stdout.find("all</span> <span class="string">systems</span> <span class="string">go")</span> <span class="string">!=</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">  retries:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  delay:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="循环清单"><a href="#循环清单" class="headerlink" title="循环清单"></a>循环清单</h5><p>Looping over inventory</p><p>遍历资产清单：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># show all the hosts in the inventory</span></span><br><span class="line"><span class="attr">- debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; groups['all'] &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># show all the hosts in the current play</span></span><br><span class="line"><span class="attr">- debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; ansible_play_batch &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># show all the hosts in the inventory</span></span><br><span class="line"><span class="attr">- debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; query('inventory_hostnames', 'all') &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># show all the hosts matching the pattern, ie all but the group www</span></span><br><span class="line"><span class="attr">- debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; query('inventory_hostnames', 'all:!www') &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="query与lookup"><a href="#query与lookup" class="headerlink" title="query与lookup"></a>query与lookup</h4><p><code>loop</code>关键字需要一个列表作为输入，但是<code>lookup</code>关键字默认返回逗号分隔的值的字符串。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># same thing</span></span><br><span class="line"><span class="attr">loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; query('inventory_hostnames', 'all') &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; lookup('inventory_hostnames', 'all', wantlist=True) &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><p>Adding controls to loops</p><p><code>loop_control</code>关键字让你可以以有效的方式管理自己的循环。</p><p><br></p><h5 id="限制循环输出"><a href="#限制循环输出" class="headerlink" title="限制循环输出"></a>限制循环输出</h5><p>Limiting loop output with label</p><p>当遍历复杂的数据结构，你的任务的控制台输出可能是巨大的。为了限制显示的输出，在<code>loop_control</code>中使用<code>label</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此任务输出仅显示每项的name字段</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">create</span> <span class="string">servers</span></span><br><span class="line"><span class="attr">  digital_ocean:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.name &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">server1</span></span><br><span class="line"><span class="attr">      disks:</span> <span class="number">3</span><span class="string">gb</span></span><br><span class="line"><span class="attr">      ram:</span> <span class="number">15</span><span class="string">Gb</span></span><br><span class="line"><span class="attr">      network:</span></span><br><span class="line"><span class="attr">        nic01:</span> <span class="number">100</span><span class="string">Gb</span></span><br><span class="line"><span class="attr">        nic02:</span> <span class="number">10</span><span class="string">Gb</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line"><span class="attr">  loop_control:</span></span><br><span class="line"><span class="attr">    label:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.name &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="暂停循环"><a href="#暂停循环" class="headerlink" title="暂停循环"></a>暂停循环</h5><p>Pausing within a loop</p><p>要控制每个项的执行之间的时间(seconds)，在<code>loop_control</code>中使用<code>pause</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.yml</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">create</span> <span class="string">servers,</span> <span class="string">pause</span> <span class="number">3</span><span class="string">s</span> <span class="string">before</span> <span class="string">creating</span> <span class="string">next</span></span><br><span class="line"><span class="attr">  digital_ocean:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">server1</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">server2</span></span><br><span class="line"><span class="attr">  loop_control:</span></span><br><span class="line"><span class="attr">    pause:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="追踪流程"><a href="#追踪流程" class="headerlink" title="追踪流程"></a>追踪流程</h5><p>Tracking progress through a loop with <code>index_var</code></p><p>要追踪你在循环的位置，在<code>loop_control</code>中使用<code>index_var</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">count</span> <span class="string">our</span> <span class="string">fruit</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span> with index <span class="template-variable">&#123;&#123; my_idx &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">apple</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">banana</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">pear</span></span><br><span class="line"><span class="attr">  loop_control:</span></span><br><span class="line"><span class="attr">    index_var:</span> <span class="string">my_idx</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="inner-and-outer-variable-names"><a href="#inner-and-outer-variable-names" class="headerlink" title="inner and outer variable names"></a>inner and outer variable names</h5><p>Defining inner and outer variable names with <code>loop_var</code></p><p>可使用<code>include_tasks</code>嵌套两个循环任务。然而，默认情况下Ansible为每个循环<code>item</code>设置循环变量。This means the inner, nested loop will overwrite the value of item from the outer loop.你可以在<code>loop_control</code>中使用<code>loop_var</code>来为每个循环指定变量名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- include_tasks:</span> <span class="string">inner.yml</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">1</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">2</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  loop_control:</span></span><br><span class="line"><span class="attr">    loop_var:</span> <span class="string">outer_item</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># inner.yml</span></span><br><span class="line"><span class="attr">- debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"outer item=<span class="template-variable">&#123;&#123; outer_item &#125;&#125;</span> inner item=<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">a</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">b</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">c</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="扩展的循环变量"><a href="#扩展的循环变量" class="headerlink" title="扩展的循环变量"></a>扩展的循环变量</h5><p>Extended loop variables</p><p>在循环控制中使用<code>extended</code>选项来获取扩展的循环信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">loop_control:</span></span><br><span class="line"><span class="attr">  extended:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VariableDescription</span><br><span class="line">ansible_loop.allitemsThe list of all items in the loop</span><br><span class="line">ansible_loop.indexThe current iteration of the loop. (1 indexed)</span><br><span class="line">ansible_loop.index0The current iteration of the loop. (0 indexed)</span><br><span class="line">ansible_loop.revindexThe number of iterations from the end of the loop (1 indexed)</span><br><span class="line">ansible_loop.revindex0The number of iterations from the end of the loop (0 indexed)</span><br><span class="line">ansible_loop.firstTrue if first iteration</span><br><span class="line">ansible_loop.lastTrue if last iteration</span><br><span class="line">ansible_loop.lengthThe number of items in the loop</span><br><span class="line">ansible_loop.previtemThe item from the previous iteration of the loop. Undefined during the first iteration.</span><br><span class="line">ansible_loop.nextitemThe item from the following iteration of the loop. Undefined during the last iteration.</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="从with-x迁移到loop"><a href="#从with-x迁移到loop" class="headerlink" title="从with_x迁移到loop"></a>从with_x迁移到loop</h4><p>Migrating from with_X to loop</p><p>从Ansible 2.5开始，执行循环的推荐的方式是使用新的<code>loop</code>关键字来取代<code>with_x</code>格式的循环。</p><p>在许多情况下，<code>loop</code>语法是使用过滤器的更好的表达，而不是更复杂的<code>query</code>或<code>lookup</code>。</p><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_list被loop替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_list</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_list:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">one</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">two</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_list</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">one</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">two</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_items被loop和flatten过滤器替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_items</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_items:</span> <span class="string">"<span class="template-variable">&#123;&#123; items &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_items</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; items|flatten(levels=1) &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_indexed_items被loop, flatten, loop_control.index_var替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_indexed_items</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0 &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_indexed_items:</span> <span class="string">"<span class="template-variable">&#123;&#123; items &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_indexed_items</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; index &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; items|flatten(levels=1) &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop_control:</span></span><br><span class="line"><span class="attr">    index_var:</span> <span class="string">index</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_flattened被loop和flatten替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_flattened</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_flattened:</span> <span class="string">"<span class="template-variable">&#123;&#123; items &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_flattened</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; items|flatten &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_together被loop和zip替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_together</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0 &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_together:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"<span class="template-variable">&#123;&#123; list_one &#125;&#125;</span>"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"<span class="template-variable">&#123;&#123; list_two &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_together</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0 &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; list_one|zip(list_two)|list &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_dict可通过loop和 dictsort或dict2items替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_dict</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.key &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.value &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_dict:</span> <span class="string">"<span class="template-variable">&#123;&#123; dictionary &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_dict</span> <span class="bullet">-&gt;</span> <span class="string">loop</span> <span class="string">(option</span> <span class="number">1</span><span class="string">)</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.key &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.value &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; dictionary|dict2items &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_dict</span> <span class="bullet">-&gt;</span> <span class="string">loop</span> <span class="string">(option</span> <span class="number">2</span><span class="string">)</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0 &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; dictionary|dictsort &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_sequence被loop, range, format替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_sequence</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_sequence:</span> <span class="string">start=0</span> <span class="string">end=4</span> <span class="string">stride=2</span> <span class="string">format=testuser%02x</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_sequence</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; 'testuser%02x' | format(item) &#125;&#125;</span>"</span></span><br><span class="line">  <span class="comment"># range is exclusive of the end point</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; range(0, 4 + 1, 2)|list &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_subelements被loop, subelements替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_subelements</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0.name &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_subelements:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"<span class="template-variable">&#123;&#123; users &#125;&#125;</span>"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">mysql.hosts</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_subelements</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0.name &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; users|subelements('mysql.hosts') &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_nested/with_cartesian被loop, product替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_nested</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0 &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_nested:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"<span class="template-variable">&#123;&#123; list_one &#125;&#125;</span>"</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"<span class="template-variable">&#123;&#123; list_two &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_nested</span> <span class="bullet">-&gt;</span> <span class="string">loop</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item.0 &#125;&#125;</span> - <span class="template-variable">&#123;&#123; item.1 &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">"<span class="template-variable">&#123;&#123; list_one|product(list_two)|list &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with_random_choice被random替代</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_random_choice</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  with_random_choice:</span> <span class="string">"<span class="template-variable">&#123;&#123; my_list &#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">with_random_choice</span> <span class="bullet">-&gt;</span> <span class="string">loop</span> <span class="string">(No</span> <span class="string">loop</span> <span class="string">is</span> <span class="string">needed</span> <span class="string">here)</span></span><br><span class="line"><span class="attr">  debug:</span></span><br><span class="line"><span class="attr">    msg:</span> <span class="string">"<span class="template-variable">&#123;&#123; my_list|random &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">random</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>Blocks: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_blocks.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_blocks.html</a></p><p>块允许任务的逻辑分组，并在play中错误处理。大多数可以适用于单任务的也可适用于块(block)，这使得它很容易设置数据或常见指令到任务。这并不意味着该指令影响块自身，而是有一个块包围的任务继承。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">   - name:</span> <span class="string">Install,</span> <span class="string">configure,</span> <span class="string">and</span> <span class="string">start</span> <span class="string">Apache</span></span><br><span class="line"><span class="attr">     block:</span></span><br><span class="line"><span class="attr">       - name:</span> <span class="string">install</span> <span class="string">httpd</span> <span class="string">and</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">         yum:</span></span><br><span class="line"><span class="attr">           name:</span></span><br><span class="line"><span class="bullet">           -</span> <span class="string">httpd</span></span><br><span class="line"><span class="bullet">           -</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">           state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line"><span class="attr">       - name:</span> <span class="string">apply</span> <span class="string">the</span> <span class="string">foo</span> <span class="string">config</span> <span class="string">template</span></span><br><span class="line"><span class="attr">         template:</span></span><br><span class="line"><span class="attr">           src:</span> <span class="string">templates/src.j2</span></span><br><span class="line"><span class="attr">           dest:</span> <span class="string">/etc/foo.conf</span></span><br><span class="line"><span class="attr">       - name:</span> <span class="string">start</span> <span class="string">service</span> <span class="string">bar</span> <span class="string">and</span> <span class="string">enable</span> <span class="string">it</span></span><br><span class="line"><span class="attr">         service:</span></span><br><span class="line"><span class="attr">           name:</span> <span class="string">bar</span></span><br><span class="line"><span class="attr">           state:</span> <span class="string">started</span></span><br><span class="line"><span class="attr">           enabled:</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">     when:</span> <span class="string">ansible_facts['distribution']</span> <span class="string">==</span> <span class="string">'CentOS'</span></span><br><span class="line"><span class="attr">     become:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">     become_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">     ignore_errors:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>在上面的栗子中，块中3个任务中的每一个附加在when条件后，在任务上下文评估之后都将执行。</p><p>块中的任务名在Ansible 2.3时可用。建议在所有任务中使用名称，无论是块还是其它地方。</p><p><br></p><h4 id="块错误处理"><a href="#块错误处理" class="headerlink" title="块错误处理"></a>块错误处理</h4><p>Blocks error handling</p><p>块同样介绍了类似于大多数编程语言的异常处理的错误处理的方法。块仅处理任务的失败(failed)状态。一个糟糕的任务定义或主机不可达不是rescuable错误。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># block error handling example</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr"> - name:</span> <span class="string">Handle</span> <span class="string">the</span> <span class="string">error</span></span><br><span class="line"><span class="attr">   block:</span></span><br><span class="line"><span class="attr">     - debug:</span></span><br><span class="line"><span class="attr">         msg:</span> <span class="string">'I execute normally'</span></span><br><span class="line"><span class="attr">     - name:</span> <span class="string">i</span> <span class="string">force</span> <span class="string">a</span> <span class="string">failure</span></span><br><span class="line"><span class="attr">       command:</span> <span class="string">/bin/false</span></span><br><span class="line"><span class="attr">     - debug:</span></span><br><span class="line"><span class="attr">         msg:</span> <span class="string">'I never execute, due to the above task failing, :-('</span></span><br><span class="line"><span class="attr">   rescue:</span></span><br><span class="line"><span class="attr">     - debug:</span></span><br><span class="line"><span class="attr">         msg:</span> <span class="string">'I caught an error, can do stuff here to fix it, :-)'</span></span><br></pre></td></tr></table></figure><p><br></p><p><code>always</code>部分，无论什么任务状态都将会运行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Always</span> <span class="string">do</span> <span class="string">X</span></span><br><span class="line"><span class="attr">  block:</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">'I execute normally'</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">i</span> <span class="string">force</span> <span class="string">a</span> <span class="string">failure</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">/bin/false</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">'I never execute :-('</span></span><br><span class="line"><span class="attr">  always:</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">"This always executes, :-)"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="高级的playbook功能"><a href="#高级的playbook功能" class="headerlink" title="高级的playbook功能"></a>高级的playbook功能</h3><p>Advanced Playbooks Features: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_special_topics.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_special_topics.html</a></p><p>下面有许多playbook功能不需要每个人都去学习，但可以为特定应用提供有用的功能。浏览这些话题，因为你可能找有一些有用的技巧。</p><p><br></p><h4 id="特权晋升"><a href="#特权晋升" class="headerlink" title="特权晋升"></a>特权晋升</h4><p><br><br><br></p><h4 id="异步操作和轮询"><a href="#异步操作和轮询" class="headerlink" title="异步操作和轮询"></a>异步操作和轮询</h4><p>Asynchronous Actions and Polling: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_async.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_async.html</a></p><p>默认情况下，playbook块中的任务，直到任务在每个节点上完成后连接才会断开。这可能不总是可取的，或者你需要运行超过ssh timeout的操作。</p><p><br></p><p><strong>限时后台操作(Time-limited background operations)</strong></p><p>你可以在后台运行长时间运行的操作，之后再检查它们的状态。例如，异步地在后台执行<code>long_running_operation</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -B 超时时间， -p 轮询数</span></span><br><span class="line">ansible all -B 3600 -P 0 -a <span class="string">"/usr/bin/long_running_operation --do-stuff"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># async_status模块 检查状态</span></span><br><span class="line">ansible web1.example.com -m async_status -a <span class="string">"jid=488359678239.2844"</span></span><br></pre></td></tr></table></figure><p>轮询模式是智能的，所以在轮询将在任意机器上开始之前所有的工作都将启动。如果想要所有工作快速开始，请确保使用足够高的<code>--forks</code>。在超时之后，远程节点上的进程将会被终止。</p><p>通常，你只需在后台长时间运行shell命令或软件更新。后台复制模块不会进行文件传输。</p><p>为了避免阻塞或超时问题，你可以使用异步模式来一次运行你的所有任务，并轮询直到它们完成。</p><p>异步模式的行为依赖于poll值。</p><p><br></p><p><strong>Avoid connection timeouts: poll &gt; 0</strong></p><p>当poll是正值，playbook仍然会阻塞任务直到它完成、失败或超时。</p><p>要异步启动任务，请指定其最大运行实践和要轮询状态的频率。如果未指定poll，则默认由<code>DEFAULT_POLL_INTERVAL</code>设置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">simulate</span> <span class="string">long</span> <span class="string">running</span> <span class="string">op</span> <span class="string">(15</span> <span class="string">sec),</span> <span class="string">wait</span> <span class="string">for</span> <span class="string">up</span> <span class="string">to</span> <span class="number">45</span> <span class="string">sec,</span> <span class="string">poll</span> <span class="string">every</span> <span class="number">5</span> <span class="string">sec</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">/bin/sleep</span> <span class="number">15</span></span><br><span class="line"><span class="attr">    async:</span> <span class="number">45</span></span><br><span class="line"><span class="attr">    poll:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>Concurrent tasks: poll=0</strong></p><p>当poll为0时，Ansible将启动任务，并立即移动到下一个而不必等待结果。</p><p>从序列试图这点是异步编程：任务现在可以同时运行。playbook将结束而不检查异步返回。异步任务将执行根据async的值，直到它们完成、失败或超时。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">simulate</span> <span class="string">long</span> <span class="string">running</span> <span class="string">op,</span> <span class="string">allow</span> <span class="string">to</span> <span class="string">run</span> <span class="string">for</span> <span class="number">45</span> <span class="string">sec,</span> <span class="string">fire</span> <span class="string">and</span> <span class="string">forget</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">/bin/sleep</span> <span class="number">15</span></span><br><span class="line"><span class="attr">    async:</span> <span class="number">45</span></span><br><span class="line"><span class="attr">    poll:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="检查模式"><a href="#检查模式" class="headerlink" title="检查模式"></a>检查模式</h4><p>Check Mode: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_checkmode.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_checkmode.html</a></p><p><br><br><br></p><h4 id="Debugger"><a href="#Debugger" class="headerlink" title="Debugger"></a>Debugger</h4><p>Playbook Debugger</p><p>Ansible包含了debugger作为策略插件的一部分。此调试器允许你调试任务。你可以在任务的上下文中访问所有的调试器的功能，以帮助解决失败的问题。</p><p>有多种方式来调用调试器。</p><p><br></p><p><strong>使用debugger关键字(Using the debugger keyword)</strong></p><p>可在提供<code>name</code>属性的块中使用<code>debugger</code>关键字，如paly, role, block, task。<code>debugger</code>关键字接受下列值：</p><ul><li>always: 总是调用调试器</li><li>never: 绝不调用调试器</li><li>on_failed: 任务失败才调用调试器</li><li>on_skipped: 任务跳过才调用调试器</li></ul><p><br></p><p>全局配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># on a task</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">execute</span> <span class="string">a</span> <span class="string">command</span></span><br><span class="line"><span class="attr">  command:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  debugger:</span> <span class="string">on_failed</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># on a play</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">play</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  debugger:</span> <span class="string">on_skipped</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Execute</span> <span class="string">a</span> <span class="string">command</span></span><br><span class="line"><span class="attr">      command:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      when:</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>在特定层级上：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Play</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  debugger:</span> <span class="string">never</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Execute</span> <span class="string">a</span> <span class="string">command</span></span><br><span class="line"><span class="attr">      command:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">      debugger:</span> <span class="string">on_failed</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>配置或环境变量(Configuration or environment variable)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ansible.cfg</span><br><span class="line">[defaults]</span><br><span class="line">enable_task_debugger = True</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># environment variable</span><br><span class="line">ANSIBLE_ENABLE_TASK_DEBUGGER=True ansible-playbook -i hosts site.yml</span><br></pre></td></tr></table></figure><p><br></p><p><strong>策略(As a Strategy)</strong></p><p>要使用debug策略，改变strategy属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  strategy:</span> <span class="string">debug</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ansible.cfg</span><br><span class="line">[defaults]</span><br><span class="line">strategy = debug</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># environment variable</span><br><span class="line">ANSIBLE_STRATEGY=debug</span><br></pre></td></tr></table></figure><p><br></p><p><strong>可用命令(Available Commands)</strong></p><p>打印值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[192.0.2.10] TASK: install package (debug)&gt; p task</span><br><span class="line">TASK: install package</span><br><span class="line">[192.0.2.10] TASK: install package (debug)&gt; p task.args</span><br><span class="line">&#123;u&apos;name&apos;: u&apos;&#123;&#123; pkg_name &#125;&#125;&apos;&#125;</span><br><span class="line">[192.0.2.10] TASK: install package (debug)&gt; p task_vars</span><br><span class="line">&#123;u&apos;ansible_all_ipv4_addresses&apos;: [u&apos;192.0.2.10&apos;],</span><br><span class="line"> u&apos;ansible_architecture&apos;: u&apos;x86_64&apos;,</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">[192.0.2.10] TASK: install package (debug)&gt; p task_vars[&apos;pkg_name&apos;]</span><br><span class="line">u&apos;bash&apos;</span><br><span class="line">[192.0.2.10] TASK: install package (debug)&gt; p host</span><br><span class="line">192.0.2.10</span><br><span class="line">[192.0.2.10] TASK: install package (debug)&gt; p result._result</span><br><span class="line">&#123;&apos;_ansible_no_log&apos;: False,</span><br><span class="line"> &apos;changed&apos;: False,</span><br><span class="line"> u&apos;failed&apos;: True,</span><br><span class="line"> ...</span><br><span class="line"> u&apos;msg&apos;: u&quot;No package matching &apos;not_exist&apos; is available&quot;&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="滚动升级"><a href="#滚动升级" class="headerlink" title="滚动升级"></a>滚动升级</h4><p>Delegation, Rolling Updates, and Local Actions: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html</a></p><p><br><br><br></p><h4 id="设置环境"><a href="#设置环境" class="headerlink" title="设置环境"></a>设置环境</h4><p>Setting the Environment: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_environment.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_environment.html</a></p><p><code>environment</code>关键字可以允许你为远程目标主机设置环境变量。例如，需要为http请求设置一个代理。获取其它工具需要的环境变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Install</span> <span class="string">cobbler</span></span><br><span class="line"><span class="attr">      package:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">cobbler</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">      environment:</span></span><br><span class="line"><span class="attr">        http_proxy:</span> <span class="attr">http://proxy.example.com:8080</span></span><br></pre></td></tr></table></figure><p>也可以存储在一个变量里：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="comment"># here we make a variable named "proxy_env" that is a dictionary</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    proxy_env:</span></span><br><span class="line"><span class="attr">      http_proxy:</span> <span class="attr">http://proxy.example.com:8080</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Install</span> <span class="string">cobbler</span></span><br><span class="line"><span class="attr">      package:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">cobbler</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">      environment:</span> <span class="string">"<span class="template-variable">&#123;&#123; proxy_env &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="特定语言版本管理器"><a href="#特定语言版本管理器" class="headerlink" title="特定语言版本管理器"></a>特定语言版本管理器</h4><p>Working With Language-Specific Version Managers</p><p>一些特定语言版本管理器(如nvm)要求，而这些工具在使用中都要求环境变量。挡手动使用这些工具，通常需要在配置文件中添加一些环境变量，在Ansible中，你可使用enviroment代替：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">### A playbook demonstrating a common npm workflow:</span><br><span class="line"># - Check for package.json in the application directory</span><br><span class="line"># - If package.json exists:</span><br><span class="line">#   * Run npm prune</span><br><span class="line">#   * Run npm install</span><br><span class="line"></span><br><span class="line">- hosts: application</span><br><span class="line">  become: false</span><br><span class="line"></span><br><span class="line">  vars:</span><br><span class="line">    node_app_dir: /var/local/my_node_app</span><br><span class="line"></span><br><span class="line">  environment:</span><br><span class="line">    NVM_DIR: /var/local/nvm</span><br><span class="line">    PATH: /var/local/nvm/versions/node/v4.2.1/bin:&#123;&#123; ansible_env.PATH &#125;&#125;</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">  - name: check for package.json</span><br><span class="line">    stat:</span><br><span class="line">      path: &apos;&#123;&#123; node_app_dir &#125;&#125;/package.json&apos;</span><br><span class="line">    register: packagejson</span><br><span class="line"></span><br><span class="line">  - name: npm prune</span><br><span class="line">    command: npm prune</span><br><span class="line">    args:</span><br><span class="line">      chdir: &apos;&#123;&#123; node_app_dir &#125;&#125;&apos;</span><br><span class="line">    when: packagejson.stat.exists</span><br><span class="line"></span><br><span class="line">  - name: npm install</span><br><span class="line">    npm:</span><br><span class="line">      path: &apos;&#123;&#123; node_app_dir &#125;&#125;&apos;</span><br><span class="line">    when: packagejson.stat.exists</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>Error Handling In Playbooks: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_error_handling.html</a></p><p>Ansible通常有默认值来确保检查命令和模块的返回码和是否失败，进行错误处理，除非你做了决定。</p><p><br></p><p><strong>忽略错误命令(Ignoring Failed Commands)</strong></p><p>一般来说，如果主机上有任务失败，playbook将停止执行。有时，你想让它继续进行：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">this</span> <span class="string">will</span> <span class="string">not</span> <span class="string">be</span> <span class="string">counted</span> <span class="string">as</span> <span class="string">a</span> <span class="string">failure</span></span><br><span class="line"><span class="attr">  command:</span> <span class="string">/bin/false</span></span><br><span class="line"><span class="attr">  ignore_errors:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>重置不可达的主机(Resetting Unreachable Hosts)</strong></p><p>连接失败将设置主机为不可达(UNREACHABLE)，它将从运行活跃主机列表中删除。可以使用<code>meta: clear_host_errors</code>来设置。</p><p><br></p><p><strong>处理程序和失败(Handlers and Failure)</strong></p><p>当主机上的一个任务失败时，先前通知(notify)的处理程序(handler)将不会在此主机上运行。例如，任务更新配置文件并通知处理程序去重启服务。如果任务以后的同一个play失败，则服务不会重启尽管配置已经更改。</p><p>可以使用<code>--force-handlers</code>命令行选项来改变此行为。或在play中包含<code>force_handlers: True</code>，或在ansible配置中包含<code>force_handlers = True</code>。当处理程序被强制执行，无论任务成功与否它们都会执行。</p><p><br></p><p><strong>控制如何定义失败(Controlling What Defines Failure)</strong></p><p>Ansible允许你使用<code>filed_when</code>条件来定义失败。栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Fail</span> <span class="string">task</span> <span class="string">when</span> <span class="string">the</span> <span class="string">command</span> <span class="string">error</span> <span class="string">output</span> <span class="string">prints</span> <span class="string">FAILED</span></span><br><span class="line"><span class="attr">  command:</span> <span class="string">/usr/bin/example-command</span> <span class="bullet">-x</span> <span class="bullet">-y</span> <span class="bullet">-z</span></span><br><span class="line"><span class="attr">  register:</span> <span class="string">command_result</span></span><br><span class="line"><span class="attr">  failed_when:</span> <span class="string">"'FAILED' in command_result.stderr"</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>覆盖改变的结果(Overriding The Changed Result)</strong></p><p>当一个模块运行，它通常会基于机器状态是否被影响而报告<code>changed</code>状态。</p><p>有时候你知道，基于返回码或返回结果，它并没有发生改变，并希望去覆盖<code>changed</code>结果，使它不出现在报告输出里：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- command:</span> <span class="string">/bin/fake_command</span></span><br><span class="line"><span class="attr">  register:</span> <span class="string">result</span></span><br><span class="line"><span class="attr">  ignore_errors:</span> <span class="literal">True</span></span><br><span class="line"><span class="attr">  changed_when:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'"ERROR" in result.stderr'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">result.rc</span> <span class="string">==</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>终止play(Aborting the play)</strong></p><p>有时需要终止失败的play，而不是为某主机跳过剩余任务。</p><p><code>any_errors_fatal</code>选项将终止Play，并防止任何后续的plays运行。当遇到一个错误，当前批次的所有主机都有机会完成致命的任务，然后play的执行停止。<code>any_errors_fatal</code>可在play或block层级设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">somehosts</span></span><br><span class="line"><span class="attr">  any_errors_fatal:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">myrole</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">somehosts</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - block:</span></span><br><span class="line"><span class="attr">        - include_tasks:</span> <span class="string">mytasks.yml</span></span><br><span class="line"><span class="attr">      any_errors_fatal:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>使用块(blocks)</strong></p><p>大多数可应用到单个任务的也可应用到块，这使得它更容易设置数据或指定到任务。块只处理任务的失败(failed)状态。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Handle</span> <span class="string">the</span> <span class="string">error</span></span><br><span class="line"><span class="attr">  block:</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">'I execute normally'</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">i</span> <span class="string">force</span> <span class="string">a</span> <span class="string">failure</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">/bin/false</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">'I never execute, due to the above task failing, :-('</span></span><br><span class="line"><span class="attr">  rescue:</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">'I caught an error, can do stuff here to fix it, :-)'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h4><p>Advanced Syntax: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_advanced_syntax.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_advanced_syntax.html</a></p><p>高级的YANL语法可以给你在Ansible的YAML文件中更多控制数据的地方。你可以在<a href="https://pyyaml.org/wiki/PyYAMLDocumentation#YAMLtagsandPythontypes" target="_blank" rel="noopener">PyYAML文档</a>中找到等多Python特定化的YAML信息。</p><p><br></p><p><strong>不安全和原生字符串</strong><br>Unsafe or Raw Strings</p><p>Ansible提供了一个内部的数据类型，用来声明变量不安全(unsafe)。这意味着变量中保存的数据应为不安全，防止字符串被替换和披露。</p><p>Jinja2包含了转义，或告诉Jinja2不渲染数据，如<code>...</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用 !unsafe 标签</span><br><span class="line">my_unsafe_variable: !unsafe &apos;this variable has &#123;&#123; characters that should not be treated as a jinja2 template&apos;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">vars:</span></span><br><span class="line"><span class="attr">    my_unsafe_variable:</span> <span class="string">!unsafe</span> <span class="string">'unsafe value'</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>锚和别名</strong><br>YAML anchors and aliases: sharing variable values</p><p>YAML的锚(anchor)和别名(aliase)可以帮助你在灵活的方式中定义、维护和使用共享变量。使用<code>&amp;</code>定义一个锚，使用别名(<code>*</code>)指向它。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 锚内设置了3个变量，别名使用其它2个，并覆盖第3个</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">vars:</span></span><br><span class="line"><span class="attr">    app1:</span></span><br><span class="line"><span class="attr">        jvm:</span> <span class="meta">&amp;jvm_opts</span></span><br><span class="line"><span class="attr">            opts:</span> <span class="string">'-Xms1G -Xmx2G'</span></span><br><span class="line"><span class="attr">            port:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/usr/lib/app1</span></span><br><span class="line"><span class="attr">    app2:</span></span><br><span class="line"><span class="attr">        jvm:</span></span><br><span class="line">            <span class="string">&lt;&lt;:</span> <span class="meta">*jvm_opts</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/usr/lib/app2</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>path的值由合并操作符(<code>&lt;&lt;</code>)所合并。</p><p><br><br><br></p><h4 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h4><p>Working With Plugins: <a href="https://docs.ansible.com/ansible/latest/plugins/plugins.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/plugins/plugins.html</a></p><p>插件时扩展Ansible的核心功能。Ansible使用插件架构来实现丰富的、灵活的、可扩展的功能集。</p><p>Ansible ships附带了许多插件，你也可以自己编写。</p><ul><li>Action Plugins</li><li>Become Plugins</li><li>Cache Plugins</li><li>Callback Plugins</li><li>Cliconf Plugins</li><li>Connection Plugins</li><li>Httpapi Plugins</li><li>Inventory Plugins</li><li>Lookup Plugins</li><li>Netconf Plugins</li><li>Shell Plugins</li><li>Strategy Plugins</li><li>Vars Plugins</li><li>Filters</li><li>Tests</li><li>Plugin Filter Configuration</li></ul><p><br><br><br></p><h4 id="提示和输入"><a href="#提示和输入" class="headerlink" title="提示和输入"></a>提示和输入</h4><p>Prompts: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_prompts.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_prompts.html</a></p><p>当运行playbook时，你可能希望提示某些用户输入信息，可使用<code>vars_prompt</code>来完成。一个常见的用途可能是要求输入敏感的数据，但不希望记录。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  vars_prompt:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">username</span></span><br><span class="line"><span class="attr">      prompt:</span> <span class="string">"What is your username?"</span></span><br><span class="line"><span class="attr">      private:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">password</span></span><br><span class="line"><span class="attr">      prompt:</span> <span class="string">"What is your password?"</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        msg:</span> <span class="string">'Logging in as <span class="template-variable">&#123;&#123; username &#125;&#125;</span>'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>Tags: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html</a></p><p>如果你有一个大型的playbook，它可能成为一个有用的能够运行playbook的一个特定部分，而不是playbook中的所有。Ansible支持使用标签(tags)来完成。</p><p>标签可应用于Ansible的许多结构，但最简单的方法是单个任务。</p><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">- yum:</span></span><br><span class="line"><span class="attr">    name:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">httpd</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">packages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- template:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">templates/src.j2</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">/etc/foo.conf</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">configuration</span></span><br></pre></td></tr></table></figure><p>当你执行playbook，你可以用两种方法基于标签过滤任务：</p><ul><li>在命令行使用<code>--tags</code>或<code>--skip-tags</code>选项；</li><li>在Ansible配置中，使用<code>TAGS_RUN</code>或<code>TAGS_SKIP</code>选项。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 仅执行某个标签</span><br><span class="line">ansible-playbook example.yml --tags &quot;configuration,packages&quot;</span><br><span class="line"></span><br><span class="line"># 跳过某个标签</span><br><span class="line">ansible-playbook example.yml --skip-tags &quot;packages&quot;</span><br><span class="line"></span><br><span class="line"># 产看标签执行情况</span><br><span class="line">ansible-playbook example.yml --tags &quot;configuration,packages&quot; --list-tasks</span><br></pre></td></tr></table></figure><p><br></p><p><strong>标签重用</strong><br>Tag Reuse</p><p><br><br><br></p><h3 id="控制playbook执行"><a href="#控制playbook执行" class="headerlink" title="控制playbook执行"></a>控制playbook执行</h3><p>Controlling playbook execution: strategies and more: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_strategies.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_strategies.html</a></p><p>默认情况下，Ansible在使用5forks任意主机上开始下一个任务之前在所有被play影响的主机上运行每个任务。如果你想要改变此默认的行为，你可以使用不同的策略插件，改变fork数，或应用几个play级别的关键字（如<code>serial</code>）。</p><p><br></p><h4 id="选择策略"><a href="#选择策略" class="headerlink" title="选择策略"></a>选择策略</h4><p>Selecting a strategy</p><ul><li>linear strategy: <a href="https://docs.ansible.com/ansible/latest/plugins/strategy/linear.html#linear-strategy" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/plugins/strategy/linear.html#linear-strategy</a></li><li>debug strategy: <a href="https://docs.ansible.com/ansible/latest/plugins/strategy/debug.html#debug-strategy" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/plugins/strategy/debug.html#debug-strategy</a></li><li>free strategy: <a href="https://docs.ansible.com/ansible/latest/plugins/strategy/free.html#free-strategy" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/plugins/strategy/free.html#free-strategy</a></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  strategy:</span> <span class="string">free</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="设置fork数"><a href="#设置fork数" class="headerlink" title="设置fork数"></a>设置fork数</h4><p>Setting the number of forks</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ansible.cfg</span><br><span class="line">[defaults]</span><br><span class="line">forks = 30</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># or cli</span><br><span class="line">ansible-playbook -f 30 my_playbook.ym</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用关键字控制执行"><a href="#使用关键字控制执行" class="headerlink" title="使用关键字控制执行"></a>使用关键字控制执行</h4><p>Using keywords to control execution</p><p><a href="https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#playbook-keywords" target="_blank" rel="noopener">play level</a>的关键字会影响paly的执行。</p><p>最常见的是<code>serial</code>，还有<code>throttle</code>, <code>ignore_errors</code>, <code>ignore_unreachable</code>, <code>any_errors_fatal</code>。</p><p><br><br><br></p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>Best Practices: <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html</a></p><p>使用Ansible和playbooks的一些技巧。</p><p>你可以在<a href="https://github.com/ansible/ansible-examples" target="_blank" rel="noopener">ansible-examples</a>仓库中找到最佳用法。</p><p><br></p><h4 id="内容组织"><a href="#内容组织" class="headerlink" title="内容组织"></a>内容组织</h4><p>Content Organization</p><p>下面将介绍组织Playbook内容的多种方式。你的ansible的使用应该适合你的需求，因此你可以按需组合各种方法。</p><p>组织ansible playbook内容的一个关键方式是role。你应该理解它。</p><p><br></p><h5 id="目录布局"><a href="#目录布局" class="headerlink" title="目录布局"></a>目录布局</h5><p>Directory Layout</p><p>栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">staging</span>                   <span class="comment"># inventory file for staging environment</span></span><br><span class="line"></span><br><span class="line"><span class="string">group_vars/</span></span><br><span class="line">   <span class="string">group1.yml</span>             <span class="comment"># here we assign variables to particular groups</span></span><br><span class="line">   <span class="string">group2.yml</span></span><br><span class="line"><span class="string">host_vars/</span></span><br><span class="line">   <span class="string">hostname1.yml</span>          <span class="comment"># here we assign variables to particular systems</span></span><br><span class="line">   <span class="string">hostname2.yml</span></span><br><span class="line"></span><br><span class="line"><span class="string">library/</span>                  <span class="comment"># if any custom modules, put them here (optional)</span></span><br><span class="line"><span class="string">module_utils/</span>             <span class="comment"># if any custom module_utils to support modules, put them here (optional)</span></span><br><span class="line"><span class="string">filter_plugins/</span>           <span class="comment"># if any custom filter plugins, put them here (optional)</span></span><br><span class="line"></span><br><span class="line"><span class="string">site.yml</span>                  <span class="comment"># master playbook</span></span><br><span class="line"><span class="string">webservers.yml</span>            <span class="comment"># playbook for webserver tier</span></span><br><span class="line"><span class="string">dbservers.yml</span>             <span class="comment"># playbook for dbserver tier</span></span><br><span class="line"></span><br><span class="line"><span class="string">roles/</span></span><br><span class="line">    <span class="string">common/</span>               <span class="comment"># this hierarchy represents a "role"</span></span><br><span class="line">        <span class="string">tasks/</span>            <span class="comment">#</span></span><br><span class="line">            <span class="string">main.yml</span>      <span class="comment">#  &lt;-- tasks file can include smaller files if warranted</span></span><br><span class="line">        <span class="string">handlers/</span>         <span class="comment">#</span></span><br><span class="line">            <span class="string">main.yml</span>      <span class="comment">#  &lt;-- handlers file</span></span><br><span class="line">        <span class="string">templates/</span>        <span class="comment">#  &lt;-- files for use with the template resource</span></span><br><span class="line">            <span class="string">ntp.conf.j2</span>   <span class="comment">#  &lt;------- templates end in .j2</span></span><br><span class="line">        <span class="string">files/</span>            <span class="comment">#</span></span><br><span class="line">            <span class="string">bar.txt</span>       <span class="comment">#  &lt;-- files for use with the copy resource</span></span><br><span class="line">            <span class="string">foo.sh</span>        <span class="comment">#  &lt;-- script files for use with the script resource</span></span><br><span class="line">        <span class="string">vars/</span>             <span class="comment">#</span></span><br><span class="line">            <span class="string">main.yml</span>      <span class="comment">#  &lt;-- variables associated with this role</span></span><br><span class="line">        <span class="string">defaults/</span>         <span class="comment">#</span></span><br><span class="line">            <span class="string">main.yml</span>      <span class="comment">#  &lt;-- default lower priority variables for this role</span></span><br><span class="line">        <span class="string">meta/</span>             <span class="comment">#</span></span><br><span class="line">            <span class="string">main.yml</span>      <span class="comment">#  &lt;-- role dependencies</span></span><br><span class="line">        <span class="string">library/</span>          <span class="comment"># roles can also include custom modules</span></span><br><span class="line">        <span class="string">module_utils/</span>     <span class="comment"># roles can also include custom module_utils</span></span><br><span class="line">        <span class="string">lookup_plugins/</span>   <span class="comment"># or other types of plugins, like lookup in this case</span></span><br><span class="line"></span><br><span class="line">    <span class="string">webtier/</span>              <span class="comment"># same kind of structure as "common" was above, done for the webtier role</span></span><br><span class="line">    <span class="string">monitoring/</span>           <span class="comment"># ""</span></span><br><span class="line">    <span class="string">fooapp/</span>               <span class="comment"># ""</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="可选的目录布局"><a href="#可选的目录布局" class="headerlink" title="可选的目录布局"></a>可选的目录布局</h5><p>Alternative Directory Layout</p><p>此布局为大型环境提供了更多灵活性，栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">inventories/</span></span><br><span class="line">   <span class="string">production/</span></span><br><span class="line">      <span class="string">hosts</span>               <span class="comment"># inventory file for production servers</span></span><br><span class="line">      <span class="string">group_vars/</span></span><br><span class="line">         <span class="string">group1.yml</span>       <span class="comment"># here we assign variables to particular groups</span></span><br><span class="line">         <span class="string">group2.yml</span></span><br><span class="line">      <span class="string">host_vars/</span></span><br><span class="line">         <span class="string">hostname1.yml</span>    <span class="comment"># here we assign variables to particular systems</span></span><br><span class="line">         <span class="string">hostname2.yml</span></span><br><span class="line"></span><br><span class="line">   <span class="string">staging/</span></span><br><span class="line">      <span class="string">hosts</span>               <span class="comment"># inventory file for staging environment</span></span><br><span class="line">      <span class="string">group_vars/</span></span><br><span class="line">         <span class="string">group1.yml</span>       <span class="comment"># here we assign variables to particular groups</span></span><br><span class="line">         <span class="string">group2.yml</span></span><br><span class="line">      <span class="string">host_vars/</span></span><br><span class="line">         <span class="string">stagehost1.yml</span>   <span class="comment"># here we assign variables to particular systems</span></span><br><span class="line">         <span class="string">stagehost2.yml</span></span><br><span class="line"></span><br><span class="line"><span class="string">library/</span></span><br><span class="line"><span class="string">module_utils/</span></span><br><span class="line"><span class="string">filter_plugins/</span></span><br><span class="line"></span><br><span class="line"><span class="string">site.yml</span></span><br><span class="line"><span class="string">webservers.yml</span></span><br><span class="line"><span class="string">dbservers.yml</span></span><br><span class="line"></span><br><span class="line"><span class="string">roles/</span></span><br><span class="line">    <span class="string">common/</span></span><br><span class="line">    <span class="string">webtier/</span></span><br><span class="line">    <span class="string">monitoring/</span></span><br><span class="line">    <span class="string">fooapp/</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="使用云动态资产"><a href="#使用云动态资产" class="headerlink" title="使用云动态资产"></a>使用云动态资产</h5><p>Use Dynamic Inventory With Clouds</p><p>如果你使用云服务提供商，你不应该在静态文件中管理你的资产。请参考<a href="https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html#intro-dynamic-inventory" target="_blank" rel="noopener">Working with dynamic inventory</a></p><p><br></p><h5 id="如何区分测试与生产"><a href="#如何区分测试与生产" class="headerlink" title="如何区分测试与生产"></a>如何区分测试与生产</h5><p>How to Differentiate Staging vs Production</p><p>如果管理静态清单，经常会问到如何区分不同类型的环境。下面的例子提供了一个好方法。分组的类似方法可以适用动态清单。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file: production</span></span><br><span class="line"></span><br><span class="line"><span class="section">[atlanta_webservers]</span></span><br><span class="line">www-atl-1.example.com</span><br><span class="line">www-atl-2.example.com</span><br><span class="line"></span><br><span class="line"><span class="section">[boston_webservers]</span></span><br><span class="line">www-bos-1.example.com</span><br><span class="line">www-bos-2.example.com</span><br><span class="line"></span><br><span class="line"><span class="section">[atlanta_dbservers]</span></span><br><span class="line">db-atl-1.example.com</span><br><span class="line">db-atl-2.example.com</span><br><span class="line"></span><br><span class="line"><span class="section">[boston_dbservers]</span></span><br><span class="line">db-bos-1.example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># webservers in all geos</span></span><br><span class="line"><span class="section">[webservers:children]</span></span><br><span class="line">atlanta_webservers</span><br><span class="line">boston_webservers</span><br><span class="line"></span><br><span class="line"><span class="comment"># dbservers in all geos</span></span><br><span class="line"><span class="section">[dbservers:children]</span></span><br><span class="line">atlanta_dbservers</span><br><span class="line">boston_dbservers</span><br><span class="line"></span><br><span class="line"><span class="comment"># everything in the atlanta geo</span></span><br><span class="line"><span class="section">[atlanta:children]</span></span><br><span class="line">atlanta_webservers</span><br><span class="line">atlanta_dbservers</span><br><span class="line"></span><br><span class="line"><span class="comment"># everything in the boston geo</span></span><br><span class="line"><span class="section">[boston:children]</span></span><br><span class="line">boston_webservers</span><br><span class="line">boston_dbservers</span><br></pre></td></tr></table></figure><p><br></p><h5 id="组和主机变量"><a href="#组和主机变量" class="headerlink" title="组和主机变量"></a>组和主机变量</h5><p>Group And Host Variables</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># file: group_vars/atlanta</span></span><br><span class="line"><span class="attr">ntp:</span> <span class="string">ntp-atlanta.example.com</span></span><br><span class="line"><span class="attr">backup:</span> <span class="string">backup-atlanta.example.com</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># file: group_vars/webservers</span></span><br><span class="line"><span class="attr">apacheMaxRequestsPerChild:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">apacheMaxClients:</span> <span class="number">900</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># file: group_vars/all</span></span><br><span class="line"><span class="attr">ntp:</span> <span class="string">ntp-boston.example.com</span></span><br><span class="line"><span class="attr">backup:</span> <span class="string">backup-boston.example.com</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="顶级playbook通过角色分离"><a href="#顶级playbook通过角色分离" class="headerlink" title="顶级playbook通过角色分离"></a>顶级playbook通过角色分离</h5><p>Top Level Playbooks Are Separated By Role</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># file: site.yml</span></span><br><span class="line"><span class="attr">- import_playbook:</span> <span class="string">webservers.yml</span></span><br><span class="line"><span class="attr">- import_playbook:</span> <span class="string">dbservers.yml</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># file: webservers.yml</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">webservers</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">common</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">webtier</span></span><br></pre></td></tr></table></figure><p>这里，我们可以选择运行<code>site.yml</code>来配置我们的整个基础架构，或者通过运行<code>webservers.yml</code>来只运行一个子集。类似于下面：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ansible-playbook</span> <span class="string">site.yml</span> <span class="bullet">--limit</span> <span class="string">webservers</span></span><br><span class="line"><span class="string">ansible-playbook</span> <span class="string">webservers.yml</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="角色的任务和处理程序组织"><a href="#角色的任务和处理程序组织" class="headerlink" title="角色的任务和处理程序组织"></a>角色的任务和处理程序组织</h5><p>Task And Handler Organization For A Role</p><p>下面解释一个NTP任务是如何工作：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file: roles/common/tasks/main.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">be</span> <span class="string">sure</span> <span class="string">ntp</span> <span class="string">is</span> <span class="string">installed</span></span><br><span class="line"><span class="attr">  yum:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">ntp</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">ntp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">be</span> <span class="string">sure</span> <span class="string">ntp</span> <span class="string">is</span> <span class="string">configured</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">ntp.conf.j2</span></span><br><span class="line"><span class="attr">    dest:</span> <span class="string">/etc/ntp.conf</span></span><br><span class="line"><span class="attr">  notify:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">restart</span> <span class="string">ntpd</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">ntp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">be</span> <span class="string">sure</span> <span class="string">ntpd</span> <span class="string">is</span> <span class="string">running</span> <span class="string">and</span> <span class="string">enabled</span></span><br><span class="line"><span class="attr">  service:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">ntpd</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">started</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">ntp</span></span><br></pre></td></tr></table></figure><p>这是一个处理程序(handler)文件栗子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># file: roles/common/handlers/main.yml</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">restart</span> <span class="string">ntpd</span></span><br><span class="line"><span class="attr">  service:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">ntpd</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><p><br></p><h5 id="什么组织启用"><a href="#什么组织启用" class="headerlink" title="什么组织启用"></a>什么组织启用</h5><p>What This Organization Enables</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 重新配置基础服务</span><br><span class="line">ansible-playbook -i production site.yml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 重新配置NTP</span><br><span class="line">ansible-playbook -i production site.yml --tags ntp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 重新配置webservers</span><br><span class="line">ansible-playbook -i production webservers.yml</span><br><span class="line"># boston</span><br><span class="line">ansible-playbook -i production webservers.yml --limit boston</span><br><span class="line"># boston first 10</span><br><span class="line">ansible-playbook -i production webservers.yml --limit boston[0:9]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ad-hoc</span><br><span class="line">ansible boston -i production -m command -a &apos;/sbin/reboot&apos;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="部署于配置组织"><a href="#部署于配置组织" class="headerlink" title="部署于配置组织"></a>部署于配置组织</h5><p>Deployment vs Configuration Organization</p><p>上面的配置模型是一个典型的配置拓扑。当进行多级部署中，会有一些额外的playbook（hop between tiers to roll out an application）。</p><p><br><br><br></p><h4 id="测试与生产"><a href="#测试与生产" class="headerlink" title="测试与生产"></a>测试与生产</h4><p>Staging vs Production</p><p>如上所述，让staging(testing)和production环境分离是为不同的环境使用单独的清单文件。你的环境不一定是相同的大小，你可以使用变量来控制它们。</p><p><br><br><br></p><h4 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h4><p>Rolling Updates</p><p>理解<code>serial</code>关键字。</p><p><br><br><br></p><h4 id="注意状态"><a href="#注意状态" class="headerlink" title="注意状态"></a>注意状态</h4><p>Always Mention The State</p><p><code>state</code>参数对许多模块是可选的。如<code>state=present</code>或<code>state=absent</code>。</p><p><br><br><br></p><h4 id="通过角色分组"><a href="#通过角色分组" class="headerlink" title="通过角色分组"></a>通过角色分组</h4><p>Group By Roles</p><p>一个系统可以在多个组。这使得playbook基于角色来选择目标主机。以及使用该组变量系统来分配角色特定的变量。</p><p><br><br><br></p><h4 id="操作系统和发行版本"><a href="#操作系统和发行版本" class="headerlink" title="操作系统和发行版本"></a>操作系统和发行版本</h4><p>Operating System and Distribution Variance</p><p>当在两个不同的操作系统之间处理一个参数时，处理它的一个好方法是使用<code>group_by</code>模块。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr"> - name:</span> <span class="string">talk</span> <span class="string">to</span> <span class="string">all</span> <span class="string">hosts</span> <span class="string">just</span> <span class="string">so</span> <span class="string">we</span> <span class="string">can</span> <span class="string">learn</span> <span class="string">about</span> <span class="string">them</span></span><br><span class="line"><span class="attr">   hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">   tasks:</span></span><br><span class="line"><span class="attr">     - name:</span> <span class="string">Classify</span> <span class="string">hosts</span> <span class="string">depending</span> <span class="string">on</span> <span class="string">their</span> <span class="string">OS</span> <span class="string">distribution</span></span><br><span class="line"><span class="attr">       group_by:</span></span><br><span class="line"><span class="attr">         key:</span> <span class="string">os_&#123;&#123;</span> <span class="string">ansible_facts['distribution']</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># now just on the CentOS hosts...</span></span><br><span class="line"></span><br><span class="line"><span class="attr"> - hosts:</span> <span class="string">os_CentOS</span></span><br><span class="line"><span class="attr">   gather_facts:</span> <span class="literal">False</span></span><br><span class="line"><span class="attr">   tasks:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="comment"># tasks that only happen on CentOS go here</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Set</span> <span class="string">OS</span> <span class="string">distribution</span> <span class="string">dependent</span> <span class="string">variables</span></span><br><span class="line"><span class="attr">      include_vars:</span> <span class="string">"os_<span class="template-variable">&#123;&#123; ansible_facts['distribution'] &#125;&#125;</span>.yml"</span></span><br><span class="line"><span class="attr">    - debug:</span></span><br><span class="line"><span class="attr">        var:</span> <span class="string">asdf</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用playbook捆绑ansible模块"><a href="#使用playbook捆绑ansible模块" class="headerlink" title="使用playbook捆绑ansible模块"></a>使用playbook捆绑ansible模块</h4><p>Bundling Ansible Modules With Playbooks</p><p>如果playbook有相对于其它YAML文件的<code>./library</code>目录，此目录可以用来添加ansible module，它会自动在ansible模块路径。这是一个保持模块与playbook在一起的好方法。</p><p><br><br><br></p><h4 id="空白和注释"><a href="#空白和注释" class="headerlink" title="空白和注释"></a>空白和注释</h4><p>Whitespace and Comments</p><p>空白和注释有利于文件可读性，值得使用。</p><p><br><br><br></p><h4 id="任务命名"><a href="#任务命名" class="headerlink" title="任务命名"></a>任务命名</h4><p>Always Name Tasks</p><p>给任务建立一个正在做什么的名称。在运行时，playbook显示此名称。</p><p><br><br><br></p><h4 id="使它简单"><a href="#使它简单" class="headerlink" title="使它简单"></a>使它简单</h4><p>Keep It Simple</p><p>当你能够简单地做事，那就简单地做。不要为了达到使用所有ansible功能而一起使用它们。使用你需要的。把复杂的事情简单化。</p><p><br><br><br></p><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>Version Control</p><p>使用版本控制来管理playbook。</p><p><br><br><br></p><h4 id="变量和拱顶"><a href="#变量和拱顶" class="headerlink" title="变量和拱顶"></a>变量和拱顶</h4><p>Variables and Vaults</p><p>当运行playbook，Ansible在未加密的文件中查找变量，并且所有敏感的变量来自加密文件。</p><p>一个最佳实践方法是在组下开始一个<code>group_vars</code>子目录。在此子目录内，创建两个名为<code>vars</code>和<code>vault</code>的文件。<code>vars</code>文件内定义所有需要的变量，包括敏感的。接下来，复制所有的敏感变量到<code>vault</code>文件或以<code>vault_</code>开头的文件。你应该在<code>vars</code>文件内使用Jinja2语法调整变量指向匹配的<code>vault_</code>文件，并确保<code>vault</code>文件是vault encrypted。</p><p><br><br><br></p><h3 id="持续交付和滚动更新"><a href="#持续交付和滚动更新" class="headerlink" title="持续交付和滚动更新"></a>持续交付和滚动更新</h3><p>Playbook Example: Continuous Delivery and Rolling Upgrades: <a href="https://docs.ansible.com/ansible/latest/user_guide/guide_rolling_upgrade.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/guide_rolling_upgrade.html</a></p><p><br></p><h4 id="什么是持续交付"><a href="#什么是持续交付" class="headerlink" title="什么是持续交付"></a>什么是持续交付</h4><p>What is continuous delivery</p><p>Continuous delivery(CD)是指经常更新你的软件应用程序。</p><p><br><br><br><br><br></p><h2 id="特权晋升-1"><a href="#特权晋升-1" class="headerlink" title="特权晋升"></a>特权晋升</h2><p>Understanding privilege escalation: become: <a href="https://docs.ansible.com/ansible/latest/user_guide/become.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/become.html</a></p><p>Ansible使用现有的权限升级系统来执行具有root或其它权限的任务。此功能允许你成为(<code>become</code>)其它用户，与登录到远程机器不同，我们称之为<code>become</code>。become关键字利用现有的权限提升工具（如<code>sudo</code>, <code>su</code>, <code>pfexec</code>, <code>doas</code>, <code>pbrun</code>, <code>dzdo</code>, <code>ksu</code>, <code>runas</code>）。</p><p><br></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>你可以在任务、连接变量、命令行等控制<code>become</code>的使用。如果你以多种方式设置了特权提升，请注意优先级。</p><p>所有become plugins完整的列表: <a href="https://docs.ansible.com/ansible/latest/plugins/become.html#become-plugin-list" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/plugins/become.html#become-plugin-list</a></p><p><br></p><p><strong>become</strong></p><p>你可在play或task层设置<code>become</code>指令。你可以设置连接变量，从不同主机之间覆盖它们。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活特权提升</span></span><br><span class="line"><span class="attr">become:</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 默认root</span></span><br><span class="line"><span class="attr">become_user:</span> <span class="string">xxx</span></span><br><span class="line"><span class="comment"># 参考become plugins，可在ansible.cfg中配置。默认sudo</span></span><br><span class="line"><span class="attr">become_method:</span> <span class="string">sudo</span></span><br><span class="line"><span class="comment"># 为role或task执行特定标志</span></span><br><span class="line"><span class="attr">become_flags:</span> <span class="string">xxx</span></span><br></pre></td></tr></table></figure><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- name: Ensure the httpd is running</span><br><span class="line">  become: yes</span><br><span class="line">  service:</span><br><span class="line">    name: httpd</span><br><span class="line">    state: started</span><br><span class="line"></span><br><span class="line">- name: Run a command as the apache user</span><br><span class="line">  command: somecommand</span><br><span class="line">  become: yes</span><br><span class="line">  become_user: apache</span><br><span class="line"></span><br><span class="line">- name: Run a command as nobody</span><br><span class="line">  command: somecommand</span><br><span class="line">  become: yes</span><br><span class="line">  become_method: su</span><br><span class="line">  become_user: nobody</span><br><span class="line">  become_flags: &apos;-s /bin/sh&apos;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>连接变量</strong></p><p>Become connection variables</p><p>你可以定义不同的选型来管理node或group。你可以在资产中定义这些变量，或将其作为正常的变量使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ansible_become</span><br><span class="line">ansible_become_method</span><br><span class="line">ansible_become_user</span><br><span class="line">ansible_become_password</span><br><span class="line"></span><br><span class="line"># 栗子</span><br><span class="line">webserver ansible_user=manager ansible_become=yes</span><br></pre></td></tr></table></figure><p><br></p><p><strong>命令行选项</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--ask-become-pass, -K</span><br><span class="line">--become, -b</span><br><span class="line">--become-method=BECOME_METHOD</span><br><span class="line">--become-user=BECOME_USER</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="风险和局限性"><a href="#风险和局限性" class="headerlink" title="风险和局限性"></a>风险和局限性</h3><p>Risks and limitations of become</p><p>虽然权限提升是很直观的，但它如何工作也有一些限制。用户应该知道这些，以避免意外。</p><p><br></p><p><strong>成为一个非特权用户的风险</strong><br>Risks of becoming an unprivileged user</p><p>Ansible模块由第一个参数带入模块文件，然后将其复制到远程主机，最后在远程机器上执行它。</p><p>如果模块文件不使用<code>become</code>，当<code>become_ueer</code>为root时，或当远程机器被设置为root时，一切都好。在这些情况下，Ansible创建具有只允许由所述用户和root读取，或只允许由所述非特权用户切换到读取权限模块文件。</p><p>然而，当连接用户和<code>become_user</code>都不是特权用户，模块文件被写入需要由Ansible设置为用户可读。在这种情况下，Ansible使得模块文件世界可读的Ansible模块执行的持续时间。一旦模块执行完毕，Ansible删除临时文件。</p><p><br></p><p><strong>不是所有连接插件都支持</strong><br>Not supported by all connection plugins</p><p>特权升级方法也必须由连接使用的插件支持。</p><p><br></p><p><strong>每个主机只能启用一个方法</strong><br>Only one method may be enabled per host</p><p><br></p><p><strong>特权提升必须通用</strong><br>Privilege escalation must be general</p><p>你不能限制权限提升某些命令的权限。</p><p><br><br><br><br><br></p><h2 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h2><p>Ansible Vault: <a href="https://docs.ansible.com/ansible/latest/user_guide/vault.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/vault.html</a></p><p>Ansible Vault是Ansible的一个功能，可以让你在加密的文件中保存敏感数据（如密码、密钥），而不是像普通文本或playbooks或roles中。这些vault文件可以分布或放置在版本控制中。</p><p>要启用此功能，使用命令行选型<code>-ansible-vault</code>，和<code>--vault-password-file</code>。</p><p><br><br><br><br><br></p><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>Ansible Modules: <a href="https://docs.ansible.com/ansible/latest/user_guide/modules.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/modules.html</a></p><p>Ansible包含了大量的模块(module library)，可以直接在远程主机或通过playbook执行。</p><p>用户也可以编写自己的模块。这些模块可以控制系统资源（服务、包、文件…），或执行系统命令。</p><p><br><br><br></p><h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><p>Introduction to modules: <a href="https://docs.ansible.com/ansible/latest/user_guide/modules_intro.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/modules_intro.html</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># adhoc</span></span><br><span class="line">ansible webservers -m service -a <span class="string">"name=httpd state=started"</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># playbook</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">restart</span> <span class="string">webserver</span></span><br><span class="line"><span class="attr">  service:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>Return Values: <a href="https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.html</a></p><p>Ansible模块通常正常返回一个可以注册为一个变量的数据结构，或直接看到由ansible程序输出。每个模块都可选的记录自己唯一的返回值。</p><p>本章节包含的返回值适用于所有模块。</p><p><br></p><ul><li>Common<ul><li>backup_file</li><li>changed</li><li>failed</li><li>invocation</li><li>msg</li><li>rc</li><li>results</li><li>skipped</li><li>stderr</li><li>stderr_lines</li><li>stdout</li><li>stdout_lines</li></ul></li><li>Internal use<ul><li>ansible_facts</li><li>exception</li><li>warning</li><li>deprecations</li></ul></li></ul><p><br><br><br></p><h3 id="模块索引"><a href="#模块索引" class="headerlink" title="模块索引"></a>模块索引</h3><p>Module Index: <a href="https://docs.ansible.com/ansible/latest/modules/modules_by_category.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/modules/modules_by_category.html</a></p><p><br><br><br><br><br></p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Working With Plugins: <a href="https://docs.ansible.com/ansible/latest/plugins/plugins.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/plugins/plugins.html</a></p><p>插件是一段代码，可以扩充Ansible的核心功能。Ansible使用插件架构，以实现丰富的、灵活的、可扩展的功能集。</p><p>Ansible附带了一些方便的插件，你也可以很容易地编写自己的插件。</p><p><br><br><br><br><br></p><h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><p>collections: <a href="https://docs.ansible.com/ansible/latest/user_guide/collections_using.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/collections_using.html</a></p><p>Collections是Ansible的内容分发格式，可以包括playbooks, roles, modules, plugins。你可以通过Ansible Galaxy安装和使用collections。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="开发指南"><a href="#开发指南" class="headerlink" title="开发指南"></a>开发指南</h1><p>Developer Guide: <a href="https://docs.ansible.com/ansible/latest/dev_guide/index.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/dev_guide/index.html</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Ansible-Galaxy"><a href="#Ansible-Galaxy" class="headerlink" title="Ansible Galaxy"></a>Ansible Galaxy</h1><p>Ansible Galaxy: <a href="https://docs.ansible.com/ansible/latest/galaxy/user_guide.html" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/galaxy/user_guide.html</a></p><p>Ansible Galaxy是一个查找、分享、下载社区开发的roles的网站。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ansible docs: &lt;a href=&quot;https://docs.ansible.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.ansible.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RHELx86_64&lt;/li&gt;
&lt;li&gt;Ansible v2.9&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="DevOps" scheme="https://zhang21.github.io/tags/DevOps/"/>
    
      <category term="Ansible" scheme="https://zhang21.github.io/tags/Ansible/"/>
    
      <category term="Automation" scheme="https://zhang21.github.io/tags/Automation/"/>
    
  </entry>
  
  <entry>
    <title>Tornado</title>
    <link href="https://zhang21.github.io/2019/10/14/Tornado/"/>
    <id>https://zhang21.github.io/2019/10/14/Tornado/</id>
    <published>2019-10-14T08:19:21.000Z</published>
    <updated>2019-11-25T02:57:15.693Z</updated>
    
    <content type="html"><![CDATA[<p>环境:</p><ul><li>Tornado: v5.1</li><li>Python: v3.6</li></ul><p><br></p><p>参考:</p><ul><li>Docs: <a href="https://www.tornadoweb.org/en/branch5.1/" target="_blank" rel="noopener">https://www.tornadoweb.org/en/branch5.1/</a></li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="用户指南"><a href="#用户指南" class="headerlink" title="用户指南"></a>用户指南</h1><p><br></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Tornado是一个Python Web框架和异步(asynchronous)网络库。通过使用非阻塞(non-blocking)网络I/O，Tornado可以扩展到上万个连接，因此非常适合长轮询(long polling)、WebSocket需要长期连接到的每个用户的应用程序。</p><p>Tornado大致可以分为四个主要组件:</p><ul><li>Web框架：包含<code>RequestHandler</code>，它的子类用于创建web应用，并支持各种类。</li><li>HTTP的Client和Server的实现：<code>HTTPServer</code>和<code>AsyncHTTPClient</code>。</li><li>异步网络库(<code>IOLoop</code>和<code>IOStream</code>)，用于HTTP组件的构建块，并且还可实现其它协议。</li><li>协程库(<code>tornado.gen</code>)，允许异步代码写的更直接而不用链式回调(chaining callbacks)的方式。</li></ul><p>Tornado web框架和HTTP server一起为WSGI提供了一个全栈(full-stack)式选择。为了充分利用Tornado的特性，你需要一起使用Tornado Web框架和HTTP Server。</p><p><br><br><br><br><br></p><h2 id="异步和非阻塞I-O"><a href="#异步和非阻塞I-O" class="headerlink" title="异步和非阻塞I/O"></a>异步和非阻塞I/O</h2><p>实时(real-time) Web功能需要为每个用户提供一个长时间空闲(mostly-idle)的长连接。在传统的同步(synchronous) web server，这意味着为每个用户提供一个线程(thread)，这是非常昂贵的。<br>要尽可能减少并发连接(concurrent connections)的开销，Tornado使用一个单线程事件循环。这意味着所有应用程序代码都应该是异步非阻塞的，因为在同一时间只有一个操作是活跃的。<br>异步和非阻塞这两个术语是非常相关的，并经常交换使用，但它们不是完全相同的事情。</p><p><br></p><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>一个函数在等待某些事情的返回的时候会被阻塞(block)。函数阻塞的原因有很多，如：网络IO、磁盘IO、互斥锁…事实上，每个函数在运行和使用CPU的时候或多或少会被阻塞。</p><p>一个函数可以在某些方面阻塞，在另外一些方面不阻塞。在Tornado下，我们通常讨论网络IO阻塞，尽管各种阻塞也被最小化。</p><p><br><br><br></p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步(asynchronous)函数在完成之前返回，在应用中触发下一个动作之前通常会在后台执行一些工作（和正常的同步函数在返回之前就执行完所有的事情不同）。这里列举了几种风格的异步接口：</p><ul><li>回调参数</li><li>返回一个占位符</li><li>传送给一个队列</li><li>回调注册表</li></ul><p><br><br><br></p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><p>一个同步(synchronous)函数的栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from tornado.httpclient import HTTPClient</span><br><span class="line"></span><br><span class="line">def synchronous_fetch(url):</span><br><span class="line">    http_client = HTTPClient()</span><br><span class="line">    response = http_client.fetch(url)</span><br><span class="line">    return response.body</span><br></pre></td></tr></table></figure><p>一个异步(asynchronous)重写的函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">asynchronous_fetch</span><span class="params">(url)</span>:</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response = <span class="keyword">await</span> http_client.fetch(url)</span><br><span class="line">    <span class="keyword">return</span> response.body</span><br></pre></td></tr></table></figure><p>协程(coroutines)有点不可思议，但它们在内如是这样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.concurrent <span class="keyword">import</span> Future</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">async_fetch_manual</span><span class="params">(url)</span>:</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    my_future = Future()</span><br><span class="line">    fetch_future = http_client.fetch(url)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_fetch</span><span class="params">(f)</span>:</span></span><br><span class="line">        my_future.set_result(f.result().body)</span><br><span class="line">    fetch_future.add_done_callback(on_fetch)</span><br><span class="line">    <span class="keyword">return</span> my_future</span><br></pre></td></tr></table></figure><p><br></p><p>任何可用协程做的都可传递到回调(callback)对象周围，但协程提供了一个重要的简化让你以相同的方式组织你的代码。这对于错误处理(error handling)尤其重要，在协程预期的<code>tyr/except</code>块工作，这是难以实现的回调。</p><p><br><br><br><br><br></p><p>在Tornado中，协程(Coroutines)是推荐的编写异步代码的方式。协程使用Python的<code>await</code>或<code>yield</code>关键字来暂停(suspend)和恢复(resume)来代替回调链。</p><p>协程几乎与同步(synchronous)代码一样简单，但不带线程(thread)的开销。它们使得并发(concurrency)更简单。</p><p>栗子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_coroutine</span><span class="params">(url)</span>:</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">response = <span class="keyword">await</span> http_client.fetch(url)</span><br><span class="line"><span class="keyword">return</span> response.body</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="原生与装饰的协程"><a href="#原生与装饰的协程" class="headerlink" title="原生与装饰的协程"></a>原生与装饰的协程</h3><p>Native vs decorated coroutines</p><p>Python 3.5介绍了<code>async</code>和<code>await</code>关键字。</p><p>只要可能，原生协程是推荐的形式。仅需要与旧版本的Python兼容时使用装饰的协程。Tornado文档中一般会使用原生形式。</p><p>这两种形式之间的转换一般是简单的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Decorated</span></span><br><span class="line"><span class="comment"># Normal function declaration</span></span><br><span class="line"><span class="comment"># with decorator</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 'yield' all async funcs</span></span><br><span class="line">b = <span class="keyword">yield</span> c()</span><br><span class="line"><span class="comment"># 'return' and 'yield'</span></span><br><span class="line"><span class="comment"># cannot be mixed in</span></span><br><span class="line"><span class="comment"># Python 2, so raise a</span></span><br><span class="line"><span class="comment"># special execption</span></span><br><span class="line"><span class="keyword">raise</span> gen.Return(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Native</span></span><br><span class="line"><span class="comment"># 'async def' keywords</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 'await' all async funcs</span></span><br><span class="line">b = <span class="keyword">await</span> c()</span><br><span class="line"><span class="comment"># return normally</span></span><br><span class="line"><span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><p><br></p><p>两种协程形式的不同:</p><ul><li>原生协程通常更快</li><li>原生协程可以使用<code>async for</code>和<code>async with</code>语句，这使得一些模式更简单</li><li>除非<code>await</code>和<code>yield</code>它们，原生协程不会运行所有。装饰的协程一经调用就运行在后台(background)。请注意，这两种协程使用<code>await</code>或<code>yield</code>都很重要，以便任何异常都有地方可去</li><li>装饰的协程有与<code>concurrent.futures</code>包额外的集成，允许直接yielded <code>executor.submit</code>的结果。对于原生协程，使用<code>IOLoop.run_in_executor</code>代替</li><li>通过生成一个列表或字典，装饰的协程支持一些速记。在原生协程中使用<code>tornado.gen.multi</code></li><li>装饰的协程可以支持与其它软件包的整合。要在原生协程中访问此功能，使用<code>tornado.gen.convert_yielded</code></li><li>装饰的协程总是返回一个<code>Future</code>对象。原生协程返回一个awaitable对象</li></ul><p><br><br><br></p><h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>本节介绍装饰的协程的操作。原生协程在概念上相似，但多了几分复杂。因为与Python runtime额外集成。</p><p>包含<code>yield</code>的函数是一个生成器(generator)。所有的生成器都是异步的，调用它们时返回一个生成器对象，而不是运行到完成。<code>@gen.coroutine</code>装饰器(decorator)通过<code>yield</code>表达式与生成器进行通信，通过协程调用返回一个<code>Future</code>。</p><p>一个协程装饰器的内循环的简单栗子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Simplified inner loop of tornado.gen.Runner</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># send(x) makes the current yield return x</span></span><br><span class="line">    <span class="comment"># It returns when the next yield is reached</span></span><br><span class="line">    future = self.gen.send(self.next)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(f)</span>:</span></span><br><span class="line">        self.next = f.result()</span><br><span class="line">        self.run()</span><br><span class="line">    future.add_done_callback(callback)</span><br></pre></td></tr></table></figure><p>装饰器从生成器接收一个<code>Future</code>，等待(不会阻塞)选择那些完成的<code>Future</code>，解包<code>Future</code>并将结果发送回生成器的<code>yield</code>表达式。大多数异步代码不直接接触<code>Future</code>类，除了由一个异步函数立即传递<code>Future</code>到<code>yield</code>表达式。</p><p><br><br><br></p><h3 id="如何调用协程"><a href="#如何调用协程" class="headerlink" title="如何调用协程"></a>如何调用协程</h3><p>协程在正常方式下不抛出异常：它们抛出的任何异常都将在<code>awaitable</code>对象直到它被yielded。这意味着以正确的方式调用协程是重要的，或者可能有被你忽略的错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x / y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bad_call</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># This should raise a ZeroDivisionError, but it won't because</span></span><br><span class="line">    <span class="comment"># the coroutine is called incorrectly.</span></span><br><span class="line">    divide(<span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在几乎所有情况下，调用协程的任何函数都必须是一个协程本身，并在调用中使用<code>await</code>和<code>yield</code>关键字。当你重写superclass中定义的方法时，查看文档看协程是否被允许。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">good_call</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># await will unwrap the object returned by divide() and raise the exception.</span></span><br><span class="line">    <span class="keyword">await</span> divide(<span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>有时，你可能想fire and forget协程，而无需等待其结果。在这种情况下，推荐使用<code>IOLoop.spawn_callback</code>，这使得<code>IOLoop</code>负责调用。如果失败，<code>IOLoop</code>将记录stack trace。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The IOLoop will catch the exception and print a stack trace in the logs.</span></span><br><span class="line"><span class="comment"># Note that this doesn't look like a normal call, since we pass the function object to be called by the IOLoop.</span></span><br><span class="line"></span><br><span class="line">IOLoop.current().spawn_callback(divide, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>函数使用<code>@gen.coroutin</code>在这种方式下建议使用<code>IOLoop.spawn_callback</code>，但它需要函数使用<code>async def</code>。</p><p>最后，在程序的顶层，如果<code>IOLoop</code>尚未运行，就可以启动<code>IOLoop</code>，运行协程，然后用<code>IOLoop.run_sync</code>方法停止<code>IOLoop</code>。这经常用来启动一个面向批处理程序的<code>main()</code>函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># run_sync() doesn&apos;t take arguments, so we must wrap the call in lambda.</span><br><span class="line">IOLoop.current().run_sync(lambda: divide(1, 0))</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="协程模式"><a href="#协程模式" class="headerlink" title="协程模式"></a>协程模式</h3><p>Coroutine patterns</p><h4 id="调用阻塞函数"><a href="#调用阻塞函数" class="headerlink" title="调用阻塞函数"></a>调用阻塞函数</h4><p>Calling blocking functions</p><p>从协程调用阻塞函数最简单的方式是使用<code>IOLoop.run_in_executor</code>，它返回与协程兼容的<code>Future</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">call_blocking</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> IOLoop.current().run_in_executor(<span class="keyword">None</span>, blocking_func, args)</span><br></pre></td></tr></table></figure><p><br></p><h4 id="Parallelism"><a href="#Parallelism" class="headerlink" title="Parallelism"></a>Parallelism</h4><p><code>multi</code>函数接收列表和字典，其值是<code>Futures</code>，并等待所有并行(parallel)的<code>Futures</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.gen <span class="keyword">import</span> multi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">paraller_fetch</span><span class="params">(url1, url2)</span>:</span></span><br><span class="line">    resp1, resp2 = <span class="keyword">await</span> multi([http_client.fetch(url1), http_client.fetch(url2)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">paraller_fetch_many</span><span class="params">(urls)</span>:</span></span><br><span class="line">    responses = <span class="keyword">await</span> multi (http_client.fetch(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls)</span><br><span class="line">    <span class="comment"># responses is a list of HTTPResponses in the same order</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parallel_fetch_dict</span><span class="params">(urls)</span>:</span></span><br><span class="line">    responses = <span class="keyword">await</span> multi(&#123;url: http_client.fetch(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls&#125;)</span><br><span class="line">    <span class="comment"># responses is a dict &#123;url: HTTPResponse&#125;</span></span><br></pre></td></tr></table></figure><p>在装饰的协程，可<code>yield</code>列表或字典:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aprallel_fetch_decorated</span><span class="params">(url1, url2)</span>:</span></span><br><span class="line">    resp1, resp2 = <span class="keyword">yield</span> [http_client.fetch(url1), http_client.fetch(url2)]</span><br></pre></td></tr></table></figure><p><br></p><h4 id="Interleaving"><a href="#Interleaving" class="headerlink" title="Interleaving"></a>Interleaving</h4><p>有时保存<code>Future</code>是有用的而不立即yielding，因此你可以在等待之前启动其它操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.gen <span class="keyword">import</span> convert_yielded</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># convert_yielded() starts the native coroutine in the background.</span></span><br><span class="line">    <span class="comment"># This is equivalent to asyncio.ensure_future() (both work in Tornado).</span></span><br><span class="line">    fetch_future = convert_yielded(self.fetch_next_chunk())</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        chunk = <span class="keyword">yield</span> fetch_future</span><br><span class="line">        <span class="keyword">if</span> chunk <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">break</span></span><br><span class="line">        self.write(chunk)</span><br><span class="line">        fetch_future = convert_yielded(self.fetch_next_chunk())</span><br><span class="line">        <span class="keyword">yield</span> self.flush()</span><br></pre></td></tr></table></figure><p>这是一个比较容易做装饰的协程，因为它们在调用时立即启动:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">    fetch_future = self.fetch_next_chunk()</span><br><span class="line">    <span class="keyword">if</span> chunk <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">break</span></span><br><span class="line">    self.write(chunk)</span><br><span class="line">    fetch_future = self.fetch_next_chunk()</span><br><span class="line">    yiield self.flush()</span><br></pre></td></tr></table></figure><p><br></p><h4 id="Looping"><a href="#Looping" class="headerlink" title="Looping"></a>Looping</h4><p>在原生协程，可使用<code>async for</code>。在不同版本的Python中，looping is tricky with coroutines，因为没有办法获得对<code>for</code>或<code>while</code>循环的每次迭代结果的yield。你需要从访问结果分隔循环条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> motor</span><br><span class="line"></span><br><span class="line">db = motor.MotorClient().test</span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_example</span><span class="params">(collection)</span>:</span></span><br><span class="line">    cursor = db.collection.find()</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">yield</span> cursor.fetch_next):</span><br><span class="line">        doc = cursor.netx_object()</span><br></pre></td></tr></table></figure><p><br></p><h4 id="在后台运行"><a href="#在后台运行" class="headerlink" title="在后台运行"></a>在后台运行</h4><p>Running in the background</p><p><code>PeriodicCallback</code>通常不与协程使用。相反，协程可以包含<code>While True:</code>循环并使用<code>tornado.gen.sleep</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">minute_loop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">await</span> do_something()</span><br><span class="line">        <span class="keyword">await</span> gen.sleep(<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Coroutines that loop forever are generally started with spawn_callback().</span></span><br><span class="line">IOLoop.current().spawn_callback(minute_loop)</span><br></pre></td></tr></table></figure><p>有时，一个更复杂的循环可能是可取的。例如，前一个循环每<code>60+N</code>秒运行，N是<code>do_something</code>的运行时间。要准确每60秒运行，使用上面的interleaving模式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">minute_loop2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">True</span>:</span></span><br><span class="line">        nxt = gen.sleep(<span class="number">60</span>)  <span class="comment"># Start the clock.</span></span><br><span class="line">        <span class="keyword">await</span> do_something()  <span class="comment"># Run while the clock is ticking.</span></span><br><span class="line">        <span class="keyword">await</span> nxt  <span class="comment"># Wait for the timer to run out.</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue example - a concurrent web spider</p><p>Tornado的<code>tornado.queues</code>模块实现了协程异步 生产者(producer)/消费者(consumer)模式，类似于由Python标准库的<code>queue</code>模块为线程(thread)实现的模式。</p><p>yields <code>Queue.get</code>协程暂停直到队列中有项。如果队列设置了最大大小集(yield <code>Queue.put</code>)协程暂停，直到有另一个项。</p><p><code>Queue</code>维护未完成的任务计数，从0开始。<code>put</code>递增计数，<code>task_done</code>递减它。</p><p>web-spider栗子，队列开始仅包含base_url。当worker获取它解析的链接和队列放出新的页面，然后调用<code>task_done</code>递减计数。最终，worker取出其url没有过的页面，也没有留在队列中工作。因此，worker调用<code>task_done</code>递减计数器归零。主协程，它等待<code>join</code>，取消暂停和完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datatime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> html.parser <span class="keyword">import</span> HTMLParser</span><br><span class="line"><span class="keyword">from</span> ulllib.parse <span class="keyword">import</span> urljoin, urldefrag</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen, httpclient, ioloop, queues</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">'http://www.tornadoweb.org/en/stable/'</span></span><br><span class="line">concurrency = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_links_from_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">"""Download the page at `url` and parse it for links.</span></span><br><span class="line"><span class="string">    Returned links have had the fragment after `#` removed, and have been made bsolute so,</span></span><br><span class="line"><span class="string">    e.g. the URL 'gen.html#tornado.gen.coroutine' becomes</span></span><br><span class="line"><span class="string">    'http://www.tornadoweb.org/en/stable/gen.html'.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    response = <span class="keyword">await</span> httpclient.AsyncHTTPClient().fetch(url)</span><br><span class="line">    print(<span class="string">'fetched %s'</span> % url)</span><br><span class="line"></span><br><span class="line">    html = response.body.decode(<span class="string">'errors='</span>ignore<span class="string">')</span></span><br><span class="line"><span class="string">    return [urljoin(url, remove_fragment(new_url))</span></span><br><span class="line"><span class="string">            for new_url in get_links(html)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def remove_fragment(url):</span></span><br><span class="line"><span class="string">    pure_url, frag = urldefrag(url)</span></span><br><span class="line"><span class="string">    return pure_url</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def get_links(html):</span></span><br><span class="line"><span class="string">    class URLSeeker(HTMLParser):</span></span><br><span class="line"><span class="string">        def __init__(self):</span></span><br><span class="line"><span class="string">            HTMLParser.__init__(self)</span></span><br><span class="line"><span class="string">            self.urls = []</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        sef handle_starttag(self, tag, attrs):</span></span><br><span class="line"><span class="string">            href = dict(attrs).get('</span>hre<span class="string">f')</span></span><br><span class="line"><span class="string">            if href and tag == '</span>a<span class="string">':</span></span><br><span class="line"><span class="string">                self.urls.append(href)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    url_seeker = URLSeeker()</span></span><br><span class="line"><span class="string">    url_seeker.feed(html)</span></span><br><span class="line"><span class="string">    return url_seeker.urls</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">async def main():</span></span><br><span class="line"><span class="string">    q = queues.Queue()</span></span><br><span class="line"><span class="string">    start = time.time()</span></span><br><span class="line"><span class="string">    fetching, fetched = set(), set()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    async def fetch_url(currrent_url):</span></span><br><span class="line"><span class="string">        if current_url in fetching:</span></span><br><span class="line"><span class="string">            return</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        print('</span>fetching %s<span class="string">' % current_url)</span></span><br><span class="line"><span class="string">        fetching.add(current_url)</span></span><br><span class="line"><span class="string">        urls = await get_links_from_url(current_url)</span></span><br><span class="line"><span class="string">        fetched.add(current_url)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        for new_url in urls:</span></span><br><span class="line"><span class="string">            # Only follow links beneath the base URL</span></span><br><span class="line"><span class="string">            if new_url.startswith(base_url):</span></span><br><span class="line"><span class="string">                await q.put(new_url)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    async def worker():</span></span><br><span class="line"><span class="string">        async for url in q:</span></span><br><span class="line"><span class="string">            if url in None:</span></span><br><span class="line"><span class="string">                return</span></span><br><span class="line"><span class="string">            try:</span></span><br><span class="line"><span class="string">                await fetch_url(url)</span></span><br><span class="line"><span class="string">            except Exception as e:</span></span><br><span class="line"><span class="string">                print('</span>Exception: %s %s<span class="string">' % (e, url))</span></span><br><span class="line"><span class="string">            finally:</span></span><br><span class="line"><span class="string">                q.task_done()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    await q.put(base_url)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # Start workers, then wait for the work queue to be empty.</span></span><br><span class="line"><span class="string">    workers = gen.multi([worker() for _ in range(concurrency)])</span></span><br><span class="line"><span class="string">    await q.join(timeout=timedelta(seconds=300))</span></span><br><span class="line"><span class="string">    assert fetching == fetched</span></span><br><span class="line"><span class="string">    print('</span>Done <span class="keyword">in</span> %d seconds, fetched %s URLs.<span class="string">' % (</span></span><br><span class="line"><span class="string">        time.time() - start, len(fetched)))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # Signal all the workers to exit.</span></span><br><span class="line"><span class="string">    for _ in range(concurrency):</span></span><br><span class="line"><span class="string">        await q.put(None)</span></span><br><span class="line"><span class="string">    await workers</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ == '</span>__main__<span class="string">':</span></span><br><span class="line"><span class="string">    io_loop = ioloop.IOLoop.current()</span></span><br><span class="line"><span class="string">    io_loop.run_sync(main)</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="Tornado-web程序结构"><a href="#Tornado-web程序结构" class="headerlink" title="Tornado web程序结构"></a>Tornado web程序结构</h2><p>Structure of a Tornado web application</p><p>一个Tornado web程序通常由一个或多个<code>RequestHandler</code>子类组成，<code>Application</code>对象是哪些路由进入的请求的处理程序(handler)，<code>main()</code>函数来启动server。</p><p>一个最小化的hello world栗子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">"Hello, world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_app</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tornado.web.Application([</span><br><span class="line">        (<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(<span class="number">8888</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Application对象"><a href="#Application对象" class="headerlink" title="Application对象"></a>Application对象</h3><p><code>Application</code>对象是负责全局配置，包括映射请求到处理程序(handler)的路由表。</p><p>路由表是<code>URLSpec</code>对象的列表(或元组)，其中每一个包含(至少)一个正则表达式和一个处理类(handler class)。顺序匹配，第一匹配规则被使用。如果正则表达式中包含捕获组，这些组的路径参数将被传递给处理程序(handler)的HTTP方法。如果字典作为<code>URLSpec</code>的第三个参数传递，它提供将初始化参数传递给<code>RequestHandler.initialize</code>。最后，<code>URLSpec</code>可以有一个名称，这将允许它与<code>RequestHandler.reverse_url</code>使用。</p><p>栗子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># / URL 映射到 MainHandler</span></span><br><span class="line"><span class="comment"># /story/后跟数字 映射到 StoryHandler，数字(作为字符串)被传递给StoryHandler.get</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">'&lt;a href="%s"&gt; link to story 1&lt;/a&gt;'</span> %</span><br><span class="line">                  self.reverse_url(<span class="string">"story"</span>, <span class="string">"1"</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoryHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self, db)</span>:</span></span><br><span class="line">        self.db = db</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, story_id)</span>:</span></span><br><span class="line">        self.write(<span class="string">"this is story %s"</span> % story_id)</span><br><span class="line"></span><br><span class="line">app = Application([</span><br><span class="line">    url(<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">    url(<span class="string">r"/story/([0-9]+)"</span>, StoryHandler, dict(db=db), name=<span class="string">"story"</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p><code>Application</code>构造器采用许多关键字参数，可用于定制应用程序的行为和启用可选功能。查看<code>Application.settings</code>获取完整列表。</p><p><br><br><br></p><h3 id="RequestHandler子类"><a href="#RequestHandler子类" class="headerlink" title="RequestHandler子类"></a>RequestHandler子类</h3><p>Subclassing RequestHandler</p><p>大部分Tornado Web应用程序的工作是<code>RequestHandler</code>子类完成的。主入口点的处理程序子类(handler subclass)是正在处理的HTTP方法(<code>get()</code>, <code>post()</code>)的方法命名。例如，每个handler可以定义这些方法中的一种或多种，以处理不同的HTTP动作。如上所述，这些方法将于对应于匹配的路由规则的捕获组参数来调用。</p><p>在处理程序内部，调用如<code>RequestHandler.render</code>或<code>RequestHandler.write</code>来产生响应(response)。<code>render()</code>通过名称加载一个模板，并与给定的参数来渲染它。<code>write()</code>被用于非基于模板(non-template-based)输出。它接受字符串，字节和字典(字典被编码为json)。</p><p><code>ReqestHandler</code>中的许多方法都设计在子类中重写(overridden)，并在整个application中使用。这是常见的定义<code>BaseHandler</code>类，覆盖方法如<code>write_error</code>, <code>get_current_user</code>，并为你所有指定的handler继承<code>BaseHandler</code>而不是<code>RequestHandler</code>。</p><p><br><br><br></p><h3 id="处理请求输入"><a href="#处理请求输入" class="headerlink" title="处理请求输入"></a>处理请求输入</h3><p>Handling request input</p><p>request handler可以访问表示与<code>self.quest</code>获取当前请求的对象。查看<code>HTTPServerRequest</code>类来获取完整的列表。</p><p>通过HTML表单中使用的格式请求的数据将为你解析，并在如<code>get_query_argument</code>和<code>get_body_argument</code>方法中可用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFormHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">'&lt;html&gt;&lt;body&gt;&lt;form action="/myform" method="POST"&gt;'</span></span><br><span class="line">                   <span class="string">'&lt;input type="text" name="message"&gt;'</span></span><br><span class="line">                   <span class="string">'&lt;input type="submit" value="Submit"&gt;'</span></span><br><span class="line">                   <span class="string">'&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.set_header(<span class="string">"Conten-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line">        self.write(<span class="string">"You wrote"</span> + self.get_body_argument)</span><br></pre></td></tr></table></figure><p>由于HTML表单的编码是模糊的，以元素中的一个参数是否为单一值(single value)或一个列表，<code>RequestHandler</code>有独特的方法，以允许application表明它是否期望一个列表。对于列表，使用<code>get_query_arguments</code>和<code>get_body_arguments</code>来代替它们的singular counterparts。</p><p>通过表单上传的文件在<code>self.request.files</code>可用，它映射名称(html <code>input type=&quot;file&quot;</code>元素)到一个文件列表。每个文件是<code>{&quot;filename&quot;:..., &quot;content_type&quot;:..., &quot;body&quot;:...}</code>格式的字典。<code>files</code>对象仅表示文件是否以一种form wrapper上传(如<code>multipart/form-data</code> 内容类型)。如果不使用这种格式，原始上传数据在<code>self.request.body</code>可用。默认情况下上传的文件在内存中完全缓冲(fully buffered)。如果你要处理的文件太大，但想在内存中舒适保存，可参考<code>stream_request_body</code>类装饰器。</p><p>由于HTML格式编码的怪癖，Tornado并不试图统一参数和其它输入类型的形式。特别是，我们不解析JSON请求主体。Applicaton希望使用JSON而不是form-encoding可以覆盖<code>prepare</code>来解析它们的请求:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepare</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.request.headers.get(<span class="string">"Content-Type"</span>, <span class="string">""</span>).startswith(<span class="string">'"application/json"'</span>):</span><br><span class="line">        self.json_args = json.loads(self.request.body)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.json_args = <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="重写RequestHandler方法"><a href="#重写RequestHandler方法" class="headerlink" title="重写RequestHandler方法"></a>重写RequestHandler方法</h3><p>Overriding RequestHandler methods</p><p>除了<code>get()</code>, <code>post()</code>…，在<code>RequestHandler</code>某些其它方法被设计成在必要时由子类重写。在每次请求，调用以下顺序进行:</p><ol><li>在每个请求上，一个新的<code>RequestHandler</code>对象被创建</li><li><code>initialize()</code>被调用，从Application配置的初始化参数。初始化通常应该只保存传入成员变量的参数，不产生任何输出或调用(如<code>send_error</code>)</li><li><code>prepare()</code>被调用。这是最有用的，由所有handler subclass共享的基类，作为prepare被无论哪个HTTP方法所调用。<code>prepare</code>可产生输出，如果它调用<code>finish</code>或<code>redirect</code>，这里处理停止</li><li>当其中一个HTTP方法被调用时: <code>get()</code>, <code>post()</code>, <code>put()</code>。如果URL正则中包含捕获组(capturing group)，它们将被作为参数传递给该方法</li><li>当请求完成后，调用<code>on_finish()</code>。对于大多数handler这个在<code>get()</code>返回后立即调用。在调用<code>finish()</code>之后使用<code>tornado.web.asynchronous</code>装饰器来装饰handler</li></ol><p>在<code>RequestHandler</code>文档中，所有的方法都设计来可重写。一些最常用的重写方法:</p><ul><li><code>writre_error</code>: 输出HTML错误页面</li><li><code>on_connection_close</code>: 当客户端断开连接时调用。应用可选择检测此情况并停止进一步的处理。注意，不能保证一个关闭的连接能够被及时发现</li><li><code>get_current_user</code></li><li><code>get_user_locale</code>: 返回当前用户的Locale对象</li><li><code>set_default_headers</code>: 用于在响应中设置其它header</li></ul><p><br><br><br></p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>Error Handling</p><p>如果handler抛出一个异常，Tornado将调用<code>RequestHandler.write_error</code>来生成一个错误页。<code>tornado.web.HTTPError</code>可用来生成一个特定状态码。所有其它异常返回500状态。</p><p>debug模式下的默认错误页面包含一个stack trace和对错误的一行说明。要生成自定义错误页，重写<code>RequestHandler.write_error</code>。可通过如<code>write</code>和<code>render</code>方法来产生输出。如果错误是由异常导致的，一个<code>exc_info</code>将作为一个关键字参数传递。</p><p>也可通过调用<code>set_status</code>产生与常规处理方法<code>write_error</code>生成的错误页面，编写一个响应，并返回。特殊异常<code>tornado.web.Finish</code>可抛出终止处理而不调用<code>write_error</code>在简单返回不方便时。</p><p>对于404错误，使用<code>default_handler_class</code>应用设置(Application setting)。此处理程序应重写<code>prepare</code>，而不是像<code>get()</code>方法更具体的方法，所以它与任何HTTP方法工作。如上所述应该产生错误页面: 要么抛出<code>HTTPError(404)</code>和重写<code>write_error</code>，或调用<code>self.set_status(404)</code>和直接在<code>prepare()</code>中产生响应。</p><p><br><br><br></p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>Redirection</p><p>Tornado中有两种主要的方式重定向请求: <code>RequestHandler.redirect</code>和<code>RedirectHandler</code>。</p><p>可在<code>RequestHandler</code>方法中使用<code>self.redirect()</code>来重定向到别处。这有一个<code>permanent</code>的可选参数，可用它来表示永久的重定向。<code>permanent</code>的默认值为<code>False</code>，其产生一个<code>302 Found</code> HTTP响应码，适合像<code>POST</code>请求成功之后使用。如果<code>permanent</code>为<code>true</code>， 则使用<code>301 Moved Permanently</code> HTTP响应码，其用于重定向到一个规范友好的URL。</p><p><code>RedirectHandler</code>让你直接在Application路由表中配置重定向，栗子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app = tornado.web.Application([</span><br><span class="line">    url(<span class="string">r"/app"</span>, tornado.web.RedirectHandler,</span><br><span class="line">        dict(url=<span class="string">"http://xxx.com"</span>)),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p><code>RedirectHandler</code>同样支持正则表达式取代。栗子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app = tornado.web.Application([</span><br><span class="line">    url(<span class="string">r"/photos/(.*)"</span>, MyPhotoHandler),</span><br><span class="line">    url(<span class="string">r"/pictures/(.*)"</span>, tornado.web.RedirectHandler,</span><br><span class="line">        dict(url=<span class="string">r"/photo/&#123;0&#125;)),</span></span><br><span class="line"><span class="string">])</span></span><br></pre></td></tr></table></figure><p>不像<code>RequestHandler.redirect</code>，<code>RedirectHandler</code>默认使用永久重定向。这因为路由表在运行时不发生变化，被认定为时永久性的，而在处理中发现重定向可能改变其它逻辑的结果。要使用<code>RedirectHandler</code>发送一个临时的重定向，将<code>permanent=False</code>添加到<code>RedirectHandler</code>初始化参数。</p><p><br><br><br></p><h3 id="异步处理程序"><a href="#异步处理程序" class="headerlink" title="异步处理程序"></a>异步处理程序</h3><p>Asynchronous handlers</p><p>某些处理方法(如<code>prepare()</code>和HTTP的<code>get()</code>, <code>post()</code>…)可能会被重写为协程，使处理程序异步。</p><p>Tornado同样支持使用<code>tornado.web.asynchronous</code>装饰器异步处理的回调风格，但这种风格已经过时，将在Tornado6中一处。新的应用应该使用协程来代替它。</p><p>使用协程的一个简单处理程序的栗子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        http = tornado.httpclient.AsyncHTTPClient()</span><br><span class="line">        response = <span class="keyword">await</span> http.fetch(<span class="string">"http://friendfeed-api.com/v2/feed/bret"</span>)</span><br><span class="line">        json = tornado.escape.json_decode(response.body)</span><br><span class="line">        self.write(<span class="string">"Fetched "</span> + str(len(json[<span class="string">"entries"</span>])) + <span class="string">" entries "</span></span><br><span class="line">                   <span class="string">"from the FriendFeed API"</span>)</span><br></pre></td></tr></table></figure><p>更多高级的异步的栗子，查考文档。</p><p><br><br><br><br><br></p><h2 id="模板和UI"><a href="#模板和UI" class="headerlink" title="模板和UI"></a>模板和UI</h2><p>Templates and UI</p><p>Tornado包含了一个简单、快速、灵活的模板语言。想想Django和Jinja2。</p><p>Tornado还可与任何其它Python模板语言使用，虽然没有规定集成这些系统到<code>RequestHandler.render</code>里。简单地渲染模板为字符串，并将其传递到<code>RequestHandler.write</code>。</p><p><br></p><h3 id="配置模板"><a href="#配置模板" class="headerlink" title="配置模板"></a>配置模板</h3><p>Configuring templates</p><p>默认情况下，Tornado在引用它的<code>.py</code>文件中的同一目录下查找模板文件。要把模板文件放在不同的目录中，使用<code>template_path</code>应用设置。如果你有不同的模板路径用于不同的处理程序，请重写<code>RequestHandler.get_template_path</code>。</p><p>要从非文件系统位置载入模板，子类<code>tornado.template.BaseLoader</code>将在模板并传递一个实例作为<code>template_loader</code>应用设置。</p><p>默认缓存编译的模板。要关闭这个缓存和重新加载模板，使用<code>compiled_template_cache=False</code>或<code>debug=True</code>应用设置。</p><p><br><br><br></p><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><p>Template syntax</p><p>Tornado模板仅仅是HTML(或其它基于文本的格式)与Python控制序列和嵌入在标记内的表达式，想想Django模板和Jinja2。</p><p>表达式可以是任意Python表达式，包括函数调用。模板代码在包括以下对象和函数的命名空间执行(请注意，以下列表适用于使用<code>RequestHandler.render</code>和<code>render_string</code>渲染模板。如果你直接使用在<code>RequestHandler</code>外的<code>tornado.template</code>模块，那么许多内容是不存在的。)</p><ul><li><code>escape</code>: <code>tornado.escape.xhtml_escape</code>的别名</li><li><code>xhtml_escape</code>: <code>tornado.escape.xhtml_escape</code>的别名</li><li><code>url_escape</code>: <code>tornado.escape.url_escape</code>的别名</li><li><code>json_encode</code>: <code>tornado.escape.json_encode</code>的别名</li><li><code>squeeze</code>: <code>tornado.escape.squeeze</code>的别名</li><li><code>linkify</code>: <code>tornado.escape.linkify</code>的别名</li><li><code>datetime</code>: Python的<code>datetime</code>模块</li><li><code>handler</code>: 目前的<code>RequestHandler</code>对象</li><li><code>request</code>: <code>handler.request</code>的别名</li><li><code>current_user</code>: <code>handler.current_user</code>的别名</li><li><code>locale</code>: <code>handler.locale</code>的别名</li><li><code>_</code>: <code>handler.locale.translate</code>的别名</li><li><code>static_url</code>: <code>handler.static_url</code>的别名</li><li><code>xsrf_form_html</code>: <code>handler.xsrf_form_html</code>的别名</li><li><code>reverse_url</code>: <code>Application.reverse_url</code>的别名</li><li>所有条目从应用的<code>ui_methods</code>和<code>ui_modules</code></li><li>任何关键字参数传递给<code>render</code>或<code>render_string</code></li></ul><p>当你在构建一个真正的应用时，你会想要使用Tornado模板的所用功能，尤其是模板继承。阅读<code>tornado.template</code>部分了解详细信息。</p><p>引擎盖下，Tornado模板直接转换为Python。模板中的表达式是逐字复制到Python函数中。我们不设法防止模板语言的任何东西。最后，如果你写的模板表达式内随机的东西，当你执行模板可能会获得随机的Python错误。</p><p>所有的模板输出默认被转义(escape)，使用<code>tornado.escape.xhtml_escape</code>函数。这个行为可通过全局地传递<code>autoescape=None</code>给应用或<code>tornado.template.Loader</code>构造器，对于模板文件指示<figure class="highlight plain"><figcaption><span>autoescape None%&#125;```或通过```&#123;% raw ... %&#125;```代替```&#123;&#123; ... &#125;&#125;```。此外，在每一个可选择转义函数名的地方，可用`None`代替。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">虽然Tornado的自动转义为避免XSS漏洞有帮助，但它并不是在所有情况下都有效。例如在JS或CSS表达式的某些地方，可能需要额外的转义。此外，必须小心地使用HTML双引号`&quot;`和`xhtml_escape`，可能包含不受信任的内容，或者必须为属性使用单独地转义函数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### UI模块</span><br><span class="line"></span><br><span class="line">UI modules</span><br><span class="line"></span><br><span class="line">Tornado支持UI模块，可以很容易地在你的应用中支持标准的、可重用的UI组件。UI模块都喜欢特殊的函数调用来渲染网页和组件，它们可以包装自己的CSS和JS。</span><br><span class="line"></span><br><span class="line">例如，如果要实现一个博客，你想拥有的博客条目同时出现在博客主页和每个博客页面上，你可以编写一个`Entry`模块在两个页面上渲染它们。首先，为你的UI模块创建一个Python模块:</span><br><span class="line"></span><br><span class="line">```py</span><br><span class="line"># uimodules.py</span><br><span class="line">class Entry(tonado.web.UIModule):</span><br><span class="line">    def render(self, entry, show_commnets=False):</span><br><span class="line">        return self.render_string(&quot;module-entry.html, entry=entry, show_comments=show_comments&quot;)</span><br></pre></td></tr></table></figure></p><p>在应用中设置<code>ui_modules</code>告诉Tornado使用<code>uimodules.py</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> uimodules</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        entries = self.db.query(<span class="string">"SELECT * FROM entries ORDER BY date DESC"</span>)</span><br><span class="line">        self.render(<span class="string">"home.html"</span>, entries=entries)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntryHander</span><span class="params">(tornado.web.ReqestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, entry_id)</span>:</span></span><br><span class="line">        entry = self.db.get(<span class="string">"SELECT * FROM entries WHERE id = %s, entry_id"</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> entry: <span class="keyword">raise</span> tornado.web.HTTPError(<span class="number">404</span>)</span><br><span class="line">        self.render(<span class="string">"entry.html"</span>, entry=entry)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">settings = &#123;</span><br><span class="line">    <span class="string">"ui_modules"</span>: uimodules,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (<span class="string">r"/"</span>, HomeHandler),</span><br><span class="line">    (<span class="string">r"/entry/([0-9])"</span>, EntryHandler),</span><br><span class="line">], **settings)</span><br></pre></td></tr></table></figure><p>在模板内，你可以使用<figure class="highlight plain"><figcaption><span>module %&#125;```调用模块，例如在`home.html`中调用`Entry`模块:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```jinja2</span><br><span class="line">&#123;% for entry in entries%&#125;</span><br><span class="line">&#123;% module Entry(entry) %&#125;</span><br><span class="line">&#123;% end %&#125;</span><br></pre></td></tr></table></figure></p><p><code>entry.html</code>中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% module Entry(entry, show_comments=True) %&#125;</span><br></pre></td></tr></table></figure><p>模块可以通过重写<code>embedded_css</code>, <code>embedded_javascript</code>, <code>javascript_files</code>或<code>css_files</code>方法来包含自定义的CSS和JS函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span><span class="params">(tornado.web.UIModule)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">embedded_css</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">".entry &#123; margin-bottom: 1em; &#125;"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self, entry, show_comments=False)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.render_string(<span class="string">"module-entry"</span>, show_comments=show_comments)</span><br></pre></td></tr></table></figure><p>模块CSS和JS将包含一次，不管一个页面中这个模块使用了多少次。CSS总是包含在页面的<code>&lt;head&gt;</code>，JS总是包含在<code>&lt;/body&gt;</code>标记之前在页面的页面结束标记。</p><p>当不需要附加的Python代码，模板文件本身可以用作一个模块。例如，前面的栗子可以改写在<code>module-entry.html</code>模块:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; set_resources(embedded_css=&quot;.entry &#123; margin-bottom: 1em; &#125;&quot;) &#125;&#125;</span><br><span class="line">&lt;!-- more template html... --&gt;</span><br></pre></td></tr></table></figure><p>经修订的模板模块将与下栗被调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% module Template(&quot;module-entry.html&quot;, show_comments=True) %&#125;</span><br></pre></td></tr></table></figure><p>该<code>set_resources</code>功能尽在通过<br><figure class="highlight plain"><figcaption><span>module Template(...) %&#125;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">调用模板。不同于</span><br><span class="line">```&#123;% include %&#125;```，</span><br><span class="line">模板模块具有从它们的包含模板的独特命名空间——它们只能看到全局模板命名空间和自己的关键字参数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 认证和安全</span><br><span class="line"></span><br><span class="line">Authentication and security</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Cookie和secure cookies</span><br><span class="line"></span><br><span class="line">可以使用`set_cookie`方法在用户浏览器中设置cookie:</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">class MainHandler(tornado.web.ReqestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        if not self.get_cookie(&quot;mycookie&quot;):</span><br><span class="line">            self.set_cookie(&quot;mycookie&quot;, &quot;myvalue&quot;)</span><br><span class="line">            self.write(&quot;Your cookie was not set yet!&quot;)</span><br><span class="line">        else:</span><br><span class="line">            self.write(&quot;Your cookie was set!&quot;)</span><br></pre></td></tr></table></figure></p><p>cookie是不安全的，可以很容易地被客户修改。如果你需要设置cookie，请确定当前登录的用户，你需要签属(signed)你的cookie来防止伪造。Tornado支持使用<code>set_secure_cookie</code>和<code>get_secure_cookie</code>方法来签属(sign)cookie。要使用这些方法，你需要在创建应用时指定一个名为<code>cookie_secret</code>的密钥键。你可以在应用中设置关键字参数来传递给应用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">application = tornado.web.Application([</span><br><span class="line">    (<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">], cookie_secret=<span class="string">"__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__"</span>)</span><br></pre></td></tr></table></figure><p>签属的cookie含有时间戳和HMAC签名的cookie编码值。如果cookie是旧的，或者签名不匹配，<code>get_secure_cookie</code>将会返回<code>None</code>就像没有设置cookie那样。上面栗子的安全版本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.get_secure_cookie(<span class="string">"mycookie"</span>):</span><br><span class="line">            self.set_secure_cookie(<span class="string">"mycookie"</span>, <span class="string">"myvalue"</span>)</span><br><span class="line">            self.write(<span class="string">"Your cookie was not set yet!"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.write(<span class="string">"Your cookie was set!"</span>)</span><br></pre></td></tr></table></figure><p>Tornado的secure cookie保证完整性，但不保密。也就是说，cookie不能被修改，但可以被用户看到。<code>cookie_secret</code>是一个对称密钥并且必须保密——得到这个值的人都可以制作自己的签名的cookie。</p><p>默认情况下，Tornado的cookie在30天后过期。可对<code>set_secure_cookie</code>使用<code>expires_days</code>参数和<code>max_age_days</code>来修改。</p><p>Tornado同样支持多个签名密钥来启用签名轮询。<code>cookie_secret</code>必须与整数密钥版本作为关键字和相应的secret作为字典的值。将当前使用的签名密钥必须在应用中设置为<code>key_version</code>，但在字典的所有其它键都允许cookie签名认证，如果设置在cookie中的是正确的密钥版本。要更新cookie，可通过查询<code>get_secure_cookie_key_version</code>获取当前的签名密钥版本。</p><p><br><br><br></p><h3 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h3><p>User authentication</p><p>当前已认证的用户在每个request handler中可使用<code>self.current_user</code>，在每个模板中为<code>current_user</code>。默认情况下，<code>current_user</code>为<code>None</code>。</p><p>要在应用中执行用户身份认证，需要在request handler中重写<code>get_current_user</code>以基于cookie的值确定当前用户。下面是一个让用户登录到应用，简单地指定一个昵称，然后将其保存到cookie中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_current_user</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.get_secure_cookie(<span class="string">"user"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(BaseHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.current_user:</span><br><span class="line">            self.redirect(<span class="string">"/login"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        name = tornado.escape.xhtml_escape(self.current_user)</span><br><span class="line">        self.write(<span class="string">"Hello, "</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginHandler</span><span class="params">(BaseHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">'&lt;html&gt;&lt;body&gt;&lt;form action="/login" method="post"&gt;'</span></span><br><span class="line">            <span class="string">'Name: &lt;input type="text" name="name"&gt;'</span></span><br><span class="line">            <span class="string">'&lt;input type="submit" value="Sign in"&gt;'</span></span><br><span class="line">            <span class="string">'&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.set_secure_cookie(<span class="string">"user"</span>, self.get_argument(<span class="string">"name"</span>))</span><br><span class="line">        self.redirect(<span class="string">"/"</span>)</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">    (<span class="string">r"/login"</span>, LoginHandler),</span><br><span class="line">], cookie_secret=<span class="string">"__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__"</span>)</span><br></pre></td></tr></table></figure><p>你可以要求用户在使用<code>tornado.web.authenticated</code> Python装饰器处登录。如果请求的方法带有此装饰器，并且用户没有登录，则他们将被重定向到<code>login_url</code>或其它设置。重写上面的栗子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(BaseHandler)</span>:</span></span><br><span class="line"><span class="meta">    @tornado.web.authenticated</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        name = tornado.escaple.xhtml_escape(self.current_user)</span><br><span class="line">        self.write(<span class="string">"Hello, "</span> + name)</span><br><span class="line"></span><br><span class="line">settings = &#123;</span><br><span class="line">    <span class="string">"cookie_secret"</span>: <span class="string">"__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__"</span>,</span><br><span class="line">    <span class="string">"login_url"</span>:<span class="string">"/login"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">    (<span class="string">r"/login"</span>, LoginHandler),</span><br><span class="line">], **settings)</span><br></pre></td></tr></table></figure><p>如果你使用<code>authenticate</code>装饰器装饰一个<code>post()</code>方法，并且用户没有登录，则Server会返回403响应。<code>@authenticated</code>装饰器简单来说就是<code>if not self.current_user: self.redirect()</code>的快捷键，并且可能不适用于非基于浏览器的登录方案。</p><p><br><br><br></p><h3 id="第三方认证"><a href="#第三方认证" class="headerlink" title="第三方认证"></a>第三方认证</h3><p>Third party authentication</p><p><code>tornado.auth</code>模块实现了许多受欢迎的网站上提供的认证(authentication)和授权(authorization)协议，包括Google, FaceBook, Twitter…</p><p>下面是一个使用谷歌认证的示例，存储Google credential到cookie以便后续访问使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoogleOAuth2LoginHandler</span><span class="params">(tornado.web.RequestHandler, tornado.auth.GoogleOAuth2Mixin)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.get_argument(<span class="string">'code'</span>, <span class="keyword">False</span>):</span><br><span class="line">            user = <span class="keyword">await</span> self.get_authenticated_user(</span><br><span class="line">                redirect_uri=<span class="string">"http://your.site.com/auth/google"</span>,</span><br><span class="line">                code=self.get_argument(<span class="string">'code'</span>))</span><br><span class="line">            <span class="comment"># Save the user with e.g. set_secure_cookie</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">await</span> self.authorize_redirect(</span><br><span class="line">            redirect_uri=<span class="string">'http://your.site.com/auth/google'</span>,</span><br><span class="line">            client_id=self.setting[<span class="string">'google_oauth'</span>][<span class="string">'key'</span>],</span><br><span class="line">            scope=[<span class="string">'profile'</span>, <span class="string">'email'</span>],</span><br><span class="line">            response_type=<span class="string">'code'</span>,</span><br><span class="line">            extra_params=&#123;<span class="string">'approval_prompt'</span>: <span class="string">'auto'</span>&#125;)</span><br></pre></td></tr></table></figure><p>更多详细内容，请参考<code>tornado.auth</code>文档。</p><p><br><br><br></p><h3 id="跨站请求伪造保护"><a href="#跨站请求伪造保护" class="headerlink" title="跨站请求伪造保护"></a>跨站请求伪造保护</h3><p>Cross-site request forgery protection</p><p>跨站请求伪造(Cross-site request forgery, XSRF)，是Web应用的一个常见的问题。</p><p>防止XSRF普遍接受的解决方案是每个用户的cookie使用不可预测的值，此值包含网站上每个表单提交的额外参数。如果表单提交的cookie和值不匹配，则请求可能是伪造的。</p><p>Tornado内置了XSRF保护。要在你的站点中包含它，启用应用<code>scrf_cookies</code>设置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">settings = &#123;</span><br><span class="line">    <span class="string">"cookie_secret"</span>: <span class="string">"__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__"</span>,</span><br><span class="line">    <span class="string">"login_url"</span>: <span class="string">"/login"</span>,</span><br><span class="line">    <span class="string">"xsrf_cookies"</span>: <span class="keyword">True</span></span><br><span class="line">&#125;</span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">    (<span class="string">r"/login"</span>, LoginHandler),</span><br><span class="line">], **settings)</span><br></pre></td></tr></table></figure><p>如果设置了<code>xsrf_cookies</code>，Tornado Web Application将为所有用户设置<code>_xsrf</code> cookie，并拒绝没有包含正确的<code>_xsrf</code>值的所有<code>POST</code>, <code>PUT</code>, <code>DELETE</code>请求。如果你打开了此设置，你需要一切形式的<code>POST</code>提交中包含此字段。你可以使用特殊的UIModule <code>vsrf_form_html()</code>，在所有模板中可用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/new_message&quot; method=&quot;post&quot;&gt;</span><br><span class="line">  &#123;% module xsrf_form_html() %&#125;</span><br><span class="line">  &lt;input type=&quot;text&quot; name=&quot;message&quot;/&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; value=&quot;Post&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>如果你提交AJAX <code>POST</code>请求，你还需要构造JS来包括每个请求的<code>_xsfr</code>值。所有包含<code>_xsrf</code>请求AJAX POST的JQuery函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getCookie(name) &#123;</span><br><span class="line">    var r = document.cookie.match(&quot;\\b&quot; + name + &quot;=([^;]*)\\b&quot;);</span><br><span class="line">    return r ? r[1] : undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jQuery.postJSON = function(url, args, callback) &#123;</span><br><span class="line">    args._xsrf = getCookie(&quot;_xsrf&quot;);</span><br><span class="line">    $.ajax(&#123;url: url, data: $.param(args), dataType: &quot;text&quot;, type: &quot;POST&quot;,</span><br><span class="line">        success: function(response) &#123;</span><br><span class="line">        callback(eval(&quot;(&quot; + response + &quot;)&quot;));</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于<code>PUT</code>和<code>DELETE</code>请求，XSRF token可能会通过HTTP <code>X-XSRFToken</code> Header进行传递。使用<code>xsrf_form_html</code>时，XSRF cookie被正常设置，但是在不使用任何形式的纯JS应用中，可能需要手动访问<code>self.xsrf_token</code>。</p><p>如果你需要在每个handler中自定义XSRF行为，你可以重写<code>RequestHandler.check_xsrf_cookie()</code>。例如，如果你有一个不使用cookie的API，你可能希望通过使<code>check_xsrf_cookie</code>什么也不做来禁用XSRF保护。然而，如果你支持基于cookie和非基于cookie的认证，只要求当前请求使用cookie认证XSRF保护是重要的。</p><p><br><br><br></p><h3 id="DNS重新绑定"><a href="#DNS重新绑定" class="headerlink" title="DNS重新绑定"></a>DNS重新绑定</h3><p>DNS Rebinding</p><p>DNS重新绑定是一种攻击，可以绕过同源策略，并允许外部站点访问内部网络的资源。使用TLS的应用不容易受到这种攻击。没有使用TLS的应用依赖网络层的访问控制，应警惕通过验证的HTTP Header的<code>Host</code>被DNS重新绑定。This means passing a restrictive hostname pattern to either a <code>HostMatches</code> router or the first argument of <code>Application.add_handlers</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BAD: uses a default host pattern of r'.*'</span></span><br><span class="line">app = Application([(<span class="string">'/foo'</span>, FooHandler)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># GOOD: only matches localhost or its ip address.</span></span><br><span class="line">app = Application()</span><br><span class="line">app.add_handlers(<span class="string">r'(localhost|127\.0\.0\.1)'</span>,</span><br><span class="line">                 [(<span class="string">'/foo'</span>, FooHandler)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># GOOD: same as previous example using tornado.routing.</span></span><br><span class="line">app = Application([</span><br><span class="line">    (HostMatches(<span class="string">r'(localhost|127\.0\.0\.1)'</span>),</span><br><span class="line">            [(<span class="string">'/foo'</span>, FooHandler)]),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p>此外，应用的<code>default_host</code>参数，和<code>DefaultHostMatches</code>路由器不能在应用中使用，这可能受到DNS重新绑定，因为它有一个通配符主模式类似的效果。</p><p><br><br><br><br><br></p><h2 id="运行和部署"><a href="#运行和部署" class="headerlink" title="运行和部署"></a>运行和部署</h2><p>Running and deploying</p><p>自从Tornado提供了自己的HTTPServer，运行和部署它便和其它Python Web框架有点不同。不同于配置WSGI，你只需要写一个<code>main()</code>函数来启动Server:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(<span class="number">8888</span>)</span><br><span class="line">    IOLoop.current().start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>请注意，这可能需要增加每个进程可打开的文件数(open files)，可能修改<code>ulimit</code>限制。</p><p><br><br><br></p><h3 id="进程和端口"><a href="#进程和端口" class="headerlink" title="进程和端口"></a>进程和端口</h3><p>Processes and ports</p><p>由于Python的GIL(Global Interpreter Lock)，有必要运行多个Python进程，以充分利用多CPU机器。通常，最好为每个CPU运行一个进程。</p><p>Tornado包含了一个内置的多进程模式，一次可启动多个进程。这需要稍微修改以下启动方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    app = make_app()</span><br><span class="line">    server = tornado.httpserver.HTTPServer(app)</span><br><span class="line">    server.bind(<span class="number">8888</span>)</span><br><span class="line">    server.start(<span class="number">0</span>)  <span class="comment"># forks one process per cpu</span></span><br><span class="line">    IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>这是启动多个进程，并让它们使用相同的端口最简单的方法，虽然它有一定的局限性。首先，每个子进程都会有自己的IOLoop，因此在fork前没有事物触及IOLoop示例是很重要的。第二，在这个模型中很难做到零停机更新(zero-downtime updates)。最后，由于所有的进程共享同一端口更难以单独监控。</p><p>对于更复杂的部署，建议单独启动进程，并监听不同的端口。<code>supervisord</code>是一个好办法。当每个进程使用了不同的端口，通常需要一个外部的负载均衡器(如HAProxy, Nginx)以单独的访问地址提供给访问者。</p><p><br><br><br></p><h3 id="运行在负载均衡器后"><a href="#运行在负载均衡器后" class="headerlink" title="运行在负载均衡器后"></a>运行在负载均衡器后</h3><p>Running behind a load balancer</p><p>当运行在如Nginx这样的负载均衡器之后，建议传递<code>xheaders=True</code>给HTTPServer构造器。这将告诉Tornado使用<code>X-Real-IP</code>用户Header，来获取用户IP地址，而不是负载均衡器的IP地址。</p><p>一个栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">user nginx;</span><br><span class="line">worker_processes 1;</span><br><span class="line"></span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">    use epoll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    # Enumerate all the Tornado servers here</span><br><span class="line">    upstream frontends &#123;</span><br><span class="line">        server 127.0.0.1:8000;</span><br><span class="line">        server 127.0.0.1:8001;</span><br><span class="line">        server 127.0.0.1:8002;</span><br><span class="line">        server 127.0.0.1:8003;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/mime.types;</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line">    access_log /var/log/nginx/access.log;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout 65;</span><br><span class="line">    proxy_read_timeout 200;</span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1000;</span><br><span class="line">    gzip_proxied any;</span><br><span class="line">    gzip_types text/plain text/html text/css text/xml</span><br><span class="line">               application/x-javascript application/xml</span><br><span class="line">               application/atom+xml text/javascript;</span><br><span class="line"></span><br><span class="line">    # Only retry if there was a communication error, not a timeout</span><br><span class="line">    # on the Tornado server (to avoid propagating &quot;queries of death&quot;</span><br><span class="line">    # to all frontends)</span><br><span class="line">    proxy_next_upstream error;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        # Allow file uploads</span><br><span class="line">        client_max_body_size 50M;</span><br><span class="line"></span><br><span class="line">        location ^~ /static/ &#123;</span><br><span class="line">            root /var/www;</span><br><span class="line">            if ($query_string) &#123;</span><br><span class="line">                expires max;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        location = /favicon.ico &#123;</span><br><span class="line">            rewrite (.*) /static/favicon.ico;</span><br><span class="line">        &#125;</span><br><span class="line">        location = /robots.txt &#123;</span><br><span class="line">            rewrite (.*) /static/robots.txt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass_header Server;</span><br><span class="line">            proxy_set_header Host $http_host;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Scheme $scheme;</span><br><span class="line">            proxy_pass http://frontends;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="静态文件和侵略性的文件缓存"><a href="#静态文件和侵略性的文件缓存" class="headerlink" title="静态文件和侵略性的文件缓存"></a>静态文件和侵略性的文件缓存</h3><p>Static files and aggressive file caching</p><p>你可以通过在应用中指定<code>static_path</code>来设置Tornaodo提供静态文件:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">settings = &#123;</span><br><span class="line">    <span class="string">"static_path"</span>: os.path.join(os.path.dirname(__file__), <span class="string">"static"</span>),</span><br><span class="line">    <span class="string">"cookie_secret"</span>: <span class="string">"__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__"</span>,</span><br><span class="line">    <span class="string">"login_url"</span>: <span class="string">"/login"</span>,</span><br><span class="line">    <span class="string">"xsrf_cookies"</span>: <span class="keyword">True</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">    (<span class="string">r"/login"</span>, LoginHandler),</span><br><span class="line">    (<span class="string">r"/(apple-touch-icon\.png)"</span>, tornado.web.StaticFileHandler,</span><br><span class="line">     dict(path=settings[<span class="string">'static_path'</span>])),</span><br><span class="line">], **settings)</span><br></pre></td></tr></table></figure><p>此设置会自动设置以<code>/static/</code>的所有请求到静态目录，如<code>http://localhost:8888/static/foo.png</code>将从指定的静态目录提供静态文件。同样还有<code>/robots.txt</code>和<code>/favicon.ico</code>，即便它们并未以<code>/static/</code>为前缀。</p><p>在上面的设置，我们已明确的配置Tornado从<code>StaticFileHandler</code>提供<code>apple-touch-icon.png</code>。</p><p>要提高性能，通常是浏览器缓存静态资源，因此浏览器将不会发送不必要的<code>If-Modified-Since</code>或<code>Etag</code>请求，这可能会阻止页面的渲染。Tornado支持这一开箱即用的静态内容版本。</p><p>要使用此功能，在你的模板中使用<code>static_url</code>方法，而不是在你的HTML中直接输入静态文件:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>FriendFeed - &#123;&#123; _("Home") &#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&#123;&#123; static_url("</span><span class="attr">images</span>/<span class="attr">logo.png</span>") &#125;&#125;"/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>static_url()</code>函数会将相对路径转换为如<code>/static/images/logo.png?v=aae54</code>这样的URI。<code>v</code>参数是<code>logo.png</code>的哈希内容，它的存在使得Tornado Server发送cache header到用户浏览器，这将使浏览器无限期缓存内容。</p><p>由于<code>v</code>参数使基于文件的内容，如果你更新文件并重启Server，它将发送一个新的<code>v</code>值，因此用户浏览器会自动获取新的文件。如果文件的内容没有改变，浏览器将继续使用本地缓存的副本而没有检查Server上的更新，显著提供渲染性能。</p><p>在生产环境，你可能希望从像Nginx这样更优化的静态文件服务器提供静态文件。你可以配置几乎所有的Web Server识别由<code>static_url</code>使用的标签，并设置相应的cache header。</p><p>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /static/ &#123;</span><br><span class="line">    root /var/friendfeed/static;</span><br><span class="line">    if ($query_string) &#123;</span><br><span class="line">        expires max;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Debug模式和自动重载"><a href="#Debug模式和自动重载" class="headerlink" title="Debug模式和自动重载"></a>Debug模式和自动重载</h3><p>Debug mode and automatic reloading</p><p>如果将<code>debug=True</code>传递给<code>Application</code>构造器，应用将运行在debug/development模式下。在此模式下，一些便于开发调试的功能将被启用:</p><ul><li><code>autoreload=True</code>：应用会监视更改的源文件并在发生变化时自动重载。这样减少了在开发过程中手动重启服务。然后，某些错误可能导致无法启动。</li><li><code>compiled_template_cache=False</code>：模板不会被缓存。</li><li><code>static_hash_cache=False</code>：静态文件哈希值(由<code>static_url</code>函数使用)将不会被缓存。</li><li><code>serve_traceback=True</code>：当RequestHandler中的异常没有被捕获，将会生成一个包含stack trace的错误页面。</li></ul><p>自动重载模式不兼容<code>HTTPserver</code>的多进程模式。如果你正在使用自动重载模式，你不要给<code>HTTPServer.start</code>一个或多于一个参数(或调用<code>tornado.process.fork_processes</code>)。</p><p>调式模式的自动重载功能是可用作为<code>tornado.autoreload</code>独立(standalone)模块。这两个可以组合使用，以提供对语法错误的额外稳健：在应用中设置<code>autoreload=True</code>来在运行时检测改变，并使用<code>python -m tornado.autoreload myserver.py</code>启动来在启动时捕获任意语法错误或其它错误。</p><p>重载将失去任何Python解释器命令行参数(如<code>-u</code>)，因为它使用<code>sys.executable</code>和<code>sys.argv</code>来重新执行Python。此外，修改这些变量将导致重载行为不正确。</p><p><br><br><br></p><h3 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h3><p>Tornado通常是为了独立运行，而不用WSGI容器。然而，在一些环境中（如Google App Engine），只允许WSGI，应用程序无法运行自己的Server。在这种情况下，Tornado支持操作的限制模式，不支持异步操作，但允许在只有WSGI环境的Tornado功能的子集。未在WSIG模式允许的功能包括协程、<code>@asynchronous</code>装饰器，<code>AsyncHTTPclient</code>、<code>auth</code>模块和WebSockets。</p><p>你可以使用<code>tornado.wsgi.WSGIAdapter</code>将一个Tornado Application转换为WSGI application。</p><p>栗子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.wsgi</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">'Hello, world'</span>)</span><br><span class="line"></span><br><span class="line">tornado_app = tornado.web.Application([</span><br><span class="line">    (<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">application = tornado.wsgi.WSGIAdapter(tornado_app)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tornado: v5.1&lt;/li&gt;
&lt;li&gt;Python: v3.6&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docs: &lt;a href=&quot;https://www.tornadoweb.org/en/branch5.1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.tornadoweb.org/en/branch5.1/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Python" scheme="https://zhang21.github.io/categories/Python/"/>
    
    
      <category term="DevOps" scheme="https://zhang21.github.io/tags/DevOps/"/>
    
      <category term="Python" scheme="https://zhang21.github.io/tags/Python/"/>
    
      <category term="Web" scheme="https://zhang21.github.io/tags/Web/"/>
    
      <category term="Tornado" scheme="https://zhang21.github.io/tags/Tornado/"/>
    
  </entry>
  
  <entry>
    <title>HTML CSS</title>
    <link href="https://zhang21.github.io/2019/10/11/HTMLCSS/"/>
    <id>https://zhang21.github.io/2019/10/11/HTMLCSS/</id>
    <published>2019-10-11T03:59:21.000Z</published>
    <updated>2019-11-17T02:42:56.756Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>《Head First HTML and CSS》</li><li>w3cSchool: <a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">https://www.w3school.com.cn/</a></li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="认识HTML"><a href="#认识HTML" class="headerlink" title="认识HTML"></a>认识HTML</h1><p>HTML(Hyper Text Markup Language)超文本标记语言，创建结构。<br>HTML会告诉浏览器文档的结构，标题放在哪、段落放在哪、哪些文本需要强调…</p><p>CSS(Cascading Style Sheets)层叠样式表，创建样式。</p><p>与试图使用一种语言兼顾这两方面的工作相比，实际上学习两种语言让它们各司其职反而更容易。</p><ul><li>首部(<code>head</code>): 包含了web页面的有关信息</li><li>页面元素(<code>body</code>): 包含web页面的所有内容和结构</li><li>元素(element): <code>开始标记+内容+结束标记</code>（如<code>element=&lt;&gt;+content+&lt;/&gt;</code>），某些例外</li><li>属性(attribute): 如<code>type=&quot;text/css&quot;</code>，能提供元素的一些额外信息</li><li><code>&lt;Style&gt;</code>元素放在HTML首部</li></ul><p><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">'en'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Starbuzz Coffee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        body &#123;</span></span><br><span class="line"><span class="undefined">            background-color:skyblue;</span></span><br><span class="line"><span class="undefined">            margin-left: 20%;</span></span><br><span class="line"><span class="undefined">            margin-right: 20%;</span></span><br><span class="line"><span class="undefined">            border: 2px dotted black;</span></span><br><span class="line"><span class="undefined">            padding: 10px 10px 10px 10px;</span></span><br><span class="line"><span class="undefined">            font-family: sans-serif;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Starbuzz Coffee Beverages<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>House Blend<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="深入了解超文本"><a href="#深入了解超文本" class="headerlink" title="深入了解超文本"></a>深入了解超文本</h1><p>想从一个页面链接到另一个页面，使用<code>&lt;a&gt;</code>元素。<br><code>&lt;a&gt;</code>元素的<code>href</code>属性制订了链接的目标文件。</p><p>文字和图像都可以用作链接的标签。<br>单击一个链接时，浏览器会加载<code>href</code>属性中指定的Web页面。</p><p>可以链接到相同文件夹中的文件，也可以链接到其它文件夹的文件。</p><p>请注意相对路径和绝对路径。</p><p>为网站选择的文件名和文件夹不要有空格。</p><p><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        body &#123;</span></span><br><span class="line"><span class="undefined">            margin-left:20%;</span></span><br><span class="line"><span class="undefined">            margin-right:20;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"top"</span>&gt;</span>Welcome<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/aaa.jpg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"aaa/aaa.html"</span> <span class="attr">title</span>=<span class="string">"aaa"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span> <span class="tag">&lt;<span class="name">h2</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> abcd <span class="tag">&lt;<span class="name">em</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">em</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'#top'</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>返回TOP<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="构建模块"><a href="#构建模块" class="headerlink" title="构建模块"></a>构建模块</h1><p>开始输入内容之前要规划好Web页面的结构。首先画出一个草图，然后创建一个略图，最后再写出HTML。<br>规划页面时，首先设计大的块元素，然后用内联(inline)元素完善。</p><p>记住，要尽可能使用元素来告诉浏览器你的内容的含义。<br>一定要使用与内容含义最接近的元素。例如，如果需要一个列表，就不要使用段落元素。</p><p><code>&lt;p&gt;, &lt;blockquote&gt;, &lt;ol&gt;, &lt;ul&gt;, &lt;li&gt;</code>都是块元素。它们单独显示，与内容前后分别有一个换行(默认的)。</p><p><code>&lt;q&gt;, &lt;em&gt;</code>是内联元素。这些元素中的内容与其包含元素的其余内容放在一起。</p><p>需要插入自己的换行时，可以使用<code>&lt;br&gt;</code>元素，它是一个<code>void</code>元素。<br><code>void</code>元素没有内容，只有一个标记组成。</p><p>空元素没有内容。不过它有开始和结束标记。</p><p>嵌套元素是指完全包含在另一个元素中的元素。如果元素能正确地嵌套，所有标记都能正确匹配。</p><p>要结合两个元素建立一个HTML列表，可以使用<code>&lt;ol&gt;</code>和<code>&lt;li&gt;</code>，也可以使用<code>&lt;ul&gt;</code>和<code>&lt;li&gt;</code>。</p><p>要对HTML内容中的特殊字符使用字符实体(character entity)，如<code>&lt;</code>符号使用<code>&amp;lt</code>。</p><p><br></p><p><strong>元素大杂烩(elements)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt;        # 建立链接</span><br><span class="line">&lt;p&gt;        # 段落</span><br><span class="line">&lt;q&gt;        # 短引用</span><br><span class="line">&lt;blockquote&gt; # 长引用</span><br><span class="line">&lt;code&gt;     # 显示代码</span><br><span class="line">&lt;em&gt;       # 斜体</span><br><span class="line">&lt;time&gt;     # 告诉浏览器此内容是时间</span><br><span class="line">&lt;ul&gt;       # 无序列表</span><br><span class="line">&lt;ol&gt;       # 有序列表</span><br><span class="line">&lt;li&gt;       # 列表</span><br><span class="line">&lt;strong&gt;   # 强调文本</span><br><span class="line">&lt;pre&gt;      # 浏览器按照你输入的格式显示文本</span><br><span class="line">&lt;br&gt;       # 换行</span><br><span class="line">&lt;img&gt;      # 图像</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>333<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        body &#123;</span></span><br><span class="line"><span class="undefined">            margin-left: 20%;</span></span><br><span class="line"><span class="undefined">            margin-right: 20%;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        q, blockquote, ol, ul &#123;</span></span><br><span class="line"><span class="undefined">            font-size: x-large;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>333<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>333<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>333<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../images/333.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        333333333333:</span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>33<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        3333</span><br><span class="line">        <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">            3<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            33<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            333<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line">        333</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>333<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        333:</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>33<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        333</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="连接起来"><a href="#连接起来" class="headerlink" title="连接起来"></a>连接起来</h1><p>要把网站发布到Web上，通常最好的方法就是找一家公司来托管你的Web页面。<br>域名(domain)是一个唯一的名字，如<code>aaa.com</code>，用来唯一标识网站。<br>托管公司可能会为你的域创建一个或多个Web服务器，通常为<code>www</code>。</p><p>URL是统一资源定位符或Web地址，可用来标识Web上的任何资源。<br>定性的URL是由一个协议、一个网站名和资源的一个绝对路径组成。</p><p>HTTP是一个请求和响应协议，用来在Web服务器和浏览器之间传送Web页面。<br>浏览器使用<code>file:///</code>协议从你的计算机读取页面。</p><p><code>index.html</code>和<code>default.html</code>都是默认页面，如果指定一个目录而没有指定文件名，则Web服务器会查找一个默认页面返回到浏览器。</p><p><code>&lt;a&gt;</code>元素的<code>href</code>属性中可以使用相对路径或URL来链接其它web页面。对于你的网站中的其它页面，最好使用相对路径，对外部链接才使用URL。<br>可以用<code>id</code>属性在页面中创建一个目标（如<code>&lt;h1 id=&quot;top&quot;&gt;</code>），使用<code>#</code>后面加一个目标<code>id</code>（如<code>&lt;a href=&quot;#top&quot;&gt;</code>），可以链接到页面中的那个位置。<br>为了便于访问，可以在<code>&lt;a&gt;</code>元素中使用<code>title</code>属性提供链接的一个描述。<br>使用<code>target</code>属性在另一个窗口中打开链接。对于不同设备和浏览器，<code>target</code>属性可能会有问题。</p><p><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>444<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        body &#123;</span></span><br><span class="line"><span class="undefined">            margin-left: 20%;</span></span><br><span class="line"><span class="undefined">            margin-right: 20%;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"top"</span>&gt;</span>444<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/444.jpg"</span> <span class="attr">width</span>=<span class="string">"800"</span> <span class="attr">height</span>=<span class="string">"400"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"about/444.html"</span> <span class="attr">title</span>=<span class="string">"444"</span> <span class="attr">taget</span>=<span class="string">"_blank"</span>&gt;</span> <span class="tag">&lt;<span class="name">h2</span>&gt;</span>4444<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        4 <span class="tag">&lt;<span class="name">em</span>&gt;</span>44<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">        444</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#top"</span>&gt;</span> <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Top<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="为页面添加图像"><a href="#为页面添加图像" class="headerlink" title="为页面添加图像"></a>为页面添加图像</h1><p>使用<code>&lt;img&gt;</code>元素在web页面中添加图像。<code>&lt;img&gt;</code>元素是一个内联元素，这说明浏览器不会在图像前后插入一个换行。<br>浏览器对<code>&lt;img&gt;</code>元素的处理与其它HTML元素稍有不同。读取HTML页面之后，浏览器会从Web服务器获取各个图像并显示。<br>如果web页面上有多个大图像，则可以通过创建图像的缩略图使web页面更可用，下载也更快。缩略图是一些小图像（大图像的缩小版本），用户单击这些缩略图时可以看到原来的大图像。</p><p>要利用<code>src</code>属性指定图像文件的位置。可以在<code>src</code>属性中使用相对路径包含自己网站中的图像，或者可使用URL包含其它网站的图像。</p><p><code>alt</code>属性是对图像的一个有意义的描述，在一些浏览器中，如果无法找到图像，就会显示这个描述。</p><p>对于浏览器来说，太大的图像会使web页面很难用，而且下载和显示都很慢。<br>图像可以用作指向其它web页面的链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JPEG、PNG和GIF是web浏览器广泛支持的3中图像格式</span><br><span class="line">JPEG格式最适合保存照片和其他复杂图像</span><br><span class="line">GIF或PNG格式最适合保存Logo和其他包含单色、线条或文本的简单图形</span><br><span class="line">JPEG图像可以按不同的质量(quality）压缩，所以可以很好地权衡图像质量和文件大小，来满足你的需要</span><br><span class="line">GIF和PNG图像格式允许建立一个有透明背景的图像。如果把一个有透明背景的图像放在一个web页面中，图像后面的东西（如页面背景色）就是透过图像的透明部分显示出来</span><br><span class="line">GIF和PNG是无损格式，这说明相比JPEG文件，这些格式的文件往往更大</span><br><span class="line">PNG可以提供比GIF更好的透明度控制，而且不像GIF只支持256中颜色，PNG可以支持更多颜色)</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>555<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        body &#123;</span></span><br><span class="line"><span class="undefined">            background-color: rgb(228, 243, 191);</span></span><br><span class="line"><span class="undefined">            margin-left: 10%;</span></span><br><span class="line"><span class="undefined">            margin-right: 10%;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"logo/555.png"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>555<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">        5</span><br><span class="line">        55</span><br><span class="line">        555</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>55<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        5</span><br><span class="line">        55</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"html/5.html"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"5/5.jpg"</span> <span class="attr">alt</span>=<span class="string">"555"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="CSS入门"><a href="#CSS入门" class="headerlink" title="CSS入门"></a>CSS入门</h1><p>CSS包含一些简单语句，成为规则。每个规则为选择的一些HTML元素提供样式。</p><p>定性的规则包括一个选择器，以及一个或多个属性和值。<br>选择器指定规则将应用到哪些元素。<br>每个属性声明以一个分号结束。<br>规则中的所有属性和值都放在<code>{}</code>大括号之间。</p><p>可以使用元素作为选择器，来选择任意元素。<br>通过用逗号分隔元素名，可以一次选择多个元素。</p><p>要在HTML包含一个样式，最容易的办法就是使用<code>&lt;style&gt;</code>标记。<br>对于HTML以及相当复杂的网站，可能要链接到一个外部样式表。<code>&lt;link&gt;</code>元素用于包含一个外部样式表。</p><p>很多属性都能继承。例如，如果为<code>&lt;body&gt;</code>元素设置了一个可继承的属性，那么<code>&lt;body&gt;</code>的所有子元素都会继承这个属性。<br>通过为你想改变的元素创建一个更特定的规则，能覆盖该元素继承的属性。</p><p>可以使用<code>class</code>属性将元素增加到一个类。<br>使用<code>.classname</code>可以选择属性这个类的多有元素。<br>通过在<code>class</code>属性中放入多个类名，可以指定一个元素属于多个类，类名之间用空格分隔。</p><p>通过在元素名和类名之间加一个<code>.</code>，可以选择该类中的一个特定元素。</p><p><br></p><p><strong>属性大杂烩</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">color: 字体颜色</span><br><span class="line">font-weight: 文本粗细</span><br><span class="line">font-family: 字体样式</span><br><span class="line">font-style: 斜体</span><br><span class="line">font-size: 字体大小</span><br><span class="line">left: 指定一个元素左边所在位置</span><br><span class="line">top: 控制元素顶部的位置</span><br><span class="line">line-height: 行间距</span><br><span class="line">text-align: 文本对齐方式(左、右、居中)</span><br><span class="line">letter-spacing: 字母之间设置间距</span><br><span class="line">background-color: 背景色</span><br><span class="line">list-style: 改变列表项外观</span><br><span class="line">padding: 内边距</span><br><span class="line">border: 外边距</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>7<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/7.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"top"</span>&gt;</span>77<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/77.jpg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"about/7.html"</span> <span class="attr">title</span>=<span class="string">"7"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>777<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        7 <span class="tag">&lt;<span class="name">em</span>&gt;</span>77<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">        777</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#top"</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Top<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Here <span class="tag">&lt;<span class="name">em</span>&gt;</span>Tcons<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">20%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#6fa5fa</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.icon</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#4bd5ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="字体和颜色样式"><a href="#字体和颜色样式" class="headerlink" title="字体和颜色样式"></a>字体和颜色样式</h1><p>访问者在你的web页面上看到的字体取决于他们自己计算机上安装了哪些字体，除非你使用web字体。</p><p>在<code>font-family</code>中指定候选字体是一个好主意，以防用户没有安装你的首选字体。<br>最后一个字体要指定为通用字体。这样一来，如果找不到其它字体，浏览器可以替换适当的字体。</p><p>如果你要使用某种字体，而默认情况下用户可能没有安装这种字体，可以在CSS中使用<code>@font-face</code>规则。</p><p>字体大小通常为： 像素(px)、斜体(em)、百分比(%)、关键字(small, mediuml…)<br>使用相对字体大小可以让你页面更可维护。</p><p>在body规则中使用字体大小关键字来设置基本字体大小，这样如果用户希望文本更大或更小，所有浏览器就能按比例缩放字体大小。</p><p>web颜色是混合数量不同的红、绿、蓝(RGB)得到的。<br>可以使用红绿蓝百分数指定你想要的颜色，也可以用红绿蓝数值(0-255)，或者使用颜色的十六进制码来指定颜色。</p><p>可以使用<code>text-decoration</code>属性为文本创建 上划线(overline)、下划线(underline)、中划线(line-through)。<br>有下划线的文档通常会被用户误以为是链接文件，所以要谨慎使用这个属性。</p><p><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>8<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">ref</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"../css/8.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>88<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>88!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>888<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../images/8.jpg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        8888:</span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>8888<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        8888:</span><br><span class="line">        <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">            88<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            888<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            8888<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line">        8888</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"Emblema One"</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">"http://wickedlysmart.com/hfhtmlcss/chapter8/journal/EmblemaOne-Regular.woff"</span>),</span><br><span class="line">         <span class="built_in">url</span>(<span class="string">"http://wickedlysmart.com/hfhtmlcss/chapter8/journal/EmblemaOne-Regular.ttf"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Verdana, Geneva, Arial, sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>: small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"Emblema One"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">140%</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0cb8cc</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: line-through;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">blockquote</span>, <span class="selector-tag">q</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>CSS使用一个盒模型来控制元素如何显示。</p><p>盒子由：</p><ul><li><p>内容区(content)<br>内容区包含元素的内容。</p></li><li><p>可选的 内边距(padding)、边框(border)、外边距(margin)<br>内边距用来在内容区周围创建可见的空间。<br>边框包围内边距和内容，它提供了从视觉上分离内容的一种手段。<br>外边距包围边框、内边距和内容，允许在元素和其它元素之间增加空间。</p></li></ul><p>内边距和外边距都可以使用像素或百分数设置。<br>边框宽度可以用像素设置，也可以使用关键字(thin, mediun, thick)来指定。<br>对于外边距、内边距或边框，CSS提供了相应的属性，可以一次对所有四个边(上下左右)完成设置，也可以单独设置任意一边。</p><p>元素的背景会在内容和内边距下显示，但不会延伸到外边距下面。<br>有八种不同的边框样式，包括实现、破折线、虚线和脊线。</p><p>对于希望成组指定样式的元素要使用<code>class</code>属性。<br>使用<code>id</code>属性为元素指定一个唯一的名字，还可使用<code>id</code>属性为元素提供唯一的样式。<br>可以使用<code>id</code>选择器按id选择元素。<br>一个元素只能有一个<code>id</code>，不过它可以属于多个类<code>class</code>。</p><p>在HTML中可以使用多个样式表。<br>如果两个样式表包含冲突的属性定义，HTML文件中最后链接的样式表最为优先。<br>可以在<code>&lt;link&gt;</code>元素中使用媒体查询或使用CSS中的<code>@media</code>规则来指定设备。</p><p><br></p><p><strong>元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">padding-top:</span><br><span class="line">padding-left:</span><br><span class="line">margin-right:</span><br><span class="line">margin-bottom:</span><br><span class="line">border-radius: 对有边框的元素创建圆角</span><br><span class="line">border-top-left-radius：</span><br><span class="line">border-right-bottom-radius：</span><br><span class="line">border-left-style：solid实线 / double双线 / groove槽线 / outset外凸 / inset内凹 / dotted虚线 / dashed破折线 / ridge脊线</span><br><span class="line">border-top-width：thin/ medium/ thick/ px</span><br><span class="line">border-right-color：</span><br><span class="line">background-image：url（images/*.jpg）或 url（http://*http://*）</span><br><span class="line">background-position：top left/ right bottom/ center</span><br><span class="line">background-repeat：no-repeat/ repeat/ repeat-x/ repeat-y/ inherit（按父元素的设置来处理）</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>9<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"9.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/9.png"</span> <span class="attr">alt</span>=<span class="string">"9"</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>99<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        9</span><br><span class="line">        99</span><br><span class="line">        999</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"wahaha"</span>&gt;</span></span><br><span class="line">        wa</span><br><span class="line">        haha</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>999<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        9</span><br><span class="line">        99</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>999<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>999<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>999<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Verdana, Helvetica, Arial, sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>: small;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(118, 173, 226, 0.86)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">170%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.6em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">35%</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">20%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#wahaha</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Georgia, <span class="string">"Times New Roman"</span>, Times, Serif;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.9em</span>;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ececec</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(images/9.gif);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>: left top;</span><br><span class="line">    <span class="attribute">border-color</span>: white;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: dashed;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">250px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="div和span"><a href="#div和span" class="headerlink" title="div和span"></a>div和span</h1><p><code>&lt;div&gt;</code>元素用于将相关的元素归组在一起，放在逻辑区中。<br>创建逻辑区有助于标识主要内容区，以及页面的页眉和页脚。</p><p>可以使用<code>&lt;div&gt;</code>元素将需要共同样式的元素归组在一起。<br>使用嵌套<code>&lt;div&gt;</code>元素为文件增加更多结构，这有利于保证结构清晰或方便增加样式。不过除非确实需要，否则不要过多地增加结构。<br>一旦使用<code>&lt;div&gt;</code>将内容区归组在一起，类似于其它块元素，可以对这些<code>&lt;div&gt;</code>增加样式。例如，对于包含在<code>&lt;div&gt;</code>中的一组元素，可以使用嵌入这些元素的<code>&lt;div&gt;</code>的边框属性，对这组元素增加一个边框。</p><p><code>width</code>属性设置设置一个元素内容区(content)的宽度。<br>一个元素的总宽度是内容区宽度，加上所增加的页边距、边框和外边距的宽度。<br>一旦设置一个元素的宽度，它不会延伸来占满浏览器窗口的整个宽度。</p><p><code>text-align</code>是块元素的一个属性，用来将这个块元素中的所有内容对其，可以居中、左、右对齐。这个属性可以由所有嵌套的块元素继承。</p><p>可以使用子孙选择器来选择嵌套在其它元素中的元素。如子孙选择器<code>div h2 {...}</code>。会选择嵌套在<code>&lt;div&gt;</code>元素中的所有<code>&lt;h2&gt;</code>(包括子元素、孙子元素等)。</p><p>可对相关的属性使用快捷方式。如<code>padding-top, padding-bottom, padding-left, padding-right</code>都与内边距有关，可以用一个快捷规则来指定: <code>padding</code>。</p><p><code>&lt;span&gt;</code>内联元素与<code>&lt;div&gt;</code>元素类似，它用于将相关的内联元素(inline)和文本归组在一起。<br>类似于<code>&lt;div&gt;</code>，可以将<code>&lt;span&gt;</code>元素增加到类（或者为<code>&lt;span&gt;</code>元素指定唯一的id），对它们增加样式。</p><p>有些元素有不同的状态，<code>&lt;a&gt;</code>元素就是这样一个例子。<code>&lt;a&gt;</code>元素的主要状态包括 未访问、已访问、悬停。</p><p>可以用 伪类(pseudo class) 单独地为各个状态指定样式。伪类最常用于<code>&lt;a&gt;</code>元素。<code>:link</code>对应未访问的链接；<code>:visited</code>对应已访问链接；<code>:hover</code>对应悬停状态。<br>伪类还可以用于其它元素，而不仅限于<code>&lt;a&gt;</code>元素。<br>另外一些伪类包括：<code>:acrivate</code>, <code>:focus</code>, <code>:first-child</code>, <code>:last-child</code>等。</p><p><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>10<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"10.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/10.png"</span> <span class="attr">alt</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"elixirs"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>1010<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/1010.png"</span> <span class="attr">alt</span>=<span class="string">"1010"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        10</span><br><span class="line">        1010</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"guarantee"</span>&gt;</span></span><br><span class="line">        10</span><br><span class="line">        1010</span><br><span class="line">        101010</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"pseudo"</span>&gt;</span></span><br><span class="line">        10</span><br><span class="line">        1010</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>101010<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        10</span><br><span class="line">        1010</span><br><span class="line">        101010</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"cd"</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"artist"</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"cd"</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"artist"</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"copyright"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            @xxxx<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            xxxx</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Verdana, Helvetica, Arial, sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>: small;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(118, 173, 226, 0.86);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">170%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.6em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">35%</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">20%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#guarantee</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: italic small/<span class="number">1.9em</span> Feorgia, <span class="string">"Times New Roman"</span>, Times, Serif;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ececec</span> <span class="built_in">url</span>(images/bg.gif) no-repeat top left;</span><br><span class="line">    <span class="attribute">border</span>: white <span class="number">2px</span> dashed;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">250px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#elixirs</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: thin solid <span class="number">#007e7e</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="comment">/* 顺时针 top right bottom left */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span> <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(images/bg2.gif) repeat-x top right;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#elixirs</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#elixirs</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#copyright</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">text-aligh</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: normal;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cd</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.artist</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#elixirs</span> <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0cb8cc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#elixirs</span> <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#elixirs</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#16a085</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: line-through;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.pseudo</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#333333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="布局与定位"><a href="#布局与定位" class="headerlink" title="布局与定位"></a>布局与定位</h1><p>浏览器使用流(flow)在页面中放置元素。</p><p>块元素从上向下流，各元素之间有一个换行。默认的，每个块元素会占浏览器窗口的整个宽度。<br>内联元素在块元素内部从左上方流向右下方。如果需要多行，浏览器会换行，在垂直方向上扩展外围块元素，来包含这些内联元素。</p><p>正常页面流中两个块元素上下相邻的外边距会折叠为最大外边距的大小，或者如果两个外边距大小相同，则会折叠为一个外边距。<br>浮动元素会从正常流中取出，浮动到左边或者右边。<br>浮动元素放在块元素之上，不会影响正常的页面流。不过，内联内容会考虑浮动元素的边界，围绕这个浮动元素。</p><p><code>clear</code>属性用来指定一个块元素左边或右边（或左右两边）不能有浮动元素。设置了<code>clear</code>属性的块元素会下移，直到它旁边没有块元素。</p><p>浮动元素必须有特定的宽度，不能设置为<code>auto</code>。</p><p>流体布局是指，扩展浏览器窗口时，页面中的内容会扩展以适应页面。<br>冻结布局是指，其中内容的宽度是固定的，不会随着浏览器窗口扩展或收缩。这有一个好处，可以对设计提供更多控制，不过也要付出代价，这样就不能有效地使用浏览器宽度了。<br>凝胶布局是指，其中内容的宽度时固定的，但是外边距会随着浏览器窗口扩展或收缩。凝胶布局通常会把内容放在中央。这与冻结布局有同样的好处，不过通常更美观。</p><p><code>positon</code>属性可以设置四个值：static(静态)、absolute(绝对)、fixed(固定)、relative(相对)。<br>静态定位是默认方式，将元素放在页面的正常流中。<br>绝对、固定和相对定位时，属性<code>top, right, bottom, left</code>可用来指定元素的位置。<br>绝对定位元素可以使用<code>z-index</code>属性分层放置，是一个元素在另一个元素上面。<code>z-index</code>值越大，说明它的层次越高（在屏幕上离你越近）。<br>固定定位元素总是相对于浏览器窗口定位，页面滚动时，固定定位的元素不会移动。页面中的其它内容会在这些固定定位元素下面正常滚动。<br>相对定位元素首先正常流入页面，然后按指定的量偏移，从而留出它们原先所在的空间。<br>使用相对定位时，<code>left, right, top, bottom</code>是指距正常流中该元素位置的偏移量。</p><p>CSS表格显示允许按一种表格布局来摆放元素。<br>要创建CSS表格显示，需要使用对应表格的一个块元素，对应行的块元素。以及对应单元格的块元素。通常，这些块元素都是<code>&lt;div&gt;</code>元素。</p><p>如果需要建立多栏布局，而且内容栏是均匀的，表格显示就是一个很好的布局策略。</p><p><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>11<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">ref</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"11.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/11.png"</span> <span class="attr">alt</span>=<span class="string">"11"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header2"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/bg2.gif"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header3"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/bg3"</span> <span class="attr">width</span>=<span class="string">"200px"</span> <span class="attr">height</span>=<span class="string">"200px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tableContainer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tableRow"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"drinks"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>11<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>11<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                    11</span><br><span class="line">                    1111</span><br><span class="line">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                    1111</span><br><span class="line">                    111111</span><br><span class="line">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"pseudo"</span>&gt;</span></span><br><span class="line">                    11 11</span><br><span class="line">                    1111 1111</span><br><span class="line">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                    11 11 11</span><br><span class="line">                    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"cd"</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span><br><span class="line">                            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"artist"</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"cd"</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span><br><span class="line">                            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"artist"</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sidebar"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>11 11 11<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"iamges/img2.ico"</span> <span class="attr">alt</span>=<span class="string">"img2"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                    11</span><br><span class="line">                    11 11</span><br><span class="line">                    11 11 11</span><br><span class="line">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"copyright"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            @2016,xxxx<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            xxxx</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Verdana, Helvetica, Arial, sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>: small;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(118, 173, 226, 0.86);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">170%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.6em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#header1</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">35%</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">40%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#header2</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#header3</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">105%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#d12c47</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0cb8cc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#sidebar</span> <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#sidebar</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#16a085</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: line-through;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#copyright</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#b9311b</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: normal;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cd</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.artist</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">105%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#tableContainer</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">border-spacing</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#tableRow</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#drinks</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: taable-cell;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">15%</span>;</span><br><span class="line">    <span class="attribute">vertical-aligh</span>: top;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;aside&gt;    # 用于表示放在内容旁边的内容，比如引用</span><br><span class="line">&lt;mark&gt;     # 用于突出显示某些文件，就像记号笔一样棒</span><br><span class="line">&lt;audio&gt;    # 用于在页面中包含声音内容</span><br><span class="line">&lt;time&gt;     # 时间、日期或日期时间</span><br><span class="line">&lt;progress&gt; # 需要显示任务的完成进度，如90%</span><br><span class="line">&lt;footer&gt;   # 定义一个区块或整个文档的页眉</span><br><span class="line">&lt;header&gt;   # 有首部的区块和整个文档的页眉可以使用这个元素</span><br><span class="line">&lt;meter&gt;    # 需要显示某个范围的度量。比如一个0到220度的温度计，现在显示90度</span><br><span class="line">&lt;article&gt;  # 用来标记类似新闻报道或博客帖子等独立内容</span><br><span class="line">&lt;canvas&gt;   # 在页面中显示js绘制的图像和动画</span><br><span class="line">&lt;section&gt;  # 定义文档的主要区块</span><br><span class="line">&lt;nav&gt;      # 把网站中用于导航的所有链接组织在一起</span><br><span class="line">&lt;figure&gt;   # 定义类似照片、图像甚至代码清单等独立的内容</span><br><span class="line">&lt;video&gt;    # 在页面中加入一个视频</span><br></pre></td></tr></table></figure><p>视频编码是用来创建视频文件的编码。<br>视频容器文件包含视频、音频和元数据。<br>要提供多个视频源文件，确保你的用户可以在他们的浏览器中播放视频文件。</p><p><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">'utf-8'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>12<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"12.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/12.png"</span> <span class="attr">alt</span>=<span class="string">"12"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"1.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"2.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"3.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tableContainer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tableRow"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"drinks"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span>&gt;</span>x<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">p</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"blog"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>blog<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">"2019-01-01"</span>&gt;</span>Jan 01 2019<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                        12</span><br><span class="line">                        12 12</span><br><span class="line">                        12 12 12</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>12 12<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/1212.png"</span> <span class="attr">alt</span>=<span class="string">"1212"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                    12 12</span><br><span class="line">                    12</span><br><span class="line">                    12 12</span><br><span class="line">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            @2019,xxx</span><br><span class="line">            xxxx</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="表格与更多列表"><a href="#表格与更多列表" class="headerlink" title="表格与更多列表"></a>表格与更多列表</h1><p>确实需要在页面中创建表格数据时，就使用HTML表格。<br>如果只需要对其它类型的内容使用一种类似与表格的表现方式，就可以使用CSS表格来显示布局。</p><p>HTML表格用来建立表格数据结构。<br>HTML表的元素： 表格(<code>&lt;table&gt;</code>)、表行(<code>&lt;tr&gt;</code>)、表头(<code>&lt;th&gt;</code>)、表格数据(<code>td</code>)，一齐用来创建一个表格。<br><code>table</code>元素定义并包围整个表格；<br>表格使用<code>&lt;tr&gt;</code>元素按行定义；<br>每行包含一个或多个数据单元格，用<code>&lt;td&gt;</code>元素定义；<br>表格采用格状布局。每行对应HTML中的一个<code>&lt;tr&gt;..&lt;/tr&gt;</code>，每列对应行中的<code>&lt;td&gt;...&lt;/td&gt;</code>内容。<br>如果一个数据单元格没有数据，<code>&lt;td&gt;</code>元素中不放置任何内容。不过，需要使用<code>&lt;td&gt;&lt;/td&gt;</code>维持表格对齐。<br>如果你的数据单元格需跨多行或多列，可使用<code>&lt;td&gt;</code>元素的<code>rowspan</code>或<code>colspan</code>属性。</p><p>可以用<code>&lt;caption&gt;</code>元素提供关于表格的额外信息。</p><p>表格有边框间距，也就是单元格之间的间距。<br>表格数据单元格还可以有内边距和边框，但没有外边距。<br>就像能够控制元素的内边距、边框、外边距一样，可以用CSS控制表格单元格的内边距、边框和边框间距。</p><p><code>border-collapse</code>(边框折叠)是针对表格的一个特殊CSS属性，允许将单元格边框合并为一个边框，让外观更简洁。</p><p>可以用<code>text-align</code>和<code>vertic-align</code> CSS属性改变表格单元格中数据的对齐方式。<br>可以用<code>background</code>属性为表格增色。可以为整个表格、各行或单个的数据单元格增加背景色。</p><p>使用CSS的<code>:nth-child</code>伪类可为表格隔行增加背景色。</p><p>可以在表格中嵌套表格，将<code>&lt;table&gt;</code>元素及其内容放在一个数据单元格中。</p><p>表格应当应用于表示表格数据，而不是建立页面布局。</p><p><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>13<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"syslesheet"</span> <span class="attr">href</span>=<span class="string">"../css/13.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>13<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>13 13 13 13<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>2019-01-10<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../images/13.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      13</span><br><span class="line">      13 13</span><br><span class="line">      <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">cpation</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>13 13<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>L1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>L2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>L3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>11<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>22<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>33<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">"cellcolor"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>1c<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>2c<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>3c<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>111<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>222<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>333<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>2222<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">td</span>&gt;</span>1 1 <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">td</span>&gt;</span>2 2 <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">td</span>&gt;</span>1 1 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">td</span>&gt;</span>2 2 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p><code>&lt;form&gt;</code>元素定义了表单，所有表单输入元素都嵌套着这个元素中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">action 属性包含了服务器脚本的URL</span><br><span class="line">method 属性包含发送表单数据的方法，可以是GET或POST</span><br><span class="line"></span><br><span class="line">POST 打包数据表单，并把它作为请求的一部分发送到服务器</span><br><span class="line">GET 打包表单数据，并把数据追加到url</span><br><span class="line"></span><br><span class="line">如果表单数据应当是私有的，或者表单数据很多，如使用了一个&lt;textarea&gt;或者file &lt;input&gt;元素，就应当使用POST方法。</span><br><span class="line">对于可以加书签的请求，要使用GET方法。</span><br><span class="line"></span><br><span class="line">&lt;input&gt;元素在web页面上可以作为多种不同的输入控件，这取决于它的type属性值。</span><br><span class="line">type为 text 时会创建一个单行文本输入框</span><br><span class="line">type为 submit 时会创建一个提交按钮</span><br><span class="line">type为 radio 时会创建一个单选框。所有同名的单选框构成一组互斥的按钮</span><br><span class="line">type为 checkbox 时会创建一个复选框控件。通过为多个复选框指定相同的名字，可以创建一组选择</span><br><span class="line">type为 number 时会创建一个只允许数字字符的单行文本输入控件</span><br><span class="line">type为 range 时会创建一个滑动条控件提供数字输入</span><br><span class="line"></span><br><span class="line">color 类型会在支持这个类型的浏览器中创建一个颜色选择器（否则只会创建一个普通的文本输入控件）</span><br><span class="line">date 类型会在支持这个类型的浏览器中创建一个日期选择器（否则只会创建一个普通的文本输入控件）</span><br><span class="line">email, url, tel 类型会创建当行文本输入，在一些移动浏览器上出现定制键盘来方便数据输入</span><br><span class="line"></span><br><span class="line">&lt;textarea&gt; 元素会创建一个多行文本输入区。</span><br><span class="line">&lt;select&gt; 元素会创建一个菜单，包含一个或多个 &lt;option&gt; 元素。&lt;option&gt; 元素定义了菜单中的菜单项。</span><br><span class="line"></span><br><span class="line">如果将文本放在 &lt;textarea&gt; 元素的内容中，这会成为web页面上文本去控件中的默认文本</span><br><span class="line"></span><br><span class="line">text &lt;input&gt; 元素中的 value 属性可以用来为单行文本输入控件提供一个初始值。</span><br><span class="line">在提交按钮设置 value 属性可以改变按钮上显示的文本。</span><br><span class="line"></span><br><span class="line">提交一个web表单时，表单数据值与相应的数据名配对，所有名和值会发送到服务器。</span><br><span class="line"></span><br><span class="line">由于表单有一个表格结构，通常会用CSS表格显示来建立表单布局。CSS还可以用来指定表单的颜色、字体风格、边框样式。</span><br><span class="line"></span><br><span class="line">HTML允许用 &lt;fieldset&gt; 元素组织表单元素。</span><br><span class="line"></span><br><span class="line">可以用 &lt;lable&gt; 元素以一种有助于提高可访问性的方式关联标签与表单元素。</span><br><span class="line"></span><br><span class="line">使用 placeholder 属性可以为表单用户提供一个提示， 指出你希望在一个输入域中输入什么内容。</span><br><span class="line"></span><br><span class="line">required 属性指示一个输入域是必要的，要让表单成功提交，这个输入域中必须有值。有些浏览器在你提交表单之前会强制要求在这些域中输入数据。</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Form<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">ref</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"form.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Form 1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Form 2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://xxx.com/xx.php"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tableRow"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span> Choose: <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"beans"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"default"</span>&gt;</span>111<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"default"</span>&gt;</span>222<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"default"</span>&gt;</span>333<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"default"</span>&gt;</span>444<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tableRow"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Type: <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"beantype"</span> <span class="attr">value</span>=<span class="string">"whole"</span>&gt;</span>55<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"beantype"</span> <span class="attr">value</span>=<span class="string">"ground"</span>&gt;</span>66</span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tableRow"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">name</span>=<span class="string">"bags"</span> <span class="attr">min</span>=<span class="string">"1"</span> <span class="attr">max</span>=<span class="string">"20"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tableRow"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Date:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">name</span>=<span class="string">"date"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tableRow"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tableRow"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Address: <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"address"</span><span class="attr">value</span>=<span class="string">""</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tableRow"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Phone: <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span> <span class="attr">name</span>=<span class="string">"phone"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tableRow"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Email: <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">placeholder</span>=<span class="string">"someone@example.com"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tableRow"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Choose file:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tableRow"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>Comment: <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"comment"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tableRow"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Order"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#efe5d0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Georgia, <span class="string">"Times New Roman"</span>, Times, Serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">form</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border</span>: thin dotted <span class="number">#7e7e7e</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#e1ceb8</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">form</span> <span class="selector-tag">textarea</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.tableRow</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.tableRow</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: top;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.tableRow</span> <span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.heading</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Head First HTML and CSS》&lt;/li&gt;
&lt;li&gt;w3cSchool: &lt;a href=&quot;https://www.w3school.com.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.w3school.com.cn/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Frontend" scheme="https://zhang21.github.io/categories/Frontend/"/>
    
    
      <category term="Frontend" scheme="https://zhang21.github.io/tags/Frontend/"/>
    
      <category term="HTML" scheme="https://zhang21.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://zhang21.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Django</title>
    <link href="https://zhang21.github.io/2019/09/25/Django/"/>
    <id>https://zhang21.github.io/2019/09/25/Django/</id>
    <published>2019-09-25T02:59:21.000Z</published>
    <updated>2019-11-24T15:44:23.100Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/</a></li></ul><p><br></p><p>版本:</p><ul><li>Django Version: v2.1</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="使用Django"><a href="#使用Django" class="headerlink" title="使用Django"></a>使用Django</h1><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/</a></p><p><br><br><br></p><h1 id="安装Django"><a href="#安装Django" class="headerlink" title="安装Django"></a>安装Django</h1><p><br><br><br></p><hr><p><br><br><br></p><h1 id="模型和数据库"><a href="#模型和数据库" class="headerlink" title="模型和数据库"></a>模型和数据库</h1><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/db/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/db/</a></p><p>模型是你的数据唯一而且准确的信息来源。它包含你正在存储的数据的重要字段和行为。一般来说，每一个模型都映射一个数据库表。</p><p><br></p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/db/models/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/db/models/</a></p><p>基础:</p><ul><li>每个模型都是一个Python类(继承<code>django.db.models.Model</code>)</li><li>模型类的每个属性都相当于一个数据库的字段</li></ul><p><br></p><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p>这个样例模型定义了一个Person, 其拥有<code>first_name</code>和<code>last_name</code>:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p><code>first_name</code>和<code>last_name</code>是模型的字段。每个字段都被指定为一个类属性，并且每个属性映射为一个数据库列。</p><p>上面的Person会创建一个如下的数据库表:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myapp_person (</span><br><span class="line">    <span class="string">"id"</span> <span class="built_in">serial</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="string">"first_name"</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">"last_name"</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>表名<code>myapp_person</code>是自动从模型元数据中派生出来，但可以被改写</li><li><code>id</code>字段会被自动添加，也可被改写</li><li>这是使用默认的PostgreSQL语法，数据库引擎可在settings中配置</li></ul><p><br><br><br></p><h3 id="使用模型"><a href="#使用模型" class="headerlink" title="使用模型"></a>使用模型</h3><p>一旦定义了模型，需要告诉Django使用这些模型。需要修改<code>setting</code>文件中的<code>INSTALLED_APPS</code>, 这个设置中添加包含你<code>models.py</code>文件的模块的名字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 例如，模型位于项目中的myapp.models中</span><br><span class="line"># 包结构使用 manage.py startapp 创建</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">  ...</span><br><span class="line">  &apos;myapp&apos;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>当你在配置中添加新应用的时候，请务必运行<code>manage.py migrate &lt;migrate&gt;</code>，此外你也可以先使用<code>manage.py makemigrations</code>先进行迁移。</p><p><br><br><br><br><br></p><h2 id="进行查询"><a href="#进行查询" class="headerlink" title="进行查询"></a>进行查询</h2><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/db/queries/</a></p><p>一旦创建了数据模型，Django会自动地给你一个数据库抽象API——让你可创建、检索、更新和删除对象。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">1000</span>)</span><br><span class="line">    tagline = models.TextField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">1200</span>)</span><br><span class="line">    email = models.EmailField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)</span><br><span class="line">    headline = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    body_text = models.TextField()</span><br><span class="line">    pub_date = models.DateField()</span><br><span class="line">    authors = models.MangToManyField(Author)</span><br><span class="line">    n_comments = models.IntegerField()</span><br><span class="line">    n_pingbacks = models.IntegerField()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.headline</span><br></pre></td></tr></table></figure><p><br></p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>为了表示在Python对象数据库表中的数据，Django使用一个直观的系统:</p><ul><li>一个模型类表示一个数据库表</li><li>类实例表示数据库中的表中的特定记录</li></ul><p>要创建一个对象，使用关键字参数模型类的实例化，然后调用<code>save()</code>将它保存到数据库中。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="keyword">from</span> blog.models <span class="keyword">import</span> Blog</span><br><span class="line"></span><br><span class="line">b = Blog(name=<span class="string">'xxx'</span>, tagline=<span class="string">'xxxx'</span>)</span><br><span class="line">b.save()</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="将更改保存到对象"><a href="#将更改保存到对象" class="headerlink" title="将更改保存到对象"></a>将更改保存到对象</h3><p>使用<code>save()</code>将更改保存到一个对象中已有的数据库。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b5.name = <span class="string">'New b5'</span></span><br><span class="line">b5.save()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这执行幕后的UPDATE SQL语句</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="检索对象"><a href="#检索对象" class="headerlink" title="检索对象"></a>检索对象</h3><p>要检索数据库对象，通过在模型类上<code>Manager</code>构建一个<code>QuerySet</code>。<br><code>QuerySet</code>代表从数据库的对象集合。它可以有0, 1, n个过滤器。在SQL方面，一个<code>QuerySet</code>相当于<code>SELECT</code>语句，而过滤器相当于<code>WHERE, LIMIT</code>。<br>通过使用<code>Manager</code>模型获取<code>QuerySet</code>。每个模型至少有一个<code>Manager</code>，这就是所谓的默认<code>objects</code>。直接通过模型类访问:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Blog.objects</span><br><span class="line"></span><br><span class="line">b = Blog(name=<span class="string">'xxx'</span>, tagline=<span class="string">'Bar'</span>)</span><br><span class="line">b.objects</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>检索所有对象；</p><p>使用过滤器检索特定对象；</p><p><br><br><br></p><h3 id="比较对象"><a href="#比较对象" class="headerlink" title="比较对象"></a>比较对象</h3><p><br><br><br></p><h3 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h3><p><br><br><br></p><h3 id="更新对象"><a href="#更新对象" class="headerlink" title="更新对象"></a>更新对象</h3><p><br><br><br></p><h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><p><br><br><br></p><h3 id="回落的原生SQL"><a href="#回落的原生SQL" class="headerlink" title="回落的原生SQL"></a>回落的原生SQL</h3><p>如果你发现自己使用Django 数据库映射器写一个SQL查询太复杂，你可以手边编写SQL fall back。</p><p><br><br><br><br><br></p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/db/aggregation/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/db/aggregation/</a></p><p>有时候要获取的值需要根据一组对象聚合后才能得到。</p><p><br><br><br></p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/db/search/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/db/search/</a></p><p>Web应用的一个常见任务就是寻找与用户输入数据库中的某些数据。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="处理HTTP请求"><a href="#处理HTTP请求" class="headerlink" title="处理HTTP请求"></a>处理HTTP请求</h1><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/http/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/http/</a></p><p><br></p><h2 id="URL调度器"><a href="#URL调度器" class="headerlink" title="URL调度器"></a>URL调度器</h2><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/http/urls/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/http/urls/</a></p><p>对于高质量的Web应用来说，使用简洁、优雅的URL模式是一个非常值得重视的世界。Django允许你自由滴设计你的URL，不受框架束缚。</p><p><br></p><h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><p>为了给一个应用设计URL，你需要创建一个Python模块，通常被称为<code>URLconf</code>。这个模块是纯粹的Python代码，包含URL模式(简单的正则)到Python函数(视图)的简单映射。<br>映射可长可短，随便你。它可以引用其它映射。而且，因为它是纯粹的Python代码，它可以动态构造。</p><p><br><br><br></p><h3 id="Django如何处理一个请求"><a href="#Django如何处理一个请求" class="headerlink" title="Django如何处理一个请求"></a>Django如何处理一个请求</h3><p>当一个用户请求Django站点的一个页面，下面是Django系统决定执行哪个Python代码使用的算法:</p><ol><li>Django确定 root URLconf 模块的使用。通常，这个<code>setting</code>中<code>ROOT_URLCONF</code>的值，但如果传入HttpRequest对象具有URL配置属性(由中间件设置)，它的值将代替<code>ROOT_URLCONF</code>。</li><li>Django载入 Python 模块并查找 <code>urlpatterns</code>变量。这应该是是一个 Python List。</li><li>Django依次匹配每个URL模式，在与请求的URL匹配的第一个模式停下来。</li><li>一旦URL模式匹配，Django导入并调用给定的视图——这是一个简单的Python函数(或基于类的视图)。该类会传递如下参数:<br>4.1 一个HttpRequest实例<br>4.2 如果匹配的URL模式没有返回命名组，则从正则匹配作为位置参数<br>4.3 关键字参数是由通过路径表达式匹配的任何命名的部分，通过在任选关键字参数<code>kwargs</code>指定的任何参数重写<code>django.urls.path()</code>或<code>django.urls.re_path()</code></li><li>如果每个URL模式匹配，或者一个异常在此过程中的任何点被抛出，则Django调用适当的错误处理视图。</li></ol><p><br><br><br></p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><p>一个简单的URLconf:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">utlpatterns = [</span><br><span class="line">    path(<span class="string">'articles/2003/'</span>, views.special_case_2003),</span><br><span class="line">    path(<span class="string">'articles/&lt;int:year&gt;/'</span>, views.year_archive),</span><br><span class="line">    path(<span class="string">'articles/&lt;int:year&gt;/&lt;int:month&gt;/'</span>, views.month_archive),</span><br><span class="line">    path(<span class="string">'articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug:slug&gt;/'</span>, view.article_detail)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>为了捕获从URL中的值，使用尖括号<code>&lt;&gt;</code></li><li>捕获的值可任选地包括一个转换器类型。如，使用<code>&lt;int: name&gt;</code>来捕获整数参数。如果不包含一个转换器，则为任意string。排除<code>/</code>字符，被匹配。</li><li>没有必要添加开始的斜线<code>/</code>，因为每个URL都有。如<code>articles</code>而不是<code>/articles</code>。</li></ul><p>一些请求栗子:</p><ul><li>一个请求<code>/articles/2005/03/</code>将匹配李彪中的第三项。Django将调用函数<code>view.mouth_archive(request, year=2005, month=3)</code>。</li><li><code>/articles/2003/</code>将匹配第一个模式，而不是第二个。Django将调用函数<code>views.special_case_2003(request)</code></li><li><code>/articles/2003</code>将不会匹配这些模式，因为每个模式都要求URL以斜线<code>/</code>结束</li><li><code>/articles/2003/building-a-django-site/</code>讲匹配最后一个模式。Django将调用函数<code>view.article_detail(request, year=2003, month=3, slug=&quot;building-a-django-site&quot;)</code></li></ul><p><br><br><br></p><h3 id="path转换器"><a href="#path转换器" class="headerlink" title="path转换器"></a>path转换器</h3><p>下面的路径转换器默认可用:</p><ul><li><code>str</code>: 匹配任意非空字符串，不包括路径分隔符<code>/</code>。如果表达式中不包含转换器，这是默认值。</li><li><code>int</code>: 匹配零个或多个正整数，返回一个int。</li><li><code>slug</code>: 匹配任何由ASCII字母、数字、连字符、下划线组成的slug字符串。</li><li><code>uuid</code>: 匹配一个格式化的UUID。为了防止映射到同一页面的多个网址，必须包含字符，必须小写。(如<code>075194d3-6885-417e-a8a8-6c931e272f00</code>)，返回一个UUID实例。</li><li><code>path</code>: 匹配任意费控字符串，包含路径分隔符<code>/</code>。这允许你来匹配一个完整的URL路径.</li></ul><p><br><br><br></p><h3 id="注册自定义路径转换器"><a href="#注册自定义路径转换器" class="headerlink" title="注册自定义路径转换器"></a>注册自定义路径转换器</h3><p>对于更复杂的匹配要求，可以定义自己的路径转换器。</p><p><br><br><br></p><h3 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h3><p>如果路径和转换器的语法不够定义你的URL模式，你也可以使用正则表达式。要做到这一点，使用<code>re_path()</code>来代替<code>path()</code>。</p><p>在Python的正则表达式中，正则表达式组名语法是<code>(?P&lt;name&gt;pattern)</code>，name是组名和pattern相匹配。</p><p>将之前的URLconf使用正则表达式改写:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, re_path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'articles/2003/'</span>, views.special_case_2003),</span><br><span class="line">    re_path(<span class="string">r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;/$'</span>, views.year_archive)),</span><br><span class="line">    re_path(<span class="string">r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/$'</span>, views.month_archive),</span><br><span class="line">    re_path(<span class="string">r'^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/(?P&lt;slug&gt;[\w-]+)/$'</span>, views.article_detail),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><p>使用未命名的正则表达式组</p><p><br></p><p>嵌套的参数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正则表达式允许嵌套参数</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r'^blog/(page-(\d+)/)?$'</span>, blog_articles),                  <span class="comment"># bad</span></span><br><span class="line">    re_path(<span class="string">r'^comments/(?:page-(?P&lt;page_number&gt;\d+)/)?$'</span>, comments),  <span class="comment"># good</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="URLconf在什么上查找"><a href="#URLconf在什么上查找" class="headerlink" title="URLconf在什么上查找"></a>URLconf在什么上查找</h3><p>请求的URL被看成是一个普通的Python字符串，URLconf在其上查找并匹配。进行匹配时将不包括GET或POST请求方式的参数以及域名。<br>例如，<code>https://www.example.com/myapp/</code>请求中，URLconf将查找<code>myapp/</code>。在<code>https://www.example.com/myapp/?page=3</code>请求中，URLconf仍将查找<code>myapp/</code>。<br>URLconf不检查使用了哪种请求方法。换句话讲，所有的请求方法——无论是POST, GET, HEAD…，都将路由到相同的函数。</p><p><br><br><br></p><h3 id="指定视图参数的默认值"><a href="#指定视图参数的默认值" class="headerlink" title="指定视图参数的默认值"></a>指定视图参数的默认值</h3><p>有一个方便的小技巧是指定视图参数的默认值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URLconf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">utlpatterns = [</span><br><span class="line">    path(<span class="string">'blog/'</span>, views.page),</span><br><span class="line">    path(<span class="string">'blog/page&lt;int:num&gt;'</span>, views.page),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># View</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page</span><span class="params">(request, num=<span class="number">1</span>)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>当Django找不到请求的URL匹配，或将引发异常，Django调用错误处理视图。<br>这些情况发生时使用的视图通过4个变量指定。它们的默认值应该能满足大部分项目，但也可给他们赋值以进一步自定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handler400: django.conf.urls.handler400</span><br><span class="line"></span><br><span class="line">handler403: django.conf.urls.handler403</span><br><span class="line"></span><br><span class="line">handler404: django.conf.urls.handler404</span><br><span class="line"></span><br><span class="line">handler500: django.conf.urls.handler500</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="包含其它的URLconfs"><a href="#包含其它的URLconfs" class="headerlink" title="包含其它的URLconfs"></a>包含其它的URLconfs</h3><p>在任何时候，你的<code>urlpatterns</code>都可以<code>include</code>其它URLconf模块。这实际上将一部分URL放置于其它URL下面。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">'community/'</span>, include(<span class="string">'abc.urls'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>当Django遇到<code>include()</code>，它砍掉任何匹配到该点和该URL的一部分发送所述剩余的字符串所包含的URL配置用于进一步的处理。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> app.main <span class="keyword">import</span> view <span class="keyword">as</span> main_views</span><br><span class="line"><span class="keyword">from</span> credit <span class="keyword">import</span> views <span class="keyword">as</span> credit_views</span><br><span class="line"></span><br><span class="line">extra_patterns = [</span><br><span class="line">    path(<span class="string">'reports/'</span>, credit_views.report),</span><br><span class="line">    path(<span class="string">'reports/&lt;int:id&gt;/'</span>, credit_views.report),</span><br><span class="line">    path(<span class="string">'charge/'</span>, credit_views.charge),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, main_views.homepage),</span><br><span class="line">    path(<span class="string">'help/'</span>, include(<span class="string">'apps.help.urls'</span>)),</span><br><span class="line">    path(<span class="string">'credit/'</span>, include(extra_patterns)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这个栗子中，<code>/credit/reports/</code> URL将被<code>credit_views.report()</code>这个Django视图处理。</p><p>这种方法可以用来去除URLconf中的冗余，其中某个模式前缀被重复使用。如:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'&lt;page_slug&gt;-&lt;page_id&gt;/history/'</span>, views.history),</span><br><span class="line">    path(<span class="string">'&lt;page_slug&gt;-&lt;page_id&gt;/edit/'</span>, views.edit),</span><br><span class="line">    path(<span class="string">'&lt;page_slug&gt;-&lt;page_id&gt;/discuss/'</span>, views.discuss),</span><br><span class="line">    path(<span class="string">'&lt;page_slug&gt;-&lt;page_id&gt;/permissions/'</span>, views.permissions),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改进它</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'&lt;page_slug&gt;-&lt;page_id&gt;/'</span>, include([</span><br><span class="line">        path(<span class="string">'history/'</span>, views.history),</span><br><span class="line">        path(<span class="string">'edit/'</span>, views.edit),</span><br><span class="line">        path(<span class="string">'discuss/'</span>, views.disscuss),</span><br><span class="line">        path(<span class="string">'permissions/'</span>, views.permissions),</span><br><span class="line">    ])),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><p><strong>捕获的参数</strong></p><p>被包含的URLconf会收到来自父URLconf捕获的任何参数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings/urls/main.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'&lt;username&gt;/blog/'</span>, include(<span class="string">'foo.urls.blog'</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># foo/urls/blog.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, views.blog.index),</span><br><span class="line">    path(<span class="string">'archive/'</span>, views.blog.archive),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在上面的栗子中，捕获的<code>username</code>变量将被如期传递给<code>include()</code>执行的URLconf。</p><p><br><br><br></p><h3 id="传递额外选项到视图函数"><a href="#传递额外选项到视图函数" class="headerlink" title="传递额外选项到视图函数"></a>传递额外选项到视图函数</h3><p>URLconfs有一个hooks，可以传递额外的参数给视图函数，作为Python字典。</p><p>The <code>path()</code> function can take an optional third argument which should be a dictionary of extra keyword arguments to pass to the view function.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'blog/&lt;int:year&gt;/'</span>, views.year_archive, &#123;<span class="string">'foo'</span>: <span class="string">'bar'</span>&#125;),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># In this example, for a request to /blog/2005/, Django will call views.year_archive(request, year=2005, foo='bar').</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>传递额外选项到<code>include()</code></strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'blog/'</span>, include(<span class="string">'inner'</span>), &#123;<span class="string">'blog_id'</span>: <span class="number">3</span>&#125;),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># inner.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> mysite <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'archive/'</span>, views.archive),</span><br><span class="line">    path(<span class="string">'about/'</span>, views.about),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="URLs的反向解析"><a href="#URLs的反向解析" class="headerlink" title="URLs的反向解析"></a>URLs的反向解析</h3><p>Django项目工作时的一个常见需要是获得 URLs 它们的最终形式或用于在生成的内容中嵌入的 URL 的可能性为在服务器上的导航流处理测(重定向)。</p><p>强烈希望避免硬编码(hard-coding)这些URLs（费力，不可扩展且容易出错）。同样危险的是<code>ad-hoc</code>机制，以产生平行于所述 URLconf 描述的设计，这可能导致生成的 URLs 随着时间的推移而变得陈旧。</p><p>换句话说，需要一个 DRY 机制。在其它优点将允许 URL 设计的进化，而不必去复习所有项目的源代码来查找和替换过时的URLs。</p><p>Django提供了一个解决方案，以使 URL 映射器 是 URL 设计的唯一仓库。用你的 URL 喂养它，那么它可以在两个方向上使用:</p><ul><li>与 user/browser 请求的 URL 开始，它调用正确的Django视图提供任意参数给需要从URL提取它的值。</li><li>与标识对应的Django视图将被传递给它的参数的值开始，获得相关的URL。</li></ul><p>第一个前面讨论过，第二个是所谓的 URL 的反向解析、URL 反向匹配、 URL 反向查找或 URL 反转。</p><p>Django提供了用于执行 URL 反向，匹配不同层 URLs 的需要:</p><ul><li>Template: 使用url template tag</li><li>Python code: 使用 <code>reverse()</code> 函数</li><li>在相关的Django模型实例的URL处理更高级别的代码: <code>get_absolute_url()</code>方法</li></ul><p>就是给这个path取个名字，通过名字去找路径。即使修改了路径，只要名字没有修改，在其它部分里使用path名字的部分就不需要修改。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">  ...</span><br><span class="line">  path(<span class="string">'articles/&lt;int:year&gt;/'</span>, views.year_archive, name=<span class="string">'news-year-archive'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>你可通过使用这些模板代码获得:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;% url &apos;news-year-archive&apos; 2012 %&#125;&quot;&gt;</span><br><span class="line">&#123;# Or with the year in a template context variable: #&#125;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;% for yearvar in year_list %&#125;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;&#123;% url &apos;new-year-archive&apos; yearvar %&#125;&quot;&gt;&#123;&#123; yearvar &#125;&#125; Archive&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&#123;% end for %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>Or in Python Code:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redirect_to_year</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    year = <span class="number">2006</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'news-year-archive'</span>, args=(year,)))</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="命名URL模式"><a href="#命名URL模式" class="headerlink" title="命名URL模式"></a>命名URL模式</h3><p>要执行URL反向，你需要使用命名的URL模式(named URL patterns)。这个名称可以包含任何你喜欢的字符，而不仅限于Python names。<br>选择不太可能与其它应用程序名称相冲突的名字。如果你调用URL pattern comment 和其它应用程序做同样的事，URL <code>reverse()</code>查找取决于哪个模式是最后在项目的 <code>urlpattens</code> 的列表中。<br>为你的URL名称放一个前缀，后去可以从应用程序的名称派生，这样降低了冲突的可能。</p><p><br><br><br></p><h3 id="URL命名空间"><a href="#URL命名空间" class="headerlink" title="URL命名空间"></a>URL命名空间</h3><p>URL命名空间允许你唯一地反转 named URL patterns，即使不同的应用程序使用相同的URL名称。</p><p>一个URL命名空间有两个部分，两个都是字符串:</p><ul><li>application namespace</li><li>instance namespace</li></ul><p>命名空间URL使用特定的<code>:</code>操作符。<br>命名空间同样可以嵌套。命名的URL <code>sports:polls:index</code> ，会在顶级命名空间<code>sports</code>中定义的<code>polls</code>的命名空间中，寻找名为<code>index</code>的一个模式。</p><p><br></p><p><strong>反向命名空间URLs</strong></p><p>当给定一个命名空间URL（如<code>polls:index</code>）来解析时，Django将分割名称为几个部分，然后尝试一下查找:</p><ul><li>首先，Django查找 应用程序命名空间（如<code>polls</code>)，这将产生应用程序的实例列表。</li><li>如果有定义当前应用程序，Django查找并返回该实例的URL解析。</li><li>如果没有当前应用程序，Django查找默认应用程序实例。</li><li>如果没有默认的应用程序实例，Django会挑选最后部署的应用的实例。</li><li>如果提供的命名空间无法匹配步骤1中的应用程序命名空间，Django会尝试将此命名空间直接作为实例命名空间查找。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'author-polls/'</span>, include(<span class="string">'polls.urls'</span>, namespace=<span class="string">'author-polls'</span>)),</span><br><span class="line">    path(<span class="string">'publisher-polls/'</span>, include(<span class="string">'polls.urls'</span>, namespace=<span class="string">'publisher-polls'</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># polls/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">app_name = <span class="string">'polls'</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, views.IndexView.as_view(), name=<span class="string">'index'</span>),</span><br><span class="line">    path(<span class="string">'&lt;int:pk&gt;/'</span>, views.DetailView.as_view(), name=<span class="string">'detail'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>使用此设置，可能进行下面这些查找:</p><ul><li>如果其中一个实例就是当前这个，如果我们在实例 <code>author-polls</code> 渲染详情页面，<code>polls:index</code> 将解析到 <code>author-polls</code> 实例页面。即两个都会导致 <code>/author-polls/</code>。</li></ul><p>在 class-based view 的方法中: <code>reverse(&#39;polls:index&#39;, current_app=self.request.resolver_match.namespace)</code><br>在 模板中: <figure class="highlight plain"><figcaption><span>url 'polls:index' %&#125;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如果没有当前实例，xxxx</span><br><span class="line">- `author-polls:index`将总是解析到`author-polls`实例的index页面。</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**URL命名空间和included URLconfs**</span><br><span class="line"></span><br><span class="line">included URLconfs的应用程序命名空间可通过两种方式指定：</span><br><span class="line"></span><br><span class="line">- 首先，你可在 included URLconf 中设置一个 `app_name` 属性，它与 `urlpatterns` 属性同级。</span><br><span class="line"></span><br><span class="line">```py</span><br><span class="line"># polls/urls.py</span><br><span class="line">from django.urls import path</span><br><span class="line">form . import views</span><br><span class="line"></span><br><span class="line">app_name = &apos;polls&apos;</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&apos;&apos;, views.IndexView.as_view(), name=&apos;index&apos;),</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># urls.py</span><br><span class="line">from django.urls import include, path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&apos;polls/&apos;, include(&apos;polls.urls&apos;))</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h2 id="编写视图"><a href="#编写视图" class="headerlink" title="编写视图"></a>编写视图</h2><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/http/views/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/http/views/</a></p><p>视图函数，或 view short，是一个简单的Python函数——接收一个Web request，并返回一个Web response。这个response可以是HTML内容的Web页面，重定向，404错误，XML文档或图像…视图本身包含任意的逻辑是必要的返回响应。此代码可以选择你想要的任何地方，只要它是你的Python路径。对于将代码放在何处，默认的约定是把视图放在<code>views.py</code>文件中。</p><p><br></p><h3 id="一个简单的视图"><a href="#一个简单的视图" class="headerlink" title="一个简单的视图"></a>一个简单的视图</h3><p>一个简单的视图，返回当期的日期和时间:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">current_datetime</span><span class="params">(request)</span>:</span></span><br><span class="line">    now = datetime.datetime.now()</span><br><span class="line">    html = <span class="string">"&lt;html&gt;&lt;body&gt;It is now %s.&lt;/body&gt;&lt;/html&gt;"</span> % now</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(html)</span><br></pre></td></tr></table></figure><p>让我们看看这个代码:</p><ul><li><p>首先，我们从<code>django.http</code>模块导入了<code>HttpResponse</code>类，<code>datetime</code>库</p></li><li><p>接下来，我们定义了一个名为<code>current_datetime</code>的函数。这是视图函数，每个视图函数都接收一个HttpRequest对象作为第一个参数，通常称为请求<code>request</code>。<br>注意，视图函数的名称并不重要，它并没有以某种方式按顺序命名的Django来识别它。我们在这里调用<code>current_datetime</code>，因为这个名字清楚地表明它做什么。</p></li><li><p>此视图返回一个包含生成的响应的HttpResponse对象。每个视图函数负责返回HttpResponse对象。</p></li></ul><blockquote><p>Django’s Time Zone<br>Django includes a TIME_ZONE setting that defaults to America/Chicago. This probably isn’t where you live, so you might want to change it in your settings file.</p></blockquote><p><br><br><br></p><h3 id="映射URLs到视图"><a href="#映射URLs到视图" class="headerlink" title="映射URLs到视图"></a>映射URLs到视图</h3><p>因此，要回顾一下，这个视图函数返回一个HTML页面，其中包括当前的日期和时间。要显示此视图的特定URL，你需要创建一个URLconf。</p><p><br><br><br></p><h3 id="返回错误"><a href="#返回错误" class="headerlink" title="返回错误"></a>返回错误</h3><p>在Django中返回HTTP error codes很容易。存在其它常见的HTTP状态码的HttpResponse子类(subclasses)。可在文档中找到所有可用的子类。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse, HttpResponseNotFound</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">if</span> foo:</span><br><span class="line">        <span class="keyword">return</span> HttpResponseNotFound(<span class="string">'&lt;h1&gt;Page not found&lt;/h1&gt;'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'&lt;h1&gt;Page was found&lt;/h1&gt;'</span>)</span><br></pre></td></tr></table></figure><p>没有对每个可能的HTTP响应码一个专门的子类，由于HttpResponse文档中，还可通过HTTP状态码到构造函数的HttpResponse创建你喜欢的任何状态码:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(status=<span class="number">201</span>)</span><br></pre></td></tr></table></figure><p>由于404错误是目前最常见的HTTP错误，处理它有简单的方法。</p><p><br></p><p><strong>The Http404 exception</strong></p><p>class <code>django.http.Http404</code></p><p>当你返回一个如HttpResponseNotFound的错误，你负责定义产生的错误页面的HTML:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> polls.models <span class="keyword">import</span> Poll</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(request, poll_id)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = Poll.objects.get(pk=poll_id)</span><br><span class="line">    <span class="keyword">except</span> Poll.DoesNotExist:</span><br><span class="line">        <span class="keyword">raise</span> Http404(<span class="string">"Poll does not exist"</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'polls/detail.html'</span>, &#123;<span class="string">'poll'</span>: p&#125;)</span><br></pre></td></tr></table></figure><p>当Django返回一个404时，为了显示自定义的HTML，你可以创建一个名为 <code>404.html</code>的模板并放在模板树顶层。</p><p><br><br><br></p><h3 id="自定义错误视图"><a href="#自定义错误视图" class="headerlink" title="自定义错误视图"></a>自定义错误视图</h3><p>Django的默认错误应该能满足大多数情况，但你也可以自定义行为。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># page_not_found()视图会被 handler404覆盖</span></span><br><span class="line">handler404 = <span class="string">'mysite.views.my_custom_page_not_found_view'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># server_error()视图会被handler500覆盖</span></span><br><span class="line">handler500 = <span class="string">'mysite.views.my_custom_error_view'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># permission_denied()视图会被handler403覆盖</span></span><br><span class="line">handler403 = <span class="string">'mysite.views.my_custom_permission_denied_view'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bad_request()会被handler400覆盖</span></span><br><span class="line">handler400 = <span class="string">'mysite.views.my_custom_bad_request_view'</span></span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>参见<br>Use the CSRF_FAILURE_VIEW setting to override the CSRF error view.</p></blockquote><p><br></p><p><strong>测试自定义错误视图</strong></p><p>为了测试自定义错误处理程序的响应，提高在测试视图中的相应的异常:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> PermissionDenied</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.test <span class="keyword">import</span> SimpleTestCase, override_settings</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">response_error_handler</span><span class="params">(request, exception=None)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Error handler content'</span>, status=<span class="number">403</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permission_denied_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> PermissionDenied</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'403/'</span>, permission_denied_view),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">handler403 = response_error_handler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ROOT_URLCONF must specify the module that contains handler403 = ...</span></span><br><span class="line"><span class="meta">@override_settins(ROOT_URLCONF=__name__)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomErrorHandlerTests</span><span class="params">(SimpleTestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_handler_renders_template_response</span><span class="params">(self)</span>:</span></span><br><span class="line">        response = self.client.get(<span class="string">'/403/'</span>)</span><br><span class="line">        <span class="comment"># Make assertions on the response here. For example:</span></span><br><span class="line">        self.assertContains(response, <span class="string">'Error handler content'</span>, status_code=<span class="number">403</span>)</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="视图装饰器"><a href="#视图装饰器" class="headerlink" title="视图装饰器"></a>视图装饰器</h2><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/http/decorators/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/http/decorators/</a></p><p>Django提供了可应用于视图，以支持各种HTTP特征的几个装饰器(decorators)。</p><p><br></p><h3 id="允许HTTP方法"><a href="#允许HTTP方法" class="headerlink" title="允许HTTP方法"></a>允许HTTP方法</h3><p><code>django.views.decorators.http</code>中的装饰器可用于限制访问基于请求方法的视图。如果条件不具备装饰器会返回<code>django.http.HttpResponseNotAllowed</code>。</p><ul><li><code>require_http_methods(request_method_list)</code></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.http <span class="keyword">import</span> require_http_methods</span><br><span class="line"></span><br><span class="line"><span class="meta">@require_http_methods(["GET", "POST"])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># I can assume now that only GET or POST requests make it this far</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li><code>require_GET()</code>：装饰器要求视图只接受GET方法</li><li><code>require_POST()</code>：装饰器要求视图只接受POST方法</li><li><code>require_safe()</code>：装饰器要求视图只接受GET和HEAD方法。这些方法通常被认为是安全的的。</li></ul><p><br><br><br></p><h3 id="条件视图处理"><a href="#条件视图处理" class="headerlink" title="条件视图处理"></a>条件视图处理</h3><p>装饰器<code>django.views.decorators.http</code>可用来控制特定视图的缓存行为。</p><ul><li><code>condition(etag_func=None, last_modified_func=None)</code></li><li><code>etag(etag_func)</code></li><li><code>last_modified(last_modified_func)</code></li></ul><p>这些装饰器可用来生成ETag和Last-Modified headers。</p><p><br><br><br></p><h3 id="GZip压缩"><a href="#GZip压缩" class="headerlink" title="GZip压缩"></a>GZip压缩</h3><p>装饰器<code>django.views.decorators.gzip</code>在每个视图上控制内容压缩。</p><ul><li><code>gzip_page()</code>：如果浏览器允许使用gzip压缩，这个装饰器压缩内容。</li></ul><p><br><br><br></p><h3 id="Vary-Headers"><a href="#Vary-Headers" class="headerlink" title="Vary Headers"></a>Vary Headers</h3><p>装饰器<code>django.views.decorators.vary</code>可用于根据特定请求头来控制缓存。</p><ul><li><code>vary_on_cookie(func)</code></li><li>vary_on_headers(<code>*headers</code>)</li></ul><p><br><br><br></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>装饰器<code>django.views.decorators.chache</code>控制服务器和客户端的缓存。</p><ul><li>cache_control(<code>**kwargs</code>)：此装饰器加入所有的关键字参数给它修补响应的Cache-Control头</li><li><code>never_cache(view_func)</code>： 此装饰器添加<code>Cache-Control: max-age=0, no-cache, no-store, must-revalidate</code>头为响应指示页面不该被缓存。</li></ul><p><br><br><br><br><br></p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/http/file-uploads/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/http/file-uploads/</a></p><p>Django处理文件上传时，文件最终会位于<code>attr:request.FILES&lt;django.http.HttpRequest.FILES&gt;</code></p><p><br><br><br><br><br></p><h2 id="快捷函数"><a href="#快捷函数" class="headerlink" title="快捷函数"></a>快捷函数</h2><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/http/shortcuts/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/http/shortcuts/</a></p><p>包<code>django.shortcuts</code>收集助手函数或跨堆积MVC的类。换句话说，为了方便起见，这些函数/类引入受控耦合。</p><p><br></p><h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><ul><li>`render(request, template_name, context=None, content_type=None, status=None, using=None)：将给定的模板与给定的上下文字典组合在一起，并以渲染的文本返回一个HttpResponse对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 必选参数</span><br><span class="line">request: 用于生成此响应的请求对象</span><br><span class="line">template_name: 要使用的模板名称</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 可选参数</span><br><span class="line">context: 要添加到模板上下文的值的字典</span><br><span class="line">content_type 用于结果文档的MIME类型默认行为</span><br><span class="line">status: 响应的状态码，默认200</span><br><span class="line">using: 用于加载模板的模板引擎</span><br></pre></td></tr></table></figure><p>栗子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># view code here</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'myapp/index.html'</span>, &#123;<span class="string">'foo'</span>: <span class="string">'bar'</span>&#125;, content_type=<span class="string">'application/xhtml+xml'</span>)</span><br></pre></td></tr></table></figure><p>此栗子相当于:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> loader</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># view code here...</span></span><br><span class="line">    t = loader.get_template(<span class="string">'myapp/index.html'</span>)</span><br><span class="line">    c = &#123;<span class="string">'foo'</span>: <span class="string">'bar'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(t.render(c, request), content_type<span class="string">'application/xhtml+xml)</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="redirect"><a href="#redirect" class="headerlink" title="redirect()"></a>redirect()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redirect(to, permanent=False, *args, **kwargs)</span><br><span class="line"># 将一个HttpResponseRedirect返回传递到参数的适当URL</span><br><span class="line"></span><br><span class="line">- A model: the model&apos;s get_absolute_url() function will be called.</span><br><span class="line">- A view name, possibly with arguments: reverse() will be used to reverse-resolve the name.</span><br><span class="line">- An absolute or relative URL, which will be used as-is for the redirect location.</span><br><span class="line"></span><br><span class="line">By default issues a temporary redirect; pass permanent=True to issue a permanent redirect.</span><br></pre></td></tr></table></figure><p>栗子:</p><p>你可以在多种方式中使用<code>redirect()</code>函数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By passing some object; that object's get_absolute_url() method will be called to figure out the redirect URL</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    obj = MyModel.objects.get(...)</span><br><span class="line">    <span class="keyword">return</span> redirect(obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># By passing the name of a view and optionally some positional or keyword arguments; the URL will be reverse resolved using the reverse() method</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ridirect(<span class="string">'some-view-name'</span>, foo=<span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># By passing a hardcoded URL to redirect to</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">'/some/url/'</span>)</span><br><span class="line"><span class="comment"># This also works with full URLs</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">'https://example.com/'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，redirect()返回一个临时重定向。设置parmanent=True修改为永久</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    obj = MyModel.objects.get(...)</span><br><span class="line">    <span class="keyword">return</span> redirect(obj, permanent=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="get-object-or-404"><a href="#get-object-or-404" class="headerlink" title="get_object_or_404()"></a>get_object_or_404()</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get_object_or_404(klass, *args, **kwargs)</span><br><span class="line"><span class="comment"># Calls get() on a given model manager, but it raises Http404 instead of the model's DoesNotExist exception.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 必选参数</span></span><br><span class="line">klass  <span class="comment"># A Model class, a Manager, or a QuerySet instance from which to get the object.</span></span><br><span class="line">**kwargs  <span class="comment"># Lookup parameters, which should be in the format accepted by get() and filter().</span></span><br></pre></td></tr></table></figure><p>栗子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_object_or_404</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(reqeust)</span>:</span></span><br><span class="line">    obj = get_object_or_404(MyModel, pk=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此栗相当于</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        obj = MyModel.objects.get(pk=<span class="number">1</span>)</span><br><span class="line">    execpt MyModel.DoesNotExist：</span><br><span class="line">        <span class="keyword">raise</span> Http404(<span class="string">"No MyModel matches the given query."</span>)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="get-list-or-404"><a href="#get-list-or-404" class="headerlink" title="get_list_or_404()"></a>get_list_or_404()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get_list_or_404(lkass, *args, **kwargs)</span><br><span class="line"># Returns the result of filter() on a given model manager cast to a list, raising Http404 if the resulting list is empty.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 必选参数</span><br><span class="line">klass  # A Model, Manager or QuerySet instance from which to get the list.</span><br><span class="line">**kwargs  # Lookup parameters, which should be in the format accepted by get() and filter().</span><br></pre></td></tr></table></figure><p>栗子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get all published objects from MyModel</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> get_list_or_404</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    my_objects = get_list_or_404(MyModel, published=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此栗子相当于</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(reqeust)</span>:</span></span><br><span class="line">    my_objects = list(MyModel.objects.filter(published=<span class="keyword">True</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> my_objects:</span><br><span class="line">        <span class="keyword">raise</span> Http404(<span class="string">"No MyModel matches the given query."</span>)</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="通用视图"><a href="#通用视图" class="headerlink" title="通用视图"></a>通用视图</h2><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/http/generic-views/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/http/generic-views/</a><br>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/ref/class-based-views/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/ref/class-based-views/</a></p><p><br></p><h3 id="基本视图与通用视图"><a href="#基本视图与通用视图" class="headerlink" title="基本视图与通用视图"></a>基本视图与通用视图</h3><p>Base class-based views 可以被认为是父视图，其可以通过本身被使用，或者从继承。它们可能不提供所有项目所需要的功能，在这种情况下，有混入其中的扩至基视图可以做。</p><p>Django generic views are built off of those base views，被开发作为一个快捷功能，用于公共使用模式（如显示对象的详细信息）。They take certain common idioms and patterns found in view development and abstract them so that you can quickly write common views of data without having to repeat yourself.<br>大多数的通用视图需要<code>QuerySet</code>键——它是一个<code>QuerySet</code>实例。</p><p><br><br><br><br><br></p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/http/middleware/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/http/middleware/</a><br>内检中间件: <a href="https://docs.djangoproject.com/zh-hans/2.1/ref/middleware/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/ref/middleware/</a></p><p>中间件是Django 请求/响应 处理的钩子框架。它是一个轻量级的、低级的插件系统，用于全局改变Django的输入或输出。</p><p>每个中间件组件负责做一些特定的功能。如Django的一个中间件组件<code>AuthenticationMiddleware</code>，它使用会话将用于与请求关联起来。<br>文档中解释了中间件是如何工作的，如何激活中间件，如何编写自己的中间件。Django具有一些内置的中间件，你可以直接使用它们。</p><p><br><br><br><br><br></p><h2 id="如何使用会话"><a href="#如何使用会话" class="headerlink" title="如何使用会话"></a>如何使用会话</h2><p>sessions: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/http/sessions/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/http/sessions/</a></p><p>Django是支持匿名会话的。会话框架允许你基于每个站点访问者存储和检索任意数据。它在服务端存储数据并提供cookie的发送和接收。<br>Cookie包含会话ID，而不是数据本身。</p><p><br></p><h3 id="打开会话"><a href="#打开会话" class="headerlink" title="打开会话"></a>打开会话</h3><p>会话通过配置一个中间件(<code>django.contrib.sessions.middleware.SessionMiddleware</code>)实现。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="使用表单"><a href="#使用表单" class="headerlink" title="使用表单"></a>使用表单</h1><p>docs: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/forms/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/forms/</a></p><p>介绍Web表单的基本内容以及它们在Django中是如何处理的。</p><p>除非搭建的网站和应用只发布内容而不接收访问者的输入，否则你就需要理解和使用表单。<br>Django提供了一系列的工具和库来帮助构建表单来接收网站访问者的输入，然后处理以及响应这些输入。</p><p><br></p><h2 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h2><p>在HTML中，表单是在<code>&lt;form&gt;...&lt;/form&gt;</code>中的一些元素，它允许访客做一些类似输入文档、选择选项、操作对象或空间等动作，然后发送这些信息到服务端。</p><p>一些表单界面元素(文本框或复选框)非常简单并内置在HTML中。其它会复杂些，如弹出日期选择、允许你移动滑块或操作控件，一般通过使用JavaScript，CSS以及HTML表单中的<code>&lt;input&gt;</code>元素来实现这些效果。</p><p>表单必须指定两样东西:</p><ul><li>何地: 负责响应用户输入数据的URL地址</li><li>如何: 数据如何请求使用的HTTP方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如，Django admin登录表单包含了一些&lt;input&gt;元素：</span><br><span class="line">用户名用type=&quot;text&quot;，密码用type=&quot;password&quot;，登录按钮用type=&quot;submit&quot;。</span><br><span class="line">它还包含一些用户看不到的隐藏文本字段，Django用它们来决定下一步行为。</span><br><span class="line"></span><br><span class="line">它还告诉浏览器表单数据应该发往&lt;form&gt;的action属性指定的URL——`/admin/`，并且应该使用method属性指定的HTTP方法——post。</span><br><span class="line"></span><br><span class="line">当&lt;input type=&quot;submit&quot; value=&quot;Log in&quot;&gt;元素被触发的时候，数据会发送到`/admin/`。</span><br></pre></td></tr></table></figure><p><br></p><p><strong>GET和POST</strong></p><p>处理表单时只会用到GET和POST两种方法。<br>Django的登录表单使用POST方法传输数据，在这个方法中浏览器会封装表单数据，为了传输会进行编码，然后发送到服务端并接收它的响应。</p><p>相比之下，GET方法将提交的数据捆绑到一个字符串中，并用它来组成一个URL。该URL包含了数据要发送的地址以及一些键值对应的数据。如<code>https://docs.djangoproject.com/search/?q=forms&amp;release=1</code></p><p>任何可用于更改系统状态的请求都应该使用POST。<br>GET方法也不适合密码表单，因为密码会出现在URL中，也是也会出现在浏览器的历史记录以及服务器的日志中，而且都是以纯文本都形式。它也不适合处理大量的数据或者二进制数据。在Web应用的管理表单中使用GET请求具有安全隐患：攻击者很容易通过模拟请求来访问系统的敏感数据。POST方法通过与其它像CSRF这样的保护措施配合使用，能对访问提供更多控制。</p><p><br><br><br></p><h2 id="Django在表单中的角色"><a href="#Django在表单中的角色" class="headerlink" title="Django在表单中的角色"></a>Django在表单中的角色</h2><p>处理表单是一件挺复杂的事情。许多不同的数据可能在一张表单中准备显示，渲染成HTML，使用方便的界面进行编辑，传到服务器，验证和清理数据，然后保存或跳过进行下一步处理。</p><p>Django会处理设计表单的三个不同部分:</p><ul><li>准备并重组数据，以便下一步的渲染</li><li>为数据创建HTML表单</li><li>接收并处理客户端提交的表单和数据</li></ul><p>你可以手动编写代码来实现，但Django可以帮你完成所有这些工作。</p><p><br><br><br></p><h2 id="Django中的表单"><a href="#Django中的表单" class="headerlink" title="Django中的表单"></a>Django中的表单</h2><p>Web应用中所说的表单，可能指的是HTML <code>&lt;form&gt;</code>，或者是生成了它的Django Form，再或者是提交时返回的结构化数据，亦或是这些端到端作业的合集。</p><p><br></p><p><strong>Django的Form类</strong></p><p>Django表单系统的核心组件是Form类。它与Django模型描述对象的逻辑结构、行为以及它呈现给我们内容的形式的方式大致相同，Form类描述一张表单并决定它如何工作及呈现。<br>类似于模型类的字段映射到数据库字段的方式，表单类的字段会映射到HTML表单的<code>&lt;input&gt;</code>元素。ModelForm通过Form映射模型类的字段到HTML表单的<code>&lt;input&gt;</code>元素。<br>表单字段本身也是类，他们管理表单数据并在提交表单时执行验证。DateField和FileField处理的数据类型差别很大，所以必须用来处理不同的字段。<br>在浏览器中，表单字段以HTML控件的形式展示给我们。每个字段类型都有与之相匹配的控件类，但必要时可以覆盖。</p><p><br></p><p><strong>实例化、处理和渲染表单</strong></p><p>在Django中渲染一个对象的时候，我们通常：</p><ul><li>在视图中获取它</li><li>将它传递给模板上下文</li><li>使用模板变量将它扩展为HTML标记</li></ul><p>在模板中渲染表单几乎与渲染任何其他类型的对象的一样，但是存在一些关键性的差异。<br>如果模型实例不包含数据，在模板中对它做任何处理几乎没什么用。但完全有理由用来渲染一张空表单——当我们希望用户来填充的时候就会这么做。<br>所以当我们在视图中处理模型实例时，我们一般从数据库中获取它。当我们处理表单时，我们一般在视图中实例化它。</p><p>当我们实例化表单时，我们可以选择让它为空或者对它预先填充：</p><ul><li>来自已经保存的模型实例的数据</li><li>从其它来源获取的数据</li><li>从前面一个HTML表单提交过来的数据</li></ul><p><br><br><br></p><h2 id="构建一张表单"><a href="#构建一张表单" class="headerlink" title="构建一张表单"></a>构建一张表单</h2><p><strong>需要完成的工作</strong></p><p>假设你希望在你的网站上创建一张简易的表单，来获取用户的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/your-name/&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;your_name&quot;&gt;Your name: &lt;/label&gt;</span><br><span class="line">    &lt;input id=&quot;your_name&quot; type=&quot;text&quot; name=&quot;your_name&quot; value=&quot;&#123;&#123; current_name &#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;OK&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>这告诉浏览器将表单数据返回给URL <code>/your-name/</code>，并使用POST方法。它将显示一个标签为”Your name:”的文本字段，以及一个”OK”按钮。如果模板上下文包含一个<code>current_name</code>变量，它会被预填充到<code>your_name</code>字段。<br>你需要一个视图来渲染这个包含HTML表单的模板，并能适当提供<code>current_name</code>字段。<br>提交表单时，发送给服务器的POST请求将包含表单数据。</p><p>现在，你还需要一个与该<code>/your-name/</code> URL相对应的视图，该视图将在请求中找到相应的键值对，然后对其进行处理。</p><p><br></p><p><strong>在Django中构建一张表单</strong></p><ul><li>Form类</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># forms.py</span></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span><span class="params">(forms.Form)</span>:</span></span><br><span class="line">    your_name = forms.CharField(label=<span class="string">'Your name'</span>, max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Form表单实例有一个`is_valid()`方法，它运行所有的字段验证。当此方法被调用时，如果所有字段包含有效数据，它将会：</span></span><br><span class="line"><span class="comment"># - 返回True</span></span><br><span class="line"><span class="comment"># - 将表单数据放到它的cleaned_data属性中</span></span><br></pre></td></tr></table></figure><p>这样整个表单在第一次渲染时，会显示如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;lable for=&quot;your_name&quot;&gt;Your name: &lt;/label&gt;</span><br><span class="line">&lt;input id=&quot;your_name&quot; type=&quot;text&quot; name=&quot;your_name&quot; maxlength=&quot;100&quot; required&gt;</span><br></pre></td></tr></table></figure><p>注意它没有包含<code>&lt;form&gt;</code>标签和提交按钮。我们必须在模板中提供。</p><p><br></p><ul><li>视图</li></ul><p>发回Django网站的表单数据由视图来处理，一般和发布这个表单用的是同一个视图。这允许我们重用一些相同的逻辑。</p><p>为了处理表单，我们需要将它实例化到我们希望发布的URL的对应的视图中：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .forms <span class="keyword">import</span> NameForm</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># if this is a POST request we need to process the form data</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        <span class="comment"># create a form instance and populate it with data from the request</span></span><br><span class="line">        form = NameForm(request.POST)</span><br><span class="line">        <span class="comment"># check whether it's valid</span></span><br><span class="line">        <span class="keyword">if</span> form.is_valid():</span><br><span class="line">            <span class="comment"># process the data in form.cleaned_data as required</span></span><br><span class="line">            <span class="comment"># ...</span></span><br><span class="line">            <span class="comment"># redirect to a new URL</span></span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(<span class="string">'/thanks/'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        form = NameForm()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'name.html'</span>, &#123;<span class="string">'form'</span>: form&#125;)</span><br></pre></td></tr></table></figure><p>如果我们访问这个视图用的是GET请求，它会创建一个空的表单实例并将其放置在模板上下文中进行渲染。<br>如果表单提交用的是POST请求，那么该视图再次创建一个表单实例并使用请求中的数据填充它。<code>form=NameForm(request.POST)</code>，这叫绑定数据到表单。<br>调用表单的<code>is_valid()</code>方法，如果不为True，就带着表单返回到模板。这次表单不在为空，所以HTML表单将用之前提交的数据进行填充，放到可以根据需要进行编辑和修正的位置。<br>如果<code>is_valid()</code>为True，我们就能在cleaned_data属性中找到所有通过验证的表单数据。我们可以发送一个HTTP重定向告诉浏览器下一步去向之前用这些数据更新数据库或做其它处理。</p><p><br></p><ul><li>模板</li></ul><p>没有必要在模板<code>name.html</code>中做过多的操作。举个栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/your-name/&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &#123;&#123; form &#125;&#125;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>所有的表单字段机器属性都将通过Django模板语言从 <code></code> 中被解包成HTML标记。</p><blockquote><p>表格和跨站请求伪造保护<br>Django自带一个简单易用的跨站请求伪造保护。当通过POST方法提交一张启用了CSRF防护的表单时，你必须使用上例中这样的模板标签 csrf_token。但是，由于CSRF防护在模板中没有与表单直接绑定，因此这个标签在本页文档之后的示例中都将被忽略。</p></blockquote><p>现在我们有了一个可以工作的Web表单，它通过一张Django Form描述，由一个视图来处理并渲染成一个HTML <code>&lt;form&gt;</code>。</p><p><br><br><br></p><h2 id="详解Django的Form类"><a href="#详解Django的Form类" class="headerlink" title="详解Django的Form类"></a>详解Django的Form类</h2><p>所有表单都作为<code>django.forms.Form</code>或者<code>django.forms.ModelForm</code>的子类来创建。</p><p>如果你的表单是要直接用来添加或编辑Django模型，用ModelForm，可以省时省力省代码，因为它会根据Model类构建一张对应字段及其属性的表单。</p><p><br></p><p><strong>绑定和未绑定的表单实例</strong></p><p>bound和unbound forms之间的区别非常重要：</p><ul><li>未绑定的表单没有与其关联的数据。当渲染给用户时，它会是空的或者包含默认值。</li><li>绑定的表单拥有已提交的数据，因此可用来判断数据是否合法。</li></ul><p>表单的<code>is_bound</code>属性将告诉你一张表单是否具有绑定的数据。</p><p><br></p><p><strong>字段详解</strong></p><p>栗子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># forms.py</span></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactForm</span><span class="params">(forms.Form)</span>:</span></span><br><span class="line">    subject = forms.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    message = forms.CharField(widget=forms.Textarea)</span><br><span class="line">    sender = forms.EmailField()</span><br><span class="line">    cc_myself = forms.BooleanField(required=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><ul><li>控件</li></ul><p>每个表单字段都有一个相对应的控件类，这个控件类又有对应的HTML表单控件，比如<code>&lt;input type=&quot;text&quot;&gt;</code>。</p><ul><li>字段数据</li></ul><p>无论用表单提交了什么数据，一旦通过调用<code>is_valid()</code>验证成功，已验证的表单数据将被放到<code>form.cleaned_data</code>字典中。这里的数据已经很好的为你转化为Python类型。如cc_myself会被转化成一个布尔值。同样的，字段 IntegerField 和 FloatField 的值分别会被转化为Python的 int 和 float 类型。</p><p>栗子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> form.is_valid():</span><br><span class="line">    subjetct = form.cleaned_data[<span class="string">'subject'</span>]</span><br><span class="line">    message = form.cleaned_data[<span class="string">'message'</span>]</span><br><span class="line">    sender = form.cleaned_data[<span class="string">'sender'</span>]</span><br><span class="line">    cc_myself = form.cleaned_data[<span class="string">'cc_myself'</span>]</span><br><span class="line"></span><br><span class="line">    recipients = [<span class="string">'info@example.com'</span>]</span><br><span class="line">    <span class="keyword">if</span> cc_myself:</span><br><span class="line">        recipients.append(sender)</span><br><span class="line"></span><br><span class="line">    send_mail(subject, message, sender, recipients)</span><br><span class="line">    <span class="keyword">return</span> HttpResponseRedirect(<span class="string">'/thanks/'</span>)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="使用表达模板"><a href="#使用表达模板" class="headerlink" title="使用表达模板"></a>使用表达模板</h2><p>你只需要将表单实例放到模板的上下文中即可。</p><p><br></p><p><strong>表单渲染选项</strong></p><blockquote><p>额外表单模板标签<br>不要忘记，一张表单的输出不包含外层<code>&lt;form&gt;</code>标签以及submit控件。这些必须由你自己提供。</p></blockquote><p>对于<code>&lt;label&gt;</code>, <code>&lt;input&gt;</code>对，还有其它输出选项：</p><ul><li><figure class="highlight plain"><figcaption><span>form.as_table &#125;&#125;```将渲染它们作为表格包裹在`<tr>`标记中</tr></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- ```&#123;&#123; form.as_p &#125;&#125;```将渲染它们包裹在`&lt;p&gt;`标记中</span><br><span class="line">- ```&#123;&#123; form.as_ul &#125;&#125;```将渲染它们包裹在`&lt;li&gt;`标记中</span><br><span class="line"></span><br><span class="line">注意，你必须自己提供外层的`&lt;table&gt;`或`&lt;ul&gt;`元素。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 模板</span><br><span class="line"></span><br><span class="line">templates: &lt;https://docs.djangoproject.com/zh-hans/2.1/topics/templates/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作为一个Web框架，Django需要一种动态生成HTML的便捷方法。最常用的方法依赖于模板。模板包含所需HTML输出的静态部分以及描述动态内容将被插入的一些特殊语法。</span><br><span class="line"></span><br><span class="line">Django项目可以配置一个或多个模板引擎（或者不使用模板引擎）。Django后端内置一个自己的模板系统，创造性地称为Django Template Language(DTL)。后端也可以使用第三方提供的其它可用的模板语言。</span><br><span class="line">Django template language是Django自己的模板系统。这是一个很好的模板库，即使它是相当僵硬和使用时带有它自己特质。如果你没有紧迫的理由需要去选择另一个后端，则应该使用DTL。</span><br><span class="line"></span><br><span class="line">Django定义了一个标准的API，用于加载和渲染模板，而不用考虑后端的模板系统。加载包括查找给定标识符的模板并对其进行预处理，通常将其编译的结果保存在内存中。渲染工具将上下文数据插入模板并返回结果字符串。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 模板引擎的支持</span><br><span class="line"></span><br><span class="line">```py</span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;,</span><br><span class="line">        &apos;DIRS&apos;: [],</span><br><span class="line">        &apos;APP_DIRS&apos;: True,</span><br><span class="line">        &apos;OPTIONS&apos;: &#123;</span><br><span class="line">        # ... some options here ...</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># BACKEND: 实现Django模板后台API，内建后台有:</span><br><span class="line"># - django.template.backends.django.DjangoTemplates</span><br><span class="line"># - django.template.backends.jinja2.Jinja2</span><br><span class="line"># DIRS: 定义一个目录列表，其中模板引擎应该寻找的源文件</span><br><span class="line"># APP_DIRS: 告诉引擎是否应该在安装的应用内寻找模板</span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Django-Template-Language"><a href="#Django-Template-Language" class="headerlink" title="Django Template Language"></a>Django Template Language</h1><p>参考:</p><ul><li><a href="https://docs.djangoproject.com/zh-hans/2.1/topics/templates/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/templates/</a></li><li><a href="https://docs.djangoproject.com/zh-hans/2.1/ref/templates/language/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/ref/templates/language/</a></li></ul><p>Django模板引擎提供了一种强大的mini-language，用于定义应用程序的面向用户层，鼓励应用程序和表示逻辑的清晰分离。任何了解HTML的人都可以维护模板，不需要Python的知识。</p><p>Django模板语言其实和Jinja2类似，只不过Jinja2更自由些。</p><p><br></p><h2 id="Django模板语言"><a href="#Django模板语言" class="headerlink" title="Django模板语言"></a>Django模板语言</h2><p>本文档解释了Django模板系统的语言语法。<br>Django的模板语言只在功能和易用性之间取得平衡。它旨在让那些习惯使用HTML的人感到舒服。如果你对其它模板语言(Smart, Jinja2)有任何接触，那么您应该对Django的模板感到宾至如归。</p><blockquote><p>哲学<br>Django模板系统不仅仅是嵌入到HTML中的Python。模板系统用于表示，而不是程序逻辑。<br>Django模板系统提供的tags功能与某些编程结构类似——<code>if</code>标签用于布尔测试，<code>for</code>标签用于循环…但这些并不是简单地作为相应的Python代码执行，并且模板系统不会执行任意Python表达式。</p></blockquote><p><br><br><br></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>Templates</p><p>一个模板是一个简单的文本文件。它可以生成任何基于文本的格式(HTML, XML, CSV…)。</p><p>模板包含变量(variables)，这些变量在评估模板时将替换为值，而变量则包含控制模板逻辑的标签(tags)。</p><p>下面是一个最小的模板示例，每个元素将在后面解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base_generic.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;&#123;&#123; section.title &#125;&#125;&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">&lt;h1&gt;&#123;&#123; section.title &#125;&#125;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&#123;% for story in story_list %&#125;</span><br><span class="line">&lt;h2&gt;</span><br><span class="line">  &lt;a href=&quot;&#123;&#123; story.get_absolute_url &#125;&#125;&quot;&gt;</span><br><span class="line">      &#123;&#123; story.headline|upper &#125;&#125;</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&lt;/h2&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; story.tease|truncatewords:&quot;100&quot; &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么使用基于文本而不是基于XML的模板？我们希望Django的模板语言不仅可用于XML/HTML模板。在互联网上，我们将其用于电子邮件、JS和CSV。你可将模板语言用于任何基于文本的格式。<br>让人类编辑XML是虐待狂!</p></blockquote><p><br><br><br></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Variables</p><p>变量像这样: <figure class="highlight plain"><figcaption><span>variable &#125;&#125;```。当模板引擎遇到变量时，它会计算该变量并将其替换为结果。变量名由字母、数字和下划线组成，但不能以下划线开头。点(`.`)也出现在变量部分，尽管它具有特殊含义。重要的是，变量名称中不能包含空格或标点符号。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从技术上来说，当模板系统遇到一个点时，它会按照一下顺序尝试查找:</span><br><span class="line"></span><br><span class="line">- 字典</span><br><span class="line">- 属性或方法</span><br><span class="line">- 数字索引</span><br><span class="line"></span><br><span class="line">在上面的例子中，```&#123;&#123; section.title &#125;&#125;```将替换为section对象的title属性。</span><br><span class="line">如果使用不存在的 变量，模板系统将插入`srting_if_invalid`选项的值，默认情况下设置为空`&apos;&apos;`。</span><br><span class="line"></span><br><span class="line">请注意，模板表达式```&#123;&#123; foo.bar &#125;&#125;```中的bar将被解释为文字字符串，而不使用变量bar的值(如果上下文中存在)。</span><br><span class="line"></span><br><span class="line">可能无法访问以下划线开头的变量属性，因为它们通常被视为私有。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 过滤器</span><br><span class="line"></span><br><span class="line">Filters</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你可使用过滤器(filters)修改要显示的变量。</span><br><span class="line">过滤器像这样: ```&#123;&#123; name|lower &#125;&#125;```。这会在通过小写过滤器后显示变量的值，后者将文本转换为小写。使用管道(`|`)应用过滤器。</span><br><span class="line"></span><br><span class="line">过滤器可以链接，一个过滤器的输出应用于下一个过滤器。```&#123;&#123; text|escape|linebreaks &#125;&#125;```。```&#123;&#123; text|escape|linebreaks &#125;&#125;```是转义文本内容，然后将换行符转换为`&lt;p&gt;`标签的常用习惯写法。</span><br><span class="line"></span><br><span class="line">一些过滤会使用参数，过滤器参数如下所示: ```&#123;&#123; bio|truncatewords:30 &#125;&#125;```，这将显示变量bio的前30个单词。</span><br><span class="line">过滤参数包含的空格必须使用引号引用，如: ```&#123;&#123; list|join:&quot;, &quot; &#125;&#125;```。</span><br><span class="line"></span><br><span class="line">Django提供了大约60个内置模板过滤器。可在[built-in filter reference](https://docs.djangoproject.com/zh-hans/2.1/ref/templates/builtins/#ref-templates-builtins-filters)查看全部。</span><br><span class="line"></span><br><span class="line">以下是一些常用的模板过滤器:</span><br><span class="line"></span><br><span class="line">- default</span><br><span class="line">如果变量为false或者为空，使用给定的默认值。</span><br><span class="line"></span><br><span class="line">```jinja2</span><br><span class="line">&#123;&#123; value|default:&quot;nothing&quot; &#125;&#125;</span><br></pre></td></tr></table></figure></p><ul><li>length<br>返回值得长度，使用与strings和lists。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; value|length &#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>filesizeformat<br>将值格式化为人类可读的文件大小(<code>12KB</code>, <code>2MB</code>…)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; value|filesizeformat &#125;&#125;</span><br></pre></td></tr></table></figure><p>当然，你可以创建自己的自定义模板过滤器。</p><p><br><br><br></p><h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>Tags</p><p>标记像这样: <figure class="highlight plain"><figcaption><span>tag %&#125;```。标签比变量更复杂：有些在输出中创建文本，有些通过执行循环或逻辑来控制流，有些则将外部信息加载到模板中以供以后的变量使用。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">有些标签需要开始和结束标记: ```&#123;% tag %&#125;```...```&#123;% endtag %&#125;```。</span><br><span class="line"></span><br><span class="line">Django附带了大约24个内置模板标签。可查看[build-in tag reference](https://docs.djangoproject.com/zh-hans/2.1/ref/templates/builtins/#ref-templates-builtins-tags)。</span><br><span class="line"></span><br><span class="line">下面是一些常用的标记:</span><br><span class="line"></span><br><span class="line">- for</span><br><span class="line">循环遍历数组中的每个项。</span><br><span class="line"></span><br><span class="line">```jinja2</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;% for athlete in athlete_list %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; athlete.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;% end for %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><ul><li>if, elif, else</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if athlete_list %&#125;</span><br><span class="line">    Number of athletes: &#123;&#123; athlete_list|length &#125;&#125;</span><br><span class="line">&#123;% elif athlete_in_locker_room_list %&#125;</span><br><span class="line">    Athletes should be out of the locker room soon!</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    No athletes.</span><br><span class="line">&#123;% enfif %&#125;</span><br></pre></td></tr></table></figure><p>可在if标记中使用过滤器和操作符:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if athlete_list|length &gt; 1 %&#125;</span><br><span class="line">    Team: &#123;% for athlete in athlete_list %&#125; ... &#123;% endfor %&#125;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    Athlete: &#123;&#123; athlete_list.0.name &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><ul><li>block, extends<br>设置模板继承<a href="https://docs.djangoproject.com/zh-hans/2.1/ref/templates/language/#id1" target="_blank" rel="noopener">template inheritance</a>，这是一种在模板中减少样板(boilerplate)的强大方法。</li></ul><p>你可以创建自己的自定义模板标记。</p><p><br><br><br></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Comments</p><p>注释的语法为: <figure class="highlight plain"><figcaption><span>#&#125;```。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如，此模板将呈现为hello: ```&#123;# greeting #&#125;hello```。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 模板继承</span><br><span class="line"></span><br><span class="line">Templates inheritance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Django模板引擎最强大，也是最复杂的就是模板继承。模板继承允许你构建一个基础骨架模型，其中包含站点的所有常用元素(elements)，并定义子模块可以覆盖的块(block)。</span><br><span class="line"></span><br><span class="line">理解模板继承的栗子(`base.html`):</span><br><span class="line"></span><br><span class="line">```jinja2</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;</span><br><span class="line">    &lt;title&gt;&#123;% block title %&#125;My amazing site&#123;% endblock %&#125;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;sidebar&quot;&gt;</span><br><span class="line">        &#123;% block sidebar %&#125;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;/blog/&quot;&gt;Blog&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &#123;% endblock %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;content&quot;&gt;</span><br><span class="line">        &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>定义了一个简单的HTML框架文档，你可将其用于简单的双列页面。子模板的工作是用内容填充空块(empty block)。<br>在此示例中，块标记(block)定义了子模块可以填充的三个块。所有块标记的作用是告诉模板引擎子模块可以覆盖模板的这些部分。</p><p>子模板栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;My amazing blog&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">&#123;% for entry in blog_entries %&#125;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; entry.title &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; entry.body &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>扩展标记(extends)是这里的关键。它告诉模板引擎改模板扩展另一个模板。当模板系统评估此模板时，它首先找到父模板。</p><p>此时，模板引擎会注意到<code>base.html</code>中的三个块标记，并将这些块替换为子模板的内容。输出可能如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lange=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;</span><br><span class="line">    &lt;title&gt;My amazing blog&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;sidebar&quot;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;/blog/&quot;&gt;Blog&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;content&quot;&gt;</span><br><span class="line">        &lt;h2&gt;Entry one&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;This is my first entry.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;h2&gt;Entry two&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;This is my second entry.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>请注意，由于子模块未定义sidebar块，因此将使用父模板中的值。</p><p><br></p><p>你可以根据需要使用尽可能多的继承级别。使用继承的一种常见方法是以下三级(three-level)方法:</p><ul><li>创建<code>base.html</code>基础模板，其中包含网站的主要外观</li><li>为网站的每个部分(section)创建一个<code>base_SECTIONNAME.html</code>模板，这些模板都扩展基础模板，并包含特定于部分的样式设计</li><li>为每种类型的页面创建单独的模板，这些模板扩展了相应部分的模板</li></ul><p>这种方法可以最大化代码重用，并且可以轻松地将项目添加到共享内容区域。</p><p><br></p><p>以下是使用继承的一些技巧与提示:</p><ul><li><p>如果在模板中使用<figure class="highlight plain"><figcaption><span>extends %&#125;```，则它必须是该模板中的第一个模板标记。否则，模板继承不起作用。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 基础模板中的```&#123;% block %&#125;```标记越多越好。请记住，子模块不必定义所有父块，因此你可在多个块中填写合理的默认值，然后仅定义需要的块。</span><br><span class="line">- 如果在许多模板中复制了内容，则可能意味着你应该将内容移动到父模板中的```&#123;% block %&#125;```。</span><br><span class="line">- 如果需要从父模板获取块的内容，```&#123;&#123; block.super &#125;&#125;```变量将起作用。如果要添加到父模块的内容而不是完全覆盖它，这将非常有用。</span><br><span class="line">- 使用模板标记`as`语法在```&#123;% block %&#125;```块之外创建的变量不能在块内使用。</span><br><span class="line"></span><br><span class="line">```jinja2</span><br><span class="line">&#123;% trans &quot;Title&quot; as title %&#125;</span><br><span class="line">&#123;% block conten %&#125;&#123;&#123; title &#125;&#125;&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>为了提高可读性，可选择为<figure class="highlight plain"><figcaption><span>endblock %&#125;```标记指定名称。在较大的模板中，此技术可帮助查看正在关闭的块标记。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```jinja2</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">...</span><br><span class="line">&#123;% endblock conten %&#125;</span><br></pre></td></tr></table></figure></p></li></ul><p>最后，请注意，你无法在同一模板中定义多个名称相同的块标记。</p><p><br><br><br></p><h2 id="自动HTML转义"><a href="#自动HTML转义" class="headerlink" title="自动HTML转义"></a>自动HTML转义</h2><p>Automatic HTML escaping</p><p>当从模板生成HTML时，变量将始终存在影响生成的HTML的字符的风险。</p><p>考虑这个模板片段:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello &#123;&#123; name &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>首先，这似乎是一种显示用户名的无害方式。但考虑如果用户输入其名称会发生什么: <code>&lt;script&gt;alert(&#39;hello&#39;)&lt;/script&gt;</code><br>使用此名称值，模板将呈现为: <code>Hello, &lt;script&gt;alert(&#39;hello&#39;)&lt;/script&gt;</code><br>这意味着浏览器会弹出一个JS警告框！</p><p>类似地，如果名称包含<code>&lt;</code>符号: <code>&lt;b&gt;username</code><br>这将导致像这样的渲染模板: <code>Hello, &lt;b&gt;username</code><br>反过来，这将导致网页的其余部分被加粗。</p><p>显然，用户提交的数据不应盲目信任并直接插入到你的网页中，因为恶意用户可能会利用这种漏洞来做坏事。此类安全漏洞称为跨站点脚本(XSS, cross site scripting)攻击。</p><p>要避免此问题，有两种选择:</p><ul><li>一，可以确保通过转义过滤器运行每个不受信任的变量，该过滤器可将可能有害的HTML字符转换为无害的HTML字符。这是Django最初几年的默认解决方案，但问题在于它让你有责任确保你逃避一切。</li><li>二，可利用Django的自动HTML转义功能。</li></ul><p>默认情况下，Django中的每个模板都会自动转义每个变量标记的输出。具体来说，这五个字符被转义:</p><ul><li><code>&lt;</code>被转换为<code>&amp;lt</code>;</li><li><code>&gt;</code>被转换为<code>&amp;gt</code>;</li><li><code>&#39;</code>被转换为<code>&amp;#39</code>;</li><li><code>&quot;</code>被转换为<code>&amp;quot</code>;</li><li><code>&amp;</code>被转换为<code>&amp;amp</code>;</li></ul><p>同样，我们强调默认情况下已启用此行为。如果你正在使用Django的模板系统，那么你将受到保护。</p><p><br><br><br></p><h3 id="如何关闭"><a href="#如何关闭" class="headerlink" title="如何关闭"></a>如何关闭</h3><p>如果不想自动转义数据，则可通过多种方式将其关闭。</p><ul><li>单独的变量(individual bariables)<br>使用<code>safe</code>过滤器。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This will be escaped: &#123;&#123; data &#125;&#125;</span><br><span class="line">This will not be escaped: &#123;&#123; data|safe &#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>模板块(template block)<br>将模板包装在<code>autoescape</code>标记中。它将on或off作为其参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% autoescape off %&#125;</span><br><span class="line">    Hello &#123;&#123; name &#125;&#125;</span><br><span class="line">&#123;% endautoescape %&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="字符串文字和自动转义"><a href="#字符串文字和自动转义" class="headerlink" title="字符串文字和自动转义"></a>字符串文字和自动转义</h3><p>String literals and automatic escaping</p><p>如前面所说，过滤参数可以是字符串:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; data|default:&quot;This is a string literal.&quot; &#125;&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h2 id="访问方法调用"><a href="#访问方法调用" class="headerlink" title="访问方法调用"></a>访问方法调用</h2><p>Accessing method calls</p><p>Most method calls attached to objects are also available from within templates. 这意味着，模板必须比类属性和从视图中传递的变量获得更多的访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for comment in task.comment_set.all %&#125;</span><br><span class="line">    &#123;&#123; comment &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>你可以轻松访问你明确对自己的模型定义的方法:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"bar"</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; task.foo &#125;&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="自定义tag和filter库"><a href="#自定义tag和filter库" class="headerlink" title="自定义tag和filter库"></a>自定义tag和filter库</h2><p>某些应用程序提供了自定义的标签和过滤器库。要访问这些模板，确保应用在<code>INSTALLED_APPS</code>中，然后在模板中使用<code>load</code>标记.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load humanize %&#125;</span><br><span class="line">&#123;&#123; 45000|intcomma &#125;&#125;</span><br></pre></td></tr></table></figure><p>load标记载入humanize标记库，然后就可以使用intcomma过滤器。</p><p>load标记可载入多个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load humanize i18n %&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="基于类的视图"><a href="#基于类的视图" class="headerlink" title="基于类的视图"></a>基于类的视图</h1><p>class-based-views: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/class-based-views/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/class-based-views/</a></p><p>视图是可调用的，能接受用户的请求并返回响应。视图远不止是个函数，Django提供了一些可用作视图的类的示例，允许你通过继承和复用构建自己的视图并且复用这些代码。</p><p><br></p><h2 id="基于类的视图-1"><a href="#基于类的视图-1" class="headerlink" title="基于类的视图"></a>基于类的视图</h2><p>intro: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/class-based-views/intro/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/class-based-views/intro/</a></p><p>基于类的视图提供了实现视图作为Python对象来替代函数。相比基于函数的视图，它们不取代基于函数的视图，但有一定的差异和优势：</p><ul><li>Organization of code related to specific HTTP methods (GET, POST, etc.) can be addressed by separate methods instead of conditional branching.</li><li>Object oriented techniques such as mixins (multiple inheritance) can be used to factor code into reusable components.</li></ul><p><br><br><br><br><br></p><h2 id="内置的基于类的通用视图"><a href="#内置的基于类的通用视图" class="headerlink" title="内置的基于类的通用视图"></a>内置的基于类的通用视图</h2><p>Built-in class-based generic views: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/class-based-views/generic-display/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/class-based-views/generic-display/</a></p><p>编写Web应用程序可以是单调的，因为我们一次又一次地重复某些模式。Django视图带走一些在模型和模板层千篇一律的单调，但Web开发者也在视图层级遇到了这些无聊的单调。</p><p>Django的通用视图被开发来缓解此问题。他们采取的在视图中开发和抽象的发现，让你能快速地编写普通视图，而无需编写大量代码。<br>我们我们可以发现一些常见的任务，比如显示对象的列表，并编写任何对象列表的代码。然后有问题的模型可以作为一个额外的参数传递到URLconf。</p><p>Django自带的通用视图能做到以下几点：</p><ul><li>为单个对象显示列表和详细页面。如果我们创建一个应用程序来管理会议，那么TalkListView和RegisteredUserListView就应是列表视图的栗子。一个单一的talk page是我们成detail view的例子。</li><li>在基于日期(<code>year/month/day</code>)归档页的对象，associated detail, and “latest” pages</li><li>允许用户创建、更新和删除对象——是否授权</li></ul><p>总之，这些视图提供了方便的接口来执行最常见的任务，以帮助开发者解决遇到的问题。</p><p><br><br><br><br><br></p><h2 id="基类视图和表单处理"><a href="#基类视图和表单处理" class="headerlink" title="基类视图和表单处理"></a>基类视图和表单处理</h2><p>Form handling with class-based views: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/class-based-views/generic-editing/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/class-based-views/generic-editing/</a></p><p>表单处理通常有3条路径：</p><ul><li>Initial GET (blank or prepopulated form)</li><li>POST with invalid data (typically redisplay form with errors)</li><li>POST with valid data (process the data and typically redirect)</li></ul><p>实现此常常导致自己有大量重复的样板代码。为了帮助避免此情况，Django提供的通用基于类视图的集合来处理表单处理。</p><p><br><br><br><br><br></p><h2 id="基类视图混入"><a href="#基类视图混入" class="headerlink" title="基类视图混入"></a>基类视图混入</h2><p>Using mixins with class-based views: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/class-based-views/mixins/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/class-based-views/mixins/</a></p><blockquote><p>警告<br>这是一个高级的话题。</p></blockquote><p>Django内置的基类视图提供了许多功能，但其中某些你可能要分开使用。例如，你可能想编写一个视图，来渲染模板生成HTTP response，但是你不能使用TemplateView。或许你需要渲染仅POST模板，GET是另外一回事。虽然你可直接使用TemplateResponse，这将有可能导致重复的代码。</p><p>出于这个原因，Django还提供了许多离散功能的混入。模板渲染，例如，被封装在TemplateResponseMixin。</p><p><br><br><br><br><br></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>Django提供了适合广泛应用的基视图类。所有视图从View class继承，它处理链接到URLs的视图，HTTP方法调度等简单功能的视图继承。RedirectView是一个简单的HTTP重定向，并且TemplateView扩展基类使其也呈现渲染的模板。</p><p><br><br><br><br><br></p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>使用通用视图组件但的方法是直接在URLconf中创建它们。如果你只改变一个基类视图的几个简单属性，你可以简单地将它们传递到<code>as_view()</code>方法来调用自身：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> TemplateView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'about/'</span>, TemplateView.as_view(template_name=<span class="string">"about.html"</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>传递给<code>as_view()</code>的任何参数将覆盖在类中设置的属性。在此例中，在TemplateView设置<code>template_name</code>。类似的覆盖模式可用于RedirectView的url属性。</p><p><br><br><br><br><br></p><h2 id="子类通用视图"><a href="#子类通用视图" class="headerlink" title="子类通用视图"></a>子类通用视图</h2><p>第二种，更强大的方式去使用通用视图是从现有视图继承和在子类中提供新值或方法覆盖属性或方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># some_app/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> TemplateView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AboutView</span><span class="params">(TemplateView)</span>:</span></span><br><span class="line">    template_name = <span class="string">"about.html"</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> some_app.views <span class="keyword">import</span> AboutView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'aboug/'</span>, AboutView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br></p><h3 id="支持其它HTTP方法"><a href="#支持其它HTTP方法" class="headerlink" title="支持其它HTTP方法"></a>支持其它HTTP方法</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> books.views <span class="keyword">import</span> BookListView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'books/'</span>, BookListView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> ListView</span><br><span class="line"><span class="keyword">from</span> books.models <span class="keyword">import</span> Book</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListView</span><span class="params">(ListView)</span>:</span></span><br><span class="line">    model = Book</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">head</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        last_book = self.get_queryset().latest(<span class="string">'publication_date'</span>)</span><br><span class="line">        response = HttpResponse(<span class="string">''</span>)</span><br><span class="line">        <span class="comment"># RFC 1123 date format</span></span><br><span class="line">        response[<span class="string">'Last-Modified'</span>] = last_book.publication_date.strftime(<span class="string">'%a, %d %b %Y %H:%M:%S GMT'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><p>Migrations: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/migrations/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/migrations/</a></p><p>迁移是将你对模型的改变传播到你的数据库架构的Django方法。它被设计的目的主要是自动，但你需要知道什么时候才能迁移。当运行它们，你可能会遇到常见的问题。</p><p><br></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>与迁移和Django处理数据库交互的几个命令：</p><ul><li><code>migrate</code>：负责applying和unapplying migrations</li><li><code>makemigrations</code>: 负责创建一个基于你对你的模型所做的更改的新的迁移</li><li><code>sqlmigrate</code>: 显示一个迁移的SQL语句</li><li><code>showmigrations</code>: 列出项目迁移及其状态</li></ul><p>你应该考虑迁移为你的数据库模式的版本控制系统。<code>makemigrations</code>是负责包装你的模型改变为个体迁移文件——类似于提交(commit)。<code>migrate</code>是负责应用(applying)你的数据库。<br>每个应用程序的迁移文件位于该应用程序内部的<code>migrations</code>目录，设计于commit和sidtributed，他是代码库的一部分。你应该在你的开发机上运行它们一次，然后在你同事的机器上运行相同的迁移，并最终在生产机上运行。</p><p><br><br><br><br><br></p><h2 id="后端支持"><a href="#后端支持" class="headerlink" title="后端支持"></a>后端支持</h2><p>迁移支持Django的所有后端。</p><ul><li>PostgreSQL</li><li>MySQL</li><li>SQLite</li></ul><p><br><br><br><br><br></p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>迁移的工作很简单。修改模型，然后运行<code>makemigrations</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure><p>你的模型将被扫描，并且与当前包含在迁移文件的版本进行比较，然后一组新的迁移会被写出来。请务必阅读<code>makemigrations</code>的输出，它并不完美，对于复杂的变化可能无法检测到你所期望的那样。</p><p>一旦有了新的迁移文件，你应该把它们应用到你的数据库，以确保它们达到预期效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br><span class="line">Operations to perform:</span><br><span class="line">  Apply all migrations: books</span><br><span class="line">Running migrations:</span><br><span class="line">  Rendering model states... DONE</span><br><span class="line">  Applying books.0003_auto... OK</span><br></pre></td></tr></table></figure><p>一旦迁移已应用，提交迁移和模型改变到你的版本控制系统作为一个单个提交(singel commit)。这样，当其他开发者check out代码时，他们将同时获得模型的改变并在同一时间执行迁移。<br>你可以为迁移取一个有意义的名称:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations --name changed_my_model your_app_label</span><br></pre></td></tr></table></figure><p><br></p><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>由于迁移是存储在版本控制中，你会偶尔遇到你和另一个开发人员在同一个应用上都有提交一个迁移，导致两个开发人员的迁移有相同迁移编号。<br>别担心，这些数字编号只是在开发者那里参考，Django只关注每个迁移有一个不同的名称。迁移指定它们依赖于哪些迁移——包括同一应用前面的迁移。</p><p>发生这些情况时，Django会提示你，给你一些选项。</p><p><br><br><br><br><br></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>虽然迁移的每个程序，通过你的模型隐含的表和关系太复杂，无法在同一时间仅一个程序创建。<br>当你依赖别的东西来运行迁移，所产生的迁移将包含在迁移的依赖上。</p><p>在限制单一应用的依赖行为为影响大部分迁移操作。限制到一个单一应用(<code>makemigrations</code> or <code>migrate</code>)是尽力的承诺，而不是保证。需要任何其它程序使用，以获得正确的依赖。</p><p><br><br><br><br><br></p><h2 id="迁移文件"><a href="#迁移文件" class="headerlink" title="迁移文件"></a>迁移文件</h2><p>迁移存储为磁盘上的格式，这里成为迁移文件(migration file)。这些文件实际上是商定布局和声明样式的普通的Python文件。</p><p>一个基本的迁移文件:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> migrations, models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Migration</span><span class="params">(migrations.Migration)</span>:</span></span><br><span class="line"></span><br><span class="line">    dependencies = [(<span class="string">'migrations'</span>, <span class="string">'0001_initial'</span>)]</span><br><span class="line"></span><br><span class="line">    operations = [</span><br><span class="line">        migrations.DeleteModel(<span class="string">'Tribble'</span>),</span><br><span class="line">        migrations.AddField(<span class="string">'Author'</span>, <span class="string">'rating'</span>, models.IntegerField(default=<span class="number">0</span>)),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="向应用添加迁移"><a href="#向应用添加迁移" class="headerlink" title="向应用添加迁移"></a>向应用添加迁移</h2><p>向新应用添加迁移很简单，一旦你做了一些改动，只需运行<code>makemigrations</code>。</p><p>如果你的应用已经有模型和数据库表，并且没有迁移。你需要转化它使用迁移，一个例子: <code>python manage.py makemigrations your_app_label</code><br>这将为你的应用执行一个新的初始迁移。现在，执行<code>python manage.py migrate --fake-initial</code>，Django会检测你有一个初始迁移，它想创建的表已经存在，并将标识这些迁移为已经应用。</p><p>注意，这仅适用于给定的两件事：</p><ul><li>你创建了表但没有改变你的模型。</li><li>你没有手动编辑你的数据库——Django将无法检测到与模型不匹配的数据库，你只得到迁移错误时尝试修改这些表。</li></ul><p><br><br><br><br><br></p><h2 id="历史模型"><a href="#历史模型" class="headerlink" title="历史模型"></a>历史模型</h2><p>当运行迁移时，Django是从存储在迁移文件中的模型的历史版本进行工作。</p><p><br><br><br><br><br></p><h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><p>与改变数据库模式一样，你也可以使用迁移数据库本身的数据。这通常称为数据迁移，最好把它写成单独地迁移，刚在模型架构迁移的旁边。<br>Djaong不能为你自动生成数据迁移。</p><p>首先，生成一个空的迁移文件:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations --empty yourappname</span><br></pre></td></tr></table></figure><p>接着，打开此文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Generated by Django A.B on YYYY-MM-DD HH:MM</span><br><span class="line">from django.db import migrations</span><br><span class="line"></span><br><span class="line">class Migration(migrations.Migration):</span><br><span class="line"></span><br><span class="line">    dependencies = [</span><br><span class="line">            (&apos;yourappname&apos;, &apos;0001_initial&apos;),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    operations = [</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="管理文件"><a href="#管理文件" class="headerlink" title="管理文件"></a>管理文件</h1><p>Managing files: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/files/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/files/</a></p><p>此文档描述那些由用户上传的Django的文件的访问API。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>Testing in Django: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/testing/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/testing/</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h1><p>Django Auth: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/auth/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/auth/</a></p><p>Django自带了一个用户认证系统。它处理用户账户、组、权限和基于cookie的用户会话。这一部分文档介绍了如何实现开箱即用。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="缓存框架"><a href="#缓存框架" class="headerlink" title="缓存框架"></a>缓存框架</h1><p>Cache framework: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/cache/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/cache/</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="条件视图处理-1"><a href="#条件视图处理-1" class="headerlink" title="条件视图处理"></a>条件视图处理</h1><p>Conditional view processing: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/conditional-view-processing/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/conditional-view-processing/</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="加密签名"><a href="#加密签名" class="headerlink" title="加密签名"></a>加密签名</h1><p>Cryptographic signing: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/signing/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/signing/</a></p><h1 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h1><p>Sending email: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/email/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/email/</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="国际化和本地化"><a href="#国际化和本地化" class="headerlink" title="国际化和本地化"></a>国际化和本地化</h1><p>i18n: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/i18n/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/i18n/</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>Logging: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/logging/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/logging/</a></p><p>Django使用Python内置的logging模块处理系统日志。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>Pagination: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/pagination/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/pagination/</a></p><p>Django提供了一些类来帮助你管理分页数据——跨页分割(Previous/Next)。它们位于<code>django/core/paginator.py</code>。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>Security: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/security/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/security/</a></p><p>Django的安全功能的概述。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="性能和优化"><a href="#性能和优化" class="headerlink" title="性能和优化"></a>性能和优化</h1><p>本文档概述了一些技术和工具，这些技术和工具可以帮助您更有效地运行Django代码——更快，并且使用更少的系统资源。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="序列化Django对象"><a href="#序列化Django对象" class="headerlink" title="序列化Django对象"></a>序列化Django对象</h1><p>Serialization: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/serialization/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/serialization/</a></p><p>Django的序列化框架提供了translating Django Model成其它格式的机制。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><p>Settings: <a href="https://docs.djangoproject.com/zh-hans/2.1/topics/settings/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/settings/</a></p><p>Django的settings文件包含Django应用的所有配置项。</p><p><br><br><br></p><hr><p><br><br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;docs: &lt;a href=&quot;https://docs.djangoproject.com/zh-hans/2.1/topics/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.djangoproject.com/zh-hans/2.1/topics/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;版本:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Django Version: v2.1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Python" scheme="https://zhang21.github.io/tags/Python/"/>
    
      <category term="Django" scheme="https://zhang21.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Beyond The Apex</title>
    <link href="https://zhang21.github.io/2019/07/16/BeyondTheApex/"/>
    <id>https://zhang21.github.io/2019/07/16/BeyondTheApex/</id>
    <published>2019-07-16T02:59:21.000Z</published>
    <updated>2019-08-29T05:35:22.765Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>GT赛车 《Beyond The Apex》</li></ul><p><br><br><br></p><a id="more"></a><p><br><br><br></p><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>最近在PS4上购置了<strong>GTSport</strong>赛车游戏，刷知乎的时候看到GT赛车附赠了有关于汽车知识的书籍<strong>《Beyond The Apex》</strong>。出于好奇，在网上下载了这两本书的PDF版本，来帮助我学习相关汽车知识。谢谢网友对书籍的分享！</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="汽车工程"><a href="#汽车工程" class="headerlink" title="汽车工程"></a>汽车工程</h1><p>Engineering for Automotive</p><p><br></p><h2 id="汽车的工学"><a href="#汽车的工学" class="headerlink" title="汽车的工学"></a>汽车的工学</h2><p>一般人与专业技师对汽车的印象，之所以会有这么大的差异，决定性的因素就在于是否拥有工学的基础知识。因此，接下来我们将解说专业汽车技师拥有的工学基础知识，希望能尽可能填补两者之间的落差。</p><ul><li>第一节： 将介绍基本的机械力学，力、力矩、能量等概念，并导入振动的理论。力、力矩、能量是所有工学的基础。</li><li>第二节： 将介绍车辆运动力学与悬吊系统的调校。</li><li>第三节： 将介绍汽车引擎的基础知识——热力学与统计力学。</li><li>第四节： 将介绍空气力学。</li><li>第五届： 将介绍流体力学(CFD)。</li></ul><p>本书中介绍的工学理论，对于专业的汽车技师来说，都是最基础的内容。不过，对于一般人来说可能比较陌生，要从头看到尾也有点困难。出现这种情况时，请先选择自己感兴趣的部分阅读即可。</p><p><br></p><h2 id="力、力量与振动"><a href="#力、力量与振动" class="headerlink" title="力、力量与振动"></a>力、力量与振动</h2><p><br></p><h3 id="力与力矩的概念"><a href="#力与力矩的概念" class="headerlink" title="力与力矩的概念"></a>力与力矩的概念</h3><p>行驶中的车辆，有各种<strong>力</strong>与<strong>力矩</strong>在作用。理解对车子产生作用的力与力矩，就是理解汽车原理的第一步。</p><p><br></p><p><strong>力的定义</strong></p><p>轮胎、悬吊系统、引擎……，汽车在行驶时，会有各种力发生于这些部分。这些作用力都是由不同的现象所引发，在直觉上或许会认为其种类也各不同。不过，从物理学角度而言，这些力全部都可以用<script type="math/tex">F=ma</script>（力量=质量x加速度），这个简单公式来代表，在本质上完全相同。</p><p>所谓力，就是改变物理的速度或运动方向的作用。反过来说，如果物理正在加速或加速，就一定有力在作用。例如，轮胎与地面之间产生的摩擦力可以改变汽车这个拥有质量的物体的运动方向或速度。避震器的阻尼力具有降低车体与轮胎振动速度的功效。</p><p><img src="/images/BeyondTheApex/1-1-1.png" alt></p><p><br></p><p><strong>力矩的定义</strong></p><p>若在行驶过程中转动方向盘，轮胎会产生与行驶方向垂直的力，车身的方向因而改变。车身会以为轮胎的作用力，而进行<strong>偏航</strong>运动。这种让有体积的物体出现旋转运动的作用，就称为<strong>力矩</strong>。所谓力矩，是因与旋转轴的举例，加重作用力力道的力量，以数学公式表示，就是<script type="math/tex">M=LxF</script>(力矩=旋转轴的距离x力)。</p><p>若将车子的重心位置设定于旋转轴，则前轮产生的力矩大小，就等于<code>从重心至前轮的距离x前轮产生的横向作用力</code>。当然，在转向时，后轮也可以发挥<code>从重心至后轮的距离x后轮产生的横向作用力</code>的力矩，让车子朝与前轮力矩相反的方向旋转。</p><p>让我们以实际的过弯来思考一下上述的情况。转动方向盘时，前轮的力矩会变大，因而开始转向。而到了弯道定点附近，前后轮的力矩达到平衡；过了顶点之后将方向盘回正，则后轮的力矩会变大，并完成转向。</p><p><img src="/images/BeyondTheApex/1-1-3.png" alt></p><p><br><br><br></p><h3 id="能量的概念"><a href="#能量的概念" class="headerlink" title="能量的概念"></a>能量的概念</h3><p>了解能量守恒定律。</p><p><br></p><p><strong>能量守恒定律</strong></p><p>关于汽车的物理现象，可细分为力学现象、热现象、电气现象、磁力现象、化学现象……。例如，在燃油引擎的气缸当中，燃油点火爆炸时，气缸内的温度上升、活塞会被推下。此时，气缸内部发生了化学现象、热现象与力学现象。这些物理现象的种类虽然不同，但在这些 现象之间，则有一种与力迥异的共通效应，那就是能量。能量可在不同的物理现象之间相互转换，而其总量在转换前与转换后会维持恒定、不会改变。这就是所谓的<strong>能量守恒定律</strong>。</p><p><img src="/images/BeyondTheApex/1-2-1.png" alt></p><p>刹车是将力学能量转换为热能量的行为。</p><p><br></p><p><strong>引擎气缸内的能量守恒</strong></p><p>若从能量的角度，观察发生于燃油引擎气缸内的物理现象，可说是气缸内的化学能量被转换成为热能与力学能量。换言之，燃油引擎可说是从化学能量当中，颉取出对人有帮助的力学能量的装置。此时，能量守恒会确保经过转换的化学能量的量与新生成的热能量与力学能量的总和相等。而引擎将化学能量转换为对人有帮助的力学能量的比率，称为<strong>引擎效率</strong>。</p><p><img src="/images/BeyondTheApex/1-2-3.png" alt></p><p><br><br><br></p><h3 id="振动的机制"><a href="#振动的机制" class="headerlink" title="振动的机制"></a>振动的机制</h3><p>振动现象的根源是物体的质量与弹性。</p><p><br></p><p><strong>从力学角度看振动</strong></p><p>为了让内容更容易理解，在此用独立的砝码与弹簧来说明（我们将可产生振动现象的对象统称为<strong>振动系统</strong>）。</p><p><img src="/images/BeyondTheApex/1-3-1.png" alt></p><p><br></p><p><strong>从能量的角度看振动</strong></p><p>振动也可以从前文提到的能量守恒定律来观察。若从能量的角度观察振动，则振动可说是由伸缩带动的砝码的运动能量，与弹簧的弹性能量之间的交互作用。</p><p><img src="/images/BeyondTheApex/1-3-2.png" alt></p><p><img src="/images/BeyondTheApex/1-3-3.png" alt></p><p><br><br><br></p><h3 id="共振现象"><a href="#共振现象" class="headerlink" title="共振现象"></a>共振现象</h3><p>共振是指对来自外部的激励无抵抗的状态。</p><p>考量悬吊系统与引擎的振动时，必须特别注意的是共振的现象。共振必须尽可能避免。若无法避免时，也必须尽可能降低其影响。</p><p><br></p><p><strong>自由振动与固有振动数</strong></p><p>试着拉动前面的振动系统，然后放手让它自由震动，这种状态叫做自由振动。不久后砝码与弹簧会以某个特定的频率振动。无论一开始用什么方式拉扯，最终都会以一定的振动数振动。这个振动数，是仅有弹簧的弹性与砝码的质量决定的固有振动频率，因此称为固有振动数。固有振动数是振动系统进行自发性振动的频率，在以这个频率振动时，弹簧的弹力与砝码的惯性力会随时保持平衡，能量也自然会重复交互作用。</p><p><img src="/images/BeyondTheApex/1-4-1.png" alt></p><p><br></p><p><strong>强制振动与共振</strong></p><p>接下来试着用手强制让前文中使用弹簧与砝码伸缩，这种状态称为强制振动。用与固有振动数不同的振动数，让弹簧与砝码伸缩时，手应该会感受到阻力。让振动系统振动时，若将固有振动数视为自然的振动频率，则对于这个振动系统而言，其它的振动数都是不自然的频率。无论从外部施加何种振动，振动系统都会尝试以对自己最自然的频率来振动，因而会感受到阻力。</p><p><img src="/images/BeyondTheApex/1-4-2.png" alt></p><p>如果我们让这种砝码与弹簧用固有振动数来伸缩，结果又会如何？由于此时的振动对于该振动系统来说属于自然的振动数，因此不会感到阻力。不仅如此，振动的幅度反而会配合施加的外力而逐渐增大。因为振动系统对于来自外部的激励，不仅没有抵抗，而且会将其能量完全吸收。若持续以固有振动数对其施加振动则振幅会增加到无限大。</p><p>如上所述，若以振动系统本身自发振动时的振动频率，从外部强制让它振动，则振动的振幅将会持续增大，这种现象称为<strong>共振</strong>，而此时的频率称为<strong>共振频率</strong>。</p><p>以悬吊系统为例，共振将会导致接地性与乘坐的舒适度降低；而引擎出现共振，更会导致引擎本身的损坏。因此必须极力避免共振现象发生。防止共振导致损坏的方式之一，就是配置避震器。避震器可以吸收来自砝码与弹簧振动的能量，并将之转换成热能，是放到外部。因此即使产生共振，若阻尼力可却是发挥作用，就可以房子机械损坏。</p><p><img src="/images/BeyondTheApex/1-4-4.png" alt></p><p><br><br><br></p><h3 id="阻尼力的作用"><a href="#阻尼力的作用" class="headerlink" title="阻尼力的作用"></a>阻尼力的作用</h3><p>振动的状态会因阻尼力而变化。</p><p><br></p><p><strong>阻尼比不同的自由振动</strong></p><p>振动衰减的情况，回音避震器阻尼力的大小而出现差异。而表示避震器阻尼力的大小，对于质量与弹簧弹力的效果有多大影响的量化指标，就是<strong>阻尼比</strong>。</p><p>当阻尼比大于1时，表示阻尼力强过质量与弹簧，因此振动系统的运动会朝向非振动收敛。这种状态称为<strong>过阻尼(over damping)</strong>。在过阻尼的状态下，振幅会随着之间而减少、逐渐趋近于零，属于无周期运动。<br>而阻尼比小于1时，则阻尼力会弱于质量与弹簧的效应，振幅会随着时间减少、而振动周期则会逐渐拉长。这种状态称为<strong>阻尼不足(underdamping)</strong>。<br>当阻尼比等于1时，则是振动或不振动的临界状态，这种状态称为<strong>临界阻尼(criticaldamping)</strong>。<br>当阻尼比为0时，不会产生阻尼力，也就是避震器不会发生作用的状态，因此振幅也不会衰减。</p><p><img src="/images/BeyondTheApex/1-5-1.png" alt></p><p><img src="/images/BeyondTheApex/1-5-2.png" alt></p><p><img src="/images/BeyondTheApex/1-5-3.png" alt></p><p><br><br><br></p><h3 id="相位差"><a href="#相位差" class="headerlink" title="相位差"></a>相位差</h3><p>相位差就是振动的节奏的差异。</p><p>汽车通过路面的起伏时，起伏会被悬吊系统缩小，再传导至车体。在这种情况下，通常车体的振幅会比路面的起伏更为平稳。换言之，车体的振幅会先被悬吊系统缩小之后，再传导至车体。由此可知，车体振幅的响应能被缩减到何种程度，应是最重要的着眼点。要讨论振动时，对于入力能以多快的速度回应，这一点也非常重要。</p><p><img src="/images/BeyondTheApex/1-6-1.png" alt></p><p><br></p><p><strong>振动的节奏之差异</strong></p><p>要评估一个振动系统，对于人力会以多快的速度回应时，使用的基准就是<strong>相位差</strong>。</p><p>用固有振动数(共振频率)以外的振动数，轻质针对弹簧与砝码进行激励时，为何手会感受到阻力？手的振动节奏与振动系统的自然节奏不同所致。这种节奏上的差异，就是施加振动的方向与砝码惯性力的方向之差异。这种运动的节奏差异，就叫相位差。</p><p><img src="/images/BeyondTheApex/1-6-3.png" alt></p><p><br><br><br></p><h3 id="频率响应"><a href="#频率响应" class="headerlink" title="频率响应"></a>频率响应</h3><p>应用于悬吊系统与车辆运动的解析。</p><p><br></p><p><strong>频率响应与波德图</strong></p><p>将振幅、相位差等振动系统对于激励频率(激励振动数)的回应，称为<strong>频率响应</strong>。</p><p>在分析汽车的振动现象时，通常会解析其频率响应。而解析频率响应时最常使用的，就是名为<strong>波德图</strong>的图标。</p><p><img src="/images/BeyondTheApex/1-7-1.png" alt></p><p><br></p><p><strong>透过波德图了解阻尼系统的振动</strong></p><p>还是使用前面的振动模型，从静止状态逐步提升激励的振动数(频率)。频率极低时的振幅比为1，换句话说，也就是激励的振幅与响应的振幅相同。不过，之后若逐步提升频率，振幅比也会随之变大，这表示响应的振幅比受入力影响而逐渐变大。而达到某一频率时，振幅比会达到最大，这就是所谓的共振。而此时的频率就是共振频率。如果再进一步提升频率，则振幅比会变小、并逐渐趋近于0.换言之，激励的振动数越高，响应的振幅也会随之逐渐趋近于0。</p><p><img src="/images/BeyondTheApex/1-7-2.png" alt></p><p><br><br><br></p><h3 id="发生于悬吊系统的振动"><a href="#发生于悬吊系统的振动" class="headerlink" title="发生于悬吊系统的振动"></a>发生于悬吊系统的振动</h3><p>多自由读之振动。</p><p><br></p><p><strong>悬吊系统的振动特性</strong></p><p>汽车的悬吊系统有各种机构，但本质上是由质量与弹簧以及避震器组成的振动系统。车体与车辆之间的弹簧与避震器代表悬吊系统；车轮与路面之间的弹簧与避震器则代表轮胎弹性与阻尼。</p><p><img src="/images/BeyondTheApex/1-8-1.png" alt></p><p><img src="/images/BeyondTheApex/1-8-2.png" alt></p><p><br><br><br><br><br></p><h2 id="车辆的运动性能"><a href="#车辆的运动性能" class="headerlink" title="车辆的运动性能"></a>车辆的运动性能</h2><p><br></p><h3 id="轮胎的力学"><a href="#轮胎的力学" class="headerlink" title="轮胎的力学"></a>轮胎的力学</h3><p>理解轮胎产生的力。</p><p><br></p><p><strong>转弯力</strong></p><p>让物体滑动或扭转变形的力，称为<strong>剪应力</strong>；而物体对剪应力产生抵抗的特性，则称为<strong>剪弹性</strong>。若剪应力对轮胎朝横向作用，轮胎就会朝横向变形。不过，此时轮胎也会产生于剪应力对抗的力，尝试恢复原状。事实上，轮胎就是用抗拒让自身变形的作用力的方式，来产生车子的加速、减速、转向时所需的力。</p><p><img src="/images/BeyondTheApex/2-1-1.png" alt></p><p>从图中可以了解，轮胎的旋转面与车子的行进方向之间是有差异的。换言之，轮胎的力，是通过一边旋转、一边横向变形所产生。在此将旋转面如行进方向形成搞得角度，称为<strong>滑移角</strong>；而与行进方向垂直产生的力，则称为<strong>转弯力</strong>。车子之所以可以转向，就是因为轮胎可以产生如上述所述的转弯力。</p><p>一般来说，若剪弹性较大，即使滑移角相同，也会产生较大的转弯力。不过，当剪弹性过大时，些微的滑移角就可能导致摩擦饱和，使路感与车手的感觉不合；相反，如果剪弹性太弱，则会过度变形，而让车手感到不安。</p><p><br></p><p><strong>转弯力与滑移角的关系</strong></p><p>在滑移角较小的范围内，转弯力会呈直线增加；而当滑移角大到一定程度时，转弯力则会达到饱和。这种转弯力的变化比率，称为<strong>转向功率</strong>。只需些微的滑移角变化，便可产生较大转弯力的轮胎，其转向功率也比较大。</p><p><img src="/images/BeyondTheApex/2-1-3.png" alt></p><p><br></p><p><strong>胎压与转向功率</strong></p><p>一般来说，在胎压较低的范围内，胎压增加时，轮胎的剪弹性会提升，转向功率也会变大。不过胎压的上升，却会导致与路面的接地面积减少。换言之，接地面积与剪弹性，是针对胎压产生的相反效果。当垂直载重较小时，胎压增加造成接地面积较少的效果，会比剪弹性增加的影响更大，因此转向功率会降低。为了将转向功率提升到极限，最重要的是考量轮胎的特性与车重，在各项要素之间取得平衡。</p><p><br></p><p><strong>伴随驱动与制动的轮胎横向力</strong></p><p>从上方观察汽车时，与轮胎旋转面方向垂直产生的抓地力，称为<strong>横向力</strong>。理解横向力在驱动或制动时会产生何种变化，是非常重要的一点。踩下油门或刹车时，轮胎的抓地力被用于驱动力或制动力，所以即使在相同的滑移角下，横向力仍然会减少。赛车会随着车手的操控，而频繁进行制动与驱动，因此斜向的摩擦力，容易影响单圈时间。</p><p><img src="/images/BeyondTheApex/2-1-4.png" alt></p><p><br><br><br></p><h3 id="车子的稳态定圆回转"><a href="#车子的稳态定圆回转" class="headerlink" title="车子的稳态定圆回转"></a>车子的稳态定圆回转</h3><p>车子的转向由前后轮的力矩之平衡决定。</p><p><br></p><p><strong>转向特性的定义</strong></p><p>以一定的转向角与速度行驶的车辆，会维持特定的旋转半径画圆，这称为<strong>定圆回转(steady state cornering)</strong>。研究进行稳态定圆回转的车辆，将有助于理解车辆运动的基本特性。</p><p>假设有一台以特定速度进行稳态定圆回转的车子，我们从此状态慢慢提升其速度。若速度提升时，前轮产生的的力矩变小，则其旋转半径将会随着速度的提升而扩大，若要持续稳态定圆回转，就必须增加转向角。相较于此，若前轮的力矩变大，则旋转半径会随着速度的提升而变小，因此必须缩小转向角。</p><p>转向特性：</p><ul><li>转向角不足的特性，称为转向不足(US)；</li><li>转向角过大的特性，称为转向过度(OS)；</li><li>旋转半径与速度的增减无关、维持一定数值，称为转向适中(NS).</li></ul><p>必须注意的是，转向过度的车辆，在特定速度下旋转半径会变为0，也就代表车子会陷入打滑的状态。而达到打滑状态的速度，则称为<strong>稳定极限速度(stability limit speed)</strong>。</p><p><img src="/images/BeyondTheApex/2-2-1.png" alt></p><p><img src="/images/BeyondTheApex/2-2-2.png" alt></p><p><br></p><p><strong>转向特性与滑移角的关系</strong></p><p>前后轮的滑移角β前轮、β后轮与转向特性之间的关系十分有趣。</p><ul><li>若<code>β前轮&gt;β后轮</code>，则为US；</li><li>若<code>β前轮=β后轮</code>，则为NS；</li><li>若<code>β前轮&lt;β后轮</code>，则为OS。</li></ul><p>这种关系，与是否有转弯力以外的横向力作用于前后轮无关，也与转弯力是否和轮胎的横向力成比例无关，而是在进行稳态定远回转的车辆，以几何学来决定的关系。</p><p><img src="/images/BeyondTheApex/2-2-3.png" alt></p><p><img src="/images/BeyondTheApex/2-2-4.png" alt></p><p><br><br><br></p><h3 id="车辆对转向角变化之回应"><a href="#车辆对转向角变化之回应" class="headerlink" title="车辆对转向角变化之回应"></a>车辆对转向角变化之回应</h3><p>车辆的运动只是一种振动现象。</p><p><br></p><p><strong>转弯的机制</strong></p><p>当转向角发生变化时，车辆会如何回应？<br>偏航运动并不是在转动反向盘后立即发生，而会因车辆的惯性与轮胎的作用力发生的关系，而有短暂的时间差(相位差)存在。</p><p><img src="/images/BeyondTheApex/2-3-1.png" alt></p><p><br></p><p><strong>转向平衡与车子的回应</strong></p><p>车子对于车手操控的变化之回应，会受到转向特性与车速很大的影响。</p><ul><li>US的车辆在达到一定速度后，会产生振动，但不久后就会收敛、并趋于稳态。</li><li>NS的车辆则不会产生振动，维持稳定的状态。</li><li>OS的车辆若行驶速度超过稳定极限速度，车子的回应将不会振动而出现发散，因而陷入打滑。</li></ul><p><img src="/images/BeyondTheApex/2-3-2.png" alt></p><p><img src="/images/BeyondTheApex/2-3-3.png" alt></p><p><br></p><p><strong>将振动理论适用于车辆运动</strong></p><p>事实上，如果用阻尼比或振动频率(固有振动数)等特定的抽象概念，来观察物体的运动，可发现由质量、弹簧与避震器构成的振动系统与车辆的运动，两者完全没有差异，都可视为一个振动系统。换言之，车辆的运动只不过是一种振动现象。</p><ul><li>US的车辆偏航阻尼的阻尼比低于1，因此会以振动方式回应。</li><li>OS的车辆偏航阻尼的阻尼比在1以上，所以其回应为非振动性。</li><li>NS的车辆则位于US与OS的分解处，也就是偏航阻尼的阻尼比为1的临界状态，其回应也属于非振动性。</li></ul><p><br><br><br></p><h3 id="车辆对周期性操控的回应"><a href="#车辆对周期性操控的回应" class="headerlink" title="车辆对周期性操控的回应"></a>车辆对周期性操控的回应</h3><p>以波德图了解车辆的特性。</p><p><br></p><p><strong>对于转向特性与周期性操控的回应</strong></p><p>车辆的运动只不过是一种振动现象。而接下来，则将利用振动理论检视在一定的车速下，反复<strong>转动</strong>与<strong>回正</strong>方向盘（进行周期性操控）时，若改变操控的速度（操控频率），车辆将会如何回应，今儿厘清在不同转向特性下的车辆特性。</p><p>当操控的频率极低时，不论在OS、NS、US任一特性下，振幅比都会与稳态定圆回转的偏航角速度大致相同。相反，当操控频率提升时，US的车辆会在特定频率达到高峰、振幅比也会变大；而NS与OS的车辆不会出现高峰，振幅比也会随着操控频率的增加而减少。</p><p>观察期相位图，可以发现随着操控频率的提升，不论在哪一种转向特性下，相位的延迟都会变大，但US的车辆相位延迟最小。换言之，越是转向不足的车辆，对于操控的回应就会越快。</p><p><img src="/images/BeyondTheApex/2-4-1.png" alt></p><p><br></p><p><strong>看波德图时应留意的重点</strong></p><p>以偏航角速度的频率为例：</p><ul><li>1是极低频率的振幅比。这个数值与稳态定圆回转时的数值大致相同；</li><li>2是振幅比峰值的高度。US越强的车辆，偏航阻尼越小、共振则会越大，因此振幅比峰值会比较高；不过在NS与OS的车辆上，则不会出现高峰；</li><li>3是共振频率。共振频率越高，回应性愈佳，车手在操控时的路感也会愈明确；</li><li>4是相位的延迟。相位的延迟越大，针对转向角的偏航角速度发生的时间也会愈慢。因此，想要确保良好的转向特性，就必须开发出相位延迟较小的车辆。换言之，也就是US的车辆。</li></ul><p><img src="/images/BeyondTheApex/2-4-2.png" alt></p><p><br><br><br></p><h3 id="车体的滚转与运动"><a href="#车体的滚转与运动" class="headerlink" title="车体的滚转与运动"></a>车体的滚转与运动</h3><p>将滚转运动活用于转向特性的调整。</p><p>转向中的车子，车体回想外侧滚转。实际上车辆的特性，会因为是否将滚转运动列入考量而出现差异。</p><p><br></p><p><strong>相对于载重的转弯力变化</strong></p><p>即使施加于车体的载重达到2倍，转弯力也不会增为2倍。这是因为随着载重的提升，转弯力的增幅会逐渐钝化（呈饱和曲线）。车辆转向时，会产生从内轮至外轮的移动载重。不过由于上述原因，左右转弯力的和，会比不考量移动载重的情况减少。换言之，转向造成的移动载重愈大，左右转弯力的和也会减少的多。</p><p><img src="/images/BeyondTheApex/2-5-1.png" alt></p><p><img src="/images/BeyondTheApex/2-5-2.png" alt></p><p><br></p><p><strong>前后移动载重不同时的转向特性</strong></p><p>轮胎转弯力的产生，会针对垂直载重以趋向饱和的方式变化，因此当前后的移动载重量因滚转运动而出现差异，转向特性也会随之变化。</p><ul><li>如果是<code>前轮的移动载重量&gt;后轮的移动载重</code>，则转向特性回潮US方向变化；</li><li>相反，若是<code>前轮的移动载重量&lt;后轮的移动载重</code>，则转向特性会朝OS方向变化。</li></ul><p>左右的移动载重量，会由<strong>于滚转运动相关的外力作用</strong>和<strong>与其相斥的车辆滚转刚性之作用</strong>的平衡关系来决定。此一关系主要是由前后的滚转中心的高低、前后的滚转刚性比，以及前轮的滚转中心的高低、前后的滚转刚性比，以及前后的轮距宽度来决定。</p><p><img src="/images/BeyondTheApex/t2-5-1.png" alt></p><p><img src="/images/BeyondTheApex/2-5-4.png" alt></p><p><br><br><br></p><h3 id="簧上质量与簧下质量的振动"><a href="#簧上质量与簧下质量的振动" class="headerlink" title="簧上质量与簧下质量的振动"></a>簧上质量与簧下质量的振动</h3><p>悬吊系统调校的振动特性。</p><p>车辆的上下振动，是会影响乘坐舒适度与轮胎接地性的重要问题。车体振动太大，会降低舒适度，更可能对接地面形成干扰、导致轮胎失去抓地力，因此必须仔细调校弹簧与避震器。</p><p><br></p><p><strong>振动模式</strong></p><p>簧上质量是指被悬吊系统支撑的质量；簧下质量是指位于悬吊系统与轮胎之间的质量。在此一次介绍簧上质量的<strong>弹跳振动(bounce vibration)</strong>、<strong>颠簸振动(pitching vibration)</strong>、<strong>簧下质量的上下振动</strong>。</p><p>为了便于理解，使用下图所示的模型来进行说明。</p><p><img src="/images/BeyondTheApex/2-6-1.png" alt></p><p><img src="/images/BeyondTheApex/2-6-2.png" alt></p><p><br></p><p><strong>因悬吊系统调校而产生的振动模式变化</strong></p><p>车体的共振，会导致轮胎的接地性与乘坐舒适度恶化，必须尽可能避免。此外，簧上质量的振动还会影响车体的空气力学性能（特别是对赛车而言，是一项十分重要的问题）。</p><p>簧上质量与簧下质量的上下振动，具有以下性质。若能充分理解，对于悬吊系统的调校应该有很大的帮助：</p><ol><li>增加避震器的阻尼力，对于降低簧上质量在共振频率附近的振动十分有效，但在共振点意外的范围，反而会使振动增加；</li><li>提升避震器的阻尼力，簧上质量的共振频率也会略微提升；</li><li>变更簧上质量或弹簧的弹性，则簧上共振会大幅变化，但簧下共振则不太会变化；</li><li>变更簧下质量或轮胎的纵向刚性，则簧下共振会答复变化，但簧上的振动则不会有太大改变。</li></ol><p><img src="/images/BeyondTheApex/2-6-3.png" alt></p><p><br></p><p><strong>抑制颠簸运动</strong></p><p>车辆直线前进时，从路面传导至后轮的人力，在时间上会出现<code>轴距÷车速</code>的延迟。若将后轮的簧上共振频率设定得比前轮略高，则后轮振动的收敛会追上前轮振动的收敛，可以抑制车辆的颠簸运动。</p><p><img src="/images/BeyondTheApex/2-6-4.png" alt></p><p><br><br><br></p><h3 id="何为运动性能优良的车子"><a href="#何为运动性能优良的车子" class="headerlink" title="何为运动性能优良的车子"></a>何为运动性能优良的车子</h3><p>车辆运动性的关键在于后轮。</p><p><br></p><p><strong>偏航角速度的共振频率与转向特性</strong></p><p>一般来说，车辆偏航角速度的共振频率越高，车辆的运动性能也就越利落敏捷。要提升偏航角速度的共振频率，可以通过提升后轮的转向功率、降低车子重量，或缩减偏航惯性半径等方式达成。</p><p>后轮抓地力的大小，对于车辆的运动性能十分重要。所以在调校悬吊系统时，除了要确保后轮的抓地力之外，也必须配合悬吊系统，将前后轮的抓地力最佳化。这是提升车辆运动性能时的基本概念。</p><p><img src="/images/BeyondTheApex/2-7-1.png" alt></p><p><br></p><p><strong>车辆回应性的分类范例</strong></p><p><img src="/images/BeyondTheApex/2-7-2.png" alt></p><p><img src="/images/BeyondTheApex/2-7-3.png" alt></p><p><br><br><br><br><br></p><h2 id="引擎与效率"><a href="#引擎与效率" class="headerlink" title="引擎与效率"></a>引擎与效率</h2><p><br></p><h3 id="温度与压力"><a href="#温度与压力" class="headerlink" title="温度与压力"></a>温度与压力</h3><p>温度与压力其实都是分子的运动。</p><p>热、温度与压力其实是由分子的运动造成的现象。问了正确理解引擎等机械的效率与能量损耗，以及将于后文中说明的空气力学（流体力学），在此最好先能掌握温度、压力相关的分子运动原理。</p><p><br></p><ul><li><strong>在密闭空间中不规则飞舞的分子样貌</strong></li></ul><p>请各位想象一下被密封在特定容器中的气体。以宏观角度来看，这个容器中的气体，在温度与压力都维持在均衡的状态，这种状态称为平衡状态。<br>不过，如果站在可观测分子动态的微观角度，观察容器内部的状态，则可以看到无数的气体分子在其中不规则地随意飞舞。有的分子以非常缓慢的速度飞舞，有的则以非常快的速度飞舞。而且分子之间会互相撞击，有时还会撞到容器的内壁，因而改变了速度。</p><p><img src="/images/BeyondTheApex/3-1-1.png" alt></p><p><br></p><ul><li><strong>所谓温度，是每个分子的平均运动能量</strong></li></ul><p>在容器中，有无数个速度各不相同的分子存在，若从能量的角度观察，即可说是容器中存在有无数个运动能量各不相同的气体分子。事实上，所谓温度，就是指每个不规则飞舞的分子平均运动能量的对应量。</p><p>若以数学方式描述，则可写成：<code>每个分子的平均运动能量=3/2kT</code>。（T为绝对温度、k为波茨曼常数(Boltzmann constant，也就是气体的温度、密度、压力、量及种类无关的比例常数)）。在这个公式中，<strong>力学量</strong>——每个分子的平均运动能量；<strong>热能量</strong>——温度。波茨曼常数才是扮演连结力学量与热能量的重要角色。</p><p><img src="/images/BeyondTheApex/3-1-2.png" alt></p><p><br></p><ul><li><strong>压力为四处飞舞的分子撞击力的平均值</strong></li></ul><p>气体的分子会不断撞击到容器的内部，它们有些速度快、有些速度慢；有些是垂直撞击、有些则是斜向撞击，所以每个分子的撞击力道也不相同。<br>不过，我们观察的所谓压力，其实是四处飞舞的无数分子，在不规则运动下的撞击力的平均值。在此要特别说明的是，在平衡状态下，上述分子撞击力的平均值，从任何一个方向测量都会得到相同的数值，不会因为量测的方向不同，压力就不同。换言之，容器中无无数的气体分子，虽然是以完全不规则的方式飞舞，但若以宏观的角度观察，撞击力其实是被平均分配至每一个方向。</p><p><img src="/images/BeyondTheApex/3-1-3.png" alt></p><p><br><br><br></p><h3 id="何为理想的热机"><a href="#何为理想的热机" class="headerlink" title="何为理想的热机"></a>何为理想的热机</h3><p>Heat Engine</p><p>完全不会产生无谓热能移动的卡诺循环(Carnot Cycle)</p><p>引擎，是可从热能量当中，以对人有助益的形式擷取出力学能量的机器。不过其效率到底是如何决定？在历史上，为了探索这个问题，而实际踏出一大步的，就是法国的卡洛。19世纪初期，卡洛以非常巧妙的论述，阐明了何为效率最高的热机，以及其效率的决定方式。他所提出的结论，成为之后开发热机时的重要指标。</p><p><br></p><ul><li><strong>卡诺留意到的两个事实</strong></li></ul><p>卡诺在考量何谓理想的热机时，留意到两个热能的性质。<br>第一，是热机在作功时，必须要有温差存在。如果没有温差，就不会发生热能的移动，也就无法让热机运作。不过，若热机内有撷取<strong>功</strong>时不需要的温度差异在，热能就只会因温差而移动，称为完全不会<strong>作功</strong>的无效率热移动。因此卡诺认为，在作功时，不靠温差进行热移动的，才是理想的热机。<br>第二，则是只要物体的体积或形状出现变化，即使没有温差、也可以进行热移动，这种现象称为<strong>等温变化(Isothermal change)</strong>。卡诺认为，如果能妥善运用等温变化，应该可以在不引发因温差而产生的热移动的情况下，便将功撷取出来。卡诺以上述假设为前提进行实验，并构思出不会因温差而产生无谓热移动的划时代热循环。</p><p><br></p><ul><li><strong>卡诺循环</strong></li></ul><p>为了明确凸显热的本质，卡诺设想出以高温与低温的<strong>热库(heat reservoir)</strong>，以及由空气充满的汽缸与活塞构成的空气引擎。下图是卡诺所设想出的热循环图：</p><p><img src="/images/BeyondTheApex/3-2-1.png" alt></p><p><img src="/images/BeyondTheApex/3-2-2.png" alt></p><ol><li>让汽缸接触高温的热库，让热能从热库移动至汽缸内的空气，使空气膨胀。不过，由于不能在此步骤中产生温差，必须确保空气与热库的温度相同。此外，空气本身的温度也必须平均一致，不能有不均匀的情况。想要达到上述条件，必须让空气非常缓慢地逐渐膨胀。而这种以一定的温度让气体膨胀或压缩的现象，就是所谓的等温变化。</li><li>必须依照上述方式膨胀的汽缸，与低温的热库接触，但此时不可避免地会产生温差。卡诺因而利用了名为<strong>绝热变化(adiabatic change)</strong>的现象，也就是即使没有热能移动。若压缩气体、温度就会上升；相反，即使没有热能移动，若让气体膨胀，温度就会下降的现象。换言之，卡诺发现，只要让因高温热库而膨胀的气体，再因为绝热变化而膨胀，在没有热能移动的情况下，将气体的温度降低即可。要注意的是，在这个过程中，必须以非常缓慢的速度，让活塞动作才行。</li><li>当空气的温度下降到与低温的热库相同时，让汽缸与低温热库接触，就可让气体中的热能移动至低温的热库，同事压缩气体。如同先前说明过的，此时当然也不能有温差，所以必须以等温变化慢慢地让热能移动。</li><li>等温变化结束后，则开始利用绝热变化压缩空气，将温度提升上去。等到将空气压缩到与高温热库相同的温度时，在进行步骤1的等温膨胀，重复相同的过程。</li></ol><p>如上所述，<code>高温热库的等温膨胀-绝热膨胀让温度下降-低温热库的等温压缩-绝热压缩让温度上升</code>，这4个过程进行一轮之后，汽缸的空气会恢复到与一开始完全相同的状态，在没有无谓的热移动的情况下，将热转换为工。由于以上热循环是卡诺构思开发，因此成为卡诺循环。</p><p><br><br><br></p><h3 id="卡诺的结论"><a href="#卡诺的结论" class="headerlink" title="卡诺的结论"></a>卡诺的结论</h3><p>以令人惊叹的方式将热能抽象化</p><p><br></p><ul><li><strong>卡诺循环的理论效率</strong></li></ul><p>经过以上说明，卡诺循环是可以达到热机最高效率的热循环。不过，卡诺的卓越之处，在于用巧妙的论述，以理论证明了由他所构思的热循环，也就是在汽缸内有温差的物体完全不会互相接触的热循环，就是最理想的热机，不会再有效率更好的热机。<br>更令人惊叹的是，卡诺下了一个结论——那就是这个热循环的理论效率，仅取决于高温热库与低温热库的温度。他虽然没有将这套理论定型化，不过之后英国的William Thomson将它整理、归纳为一下数学公式: <script type="math/tex">卡诺循环的理论效率=1-\frac{低温热库的绝对温度}{高温热库的绝对温度}</script></p><p><img src="/images/BeyondTheApex/3-3-1.png" alt></p><p><br></p><ul><li><strong>将热机终极完美地抽象化</strong></li></ul><p>卡诺循环的理论效应，仅仅取决于热库的温度——这个由卡诺导出的结论，还证明了一项划时代的事实。那就是卡诺循环的理论效率，与热机的制作方式无关，仅仅取决于自然本身的性质。<br>他的理论当中，完全没有不必要的成份，也完全没有遗漏不可或缺的部分，堪称是终极完美的抽象化。</p><p><br><br><br></p><h3 id="汽车引擎的理论效率"><a href="#汽车引擎的理论效率" class="headerlink" title="汽车引擎的理论效率"></a>汽车引擎的理论效率</h3><p>何谓奥图循环、狄赛尔循环的理论效率。</p><p><br></p><ul><li><strong>奥图循环的理论效率</strong></li></ul><p>在了解了何谓理想的热机之后，让我们来看看一般的汽车引擎。</p><p>目前的燃油引擎，事宜Nikolaus August Otto构思出的四衝程循环——<strong>奥图循环(otto cycle)</strong>为基础。奥图循环包括以下四个过程：1，绝热压缩；2，定容加热；3，绝热膨胀；4，定容冷却。<br>定容加热、定容冷却，是指在不改变汽缸容积的情况下，将汽缸内的工作物质加热或冷却的作用。‘</p><p>与卡诺循环相同，我们准备由高温与低温热库驱动的空气引擎，以非常缓慢的速度让活塞动作，就可以了解奥图循环是如何达到最高的效率。不过，在奥图循环中2和4的定容过程一定会产生温差，因为如果没有温差，从高温热库至空气的热移动，或是从空气至低热库的热移动就不会发生。因此，奥图循环的理论效率会低于卡诺循环，其差距就是上述温差导致热移动部分。</p><p>奥图循环的理论效率，可用以下的公式表示: <script type="math/tex">奥图循环的理论效率=1-\frac{1}{压缩比^{比热比-1}}</script></p><p><img src="/images/BeyondTheApex/3-4-1.png" alt></p><p><img src="/images/BeyondTheApex/3-4-2.png" alt></p><p><br></p><ul><li><strong>狄赛尔循环的理论效率</strong></li></ul><p><strong>狄赛尔循环(Diesel cycle)</strong>是由Rudolf Christian Karl Diesel构思出的柴油引擎热循环。狄赛尔循环主要包括一下四个过程：1，绝热压缩；2，定压加热；3，绝热膨胀；4，定容冷却。<br>这里所谓的定压加热，是指在不改变空气压力的情况下，将汽缸内的工作物质加热之作用。</p><p>迪赛尔循环的理论效率公式为：<script type="math/tex">狄赛尔循环的理论效率=1-\frac{1}{压缩比^{比热比-1}}\frac{燃料喷射的截止比^{比热比-1}}{比热比(燃料喷射的截止比-1)}</script></p><p><img src="/images/BeyondTheApex/3-4-3.png" alt></p><p><img src="/images/BeyondTheApex/3-4-4.png" alt></p><p><br></p><p>卡诺循环、奥图循环、狄赛尔循环，不论采用哪一种循环，都无法制作出可实际达成理论效率的热机。因为非常缓慢的活塞运动，根本就不具有实质上的利用价值。此外，活塞与汽缸无法完全绝热，不仅会因为温差而产生无谓的热移动，活塞与汽缸之间的摩擦，也不可能完全消除。不过厘清理论效率，可以突显热机的本质，为工程师提供重要的指标。</p><p><br><br><br></p><h3 id="可逆変化与不可逆变化"><a href="#可逆変化与不可逆变化" class="headerlink" title="可逆変化与不可逆变化"></a>可逆変化与不可逆变化</h3><p>自然的变化具有方向。</p><p>有一个重要的自然法则，会发生能量的损耗问题。请注意。</p><p><br></p><ul><li><strong>自然是从秩序朝向无秩序变化</strong></li></ul><p>准备高温与低温气体的两个容器。让温度不同的两个容器接触，热会从高温的容器朝向低温的容器移动。保持这一状态，不久后两个容器的温度将会相同，热将不再移动，进入平衡状态。若以微观的角度观察，最初高温的容器中，会有比较多激烈的分子；而低温的容器中，则较少激烈飞舞的分子。而在让容器互相接触时，高温容器内的分子的运动能量会朝向低温容器移动，低温容器内的分子的运动能量因而增加。等到两个容器内的分子平均运动能量（也就是温度）相等时，运动能量（热能量）的移动就会停止。</p><p><img src="/images/BeyondTheApex/3-5-1.png" alt></p><p><br></p><ul><li><strong>从无秩序朝向秩序的变化不会发生</strong></li></ul><p>接下来再从另一个角度观察。一开始，高运动能量的分子与低运动能量的分子，分处于不同的容器当中，可以明确区别出高温容器内的分子运动与低温容器内的分子运动。换句话说，容器内有可供判别两者差异的秩序存在，而可供区别其差异的资讯，就存在该项秩序当中。不过，达到平衡状态之后，可供判别两者间差异的资讯就会消失，进入所谓无秩序的状态。</p><p>事实上，上述从有秩序的状态朝向无秩序的状态之变化，对于自然界而言是十分自然的变化；相较于此，从无秩序朝向有秩序的变化，则不会自然发生。举例来说，让高温的容器与低温的容器接触时，高温的容器会冷却、低温的容器则会加温，这对于自然界而言是十分自然的变化。相较于此，让两个温度不同的容器接触时，高温容器的温度进一步提升，而低温容器的温度反而下降，这种现象绝不会发生。<br>像这种不论用何种方式，都不可能将现有状态恢复到与原本完全相同的状态的变化，就称为不可逆变化；而可以复原的变化，则称为可逆变化。</p><p><img src="/images/BeyondTheApex/3-5-2.png" alt></p><p><br><br><br></p><h3 id="尝试让热机逆向运转"><a href="#尝试让热机逆向运转" class="headerlink" title="尝试让热机逆向运转"></a>尝试让热机逆向运转</h3><p>可逆循环与不可逆循环的差异。</p><p>到底实际上引擎为何无法达到理论效率？在可达到理论效率的热循环中，必须让活塞以非常缓慢的速度动作。</p><p><br></p><ul><li><strong>卡诺循环的逆向运转是可逆的</strong></li></ul><p>在此，将卡诺循环以1-2-3-4的顺序运作的情况称为顺向运转；而以4-3-2-1的顺序运行的情况称为逆向运转。</p><p>让卡诺循环进行顺向运转，让特定量的热从高温热库移动至低温热库，并将过程中产生的功存储起来。接下来再用存储的功，让卡诺循环逆向运转，使在顺向运转中移动的热，从低温热库移动至高温热库，恢复与原本完全相同的状态，不会剩下任何东西。换句话说，也就是将卡诺循环顺向运转产生的功存储起来，再用存储的功进行逆向运转，恢复到与原本完全相同的状态。之所以能做到，是因为在卡诺循环的过程中，完全没有物体相互接触，因而完全不会发生无谓的热移动。换言之，卡诺循环的所有过程都属于可逆变化，所以才能进行可逆的你想运转。</p><p><img src="/images/BeyondTheApex/3-6-1.png" alt></p><p><img src="/images/BeyondTheApex/3-6-2.png" alt></p><p><br></p><ul><li><strong>汽车引擎的逆向运转是不可逆的</strong></li></ul><p>如果换成奥图循环或狄赛尔循环，有会如何？在此同样让上述循环顺向运转，将过程中产生的功存储起来，再用存储的功进行逆向运转。结果发现即使将在顺向运转中存储的功完全耗尽，也只能让一部分的热复原，无法让所有的热从低温热库移动至高温热库。</p><p>原因是它们两者的定容过程中，必然会出现温差。无论如何都会产生无谓的热移动。因此我们可以说奥图循环和狄赛尔循环是不可逆的。而这代表了一个非常重要的观念，那就是热机无法进行可逆的逆向运动，其实也就证明了在该循环中，有发生无法产生工的无谓热移动。</p><p><img src="/images/BeyondTheApex/3-6-3.png" alt></p><p><br><br><br></p><h3 id="能量的损耗"><a href="#能量的损耗" class="headerlink" title="能量的损耗"></a>能量的损耗</h3><p>能量的损耗其实就是不可逆变化。</p><p>在说明热机的理论效率时，我们多次强调了<strong>必须让活塞以非常缓慢的速度运动</strong>，其原因就是为了不要引起不可逆变化。因为不可逆变化，其实就是能量损耗的真面目。</p><p><br></p><ul><li><strong>引擎的能量损耗</strong></li></ul><p>如果在热机的运转过程中，包含了可归为不可逆变化的现象，则该现象就属于前文提到的无法作功的热移动，也就代表可使用的功会减少。<br>实际上引擎是通过在汽缸内引发燃烧的化学变化来产生热能，并以该能量让活塞运动、从而产生功。此时产生的热会造成温差，引起无谓的热移动。而汽缸与活塞之间也会产生摩擦，导致声音与扰流。此外，燃油的化学变化也属于不可逆变化。这些现象一旦发生，就绝对无法向影片的你想播放一样，恢复到与发生前完全相同的状态，因此属于不可逆变化。换言之，也就是无法作功的无谓热移动。</p><p><br></p><ul><li><strong>机械的能量损耗</strong></li></ul><p>先前探讨的对象都仅限于热机，而事实上机器装置的能量损耗，全部都是因不可逆变化而产生。反过来说，效率高的机器，可以说是在运作时尽可能减少不可逆变化的机器。因此，想要制作出效率高的机器，重要的关键之一，就在于理解何种现象属于不可逆变化，并极可能减少该现象的发生。</p><p><img src="/images/BeyondTheApex/3-7-1.png" alt></p><p><br></p><p>阿特金森循环是与奥图循环相同的热循环，一般来说，其机制是通过将奥图循环的膨胀行程延长，来产生更多的功。</p><p><img src="/images/BeyondTheApex/3-7-2.png" alt></p><p><br><br><br><br><br></p><h2 id="空气力学"><a href="#空气力学" class="headerlink" title="空气力学"></a>空气力学</h2><p><br></p><h3 id="白努利定律"><a href="#白努利定律" class="headerlink" title="白努利定律"></a>白努利定律</h3><p>思考流体的压力与速度的关系。</p><p>汽车的空气力学特性，对于耗油量、加速性能与行驶稳定性等，都有很大的影响。特别是赛车，其空气力学特性，对于车辆整体运动性能的贡献占有很大的比例。<br>因此，接下来就要解说作为汽车空气力学解析与设计基础的空气力学理论。</p><p><br></p><ul><li><strong>有流体流动时的分子运动</strong></li></ul><p>当有气流时，能量均分定理就无法成立。在气流当中，会有较多的分子运动能量被分配至流动的方向，而与气流不同方向的运动能量则会因而减少。如果在气流中量测压力，则在流动方向测到的压力会长高，在与流动垂直的方向量测到的压力则会最低。<br>在此要注意的是，在流动变化的前与后，分子运动能量的总和是不会改变的。</p><p><img src="/images/BeyondTheApex/4-1-1.png" alt></p><p><img src="/images/BeyondTheApex/4-1-2.png" alt></p><p><br></p><ul><li><strong>有流动时的分子运动</strong></li></ul><p>由白努利(Daniel Bernoulli)提出的白努利定律，代表当分子的能量分配因流速的变化而改变时，流速与压力的关系。</p><p>白努利定律的数学公式如下（P代表压力，ρ为流体的密度、V则是流速）：<script type="math/tex">P_0=P_1+\frac{1}{2}ρV_1^2=P_2+\frac{1}{2}ρV_2^2</script></p><p><img src="/images/BeyondTheApex/4-1-3.png" alt></p><p><br></p><ul><li><strong>升力发生的机制</strong></li></ul><p>接下来就用白努利定律，来说明翼型(airfoil)产生升力的机制。下图以流线代表翼型周围流场的示意图。所谓流线，是指以流体的速度向量为切线的曲线，也就是流动的路线。从流线的定义可以了解，气流不会横向穿过流线，换言之，被相同的流线上下包夹的区域，无论在哪个位置的流量都相同，这一点请留意。此外，流体存在的场域，称为流场(flow field)。</p><p>从下图的流场中可以了解，在翼型的前方，流线为等间隔，但在翼型的上表面，流线的间隔则会变窄。由于气流不会横向穿越流线，所以在翼型的上表面，实际上流路是被缩减的。尽管如此，由于被相同流线包夹的流路，其流量不会出现变化，所以在流路被缩减的翼型上表面，压力会与流速的平方成反比例降低。相反地，若翼型小表面的流线间隔变宽，则流速会下降、压力则会上升。而在此过程中产生的上表面压力与下表面压力的差，就是所谓的升力。</p><p><img src="/images/BeyondTheApex/4-1-4.png" alt></p><p><br><br><br></p><h3 id="流体的运动法则"><a href="#流体的运动法则" class="headerlink" title="流体的运动法则"></a>流体的运动法则</h3><p>流体的运动方程式代表的意义。</p><p><br></p><ul><li><strong>尤拉方程式</strong></li></ul><p>第一个导出流体运动方程式的，就是将白努利定律正确地以公式描述的尤拉。对于流体力学的进步而言，其重要性远超过白努利定律。因为若能解出气运动方程式，就可以计算出流场的状态。这个由尤拉导出的运动方程式，名为尤拉方程式(Euler equations)。</p><p><img src="/images/BeyondTheApex/euler-equations.png" alt></p><p>左边代表流体流动（加速）的效果；而右边则称为压力项，代表压力的梯度。总括来说，尤拉方程式描述的就是<strong>流体会沿着压力梯度流动</strong>。<br>压力梯度与流经该流场的流体之间的关系，可说是和斜面与滚过斜面的球的关系相同。这里的斜面相当于压力梯度，而球则相当于流体。举例来说，在斜面坡度较陡的地方，球会加速；而在斜面坡度方向相反时，则会减速。同样，流体在压力梯度高的地方会加速，与压力梯度方向相反时，则会减速。</p><p><img src="/images/BeyondTheApex/4-2-1.png" alt></p><p><br></p><ul><li><strong>那维尔-史托克方程式</strong></li></ul><p>尤拉方程式，虽然已数学方式描述了流体的速度与压力的关系，但并不包括流体实际上具有的黏滞性之效果。而将黏滞性效果列入考量的运动方程式，是在19世纪由Navier与Stokes导出的那维尔-史托克方程式(navier-stoker equations)。</p><p><img src="/images/BeyondTheApex/navier-stokes-equations.png" alt></p><p>左边是流体流动（加速）的效果；右边第一项为压力项，表示压力的梯度；右边第二项，则称为黏滞性项或扩散项，代表黏滞的特性。</p><p>尤拉方程式与那维尔-史托克方程式，到目前为止都还没有通解，所以只能直接适用于非常特殊的流体。在此情况下，要从这些方程式了解一般的流场，目前只能利用电脑以数值方式求解。</p><p><img src="/images/BeyondTheApex/navier-stokes-equations-2.png" alt></p><p><br><br><br></p><h3 id="涡线与不连续面"><a href="#涡线与不连续面" class="headerlink" title="涡线与不连续面"></a>涡线与不连续面</h3><p>回避流体运动方程式的策略。</p><p>尤拉方程式和那维尔-史托克方程式，都是可以正确描述流体运动的方程式，不过由于在数学上的难度过高，几乎无法适用于实际的流体，在发展上也出现瓶颈。在此情况下，因而出现了不仰赖上述方程式，来解析流体的动向。接下来就为各位介绍达朗伯特矛盾，与突破此一矛盾的尝试。</p><p><br></p><ul><li><strong>达朗伯特矛盾</strong></li></ul><p>达朗伯特(Jean Le Rondd’Alembert)，尝试以理论求出放置于恒定流中的圆柱的阻力（与流体的速度平行且逆向产生的力），结果他解出的阻力为0.</p><p>当然，在实际的流动中，阻力不会是0.尽管如此，在他的计算当中完全找不出错误，无论是由谁重新计算几次，得出的阻力都还是0，结果并没有改变。这成为了之后160年间流体力学上的重大问题，因此也被称为<strong>达朗伯特矛盾</strong>。</p><p>如果具备现代的知识，就可以了解他的计算本身完全没有错误，只是没有考量到流体的黏滞性，所以当然会导出阻力为0的结果。如果不考量黏滞性的恒定流，则圆柱前后的气流会对称，压力也会在圆柱前后形成对称，圆柱周围的压力会互相抵消，结果造成阻力成为0。</p><p>当时还没有那维尔-史托克方程式，对于黏滞性效果的处理方式，也不甚了解。一直到1904年德国物理学家Ludwig Prandtl提出边界层的概念之后，才完全解决了达朗特矛盾。</p><p><img src="/images/BeyondTheApex/4-3-1.png" alt></p><p><br></p><ul><li><strong>涡线与不连续面的概念</strong></li></ul><p>不直接针对流体的运动方程式求解，而是以数学的方式处理流体运动、开创出新境界的，就是德国的Hermann Von Helmholtz。他进一步扩展涡旋的概念，并提出新的流体概念。</p><p><img src="/images/BeyondTheApex/4-3-2.png" alt></p><p><img src="/images/BeyondTheApex/4-3-3.png" alt></p><p><img src="/images/BeyondTheApex/4-3-5.png" alt></p><p>Helmholtz导入涡线与涡层的概念后，让长达一世纪不得其解的朗伯特矛盾，突然豁然开朗。根据达朗伯特矛盾，平板的抗力应为0。不过，若假设没有不连续面从平板的前缘与后缘延伸，便可将平板的背面视为流速较低的范围，实际上达朗伯特矛盾便不再存在。虽然因为他们过度高估了平板背后的压力，结果并没有成功试算出阻力，不过计算阻力的努力确实是朝正确的方向迈进。</p><p><br><br><br></p><h3 id="库塔-贾可斯基定律"><a href="#库塔-贾可斯基定律" class="headerlink" title="库塔-贾可斯基定律"></a>库塔-贾可斯基定律</h3><p>升力的循环理论。</p><p>Kirchhoff与Reyleigh，假设不连续面是由物体的锐角部分所形成。不过，这种不连续面，会发生与物体表面的任何位置，所以也可以说物体表面是由涡层所覆盖。事实上，这种想法与升力理论中的<strong>升力之循环理论</strong>密切相关。</p><p><br></p><ul><li><strong>库塔-贾可斯基定律</strong></li></ul><p>由于物体表面的流速，会因为黏滞性而产生很大的变化，所以从物体表面的任何位置都会产生涡线，并成为覆盖物体的涡层。此时，覆盖物体的涡层整体的强度，便称为<strong>循环</strong>。如此一来，我们就可以将物体周围的气流，分离成均匀流与循环流两种（循环的定义，是指沿着任意的平曲线，将流速线积分后得出的量）。</p><p>假设有均匀流与循环流存在，来思考一下将两者重叠的流体。由于在循环流的上方，其流动方向与均匀流一致，所以上方的流速会增加。而在循环流的下方，均匀流与循环流朝反方向流动，若将两者重叠，流速将会降低。结果依据白努利定律，循环流上方压力会下降，下方压力则会上升，所以会产生向上的升力。<br>上述的流场正与翼型周围的流场类似，在翼型的上表面，流速变快、压力降低；而在翼型的下表面，则是流速变慢、压力上升。事实上，我们同样可以将翼型周围的流场，当作是均匀流与循环流的重叠流场来处理若能得出循环，就可用以下方式计算出升力：<script type="math/tex">升力=流体的密度×均匀流的速度×涡漩的循环(L=\rho V \Gamma)</script></p><p><img src="/images/BeyondTheApex/kutta-joukowski.png" alt></p><p><img src="/images/BeyondTheApex/4-4-1.png" alt></p><p><br></p><ul><li><strong>库塔条件</strong></li></ul><p>依据库塔-贾可斯基定律，若能解出物体周围的循环，就可以算出作用于该物体的升力。不过，要将该定律适用于翼型时，有一点必须特别注意，那就是基本上流体的方程式，是根据流动是平滑的这个前提导出。而对于尖锐或不连续的流动，通常必须另行考虑。</p><p>以翼型为例，翼型的后缘形状是尖的，因此在尖翼的后缘有一项限制，那就是无法满足翼型上表面的气流与下表面的气流会在翼型的后缘平顺汇进这个条件，库塔-贾可斯基定律就无法适用于机翼。而这个上表面与下表面的气流，会在翼的后缘平顺汇进的条件，就称为库塔条件。必须先满足库塔条件，才能决定循环，也才能用数学公式算出升力。<br>要补充的是，如果针对气流在翼加上攻角，则攻角愈大、要满足的库塔条件时所需的循环也会变大。因此攻角愈大、循环也会自然随之变大，结果也就会产生较大的升力。这就是将攻角加大、升力也会随之提升的机制。</p><p><img src="/images/BeyondTheApex/4-4-3.png" alt></p><p><br><br><br></p><h3 id="普朗特的边界层理论"><a href="#普朗特的边界层理论" class="headerlink" title="普朗特的边界层理论"></a>普朗特的边界层理论</h3><p>摩擦的影响局限于物体的表面附近。</p><p>Kirchhoff与Reyleigh计算阻力的尝试虽然失败，但已向成功迈进了一大步。接下来便介绍普朗特(Ludwig Prandtl)提出，最终解决了达朗伯特矛盾的<strong>边界层理论</strong>。</p><p><br></p><ul><li><strong>普朗特的边界层理论</strong></li></ul><p>想要估算阻力，除了压力之外，如何处理摩擦力也十分重要。而在处理摩擦力时，必须先了解物体表面的气流流动的情况。</p><p>率先提出边界层的概念，就是普朗特。他指出受到黏滞性的影响，物体表面的流速会变成0，而摩擦的影响，则仅局限于物体表面的邻近区域，而在其外部，气流基本上不会收到黏滞性的影响，可将该气流视为非黏滞性流体。而这个位于邻近物体表面、会受到黏滞性影响的范围，目前称为<strong>边界层</strong>。</p><p>普朗特于1904年发表名为《具有极低黏滞性的流体之运动》的论文，并在这篇仅有8页的论文中，首都提出边界层的概念。他指出那维尔-史托克方程式简化的边界层方程式。此外，利用他的边界层理论，在某种程度上也可以预测流体剥离的位置。<br>就这样，边界层理论完全解决了达朗伯特矛盾的问题。普朗特于1904年发表的这篇论文，为流体力学开创了新的发展，因而被视为流体力学史上最重要的论文。</p><p><img src="/images/BeyondTheApex/4-5-1.png" alt></p><p><img src="/images/BeyondTheApex/4-5-3.png" alt></p><p><br><br><br></p><h3 id="普朗特的升力线理论"><a href="#普朗特的升力线理论" class="headerlink" title="普朗特的升力线理论"></a>普朗特的升力线理论</h3><p>发生于有限翼的翼尖涡流问题。</p><p>Kutta和Joukowski催生了升力的循环理论，并得以正确计算出二维气流中的升力。不过一般来说，翼周围的气流都是三维的，无法直接使用二维流体的翼型理论。在此情况下，就必须构建出翼在三维流场中的升力理论。</p><p><br></p><ul><li><strong>有限翼展翼周围的气流情况</strong></li></ul><p>翼型也可以说是拥有无限长翼展的翼。这种无限翼展翼，在翼展任何一个位置的循环大小都相同，升力也维持一定，因此无限翼展翼可以直接使用库塔-贾可斯基定律。<br>不过，实际上翼的翼展是有限的。所以在翼尖，气流会从压力较高的下表面流动至压力较低的上表面，其压力分布会与无限翼展不同。愈靠近翼尖，升力会变得愈小。此外，从翼尖的高压侧转入低压侧的气流会形成纵向涡旋，并朝向背风面流动。这种以翼尖为起点产生的涡旋，称为翼尖流。</p><p><img src="/images/BeyondTheApex/4-6-1.png" alt></p><p><img src="/images/BeyondTheApex/4-6-3.png" alt></p><p><br></p><ul><li><strong>普朗特的升力线理论</strong></li></ul><p>普朗特提出的有限翼展翼升力理论，成功的赋予了Lanchester建构的模型非常相似，不过普朗特成功赋予了该理论严密的数学描述，这是Lanchester没有做到的。<br>普朗特构思出的模型，是沿着翼展方向在翼面配置由无数个无限弱的涡线组成的涡线束，而每条涡线均朝着背风面玩去流动。这个无限弱的涡线，就称为升力线。<br>利用普朗特的升力线理论，可以算出有限翼可产生的升力与力矩。此外，普朗特也证明了由翼尖涡流诱发的下洗(downwash)气流造成的阻力，也就是诱导阻力的存在，并以理论阐明了翼展愈大的翼，其诱导阻力就会愈小。</p><p><img src="/images/BeyondTheApex/4-6-4.png" alt></p><p><img src="/images/BeyondTheApex/4-6-6.png" alt></p><p><br><br><br><br><br></p><h2 id="计算流体力学"><a href="#计算流体力学" class="headerlink" title="计算流体力学"></a>计算流体力学</h2><p><br></p><h3 id="CFD的世界"><a href="#CFD的世界" class="headerlink" title="CFD的世界"></a>CFD的世界</h3><p>CFD是一个被离散化的世界。</p><p>随着电脑的普及，利用电脑求出流体方程式数值解答的手法持续发展。而这也是<strong>Computational Fluid Dynamics(计算流体力学、数值流体力学)</strong>，也就是统称为CFD的学问。目前CFD已成为研发汽车时不可或缺的工具，但一般人对于其机制都不甚了解。所以接下来就简单介绍一下与CFD有关的理论概念。</p><p><br></p><ul><li><strong>近似</strong></li></ul><p>真实的世界是类比，换言之，也就是平滑而连续的，无论在何时取出任何一个空间的一点，里面都包含了某些物理的资讯。相较于此，电脑是数位的，只能处理不连续的分散数值，也只能保存有限的资讯。因此CFD也只能将原本平滑连续的时间与空间分割，当成不连续的物体来处理。尽管如此，在CFD的世界当中，仍希望能尽量呈现出与真实世界接近的平滑类比世界，所以会通过模型化，来补足电脑没有的资讯。<br>那么，应通过何种方式，来补足资讯欠缺的部分？答案其实很简单，只要用直线将电脑的资讯连结起来，将资讯欠缺的部分视为直线变化；或是用曲线进行模型化，将资讯欠缺的部分，以曲线变化的方式来补足即可。这种精确来说与原本的资讯有差异，却是在不减损原本资讯的性质下，进行单纯化的作业，称为<strong>近似</strong>。而通过此一过程所得出的与原本数值非常接近的数值，则称为<strong>近似值</strong>。在CFD当中，将上述的近似手法，称为数值法(scheme)。</p><p><img src="/images/BeyondTheApex/5-1-1.png" alt></p><p><br></p><ul><li><strong>Lax等价定理</strong></li></ul><p>只要近似值与真值之间的误差够小，在实用上就不会有问题。因此，对于解析气流的人来说，无意义的极小数值可以忽略，而通过模拟得出的结果误差，只要小于必要的精度，以专业的术语来说，只要模拟的计算结果向真值<strong>收敛</strong>即可。<br>接下来介绍一个重要的定理，那就是由Peter David Lax证明的<strong>Lax等价定理</strong>。这个定理的内容是<strong>会趋于收敛的唯一数值法，就是稳定且相容的数值法。</strong>换言之，所谓的Lax等价定理，可以说就是指<code>稳定性+相容性=收敛性</code>的关系。</p><p><img src="/images/BeyondTheApex/5-1-3.png" alt></p><p><img src="/images/BeyondTheApex/5-1-4.png" alt></p><p><br><br><br></p><h3 id="有限体积法"><a href="#有限体积法" class="headerlink" title="有限体积法"></a>有限体积法</h3><p>运用最广泛的流体模拟方式。</p><p><br></p><ul><li><strong>有限体积法的概念</strong></li></ul><p>有限体积法主要是针对被分割的个别空间元素，留意其流入量与流出量的平衡（如<code>1秒后容器中的水量=原本的水量+流入量-流出量</code>）。在实际的流体模拟中，处理流体的量之外，对于压力与流速等物理量，也是用同样的方式计算。</p><p><br></p><ul><li><strong>数值通量</strong></li></ul><p>接下来让我们按照实际的CFD，更具体地观察有限体积法的基本概念。如下图，将空间细细分割，如此分割出来的空间，称为网格(grid)。让我们思考一下流经这些网格的流体。</p><p>首先，假设我们知道每个网格在特定时刻拥有的物理量，然后再根据这些资讯，以单位时间的流出量与流入量，来预测未来每个网格中的物理量——这就是以有限体积法模拟流体的方式。<br>上述流入量与流出量，必须由操作CFD的人，根据当下的物理量之分布，用某种方式来推测出最合理的数值。换句话说，决定这些量的方式，有可供选择的空间，因此单位时间的流入流出量，无法定义为单值。向这种有人为选择空间的单位时间流入流出的物理量，称为<strong>数值通量</strong>，而数值通量的精度，会大幅左右计算结果的精度。</p><p><img src="/images/BeyondTheApex/5-2-2.png" alt></p><p><img src="/images/BeyondTheApex/5-2-3.png" alt></p><p><br><br><br></p><h3 id="数值法的特征"><a href="#数值法的特征" class="headerlink" title="数值法的特征"></a>数值法的特征</h3><p>单调性与高精度无法兼顾。</p><p>数值通量的精度，会因为采用的数值法而出现差异，当然也会影响到模拟的精度。若采用了不适当的数值法，则误差将随着计算你的进行而持续扩大，计算甚至可能发散。</p><p><br></p><ul><li><strong>一街精度的数值法</strong></li></ul><p>一阶精度的数值法，优点在于可维持单调性，但缺点则是得出的解容易扩散。</p><p><img src="/images/BeyondTheApex/5-3-1.png" alt></p><p><br></p><ul><li><strong>高阶精度的数值法</strong></li></ul><p>采用高精度数值法得出的解，精度通常较高。不过，愈是高阶，就代表须从更多的网格中取得更多的物理量来进行计算，计算量势必会大增。此外，采用高阶精度数值法得出的解，在部分情况下会出现振荡，反而会导致精度下降，这也是其缺点之一。</p><p><img src="/images/BeyondTheApex/5-3-2.png" alt></p><p><br></p><ul><li><strong>戈多诺夫定理</strong></li></ul><p>数值法无法兼顾高精度与解的单调性（解不会出现振荡），这一点已经过数学上的验证，也就是所谓的戈多诺夫(Godunov)定理。根据戈多诺夫定理，可同时满足高精度与解不会出现振荡的数值法并不存在，无论如何费心，都无法制作出两全其美的高阶精度数值法。</p><p><img src="/images/BeyondTheApex/5-3-3.png" alt></p><p><br><br><br></p><h3 id="一阶与高阶精度的并存"><a href="#一阶与高阶精度的并存" class="headerlink" title="一阶与高阶精度的并存"></a>一阶与高阶精度的并存</h3><p>设法让一阶精度与高阶精度并存。</p><p><br></p><ul><li><strong>TVD法</strong></li></ul><p>只要配合气流的性质，妥善运用不同数值法各自的优点，应该就能得出良好的计算结果。基于这种想法而实际开发出来的，就是名为TVD的数值法。<br>TVD是一阶精度与高阶精度的混合数值法，特别注重于避免增加解整体的变动。它可以自行判断气流变化的激烈程度，大部分的气流以高阶精度进行计算，而气流急剧变化的部分，则切换为一阶精度，以维持其单调性。</p><p><img src="/images/BeyondTheApex/5-4-1.png" alt></p><p>TVD法不会像高阶精度的数值法般出现预测过度(overshoot)或预测不足(undershoot)的振荡。此外，TVD法也比一阶精度数值法更能控制解的扩散。而且不论与一阶或高阶的数值法相较，TVD法得出的解都更接近真值。<br>不过，TVD法必须有判定流场变化的作业程序，因此多少会消耗额外的计算时间。</p><p><img src="/images/BeyondTheApex/5-4-2.png" alt></p><p><br><br><br></p><h3 id="如何解析紊流"><a href="#如何解析紊流" class="headerlink" title="如何解析紊流"></a>如何解析紊流</h3><p>设法降低庞大的计算量。</p><p><br></p><ul><li><strong>解析涡旋</strong></li></ul><p>汽车行驶时，其周围会发生紊流。紊流是由大大小小的空气涡旋构成。无论其结构有多单纯，要计算一个涡旋，至少需要9个网格。如果要直接计算车子周围所有的涡旋，所需的网格数量将会及其庞大，这应该很容易可以想象。</p><p><img src="/images/BeyondTheApex/5-5-1.png" alt></p><p><img src="/images/BeyondTheApex/5-5-2.png" alt></p><p><br></p><ul><li><strong>紊流模型</strong></li></ul><p>在进行研究分析时，通常会将以上述成果为基础的紊流模型导入CFD，放弃解析构成紊流的大大小小的所有涡旋，而仅计算具有特征的部分，以缩减庞大的计算量。接下来就简单介绍一下目前应用最为广泛的RANS与LES这两种紊流模型。</p><p><br></p><ul><li><strong>RANS(Reynolds Averaged Navier-Stokes)</strong></li></ul><p>RANS，是将紊流的流速，分成平均流速与其中的变动成份之紊流模型。由RANS的计算量相对较少，所以是应用最为广泛的紊流模型。不过，它无法正确重现非恒定的气流，所以有较难正确估算剥离等的缺点。</p><p><img src="/images/BeyondTheApex/5-5-3.png" alt></p><p><br></p><ul><li><strong>LES(Large Eddy Simulation)</strong></li></ul><p>在紊流当中，拥有支配性影响力的是大型的涡旋：小型涡旋对于整体流场的影响则相对较弱。而放弃直接解析小型涡旋，只计算大型涡旋，并将小型涡旋模型化的方式，就是所谓的LES。与RANS相较，LES能够以非常高的精度重现流场，但计算量也远超RANS。</p><p><img src="/images/BeyondTheApex/5-5-4.png" alt></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="汽车结构"><a href="#汽车结构" class="headerlink" title="汽车结构"></a>汽车结构</h1><p>Mechanism</p><p><br></p><h2 id="车的基本要件"><a href="#车的基本要件" class="headerlink" title="车的基本要件"></a>车的基本要件</h2><p>车身骨架和基本结构的皮遏制称作车子的基本性能，从设计初期阶段便已决定，无法轻易更动。这是一辆车的潜能，会大幅影响它的三大性能： <strong>行进、过弯、停止</strong>，同时也是用来判断一辆车的行进性能的重要基准。有关基本性能的部分，大多难以通过改装加一弥补，医药一点点规格上的差异，便足以影响上路时表现的优劣。</p><p><br></p><h3 id="车身尺寸"><a href="#车身尺寸" class="headerlink" title="车身尺寸"></a>车身尺寸</h3><ul><li><strong>轴距(wheel base)</strong></li></ul><p>从车身侧边看去，自前轮中心起到后轮中心为止的长度就叫做轴距。<br>这项特性主要影响车子行进间的安全性。轴距越长越不容易受到路面的高低起伏和横风的影响，在直线行进时具有较高的安定性。一般而言，虽然轴距较短会降低车辆稳定性，但是当方向盘转向时，反应会变得较为敏锐，并可更灵活地过弯。就乘客的感受来说，长轴距可提供舒适的感受。</p><p><img src="/images/BeyondTheApex/wheel-base.png" alt></p><p><br></p><ul><li><strong>外悬(Overhang)</strong></li></ul><p>从前轮中心至前保险杠前端的距离称为<strong>前悬(front overhang)</strong>，从后轮中心到后保险杠末端的距离称为<strong>后悬(behind overhang)</strong>。<br>如果有重物位于这个部位，将使得车的偏向惯性力矩（妨碍转向的力量）变大，降低车子的运动性能。因此从结构上来看，重量应尽量设置在轴距内侧较为理想。这一点对于引擎这类重型机具而言更是格外重要。另外，必须保留一定以上的外悬长度，才能处理空力的问题。</p><p><img src="/images/BeyondTheApex/overhang.png" alt></p><p><br></p><ul><li><strong>轮距(tread)</strong></li></ul><p>左右轮间的距离称为轮距。放宽轮距则可降低车身假想重心的高度。<br>一般而言，轮距越宽，过弯时轮胎的抓地力效果越大。因此，若放大驱动轮的轮距，便有利于将汽车的马力传到到地面。在比赛用车种上，常会将前后轮改装成不同轮距，以改变操控感。另一方面，若轮距相较于轴距在比例上显得极度狭窄，则虽然可以得到快速的操纵反应，却也较容易使车子时区稳定性。</p><p><img src="/images/BeyondTheApex/tread.png" alt></p><p><br></p><ul><li><strong>车高(height)</strong></li></ul><p>指从路面至车身最高处的高度。<br>车高越低，则因为重心降低，可以抑制过弯时的晃动（车身横向的倾斜），提升回转反应速度。另一方面，降低车高将会影响车内的舒适性，切回造成难以确保悬吊行程的状况，是的行经赛道路石等处时，发生触底（避震行程完全用尽）的原因。</p><p><img src="/images/BeyondTheApex/height.png" alt></p><p><br></p><ul><li><strong>车重(weight)</strong></li></ul><p>这是左右汽车运动性能的重要因素。<br>车重越轻，引擎负担也会降低，在动力性能面较占优势，且因降低了对刹车曹成的负担，得以提升制动力。另外，更因省去了惯性造成的浪费，让过弯变得更加轻快，好处不胜枚举。<br>将车重除以最高输出功率的值称为<strong>重量马力比</strong>。这个值越小，包括出弯后起步在内的加速性将更敏锐，车子行驶起来也更加灵活，且在降低燃料消耗率方面也极具效果。因此从环保性能的角度来看，车重轻量化业已成为开发新车时的重要主题。</p><p><br><br><br></p><h3 id="重量平衡与驱动方式"><a href="#重量平衡与驱动方式" class="headerlink" title="重量平衡与驱动方式"></a>重量平衡与驱动方式</h3><p>驱动方式和车身尺寸同样属于基本的规格。驱动方式视引擎安装位置、驱动轮位置而定。一般分为：FF、FR、MR、RR等种类。决定将车身上最重的零件——引擎安装在哪里？又要让它驱动哪个轮胎，是决定车身重量平衡的重大因素。</p><p>一台重量平衡良好的车，可以让引擎动力有效地传导到驱动轮上，对于起步/加速性能都有帮助；刹车时不容易让车身受惯性影响而向前倾，并可以更有效地发挥刹车性能。</p><p>重量平衡影响最大的是过弯。由于过弯时离心力会使得车子变得不稳定，因此重量分配不当的车子，在车身过弯离心力增加的情况下，更容易发生打滑等风险。</p><p>基本上，车身重量分配的理想值为前后、左右各为50比50。将引擎安置在车身前部，驱动后轮的FR式配置较易实现上述50比50的比例。另一方面，将引擎和驱动机组集中在车身前方的FF（以及4WD）式配置，则较易呈现中心在前的倾向。引擎和驱动机组集中在车身后方的RR式配置，则较易呈中心在后的倾向。因此，部分FF配置的车种为了改善重量分配的问题，会可以将横向安置为主流的引擎，改为纵向方式安置。</p><p><br></p><p>驱动方式的种类：</p><ul><li><strong>FR(Front engine Rear drive)</strong><br>引擎安置于车厢前方，并驱动后轮的配置。<br>最易实现前后重量50:50的理想数据。除了具备优异的操作感受外，由于操舵轮和驱动轮的分离设计，因此不需要特别去习惯操舵感觉，则是它的另一优点。然而，随着路面状况不同，这种配置也会发生难以获得驱动力的情形。</li></ul><p><img src="/images/BeyondTheApex/front-engine-rear-drive.png" alt></p><p><br></p><ul><li><strong>FF(front engine front drive)</strong><br>集中在前方的引擎驱动配置。<br>由于结构上将沉重的引擎和变速器都收纳在引擎盖当中，因此，虽然可提供更宽广的车厢空间，却无可避免地将使重量集中于车体前方。又因为前轮必须同时扮演了驱动和操舵轮两种角色，以致在过弯时，车胎的抓地力必须兼顾维持直进与转向两个部分。正因如此，这样的配置通常不太适合大马力的车种使用。</li></ul><p><img src="/images/BeyondTheApex/front-engine-front-drive.png" alt></p><p><br></p><ul><li><strong>MR(Mid engine rear drive)</strong><br>引擎装在车身中央来驱动后轮，也称为中置引擎(middle-ship)配置。<br>通过将引擎安装在车身中央附近、缩短引擎与车辆重心距离的方式，让车辆发挥锐利的过弯性能。且无论在加速或减速时，前后轮都能发挥最大的抓地力。这种配置对于车子行驶最为有利，是纯跑车、赛车常见的固定配置。</li></ul><p><img src="/images/BeyondTheApex/mid-engine-rear-drive.png" alt></p><p><br></p><ul><li><strong>RR(rear engine rear drive)</strong><br>引擎安装在比后轮更后的后悬部位来驱动后轮。<br>这样的做法会导致车辆重心偏后。然而，由于引擎和变速器的重量将后轮牢牢地压在路面上，因此反而容易取得驱动力，今儿获得更优秀的加速性能。但相反，由于前轮缺少负重，因此在过弯初期容易发生转向不足的问题。又因为后轮负重较重，因此在后胎超过负荷时，会产生激烈的打滑现象，想要从这样的状况中恢复正常，需要极高的驾驶技巧。</li></ul><p><img src="/images/BeyondTheApex/rear-engine-rear-drive.png" alt></p><p><br></p><ul><li><strong>4WD(four wheel drive)</strong><br>通过前后左右四个轮胎进行驱动。<br>这种配置架构除了增加车辆总重量的小缺点以外，可以说是姿势和起步与加速的驱动配置。然而，高度的稳定性却也意味着不容易过弯。</li></ul><p><img src="/images/BeyondTheApex/four-wheel-drive.png" alt></p><p><br><br><br><br><br></p><h2 id="车的心脏"><a href="#车的心脏" class="headerlink" title="车的心脏"></a>车的心脏</h2><p>在组成汽车的零件中，引擎扮演着最重要的角色。能够正确掌握引擎的原理，搭配上正确的操作，才能百分百发挥出车子的性能。</p><p><br></p><h3 id="构造与原理"><a href="#构造与原理" class="headerlink" title="构造与原理"></a>构造与原理</h3><p>几乎所有的燃油引擎车都搭载4衝程的往复式设计。往复式引擎当中配有汽缸，靠着汽缸中的活塞往返运动来产生动力。而所谓的4衝程设计，便是因具采用了<strong>进气-压缩-燃烧-排气</strong>等4到反复程序设计而命名。</p><p>首先，在活塞到达汽缸上死点前，进气门便会打开，而在活塞达到死点后开始下降，因此会自动开启的进气门吸入空气与汽油的混合气体。当活塞降至最下方，进气衝程即告结束，进入压缩衝程。此时，在所有气门都已关上的气缸当中，活塞开始加压前述混合气体。<br>当压缩混合气体的活塞抵达稍微超过顶点的位置时，火星塞即会进行点火，于是便告进入燃烧衝程。此时汽油引擎的气缸内部甚至可以达到摄氏2000度以及200个大气压力。这样高温高压的能量会将活塞往下推，并推动曲轴以产生回转的动力。<br>活塞抵达下端后，排气门便会打开，展开排气衝程。在此衝程中，与其说是活塞把气体推排出去，不如说是这些排出气体因本身夹带了高温、高压动力，自动地从排气门喷出。排气后， 顶点的进气门有会打开，于是再度回到进气衝程。</p><p>4衝程引擎即使在怠速状况下1分钟，也会执行数百次这4道步骤，在全力运转的状况下能够以1分钟数千次的速度转动曲轴，以持续产生动能。</p><p><img src="/images/BeyondTheApex/engine.png" alt></p><p><br><br><br></p><h3 id="气缸配置的种类"><a href="#气缸配置的种类" class="headerlink" title="气缸配置的种类"></a>气缸配置的种类</h3><ul><li><strong>直列型(in-line engine)</strong><br>将复数汽缸配置成一列的设计。<br>所有的汽缸均共享一根曲轴，可让气缸体机组成为整体化结构，因此有着结构简单、且较能降低重量的优点。然而，若汽缸数量越多，则本体长度也会随之增加，同事会影响空间上的运用。</li></ul><p><img src="/images/BeyondTheApex/in-line-engine.png" alt></p><p><br></p><ul><li><strong>V型(V engine)</strong><br>将汽缸左右交互配置呈V字型。<br>这种配置可以缩短曲轴的长度，优点是在多汽缸的情况下，也能有效缩小引擎本身的体积。且无论汽缸数量有多少都不易震动，而较短的汽缸区块和曲轴长度，同时可让结构更为坚固。</li></ul><p><img src="/images/BeyondTheApex/v-engine.png" alt></p><p><br></p><ul><li><strong>水平对向型(flat engine)</strong><br>将汽缸左右交互进行水平配置的型式。<br>各汽缸以曲轴为中心左右对置，且对向的活塞呈现左右对称的动作。就好像拳击场上两名选手交互打出的拳击一般，因此也被称为拳击手(boxer)引擎。另外，由于引擎高度较低，因此也有这适合低重心化的优点。</li></ul><p><img src="/images/BeyondTheApex/flat-engine.png" alt></p><p><br></p><ul><li><strong>W型(W engine)</strong><br>原本是指1根曲轴对应3列气缸呈扇状安置的引擎设计，不过，现在也可用来称呼结合了2组狭角V型引擎的机组。这种配置的宽度大于V型引擎，但是在汽缸数超过12颗以上的多汽缸架构下，此种配置可以缩短曲轴长度（即引擎全长），并带来更大的好处。</li></ul><p><img src="/images/BeyondTheApex/w-engine.png" alt></p><p><br><br><br></p><h3 id="气门驱动方式"><a href="#气门驱动方式" class="headerlink" title="气门驱动方式"></a>气门驱动方式</h3><p>4衝程引擎当中，有着在进气衝程中开启以自外部引入混合气体的进气门，以及在排气衝程中开启以将燃烧气体送出外部的排气门。气门设置在汽缸盖的位置，负责在适当的时机阻隔/连接燃烧室与外界。</p><p>现代引擎一般选在将凸轮轴设在引擎的上半部，以更加正确地驱动气门。关于气门的数量，目前几乎都采用2个进气门、2个出气门，共计4气门的设计。不过，今后为了追求在低转速领域的燃烧效率，像进气门、排气门各1的2气门设计，仍很有可能重新面世。<br>另外，近来潮流倾向于采用可变气门正时系统。原本在低转速和高转速领域间转换时，气门开闭正时也必须随之变更。然而，之后已进步到可随着引擎回转连续不间断地变换气门开闭正时和扬程深度。而自BMW推出可变气门扬程系统后，市面上一系列最新的可变气门结构，更能在不通过节流阀的情况下调整输出功率，这项进展得以进一步地提升效率。</p><p><br></p><p>气门驱动方式的种类：</p><ul><li><strong>DOHC(double over head camshaft)</strong><br>DOHC(双凸轮轴)，使用两根凸轮轴分别驱动进气与排气门的设计。此设计减轻了凸轮轴的负担，不仅能更加确实地执行开关气门的动作，同时可以降低气门结构附近的往复运动质量（即惯性），以获得高转速表现。该配置也容易取得高输出功率，因此今日几乎所有的高性能引擎，都采用这种设计。</li></ul><p><img src="/images/BeyondTheApex/DOHC.png" alt></p><p><br></p><ul><li><strong>SOHC(single over head camshaft)</strong><br>在汽缸盖上设置1根凸轮轴的方式就称为SOHC(单凸轮轴)。依照燃烧室的形状不同，又可区分为凸轮轴直接驱动气门，或由凸轮轴通过一种像跷跷板的零件锁臂(locker arm)驱动气门。它拥有更可靠的气门运作表现，且可获得更高的转速。</li></ul><p><img src="/images/BeyondTheApex/SOHC.png" alt></p><p><br></p><ul><li><strong>OHV(over head value)</strong><br>OHV(顶置气门式)。顾名思义，气门机组设于汽缸盖上方。它与SOHC、DOHC引擎之间的差别，在于凸轮轴不是位于顶部，而是在汽缸旁，并从这个位置通过一种叫做推杆的长棒和锁臂来驱动气门。虽然此中结构较为简单、且便于维修，不过，在高速运转的状态下却缺乏可靠性，也因此通常不适合被赋予大功率输出。</li></ul><p><img src="/images/BeyondTheApex/OHV.png" alt></p><p><br><br><br></p><h3 id="转子引擎"><a href="#转子引擎" class="headerlink" title="转子引擎"></a>转子引擎</h3><p><strong>转子引擎(rotary engine)</strong>基本上也和往复式引擎一样，通过反复进气、压缩并燃烧、最后排除废气的过程来取得运转能力。然而在这样的过程中，转子引擎所用的原理却和往复式引擎完全不同。</p><p>在转子引擎当中有著名为转子室的茧形空间，完全取代了汽缸的功能。三角形的转子就安置在这个空间当中。在转子于其中进行偏心旋转时，转子和转子室之间的空间大小会有所变化，在此进行压缩-燃烧-排气过程。<br>一般引擎之中通常拥有复数组的活塞反复运动，因此不仅难以控制作用力，同时也成为振动与噪音的起因。然而，由于转子引擎利用了旋转运动的原理，因此运转起来较为平稳顺畅。又因为不具备气门机组，所有有着零件总数大幅减少的优点。不过，随着往复式引擎近年逐步地趋向轻量化，相较之下，此优点并不显得格外突出，然而不可否认的，这种引擎整体而言是较为小巧的。<br>转子引擎进气与排气的时机，取决于设置于转子室壁面与侧面的气埠（混合气体的通道）的形状而定。调节转子引擎的进气/排气时机，基本上便是通过改变气埠的位置和形状来进行。又由于回转引擎中不具备排气门，而是让排气动能直接自排气埠排出，因此非常适合搭配涡轮增压器。<br>另一方面，转子引擎普遍被认为在节省燃料费用方面的表现不如往复式引擎。这是因为转子引擎的燃烧室容积与表面积比例相对较大，容易让热能散失，因此导致转换成回转动能的比例较低。</p><p><img src="/images/BeyondTheApex/rotary-engine.png" alt></p><p><br><br><br></p><h3 id="增压器"><a href="#增压器" class="headerlink" title="增压器"></a>增压器</h3><p>若能让引擎吸入越多空气，便能提升越多马力。因此增加功率最简单的作法，便是从提升排气量着手。</p><p>然而有种东西可以不必提升排气量，便可获得相同的效果，那就是<strong>增压器(compressor)</strong>。这种装置可以大略分为<strong>机械增压器(supercharger)</strong>和<strong>涡轮增压器(turbocharger)</strong>。不过，大致上都是将空气压进引擎中（称为加压），以达到与提升排气量相同的效果。<br>加压空气时的压力称为增压，提升此压力，便能得到更大的输出功率。</p><p>大气压为1气压时，记为<code>1bar</code>或<script type="math/tex">1kg/cm^2</script>。因此，若过增压为<code>1bar</code>连同大气压在内合计有<code>2bar</code>的压力，意味着会迫使2倍的空气进入引擎当中。</p><p>增压器的缺点在于随着增压提升，燃烧能量亦会提高，但同时却也会对引擎造成较大的损伤，例如偶发性的异常燃烧现象等。因此，装有增压器的引擎当中，大多会同时补强引擎内部零件的强度，或是降低压缩比例，以减少发生异常燃烧的次数。<br>另外，空气经压缩之后将会夹带热能，使得密度降低，尤其在高负荷运作的条件或夏季时会特别显著，而此时点火亦无法得到巨大的爆发力（马力输出功率）据说进气温度每上升1度，便会损失1ps。因此，通过装设中冷器来降低压缩空气的温度，已被车坛视为常识。</p><p>由于增压器使用排气端的废气来推动增压器，因此在产生增压之前会出现一段延迟时间。另一方面，使用引擎曲轴作为动力来源的机械增压器虽然无此烦恼，但却会丧失些许引擎本身的功率输出。<br>近来颉取两种增压器的长处：在低转速领域使用机械增压，但到了高转速领域该用涡轮增压的新引擎设计，开始受到业界注目。</p><p><br></p><ul><li><strong>机械增压器(supercharger)</strong><br>自引擎曲轴通过皮带来驱动增压器(compressor)，并将空气压缩后供给引擎的装置，便称为机械增压器。<br>由于增压器的动力来自于曲轴运转，因此和涡轮增压器相比，具备<em>在低回转领域有着极大的增压效果</em>、<em>加速反应灵敏</em>等优点，并且相当适合搭配自动变速器。</li></ul><p>图为鲁式(Rootsblower)机械增压器，其它还有李式(Lysholm)双螺管机械增压器、涡卷式(Scroll)等不同种类。</p><p><img src="/images/BeyondTheApex/supercharger.png" alt></p><p><br></p><ul><li><strong>涡轮增压器(turbocharger)</strong><br>Turob意即涡轮机，通常是指利用通过排气管所排出的排气压力，来推动涡轮云总的增压器。<br>由于使用排气动能作为动力，因此没有像机械增压器那样，会发生在高转速领域损失驱动力的缺点。但相对来说，由于排气的动能较低，在低转速领域不足以转动涡轮，就算想要开始加速，也必须等待涡轮转速升高。这就是所谓涡轮增压延迟现象的成因。为了克服此问题，技术人员想出了各种不同的系统架构，现在也仍不断地改进当中。目前欧洲地区仍持续推出可提升油耗表现的小型化涡轮引擎。</li></ul><p><img src="/images/BeyondTheApex/turbocharger.png" alt></p><p><br><br><br></p><h3 id="混合驱动系统"><a href="#混合驱动系统" class="headerlink" title="混合驱动系统"></a>混合驱动系统</h3><p>混合驱动系统的目的在于<strong>并用引擎与马达以降低燃料消耗率</strong>。日本走在这个领域的前端，所开发出来的混合驱动车种清一色都是所谓的环保车，不过随着欧洲的车厂也开始研究，也许有朝一日这种系统会成为核心设计。</p><p>这种系统的弱点，在于引擎怠速和起步时的效率较差。不过，马达即使在零转速的情况下也能发挥最大扭力，且效率亦高，可以有效弥补引擎不擅长的低回转领域。而在速度上升之后，引擎运转的效率也随之提高，而相对低马达的输出效率则会下降。因此为了让两种机组都能在各自擅长的领域有所发挥，以充分提升能源的使用效率，混合驱动车便应运而生了。<br>车上同时装载马达和电池的优点，在于可以回收能源再利用。这样的机制称为<strong>回生</strong>，在未踩油门/刹车时，会运用轮胎的转动能量带动发电机为电池充电，而这些存下来的电能，则可于再度驱动马达时使用。原本刹车产生的热能只能任其丧失，如今却能够回收成电能并再度利用。<br>本系统的另一个优点，在于马达可以弥补引擎的性能，发挥近似于增压器的功能。欧洲车厂制作混合驱动车时，大多着眼于此。它们推出的这类车种，在设计上大多不使用增压器，改采用电动马达来呈现大排气量车种的驾驶感。</p><p><br></p><p><img src="/images/BeyondTheApex/toyota-prius.png" alt></p><p><br></p><p><strong>混合驱动系统种类</strong></p><ul><li>串联式(series hybrid)</li><li>并联式(parallel hybrid)</li><li>串并联混合式(series-parallel hybrid)</li></ul><p><img src="/images/BeyondTheApex/hybrid-drive-system.png" alt></p><p><br><br><br></p><h3 id="车子性能的关键字"><a href="#车子性能的关键字" class="headerlink" title="车子性能的关键字"></a>车子性能的关键字</h3><p>车辆的规格表上通常列出了许多数值与专有名词。必须充分掌握这些资料的意思以及解读方式，才能了解车子的引擎性能，并且推敲出车子锁蕴含的潜能。</p><p><br></p><p><strong>马力(horsepower)</strong></p><p>最能直截了当地表现出引擎性能的数值，便是以<code>ps</code>为单位的<strong>马力</strong>。1马力代表能将75KG重的物体在1s内举起1公尺的工作效率。<br>也就是说，1台100马力的引擎可以将1T中的物体在1s内举起<code>7.5</code>公尺。马力是由<code>扭力x引擎转速</code>求得，所以即使引擎的排气量小，只要转速高，一样能够发挥出输出功率。顺便说一句，国际通用规格使用<code>kW</code>来换算马力（<code>1ps:0.735kW</code>）。</p><p><img src="/images/BeyondTheApex/horsepower.png" alt></p><p><br></p><p><strong>扭力(torque)</strong></p><p>用来表示回转力的数值称为扭力。<br>将长1公尺的扳手，对于位于1公尺源的螺帽施加1KG的力使其旋转时的回转力写做<code>1kg-m</code>。就引擎而言，扭力通常用来表示曲轴所拥有的回转力。扭力几乎等同于燃烧能，以自然进气引擎而言，大致上可以得到等同于排气量的扭力。<br>一辆车的扭力越强，表示维持引擎回转的力道越强，如此一来我们便能说，这对驾驶人而言是一辆好驾驭的车子。</p><p><img src="/images/BeyondTheApex/torque.png" alt></p><p><br></p><p><strong>排气量/汽缸数(displacement/cylinder)</strong></p><p>从排气量可以得知引擎能够吸入多少混合气体。这在往复式引擎来说，即<code>活塞运动中往返的圆柱体积x汽缸数</code>。</p><p>当引擎排气量越大，获得的输出功率也越大。然而若单个汽缸的容积过大，相对也会妨碍到运转。未解决此问题，一般采用的方法是增加汽缸的数目，来降低每个汽缸所需的容积。若汽缸数目增加，曲轴每回转1次在汽缸中的引爆次数也会随之增加，因此有着令引擎回转更加顺畅的效果。<br>一般而言，一个汽缸的排气量以<code>350-600cc</code>较为理想，然而多汽缸引擎的成本非常高。因此，实际装载的汽缸数目大多依据车身尺寸和车款价位而定。</p><p><br></p><p><strong>缸径衝程比(bore stroke ratio)</strong></p><p>将汽缸内的衝程除以缸径所得到的值就叫做<strong>缸径衝程比</strong>。<br>当此值小于1时，称为短衝程引擎；大于1时，称为长衝程引擎；等于1时，称为方型引擎。缸径衝程比会影响引擎的特性，一般来说，长衝程引擎在低中转速领域较容易产出扭力，但在高转速领域却不太能发挥功率；短衝程则相反。<br>顺便说一句，当活塞运动到气缸内的最上部时称为上死点；降至最底部时称为下死点。</p><p><img src="/images/BeyondTheApex/bore-stroke-ratio.png" alt></p><p><br></p><p><strong>压缩比(compression ratio)</strong></p><p>所谓压缩比是用来表示引擎将吸入的混合气体压缩至多少程度的数值。引擎的功率将大幅受此压缩比左右。<br>将活塞被推至最下方时汽缸中呈现的<strong>最大容量(汽缸总容量)</strong>，除以活塞推至最高处时汽缸中呈现的<strong>最小容量(燃烧室容量)</strong>，即可求得此比例。所谓汽缸总容量，则是将活塞运动中上下往返的<strong>圆柱体积(排气量)</strong>再加上燃烧室容量。</p><p>以一个<code>2000cc</code>的4汽缸引擎为例，1个汽缸的<code>排气量=汽缸容量(500cc)</code>。假设燃烧室容量为<code>50cc</code>，则将总容量<code>500cc+50cc=550cc</code>处理燃烧室容量<code>50cc</code>，可得知压缩比为<code>11</code>。<br>通常，自然进气式汽油引擎的压缩比大多设定在<code>9-11</code>之间，超过10的即可视为该引擎的排气量做了较高输出功率设定。若是装有增压器的引擎，一般则倾向于<code>7-9</code>之间。</p><p><img src="/images/BeyondTheApex/compression-ratio.png" alt></p><p><br><br><br><br><br></p><h2 id="将动力转化为速度的驱动装置"><a href="#将动力转化为速度的驱动装置" class="headerlink" title="将动力转化为速度的驱动装置"></a>将动力转化为速度的驱动装置</h2><p>为了有效地引出引擎功率并转化成速度，必须拥有适切的齿轮和驱动力配置。因此驱动系统的零件会大幅左右引擎效率。</p><p><br></p><h3 id="变速器"><a href="#变速器" class="headerlink" title="变速器"></a>变速器</h3><p>引擎每分钟可以达到数百甚至数千转，这样的速度如果直接用来转动轮胎则嫌太快，因此我们需要靠着<strong>变速器(transmission)</strong>，通过搭配<strong>齿轮(gear)</strong>以依照状况自引擎取出所需的速度与动力。</p><p>让我们回顾一下齿轮的原理。如果将某个此轮搭配上比它大的齿轮，那么虽然大齿轮的转速不如原本那么快，但却可以增大运作的力道；如果搭配的是比较小的齿轮，则虽然较小的齿轮转速较快，但相对取得的动力也比较有限。<br>变速器靠的便是这样的原理。车子需要最大动力的时间点起步时，相反地，再告诉状况下维持固定速度行进时，则只需要少许动力即可。</p><p>因此在起步时让引擎搭配能产生较大扭力的大此轮（较大的减速比），才能确实地让车子往前推进。<br>大齿轮虽然对于扭力有倍力的效果，但是转速较慢。这解释了为什么在打1档时，就算把引擎转速踩到极限，车辆的时速也只能达到数十公里左右。因此在变速器中北邮复数此轮，以逐渐缩小搭配齿轮（降低减速比）的方式，让使用者可以因应行进情况，自由地操纵车子的速度和动力。<br>实际上在汽车当中，是靠着引擎正后方的变速器，以及驱动轮前方的最终传动齿轮两者间的搭配组合，调整出齿轮比例。变更此一齿轮比例，便能大幅影响车子的行进特性。特别是在赛道奔走时，为顺应赛道特性选择合适的齿轮搭配，往往是缩短时间记录的重要关键。</p><p><img src="/images/BeyondTheApex/gearbox.png" alt></p><p><br><br><br></p><h3 id="终传齿轮"><a href="#终传齿轮" class="headerlink" title="终传齿轮"></a>终传齿轮</h3><p>介于引擎和驱动轮间，在驱动机组中做最后一道减速步骤的此轮装置，就叫做终传齿轮。从整体驱动机组的角度来看，他和变速器有着相互补强的关系，也可以把它看做是将引擎的转速再减速过一次之后，才传给轮胎的装置。在纵向配置引擎的车种中，最终传动齿轮则还肩负著将动力传导的方向转换90度的责任。</p><p>由最终传动齿轮独立在变速器之外，因此比较便于拆装更换。换言之，当我们想要大幅变更车子的特性时，最终传动齿轮便是必须考量的重要因素之一。一般而言，若重视车子的运动性能，只需要调高最终传动齿轮齿轮比，就能提升车子的加速能力（到达极限会降低）。相反，若以降低燃料消耗为目标，则只需降低齿轮比，便可收到降低引擎转速的功效。</p><p><img src="/images/BeyondTheApex/final-gear.png" alt></p><p><br><br><br></p><h3 id="双踏板式变速器的种类"><a href="#双踏板式变速器的种类" class="headerlink" title="双踏板式变速器的种类"></a>双踏板式变速器的种类</h3><ul><li><strong>AT(Automatic transmission)</strong><br>自动变速器。<br>利用扭力变换器（流体离合器）调整引擎断断续续输出的动力，能够顺应车速和引擎转速，自动切换成适当的变速比率，而在内部则配有行星齿轮，通过油压进行控制。虽然优点在于能够顺畅地进行变速，然而却也会因为使用油压带来打滑或浪费功率的问题，在油耗上比较不理想。</li></ul><p><br></p><ul><li><strong>CVT(Continuously variable transmission)</strong><br>无段自动变速器或连续可变变速器。<br>不像一般变速器通过切换齿轮达到变速效果，这种变速器通过变化金属带和链条等连接成的2组滑车和滚轮的直径，来连续地变换变速比。这种变速器在变速时不会产生震动，且在各种行进状况下，都能选择效率最佳的引擎回转域来行进。</li></ul><p><br></p><ul><li><strong>DCT(Dual clutch transmission)</strong><br>双离合变速器是将手排变速器的操作以2具离合器加以自动化之后的产物。<br>通过将奇数档分在不同轴上，以双离合器分别瞬时切换，在变速性能上可以超越手排变速器。在自动变速器当中，受限于行星齿轮的回转性能，引擎的最高转速也受到限制。然而，双离合变速器却能够搭配高转速的引擎。正因如此，跑车以至于环保车种都能有效地发挥此种变速器的性能。</li></ul><p><br><br><br></p><h3 id="差速齿轮"><a href="#差速齿轮" class="headerlink" title="差速齿轮"></a>差速齿轮</h3><p>对于左右两侧都有驱动轮的车种而言，差速齿轮是不可或缺的零件。虽然这在完全直线行进时派不上用场，但是会在过弯时发挥重要的功能。</p><p>过弯时，弯道外侧轮胎行走的距离比起内侧轮胎要来的长，这就是所谓的内轮差。如果不顺应这样的差异，对内/外胎设定不同的回转圈数，那么内侧轮胎将会卡住，车子根本无法转弯。能够吸收这种差异的，便是这里要介绍的差速齿轮。差速齿轮通常和终传齿轮整合为一，装置与左右驱动轮之间。</p><p><img src="/images/BeyondTheApex/chasu-gear.png" alt></p><p>平时在车子直线前进时，主动此轮会配合终传四轮旋转与边此轮周围绕行，以将引擎动力传导至边齿轮。此时分配给左右驱动轮的扭力是相同的。<br>而当开始过弯进入回转状态时，位于弯道内侧的轮胎将产生阻力，而这样的阻力会通过传动轴传至内轮的边齿轮。此时，原本只会绕着齿轮周围公转的主动齿轮会同时展开自转，以调整外侧轮胎和内侧轮胎之间的回转差。<br>如此一来，分配引擎动力时，将只传给产生阻力的弯道内侧较少的动力，而给外轮胎更多的动力，以弥补两者之间的回转差。</p><p><img src="/images/BeyondTheApex/chasu-gear-2.png" alt></p><p><br><br><br></p><h3 id="限滑差速器"><a href="#限滑差速器" class="headerlink" title="限滑差速器"></a>限滑差速器</h3><p>前面介绍了差速齿轮在弯道的作用，不过这种机组在结构上存在著弱点：在装置了差速齿轮的驱动轮之中，只要有一个轮胎离开地面，就无法将驱动力传导给其它驱动轮。这是因为此时离开地面的轮胎将会空转，而差速齿轮则视图修正空转胎的回转差，将驱动力全部传给这个轮胎。路上常可以看到卡在泥泞或雪地上的车子，大多是因为差速齿轮的这种特性造成的。</p><p>因此，当左右驱动轮之间的回转差大于某个范围时，能够限制差速齿轮功能的，便是所谓的<strong>LSD(限滑差速器)</strong>。<br>LSD的原理，是借由装上能够限制两侧边此轮转速差的装置，达到确实将驱动力分配各两轮的目的。具体的方式可以细分为多板离合器式、电子控制式、以及通过齿轮咬合和转轴方向产生的摩擦力，所作动的粘性耦合式等设计。<br>LSD机制运用在跑车车种上时，与其说是为了从泥泞中爬出来，不如说是为了确保驱动力并提升操控性。</p><p><img src="/images/BeyondTheApex/LSD.png" alt></p><p><br></p><p>LSD的种类：</p><ul><li><strong>扭力感应式(torque sensing type)</strong><br>采用特殊齿轮组合的方式。当左右驱动轮间产生扭力差时，便会增加齿轮的齿面阻力，以限制差速效果。由于这样的差速限制力相当大，运用在像赛道上行进这类对车子负担较重的场面特别有效；切实际产生限制差速效果的反应时间也相当迅速。此类除多踏板离合器式之外，还有扭力感应式、螺旋齿轮式等。</li></ul><p><br></p><ul><li><strong>回转感应式(revolution sensing type)</strong><br>不限制差速齿轮运作，而是利用高粘度矽油的方式。除了最具代表性，利用油类剪阻力（物质内部抗形变的阻力）的粘性耦合式之外，还有利用油类通过孔穴式。和扭力感应式相较之下，此类的差速限制力比较和缓，反应速度也比较迟，但是相对的也比较适合用在低摩擦系数的路面上。</li></ul><p><br></p><ul><li><strong>动态控制式(active control type)</strong><br>就是电子控制式。由电脑通过收集自各种感应器的资讯，主动地进行差速限制。通常用在越野赛车等竞技车种当中。一般都用于世界越野锦标赛(WRC.</li></ul><p><br><br><br><br><br></p><h2 id="支持汽车行进的骨架"><a href="#支持汽车行进的骨架" class="headerlink" title="支持汽车行进的骨架"></a>支持汽车行进的骨架</h2><p>车身结构对行进性能造成的影响大于引擎和变速器，操控性优良与否也取决于此，可说是一辆车的基础，也是最根本的部分。</p><p><br></p><h3 id="车身应具备的性能"><a href="#车身应具备的性能" class="headerlink" title="车身应具备的性能"></a>车身应具备的性能</h3><p>能与车身、引擎、以及悬吊并列足以左右车子个性的要素，则是一辆车的骨干。一般来说，我们要求车身必需兼具<strong>刚性</strong>与<strong>强度</strong>，还得同事追求<strong>轻巧</strong>。这里所说的刚性简单来说便是<strong>不易变形的程度</strong>，而强度则是<strong>不易损坏的程度</strong>。</p><p>上述特征中，刚性对行驶性能造成的影响特别大。当一辆车通过凹凸路面，或处在过弯等对车身造成负担的状况下时，若车身仍不会轻易变形，则可以说这辆车刚性高。<br>就算车身变形了，只要能够瞬间恢复原状，悬吊便可以正确地运作，也能提升轮胎接地性。车身刚性够高，动力便容易传达到路面，车子行进更加安定，也较容易驾驶。<br>加诸于车身的冲击力并没有固定的模式；有些缓慢的到来，也有突然发生的。而在车辆的产品型号上有着弯曲刚性和扭曲刚性这类标示，这些大多是针对缓慢到来的冲击力而言的刚度。然而，真正具备高刚性的车身，即使受到剧烈摇晃这类瞬间的冲击力，也必须能够承受。<br>另一方面，所谓的强度即硬度或坚固的程度。强度过低时，发生冲撞时对车身的伤害较大。然而，若因此便让车子具备有如坦克车般的强度，则虽然让车身毫发无损，但激烈的冲击力却会相对加诸在乘客身上。<br>一辆车的车身，必须将刚性和强度的平衡追求到及完善的境界。如果只是要单纯地提升刚性和轻度，有许多简单的补强方法。然而，却无可避免地会让车身变重。</p><p><img src="/images/BeyondTheApex/gangxing-qiangdu.png" alt></p><p><br></p><ul><li><strong>框架式车身(frame body)</strong></li></ul><p>也称为<strong>非承载式车身</strong>或<strong>车身与车架分离式结构</strong>。<br>这种结构是将引擎和变速器、悬吊等装置在固定的车架上之后，再架设上理你性制作的车身。除了梯型式，还有背骨式、周长式、平台式等。而其中又以梯型式较能压低制造成本，同时又能确保强度，所以许多越野车种喜欢采用。</p><p><img src="/images/BeyondTheApex/frame-body.png" alt></p><p><br></p><ul><li><strong>车体式车身(monocoque body)</strong></li></ul><p>车架和车身一体成形，是现代车身结构的主流。整个车体的强度来自于车身板件等多项结构零件，有如蛋壳般地支撑了车身的整体强度，不仅轻巧且也具备了高刚性。这种架构的另一个优点在于可以降低底盘高度，而在发生冲撞时也易于吸收能量。由于引擎和悬吊直接安装在车身上，使得过去这样的架构在乘坐舒适性和噪音抑制方面，一直比不上框架车身。然而，随着悬吊不断演进及组装技术提升，这些缺点已成为过去式。</p><p><img src="/images/BeyondTheApex/monocoque-body.png" alt></p><p><br><br><br><br><br></p><h2 id="用来降低车速的热交换器"><a href="#用来降低车速的热交换器" class="headerlink" title="用来降低车速的热交换器"></a>用来降低车速的热交换器</h2><p>减速就是将车子行进的动能转化为热能。除了让车子停下的功率理所当然地必须大于引擎功率外，对于过热问题也必须做好万全的处置，因此这是车上最重要的零件。</p><p><br></p><h3 id="结构与原理"><a href="#结构与原理" class="headerlink" title="结构与原理"></a>结构与原理</h3><p>汽车的刹车，说穿了就是将动能转换为热能，以降低车速的装置。这种装置也有固定车身、防止静态状态下的车子产生移动的功能。</p><p>组成刹车的基本原件为接受驾驶员命令的操作装置、传导操作力的液压回路，以及最重要的制动装置。近来的刹车系统则还会在液压回路中额外加装能够放大操作力的倍力装置，以及能够防止轮胎锁死的ABS系统。<br>刹车踏板和制动装置之间通过液压回路相连。由于液压回路仰仗帕斯卡原理运作，因此啥词踏板前端连接著一个大剖面积的刹车总泵。这个刹车总泵中产生的压力在放大过后，再传导给刹车来令和蹄片。刹车来令和蹄片是摩擦介质，将它们压在刹车碟盘或刹车鼓上之后，才能将动能转换成热能，以降低车速。<br>流动在液压回路当中的并不是一般油类，而是专用的刹车液。针对刹车时的热能，刹车液必须具备不易沸腾的特性，也因此主要依沸点分为几种不同种类。<br>随着高速道路的逐渐普及，小客车主流的前刹车设计，已由鼓刹转为碟刹。碟式刹车主要是通过在刹车卡钳当中的刹车来令片从两侧家住刹车碟盘，已发挥制动力。</p><p><img src="/images/BeyondTheApex/breaker.png" alt></p><p><br></p><ul><li><strong>碟式刹车(disc type)</strong></li></ul><p>通过从两侧来令片家住转动的金属制圆盘（刹车碟盘）产生摩擦力，以发挥刹车效果。最大的优点在于包括刹车碟盘在内，几乎所有的结构零件都露出在外，所以通风性、散热性十分优秀，不容易过热。另一个优点在于当水附著在刹车碟盘上的时候，可以靠著碟盘本身的旋转将其挥散，因此不至于使摩擦系数降至过低。不过，这种刹车虽然易于通过调整脚踩刹车踏板的力道来微调制动力，然而，自身却没有产生倍力效果，以至于如果停车时的制动维持力不如鼓式刹车。</p><p><img src="/images/BeyondTheApex/disc-type.png" alt></p><p><br></p><ul><li><strong>鼓式刹车(drum type)</strong></li></ul><p>这种刹车系统，乃是将刹车蹄片由内侧压在和轮圈一起转动的圆筒型刹车鼓上来取得制动力。由于散热性不佳，比碟刹更容易发生过热的情形，且若刹车内部进水，需要一段时间才能恢复摩擦力。不过在制动时，刹车蹄片会自动朝向咬住刹车鼓的运动方向，因此可以发挥极大的制动力（这称为自我倍力作用）。在小客车上 ，通常装载刹车负荷较小的后轮为多，而在大型车中则会把它装载后轮碟刹的内侧，作为驻车用的刹车。</p><p><img src="/images/BeyondTheApex/drum-type.png" alt></p><p><br><br><br></p><h3 id="摩擦热引起的刹车问题"><a href="#摩擦热引起的刹车问题" class="headerlink" title="摩擦热引起的刹车问题"></a>摩擦热引起的刹车问题</h3><ul><li><strong>过温衰退现象(fade)</strong></li></ul><p>当过度使用刹车时，造成制动力急速下降的现象。具体而言，这样的现象时因为用作摩擦截止的来令片和刹车皮过热后产生气体，而这些气体在刹车碟和鼓之间发挥了近似于润滑剂的作用，导致摩擦系数降低。</p><p><br></p><ul><li><strong>气阻(vapor lock)</strong></li></ul><p>过热的来令片和刹车皮上的热能使得刹车液沸腾，使得刹车油管内产生气泡的现象。此时即使踩刹车踏板也无法将正规的压力送出刹车液，最糟的状况下甚至无法取得制动力。</p><p><br><br><br></p><h3 id="刹车碟盘的种类"><a href="#刹车碟盘的种类" class="headerlink" title="刹车碟盘的种类"></a>刹车碟盘的种类</h3><ul><li><strong>实心碟盘(solid disc)</strong></li></ul><p>仅使用一面碟盘，是最基本的结构种类设计。虽然散热效果不如通风式刹车，不过由于制造成本地，所以用于许多轻型汽车的前刹，或者在4轮碟刹系统中负责制动时符合较小的后刹。比起通风式刹车碟，此类设计对摩擦热承受度较强，并以散热效果高的钢铁材质为主流。</p><p><img src="/images/BeyondTheApex/solid-disc.png" alt></p><p><br></p><ul><li><strong>通气式碟盘(ventilated disk)</strong></li></ul><p>结合两面刹车碟盘，并在其中设置多个散热孔。原本是为了赛车所开发、运用，不过现在许多客车也采用此种刹车碟盘。由于和实心碟盘相较之下，碟面温度大概降低了30%，因此可以进一步提升耐热性（以及防止过温衰退），并延长来令片的寿命。缺点在于碟身较厚导致重量较重。</p><p><img src="/images/BeyondTheApex/ventilated-disk.png" alt></p><p><br></p><p>更加进化的通气式通气式刹车碟：</p><ul><li><strong>针孔式碟盘(pinhole type)</strong></li></ul><p>一般用来指在通风式刹车碟盘的摩擦面上打更多的洞，以提高散热性、冷却效率的刹车碟盘。而这种也叫做攒孔刹车碟(drilled disc)的碟盘设计，同时频繁使用在赛车和高性能跑车上。这些洞孔对于排除制动时产生的摩擦粉也很有效。而另一种在表面上挖满槽的画线式碟刹(slit disc)，在设计上也是出于同样目的。</p><p><img src="/images/BeyondTheApex/pinhole-type.png" alt></p><p><br></p><ul><li><strong>螺翼式碟盘(spiral fin type)</strong></li></ul><p>在贴合的2面刹车碟盘内侧将散热排成螺旋状。翼片的形状是经过解析刹车碟盘内气流数据之后做出最佳化的设计，可以伴随着车辆转动有效地排除摩擦热。除了常用在高性能跑车以外，也会用在车重较重的大马力车种上。</p><p><img src="/images/BeyondTheApex/spiral-fin-type.png" alt></p><p><br><br><br></p><h3 id="刹车卡钳"><a href="#刹车卡钳" class="headerlink" title="刹车卡钳"></a>刹车卡钳</h3><ul><li><strong>浮动式刹车卡钳(floating type)</strong></li></ul><p>这是在刹车卡钳内部只有单边具有将刹车来令片推出的刹车活塞的型式，因此也叫单活塞式。承受来自于刹车踏板油压的活塞只存在于机组的一侧，对面的来令片则靠反作用力压制住刹车碟盘。在这种刹车卡钳当中，与刹车碟的解除位置是常时在调整的，且左右两侧来令片之间不存在著时间差的变化，每次都能得到同样的刹车感。由于这种刹车卡钳本身体积较小，重量也较轻，因此可以顺应高温扭曲变形的碟刹做出应变。虽然在赛道等连续行驶的状况下会导致效果降低，但是从性能上来看，在一般使用情况下丝毫没有问题。</p><p><img src="/images/BeyondTheApex/floating-type.png" alt></p><p><br></p><ul><li><strong>对向活塞式刹车卡钳(opposite piston type)</strong></li></ul><p>左右皆装有刹车活塞，从两侧将来令片夹上刹车碟盘的型式。由于这种结构体积较大，必须选用吕质刹车卡钳，因此仅以维持刹车卡钳的刚度。用在赛道等跑车的行驶条件下十分有效，单向有发挥原本的性能，如果不一并把刹车碟盘改装成浮动式，碟盘会因为热变形而倾斜，导致来令片无法确实著力。随着刹车碟盘直径逐渐变大，市面上也有不少采用4活塞设置6活塞这类复数刹车活塞、以及来令片总面积较大的车种。从吕质轮圈的空隙间能窥见的大型对向活塞，可说是一台高性能车的有利表征。</p><p><img src="/images/BeyondTheApex/opposite-piston-type.png" alt></p><p><br><br><br><br><br></p><h2 id="控制车身动态的缓冲装置"><a href="#控制车身动态的缓冲装置" class="headerlink" title="控制车身动态的缓冲装置"></a>控制车身动态的缓冲装置</h2><p><strong>伸缩</strong>乍看之下是种简单的运作原理，然而车上要是没有悬吊，不仅无法正确操作，甚至无法正常行驶。</p><p><br></p><h3 id="构造与原理-1"><a href="#构造与原理-1" class="headerlink" title="构造与原理"></a>构造与原理</h3><p>从结构上来看，悬吊位于车身和轮胎间，一边支撑着车身，一面吸收来自轮胎的冲击力。这重要的机制大幅影响着车子行进间的操纵稳定性。</p><p>悬吊可以大略分为左/右轮动态会影响到另一轮的固定式悬吊，以及左右轮个别作动的独立式悬吊。而这两类悬吊又各自有几种具代表性的形式，如固定式车轴式、吊环式、扭力梁式等。而独立式则有支架式或双叉骨式等等。<br>悬吊本身由弹簧、减震筒、连杆支臂等结构组成。弹簧能够缓和来自 路面的冲击力，减震筒则是可以抑制弹簧的弹跳，提升搭乘的舒适感与稳定性。连杆支臂则用在限制轮胎的动态，让轮胎能以最佳的方式与地面接触。悬吊还有另一个重大的用途，是通过弹簧的反作用力将轮胎压在地面，以稳定轮胎位置。</p><p><img src="/images/BeyondTheApex/zhijiashi-xuandiao.png" alt></p><p><br></p><ul><li><strong>弹簧(spring)</strong></li></ul><p>除了具备先一步吸收加诸于行进间车身的冲击力、缓和震动的功能之外，还有维持固定车高的功能，是会影响操控性、方向盘性能、动作稳定性的重要因素。因此我们可以说，就算只调整弹簧设定，也足以让车子的个性不大相同。而一般除了金属制的线圈弹簧以外，还包括利用空气压力的气压式悬吊。</p><p><img src="/images/BeyondTheApex/spring.png" alt></p><p><br></p><ul><li><strong>减震筒(shock absorbers)</strong></li></ul><p>线圈状的弹簧在承受负重时，虽然可以通过伸缩原理加以缓冲，然而光是如此却无法消弭上下的运动量。而抑制这样的动态便需要减震筒（也称阻尼装置）的责任。一般常见的减震筒种类是仰赖活塞在密封于筒内的油类和气体中上下运动时遭遇的抵抗力来运作，可通过慢慢伸缩、慢慢恢复的动态，来缓和弹簧激烈的上下运动。因此减震筒和弹簧同样左右着车子的操作性和稳定性。</p><p><img src="/images/BeyondTheApex/shock-absorbers.png" alt></p><p><br></p><ul><li><strong>悬吊臂(suspension arm)</strong></li></ul><p>这是控制轮圈动态的零件，也称为控制臂。这种零件借由安装在车身与轮轴之间，可以依照各种不同的形状分为A臂和I臂等不同种类。基本上使用压合钢板，不过有时也会使用强度更加的锻造制品。在双A臂式悬吊这种上下成对的悬吊组当中，上方称为上臂，下方称为下臂。</p><p><br></p><ul><li><strong>稳定杆(stabilizer)</strong><br>利用扭杆弹簧的扭曲来抑制车身晃动的安定装置，也称为防倾杆。两端安装于悬吊的下臂上，只会在左右车轮动态相異时作动。例如在过弯时，外侧车轮下沉，内侧车轮将会拉高，此时稳定杆就能控制左右车轮成为相同的动态，让行车姿势更安定。也有人会可以利用稳定杆的这种效果，调校成可以用来应变转向不足、转向过度的设定。</li></ul><p><br></p><ul><li><strong>悬吊衬套(suspension bush)</strong></li></ul><p>用于构成悬吊的金属制连杆和悬吊臂等的结合部位，或是装著于车身部位的缓冲材质。如果衬套硬度不足，将会因过弯等情况下庞大的负重而变形，使得悬吊产生不必要的动作，影响车子的操作性和稳定性。因此，衬套的材料一般都选用冲击吸收性佳的橡胶材质，不过在竞技用车种当中，为了减少不必要的动作，较常改用鱼眼(pillow ball)这种金属球面轴承。衬套是能够引导出弹簧和避震装置性能的重要零件。</p><p><img src="/images/BeyondTheApex/stabilizer.png" alt></p><p><br><br><br></p><h3 id="悬吊的种类"><a href="#悬吊的种类" class="headerlink" title="悬吊的种类"></a>悬吊的种类</h3><p>虽然各种不同的悬吊同样具有保持车高、介绍行进间的负重和冲击的功能，不过彼此间的性能和特性却是各不相同的。这些性能与特性的差异，会影响到过弯、行驶性能、与安全息息相关的操控性能、以及乘客乘坐时的舒适性。<br>悬吊正日新月异地进步，目前已发展出了许多不同种类。虽然结构复杂并非就等同于具备了高性能，但是为了实现理想的悬吊能够瞬间追踪路面的凹凸起伏，保持轮胎能够维持在正确的接地状态的目标，目前各方专家仍在持续努力研究改进的技术和手法。</p><p><br></p><ul><li><strong>固定式(rigid axle)</strong></li></ul><p>所谓固定式悬吊，即通过车轴连接左右轮和轮圈的结构。由于轮胎的动作将会传达给另一侧的轮胎，因此容易降低接地性。且因轴梁和轴殻本身重量也重，在比较簧下重量时便较为吃亏。不过一你诶这种结构成本低、且强度优异，尝尝用在低价位的后轮驱动车种中作为后悬吊。</p><p><img src="/images/BeyondTheApex/rigid-axle.png" alt></p><p><br></p><ul><li><strong>独立悬架式(independent system)</strong></li></ul><p>能够让左右车轮独立上下运动，在应付凹凸起伏路面方面的表现亮眼。特别是在后轮驱动车种中，可以有效地将动力传导给左右车轮。除此之外，还能减轻运作部位的重量。能够兼顾操控稳定性和乘坐舒适性的特点也让人激赏。</p><p><img src="/images/BeyondTheApex/independent-system.png" alt></p><p><br></p><p>常见于跑车款中的独立式悬吊：</p><ul><li><strong>支柱式悬吊(macpherson strut)</strong></li></ul><p>基本上是由弹簧和避震装置以及下臂组成的简单结构。<code>strut</code>的意思是承受作用力的支柱，在此指的是减震筒与弹簧装置。减震筒的上端通过缓冲橡胶支撑车身，下部则由下臂支撑。不了零件数量少，得以控制重量之外，也因为易于确保衝程距离，可吸收较大范围来自路面的震动。</p><p><img src="/images/BeyondTheApex/macpherson-strut.png" alt></p><p><br></p><ul><li><strong>双A臂悬吊(double wishbone)</strong></li></ul><p>由上下成对的悬吊臂悬架起车轮的结构。使用双悬吊臂，而因为V字型排列的悬吊臂就像鸡的锁骨的形状，因此便以之命名。随着悬吊臂形状和配置位置不同，可以比较自由地控制加速/减速时车子的姿势和车轮矫正的变化。另外也因为这种悬吊便于追求高刚性，所以常用在重视操作性和稳定性的跑车当中。然而，相对的也因为零件数量较多且结构复杂，需要较大的安装控件。</p><p><img src="/images/BeyondTheApex/double-wishbone.png" alt></p><p><br></p><ul><li><strong>多连杆式悬吊(multi link)</strong></li></ul><p>虽然这属于双A臂式悬吊的进化形，不过相较于双A臂式悬吊仅由上下2根悬吊臂组成，这种悬吊则由<code>3-5</code>根的连杆来决定车轴的位置。由于各悬吊臂互相分离，配置的自由度极高，方便进行更细腻的调校。并且在由数根悬吊臂共同支撑的情况下，可以严密地监控悬吊系统几何的变化，轮胎接地性亦佳。在高性能的FF驱动车种一季大马力的后轮驱动车种当中，常以此为后悬吊，以维持在高速领域的动态稳定性和确保马力。</p><p><img src="/images/BeyondTheApex/multi-link.png" alt></p><p><br><br><br></p><h3 id="车辆矫正"><a href="#车辆矫正" class="headerlink" title="车辆矫正"></a>车辆矫正</h3><p>如果你身边的家具或椅子上装有移动的车辆，请稍微留意一下。从正上方俯瞰，便会发现车轮的中心轴与它被装在家具上的轴心位置并未对齐。在移动家具和椅子时，车轮之所以不会乱摆，而能朝着固定的方向前进，这是多亏了这样的位置差。</p><p>另一方面，假设我们把轮胎拆下来，任其在地面上滚动，那么躲过滚动时轮胎的接地面紧密地沿着地面，轮胎便会直线前进；然而若转动时只使用到一部分的接地面，就会发现轮胎会朝着特定的方向转弯。<br>这说明了当轮胎固定在车身上时，只要给予各种不同的角度，便能让轮胎在适合车子的运动条件下运作。这就是所谓的<strong>车轮矫正(whell alignment)</strong>（悬吊系统几何）。<br>行驶-过弯-停止的基本原则建立在4轮矫正处于正确地装置状况下，这道决定轮胎位置的手续将可引导出轮胎的性能，设置发挥决定车子特性的效果。</p><p>具体而言，车轮校正的代表性因素共有如下所列4项：</p><ul><li>从车身上方俯瞰时轮胎的角度————束角；</li><li>从车身侧边看去时悬吊的倾斜角度————倾斜角；</li><li>从车身正面看过去时轮胎的扁平度————外倾角；</li><li>车身正面看过去时轮胎的扁平度————外倾角。</li></ul><p>这些角度都必须以<code>0.1mm</code>或<code>0.1度</code>的精确度加以管控，只要有些许的误差，便会影响车子的直进性能，或让操作感觉起来有异。因此，务必谨记这些因素会对车造成的影响。</p><p><br></p><ul><li><strong>束角(toe angle)</strong></li></ul><p>自车身上方俯瞰时，左右轮朝外侧展开的角度。当轮胎朝向行进方向的外侧展开时，称为<strong>外束角(toe-out)</strong>，而朝内侧收敛时，称为<strong>内束角(toe-in)</strong>。此角度会大幅影响直进性，设定角度过大时将会使轮胎产生偏磨损。</p><p><img src="/images/BeyondTheApex/toe-angle.png" alt></p><p><br></p><ul><li><strong>后倾角(caster-angle)</strong></li></ul><p>从旁看向车轮时前悬吊的倾斜角度。这个角度除了有抑制轮圈横向震动的效果之外，还具有<strong>自校准扭力(self-aligning-torque)</strong>，打方向盘是会尝试着将轮圈转回直进状态的作用力的功用。如果左右轮的此角度不同，则车子会偏向角度较大的那一侧，导致在制动时无法操作方向盘的现象。</p><p><img src="/images/BeyondTheApex/caster-angle.png" alt></p><p><br></p><ul><li><strong>外倾角(camber-angle)</strong></li></ul><p>从车子正面看去，轮胎下册变宽的状况较做负外倾，而上侧变窄的状况则称为正外倾。在正常状态下，为了防止负重时轮胎呈外八字行，因此会实现设定为上方较开的角度。</p><p><img src="/images/BeyondTheApex/camber-angle.png" alt></p><p><br></p><ul><li><strong>内倾角(king-pin-angle)</strong></li></ul><p>从正面看向轮胎时，固定轮圈轴心的倾斜角。这个角度基本上用来输入自路面的作用力，以防止方向盘失去控制。主要影响车子的直进性、操作方向盘时的复元力（自校准扭力）、方向盘操舵力。</p><p><img src="/images/BeyondTheApex/king-pin-angle.png" alt></p><p><br><br><br><br><br></p><h2 id="汽车与路面的交会点"><a href="#汽车与路面的交会点" class="headerlink" title="汽车与路面的交会点"></a>汽车与路面的交会点</h2><p>TIRES</p><p>引擎动力经由传动系统和悬吊，最后通过轮胎传到地面。无论是什么车种，行驶时都无法超越轮胎所能负荷的性能。</p><p><br></p><h3 id="高性能轮胎的条件"><a href="#高性能轮胎的条件" class="headerlink" title="高性能轮胎的条件"></a>高性能轮胎的条件</h3><p>轮胎的功能主要分为4项：</p><ul><li>支撑车身重量的<strong>负重支撑功能</strong>；</li><li>缓和来自路面冲击力的<strong>缓冲功能</strong></li><li>开始行进与停止的<strong>制动/驱动功能</strong>；</li><li>安定地在直线与弯道上行进的<strong>路线维持功能</strong>。</li></ul><p>改装轮胎时，必须在确保上述4项功能之间取得平衡后，才能按照各种轮胎不同的性能与特性进行调校。</p><p>就重视行驶功能的跑车轮胎而言，如果提升制动/驱动功能和路线维持功能，也就是有关开始、行进与停止的项目，显得格外重要。具体的做法是提升接触地面的橡胶的抓地力，并且提高刚度以抑制轮胎负重时的变形程度。如此一来，以过弯时为例，就可以让车子对方向盘操作的反应变得更敏锐，大幅提升回转速度。<br>当然，高抓地力的轮胎也有其缺点。这种轮胎虽然在过弯时负荷极限较高，但是一旦超过了极限就会变得难以控制，因此需要箱单的驾驶技巧。另外，这种轮胎也会增加多悬吊与车身的负荷，打破抓地力的均衡，使得过弯中的翻滚量变大。这意味着要使用这种轮胎，车子也必须有足以支撑的负荷的能力。而且由于轮胎与路面的摩擦力较大，使得磨损迅速，会使得搭乘感受恶化，噪音也大。<br>在泾滑路面上行进时，刻在轮胎接地面的满纹将会大幅左右其性能。这些满纹的目的在于排除存在于轮胎与路面间的水分，然而排水性能和接地面的刚度之间却有着相对的关系。在跑车轮胎中，两者间的平衡特别难以取舍。<br>汽车无法超越轮胎所能负荷的性能行驶，因此必须具备相关知识，才能选出符合自己的驾驶风格的轮胎。</p><p><img src="/images/BeyondTheApex/tire.png" alt></p><p><br></p><ul><li><strong>胎面胶料(tread compound)</strong></li></ul><p>用于接地面的橡胶。高性能轮胎使用抓地力强的软质橡胶，由于与路面摩擦力大，磨损迅速。而另一方面，一般车种使用的则比较表示耐磨损性，选择的硬质胶料就仅有一般水准的抓地性能。另外，虽然橡胶在未升温到某种程度时呈现坚硬的状态，不易发挥原本的抓地力，然而过热时也会使抓地力降低。</p><p><br></p><ul><li><strong>胎面花纹(tread pattern)</strong></li></ul><p>即雕刻在接地面上的纹路。主要目的在于（随着转动）将路面的水排出去。许多汽车为了提高排水效果，还会特别采用具备指定方向性纹路的轮胎。另一方面，由于胎纹是造成接地面刚性降低的主要原因，所以高性能轮胎通常会省去细微的纹路，全部采用较粗的胎纹。而有些轮胎甚至会使用左右非对称的纹路，减少在过弯时会被强力地压在地面外侧部分的胎纹以提高胎面刚度，并将较多的胎纹设置在内侧以改善排水性。</p><p><br></p><ul><li><strong>胎身刚性(casing rigid)</strong></li></ul><p>轮胎的横剖面有胎面、胎臂、各胎体层组成有如一容器状，而这种结构的刚度就称做<strong>胎身刚性</strong>。来自路面加诸于胎面的力将会传达到各部位，最后由胎圈底部承受。也就是说，在加速/减速、过弯这些对轮胎造成庞大负荷的场合，为了不使轮胎发生不必要的扭曲，重要的是提升轮胎整体的刚性（胎身刚性）。然而，刚度越高，虽然能提升车子的运动性能，却会损及搭乘时的舒适度感。这也是为什么调校轮胎时，必须考虑其扮演的角色和使用目的。</p><p><img src="/images/BeyondTheApex/casing-rigid.png" alt></p><p><br><br><br><br><br></p><h2 id="以吕制为主流的轮圈"><a href="#以吕制为主流的轮圈" class="headerlink" title="以吕制为主流的轮圈"></a>以吕制为主流的轮圈</h2><p>WHEELS</p><p>簧下重量每轻1KG，收到的效果是簧上重量轻量化的15倍。<br>想要彻底在起步、加速、制动、过弯发挥出完整性能，绝对少不了选用轻巧的轮圈。</p><p><br></p><h3 id="簧下重量"><a href="#簧下重量" class="headerlink" title="簧下重量"></a>簧下重量</h3><p>吕制轮圈装饰性意义虽强，但一方面也仍对形式心梗造成不小的影响。</p><p>车子需要最多动力的时机在于起步时。想要让车子由静止状态稍稍开始移动，需要极大的动能。如果轮圈较重，则不易使其转动；所以轮圈越轻，便只需少量的动能(引擎马力)便可让它转动起来。<br>因此这项条件就称为<strong>簧下重量</strong>，会大幅影响车的运动性能。轮圈和轮胎越轻，不仅起步、加速性能会提升，制动时也容易停止轮胎的转动(刹车较为有效)。另外，悬吊的运作也更加流畅，路面运动表现和搭乘舒适感也都会获得改善，更能节省燃料费用。<br>目前成为主流的吕制轮圈，在优良的导热性、热容量以至于排除刹车热的效率方面的表现都十分出色，而且比起铁材料，耐腐蚀性更是优异。<br>而在更换轮圈时，要特别注意尺寸变大导致重量增加。特别是尺寸大幅提升时，通常也会使得簧下重量大幅增加。因此必须审慎考虑扁平轮胎所带来的好处，以及随之增加的重量所带来的坏处。</p><p><img src="/images/BeyondTheApex/wheels-1.png" alt></p><p><img src="/images/BeyondTheApex/wheels-2.png" alt></p><p><br></p><p>结构：</p><ul><li><p><strong>单片式(one piece)</strong><br>轮框部位和轮盘部位一体成形，是最基本的结构。由于在制作上于锻造后进行切削加工，因此尺寸精确度极高。虽然在设计上自由度较小，不过因为零件数量少，重量较双片式和三片式来得轻，在重量平衡方面表现也相当优异。</p></li><li><p><strong>双片式(two pieces)</strong><br>分别制作轮盘部位和轮框部位，使用螺丝和螺帽，或用焊接方式连接两者的结构。这种作法允许在轮盘和轮框分别采用不同的材质（镁、铝、钛…）和制造方法（锻造、铸造），因此在调整偏距值和设计轮盘的自由度上较高。</p></li><li><p><strong>三片式(tree pieces)</strong><br>焊接起表面的轮框部位和内侧的轮框部位，再用穿孔螺栓组装轮盘部位的结构。具有双片式的特征与优点，但在重量上较为不利，因此许多重视时尚设计感的轮圈都采用此结构。</p></li></ul><p><img src="/images/BeyondTheApex/onetwothree-pieces.png" alt></p><p><br></p><p>制法：</p><ul><li><p><strong>铸造(casting)</strong><br>将高温融化的铝液注入模具中使其成型的制法。用在双片式和三片式轮圈当中，可以提高轮盘部位的设计自由度。反过来说却也因此必须为了维持强度而增加厚度，使得原本该材质相较于钢铁材质在重量面的优势变得比较不明显。由于制作成本低，是为目前铝制轮圈的主流方法。</p></li><li><p><strong>锻造(die casting)</strong><br>用数千吨的高压压缩金属块（令金属分子重新排列），使其变成高韧性、高硬度的材质。由于成品强度由于铸造，所以可以牺牲厚度换取亲量化。然而却也因为高硬度的特质，使得成品虽然抗拉力机枪，但是对扭曲变形力的承受力却较为脆弱，且制作成本较高，设计上限制也多。在材料方面不至于铝制，在赛车和部分跑车当中，设置还可以看到选择了比铝还轻的镁制轮圈。</p></li></ul><p><br><br><br><br><br></p><h2 id="对车身作用的空气力"><a href="#对车身作用的空气力" class="headerlink" title="对车身作用的空气力"></a>对车身作用的空气力</h2><p>AERODYNAMICS</p><p>车身设计的影响力足以全盘改变汽车的高速性能。从极速、稳定性以至于经济性能都与此息息相关。现在讨论车子时，空气力学已是无法忽略的一大主题。</p><p><br></p><h3 id="空气阻力与异力"><a href="#空气阻力与异力" class="headerlink" title="空气阻力与异力"></a>空气阻力与异力</h3><p>在高速行进间，<strong>空气阻力</strong>将发挥极大的影响力。这道肉眼看不见的<strong>空气墙</strong>，在车速越快时，会夺走越多车子的行进动力。</p><p>空气阻力所造成的影响大约从时速80公里以上便开始无法忽视，之后更随速度提升等比放大。也就是说当速度提升为2倍，阻力便成为4倍；速度提高3倍则阻力可达9倍。虽然实际上还必须将轮胎的<strong>转动阻力</strong>等因素考虑进去，不过，当引擎马力无法冲破这道空气墙时，那就是这辆车的极速。因此对重视极速与高速性能的带车与跑车而言，如何减低空气阻力的重要性自然不在话下。就连对以讲求节省燃料费用为诉求的车种来说也不容小觑。<br>车高较低的阻力较小，而车身外型则以能够顺畅地将行进气流送往后方的流线型与楔形较为吃香。还有一种去除车身表面多余的凹凸起伏（齐平表面处理），同样是可以降低空气阻力的设计。<br>仍需留意的是，空气阻力较小的车身，从侧面看去通常会呈现像是飞机主翼的形状。在这样的车身上，流动在上方的空气快于下方的空气，导致产生让车身往上方浮起的作用力（昇力的问题），然而要抑制昇力却又必须增加空气阻力。因此，如何在空气阻力和昇力之间取得平衡点，便是开发车子时的重要关键。<br>另外，在高速行进间会打乱车子直线行进的横风，也是无法忽视的重要因素。在空气力学方面，必须考虑进包含空气阻力、昇力以及偏向力矩各种条件在内的整体平衡。</p><p><br></p><ul><li><strong>正面投影面积(frontal area)</strong><br>从车身正面望去时的车身剪影。此面积越广，必须承受越多的行进风阻，阻力也就越大。跑车之所以将车身压低，就是为了尽量缩小正面投影面积。因此箱型车或小货车在这方面必然较为不利。</li></ul><p><img src="/images/BeyondTheApex/frontal-area.png" alt></p><p><br></p><ul><li><strong>Cd值-风阻系数(constant drag)</strong><br>这是用来表示当风吹在某个物体上时，气流流动的顺畅程度的系数。实际上在行进间会造成问题的空气阻力，就是一次空气阻力系数乘上正面投影面积所得。因此即使跑车的Cd系数高，只要正面投影面积小，承受的空气阻力便小，而向房车这类车种可说刚好相反。</li></ul><p><img src="/images/BeyondTheApex/constant-drag.png" alt></p><p><br></p><ul><li><strong>CL值-昇力系数</strong><br>这是用来表示高速行进间的行进风产生的让车身上浮的作用力的系数。而相反地，将车身往下压的作用力则称为<strong>下压力</strong>或<strong>负昇力</strong>。想要获得下压力，必须增加空气阻力，因此为求稳定车子的动态，必须将车身前后的下压力调整到最佳平衡。</li></ul><p><img src="/images/BeyondTheApex/constant-lift.png" alt></p><p><br></p><ul><li><strong>CYM值—偏向力矩系数(constant yawing moment)</strong><br>行进间所承受的风力不仅限于前方。当风力来自各种方向时，产生在车身中心轴周边，视图使其<code>回转向的作用力=妨碍直线前进性能的力</code>就称为偏向力矩。CYM值小的车种比较耐横风，而一般来说重心高度较高的高车身车种在此方面较为吃亏。</li></ul><p><img src="/images/BeyondTheApex/constant-yawing-moment.png" alt></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="改装汽车"><a href="#改装汽车" class="headerlink" title="改装汽车"></a>改装汽车</h1><p>Tuning and Settings</p><p><br></p><h2 id="提升引擎的战斗力"><a href="#提升引擎的战斗力" class="headerlink" title="提升引擎的战斗力"></a>提升引擎的战斗力</h2><p>一味提升引擎马力，只会让车子更难驾驭，无助于让它奔驰得更加快速。因此必须先看准了追求的目标为何，如何炒理想迈进，才能做出符合车子用途或赛道条件的完美调校。</p><p><br></p><h3 id="微调"><a href="#微调" class="headerlink" title="微调"></a>微调</h3><p>更换引擎电脑与改善排气系统的效率，可以说是为了提升引擎基本体力而做的处理。这些处理会成为之后针对引擎本体进行机械调校、加装增压器等正式调校工程的基础。虽然这些处理无法大幅提升马力，但效果却会展现在转速提升速度变得更敏锐、油门反应速度更快等，让驾驶员操作起来更舒适。另外，这些调校对于引擎造成的负担较小，且具有在高负荷运作下保护引擎的效果，可以带来提升引擎耐久度的好处。</p><p><br></p><ul><li><strong>电脑(computer)</strong></li></ul><p>通常是改写存有控制引擎的相关资讯的ROM中的资料，也称为记忆体调校。当提升增压器的增压质、更换进排气系统的零件以及对引擎本体做过变更之后，就有必要进行记忆体调校。</p><p><br></p><ul><li><strong>火星塞(spark plug)</strong></li></ul><p>想要对燃烧室内的混合气体点火使其正常引爆，需要产生强力的火花。即使是一般引擎，如果持续使用一般火星塞在高负荷下运转，便会导致过度燃烧。特别是在通过调校提升过马力的引擎当中，爆炸力增强将使燃烧室温度上升，导致变得容易发生异常燃烧现象(pre-ignition，也称预燃)。因此必须提高火星塞的耐热度，选择高价的火星塞。</p><p><img src="/images/BeyondTheApex/computer-spark-plug.png" alt></p><p><br></p><ul><li><strong>空气滤清器(air cleaner)</strong></li></ul><p>空气滤清器能够去除引擎进气中含带的灰尘与异物。一般款式的阻力较大，会对马力输出造成不利影响，因此更换成阻力较小的竞赛用款式较为理想。这样带来的效果与其说是提升马力，不如说是会提升高转速领域的引擎反应速度和加速时加速性能方面的表现。同时，吸气音也可变得更大声。</p><p><img src="/images/BeyondTheApex/air-cleaner.png" alt></p><p><br></p><ul><li><strong>排气系统(exhausut system)</strong></li></ul><p>降低排气阻力能够使引擎转速上升的速度、踩踏板时的油门反应速度变得更加敏锐。此调校对于利用排气动能驱动涡轮增压引擎来说效果尤其显著，甚至只靠着调校消音器便能提升1-2成马力。不过，在更换零件后引擎的扭力特性也会随之变化，因此动手调校引擎前应该要根据调校目的，预先设想调整后想得到的特性。</p><p><img src="/images/BeyondTheApex/exhausut-system.png" alt></p><p><br></p><ul><li><strong>机油(engine oil)</strong></li></ul><p>高马力引擎内部各处都必须承受极大的压力，因此也必须使用高性能机油。机油除了润滑之外，还负有冷却、保持气密性等功用，因此若发生油膜破裂等情况，将引发缩缸导致马力降低。而在高速运转的金属零件之间，如果来不及润滑，很容易便会烧毁。另外，在选择机油时，影响摩擦损耗的黏度也是重要条件之一。</p><p><br><br><br></p><h3 id="检修"><a href="#检修" class="headerlink" title="检修"></a>检修</h3><p>在以量产为目的的引擎当中，一般状况下的运作精确度可能未臻完美，导致无法发挥原本应有的马力。要改善这种状况，可以通过把引擎全面拆解为零件，重新加以精密组装，以压榨出引擎的所有性能。这是称为<strong>检修(overhaul)</strong>的作业步骤，若同时配合调整各零件之间的平衡与轻量化，可以收到更显著的效果。若调校条件对于排气量没有特别限制，借此机会同时提升引擎汽缸本身的容量，可望更有效率、更合理地提升马力和扭力。</p><p><br></p><ul><li><strong>提升排气量(scale up)</strong></li></ul><p>这是在对引擎本身进行调校时，可以最确定收到最高的效果的工程。让引擎燃烧更大量的混合气体，便可得到更大的马力。<br>在做法上则可分为削薄汽缸内径，该用大口径活塞的扩大缸径式，或是更换曲轴与连杆等零件以增加活塞衝程的衝动式两种。虽然同样是增加排气量，但两者在特性上相当不同。前者适合增进提升转速以取得马力，后者适合用以提升中低转速领域的扭力。最近的引擎由于普遍经过轻量化处理，汽缸体的零件厚度变得较薄，因此想要大幅地提升内径更加困难了。</p><p><img src="/images/BeyondTheApex/scale-up.png" alt></p><p><br></p><ul><li><strong>调整平衡(balancing)</strong></li></ul><p>在一般状态下，每个汽缸的活塞和连杆之间都存在着些微的重量误差。而曲轴的旋转平衡若不佳，则会产生阻力，成为损失马力的主要原因。因此，调整平衡所要做的就是分解引擎，并精密地测量、同一每个零件的重量，以及修正旋转平衡来确保引擎运转顺畅，并有效率地引导马力。如果只靠加工零件无法达到上述目的时，甚至必须更换全新的零件。对于参加无法大幅改造引擎的统一规格赛的赛车而言，调整平衡可说是必备的已向调校作业。</p><p><br></p><ul><li><strong>轻量化(lightweighting)</strong></li></ul><p>惯性会出现在以超高速运转的引擎零件上，造成摩擦损耗而折损马力。能够解决这个问题的便是轻量化处理。基本上，轻量化必须与调整平衡作业同时运行，不过，若过度轻量化削薄零件的厚度，将会发生耐久性发面的问题。</p><p><br></p><ul><li><strong>强化(build up)</strong></li></ul><p>在大幅调校引擎之后，随着燃烧力变大，会对各部位零件造成庞大的负担，甚至有造成损坏之处。为此，虽然提升零件强度势在必行，然而在另一个方面，也不能忽略要保持轻盈的原则。经常被用来解决这个难题的，是以钛合金为首的各种新材质，以及用锻造工法制造的强化零件。它们具备一般零件难以相比的轻巧度，且能兼顾强度与刚度。在赛车用火调校过的引擎当中，使用铝制锻造活塞、钛合金值连杆等零件，已成为标准。</p><p><br><br><br></p><h3 id="高转速化"><a href="#高转速化" class="headerlink" title="高转速化"></a>高转速化</h3><p>由于<code>马力=扭力x转速</code>，所以想要提升马力，可说如何提升引擎转速。这个调校工程主要是和汽缸盖有关，关键在于提升高转速领域的进排气效率。主流做法是更换为凸轮运作角度更大的高角度轮轴，同时补强凸轮周围的结构。这样的处理可以收到与扩大进排气门相同效果，能够在高转速领域带来压倒性的马力。</p><p><br></p><ul><li><strong>气埠(port)</strong></li></ul><p>进气/排气埠分别是混合气体与燃烧后废气的通道。理想状况下，这个部分应该尽可能接近光滑；然而基于成本考量，在一般引擎中很少会讲究到这个部分，因此往往会对进排气造成阻力。造成问题的主要是铸造制品表面特有的粗燥起伏、与气流通道的尺寸大小或变形等。因此，有必要把气埠研磨成有如镜面般光滑，让进排气变得更顺畅。研磨气埠即可改善高速运转时的操驾感，然而若没针对汽缸整体同时进行更换凸轮、研磨汽缸表面等调校，则难以收到原本的功效。</p><p><br></p><ul><li><strong>气门(value)</strong></li></ul><p>在研磨气埠以及更换凸轮的同时，建议同时考虑扩大气门。扩大进气门的开口面积，可以增加进气量，提升填充效率。当然，气门尺寸越大便会越笨重(惯性作用力越强)，因此大多会选择以质轻的钛材料制造，来解决此问题。</p><p><br></p><ul><li><strong>气门弹簧</strong></li></ul><p>为了防止引擎在高转速运作时，气门弹簧发生异常震动，也就是所谓的激振（凸轮的运作跟不上弹簧伸缩速度的状态）想象，势必得要补强弹簧。在搭配高角度凸轮轴时更是如此，否则要是持续使用一般弹簧，将无法承受增加的气门扬程量，最糟糕的情况将会使得弹簧紧靠上凸轮导致锁死，或者让气门与活塞互相接触。但是若搭配国语强力的弹簧，又会造成引擎的阻力，或是加速气门周边磨损，因此必须特别注意。</p><p><br></p><ul><li><strong>凸轮轴(camshaft)</strong></li></ul><p>凸轮轴时负责开关进排气门的轴，而所谓的高角度凸轮轴=高扬程图轮轴，则是指高凸轮的抬举部分，以延长气门开启时间的凸轮轴款式。选用这种凸轮轴，可收到和扩大进排气们相同的功效。这虽然会降低在低中速领域的扭力，但是却能大幅提升高转速领域的马力。虽然无法否认这是种极端的特性，不过确实是在提升自然进气引擎的马力时最基本的调校手法。</p><p><img src="/images/BeyondTheApex/camshaft.png" alt></p><p><br><br><br></p><h3 id="高压缩化"><a href="#高压缩化" class="headerlink" title="高压缩化"></a>高压缩化</h3><p>在引擎当中，当活塞上推以压缩混合气体的力道越强，燃烧力也就越强，进而能引出更强大的马力和扭力。针对这个部分所做的调校，主要以汽缸盖的燃烧室容量设计为重点。不过要是过度提升压缩比，除了会造成引擎运转时的阻力，也可能导致异常燃烧。因此在调校时，也必须调整燃料、延迟点火正时、换成冷式火星塞、补强活塞和连杆等部分，以对抗更强的爆炸力。</p><p><br></p><ul><li><strong>活塞(piston)</strong></li></ul><p>在提高压缩比时，最具代表的调校手法便是更换成高压缩比活塞。不过，在压缩比提高后，混合气体的温度、燃烧温度都会变高，容易发生引擎爆震现象，所以必须采取改善混合气体动线等相关措施加以因应。</p><p><img src="/images/BeyondTheApex/piston.png" alt></p><p><br></p><ul><li><strong>燃烧室</strong></li></ul><p>在针对燃烧室所作的加工方面，比较简便的做法是把它修整成排气和点火效率优良的棱顶形状，但以因提高压缩比例预防异常燃烧所做压缩涡流加工为主流。这种加工方式是削薄燃烧室内压力变高的挤流区，稍微降低一些压缩比。但是在进行压缩涡流加工之后，各个燃烧室的容量将会出现差异，所以必须精密地重测各燃烧室容量。</p><p><br></p><ul><li><strong>汽缸盖(sylinder head)</strong></li></ul><p>以<code>0.1mm</code>的细小单位研磨汽缸盖的底面，这种手法称为盖面研磨。基本上这么做的目的在于减少燃烧室容量以提高压缩比例。盖面研磨的另一种用途，在于用来修正当引擎在过度严苛的热能条件下运作时，发生在汽缸体和汽缸盖之间的变形现象。</p><p><br></p><ul><li><strong>汽缸床垫片(head gasket)</strong></li></ul><p>结余汽缸盖与汽缸体之间，用以保持气密性，防止压缩气体外漏的金属板，就叫汽缸床垫片。将这块金属板磨得比一般状况下更薄，也能收到与盖面研磨相同的效果——即减少燃烧室容量以提高压缩比。最近常见通过选用热传导率高、强度优异的不锈钢作为汽缸床垫片的材质，以同时达到防止压缩气体外泄和调节压缩比的目的。</p><p><br></p><ul><li><strong>涡轮增压(turbo boosting pressure)</strong></li></ul><p>显示涡轮增压器能够吸入多少空气、并加以压缩的数值，即称为增压值。这个值以压力的单位<code>kg/cm²</code>加以表记，愈高表示能够引出愈大的马力。然而，在吸入大量空气的同时，也必须要提供足够的燃料与之搭配，因此需要借由电脑调节燃料供给，并更换能够喷出大量燃料的喷油嘴等零件。而引擎内部也必须具备足够的强度以承受增加后的爆炸力。</p><p><br></p><ul><li><strong>高流量涡轮(high flow turbine)</strong></li></ul><p>扩大用来压缩进气的压缩机轮部分，以争取更多风量的涡轮。基本上都采分解一般涡轮，只更换其中的压缩机轮部分的做法。由于涡轮经过削减处理惯性重量减轻，因此擅长于快速地发挥增压效果。这种做法几乎不需要牺牲引擎反应速度，便能提高马力。</p><p><br><br><br></p><h3 id="增压器-1"><a href="#增压器-1" class="headerlink" title="增压器"></a>增压器</h3><p>只需要提升增压和加大增压器自身的大小，便可发挥提升排气量相同的效果。如果搭配机械调校一起实施，则可望更加显著地提升马力。然而增压器加诸于引擎的负担甚至大过自然进气式，因此必须做出相对的因应措施。在自然进气引擎当中，提升马力的关键在于提高压缩比，不过，在使用增压器的引擎当中，反而得要降低压缩比，才能防止异常燃烧、或增加的爆炸力造成零件损坏。若使用的是涡轮增压器，泽荣旗产生动力迟滞现象，为了避免使引擎反应速度季度恶化，还得特别下工夫加以处理。</p><p><br></p><ul><li><strong>大容量涡轮(big turbine)</strong></li></ul><p>由于涡轮的大小决定了它的极限功率，所以这种调校手法就是直接将它更换成更大容量的涡轮。虽然可以飞跃性地提升马力，然而，却相对地因为要转动更大的涡轮，将使得引擎反应速度变得较为迟钝。除此之外，除非具备足以产生大量排气动能的排气量、或引擎本身具有足够的潜藏性能，否则这样的调校手法会使得地转速领域的扭力降低，并且只有在高转速领域才能得到增压下过。这样会让车子变得难以驾驭，是进行此种调校手法前应要事先考虑的部分。</p><p><br></p><ul><li><strong>中冷器(inter cooler)</strong></li></ul><p>能够冷却受涡轮增压器压缩而变得高温的空气，以提高引擎填充效率，进而提升马力的套件，便是所谓的中冷器。这种装置在市售车种当中亦属必备，尺寸越大、冷却效果也越强。不过如果因此装上过大的中冷器，会让压缩空气停驻于内部的时间变长，导致增压下降。这种现象叫做压力损失，依据条件不同，可能成为让增压值下降<code>10%-20%</code>的肇因。</p><p><br></p><ul><li><strong>机械增压器(super charger)</strong></li></ul><p>机械增压器和涡轮增压器同样采用将压缩空气压入引擎当中获得马力的设计原理。也就是说，在使用机械增压器时，只要提升增压值，同样可以提升更多的马力。机械增压器和涡轮增压器一样，都只要用螺丝便能装置在自然进气引擎上，可以轻易地大幅提升马力。由于结构上的设计，不易在踩踏油门时产生动力迟滞的状况，所以在技术赛道上非常占优势。</p><p><br><br><br></p><h3 id="转子引擎-1"><a href="#转子引擎-1" class="headerlink" title="转子引擎"></a>转子引擎</h3><p>调校转子引擎的重点在于提升进气效率，也就是如何扩大进气埠，将更多的混合气体送入燃烧室。这和在往复式引擎当中改用高角度凸轮轴得到的效果类似。不过值得注意的是，在转子引擎上扩大与移设气埠后得到的效果较大，同时车辆特性改变也较明显。在转子引擎上同时调校气埠和涡轮增压器，两相搭配之下可望引出跟多引擎的潜藏性能。</p><p><br></p><ul><li><strong>调校平衡(balancing)</strong></li></ul><p>转子引擎的结构比起往复式引擎相对简单，零件数目也比较少。因此，只要提升各零件的精确度，仔细地加以组装，便能够引导出引擎的潜藏性能，而改装重点则在于叫做<code>sealset</code>的作业。这是讲相当于往复式引擎活塞运动的三角气封加以重新组装，让它们具备相同的间隙。借此可以让转子室中的转子在保持着正确压缩比下，以极度顺畅地方式回转。反过来说，若气封发生问题，将造成马力降低，最糟糕的情况下将会导致烧毁。</p><p><br></p><ul><li><strong>侧边气埠(side port)</strong></li></ul><p>通过扩大设置在殻体侧边的进气埠口径，可以比平常更早开始吸入混合气体，进而提升马力。这种做法可以获得与在往复式引擎上该用高角度凸轮轴同样的效果。</p><p><br></p><ul><li><strong>桥状气埠(bridge port)</strong></li></ul><p>这是调校侧边气埠的手法之一。由于好像在磨削过的气埠间架起了桥梁一般，因而获得此名称。之所以在2道气埠开口之前设置桥状的通道，是因为要预留在气埠扩大到接近极限时，供三角气封通过动线范围。</p><p><br></p><ul><li><strong>外环气埠(peripheral port)</strong></li></ul><p>以特殊接著剂将通常位于普通引擎殻体侧边的进气埠塞住后，再将它移至转子室上部的做法。由于这可以让混合气体直接送入转子室内，因此优点是在高回转领域可以引出强大的马力。然而，另一方面却会失去在一般配置下，依据低回转/高回转区隔不同的混合气体进气方式以确保常用转速领域下扭力的功能，今儿使得引擎特性走向极端，变成在高回转领域能够发挥压倒性的马力，但低回转领域却几乎无法产生扭力。</p><p><br></p><ul><li><strong>组合式气埠(combination port)</strong></li></ul><p>结合了侧置气埠和外环气埠的调校手法。采用序列式控制，让低转速领域当中只有侧置气埠作动，而高转速当中只有外环气埠会运作，兼具了双发的优点。</p><p><br><br><br><br><br></p><h2 id="调校驱动系统"><a href="#调校驱动系统" class="headerlink" title="调校驱动系统"></a>调校驱动系统</h2><p>驱动系统负责将引擎效能转化为速度。除了必须具备良好的效率，将马力尽可能原封不动地传导至路面，害的要具备能够确实承受高功率的强度。</p><p><br></p><h3 id="终传齿轮比"><a href="#终传齿轮比" class="headerlink" title="终传齿轮比"></a>终传齿轮比</h3><p>想要将引擎动力按照重视速度、或重视加速的需求加以分配，可以通过改变终传齿轮的齿轮比来进行，亦即改变动力系统的终传比。特别是针对终传比进行低速档化，将可以更容易地引出拥有高转速、高马力效能的极端引擎特性，并可显著提升加速性能。</p><p><br></p><p>引导出引擎的性能。</p><ul><li><strong>高速档化(high geared)</strong></li></ul><p>这种手法可以提升在低引擎转速下的车速，因此在重视极速的情况下较为有利。另外，对于降低燃耗也很有效果。然而反过来说，想要提升引擎转速取得马力或扭力带时，将会产生时间延迟，所以不可否认地在加速上确实较为缓慢。在出了狭窄弯道后重新加速之类的情况下，将会因不易引出有效的马力与扭力，导致难以获得充分的加速力。</p><ul><li><strong>低速档化(low geared)</strong></li></ul><p>这种手法即使在3速和4速这类较高的档位下仍能轻易保持高转速，所以虽然会牺牲极速，但却能有效地引导出马力和扭力、提升加速性能。而在过弯时也能充分发挥引擎性能，使车子能在出弯时重新加速，因此十分适合用在以狭窄弯道为主的技术赛道。不过，随着引擎对油门操作的加速反应更加灵敏，必须留意转速提升过快的情况。</p><p><img src="/images/BeyondTheApex/high-low-geared.png" alt></p><p><br><br><br></p><h3 id="变速齿轮比"><a href="#变速齿轮比" class="headerlink" title="变速齿轮比"></a>变速齿轮比</h3><p>一般而言，针对变速器所做的调校，主要指的是将齿轮进行<strong>密齿比化</strong>（让相邻齿轮的比率更为接近），方能够比较容易地维持有效的马力带。这样做虽然能大幅提升加速性能，但根据与终传齿轮之间的搭配方式的不同，可能容易发生转速过快、需要频繁地换挡的情况。</p><p><br></p><ul><li><strong>密齿轮比(close ratio)</strong></li></ul><p>调校手排变速器的各齿轮比，使其具有相近比率后，这样的变速器通常就称为横向变速器。当比率愈接近时，在切入高档次时引擎转速下降幅度愈少，可以更有效率地引出马力。用此方法再搭配高角度凸轮轴的助力下，可以说是特别适合用在马力带狭窄的自然进气引擎的此轮配置。通常要采用此方法时，会顺应赛道结构等情况，搭配终传比一起进行设定。</p><ul><li><strong>疏齿轮比(wige ratio)</strong></li></ul><p>和高速档化一样，一般市售车款重视降低燃耗，因此会为了抑制转速而刻意地将各档齿轮比设定得比较大。在如此设定下，即便是切入高档位，引擎马力却仍旧只能和缓地传导至地面，也等于是牺牲了车辆的加速性能。不过，通常不会将1到5档，甚至包括6档在内的所有档位都改为疏齿轮比设定。比较常见的做法是将用于起步、加速的1、2档设定为密齿轮比，在3档以上设定为远齿轮比，再顺应引擎特性和赛道配置，来选择搭配较密或较疏的此轮比率设定。</p><p><img src="/images/BeyondTheApex/close-wide-ratio.png" alt></p><p><br><br><br></p><h3 id="离合器"><a href="#离合器" class="headerlink" title="离合器"></a>离合器</h3><p>减少驱动力损失，提高引擎反应速度。</p><p>想要将调校过后所增加的马力，尽可能地在未经损失的情况下传导给变速器，并确实执行换挡，则必须要补强离合器。离合器只要稍微打滑，便会导致车辆的加速性能下降。因此，合理的做法是配合马力/扭力提升的比率，提高离合器片的摩擦力与离合器压板的压著力。</p><p><img src="/images/BeyondTheApex/clutch.png" alt></p><p><br></p><ul><li><strong>离合器片与离合器压板(disc cover)</strong></li></ul><p>要想补强离合器，最传统的做法是将离合器片与离合器更换成强化过的款式。通过提高离合器片的摩擦力和离合器压板的压著力，可以更确实地将引擎马力传导给变速器。这些是引擎马力提升过后必备的零件，在家时跑车等严苛的离合器操作条件下，也不会产生反应变慢的情况。另外，离合器片目前以摩擦系数高，耐磨损性优异的金属制碟片为主流。</p><p><img src="/images/BeyondTheApex/disc-cover.png" alt></p><p><br></p><ul><li><strong>多片式离合器(multi plate)</strong></li></ul><p>相对于一般的离合器采单片式，补强过的离合器大多配有复数碟片，以扩大摩擦面积与加大压著力，来提升引擎马力的传导效率。多片式离合器从双片式到四片式都有，而增加的摩擦力大小与碟片数量成正比，摩擦力愈大便适用于马力愈高的引擎。此举虽然会提升动力系统的反应速度和耐久性，但在操作上却会产生缺点。如需更重的踏力，以及更细微的离合器接合动作等。</p><p><img src="/images/BeyondTheApex/multi-plate.png" alt></p><p><br><br><br></p><h3 id="飞轮和传动轴"><a href="#飞轮和传动轴" class="headerlink" title="飞轮和传动轴"></a>飞轮和传动轴</h3><p>想要提升引擎提高回转的速度、反应速度以及加速性能，将驱动系统加以轻量化可以带来相当大的效果。然而极度轻量化的飞轮，在爬坡时将难以产生足够的扭力，因此为了补强该特性，需要特别加以调校。</p><p><br></p><ul><li><strong>轻量化飞轮(lightweight flywheel)</strong></li></ul><p>装置在曲轴后端(离合器前方)的滑车称为飞轮，主要用途在于抑制引擎回转的落差。飞轮重量越重，回转起来越顺畅。然而飞轮的种类却会对追求速度方面带来负面影响，因此加以轻量化才是理想做法。虽然如此一来会让飞轮回转的顺畅度受到影响，也会使引擎扭力减少，但相对的却能使得转速提升速度和引擎反应更加敏锐。</p><ul><li><strong>领量化传动轴(lightweight propeller shaft)</strong></li></ul><p>介于变速器和差速齿轮之间，传导引擎马力的传动轴在经过轻量化之后，也能带来提升引擎反应速度和加速性能的好处。轻量化传动轴的材质主要为碳纤维和强化塑胶(FRP)，重量约只有一般款式的一般。减轻重量固然重要，不过是否保持正确的回转平衡则同样不容忽视。</p><p><img src="/images/BeyondTheApex/lightweight-flywheel-propeller-shaft" alt></p><p><br><br><br></p><h3 id="限滑差速器-1"><a href="#限滑差速器-1" class="headerlink" title="限滑差速器"></a>限滑差速器</h3><p>将动力确实地传导至路面。</p><p>想要追求快速过弯的目的，绝对少不了能将引擎马力确实传达给路面的限滑差速器(LSD)。而在各类限滑差速器当中，能够发挥最大差速限制能力的，是利用多片式离合器产生压著力的机械式限滑差速器。这种限滑差速器最大的优点，在于能够自由设定开始生效、乃至生效为止的引擎反应速度。换言之，它能够配合驱动系统配置等车辆特性，驾驶风格与赛道配置，取得最适切的驱动力。然而，在发挥极大的差速限制力的同时，对于内部零件的负担也会增加，所以更要确实做好更换机油、全面检修等定期保养措施。</p><p><img src="/images/BeyondTheApex/LSD-2.png" alt></p><p><br></p><ul><li><strong>锁定比(lock ratio)</strong></li></ul><p>锁定比是用来显示LSD功效的数值。<code>0%</code>时为使用一般差速齿轮时的状况，而<code>100%</code>则表示差速器锁死。此数值越高，表示差速限制力越大。但一般来说并不是锁定比愈高愈好，理想值和驱动方式、车高和轮距等，都有很大的关联性，也会因为希望将车子调教成何种特性而有所不同。如果锁定比设定超出了理想值，则会在入弯初期呈现强烈的转向不足特性，并显著地影响过弯性能。一般来说，车辆在锁定比设定为约<code>50%</code>左右的情况下最容易操控，同时也能得到充分的差速限制效果，不过，仍有必要通过反复的测试，从错误中找出最合适的数值。</p><p><br></p><ul><li><strong>介入扭力(initial torque)</strong></li></ul><p>介入扭力指的是差速齿轮箱内部压制碟片的压力。提高或降低此压力，可以变更LSD达到锁死前的时间。提高介入扭力，可以让对油门操作的反应速度变快，转瞬间便能使LSD锁死；降低介入扭力，则能使LSD平缓地达到锁死，乘驾感较为舒适。在调校汽车性能的过程当中，提高扭力是基本需求。不过，若因此而使得转向性降低、或在FF式驱动车种中造成扭力转向增强等缺点，也同样不容忽视。附带一提，近来在低扭力领域当中，能够发挥极高差速限制效果的车种，有愈渐增加的趋势。</p><p><br></p><p><strong>机械式LSD的种类</strong></p><ul><li><p><strong>1WAY</strong><br>只有在踩踏油门时运作的LSD。由于不会在放开油门时运作，所以可以运用一般差速齿轮所具备的内轮差修正功能，更加顺畅地攻略弯道。这种LSD特别适合用在转向不足现象较强的FF式驱动车种上，不过会使得册子在踩踏/放开油门的情况下动态出现显著差异。</p></li><li><p><strong>2WAY</strong><br>在踩踏/放开油门两种情况下都会生效的LSD。在初期会发生较强的转向不足现象，不过，由于在减速时能够确保车身动态稳定，让人可以放心地攻略弯道。引擎反应速度也极为优异，让驾驶员可以积极地踩踏油门过弯。</p></li><li><p><strong>1.5WAY</strong><br>具有1WAY和2WAY双方特性的LSD。除了能够保持在加速方向的LSD效果，也能抑制LSD在减速方向的效果，同事也考虑到了在攻略弯道途中转向的容易性。可称得上是不会让驾驶人感受到车子的特殊习性，且能够应付各种状况的LSD。</p></li></ul><p><br><br><br><br><br></p><h2 id="为车瘦身"><a href="#为车瘦身" class="headerlink" title="为车瘦身"></a>为车瘦身</h2><p>轻巧、高刚性的车身，是高速奔驰的基本要件。无论提升了多少引擎马力，若搭配的是笨重脆弱的车身，还是难以发挥速度。</p><p><br></p><h3 id="高刚性-轻量化"><a href="#高刚性-轻量化" class="headerlink" title="高刚性/轻量化"></a>高刚性/轻量化</h3><p>为了将车子的运动性能提升至极限，无可避免地一定得对车身做轻量化以及高刚性化的调校。车身轻量化不仅对提升加速性能而言十分重要，也对改善刹车和过弯性能有很大的影响。另外，为了确保悬吊在高负荷状态下能够正确运作，同时兼顾轮胎的接地性，高刚性化同样是不可或缺的步骤。为了让驾驶员能够瞬间掌握车辆动态，采取正确的操作，也绝对需要一具不易变形的坚固车身。附带一提，在路面阻力系数极低，且有著来自纵横两方向的强力G力的纽堡林赛道，若尘神未具备坚实刚性，很可能连一圈都没办法顺利跑完。</p><p><br></p><ul><li><strong>拉杆(tower bar)</strong></li></ul><p>连接悬吊和车体相连部位（轮胎室上端）左右两侧的长棒叫做拉杆。车子装上拉杆之后，将能提升车身前部的刚性，并使悬吊能够正确运作。对于方向盘操作的反应也会更加锐利。基本上，拉杆应该在针对减震筒、弹簧、襯套等悬吊系统进行调校时一并装上。一般来说，拉杆通常只装在车身前方，不过若只考量到提升刚度的需求，最理想的做法是在车身前后都装上拉杆。</p><p><img src="/images/BeyondTheApex/tower-bar.png" alt></p><p><br></p><ul><li><strong>点焊(spot welding)</strong></li></ul><p>车身是用冲压过的金属板件接合起来所制成的。在所有接合手法中，最具代表性的就是每个固定的间隔设一个点建议焊接，称之为<strong>点焊</strong>。不过，由于市售车种为了讲求生产效率，必须尽可能减少焊接部位，所以容造成车体刚性不足的问题，因此，增加焊接部位的强化手法，就称为<strong>增加焊点</strong>。这能让车身板件间的接合部位更加坚固，可望大幅提升车体刚性，此外，由于不用增加新的零件即可执行，所以也不需要担心会导致车身变重。</p><p><img src="/images/BeyondTheApex/spot-welding.png" alt></p><p><br></p><p>获得正确的操纵性。</p><ul><li><strong>防滚笼(roll cage)</strong></li></ul><p>防滚笼原本的功用在于保护驾驶员不受变形的车身伤害，但在提高车身刚性时，它也能发挥很大的效果。不过先决条件时这款防滚笼和车顶与车柱之间必须毫无缝隙，稳固且确实地焊接在车身上的设计，而不是只通过螺丝固定的款式。另外，若能尽可能增加支撑点，并架设成有如立体攀爬架的状态，则可提升更多的刚性。</p><p><img src="/images/BeyondTheApex/roll-cage.png" alt></p><p><br></p><ul><li><strong>底架(member brace)</strong></li></ul><p>底架是看完去和变形的金属制长棒，在强化车舱地板下部刚性的同时，也能通过连接车身底座，限制悬索的多余动态，已完全发挥悬吊的性能。换句话说，就像拉杆从引擎盖内部支撑悬吊和车身一样，底架则是从车身下部支撑着。和栏杆并用不仅效果更佳，还能进一步地提升车身动态的稳定性。</p><p><img src="/images/BeyondTheApex/member-brace.png" alt></p><p><br></p><ul><li><strong>轻量化(lightweighting)</strong></li></ul><p>想要提升车子的加速/减速/转向等所有行驶性能，最有效的调校手法莫过于减轻车体重量。在做法上，依照轻量化程度的不同，从最基本的省略空调等行车舒适设备和隔音材质，乃至于将车身板件换成轻质量的铝制或碳纤维制材质都有。或者更讲究一点，还得将车殻本身改为碳纤维材质，并把车架换成铝制。不过，为了在保持均衡的状况下提升行驶性能，轻量化与高刚性化因该要同时进行。另外，若能一并考虑重心高度(低重心)，并主要针对车体的上部进行轻量化，效果会较为显著，效率也跟高。</p><p><br><br><br><br><br></p><h2 id="增强制动力"><a href="#增强制动力" class="headerlink" title="增强制动力"></a>增强制动力</h2><p>调校刹车应该和提升马力同步进行考量。唯有具备足够的制动力，驾驶员才能放心踩油门。调校刹车时不仅得要强化制动力，对于热能也要有万全之策。</p><p><br></p><h3 id="强化制动力-耐过温衰退性"><a href="#强化制动力-耐过温衰退性" class="headerlink" title="强化制动力/耐过温衰退性"></a>强化制动力/耐过温衰退性</h3><p>一辆调校过引擎、提升了绝对速度的车子，相对的也会需要更强大的制动力，以及更高的耐过温衰退性能。最基本的做法是更换来令片，而若要追求极致，则得将整套刹车系统换成大排气量赛车专用的套件。根据调校的需求层级不同，有许多的手法可供选择。不过，即使是赛车用的零件，也未必在各种用途上都能发挥完备的性能，还是应该要按照使用目的来选择零件。一味地加大刹车碟和卡钳的尺寸，可是会增加簧下重量，妨碍车辆运动性能。虽说刹车性能的铁则是必须高于引擎马力，但若因此就在轻量级的车种上装置大容量的系统，则明显大材小用了，极有可能会破坏车辆行驶时的整体平衡。</p><p><br></p><ul><li><strong>来令(pad)</strong></li></ul><p>刹车来令是在强化刹车时最基本的零件，会大幅影响制动力与耐过温衰退性。来令种类繁多，从街道用到竞赛用都有，然而在如此多样化的选择当中，适温(能够发挥最大制动力的温度)和耐热温度都各有不同，如果不能按照使用目前的选择最合适的种类，则很有可能效果不如预期，甚至对行驶造成不良影响。当然，跟一般的来令片比起来，特殊的来令片磨损较快，对刹车碟的伤害性也较高，为了确保制动力的平衡，通常会前后一起更换。</p><ul><li><strong>刹车油(fluid)</strong></li></ul><p>用在油压式刹车当中的作用油。为防止气阻现象，竞赛用的刹车油沸点必须在200度以上，但如此一来却也会使得吸湿性极高而容易裂化。<br>刹车油的DOT级数越高，沸点也就越高，干同事也更容易因吸收湿气而裂化(沸点下降)。因此，竞赛专用的DOT5刹车油，在使用时必须以很短的周期频繁更换。需要特别留意的是，DOT值越大，并不表示制动力本身也跟着提升。</p><p><br></p><p>提升刹车的整体性能。</p><ul><li><strong>刹车油管(hoos)</strong></li></ul><p>刹车油管是刹车油的通道，一般为橡胶材质。因此在紧急刹车等油压升高的状况下，刹车油管将会膨胀，使得刹车踏感变得暧昧不扎实。能够排除这种现象的便是称为不锈钢網的刹车油管。这种刹车油管当中在铁氟龙油管外部披上网状的不锈钢，使其在保有和橡胶同等的柔软性之下，又能防止膨胀。这在竞赛用车种当中是必备的补强零件，并能经常维持直接而正确的刹车踏感。</p><p><img src="/images/BeyondTheApex/hoos.png" alt></p><p><br></p><ul><li><strong>刹车碟盘</strong></li></ul><p>在提高制动力的手法当中，最有效的的便是提升刹车面积，也就是加大碟盘直径以产生更大的摩擦热。然而，换用铸铁制的大直径刹车碟盘同事却会使得簧下重量增加，降低车子的行驶性能。因此，最近市面上开始出现以陶瓷或碳纤维为主要材质的轻量化刹车碟。刹车碟盘是随着使用逐渐磨损的耗材，想要得到应有的制动力，就得定期更换或者研磨。</p><p><br></p><ul><li><strong>刹车卡钳(caliper)</strong></li></ul><p>对刹车卡钳本身进行的调校手法之一，是干脆升级整个刹车系统。一般而言是将卡钳更换成能够将两侧来令片推夹刹车碟的对向活塞式设计，让刹车来令能够确实紧压刹车碟。而从许多市场车款也采用6活塞式刹车来看，课件活塞数目愈多，愈有助于同一队来令表面施加的压力，达到提升制动力的效果。另外，在对向活塞式刹车系统中，刹车卡钳本体可采一体成型，固定在车体上无需移动，这种配置当中刹车卡钳的刚性高，即使在严苛的使用条件下也能发挥稳定的刹车性能。</p><p><img src="/images/BeyondTheApex/caliper.png" alt></p><p><br><br><br><br><br></p><h2 id="补强车底结构"><a href="#补强车底结构" class="headerlink" title="补强车底结构"></a>补强车底结构</h2><p>补强车底结构是重要的调校工程，可以在严苛的行驶条件下稳定车辆的动态，带来正确的操控性。这道步骤的效果足以使得车辆特性大幅转变。</p><p><br></p><h3 id="变更驾驶特性"><a href="#变更驾驶特性" class="headerlink" title="变更驾驶特性"></a>变更驾驶特性</h3><p>在竞赛行驶目的下对悬吊所做的调校，通常意味着为追求速度而牺牲部分乘驾的舒适感。如果只会跑在像赛车跑道那种平坦的路面上，那么车高愈地，将使重心下降，车辆的动态便会愈安定。而悬吊越硬，就越能减少加速、减速、与转向时不必要的动态，让操控性更锐利。当然，实际上若悬吊完全不发挥功用，则重心便不会移动，让车辆的操控性变得极为糟糕，因此，在调硬悬吊阻尼时，应确保在能够运用重心移动的范围之内，并考量前后左右的均衡才是上策。随着车辆特性和路面状况不同，有时为了提升轮胎的抓地力，会刻意地调软悬吊。</p><p><br></p><ul><li><strong>弹簧(spring)</strong></li></ul><p>除了最基本的利用重心化来提高运行性能之外，同时是抑制过弯时的车身晃动、起步/加速时的后沉现象等，用以稳定车辆动态上所不可或缺的零件。</p><p><img src="/images/BeyondTheApex/spring-2.png" alt></p><p><br></p><ul><li><strong>车高可调试悬吊(height adjust suspension)</strong></li></ul><p>拥有了可任意伸缩弹簧长度的车高调整功能，有些还同时具备可调整阻尼衰减的减震筒。各两件搭配的方式种类繁多，可以因应行驶情境做出细微的调整。调整车高的方式则可分为螺丝式、C环式、托架式等。</p><p><img src="/images/BeyondTheApex/height-adjust-suspension" alt></p><p><br></p><ul><li><strong>减震筒(damper)</strong></li></ul><p>通过赋予比一般减震筒更大的阻尼硬度，以确保在承受巨大负荷的高速行驶状况下，仍能维持车辆动态的稳定性，并提高操控性。更换与调校减震筒应该要与弹簧同时进行。</p><p><img src="/images/BeyondTheApex/damper.png" alt></p><p><br></p><p>随心所以掌握操纵性能。</p><ul><li><strong>平衡杆(stabilizer)</strong></li></ul><p>通过调高比例，可以进一步提升平衡杆原本具备在过弯时抑制车身晃动的效果。若仅调高前方的比例，则可以使车子呈现出转向不足的特性，仅调高后方的比例，则会呈现出转向过度的特性。</p><p><img src="/images/BeyondTheApex/stabilizer-2.png" alt></p><p><br></p><ul><li><strong>悬吊襯套(bush)</strong></li></ul><p>通过强化装在避震装置和悬吊环等零件与车身相连处、以及各连杆的连接部位的缓冲材质（襯套），可以抑制悬吊的多余动态，给予驾驶员直线性的操盘反应与操控性。悬吊襯套的材质以橡胶或聚氨脂等树脂类为主，也有在可活动部位使用金属球（一般称为鱼眼）的种类。</p><p><img src="/images/BeyondTheApex/Bush.png" alt></p><p><br><br><br><br><br></p><h2 id="轮胎的高性能化"><a href="#轮胎的高性能化" class="headerlink" title="轮胎的高性能化"></a>轮胎的高性能化</h2><p>高性能轮胎的抓地力虽高，但是超出极限时却也极难控制，可说是有利有弊。因此在选择轮胎时，必须审慎考虑车子特性和动力间的平衡。</p><p><br></p><ul><li><strong>胎面加宽(width up)</strong></li></ul><p>加大胎面宽度能增加接地面积，则抓地性能自然会提升。不过轮胎的抓地力不仅来自于和地面的摩擦，同时也会因为轮胎的负重而大幅变化。例如，在车重较轻的车子上装上胎面极宽的轮胎时，因对轮胎施加的负重不足而导致无法获得高抓地力，也不是什么稀奇的事。而若是在马力不足的车种上装上尺寸过大的轮胎时，常会因轮胎的抓地力吃掉马力，反而使得车速变慢。因此，配合车重与引擎马力选择适当的轮胎相当重要。</p><p><br><br><br></p><h3 id="提升抓地力-轮胎刚性"><a href="#提升抓地力-轮胎刚性" class="headerlink" title="提升抓地力/轮胎刚性"></a>提升抓地力/轮胎刚性</h3><p>高性能轮胎的要件是抓地力与刚性。将这两项条件追求到极致的境界的，是竞赛专用的光滑胎。这种轮胎的接地面胶料会因为摩擦热而融化，让车胎与路面紧密接触，而为了确保地面的刚性，这种轮胎上没有任何胎纹。这样的作法同样可以套用在公路胎上，凡是强调高性能的轮胎，无一例外会选用软质的胎面胶料，并且具备满较浅的粗胎纹。不过，为了确保在湿滑路面上的排水功能，胎面上势必还是得保留胎纹，且胎纹愈多、愈深，排水功能愈强。对轮胎而言，行驶性能和应付湿滑路面的性能时两种相斥的性能，如果将其中的平衡调整到极致境界也是一大学问。</p><p><img src="/images/BeyondTheApex/tire-2.png" alt></p><p><br></p><p>紧紧地抓住地面。</p><p><br></p><ul><li><strong>升级轮圈尺寸(inch up)</strong></li></ul><p>所谓inch up，指藉由降低轮胎的扁平率（轮胎宽度相对于高度所占百分比），而在不需要变更轮胎外径的前提下，加大轮圈尺寸的手法，但这种手法未必等同于加宽轮胎宽度。主要的有点事当胎肩宽度（高度）变窄时，会减轻轮胎的过弯或刹车时的横向变形程度。这也可说是藉由提升刚性来改善操作方向盘的反应速度与操纵性。然而，极端的inch up将会因轮圈尺寸加大，导致簧下重量增加而显著折损运动性能。附带一提，竞赛用车种当中，inch up本来不低在于藉由扩大轮圈直径，以装载更大容量的刹车系统。</p><p><img src="/images/BeyondTheApex/inch-up.png" alt></p><p><br></p><ul><li><strong>胎面胶料(compound)</strong></li></ul><p>用在轮胎接地部位的橡胶材质称为胎面胶料，对于轮胎抓地力有决定性的影响力。重视抓地力的高性能轮胎会使用容易紧贴于路面的软质胶料，特别是赛车胎的表面会因为与路面抹茶生热而融化，利用融化后的黏性牢牢地抓住地面。然而软质胶料虽然能够产生极高的抓地力，但相对地磨损也快。硬质胶料则具有完全相反的特性。选择轮胎时，应该对此基本特性有充分认识。另外，轮胎会随着时间经过而硬化，使得抓地力从全新品的状态开始逐渐劣化。越是软质的胎面胶料，这样的倾向越明显。</p><p><br></p><ul><li><strong>胎纹(groove)</strong></li></ul><p>刻在轮胎接地面上的满槽称为胎纹，具有在潮湿路面上排水，以保持接地面与路面间的抓地力的功能。另一方面，在干燥路面上进行过弯、刹车或加速等增加轮胎超负荷的动作时，胎纹只会带来使轮胎横向变形等坏处而已。最明显地说明了此一事实的，是赛道用的光滑胎上完全没有任何胎纹。而在试车会与假日车赛中使用的准赛车胎上，为了确保接地面的刚性，仅在胎面上刻上浅浅的、最低限度的胎纹。</p><p><img src="/images/BeyondTheApex/groove-2.png" alt></p><p><br><br><br><br><br></p><h2 id="提升空气性能"><a href="#提升空气性能" class="headerlink" title="提升空气性能"></a>提升空气性能</h2><p>为了提升高速领域的行驶性能，空气调校不可或缺。反过来说，如果这方面的调校稍有失误，则只会带来不好的影响。想要得到预期的效果，调校必须及其精密。</p><p>化解风阻并加以活用。</p><p><br></p><h3 id="空力调校"><a href="#空力调校" class="headerlink" title="空力调校"></a>空力调校</h3><p>一般而言，安装空力套件大多是为了装饰目的。不过对正式地进行大幅调校的车而言，这道步骤发挥了非常重要的功能。空力调校的主要目的是降低在高速领域使车速变慢的风阻、抑制让车身浮起的升力，以提高行驶性能。其中，安装空力套件后产生将车体向下压的作用力（下压力），是提高车身动作稳定性、强化轮胎抓地力时不可或缺的力量，对于提升操纵性有很大的贡献。不过，进行空力调校时，必须注意与包含悬吊在内的车辆整体之间的平衡性，若空力调校不当，往往反而使得行驶性能恶化。</p><p><br></p><ul><li><strong>前扰流器(front spoiler)</strong></li></ul><p>加装前扰流器的目的在于抑制流入车身下方的空气，以降低升力。不过，在一些稀有的案例当中，帮车子装上外型未充分改装的空力套件，又将是离地高度降低以放低重心之后，加压过的气流不断流入空间变窄的车身下方，反而在车身前方产生升力，造成和原本预期的完全相反的效果。这在最糟糕的情况下，甚至会让车子失去控制。</p><p><img src="/images/BeyondTheApex/front-spoiler.png" alt></p><p><br></p><ul><li><strong>后扰流器(rear spoiler)</strong></li></ul><p>这种空力套件的功用在于优化后保险杠的形状，以抑制车身后方产生的涡流，引导气流更顺畅地通过车身。有的后扰流器和后保险杠一体成型，也有一部分装设在保险杠下方。一般而言前者称为<strong>后保险杠扰流器(rear bumper spoiler)</strong>，后者则称为<strong>下扰流器(under spoiler)</strong>或<strong>后裙(rear skirt)</strong>。</p><p><img src="/images/BeyondTheApex/rear-spoiler.png" alt></p><p><br></p><ul><li><strong>尾翼(rear wing spoiler)</strong></li></ul><p>装置在车身后方上部，除了具有引导气流顺畅地通过车身的整流效果，还能抑制产生于车身后方的涡流。扰流尾翼的形状和能够产生升力的飞机主翼恰恰相反，因此尺寸越大，能够产生越大的下压力，并可借此提高后胎的抓地力。</p><p><img src="/images/BeyondTheApex/rear-wing-spoiler.png" alt></p><p><br></p><ul><li><strong>侧扰流器(side spoiler)</strong></li></ul><p>也称做<strong>侧扰流裙(side skirt)</strong>、<strong>侧扰流梯(side step)</strong>，装置在车身两侧下方（侧油封附近），具有减低车体两侧风阻的效果。</p><p><img src="/images/BeyondTheApex/side-spoiler.png" alt></p><p><br></p><ul><li><strong>扰流尾翼(rear diffuser)</strong></li></ul><p>这种整流板的作用是有效率地将车身下方的气流自后保险杠下导出，以产生负压进而获得下压力。扰流尾翼是赛车必备的零件，车身下方和路面间的间隔越窄，则效果越显著。</p><p><img src="/images/BeyondTheApex/read-diffuser.png" alt></p><p><br><br><br><br><br></p><h2 id="根据汽车特性改变设定"><a href="#根据汽车特性改变设定" class="headerlink" title="根据汽车特性改变设定"></a>根据汽车特性改变设定</h2><p>改装一辆汽车必须根据车辆本身的特性来进行合适的设定与调校。每一辆车不同之处、驱动方式可能对于操控与车辆动态造成最大的影响，在改装前了解不同驱动方式的差异是相当重要的。</p><p><img src="/images/BeyondTheApex/156.png" alt></p><p><br></p><h3 id="驱动方式"><a href="#驱动方式" class="headerlink" title="驱动方式"></a>驱动方式</h3><p>车辆的驱动方式，指的是引擎位置——整车最重的地方，以及连接驱动轮的部分。不同的驱动方式拥有不同的优点与缺点，即使在高度改装的性能车上，操控特性与车身反应都无法不受到驱动方式的影响。改变车辆的驱动方式相当困难，但依旧可能藉由结构变动与调校，来改善驱动方式先天上的差异。最佳的改装与调校，就是要能在既有的驱动方式、悬吊、空力效应方面，提供比量产车更为优异的特性。</p><p><br></p><ul><li><strong>FR前置引擎后轮驱动</strong></li></ul><p>假设车辆的配重均衡的话，一辆FR(前置后驱)的汽车，可以提供顶尖的弯道表现与稳定性。如果想要提高车速，提升后轮循跡性，让车辆在加速过程中不发生后轮偏移的情况也是一种方法。另外针对非驱动轮的前轮，可以调整为转向不足的特性，有助于让整体转向特性趋于均衡，这尤其在车辆减速时可以让驾驶人更容易控制方向。</p><p><img src="/images/BeyondTheApex/FR-2.png" alt></p><p><br></p><ul><li><strong>FF前置引擎前轮驱动</strong></li></ul><p>在一辆FF前置引擎前轮驱动的汽车上，尽管转向与驱动轮均在前轮，但也不能完全忘记后轮的反应。。在高速赛道的情况下，后轮需要更高的稳定性，降低在极端的情况下，后轮因为重量较低而产生偏移的几率，而车辆的调校必须让驾驶人松开油门后，让后轮回到可控制的反应范围内，并且协助前轮望准确的转向方向去，FF前置引擎前轮驱动车，可利用单向限制差速器，并且仅与车辆加速时作动提升车辆循跡性。</p><p><img src="/images/BeyondTheApex/FF-2.png" alt></p><p><br></p><ul><li><strong>MR中置引擎后轮驱动</strong></li></ul><p>让引擎位于车辆的中心，可以提供车辆优异的加速与减速性能。但是在经过调校的情况下，若车头的负载较轻也可能让车辆出现转向不足的状况，车身后半部的偏移速度也会较快。所以当进行改装时，重点应该放在车辆入弯时容易操作的特性，之后才是车辆出弯时的循跡性，此外车辆的前方与后方的下压力也应该注意平衡。</p><p><img src="/images/BeyondTheApex/MR-2.png" alt></p><p><br></p><ul><li><strong>RR后置引擎后轮驱动</strong></li></ul><p>将引擎放置在后轮上，并且采用后轮来驱动，这样的驱动方式，基本上会让车头更轻也可能出现明显的转向不足，但若在弯道操控时逼近极限，车尾可能出现钟摆效应，进而使整车出现瞬间转向过度的情况，通常改善的方式，是提升对于入弯时的控制能力，让车辆的转向趋于中性。</p><p><img src="/images/BeyondTheApex/RR-2.png" alt></p><p><br></p><ul><li><strong>4WD四轮驱动</strong></li></ul><p>在各种不同的四轮驱动方式上，可能让车辆出现的过弯特性截然不同，但一般而言，让一辆车四轮驱动转弯更不容易，所以在设定方面往往都将焦点放在入弯控制的能力，通常会在前轴采用单向限滑差速器，并且在后轮导入双向限滑差速器，来解决先天上的问题。</p><p><img src="/images/BeyondTheApex/4WD-2.png" alt></p><p><br><br><br><br><br></p><h2 id="逐项基本设定"><a href="#逐项基本设定" class="headerlink" title="逐项基本设定"></a>逐项基本设定</h2><p>仅单纯地装置高性能组件，并无法让车变快，性能设定必须考虑到整车的均衡性表现，这样才能够发挥车辆各部分性能提升后的潜力。</p><p><br></p><h3 id="悬吊"><a href="#悬吊" class="headerlink" title="悬吊"></a>悬吊</h3><p><br></p><h4 id="车辆高度-弹簧系数"><a href="#车辆高度-弹簧系数" class="headerlink" title="车辆高度/弹簧系数"></a>车辆高度/弹簧系数</h4><p><strong>改变车身反应。</strong></p><p><br></p><p>假设路况够好，车辆的重心降低，将让整车的稳定性明显提升，这会降低车辆加速或减速时的车身俯仰程度，藉由改变悬吊行程的长度，影响前后轮的高度，也会影响到提升整体性能。<br>举例来说，若让前悬吊明显低于后悬吊，弯道上产生的进入制动会令前轮贴紧路面，使进弯的动作更顺畅。在FF前置引擎前轮驱动汽车上，可藉由提升加速来抑制车头俯仰程度，来改变车辆入弯的特性。</p><p>弹簧系数同样对于车辆的反应影响甚大，理论上悬吊设定更硬会提升过弯性能，但也不永远总是这样。较硬的悬吊可以让车辆在入弯时降低车头俯仰的幅度与车身的晃动，但是若降低悬吊高度太多，也可能会影响到车辆入弯时接触地面的面积与悬吊几何，结果影响到车辆的循跡状况，所以弹簧系数适当与否对于车辆入弯或出弯的表现影响甚大。<br>弹簧系数也将对操控表现影响极大，提升弹簧系数可能导致转向不足，而且也可能提升后轮转向过度的几率，有时藉由调整阻尼系数，也可以补偿原有的特性。</p><p><img src="/images/BeyondTheApex/gaodu-tanhuangxishu.png" alt></p><p><br><br><br></p><h4 id="阻尼系数"><a href="#阻尼系数" class="headerlink" title="阻尼系数"></a>阻尼系数</h4><p><strong>控制弹簧的压缩比。</strong></p><p><br></p><p>若增加负载的压力，避震器会控制悬吊弹簧扩张，而执行这项任务的应力，便被称为阻尼系数，通常这股力量减震筒内所封存的气体压力进行活塞运动来决定，阻尼系数愈高，表示弹簧的活动速度反应会变快，若被压缩地位置愈地，或是活动行程加长，避震器的反应会较为和缓。<br>阻尼系数的设定独立施力，让车身反应与操控更精确，假设阻尼系数利用弹簧压缩，也会影响悬吊系统的反应时间、车身晃动与俯仰角度，也可以让车轮尽速脱离不均衡的状态，另外一方面，提升阻尼系数，也可以降低前悬吊在短时间内的反应幅度，维持车轮与地面的接触面积。</p><p>操控特性同样也可藉由改变阻尼系数的压缩或延伸还加以改变，也可以影响前后轮的反应状况，若藉由减少对前悬吊的压缩来改变阻尼系数，车辆大部分的重量将向前移，导致转向不足。<br>降低后轴弹簧反应的阻尼系数改变，则可能让车身重心后移，提升转向过度的几率，这必须藉由事先的调校与设定才能改变车身的反应。</p><p><img src="/images/BeyondTheApex/zunixishu.png" alt></p><p><br><br><br></p><h4 id="轮胎定位-外倾角"><a href="#轮胎定位-外倾角" class="headerlink" title="轮胎定位/外倾角"></a>轮胎定位/外倾角</h4><p>最普遍的轮胎定位设置，就是轮胎外倾角的调整，负外倾角所指的是胎面与地面接触的面积，大于轮胎上半部；而正外倾角的状况正好相反，主要是轮胎轴心与铅直中央夹角向轮胎外侧扩大。</p><p>当车辆转弯时，离心力会导致车辆往弯道的外侧倾斜，假设在车辆转弯时出现负外倾角，表示转弯时轮胎胎面与地面接触面积较大，也代表可以提供较佳循跡表现，所以一般来说提升外倾角，指的就是造成负外倾角效应。<br>然而，负外倾角在车辆直线行进时还是有缺点，由于直进时轮胎并未与地面保持垂直，所以可能会造成车轮在此时接地面积比转弯时小，也代表影响到循跡表现，进而对操控产生不利的影响，同时行进时轮胎的滚动阻抗会予以提升，直接影响到车辆的加速性表现，更甚者会让同样的速度情况下，车辆需要更长的距离与更强大的制动力才能刹车，进行极端的调整前要注意上列的利与弊。</p><p>当采用负外倾角定位时，最重要的就是考量到车身前后配重，对于弯道操控与车身反应造成的影响，若车头负载较重，前轮负外倾角应该要增加，而且后轮外倾角则应该减少，这样可以降低转向不足的风险。</p><p>正外倾角几乎很少用到，因为会降低轮胎的抓地力，而且会容易让车身反应过于灵敏。</p><p><img src="/images/BeyondTheApex/waiqingjiao.png" alt></p><p><br><br><br></p><h4 id="轮胎定位-束角"><a href="#轮胎定位-束角" class="headerlink" title="轮胎定位/束角"></a>轮胎定位/束角</h4><p>束角主要是当由上俯视轮胎时，与车辆前进方向之间所产生的夹角，束角的重要性，在于其在维持车辆稳定性方面，扮演十分吃重的角色，而且在轮胎左右对调时也将产生戏剧性的影响。</p><p>当内束角时，代表着由上方俯视车轮，车辆的方向呈现八字的状态，反之亦然，当前后轮均设定为内束角时，代表着会在转弯时造成较为明显的转向不足状态，若后轮为外束角时，代表着前轮呈现内八、后轮呈现外八字的状态，这时候则较为容易造成转向过度。<br>束角的状态与轴距、轮距、外倾角以及动力输出等因素都有关联，其中一个因素变化，都可能导致束角产生的差距，将对于车辆在过弯状态下的转向特性产生改变，所以也影响驾驶人在弯道操控的掌握程度，通常在轮胎定位时会先调整或校正正前束角，之后才决定后束角的修正状况。</p><p><img src="/images/BeyondTheApex/shujiao.png" alt></p><p><br><br><br></p><h4 id="平衡杆-增加刚性"><a href="#平衡杆-增加刚性" class="headerlink" title="平衡杆/增加刚性"></a>平衡杆/增加刚性</h4><p>平衡杆的本身就是拖拽臂结构中，连结下控制臂与左右两侧悬吊机构的部分。<br>拖拽臂本身是运用扭曲力道所造成的阻力来运作的金属杆，主要作用为降低车身晃动状态，让轮胎的胎面可以保持与路面接触面积较大的相对稳定状态，并且提升车身抗扭曲性表现，而平衡杠同样也具备安定车身反应的功能。</p><p>当调整平衡杆系数时，别让弹簧系数高于悬吊的弹性系数相对来说十分重要。<br>假如平衡杆强度愈高，悬吊弹簧会因此无法应付其所需要处理的状态，会让重量所产生的应力向轮胎外侧方向移动，导致内侧的悬吊组件举起平衡杆而丧失循跡性。<br>这当然可能在调校前后平衡杆时繁盛，但这些调整方式主要是藉由调整悬吊的弹簧系数或是阻尼系数来大城其目标，提升平衡杆的刚性当然也可能达到同样的效果，但相对来说这一部分的调校，应该是完成其他部分的调整之后，才需要在最后检视时处理的程序。</p><p><img src="/images/BeyondTheApex/pinghenggan-gangxing" alt></p><p><br><br><br></p><h3 id="驱动系统-限滑差速器"><a href="#驱动系统-限滑差速器" class="headerlink" title="驱动系统(限滑差速器)"></a>驱动系统(限滑差速器)</h3><p>初期的扭力输出，决定了限滑差速器的介入的时机，若扭力输出较大，限滑差速器就愈容易做动，而且也让弯道加速过程更容易进行，反之，扭力输出较低，限滑差速器就较不容易作动与介入。</p><p>一般而言，提升初步扭力输出能强化车辆驱动配置的特征，然而过度转向在这样的处理方式下，却更容易在高速过弯时产生，而且前轮也可能因为驱动轮扭力输出过大，而产生较为明显的转向不足现象。<br>所以初步扭力输出比例的调整，将可能影响到驾驶人希望车辆对于弯道反应的速度与幅度。</p><p>另一种调整，也可以藉由限滑差速器介入的时机与力道，来调整加速或减速时的扭力输出力道，加速设定将使得加速器与动作过程中反应更为强烈，而且驱动系统也会传送更多引擎输出的力道至驱动轮，这可以让入弯时驱动轮藉由取得更多的扭力，更容易入弯而达成提升过弯速度的能力。<br>然而，这也可能影响到驾驶人的弯道操控乐趣，因为让车辆更容易克服弯道，而降低驾驶技术对于训练弯道过弯的能力。</p><p>减速过程中对于限滑差速器的设定，也将影响到弯道中减速之后车辆的反应。限滑差速器在减速过程中作动的反应提升，将可能增加弯道减速过程中刹车系统的作用力，这可能让驾驶人在入弯时用更快的速度进入弯道，因为驾驶人可以在任何情况下对于刹车力道有更高程度的掌握，然而此设定会使过弯难度提升，虽然是适用于驾驶技术较优异之职业或半专业驾驶者，但也是解决初期转向不足的必备技术。</p><p><img src="/images/BeyondTheApex/xianhuachasuqi.png" alt></p><p><br><br><br></p><h3 id="驱动配置-齿轮比"><a href="#驱动配置-齿轮比" class="headerlink" title="驱动配置(齿轮比)"></a>驱动配置(齿轮比)</h3><ul><li><strong>利用密齿比维持动力输出</strong></li></ul><p>为了应付各种赛道状况，由于蜿蜒的赛道具备更多的弯道，也充满各种加速直线道，为了让爱车引擎可以在这样复杂状况下适应反应，改变动力系统输出的比例便显得相当重要。这通常包括改变变速系统的<em>终传比</em>愈<em>齿轮比</em>。</p><p>当驾驶在较高比例的低速加速道与弯道上时，驾驶人的焦点将放在提升出弯速度，而非提升整体行车速度。变速系统在这种情况下，必须持续地在各档位、各种速度下维持相近的齿轮比，让驾驶人可以随时掌握动力系统较高的扭力输出状态，这样的设定就被称为<strong>密齿比</strong>。<br>另一方面，若是驾驶在直线加速道比例较高的赛道上，就需要针对五档或六档来提升高速反应，即所谓较疏的齿轮比设定。</p><p>最高档位的齿轮比会决定变速系统的做动方式，假设最高档位齿轮比被提升，这将提升车辆的最终速度时所具备的加速力道，当开始调整齿比时，应该调整的是最高档位的终传比，这样才能让车辆在直线加速道时，于最高档位获得较高比例的动力输出以提升最终速度。</p><p><img src="/images/BeyondTheApex/chilunbi-1.png" alt></p><p><img src="/images/BeyondTheApex/chilunbi-2.png" alt></p><p><br><br><br></p><h3 id="空力效应-下压力"><a href="#空力效应-下压力" class="headerlink" title="空力效应(下压力)"></a>空力效应(下压力)</h3><ul><li><strong>提升高速反应</strong></li></ul><p>当实行高速驾驶时，驾驶不可忽视气流对于车身产生的影响程度，空力效应主要对于车身造成二种影响：<em>空气阻力将限制车辆的速度</em>， <em>另外也可能在高速时抬升车身，进而影响到车辆行驶的速度</em>。所以维持空力效应的均衡，将让车辆在高速行驶时更为顺利而且稳定。</p><p>此外，在高速行驶时所谓的下压力，也对于车辆行驶的稳定性造成相当重要的影响。下压力提升可以让车辆在高速行驶的情况下，提升车轮与地面接触的面积，也有利于提升车辆各轮的循跡性与稳定性。<br>尽管下压力可能压制最终速度，但是在高速过弯时却有助提升车辆的动态稳定性，所以减少下压力，会降低车辆过弯的速度，但却可以容许车辆在直线高速道时维持较快的车速。<br>下压力也可能受到赛道路线形状的影响，但若出现在起步时却不见得有利于车辆加速。最理想的状态，是提供车辆在不同的行驶状态下可以提供当时最适切的下压气流力道，在小排量动力的车辆上，通常藉由降低下压力来提升最终速度。</p><p>利用车身前后不同的下压力改变，可以用来提升车辆高速过弯时的操控表现，提升车身前端的下压力将增加车轮的抓地力，并且提升转向过度特性，相反地增加车身后半部的下压力，将较容易导致转向不足。各种不同的调整，将让车辆在高速赛道中拥有不同的反应特性。</p><p><img src="/images/BeyondTheApex/kongqixiaoying-xiayali.png" alt></p><p><br><br><br><br><br></p><h2 id="依照目的状况进行设定"><a href="#依照目的状况进行设定" class="headerlink" title="依照目的状况进行设定"></a>依照目的状况进行设定</h2><p>针对特性的赛道或路况进行跳帧，其实是为了替身整体驾驶技巧，以及对于车辆各种状况下反应的掌握。反应速度较快的悬吊与驱动模式，将可以让车辆在赛道上产生令人难以想象的改变。</p><p><br></p><h3 id="高速赛道"><a href="#高速赛道" class="headerlink" title="高速赛道"></a>高速赛道</h3><ul><li><strong>提升极速</strong></li></ul><p>在高速赛道上，理想的车辆设定，将让赛车可以在高速弯道中维持较高的行驶速度。悬吊系统避震器必须较为强固，而且保持车身高度较低。然而，若车身高度太低，则也会影响到悬吊弹簧的作动效率，悬吊系统会难以吸收车轮与地面接触所传处的震动，减低悬吊系统原本带给车辆的优点。</p><p>若使用较为硬的悬吊设定，降低防倾杆的刚性表现，将会让轮胎因为车身小幅度的滚动效应而提升抓地力，但另外一方面，若使用较软的悬吊设定，在崎岖不平的路面上，悬吊系统与避震器也会有较大的作来吸收来自路面的震动，这是因为平衡杆可以补偿悬吊系统弹簧能力的不足。当然，轮胎定位也十分重要，提升后轮的束角，也是提升车身稳定性的方法。当驾驶在高速赛道上，降低车辆在全力刹车时对于悬吊系统与避震器的负担，却也同样重要，因为这样可以维持车辆的反应与结构耐久程度。<br>至于变速系统的齿轮比，其调校也是为了同样的目的：维持车辆动力系统，在较宽阔的高扭力输出范围，以提供随时都可以拥有强大的加速力道，藉由调整最终传比的设定，也可以让车辆及时在最高档位具备较强的扭力输出表现，当然提升下压力，也可以提升车辆在高速行驶时的稳定性，进而在高速赛道上追求更高的行驶速度，但必须避免在弯道与刹车时丧失稳定性。</p><p><br></p><ul><li><strong>建议悬吊设定</strong><br>依照车辆特性不同亦有可能有所差异。</li></ul><p><img src="/images/BeyondTheApex/jianyi-xuandiao.png" alt></p><p><br><br><br></p><h3 id="技术赛道"><a href="#技术赛道" class="headerlink" title="技术赛道"></a>技术赛道</h3><ul><li><strong>让动力更有效率地传达至路面</strong></li></ul><p>所谓技术型赛道，通常代表着赛道上不满高难度的玩到，所以调校的目标将是让车身反应更为灵敏，而且让车辆在弯道时因为传输所丧失的动力比例降到最低，首先针对赛道状况设定适当的车身高度相当重要，当然也必须维持最佳的贴地性，但同时又必须考量悬吊系统与避震器，可以在任何状况下动作良好。</p><p>在这样的情况下，若是后轮驱动车辆，建议前轮弹簧应该调软，后轴弹簧应该调硬，以提升车辆过弯性能，另外在轮胎定位的部分，前路你应该增加束角角度，这样可以提升驾驶掌握车辆入弯时的反应，但也必须注意到车辆在过顶点后出弯的车身反应，负外倾角也可以适当地运用，但也同时必须考量到弯道行车与刹车时车辆的循跡性。<br>变速系统应该提供较为紧密的齿轮比，让车辆随时可以维持较高的扭力输出，而且终传比例应该调低。<br>若引擎调校的宜，那应该维持各种转速领域下可以输出的最大扭力，以便于车辆在各种状况下都可以获得最大的加速力道，空力效应中的下压力，作用于前后轴都应该维持在较强大的状况，已提供车辆在连续过弯之后拥有较佳的稳定性。</p><p><br></p><ul><li><strong>建议悬吊设定</strong></li></ul><p><img src="/images/BeyondTheApex/jianyi-xuandiao-2.png" alt></p><p><br><br><br></p><h3 id="转向不足之对策"><a href="#转向不足之对策" class="headerlink" title="转向不足之对策"></a>转向不足之对策</h3><ul><li><strong>了解为何车辆无法转弯</strong></li></ul><p>一开始为了定义何时开始出现转向不足，车辆何时开始转弯、靠近顶点，或是何时开始加速出弯都是关键。</p><p>假设转向不足在车辆入弯时发生，前轮抓地力必须尽可能增加。这可能藉由调软前轴悬吊弹簧以及增加避震器内部的延伸量，以及减少对弹簧的压缩量来增加对于轮胎的负载量，进而达成提升前轮抓地力的目标。<br>各项与悬吊系统相关的变数，包含限滑差速器也同样可以让车辆，在这一个阶段出现转向不足，降低限滑差速器锁定的比例，或是限缩的扭力输出比例，也可予以纠正。<br>如果是FR车辆使用双向限滑差速器（系统会视驾驶人踩踏油门踏板与否决定限缩输出比例），试着在车辆减速时，使用单向凡是控制限滑差速器。在车辆高速过弯时，提升前轴的下压力提升前轮抓地力，也可以达成同样的效果。<br>若转向不足发生于车辆接近顶点，应该予以负增加外倾角，让前轮确认可在此时增加对于地面的抓地力，或是降低后轮束角也可以协助平衡前后轮的抓地力提升前轮距同样也可能达成效果。<br>若转向不足发生于后轮驱动车准备加速出弯时，降低前轴车身高度则可以抵销其作用力，或是提升悬吊阻尼系数，促使避震器提升前轴行程，或压缩避震器行程也可以达成，若发生在FF前置引擎前轮驱动车上，提升限滑差速器的作用效果也同样可以解决此问题。</p><p><br></p><ul><li><strong>建议悬吊设定</strong></li></ul><p><img src="/images/BeyondTheApex/jianyi-xuandiao-3.png" alt></p><p><br><br><br></p><h3 id="转向过度之对策"><a href="#转向过度之对策" class="headerlink" title="转向过度之对策"></a>转向过度之对策</h3><ul><li><strong>后轮驱动车固有的麻烦</strong></li></ul><p>FF车与四驱车很少苦于转向过度。这个问题几乎否发生在后轮驱动车上。</p><p>如果以甩尾驾驶为主并注重操控性，前后轴的悬吊系统都必须强化到足以控制因为转向过度导致的偏滑或可能失控，然而在小场地的竞赛中，则需要计算维持循跡性的各项因素，才能顺利地让车辆前进。<br>大部分发生转向过度的原因是因为后驱车，在加速过程中发生了后轮失去循跡性的状况，这将让传输的动力浪费在加速过程中发生的车辆打滑现象。<br>弹簧与阻尼系数也可以藉由调校以降低转向过度，后悬吊应该调软，而避震器的阻尼系数应该降低压缩比例，并且提升延展性，这同样可以降低后平衡杆的刚性，增加转向内侧车轮往往行进方向移动。若可能的话，增加后轮距也是个方法。若前悬吊过软的话，后轴的负重比例可能向前移动，所以前悬吊应该强化来提升后轮的抓地力。<br>若车辆皮质后扰流，可增加其角度，以提升车身后半部的下压力效应，但这也同时表示车辆可能必须牺牲最高车速。</p><p><br></p><ul><li><strong>建议悬吊设定</strong></li></ul><p><img src="/images/BeyondTheApex/jianyi-xuandiao-4.png" alt></p><p><br><br><br></p><h3 id="湿滑路况"><a href="#湿滑路况" class="headerlink" title="湿滑路况"></a>湿滑路况</h3><ul><li><strong>重视轮胎表现</strong></li></ul><p>就像你可以想象的，在雨天时道路的摩擦力都已经降低了，当然轮胎的抓地力也会大受影响。在此就来看看有哪些设定在这样的路况下必须改变，让车辆可以充分地在湿滑路况发挥作用。<br>包括弹簧系数、下压力与平衡杆的强度，都应该尽可能在干燥时事先降低，在部分的情况下，后平衡杆还必须完全拆除。过硬的悬吊可能让车辆更不容易掌握抓地力，当路况相当湿滑，车辆不容易维持抓地力时，悬吊设定愈软愈好。<br>外倾角应该在还处于干燥的情况下略为增加，确定轮胎在路面湿滑的情况下，无论是加速或减速时都可以维持与路面最大的接触面积，当然车辆的空力套件也必须予以调整，前后下压力都应该增加，以尽可能地提升前后轮的抓地力。<br>另外要降低气候对于汽车的负面影响，还有一个方法就是调整轮胎，若在大雨的情况下提升轮胎的负载，可以提升车轮的抓地力，相反的在雨小时，降低轮胎可以提升性能表现，随时注意并且调整前后胎压，在面对湿滑路面或大小雨气候时，都是调校过程中的优先考量。<br>若可能提升动力调校的话，应该重视的是中低回转域的扭力输出表现，而非一味追求高速表现，而仰赖电子辅助系统的协助，在恶劣的湿滑路况下，更容易发现电子控制刹车系统的效果。</p><p><br></p><ul><li><strong>建议悬吊设定</strong></li></ul><p><img src="/images/BeyondTheApex/jianyi-xuandiao-5.png" alt></p><p><br><br><br></p><h3 id="砂砾路面"><a href="#砂砾路面" class="headerlink" title="砂砾路面"></a>砂砾路面</h3><ul><li><strong>增加控制</strong></li></ul><p>当车辆必须在砂砾路面行驶时，针对车辆各部分的调校应该赋予最大的弹性，因为在这类路面上有太多难以预料的变化。可能在环境细微的变化，都必须针对车辆进行些许的调整，才能够让车辆顺利脱困并且降低应付路况所浪费的动力输出比例。</p><p>此外，在车辆加速的过程中，可能因此又随时改变了车轮与地面的抓地力，进而影响到循跡性，这也是砂砾路面随时可能变化的原因之一，所以对于车辆的调校与改变各项设定，在行驶砂砾路面时尤其重要。<br>针对砂砾路面进行的调校中，必须注意的另外一个重点是当松开油门踏板之后，车辆所产生的反应，包括所产生的各种转向特性，这有被称为转向过度的调校，主要是为了要控制加速时的转向特性，这可能藉由使用双向限滑差速器或是调整前后刹车力道的均衡来达成。<br>转向不足或过度同样可能发生在砂砾路面或柏油路面上，车身高度调整要视路面情况而定，尽管降低有其益处，但必须考量到在这类砂砾路面上，降低车身高度，会对底盘相关零件与结构造成的危机与损伤，当然在这样多变的情况下，车身空力效应依旧扮演重要角色，引擎的调校重点并不在于最高输出，而是可以在各种情况下保持最佳反应。</p><p><br></p><ul><li><strong>建议悬吊设定</strong></li></ul><p><img src="/images/BeyondTheApex/jianyi-xuandiao-6.png" alt></p><p><br><br><br></p><p>—</p><p><br><br><br></p><h1 id="赛道"><a href="#赛道" class="headerlink" title="赛道"></a>赛道</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GT赛车 《Beyond The Apex》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Automotive" scheme="https://zhang21.github.io/categories/Automotive/"/>
    
    
      <category term="PS4" scheme="https://zhang21.github.io/tags/PS4/"/>
    
      <category term="PlayStation" scheme="https://zhang21.github.io/tags/PlayStation/"/>
    
      <category term="Game" scheme="https://zhang21.github.io/tags/Game/"/>
    
      <category term="Automotive" scheme="https://zhang21.github.io/tags/Automotive/"/>
    
      <category term="GTSport" scheme="https://zhang21.github.io/tags/GTSport/"/>
    
  </entry>
  
  <entry>
    <title>Kong</title>
    <link href="https://zhang21.github.io/2019/05/08/Kong/"/>
    <id>https://zhang21.github.io/2019/05/08/Kong/</id>
    <published>2019-05-07T18:44:31.000Z</published>
    <updated>2019-06-24T10:00:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li>Kong GitHub: <a href="https://github.com/Kong/kong" target="_blank" rel="noopener">https://github.com/Kong/kong</a></li><li>Kong Docs: <a href="https://docs.konghq.com/" target="_blank" rel="noopener">https://docs.konghq.com/</a></li></ul><p><br></p><p>环境：</p><ul><li>ELRH7x86_64</li><li>Kong v1.2</li><li>Docker CE v18.09</li><li>K8s v1.11</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>GETTING STARTED</p><p><img src="/images/Kong/kongLogo.png" alt></p><p>Kong是一个可扩展的开源<strong>API Layer</strong>（也称为<strong>API Gateway</strong>或<strong>API Middleware</strong>）。Kong运行在任何RESTful API之前，并通过<strong>插件(plugin)</strong>进行扩展。</p><p>Kong的优点：</p><ul><li><strong>Scalable</strong>：只需添加更多机器便可轻易扩展，这意味着你的平台可以处理任何负载，同时保持低延迟；</li><li><strong>Modular</strong>：可以通过添加新的插件来扩展Kong，这些插件可通过RESTful API配置；</li><li><strong>Runs on any infrastructure</strong>：Kong可以运行在任何地方。</li></ul><p>Kong建立在N影响和Apache Cassandra或PostgreSQL等可靠技术之上，为你提供易于使用的RESTful API来操作和配置系统。</p><p><img src="/images/Kong/kong-architecture.jpg" alt></p><p><br></p><p>下图是一个使用Kong请求API的典型工作流程。<br>一旦Kong运行，对API的所有请求都将首先到达Kong，然后代理到最终的API。在请求和相应之间，Kong将执行你决定安装的任何插件，为你的API提供支持。Kong有效地成为每个API请求的入口点。</p><p><img src="/images/Kong/kong-simple.png" alt></p><p><br><br><br></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://docs.konghq.com/1.1.x/getting-started/introduction/" target="_blank" rel="noopener">Introduction</a></p><p>你可能听过Kong是建立在Nginx之上的，它利用它的稳定性和效率。<br>更确切地说，Kong是一个在Nginx中运行的Lua Application，并且可通过<code>lua-nginx-module</code>模块实现。Kong不是用这个模块编译Nginx，而是与<strong>OpenResty</strong>一起发布，OpenResty以及包含了<code>lua-nginx-module</code>模块。OpenResty不是Nginx的分支(fork)，而是一组扩展其功能的模块。</p><p>这位可插拔架构(pluggable architecture)奠定了基础，在运行时启动并执行Lua scripts(plugins)。因此，我们认为Kong是微服务架构的典范，它的核心是实现<strong>数据库抽象(database abstraction)</strong>、<strong>路由(routing)</strong>和<strong>插件管理(plugin management)</strong>。插件可以存在于单独的代码中，并可以在几行代码中诸如到请求生命周期的任何位置。</p><p><br><br><br><br><br></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p><a href="https://docs.konghq.com/1.1.x/getting-started/quickstart/" target="_blank" rel="noopener">Quickstart</a></p><p>在本章中，你讲学习如何管理Kong实例。首先，你将启动Kong，以便可访问RESTful Admin Interface，通过该界面管理服务(service)、路由(route)、消费者(consumer)…通过Admin API发送的数据存储在Kong的数据存储区中(PostgreSQL后Cassandra)。</p><p><br><br><br></p><h3 id="启动Kong"><a href="#启动Kong" class="headerlink" title="启动Kong"></a>启动Kong</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行kong migrations命令来准备数据存储</span></span><br><span class="line">kong migrations bootstrap [-c /path/to/kong.conf]</span><br><span class="line"><span class="comment"># 你应该看到Kong已成功迁移的消息。否则，你可能在配置文件中错误的配置了数据库连接。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里把默认配置文件中的postgre注释取消就好</span></span><br><span class="line">cp /etc/kong/kong.conf.default kong.conf</span><br><span class="line">vim kong.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可指定配置项</span></span><br><span class="line">kong start [-c /path/to/kong.conf]</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="验证Kong"><a href="#验证Kong" class="headerlink" title="验证Kong"></a>验证Kong</h3><p>如果一切顺利，你应该看到一条消息通知你Kong正在运行。</p><p>默认情况下，Kong监听以下端口：</p><ul><li><strong>8000</strong>：监听来自Client的传入流量，并将其转发到上游服务</li><li><strong>8443</strong>：与8000端口类似，它监听HTTPS流量</li><li><strong>8001</strong>：Admin API用于配置Kong监听</li><li><strong>8444</strong>：Admin API监听HTTPS流量</li></ul><p><br><br><br></p><h3 id="停止和重载"><a href="#停止和重载" class="headerlink" title="停止和重载"></a>停止和重载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kong stop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在不停机的情况下重新加载Kong</span></span><br><span class="line">kong reload</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h2><p><a href="https://docs.konghq.com/1.1.x/getting-started/configuring-a-service/" target="_blank" rel="noopener">Configuring a Service</a></p><p>在本章中，你将向Kong添加API。为此，你首先需要添加一个<strong>服务（Service）</strong>，这就是Kong又来指代它管理的上游API和微服务的名称。</p><p>出于测试的目的，将创建一个指向Mockbin API（返回请求作为响应）的服务。这有助于了解Kong如何代理你的API请求。</p><p>在开始向服务发出请求之前，你需要为其添加<strong>路由（Route）</strong>。路由指定请求在到达Kong后如何（以及是否）发送到服务。单个服务可以有多个路由。</p><p>在配置了服务和路由之后，你能够通过Kong使用它们发出请求。</p><p>Kong在端口<code>8001</code>上公开RESTful Admin API。Kong的配置（包括添加服务和路由），是通过该API的请求进行的。</p><p><br><br><br></p><h3 id="添加服务"><a href="#添加服务" class="headerlink" title="添加服务"></a>添加服务</h3><p>Add your Service using the Admin API</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发出以下cURL请求，将服务添加到Kong</span></span><br><span class="line">curl -i -X POST \</span><br><span class="line">  --url http://localhost:8001/services/ \</span><br><span class="line">  --data <span class="string">'name=example-service'</span> \</span><br><span class="line">  --data <span class="string">'url=http://mockbin.org'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你应该收到类似的响应</span></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"host"</span>:<span class="string">"mockbin.org"</span>,</span><br><span class="line">   <span class="string">"created_at"</span>:1519130509,</span><br><span class="line">   <span class="string">"connect_timeout"</span>:60000,</span><br><span class="line">   <span class="string">"id"</span>:<span class="string">"92956672-f5ea-4e9a-b096-667bf55bc40c"</span>,</span><br><span class="line">   <span class="string">"protocol"</span>:<span class="string">"http"</span>,</span><br><span class="line">   <span class="string">"name"</span>:<span class="string">"example-service"</span>,</span><br><span class="line">   <span class="string">"read_timeout"</span>:60000,</span><br><span class="line">   <span class="string">"port"</span>:80,</span><br><span class="line">   <span class="string">"path"</span>:null,</span><br><span class="line">   <span class="string">"updated_at"</span>:1519130509,</span><br><span class="line">   <span class="string">"retries"</span>:5,</span><br><span class="line">   <span class="string">"write_timeout"</span>:60000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="为服务添加路由"><a href="#为服务添加路由" class="headerlink" title="为服务添加路由"></a>为服务添加路由</h3><p>Add a Route for the Service</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST \</span><br><span class="line">  --url http://localhost:8001/services/example-service/routes \</span><br><span class="line">  --data <span class="string">'hosts[]=example.com'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似的响应</span></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"created_at"</span>:1519131139,</span><br><span class="line">   <span class="string">"strip_path"</span>:<span class="literal">true</span>,</span><br><span class="line">   <span class="string">"hosts"</span>:[</span><br><span class="line">      <span class="string">"example.com"</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="string">"preserve_host"</span>:<span class="literal">false</span>,</span><br><span class="line">   <span class="string">"regex_priority"</span>:0,</span><br><span class="line">   <span class="string">"updated_at"</span>:1519131139,</span><br><span class="line">   <span class="string">"paths"</span>:null,</span><br><span class="line">   <span class="string">"service"</span>:&#123;</span><br><span class="line">      <span class="string">"id"</span>:<span class="string">"79d7ee6e-9fc7-4b95-aa3b-61d2e17e7516"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"methods"</span>:null,</span><br><span class="line">   <span class="string">"protocols"</span>:[</span><br><span class="line">      <span class="string">"http"</span>,</span><br><span class="line">      <span class="string">"https"</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="string">"id"</span>:<span class="string">"f9ce2ed7-c06e-4e16-bd5d-3a82daef3f9d"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kong现在知道你的服务并准备代理请求。</p><p><br><br><br></p><h3 id="转发请求"><a href="#转发请求" class="headerlink" title="转发请求"></a>转发请求</h3><p>Forward your requests through Kong</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发出一下cURL请求来验证Kong是否正确地将请求转发给服务</span></span><br><span class="line"><span class="comment"># 默认情况下，Kong在8000端口上处理代理请求</span></span><br><span class="line">curl -i -X GET \</span><br><span class="line">  --url http://localhost:8000/ \</span><br><span class="line">  --header <span class="string">'Host: example.com'</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="启用插件"><a href="#启用插件" class="headerlink" title="启用插件"></a>启用插件</h2><p><a href="https://docs.konghq.com/1.1.x/getting-started/enabling-plugins/" target="_blank" rel="noopener">Enabling Plugins</a></p><p>在本章中，你将学习如何配置Kong<strong>插件（Plugins）</strong>。Kong的核心原则之一是它通过插件的可扩展性。插件允许你轻松地向服务添加新功能或使其更易于管理。</p><p>下面的栗子中，将配置<code>key-auth</code>插件以向服务添加身份认证。</p><p><br><br><br></p><h3 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h3><p>Configure the key-auth plugin</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插件配置栗子</span></span><br><span class="line">curl -i -X POST \</span><br><span class="line">  --url http://localhost:8001/services/example-service/plugins/ \</span><br><span class="line">  --data <span class="string">'name=key-auth'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="验证插件"><a href="#验证插件" class="headerlink" title="验证插件"></a>验证插件</h3><p>Verify that the plugin is properly configured</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X GET \</span><br><span class="line">  --url http://localhost:8000/ \</span><br><span class="line">  --header <span class="string">'Host: example.com'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于未指定key，因此响应为 401 Unauthorized</span></span><br><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"message"</span>: <span class="string">"No API key found in request"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="添加消费者"><a href="#添加消费者" class="headerlink" title="添加消费者"></a>添加消费者</h2><p><a href="https://docs.konghq.com/1.1.x/getting-started/adding-consumers/" target="_blank" rel="noopener">Adding Consumers</a></p><p>在本章中，将介绍将<strong>消费者（Consumer）</strong>添加到Kong实例中。消费者与使用服务的个人相关联，并可用于追踪，访问管理等。</p><p><br></p><h3 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h3><p>Create a Consumer through the RESTful API</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为Jason的用户</span></span><br><span class="line"><span class="comment"># Kong还接受custom_id参数</span></span><br><span class="line">curl -i -X POST \</span><br><span class="line">  --url http://localhost:8001/consumers/ \</span><br><span class="line">  --data <span class="string">"username=Jason"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似响应</span></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"username"</span>: <span class="string">"Jason"</span>,</span><br><span class="line">  <span class="string">"created_at"</span>: 1428555626000,</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"bbdf1c48-19dc-4ab7-cae0-ff4f59d87dc9"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="为消费者提供key"><a href="#为消费者提供key" class="headerlink" title="为消费者提供key"></a>为消费者提供key</h3><p>Provision key credentials for your Consumer</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为消费者创建密钥</span></span><br><span class="line">curl -i -X POST \</span><br><span class="line">  --url http://localhost:8001/consumers/Jason/key-auth/ \</span><br><span class="line">  --data <span class="string">'key=ENTER_KEY_HERE'</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="验证消费者凭证"><a href="#验证消费者凭证" class="headerlink" title="验证消费者凭证"></a>验证消费者凭证</h3><p> Verify that your Consumer credentials are valid</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发出请求来验证凭据是否有效</span></span><br><span class="line">curl -i -X GET \</span><br><span class="line">  --url http://localhost:8000 \</span><br><span class="line">  --header <span class="string">"Host: example.com"</span> \</span><br><span class="line">  --header <span class="string">"apikey: ENTER_KEY_HERE"</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://konghq.com/install/" target="_blank" rel="noopener">install</a></p><p>Kong可以运行在多个环境中。</p><p><br><br><br></p><h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><p><a href="https://docs.konghq.com/install/centos/" target="_blank" rel="noopener">CentOS Installation</a></p><ul><li><strong>安装Kong</strong></li></ul><p>安装方式：</p><ul><li>yum repo</li><li>packages</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># repo</span></span><br><span class="line">wget https://bintray.com/kong/kong-rpm/rpm -O bintray-kong-kong-rpm.repo</span><br><span class="line"><span class="built_in">export</span> major_version=`grep -oE <span class="string">'[0-9]+\.[0-9]+'</span> /etc/redhat-release | cut -d <span class="string">"."</span> -f1`</span><br><span class="line">sed -i -e <span class="string">'s/baseurl.*/&amp;\/centos\/'</span><span class="variable">$major_version</span><span class="string">''</span>/ bintray-kong-kong-rpm.repo</span><br><span class="line">sudo mv bintray-kong-kong-rpm.repo /etc/yum.repos.d/</span><br><span class="line">sudo yum install -y kong</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>准备数据库</strong></li></ul><p>Kong支持PostgreSQL v9.5+和Cassandra 3.x.x作为数据存储。</p><p>此处我按照文档安装PostgreSQL v11: <a href="https://www.postgresql.org/download/linux/redhat/" target="_blank" rel="noopener">https://www.postgresql.org/download/linux/redhat/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装PostgreSQL v11</span></span><br><span class="line">sudo yum install -y https://download.postgresql.org/pub/repos/yum/11/redhat/rhel-7-x86_64/pgdg-centos11-11-2.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo yum install -y postgresql11</span><br><span class="line"></span><br><span class="line">sudo yum install -y postgresql11-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自启</span></span><br><span class="line">/usr/pgsql-11/bin/postgresql-11-setup initdb</span><br><span class="line">systemctl <span class="built_in">enable</span> postgresql-11</span><br><span class="line">systemctl start postgresql-11</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># 登录psql</span><br><span class="line">sudo su postgres</span><br><span class="line">psql</span><br><span class="line"></span><br><span class="line"># 创建数据库，官方默认无密码，此处我使用密码</span><br><span class="line"># CREATE USER kong; CREATE DATABASE kong OWNER kong;</span><br><span class="line">CREATE USER kong with password &apos;kong&apos;; CREATE DATABASE kong OWNER kong; grant all privileges on database kong to kong;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 这里可能会报连接错误</span><br><span class="line"># psql: 致命错误:  对用户&quot;kong&quot;的对等认证失败</span><br><span class="line">sudo find / -name pg_hba.conf</span><br><span class="line">/var/lib/pgsql/11/data/pg_hba.conf</span><br><span class="line"></span><br><span class="line"># 修改安全配置</span><br><span class="line">vim /var/lib/pgsql/11/data/pg_hba.conf</span><br><span class="line"></span><br><span class="line"># METHOD指定如何处理客户端的认证。常用的有ident，md5，password，trust，reject</span><br><span class="line"># ident是Linux下PostgreSQL默认的local认证方式，凡是能正确登录服务器的操作系统用户（注：不是数据库用户）就能使用本用户映射的数据库用户不需密码登录数据库。</span><br><span class="line"># md5是常用的密码认证方式，如果你不使用ident，最好使用md5。密码是以md5形式传送给数据库，较安全，且不需建立同名的操作系统用户。</span><br><span class="line"># password是以明文密码传送给数据库，建议不要在生产环境中使用。</span><br><span class="line"># trust是只要知道数据库用户名就不需要密码或ident就能登录，建议不要在生产环境中使用。</span><br><span class="line"># reject是拒绝认证。</span><br><span class="line"></span><br><span class="line"># &quot;local&quot; is for Unix domain socket connections only</span><br><span class="line">local   all             all                                     peer</span><br><span class="line"># IPv4 local connections:</span><br><span class="line">host    all             all             127.0.0.1/32            ident</span><br><span class="line"># IPv6 local connections:</span><br><span class="line">host    all             all             ::1/128                 ident</span><br><span class="line"></span><br><span class="line"># 将peer改为md5（）</span><br><span class="line"># &quot;local&quot; is for Unix domain socket connections only</span><br><span class="line">local   all             all                                     md5</span><br><span class="line"># IPv4 local connections:</span><br><span class="line">host    all             all             127.0.0.1/32            ident</span><br><span class="line"># IPv6 local connections:</span><br><span class="line">host    all             all             ::1/128                 ident</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 重启psql</span><br><span class="line">systemctl restart postgresql-11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 登录postgre</span><br><span class="line">psql -U kong</span><br><span class="line"># 输入密码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看帮助</span><br><span class="line">\h</span><br><span class="line"></span><br><span class="line"># 退出</span><br><span class="line">\q</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里需要提前配置kong配置文件，默认/etc/kong/kong.conf.default</span></span><br><span class="line">cp /etc/kong/kong.conf.default /etc/kong/kong.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改里面的数据库配置，写入用户、密码、数据库、端口等信息</span></span><br><span class="line">vim /etc/kong/kong.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kong migrations</span></span><br><span class="line">kong migrations bootstrap [-c /path/to/kong.conf]</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>启动Kong</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong start [-c /path/to/kong.conf]</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>使用Kong</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i http://localhost:8001/</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><a href="https://docs.konghq.com/install/docker/" target="_blank" rel="noopener">Docker Installation</a></p><p>以下是一个快速示例。</p><ul><li><strong>Create a Docker network</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create kong-net</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>Start your database</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PostgreSQL</span></span><br><span class="line">docker run -d --name kong-database \</span><br><span class="line">               --network=kong-net \</span><br><span class="line">               -p 5432:5432 \</span><br><span class="line">               -e <span class="string">"POSTGRES_USER=kong"</span> \</span><br><span class="line">               -e <span class="string">"POSTGRES_DB=kong"</span> \</span><br><span class="line">               postgres:9.6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># or Cassandra</span></span><br><span class="line">docker run -d --name kong-database \</span><br><span class="line">               --network=kong-net \</span><br><span class="line">               -p 9042:9042 \</span><br><span class="line">               cassandra:3</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>Prepare your database</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">     --network=kong-net \</span><br><span class="line">     -e <span class="string">"KONG_DATABASE=postgres"</span> \</span><br><span class="line">     -e <span class="string">"KONG_PG_HOST=kong-database"</span> \</span><br><span class="line">     -e <span class="string">"KONG_CASSANDRA_CONTACT_POINTS=kong-database"</span> \</span><br><span class="line">     kong:latest kong migrations bootstrap</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>Start Kong</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kong \</span><br><span class="line">     --network=kong-net \</span><br><span class="line">     -e <span class="string">"KONG_DATABASE=postgres"</span> \</span><br><span class="line">     -e <span class="string">"KONG_PG_HOST=kong-database"</span> \</span><br><span class="line">     -e <span class="string">"KONG_CASSANDRA_CONTACT_POINTS=kong-database"</span> \</span><br><span class="line">     -e <span class="string">"KONG_PROXY_ACCESS_LOG=/dev/stdout"</span> \</span><br><span class="line">     -e <span class="string">"KONG_ADMIN_ACCESS_LOG=/dev/stdout"</span> \</span><br><span class="line">     -e <span class="string">"KONG_PROXY_ERROR_LOG=/dev/stderr"</span> \</span><br><span class="line">     -e <span class="string">"KONG_ADMIN_ERROR_LOG=/dev/stderr"</span> \</span><br><span class="line">     -e <span class="string">"KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl"</span> \</span><br><span class="line">     -p 8000:8000 \</span><br><span class="line">     -p 8443:8443 \</span><br><span class="line">     -p 8001:8001 \</span><br><span class="line">     -p 8444:8444 \</span><br><span class="line">     kong:latest</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>Use Kong</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i http://localhost:8001/</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><p><a href="https://docs.konghq.com/install/kubernetes/" target="_blank" rel="noopener">Kong on Kubernetes</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="无数据库和声明性配置"><a href="#无数据库和声明性配置" class="headerlink" title="无数据库和声明性配置"></a>无数据库和声明性配置</h1><p><a href="https://docs.konghq.com/1.1.x/db-less-and-declarative-config/" target="_blank" rel="noopener">DB-less and Declarative Configuration</a></p><p>传统上，Kong总是需要一个数据库（如PostgreSQL或Cassandra），来存储其配置的实体（如服务、路由和插件）。<br>Kong使用其配置文件（<code>kong.conf</code>）来指定各种设置。</p><p>Kong v1.1增加了在没有数据库的情况下运行Kong的能力，仅对实体使用内存存储。—— 称之为<strong>无数据库模式（DB-less mode）</strong>。当运行KOng无数据模式时，实体的配置是使用<strong>声明性配置（declarative configuration）</strong>（YAML或JSON）在第二本配置文件中完成的。</p><p>无数据库模式和声明性配置的组合具有许多优点：</p><ul><li>减少依赖的数量： 如果用例的整个设置适合内存，则无需管理数据库安装</li><li>非常适合CI/CD场景中的自动化：实体配置可以保存在通过Git Repo管理的单一源中</li><li>为Kong提供了更多的部署选项：在Service Mesh场景中非常适合轻量级Sidecar</li></ul><p><br><br><br></p><h2 id="声明性配置"><a href="#声明性配置" class="headerlink" title="声明性配置"></a>声明性配置</h2><p>What Is Declarative Configuration</p><p>正如其名称所言，声明性配置中的关键思想是陈述它是声明性（declarative）的，而不是命令式（ imperative style）配置。<br><strong>Imperative</strong>意味着配置是作为一系列顺序给出的：做这做那。<br><strong>Declarative</strong>意味着配置一次全部给出：宣布这是世界的状态。</p><p>Kong Admin API是命令式配置工具的一个栗子：配置的最终状态是通过一系列API调用获得。一个调用创建服务，一个调用创建路由，另一个调用添加插件…</p><p>像这样递增地执行具有中间状态的配置，会发生不期望的副作用。如在创建路由和添加插件之间存在时间窗口，其中路由没有应用插件。</p><p>另一方面，声明性配置文件将包含单个文件中所有所需实体的设置，并且一旦将改配置加载到Kong中，它将替换整个配置。当需要增量更改时，将对声明性配置文件进行更改，然后将其完整地重新加载。在任何时候，加载到Kong中的文件中描述的配置是系统的配置状态。</p><p><br><br><br></p><h2 id="在无数据库模式配置Kong"><a href="#在无数据库模式配置Kong" class="headerlink" title="在无数据库模式配置Kong"></a>在无数据库模式配置Kong</h2><p>Setting Up Kong in DB-less mode</p><p>要在无数据库模式下使用Kong，有两种方式：</p><ul><li>修改配置文件<code>kong.conf</code></li><li>修改环境变量<code>KONG_DATABASE</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/kong/kong.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># database = postgres</span></span><br><span class="line">database=off</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">export</span> KONG_DATABASE=off</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kong start -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><p>一旦Kong启动，访问Admin API的<code>/</code>根端点已验证它是否在没有数据库的情况下运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># httpie: &lt;https://github.com/jakubroztocil/httpie&gt;</span></span><br><span class="line">$ http :8001/</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 6342</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Date: Wed, 27 Mar 2019 15:24:58 GMT</span><br><span class="line">Server: kong/1.1.0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"configuration:"</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="string">"database"</span>: <span class="string">"off"</span>,</span><br><span class="line">       ...</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"1.1.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kong正在运行，但尚未加载声明性配置。这意味着此节点的配置为空。没有任何类型的路由、服务或实体。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># httpie</span></span><br><span class="line">http :8001/routes</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 23</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Date: Tue, 14 May 2019 06:58:37 GMT</span><br><span class="line">Server: kong/1.1.2</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"data"</span>: [],</span><br><span class="line">    <span class="string">"next"</span>: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="创建声明性配置文件"><a href="#创建声明性配置文件" class="headerlink" title="创建声明性配置文件"></a>创建声明性配置文件</h2><p>Creating a Declarative Configuration File</p><p>要将实体载入到无数据库的Kong，我们需要一个声明性配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此命令在当前目录中创建kong.yml文件</span></span><br><span class="line">kong config -c kong.conf init</span><br><span class="line"></span><br><span class="line">ls .</span><br><span class="line">kong.yml</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="声明性配置格式"><a href="#声明性配置格式" class="headerlink" title="声明性配置格式"></a>声明性配置格式</h2><p>The Declarative Configuration Format</p><p>Kong声明性配置格式由实体列表及其属性组成。</p><p>看看<code>kong.yml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># This is an example file to get you started with using</span></span><br><span class="line"><span class="comment"># declarative configuration in Kong.</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Metadata fields start with an underscore (_)</span></span><br><span class="line"><span class="comment"># Fields that do not start with an underscore represent Kong entities and attributes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># _format_version is mandatory,</span></span><br><span class="line"><span class="comment"># it specifies the minimum version of Kong that supports the format</span></span><br><span class="line"></span><br><span class="line"><span class="attr">_format_version:</span> <span class="string">"1.1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Each Kong entity (core entity or custom entity introduced by a plugin)</span></span><br><span class="line"><span class="comment"># can be listed in the top-level as an array of objects:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># services:</span></span><br><span class="line"><span class="comment"># - name: example-service</span></span><br><span class="line"><span class="comment">#   url: http://example.com</span></span><br><span class="line"><span class="comment">#   # Entities can store tags as metadata</span></span><br><span class="line"><span class="comment">#   tags:</span></span><br><span class="line"><span class="comment">#   - example</span></span><br><span class="line"><span class="comment">#   # Entities that have a foreign-key relationship can be nested:</span></span><br><span class="line"><span class="comment">#   routes:</span></span><br><span class="line"><span class="comment">#   - name: example-route</span></span><br><span class="line"><span class="comment">#     paths:</span></span><br><span class="line"><span class="comment">#     - /</span></span><br><span class="line"><span class="comment">#   plugins:</span></span><br><span class="line"><span class="comment">#   - name: key-auth</span></span><br><span class="line"><span class="comment"># - name: another-service</span></span><br><span class="line"><span class="comment">#   url: https://example.org</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># routes:</span></span><br><span class="line"><span class="comment"># - name: another-route</span></span><br><span class="line"><span class="comment">#   # Relationships can also be specified between top-level entities,</span></span><br><span class="line"><span class="comment">#   # either by name or by id</span></span><br><span class="line"><span class="comment">#   service: example-service</span></span><br><span class="line"><span class="comment">#   hosts: ["hello.com"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># consumers:</span></span><br><span class="line"><span class="comment"># - username: example-user</span></span><br><span class="line"><span class="comment">#   # Custom entities from plugin can also be specified</span></span><br><span class="line"><span class="comment">#   # If they specify a foreign-key relationshp, they can also be nested</span></span><br><span class="line"><span class="comment">#   keyauth_credentials:</span></span><br><span class="line"><span class="comment">#   - key: my-key</span></span><br><span class="line"><span class="comment">#   plugins:</span></span><br><span class="line"><span class="comment">#   - name: rate-limiting</span></span><br><span class="line"><span class="comment">#     _comment: "these are default rate-limits for user example-user"</span></span><br><span class="line"><span class="comment">#     config:</span></span><br><span class="line"><span class="comment">#       policy: local</span></span><br><span class="line"><span class="comment">#       second: 5</span></span><br><span class="line"><span class="comment">#       hour: 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When an entity has multiple foreign-key relationships</span></span><br><span class="line"><span class="comment"># (e.g. a plugin matching on both consumer and service)</span></span><br><span class="line"><span class="comment"># it must be specified as a top-level entity, and not through</span></span><br><span class="line"><span class="comment"># nesting.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># plugins:</span></span><br><span class="line"><span class="comment"># - name: rate-limiting</span></span><br><span class="line"><span class="comment">#   consumer: example-user</span></span><br><span class="line"><span class="comment">#   service: another-service</span></span><br><span class="line"><span class="comment">#   _comment: "example-user is extra limited when using another-service"</span></span><br><span class="line"><span class="comment">#   config:</span></span><br><span class="line"><span class="comment">#     hour: 2</span></span><br><span class="line"><span class="comment">#   # tags are for your organization only and have no meaning for Kong:</span></span><br><span class="line"><span class="comment">#   tags:</span></span><br><span class="line"><span class="comment">#   - extra_limits</span></span><br><span class="line"><span class="comment">#   - my_tag</span></span><br></pre></td></tr></table></figure><p>唯一必须声明的元数据是<code>_format_version</code>，它指定声明性配置语法格式的版本号。这也匹配解析文件所需的Kong的最小版本。</p><p><br><br><br></p><h2 id="检查声明性配置文件"><a href="#检查声明性配置文件" class="headerlink" title="检查声明性配置文件"></a>检查声明性配置文件</h2><p>Checking The Declarative Configuration File</p><p>编辑完文件后，可在将声明性配置文件加载到Kong之前检查任何语法错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parse &lt;file&gt;，Parse a declarative config file (check its syntax) but do not load it into Kong.</span></span><br><span class="line"><span class="comment"># kong config -c kong.conf parse kong.yml</span></span><br><span class="line">kong config parse kong.yml</span><br><span class="line"></span><br><span class="line">parse successful</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="加载声明性配置文件"><a href="#加载声明性配置文件" class="headerlink" title="加载声明性配置文件"></a>加载声明性配置文件</h2><p>Loading The Declarative Configuration File</p><p>有两种方式可将声明性配置文件加载到Kong：</p><ul><li>通过<code>kong.conf</code></li><li>通过Admin API</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kong.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改环境变量</span></span><br><span class="line"><span class="built_in">export</span> KONG_DATABASE=off</span><br><span class="line"><span class="built_in">export</span> KONG_DECLARATIVE_CONFIG=kong.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或修改配置文件</span></span><br><span class="line">database=off</span><br><span class="line">declarative_config=kong.yml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kong start -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用/根端点通过其Admin API将声明性配置加载在正在运行的Kong节点中</span></span><br><span class="line"><span class="comment"># 栗子使用httpie加载kong.yml</span></span><br><span class="line">http :8001/config config=@kong.yml</span><br><span class="line"></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 2</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Date: Tue, 14 May 2019 06:59:57 GMT</span><br><span class="line">Server: kong/1.1.2</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="在无数据库模式下使用Kong"><a href="#在无数据库模式下使用Kong" class="headerlink" title="在无数据库模式下使用Kong"></a>在无数据库模式下使用Kong</h2><p>Using Kong in DB-less Mode</p><p>在无数据库模式下使用Kong时，有许多事项需要注意。</p><p><br></p><h3 id="内存缓存要求"><a href="#内存缓存要求" class="headerlink" title="内存缓存要求"></a>内存缓存要求</h3><p>Memory Cache Requirements</p><p>实体的整个配置必须适合Kong Cache。确保正确配置了内存缓存（memory cache）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">'mem_cache_size'</span> /etc/kong/kong.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#mem_cache_size = 128m</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="只读Admin-API"><a href="#只读Admin-API" class="headerlink" title="只读Admin API"></a>只读Admin API</h3><p>Read-Only Admin API</p><p>由于配置实体的唯一方法是通过声明性配置文件，因此在无数据库模式下运行Kong时，实体上的CRUD操作的端点在Admin API中实际上是只读的。<code>GET</code>操作正常工作，但在端点(/services, /plugins…)中<code>POST, PATCH, PUT, DELETE</code>将返回<code>HTTP 405 Not Allowed</code>。</p><p>此限制仅限于数据库操作。特别是，仍然启用<code>POST</code>来设置目标的运行状态，因为这是特定节点的内存中的操作。</p><p><br><br><br></p><h3 id="插件兼容性"><a href="#插件兼容性" class="headerlink" title="插件兼容性"></a>插件兼容性</h3><p>Plugin Compatibility</p><p>并非所有的Kong插件斗鱼无数据库模式兼容。因为其中一些插件需要中央数据库协调或动态创建实体。</p><p><br></p><p><strong>完全兼容（Fully Compatible）</strong><br>以下插件只从数据库中读取（大多是读取初始配置），因此与无数据库模式完全兼容。</p><ul><li><code>aws-lambda</code></li><li><code>azure-functions</code></li><li><code>bot-detection</code></li><li><code>correlation-id</code></li><li><code>cors</code></li><li><code>datadog</code></li><li><code>file-log</code></li><li><code>http-log</code></li><li><code>tcp-log</code></li><li><code>udp-log</code></li><li><code>syslog</code></li><li><code>ip-restriction</code></li><li><code>prometheus</code></li><li><code>zipkin</code></li><li><code>request-transformer</code></li><li><code>response-transformer</code></li><li><code>request-termination</code></li><li><code>kubernetes-sidecar-injector</code></li></ul><p><br></p><p><strong>部分兼容（Partial Compatibility）</strong><br>只要使用的凭证集是静态的并且指定为声明性配置的一部分，就可以使用认证插件。在无数据库模式下，无法使用Admin API端点来动态创建、更新或删除凭据。属于此类的插件有：</p><ul><li><code>acl</code></li><li><code>basic-auth</code></li><li><code>hmac-auth</code></li><li><code>jwt</code></li><li><code>key-auth</code></li></ul><p>与Kong捆绑在一起的速率限制插件提供了不同的策略来存储可协调计数器：</p><ul><li><code>Local</code>策略：用于存储计数器节点的内存，以每个节点的方式应用限制；</li><li><code>Redis</code>策略：使用Redis作为外部键值存储来协调跨节点的计数器；</li><li><code>Cluster</code>策略：使用Kong数据库作为集群范围限制的中心协调点。</li></ul><p>在无数据库模式下，Local和Redis策略可用，无法使用Cluster策略。属于此类的插件有：</p><ul><li><code>rate-limiting</code></li><li><code>response-ratelimiting</code></li></ul><p>无服务器（serverless）的<code>pre-function</code>和<code>post-function</code>可在无数据库模式下使用。但需注意，如果任何已配置的功能尝试写入数据库，则写入将失败。</p><p><br></p><p><strong>不兼容（Not Compatible）</strong></p><ul><li><code>oauth2</code>：对于常规工作，插件需生成和删除token，并将这些更改提交到数据库</li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="流和服务网格"><a href="#流和服务网格" class="headerlink" title="流和服务网格"></a>流和服务网格</h1><p><a href="https://docs.konghq.com/1.1.x/streams-and-service-mesh/" target="_blank" rel="noopener">Streams and Service Mesh</a></p><p>Kong v1.0.0增加了代理(proxy)和路由(route)原始TCP和TLS流(stream)的能力，并使用service-mesh sidecar和在Kong节点之间交互TLS来部署Kong。<br>本章将介绍使用简单工具简化Service Mesh部署的基本设置： 两台服务器，通过两个Kong节点在一台主机中互相通信。如果你有兴趣使用k8s运行Service Mesh，请查看<a href="https://github.com/Kong/kong-mesh-dist-kubernetes" target="_blank" rel="noopener">Kubernetes and Service Mesh example</a></p><p>Kong支持逐步部署sidecar。它即可以作为传统网关，也可作为服务网格节点同时工作。在Kong中，服务网格是动态构建的，只有在Kong节点之间存在活动连接时才存在。简而言之，这意味着Kong节点不必了解其它Kong节点，服务也不必了解Kong。</p><p><br></p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>Prerequisites</p><p>需使用Kong v1.1.0+来运行不同的部署方案。建议使用Linux发行版来演示。系统上需要的一些工具：</p><ul><li><code>ncat</code>(<code>nmap</code>)</li><li><code>iptables</code></li><li><code>curl</code></li></ul><p>你的主机需要监控<code>lo0</code>网络适配器绑定到这些ip：</p><ul><li><code>127.0.0.1</code> (Host C running Kong Control Plane)</li><li><code>127.0.0.2</code> (Host A running Service A)</li><li><code>127.0.0.3</code> (Host A running Kong A)</li><li><code>127.0.0.4</code> (Host B running Kong B)</li><li><code>127.0.0.5</code> (Host B running Service B)</li></ul><p>本章的教程在单个主机上运行所有内容。为了简单起见，我们还是用IP地址而不是DNS来配置所有内容。<br>对于某些更改，可能需要root权限。</p><p><br><br><br><br><br></p><h2 id="术语和定义"><a href="#术语和定义" class="headerlink" title="术语和定义"></a>术语和定义</h2><p>Terms and Definitions</p><ul><li><strong>Kong Control Plane</strong>： 在<code>127.0.0.1</code>上启动。它在<code>8001</code>和<code>8444</code>上监听Kong Admin API，它不代理任何流量；</li><li><strong>Service A</strong>：假象的业务实体（微服务），使网络连接到Service B；</li><li><strong>Service B</strong>：接受来自Service A的网络连接的业务实体；</li><li><strong>Kong A</strong>：它是服务A前端的sidecar代理。它不监听和提供Kong Admin API；</li><li><strong>Kong B</strong>：它是服务B前端的sidecar代理。它不监听和提供Kong Admin API；</li></ul><p><br><br><br><br><br></p><h2 id="步骤1：启动服务B"><a href="#步骤1：启动服务B" class="headerlink" title="步骤1：启动服务B"></a>步骤1：启动服务B</h2><p>Step1: Start Service B</p><p>启动Service B监听TCP流量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ncat --listen \</span><br><span class="line">       --keep-open \</span><br><span class="line">       --verbose \</span><br><span class="line">       --sh-exec <span class="string">"echo 'Hello from Service B (TCP)'"</span> \</span><br><span class="line">       127.0.0.5 19000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Listening on 127.0.0.5:19000</span><br></pre></td></tr></table></figure><p><br></p><p>让命令继续运行。开一个新控制台并启动Service B监听TLS流量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ncat --listen \</span><br><span class="line">       --keep-open \</span><br><span class="line">       --verbose \</span><br><span class="line">       --ssl \</span><br><span class="line">       --sh-exec <span class="string">"echo 'Hello from Service B (TLS)'"</span> \</span><br><span class="line">       127.0.0.5 19443</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Listening on 127.0.0.5:19443</span><br></pre></td></tr></table></figure><p><br></p><p>让它继续运行。开一个新控制台并启动Service B监听HTTP流量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ncat --listen \</span><br><span class="line">     --keep-open \</span><br><span class="line">     --verbose \</span><br><span class="line">     --sh-exec <span class="string">"echo 'HTTP/1.1 200 OK\r\n\r\nHello from Service (HTTP)'"</span> \</span><br><span class="line">     127.0.0.5 18000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Listening on 127.0.0.5:18000</span><br></pre></td></tr></table></figure><p><br></p><p>让它继续运行，开一个新控制台并启动Service B监听HTTPS流量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ncat --listen \</span><br><span class="line">     --keep-open \</span><br><span class="line">     --verbose \</span><br><span class="line">     --ssl \</span><br><span class="line">     --sh-exec <span class="string">"echo 'HTTP/1.1 200 OK\r\n\r\nHello from Service B (HTTPS)'"</span> \</span><br><span class="line">     127.0.0.5 18443</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Generating a temporary 1024-bit RSA key. Use --ssl-key and --ssl-cert to use a permanent one.</span><br><span class="line">Ncat: SHA-1 fingerprint: 9B41 1A89 664A 434A 35A7 6DFA 9540 3D21 9466 46D1</span><br><span class="line">Ncat: Listening on 127.0.0.5:18443</span><br></pre></td></tr></table></figure><p>同样，保持命令继续运行。<br>此时，应该有4个ncat进程在运行，表示Service B使用不同的协议进行监听。</p><p><br><br><br><br><br></p><h2 id="步骤2：确保服务A可以连接到服务B"><a href="#步骤2：确保服务A可以连接到服务B" class="headerlink" title="步骤2：确保服务A可以连接到服务B"></a>步骤2：确保服务A可以连接到服务B</h2><p>Step2: Ensure that Service A can connect Service B</p><p>Service A直接调用<code>ncat</code>和<code>curl</code>。</p><p><br></p><p>使用TCP与Service B连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ncat --<span class="built_in">source</span> 127.0.0.2 --recv-only 127.0.0.5 19000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Hello from Service B (TCP)</span><br></pre></td></tr></table></figure><p><br></p><p>使用TLS与Service B连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ncat --<span class="built_in">source</span> 127.0.0.2 --recv-only --ssl 127.0.0.5 19443</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Hello from Service B (TLS)</span><br></pre></td></tr></table></figure><p><br></p><p>使用HTTP与Service B连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl --interface 127.0.0.2 http://127.0.0.5:18000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Hello from Service B (HTTP)</span><br></pre></td></tr></table></figure><p><br></p><p>使用HTTPS与Service B连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl --interface 127.0.0.2 --insecure https://127.0.0.5:18443</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Hello from Service B (HTTPS)</span><br></pre></td></tr></table></figure><p>服务A运行在<code>127.0.0.2</code>并可以直接连接到服务B。</p><p><br><br><br><br><br></p><h2 id="步骤3：启动Kong控制面板"><a href="#步骤3：启动Kong控制面板" class="headerlink" title="步骤3：启动Kong控制面板"></a>步骤3：启动Kong控制面板</h2><p>Step 3: Start Kong Control Plane</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动金监听Kong Admin API的Kong节点</span></span><br><span class="line">KONG_PREFIX=kong-c \</span><br><span class="line">KONG_LOG_LEVEL=debug \</span><br><span class="line">KONG_STREAM_LISTEN=<span class="string">"off"</span> \</span><br><span class="line">KONG_PROXY_LISTEN=<span class="string">"off"</span> \</span><br><span class="line">KONG_ADMIN_LISTEN=<span class="string">"127.0.0.1:8001, 127.0.0.1:8444 ssl"</span> \</span><br><span class="line">  kong start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Kong started</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="步骤4：启动Kong-A"><a href="#步骤4：启动Kong-A" class="headerlink" title="步骤4：启动Kong A"></a>步骤4：启动Kong A</h2><p>Step4: Start Kong A</p><p>Kong A将是一个作为Service A的sidecar的Kong实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">KONG_PREFIX=kong<span class="_">-a</span> \</span><br><span class="line">KONG_LOG_LEVEL=debug \</span><br><span class="line">KONG_STREAM_LISTEN=<span class="string">"127.0.0.3:9000 transparent, 127.0.0.3:9443 transparent"</span> \</span><br><span class="line">KONG_PROXY_LISTEN=<span class="string">"127.0.0.3:8000 transparent, 127.0.0.3:8443 ssl transparent"</span> \</span><br><span class="line">KONG_ADMIN_LISTEN=<span class="string">"off"</span> \</span><br><span class="line">KONG_NGINX_PROXY_PROXY_BIND=<span class="string">"127.0.0.3"</span> \</span><br><span class="line">KONG_NGINX_SPROXY_PROXY_BIND=<span class="string">"127.0.0.3"</span> \</span><br><span class="line">  kong start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Kong started</span><br></pre></td></tr></table></figure><p><br></p><p><strong>关于<code>transparent</code>选项</strong></p><p><code>transparent</code>选项使Kong可使用<code>iptables PREROUTING</code>规则的请求，并在<code>iptables</code>堆栈透明地将其代理到其sidecar代理之前读取原始目标地址和客户端尝试连接的端口。</p><p><br><br><br><br><br></p><h2 id="步骤5：启动Kong-B"><a href="#步骤5：启动Kong-B" class="headerlink" title="步骤5：启动Kong B"></a>步骤5：启动Kong B</h2><p>Step 5: Start Kong B</p><p>Kong B将是一个作为Service B的sidecar的Kong实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">KONG_PREFIX=kong-b \</span><br><span class="line">KONG_LOG_LEVEL=debug \</span><br><span class="line">KONG_STREAM_LISTEN=<span class="string">"127.0.0.4:9000 transparent, 127.0.0.4:9443 transparent"</span> \</span><br><span class="line">KONG_PROXY_LISTEN=<span class="string">"127.0.0.4:8000 transparent, 127.0.0.4:8443 transparent ssl"</span> \</span><br><span class="line">KONG_ADMIN_LISTEN=<span class="string">"off"</span> \</span><br><span class="line">KONG_NGINX_PROXY_PROXY_BIND=<span class="string">"127.0.0.4"</span> \</span><br><span class="line">KONG_NGINX_SPROXY_PROXY_BIND=<span class="string">"127.0.0.4"</span> \</span><br><span class="line">  kong start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Kong started</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="步骤6：创建Kong服务和路由"><a href="#步骤6：创建Kong服务和路由" class="headerlink" title="步骤6：创建Kong服务和路由"></a>步骤6：创建Kong服务和路由</h2><p>Step 6: Create Kong Services and Routes</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为Service B的TCP流量创建Kong服务</span></span><br><span class="line">curl -X PUT \</span><br><span class="line">       -d url=tcp://127.0.0.5:19000 \</span><br><span class="line">       http://127.0.0.1:8001/services/service-b-tcp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为服务创建路由</span></span><br><span class="line">curl -X POST \</span><br><span class="line">       -d name=service-b-tcp \</span><br><span class="line">       -d protocols=tcp \</span><br><span class="line">       -d destinations[1].ip=127.0.0.5 \</span><br><span class="line">       -d destinations[1].port=19000 \</span><br><span class="line">       http://127.0.0.1:8001/services/service-b-tcp/routes</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为Service B的TLS流量创建服务</span></span><br><span class="line">curl -X PUT \</span><br><span class="line">       -d url=tls://127.0.0.5:19443 \</span><br><span class="line">       http://127.0.0.1:8001/services/service-b-tls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加路由</span></span><br><span class="line">curl -X POST \</span><br><span class="line">       -d name=service-b-tls \</span><br><span class="line">       -d protocols=tls \</span><br><span class="line">       -d destinations[1].ip=127.0.0.5 \</span><br><span class="line">       -d destinations[1].port=19443 \</span><br><span class="line">       http://127.0.0.1:8001/services/service-b-tls/routes</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为Service B的HTTP流量创建服务</span></span><br><span class="line">curl -X PUT \</span><br><span class="line">       -d url=http://127.0.0.5:18000 \</span><br><span class="line">       http://127.0.0.1:8001/services/service-b-http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加路由</span></span><br><span class="line">curl -X POST \</span><br><span class="line">       -d name=service-b-http \</span><br><span class="line">       -d protocols=http \</span><br><span class="line">       -d hosts=127.0.0.5 \</span><br><span class="line">       http://127.0.0.1:8001/services/service-b-http/routes</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为Service B的HTTPS流量创建服务</span></span><br><span class="line">curl -X PUT \</span><br><span class="line">       -d url=https://127.0.0.5:18443/ \</span><br><span class="line">       http://127.0.0.1:8001/services/service-b-https</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加路由</span></span><br><span class="line">curl -X POST \</span><br><span class="line">       -d name=service-b-https \</span><br><span class="line">       -d protocols=https \</span><br><span class="line">       -d hosts=127.0.0.5 \</span><br><span class="line">       http://127.0.0.1:8001/services/service-b-https/routes</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="步骤7：配置代理规则"><a href="#步骤7：配置代理规则" class="headerlink" title="步骤7：配置代理规则"></a>步骤7：配置代理规则</h2><p>Step 7: Configure Transparent Proxying Rules</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Reference</p><p><br></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><a href="https://docs.konghq.com/1.1.x/configuration/" target="_blank" rel="noopener">Configuration Reference</a></p><p><br></p><h3 id="配置加载"><a href="#配置加载" class="headerlink" title="配置加载"></a>配置加载</h3><p>Configuration loading</p><p>如果通关官方软件包安装Kong，则可以在<code>/etc/kong/kong.conf.default</code>找到此默认文件。</p><p>如果配置文件中的所有值都被注释掉，Kong将使用默认配置运行。为方便起见，可将布尔值指定为<code>on/off</code>或<code>true/false</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置Kong</span></span><br><span class="line">cp /etc/kong/kong.conf.default /etc/kong/kong.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动时，Kong会查找可能包含配置文件的多个默认位置</span></span><br><span class="line">/etc/kong.conf</span><br><span class="line">/etc/kong/kong.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过-c/--conf参数指定自定义配置文件来覆盖默认行为</span></span><br><span class="line">kong start --conf /path/to/kong.conf</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h3><p>Verifying your configuration</p><p>你可以通过命令验证配置的完整性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kong check /path/to/kong.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug模式</span></span><br><span class="line">kong start -c /path/to/kong.conf --vv</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>Environment variables</p><p>从配置文件中加载属性时，Kong还是查找同名的环境变量。这允许你通过环境变量配置Kong，这对于容器结构非常方便。<br>要使用环境变量覆盖配置，请设置声明环境变量，如<code>KONG_XXX</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kong.conf</span></span><br><span class="line">log_level = debug</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># env</span></span><br><span class="line"><span class="built_in">export</span> KONG_LOG_LEVEL=error</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="注入Nginx指令"><a href="#注入Nginx指令" class="headerlink" title="注入Nginx指令"></a>注入Nginx指令</h3><p>Injecting Nginx directives</p><p>通过调整Kong实例的Nginx配置，你可以优化其基础架构的性能。</p><p>当Kong启动时，它会构建一个Nginx配置文件。你可通过Kong配置直接将自定义Nginx指令注入此文件。</p><p><br></p><h4 id="注入单个Nginx指令"><a href="#注入单个Nginx指令" class="headerlink" title="注入单个Nginx指令"></a>注入单个Nginx指令</h4><p>Injecting individual Nginx directives</p><p>添加到<code>kong.conf</code>文件的任何以<code>nginx_http_</code>, <code>nging_proxy_</code>, <code>nginx_admin_</code>为前缀的条目将通过删除前缀并添加到Nginx配置的相应部分而转换为等效的Nginx指令。</p><ul><li>带有<code>nginx_http_</code>前缀的条目将被注入http块；</li><li>带有<code>nginx_proxy_</code>前缀的条目将被注入处理Kong的代理端口的server块；</li><li>带有<code>nginx_admin_</code>前缀的条目将被注入处理Kong的Admin API端口的server块。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如，将以下行添加到`kong.conf`文件：</span></span><br><span class="line">nginx_proxy_large_client_header_buffers=16 128k</span><br><span class="line"><span class="comment"># 它将添加到Kong的Nginx 配置的代理server</span></span><br><span class="line">large_client_header_buffers 16 128k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或通过环境变量</span></span><br><span class="line"><span class="built_in">export</span> KONG_NGINX_HTTP_OUTPUT_BUFFERS=<span class="string">"4 64k"</span></span><br><span class="line"><span class="comment"># 它将添加到nginx的http块</span></span><br><span class="line">output_buffers 4 64k;</span><br></pre></td></tr></table></figure><p>有关更多的Nginx指令，请参考<a href="https://nginx.org/en/docs/dirindex.html" target="_blank" rel="noopener">Nginx文档</a>。但请注意，某些执行依赖于特定Nginx模块，其中一些可能没有包含在Kong版本中。</p><p><br><br><br></p><h4 id="注入Nginx指令文件"><a href="#注入Nginx指令文件" class="headerlink" title="注入Nginx指令文件"></a>注入Nginx指令文件</h4><p>Including files via injected Nginx directives</p><p>对于更复杂的配置，可将Nginx指令写入配置文件，然后将其注入Kong。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 栗子，my-server.kong.conf</span></span><br><span class="line"><span class="comment"># custom server</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen 2112;</span><br><span class="line">  location / &#123;</span><br><span class="line">    <span class="comment"># ...more settings...</span></span><br><span class="line">    <span class="built_in">return</span> 200;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在kong.conf配置文件中添加条目使kong节点服务此端口</span></span><br><span class="line">nginx_http_include = /path/to/your/my-server.kong.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或通过环境变量</span></span><br><span class="line"><span class="built_in">export</span> KONG_NGINX_HTTP_INCLUDE=<span class="string">"/path/to/your/my-server.kong.conf"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line">curl -I http://127.0.0.1:2112</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="自定义Nginx模板并嵌入Kong"><a href="#自定义Nginx模板并嵌入Kong" class="headerlink" title="自定义Nginx模板并嵌入Kong"></a>自定义Nginx模板并嵌入Kong</h3><p>Custom Nginx templates and embedding Kong</p><p>对于绝大多数用例，使用上面的指令注入已足够定义Kong的Nginx实例的行为。这样，你可从单个<code>kong.conf</code>文件（以及自己包含的文件）管理Kong节点的配置和调优，而无需自定义Nginx配置模板。</p><p>有两种情况，你希望直接使用自定义的Nginx配置模板：</p><ul><li>在极少数情况下，你可能需要修改一些不能通过其标准<code>kong.conf</code>属性调整的Kong默认的Nginx配置。你可以修改Kong用于生成器Nginx配置并使用你自定义的模板启动Kong的模板；</li><li>如果需要在已经运行的OpenResty实例中嵌入Kong，则可重用Kong生成的配置并将其包含在现有配置中。</li></ul><p><br></p><h4 id="自定义Nginx模板"><a href="#自定义Nginx模板" class="headerlink" title="自定义Nginx模板"></a>自定义Nginx模板</h4><p>Custom Nginx templates</p><p>可使用<code>--nginx-conf</code>参数启动、重载和重启Kong，该参数必须指定Nginx配置模板。这样的模板使用Penlight模板引擎，该引擎使用给定的Kong配置进行编译，然后在启动Nginx之前将其转储到Kong前缀目录中。</p><p>默认模板可在GitHub上查看: <a href="https://github.com/kong/kong/tree/master/kong/templates" target="_blank" rel="noopener">https://github.com/kong/kong/tree/master/kong/templates</a>。它分为两个Nginx配置文件<code>nginx.lua</code>和<code>nginx_kong.lua</code>。当<code>kong start</code>运行时，它会将这两个文件复制到前缀目录中，如下所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/kong</span><br><span class="line">├── nginx-kong.conf</span><br><span class="line">└── nginx.conf</span><br></pre></td></tr></table></figure><p>如果你必须调整Kong定义但不能通过<code>kong.conf</code>配置的全局设置，你可将<code>nginx_kong.lua</code>配置模板的内容内联到一个自定义模板文件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># ---------------------</span><br><span class="line"># custom_nginx.template</span><br><span class="line"># ---------------------</span><br><span class="line"></span><br><span class="line">worker_processes $&#123;&#123;NGINX_WORKER_PROCESSES&#125;&#125;; # can be set by kong.conf</span><br><span class="line">daemon $&#123;&#123;NGINX_DAEMON&#125;&#125;;                     # can be set by kong.conf</span><br><span class="line"></span><br><span class="line">pid pids/nginx.pid;                      # this setting is mandatory</span><br><span class="line">error_log logs/error.log $&#123;&#123;LOG_LEVEL&#125;&#125;; # can be set by kong.conf</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;          # a custom setting</span><br><span class="line">    multi_accept on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">  # contents of the nginx_kong.lua template follow:</span><br><span class="line"></span><br><span class="line">  resolver $&#123;&#123;DNS_RESOLVER&#125;&#125; ipv6=off;</span><br><span class="line">  charset UTF-8;</span><br><span class="line">  error_log logs/error.log $&#123;&#123;LOG_LEVEL&#125;&#125;;</span><br><span class="line">  access_log logs/access.log;</span><br><span class="line"></span><br><span class="line">  ... # etc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">kong start -c kong.conf --nginx-conf custom_nginx.template</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="在OpenResty中嵌入Kong"><a href="#在OpenResty中嵌入Kong" class="headerlink" title="在OpenResty中嵌入Kong"></a>在OpenResty中嵌入Kong</h3><p>Embedding Kong in OpenResty</p><p>如果您正在运行自己的OpenResty Server，您还可以通过使用<code>include</code>指令包含Kong Nginx自配置来轻松嵌入Kong。栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># my_nginx.conf</span><br><span class="line"></span><br><span class="line"># ...your nginx settings...</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include &apos;nginx-kong.conf&apos;;</span><br><span class="line"></span><br><span class="line">    # ...your nginx settings...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动Nginx实例</span></span><br><span class="line">nginx -p /usr/<span class="built_in">local</span>/openresty -c my_nginx.conf</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="同时提供来自Kong的Website和API"><a href="#同时提供来自Kong的Website和API" class="headerlink" title="同时提供来自Kong的Website和API"></a>同时提供来自Kong的Website和API</h3><p>Serving both a website and your APIs from Kong</p><p>提供API的一个常见用例是让Kong通过代理端口(80/443)在生产中同时为Website和API提供服务。例如，<code>https://example.net</code>（Website）和<code>https://example.net/api/v1</code>（API）。<br>为了实现此目标，我们不能简单地声明一个新的虚拟<code>server</code>块。一个好的解决办法是使用自定义Nginx配置模板，该模板内联<code>nginx_kong.lua</code>并添加一个新的<code>location</code>块，为Kong Proxy <code>location</code>块提供服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># ---------------------</span><br><span class="line"># custom_nginx.template</span><br><span class="line"># ---------------------</span><br><span class="line"></span><br><span class="line">worker_processes $&#123;&#123;NGINX_WORKER_PROCESSES&#125;&#125;; # can be set by kong.conf</span><br><span class="line">daemon $&#123;&#123;NGINX_DAEMON&#125;&#125;;                     # can be set by kong.conf</span><br><span class="line"></span><br><span class="line">pid pids/nginx.pid;                      # this setting is mandatory</span><br><span class="line">error_log logs/error.log $&#123;&#123;LOG_LEVEL&#125;&#125;; # can be set by kong.conf</span><br><span class="line">events &#123;&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">  # here, we inline the contents of nginx_kong.lua</span><br><span class="line">  charset UTF-8;</span><br><span class="line"></span><br><span class="line">  # any contents until Kong&apos;s Proxy server block</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  # Kong&apos;s Proxy server block</span><br><span class="line">  server &#123;</span><br><span class="line">    server_name kong;</span><br><span class="line"></span><br><span class="line">    # any contents until the location / block</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    # here, we declare our custom location serving our website</span><br><span class="line">    # (or API portal) which we can optimize for serving static assets</span><br><span class="line">    location / &#123;</span><br><span class="line">      root /var/www/example.net;</span><br><span class="line">      index index.htm index.html;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # Kong&apos;s Proxy location / has been changed to /api/v1</span><br><span class="line">    location /api/v1 &#123;</span><br><span class="line">      set $upstream_host nil;</span><br><span class="line">      set $upstream_scheme nil;</span><br><span class="line">      set $upstream_uri nil;</span><br><span class="line"></span><br><span class="line">      # Any remaining configuration for the Proxy location</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # Kong&apos;s Admin server block goes below</span><br><span class="line">  # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>Properties reference</p><p><br></p><h4 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#------------------------------------------------------------------------------</span><br><span class="line"># GENERAL</span><br><span class="line">#------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 工作目录。相当于Nginx的前缀路径，包含临时文件和日志</span><br><span class="line"># 每个Kong进程必须有一个单独的工作目录</span><br><span class="line">prefix = /usr/local/kong/  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Nginx Server的日志级别，位于&lt;prefix&gt;/logs/error.log</span><br><span class="line">log_level = notice  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 代理端口的访问日志路径。设置为off可禁用</span><br><span class="line"># 如果此值是相对路径，则它位于&lt;prefix&gt;</span><br><span class="line">proxy_access_log = logs/access.log  #default</span><br><span class="line"></span><br><span class="line"># 代理端口的错误日志路径</span><br><span class="line">proxy_error_log = logs/error.log  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Admin API请求访问的日志路径</span><br><span class="line">admin_access_log = logs/admin_access.log  #default</span><br><span class="line"></span><br><span class="line"># Admin API请求错误的日志路径</span><br><span class="line">admin_error_log = logs/error.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># plugins</span><br><span class="line"># 加载以逗号分隔的插件列表。默认情况下，只有捆绑在官方发行版中的插件才会通过bundled关键字加载。</span><br><span class="line"># 默认不启用加载插件</span><br><span class="line"># 特定名称将在Lua命名空间中替换为：kong.plugins.&#123;name&#125;.*</span><br><span class="line"># off关键字被指定为唯一时，不会加载任何插件</span><br><span class="line"># bundled和plugin名称可以混合在一起，示例如下：</span><br><span class="line">#  - plugins = bundled,custom-auth,custom-log</span><br><span class="line">#  - plugins = custom-auth,custom-log</span><br><span class="line">#  - plugins = off</span><br><span class="line"># 在禁用插件之前，请确保在重新启动Kong之前删除它的所有实例</span><br><span class="line">plugin = bundled  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 发送匿名使用数据，如错误栈追踪，以帮助改善Kong</span><br><span class="line">anonymous_reports = on  #default</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">#------------------------------------------------------------------------------</span><br><span class="line"># NGINX</span><br><span class="line">#------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 以逗号分隔的代理服务器应监听HTTP/HTTPS流量的地址和端口列表</span><br><span class="line"># 代理服务器是Kong的公共入口点，它将来自消费者的流量代理到后端服务</span><br><span class="line"># 此值接受IPv4, IPv6, hostname</span><br><span class="line"># 可以为每对指定一些后缀：</span><br><span class="line">#  - ssl，要求通过特定地址/端口建立的所有连接都在启用TLS的情况下进行</span><br><span class="line">#  - http2，允许客户端打开到Kong代理服务器的HTTP2连接</span><br><span class="line">#  - proxy_protocol，为给定的地址/端口启用PROXY协议</span><br><span class="line">#  - transparent，Kong监听您在iptables中配置的任何IP 地址和端口，并进行响应</span><br><span class="line"># 此值可设为off，从而禁用此节点的HTTP/HTTPS代理端口</span><br><span class="line"># 栗子：proxy_listen = 0.0.0.0:443 ssl, 0.0.0.0:444 http2 ssl</span><br><span class="line">proxy_listen = 0.0.0.0:8000, 0.0.0.0:8443 ssl  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 流模式监听以逗号分隔的地址和端口列表</span><br><span class="line"># 此值接受 IPv4, Ipv6, hostname</span><br><span class="line"># 可为每队指定一些后缀：</span><br><span class="line">#  - proxy_protocol，为给定的地址/端口启用PROXY协议</span><br><span class="line">#  - transparent，Kong监听您在iptables中配置的任何IP 地址和端口，并进行响应</span><br><span class="line"># 不支持ssl后缀，并且每个地址/端口都将接受启用/未启用TLS的TCP</span><br><span class="line"># 栗子：</span><br><span class="line"># stream_listen = 127.0.0.1:7000</span><br><span class="line"># stream_listen = 0.0.0.0:989, 0.0.0.0:20</span><br><span class="line"># stream_listen = [::1]:1234</span><br><span class="line"># 默认设置为off，从而禁用此节点的流代理端口</span><br><span class="line">stream_listen = off  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Admin接口监听的地址和端口列表</span><br><span class="line"># Admin API允许您配置和管理Kong</span><br><span class="line"># 应仅限于Kong管理员访问此接口</span><br><span class="line"># 此值接受 IPv4, IPv6, Hostname</span><br><span class="line"># 可为每队执行一些后缀：</span><br><span class="line">#  - ssl</span><br><span class="line">#  - http2</span><br><span class="line">#  - proxy_protocol</span><br><span class="line"># 栗子</span><br><span class="line"># stream_listen = 127.0.0.1:8444 http2 ssl</span><br><span class="line">admin_listen = 127.0.0.1:8001, 127.0.0.1:8444 ssl  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义工作进程使用的用户和组凭据</span><br><span class="line"># 如果省略group，则默认为User一致</span><br><span class="line">nginx_user = nobody nobody</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Nginx生成的工作进程数</span><br><span class="line">nginx_worker_processes = auto  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Nginx是作为守护进程还是前台进程运行</span><br><span class="line"># 主要用于在Docker环境下运行Kong</span><br><span class="line">nginx_daemon = on  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 数据库实体的内存缓存大小</span><br><span class="line"># 单位接收KB和MB，最小推荐值几MBs</span><br><span class="line">mem_cache_size = 128m  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义Nginx提供的TLS密码</span><br><span class="line"># 可接受的值包括：modern, intermediate, old, custom</span><br><span class="line">ssl_cipher_suite = modern  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义由Nginx提供服务的TLS密码的自定义列表。此列表必须符合openssl密码定义的模式</span><br><span class="line">ssl_ciphers =  #Default: none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 启用SL的proxy_listen值的SSL证书的绝对路径</span><br><span class="line">ssl_cert =  #Default: none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 启用SSL的proxy_listen值的SSL Key的绝对路径</span><br><span class="line">ssl_cert_key =  #Default: none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 确定代理请求时Nginx是否应发送客户端SSL证书</span><br><span class="line">client_ssl = off  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如果启用了client_ssl，则为proxy_ssl_certificate指令的客户端SSL证书的绝对路径</span><br><span class="line"># 请注意，此值是在节点上静态定义的，并且当前无法基于每个API进行配置。</span><br><span class="line">client_ssl_cert =  #Default: none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如果启用了client_ssl，则为proxy_ssl_certificate_key地址的客户端SSL密钥的绝对路径</span><br><span class="line"># 请注意，此值是在节点上静态定义的，目前无法基于每个API进行配置</span><br><span class="line">client_ssl_cert_key =  #Default: none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 启用SSL的admin_listen值的SSL证书的绝对路径</span><br><span class="line">admin_ssl_cert =  #Default: none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 启用SSL的admin_listen值的SSL Key的绝对路径</span><br><span class="line">admin_ssl_cert_key =  #Default: none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 设置在每个工作进程的缓存中保留的上游服务器的最大空闲keepalive连接数。</span><br><span class="line"># 超过此数量时，将关闭最近最少使用的连接。</span><br><span class="line"># 值为0表示禁用此功能</span><br><span class="line">upstream_keepalive = 60  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 以逗号分隔的Header列表应该在客户端响应中注入</span><br><span class="line"># 接受的值如下：</span><br><span class="line">#  - Server，Server: kong/x.y.z</span><br><span class="line">#  - Via，Via: kong/x.y.z</span><br><span class="line">#  - X-Kong-Proxy-Latency，Kong代理上游请求之前处理并运行所有插件所花费的时间(ms)</span><br><span class="line">#  - X-Kong-Upstream-Latency，上游服务发送响应头所花费的时间(ms)</span><br><span class="line">#  - X-Kong-Upstream-Status，上游服务返回的HTTP状态码。如果响应被插件重写，这对于客户端区分上游状态特别有用</span><br><span class="line">#  - server_tokens，与指定Server和Via相同</span><br><span class="line">#  - latency_tokens，与指定X-Kong-Proxy-Latency和X-Kong-Upstream-Latency相同</span><br><span class="line">headers = server_tokens, latency_tokens  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义已知可发送正确的 X-Forwarded-* Header 的可信IP地址块</span><br><span class="line"># 来自信任的IP的请求使Kong向上游转发了它们的 X-Forwarded-* Header</span><br><span class="line"># 不受信任的请求使Kong插入它自己的 X-Forwarded-* headers</span><br><span class="line"># 此属性还在Nginx配置中配置 set_real_ip_from 指令。它接受相同类型的值(CIDR)，以逗号分割的列表</span><br><span class="line"># 要信任所有IP，将值设置为 0.0.0.0/0,::/0</span><br><span class="line"># 如果指定为 unix:，则所有 UNIX-domain sockets都将被信任</span><br><span class="line">trusted_ips =    #default: none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义请求头字段，其值将用于替换客户端地址</span><br><span class="line"># 此值设置Nginx配置中同名的 ngx_http_realip_module 指令</span><br><span class="line"># 如果此值接收 proxy_protocol</span><br><span class="line">#  - 至少有一个 proxy_listen 条目必须启用 proxy_protocol 标志</span><br><span class="line">#  - proxy_ptotocol 参数将附加到Nginx模板的 listen 指令</span><br><span class="line">real_ip_header = X-Real-IP  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 此值设置Nginx配置中同名的ngx_http_realip_module指令</span><br><span class="line">real_ip_recursive = off  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义由Kong代理的请求所运行的最大请求主体大小，在Content-Length请求头中指定。如果请求超过此限制，Kong将响应413（Request Entity Too Large）</span><br><span class="line"># 将此值设置为0禁用检查请求主体大小</span><br><span class="line">client_max_body_size = 0    #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义用于读取请求正文的缓冲区大小。如果客户端请求正文（request body）大于此值，则正文（body）将被缓冲到磁盘</span><br><span class="line"># 请注意，当主体缓冲到磁盘时，访问或操作请求主体可能无法正常工作，因此建议将此值设置得尽可能高。（例如，将其设置为与client_max_body_size一样，以强制保留请求主体在内存中）</span><br><span class="line"># 请注意，高并发环境将需要大量内存分配来处理许多并发的大型请求</span><br><span class="line">client_body_buffer_size = 8k  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 缺少Request Accept Header且Nginx返回请求错误时要使用的默认MIME类型</span><br><span class="line"># 接受的值有： text/plain, text/html, application/json, application/xml</span><br><span class="line">error_default_type = text/plain  #default</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h4><p>Kong把所有数据（如路由、服务、消费者、插件…）存储在Cassandra或PostgreSQL中，并且属于同一集群的所有Kong节点必须将它们自己连接到同一个数据库。</p><p>Kong支持的版本:</p><ul><li>PostgreSQL v9.5+</li><li>Cassandra v2.2+</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#------------------------------------------------------------------------------</span><br><span class="line"># DATASTORE</span><br><span class="line">#------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 确定使用哪种存储</span><br><span class="line"># 接受的值有：postgres、cassandra、off</span><br><span class="line">database = postgres  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Postgres settings</span><br><span class="line">pg_host</span><br><span class="line">pg_port</span><br><span class="line">pg_timeout</span><br><span class="line">pg_user</span><br><span class="line">pg_password</span><br><span class="line">pg_database</span><br><span class="line">pg_schema</span><br><span class="line">pg_ssl</span><br><span class="line">pg_ssl_verify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Cassandra settings</span><br><span class="line">cassandra_contact_points</span><br><span class="line">cassandra_port</span><br><span class="line">cassandra_keyspace</span><br><span class="line">cassandra_consistency</span><br><span class="line">cassandra_timeout</span><br><span class="line">cassandra_ssl</span><br><span class="line">cassandra_ssl_verify</span><br><span class="line">cassandra_username</span><br><span class="line">cassandra_password</span><br><span class="line">cassandra_lb_policy</span><br><span class="line">cassandra_local_datacenter</span><br><span class="line">cassandra_repl_strategy</span><br><span class="line">cassandra_repl_factor</span><br><span class="line">cassandra_data_centers</span><br><span class="line">cassandra_schema_consensus_timeout</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Datastore-Cache"><a href="#Datastore-Cache" class="headerlink" title="Datastore Cache"></a>Datastore Cache</h4><p>为了避免与数据存储进行不必要的通信，Kong可将实体缓存一段可配置的时间。如果更新了这样的实体，它还会处理失效。<br>本节允许配置Kong关于此类配置实体的缓存的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#------------------------------------------------------------------------------</span><br><span class="line"># DATASTORE CACHE</span><br><span class="line">#------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用数据存储检查更新实体的频率（单位s）</span><br><span class="line"># 当节点通过Admin API创建，更新或删除实体时，其他节点需要等待下一轮询（由此值配置）以最终清除旧的缓存实体并开始使用新的实体</span><br><span class="line">db_update_frequency = 5  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 数据存储中的实体传播到另一个数据中心的副本节点所用的时间（单位s）</span><br><span class="line"># 单数据中心或单节点没有这样的问题，可安全地设置为0</span><br><span class="line">db_update_propagation = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 此节点缓存时实体从数据存储区的ttl（单位s）</span><br><span class="line"># 如果设置为0，则永不过期</span><br><span class="line">db_cache_ttl = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 数据存储区中的陈旧实体在无法刷新是的时间。当此TTL到期时，将进行刷新陈旧实体的新尝试</span><br><span class="line">db_resurrect_ttl = 30</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="DNS-Resolver"><a href="#DNS-Resolver" class="headerlink" title="DNS Resolver"></a>DNS Resolver</h4><p>默认情况下，DNS解析器将使用标准配置文件<code>/etc/hosts</code>和<code>/etc/resolv.conf</code>。如果已设置环境变量<code>LOCALDOMAIN</code>和<code>RES_OPTIONS</code>，则后一个文件的设置将被覆盖。</p><p>Kong会将主机名解析为<code>SRV</code>或<code>A</code>记录。如果名称被解析为SRV记录，它还将通过从DNS服务器接收的端口字段内容覆盖任何给定的端口号。</p><p>在ttl的持续时间内，内部DNS解析器将对通过DNS记录中的条目获得的每个请求进行负载均衡。对于SRV记录，权重（weight）字段将被接受，但它将仅使用记录中的最低优先级（priority）字段条目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#------------------------------------------------------------------------------</span><br><span class="line"># DNS RESOLVER</span><br><span class="line">#------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 以逗号分隔的nameserver列表，每个条目都采用 ip[:port] 的格式供Kong使用。如果省略，端口默认为53。它接受IPv4和IPv6地址</span><br><span class="line"># 如果未指定，将使用本地 resolv.conf 文件的配置</span><br><span class="line">dns_resolver =  #default: none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 要使用的hosts文件。此文件只读一次便加载为静态内存内容</span><br><span class="line"># 要在修改后再次读取文件，必须重新加载Kong</span><br><span class="line">dns_hostsfile = /etc/hosts  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 解析不同记录类型的顺序</span><br><span class="line">dns_order = LAST,SRV,A,CNAME  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 默认情况下，使用响应的TTL值缓存DNS记录。如果此属性收到一个值（以秒为单位），它将覆盖所有记录的TTL</span><br><span class="line">dns_valid_ttl =  #default: none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义记录在缓存中保留的时间长度</span><br><span class="line">dns_stale_ttl = 4  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 空DNS响应和名称错误响应的TTL</span><br><span class="line">dns_not_found_ttl = 30  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 错误响应的TTL</span><br><span class="line">dns_error_ttl = 1  #default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如果启用，则在缓存未命中时，每个请求都将触发其自己的dns查询</span><br><span class="line"># 禁用时，同一名称/类型的多个请求将同步到单个查询</span><br><span class="line">dns_no_sync = off</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="Development"><a href="#Development" class="headerlink" title="Development"></a>Development</h4><p>从<code>lua-nginx-module</code>继承的其他设置允许更多的灵活性和高级用法。</p><p><br><br><br></p><h4 id="Additional"><a href="#Additional" class="headerlink" title="Additional"></a>Additional</h4><ul><li><strong>origin</strong></li></ul><p><strong>Origin Configuration</strong>在复杂的网络配置中非常有用，并且在Kong用于<strong>服务网格（Service Mesh）</strong>通常是必需的。</p><p><code>origins</code>是一个以逗号分隔的成对的对象列表，每对使用<code>=</code>。每对左侧的原（origin）被右侧的原(origin)覆盖。此覆盖发生在访问阶段之后和上游解析之前。它具有导致Kong将流向左侧origin的流量发送到右侧origin的效果。</p><p>术语 <code>origin</code> 是指特定 scheme/host或ip/port，如RFC 6454中所描述。在Kong的origin配置中，该方案必须是<code>http</code>, <code>https</code>, <code>tcp</code>, <code>tls</code>。在每对origin中，必须匹配。如http可与https配对，tcp可与tls配对，但http不能与tcp配对。</p><p>When an encrypted scheme like <code>tls</code> or <code>https</code> in the left origin is paired with an unencrypted scheme like <code>tcp</code> or <code>http</code> in the right origin, Kong will terminate TLS on incoming connections matching the left origin, and will then route traffic unencrypted to the specified right origin. This is useful when connections will be made to the Kong node over TLS, but the local service (for which Kong is proxying traffic) doesn’t or can’t terminate TLS. Similarly, if the left origin is <code>tcp</code> or <code>http</code> and the right origin is <code>tls</code> or https, Kong will accept unencrypted incoming traffic, and will then wrap that traffic in TLS as it is routed outbound. This capability is an important enabler of Kong Mesh.</p><p>与所有Kong配置设置一样，可在<code>kong.conf</code>文件中声明origin设置。但是，建议Kong管理员不要这么做。相反，应该使用环境变量在每个节点上设置origin。因此，默认的<code>kong.conf.default</code>中不存在origin。</p><p><br></p><p>栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 如果给定的Kong节点具有以下origin的配置</span><br><span class="line">http://upstream-foo-bar:1234=http://localhost:5678</span><br><span class="line"># Kong节点不会尝试解析upstream-foo-bar，而是将该节点路由到localhost:5678</span><br><span class="line"># 在Kong的服务网格部署中，这种覆盖是必要的，以使邻近 upstream-foo-bar 应用程序的实例 Kong sidecar 将流量路由到本地实例，而不是试图将流量通过网络路由回到 upstream-foo-bar 的非本地实例</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 在另一个典型的sidecar部署中，Kong节点作为Kong代理服务的一个实例，origin将配置为</span><br><span class="line">https://service-b:9876=http://localhost:5432</span><br><span class="line"># 这将导致Kong节点仅接受端口9876上的https连接，终止tls，然后将现在未加密的流量转发到localhost:5432</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 下面这个栗子由两对组成，由逗号分隔</span><br><span class="line">https://foo.bar.com:443=http://localhost:80,tls://dog.cat.org:9999=tcp://localhost:8888</span><br><span class="line"># 这将导致Kong仅接受端口443上的https流量，并仅接受 端口9999的TLS流量，在两种情况下都终止TLS，然后分别将流量转发到localhost:80和localhost:8888</span><br><span class="line"># 假设80和8888都与单独的服务相关，当Kong充当节点代理是，可能会发生这种配置，这是一个代表多个服务的本地代理</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h2><p><a href="https://docs.konghq.com/1.1.x/cli/" target="_blank" rel="noopener">CLI Reference</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global flags</span></span><br><span class="line">--<span class="built_in">help</span>: <span class="built_in">print</span> the <span class="built_in">command</span>’s <span class="built_in">help</span> message</span><br><span class="line">--v: <span class="built_in">enable</span> verbose mode</span><br><span class="line">--vv: <span class="built_in">enable</span> debug mode (noisy)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kong --<span class="built_in">help</span></span><br><span class="line">No such <span class="built_in">command</span>: --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage: kong COMMAND [OPTIONS]</span><br><span class="line"></span><br><span class="line">The available commands are:</span><br><span class="line"> check</span><br><span class="line"> config</span><br><span class="line"> health</span><br><span class="line"> migrations</span><br><span class="line"> prepare</span><br><span class="line"> quit</span><br><span class="line"> reload</span><br><span class="line"> restart</span><br><span class="line"> roar</span><br><span class="line"> start</span><br><span class="line"> stop</span><br><span class="line"> version</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> --v              verbose</span><br><span class="line"> --vv             debug</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p><a href="https://docs.konghq.com/1.1.x/proxy/" target="_blank" rel="noopener">Proxy Reference</a></p><p>本章我们将通过详细解释其路由功能(routing capabilities)和内部工作来涵盖Kong的代理功能(proxying capabilities)。</p><p>Kong公开了几个可以通过两个配置属性调整的接口:</p><ul><li><code>proxy_listen</code>，默认是<code>8000</code>，接受来自客户端的公共流量(public traffic)并将其代理带上游服务；</li><li><code>admin_listen</code>，默认<code>8001</code>，Admin API被限制为仅由管理员访问。</li></ul><p><br><br><br></p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>Terminology：</p><ul><li><code>client</code>，向Kong代理端口发出请求的下游客户端；</li><li><code>upstream service</code>，位于Kong后面的API/Service，转发客户端请求到此；</li><li><code>Service</code>，服务实体是每个上游服务的抽象；</li><li><code>Route</code>，Kong路由实体。路由是进入Kong的入口点(entrypoints)，并定义要匹配的请求的规则，并路由到给定的服务；</li><li><code>Plugin</code>，Kong插件。它们是在代理生命周期中运行的业务逻辑。可通过Admin API配置全局/特定路由和服务的插件。</li></ul><p><br><br><br></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>从高层次的角度来看，Kong在其配置的代理和端口上监听HTTP流量(<code>8000/8443</code>)。Kong将根据你配置的路由评估任何传入的HTTP请求，并尝试查找匹配的路由。如果给定的请求与特定路由的规则匹配，Kong将处理代理请求。由于每个路由都链接(link)到一个服务，因此Kong将运行你在路由及相关服务上配置的插件，然后代理请求到上游。</p><p>你可以通过Kong Admin API管理路由。路由的<code>hosts, pahts, methods</code>属性定义用于匹配传入HTTP请求的规则。</p><p>如果Kong收到的请求无法与任何已配置的路由匹配（或没有配置路由），它将返回；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Server: kong/&lt;x.x.x&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;message&quot;: &quot;no route and no Service found with those values&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="如何配置服务"><a href="#如何配置服务" class="headerlink" title="如何配置服务"></a>如何配置服务</h3><p>How to configure a Service</p><p>在快速开始指南里面介绍了如何通过Admin API配置Kong。<br>通过向Admin API发送HTTP请求来向Kong添加服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST http://localhost:8001/services/ \</span><br><span class="line">    -d <span class="string">'name=foo-service'</span> \</span><br><span class="line">    -d <span class="string">'url=http://foo-service.com'</span></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"connect_timeout"</span>: 60000,</span><br><span class="line">    <span class="string">"created_at"</span>: 1515537771,</span><br><span class="line">    <span class="string">"host"</span>: <span class="string">"foo-service.com"</span>,</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"d54da06c-d69f-4910-8896-915c63c270cd"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"foo-service"</span>,</span><br><span class="line">    <span class="string">"path"</span>: <span class="string">"/"</span>,</span><br><span class="line">    <span class="string">"port"</span>: 80,</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"http"</span>,</span><br><span class="line">    <span class="string">"read_timeout"</span>: 60000,</span><br><span class="line">    <span class="string">"retries"</span>: 5,</span><br><span class="line">    <span class="string">"updated_at"</span>: 1515537771,</span><br><span class="line">    <span class="string">"write_timeout"</span>: 60000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该请求指示Kong注册一个名为<code>foo-service</code>的服务，该服务指向<code>http://foo-service.com</code>（上游）。<br><code>url</code>参数是一个简写的参数，用于一次填充<code>protocol, host, prot, path</code>属性。</p><p><br></p><p>现在，为了通过Kong向这个服务发送流量，我们需要指定一个路由，它作为Kong的入口点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST http://localhost:8001/routes/ \</span><br><span class="line">    -d <span class="string">'hosts[]=example.com'</span> \</span><br><span class="line">    -d <span class="string">'paths[]=/foo'</span> \</span><br><span class="line">    -d <span class="string">'service.id=d54da06c-d69f-4910-8896-915c63c270cd'</span></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"created_at"</span>: 1515539858,</span><br><span class="line">    <span class="string">"hosts"</span>: [</span><br><span class="line">        <span class="string">"example.com"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"ee794195-6783-4056-a5cc-a7e0fde88c81"</span>,</span><br><span class="line">    <span class="string">"methods"</span>: null,</span><br><span class="line">    <span class="string">"paths"</span>: [</span><br><span class="line">        <span class="string">"/foo"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"preserve_host"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"priority"</span>: 0,</span><br><span class="line">    <span class="string">"protocols"</span>: [</span><br><span class="line">        <span class="string">"http"</span>,</span><br><span class="line">        <span class="string">"https"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"service"</span>: &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="string">"d54da06c-d69f-4910-8896-915c63c270cd"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"strip_path"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"updated_at"</span>: 1515539858</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在已经配置了一个路由来匹配与给定<code>hosts</code>和<code>path</code>匹配的传入请求，并将它们转发到我们配置的<code>foo-service</code>服务，从而将此流量代理到<code>http://foo-service.com</code>。</p><p>Kong是一个透明的代理，它默认情况下会原封不同的(untouched)将请求转发给上游服务，但HTTP规范要求使用各种表头(Header)（如<code>Connection, Date ...</code>）</p><p><br><br><br></p><h3 id="路由和匹配"><a href="#路由和匹配" class="headerlink" title="路由和匹配"></a>路由和匹配</h3><p>Routes and matching capabilities</p><p>现在让我们讨论Kong如何匹配针对路由的已配置的<code>hosts, paths, methods</code>属性的请求。请注意，所有这三个字段都是可选的，但必须指定其中一个。</p><p>对于匹配路由的请求：</p><ul><li>请求必须包含所有已配置的字段；</li><li>请求中的字段值至少与其中一个配置值匹配（当字段配置接受一个或多个值时，请求只需其中一个值被视为匹配）。</li></ul><p><br></p><p>举个栗子。考虑如下配置的路由：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"example.com"</span>, <span class="string">"foo-service.com"</span>],</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"/foo"</span>, <span class="string">"/bar"</span>],</span><br><span class="line">    <span class="attr">"methods"</span>: [<span class="string">"GET"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此路由匹配的一些可能的请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /bar HTTP/1.1</span><br><span class="line">Host: foo-service.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /foo/hello/world HTTP/1.1</span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure><p>所有这三个请求都满足路径定义中设置的所有条件。</p><p>但是，以下请求与配置的路由条件不匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># path不匹配</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># method不匹配</span><br><span class="line">POST /foo HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># host不匹配</span><br><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Host: foo.com</span><br></pre></td></tr></table></figure><p>现在我们了解了<code>hosts, pahts, mehtods</code>属性如何协作工作，让我们分别探索每个属性。</p><p><br><br><br></p><h4 id="请求主机头"><a href="#请求主机头" class="headerlink" title="请求主机头"></a>请求主机头</h4><p>Request Host header</p><p>基于其Host Header路由请求是通过Kong代理流量的最直接的方式，尤其是因为这是HTTP Host Header的预期用途。Kong可以通过路由实体的<code>hosts</code>字段轻松完成。</p><p><code>hosts</code>接受多个值，在通过Admin API指定它们时必须以逗号分隔。这些值很容易在JSON有效负载中表示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST http://localhost:8001/routes/ \</span><br><span class="line">    -H <span class="string">'Content-Type: application/json'</span> \</span><br><span class="line">    -d <span class="string">'&#123;"hosts":["example.com", "foo-service.com"]&#125;'</span></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br></p><p>由于Admin API还支持<strong>form-urlencoded</strong>内容类型，因此还可通过<code>[]</code>表示法指定数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST http://localhost:8001/routes/ \</span><br><span class="line">    -d <span class="string">'hosts[]=example.com'</span> \</span><br><span class="line">    -d <span class="string">'hosts[]=foo-service.com'</span></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><br></p><p>要满足此路由的<code>hosts</code>条件，来自客户端的任何传入请求现在必须将Host Header设置为两者之一：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Host:</span> <span class="string">example.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Host:</span> <span class="string">foo-service.com</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="使用通配符主机名"><a href="#使用通配符主机名" class="headerlink" title="使用通配符主机名"></a>使用通配符主机名</h5><p>Using wildcard hostnames</p><p>为了提供灵活性，Kong允许你在<code>hosts</code>字段中指定带通配符的主机名。通配符主机名允许任何匹配的Host Header满足条件，从而匹配给定的路由。</p><p>通配符主机名必须在域的最左侧或最右侧标签中仅包含一个星号(<code>*</code>)：</p><ul><li><code>*.example.com</code><ul><li><code>a.example.com</code></li><li><code>x.y.z.example.com</code></li><li>…</li></ul></li><li><code>example.*</code><ul><li><code>example.com</code></li><li><code>example.org</code></li><li>…</li></ul></li></ul><p><br></p><p>栗子:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"*.example.com"</span>, <span class="string">"service.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配的路由栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: an.example.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: service.com</span><br></pre></td></tr></table></figure><p><br><br><br></p><h5 id="preserve-host属性"><a href="#preserve-host属性" class="headerlink" title="preserve_host属性"></a><code>preserve_host</code>属性</h5><p>代理时，Kong的默认行为是将上游请求的Host Header设置为服务<code>host</code>中指定的主机名。<code>preserve_host</code>字段接受一个布尔标志，指示Kong不要这样做。</p><p>例如，当<code>preserve_host</code>属性未更改且路由配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"service.com"</span>],</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端对Kong的可能请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: service.com</span><br></pre></td></tr></table></figure><p>Kong从服务的<code>host</code>属性中提取Host Header，并将发送以下上游请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: &lt;my-service-host.com&gt;</span><br></pre></td></tr></table></figure><p><br></p><p>但是，通过使用<code>preserve_host=true</code>显式配置路由：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"service.com"</span>],</span><br><span class="line">    <span class="attr">"preserve_host"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设来自客户端的相同请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: service.com</span><br></pre></td></tr></table></figure><p>Kong将根据客户端请求保留Host，并将发送以下上游请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: service.com</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="请求路径"><a href="#请求路径" class="headerlink" title="请求路径"></a>请求路径</h4><p>Request path</p><p>路由匹配的另一种方式是通过请求路径。要满足此路由条件，客户端请求的路径必须以<code>paths</code>属性的值之一为前缀。</p><p>例如，如下路由配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"/service"</span>, <span class="string">"/hello/world"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下请求将匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /service HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /service/resource?param=value HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /hello/world/resource HTTP/1.1</span><br><span class="line">Host: anything.com</span><br></pre></td></tr></table></figure><p>对于每一个请求，Kong检测其以路由的路径配置为前缀之一的URL path。默认情况下，Kong会在不更改URL path的情况下代理上游请求。<br>使用路径前缀进行代理时，首先评估最长路径(longest paths)。这允许你定力具有两个路径的两个路由：<code>/service</code>, <code>/service/resource</code>，并确保前者不会遮蔽(shadow)后者。</p><p><br><br><br></p><h5 id="在路径中使用正则"><a href="#在路径中使用正则" class="headerlink" title="在路径中使用正则"></a>在路径中使用正则</h5><p>Using regexes in paths</p><p>Kong通过PCRE(Perl Compatible Regular Expression)支持路由的路径字段的正则表达式模式匹配。你可以同时将路径作为前缀和正则表达式分配给路由。</p><p>例如，考虑如下路由：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"/users/\d+/profile"</span>, <span class="string">"/following"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此路由匹配以下请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /following HTTP/1.1</span><br><span class="line">Host: ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /users/123/profile HTTP/1.1</span><br><span class="line">Host: ...</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>评估顺序(Evaluation order)</strong></li></ul><p>如前所述，Kong按长度评估前缀路径：首先评估最长路径。但是，Kong将根据路由的<code>regex_priority</code>属性从最高优先级到最低优先级来评估正则表达式。<br>考虑如下路由：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"paths"</span>: [<span class="string">"/status/\d+"</span>],</span><br><span class="line">        <span class="attr">"regex_priority"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"paths"</span>: [<span class="string">"/version/\d+/status/\d+"</span>],</span><br><span class="line">        <span class="attr">"regex_priority"</span>: <span class="number">6</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"paths"</span>: [<span class="string">"/version"</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"paths"</span>: [<span class="string">"/version/any/"</span>],</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在这种情况下，Kong将按照以下顺序评估对以下定义的URL的传入请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. /version/any/</span><br><span class="line">2. /version</span><br><span class="line">3. /version/\d+/status/\d+</span><br><span class="line">4. /status/\d+</span><br></pre></td></tr></table></figure><p>始终在正则表达式之前评估前缀路径。</p><p>向往常一样，请求仍然必须匹配路由的<code>hosts</code>和<code>methods</code>属性，并且Kong将遍历你的路由，直到找到匹配最多规则的路由。</p><p><br></p><ul><li><strong>捕获组(Capturing groups)</strong></li></ul><p>还支持捕获组，并且将从路径中提取匹配的组并可用于插件使用。</p><p>考虑如下正则和请求路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/version/(?&lt;version&gt;\d+)/users/(?&lt;user&gt;\S+)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/version/1/users/john</span><br></pre></td></tr></table></figure><p>Kong会将请求路径视为匹配，如果匹配整个路由(考虑<code>hosts</code>, <code>methods</code>)，则可从<code>ngx.ctx</code>变量中的插件获取捕获组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local router_matches = ngx.ctx.router_matches</span><br><span class="line"></span><br><span class="line">-- router_matches.uri_captures is:</span><br><span class="line">-- &#123; &quot;1&quot;, &quot;john&quot;, version = &quot;1&quot;, user = &quot;john&quot; &#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>转义特殊字符(Escaping special characters)</strong></li></ul><p>通过Admin API配置具有正则表达式路径的路由时，请务必在必要时对你的有效负载进行URL编码。<br>例如，使用<code>curl</code>并使用<code>application/x-www-form-urlencoded</code>MIME类型：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST http://localhost:8001/routes \</span><br><span class="line">    --data-urlencode 'uris[]=/status/\d+'</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>请注意，<code>curl</code>不会自动对你的有效负载进行URL编码，并注意使用<code>--data-urlencode</code>，它可以防止对<code>+</code>字符进行URL编码，并将其解释为Kong的Admin API `` 空间。</p><p><br><br><br></p><h5 id="strip-path属性"><a href="#strip-path属性" class="headerlink" title="strip_path属性"></a><code>strip_path</code>属性</h5><p>可能需要指定路径前缀以匹配路由，但不将其包括在上游请求中。要这样做，请在路由配置中使用<code>strip_path</code>属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    &quot;paths&quot;: [&quot;/service&quot;],</span><br><span class="line">    &quot;strip_path&quot;: true,</span><br><span class="line">    &quot;service&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;...&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启用此标志会指示Kong在匹配此路由并继续代理服务时，不应在上游请求的URL中包含URL路径的匹配部分。</p><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 例如，以下客户端对上述路由的请求</span><br><span class="line">GET /service/path/to/resource HTTP/1.1</span><br><span class="line">Host: ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 将导致Kong发送以下上游请求</span><br><span class="line">GET /path/to/resource HTTP/1.1</span><br><span class="line">Host: ...</span><br></pre></td></tr></table></figure><p><br></p><p>同样，如果启用了<code>strip_path</code>的路由上定义了正则表达式，则将剥离整个请求URL匹配序列。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"/version/\d+/service"</span>],</span><br><span class="line">    <span class="attr">"strip_path"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下HTTP请求与提供的正则表达式路径匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /version/1/service/path/to/resource HTTP/1.1</span><br><span class="line">Host: ...</span><br></pre></td></tr></table></figure><p>有Kong代理到上游：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /path/to/resource HTTP/1.1</span><br><span class="line">Host: ...</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>Request HTTP method</p><p><code>methods</code>字段允许根据HTTP方法匹配请求。它接受多个值。其默认值为空（HTTP方法不用于路由）。</p><p>以下路由允许通过<code>GET</code>和<code>HEAD</code>进行路由：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"methods"</span>: [<span class="string">"GET"</span>, <span class="string">"HEAD"</span>],</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的路由符合以下要求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HEAD /resource HTTP/1.1</span><br><span class="line">Host: ...</span><br></pre></td></tr></table></figure><p>但它与<code>POST</code>和<code>DELETE</code>请求不匹配。在路由上配置插件时，这允许更多粒度。例如，你可以想象两个执行同一服务的路由：</p><ul><li>一个具有无限制的未认证的<code>GET</code>请求</li><li>另一个仅允许经过身份认证和速率限制的<code>POST</code>请求</li></ul><p><br><br><br></p><h3 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h3><p>Matching priorities</p><p>路由可以基于其<code>hosts, paths, methods</code>字段定义匹配规则。要使Kong匹配到路由的传入请求，必须满足所有现有字段。但是，通过允许两个或多个路由配置包含相同值的字段，Kong允许相当大的灵活性。当发生这种情况时，Kong应用优先级规则(priority rule)。</p><p>规则是：<strong>在评估请求时，Kong将首先尝试匹配具有最多规则(most rules)的路由</strong>。</p><p>例如，如果两个路由配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"example.com"</span>],</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"example.com"</span>],</span><br><span class="line">    <span class="attr">"methods"</span>: [<span class="string">"POST"</span>],</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个路由有<code>hosts, methods</code>字段，因此它将首先由Kong评估。通过这样做，我们避免了第一个用于第二个路由的<strong>阴影(shadow)</strong>调用。</p><p>看看请求匹配的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 匹配第一个路由</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 匹配第二个路由</span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure><p>遵循这个逻辑，如果第三个路由配置了<code>hosts, methods, uris</code>字段，则它将首先由Kong评估。</p><p><br><br><br></p><h3 id="代理行为"><a href="#代理行为" class="headerlink" title="代理行为"></a>代理行为</h3><p>Proxying behavior</p><p>上面的代理规则详细地说明了Kong如何将传入请求转发到你的上游服务。下面来详细说明Kong与HTTP请求与注册路由匹配(match)的时间与请求的实际转发(forwarding)之间内部发生的情况。</p><p><br></p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>Load balancing</p><p>Kong实现负载均衡功能，以跨上游服务实例池来分发代理请求。<br>详情参考后面负载均衡详情。</p><p><br><br><br></p><h4 id="插件执行"><a href="#插件执行" class="headerlink" title="插件执行"></a>插件执行</h4><p>Plugins execution</p><p>Kong可通过插件(plugins)进行扩展，这些插件将将自己钩(hook)在代理请求的请求/响应的生命周期中。插件可在你的环境中执行各种操作，或在代理请求上进行转换。</p><p>可将插件配置为<strong>全局(globally)</strong>或特定(specific)路由和服务运行。在这两种情况下，你都必须通过Admin API创建插件配置。<br>一旦路由匹配，Kong将运行与这些实体中的任何一个相关联的插件。在路由上配置的插件在服务上配置的插件之前运行。</p><p>详细信息参考插件开发指南。</p><p><br><br><br></p><h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p>Proxying/upstream timeouts</p><p>一旦Kong执行了所有必要的逻辑（包括插件），它就可以将请求转发给你的上游服务。这通过Nginx的<code>ngx_http_proxy_module</code>模块完成。你可通过以下服务的属性为Kong和给定上游之间的连接配置超时：</p><ul><li><code>upstream_connect_timeout</code>：定义建立与上游服务的连接的超时时间，以毫秒(ms)为单位，默认60000</li><li><code>upstream_send_timeout</code>：定义用于向上游服务发送请求的两个连续写入操作之间的超时时间，以毫秒(ms)为单位，默认60000</li><li><code>upstream_read_timeout</code>：定义用于接收来自上游服务的两个连续读取操作之间的超时时间，以毫秒(ms)为单位，默认60000</li></ul><p>Kong将通过<code>HTTP/1.1</code>发送请求，并设置以下Header：</p><ul><li><code>Host: &lt;your_upstream_host&gt;</code></li><li><code>Connection: keep-alive</code>，允许重用上游连接</li><li><code>X-Real-IP: &lt;remote_addr&gt;</code>，其中<code>$remote_addr</code>是与<code>ngx_http_core_module</code>模块提供的名称相同的变量。请注意，<code>$remote_addr</code>可能被<code>ngx_http_realip_module</code>覆盖</li><li><code>X-Forwarded-For: &lt;address&gt;</code>，其中<code>&lt;address&gt;</code>是由附加到请求头的<code>ngx_http_realip_module</code>提供的<code>$realip_remote_addr</code>的内容，其名称相同</li><li><code>X-Forwarded-Proto: &lt;protocol&gt;</code>，其中<code>&lt;protocol&gt;</code>是客户端使用的协议。在<code>$realip_remote_addr</code>是可信地址之一的情况下，如果提供，则转发具有相同名称的请求头。否则，将使用<code>ngx_http_core_module</code>提供的<code>$scheme</code>变量的值</li><li><code>X-Forwarded-Host: &lt;host&gt;</code>，其中<code>&lt;host&gt;</code>是客户端发送的主机名。在<code>$realip_remote_addr</code>是可信地址之一的情况下，如果提供，则转发具有相同名称的请求头。否则，将使用<code>ngx_http_core_module</code>提供的<code>$host</code>变量的值</li><li><code>X-Forwarded-Port: &lt;port&gt;</code>，其中<code>&lt;port&gt;</code>是接受请求的服务器的端口。在<code>$realip_remote_addr</code>是可信地址之一的情况下，如果提供，则转发具有相同名称的请求头。否则，将使用<code>ngx_http_core_module</code>提供的<code>$server_port</code>变量的值</li></ul><p>所有其它请求头都由Kong转发。</p><p>使用WebSocket协议时会出现一个例外。如果这样，Kong将设置以下Header以允许升级客户端和上有服务之间的协议：</p><ul><li><code>Connection: Upgrade</code></li><li><code>Upgrade: websocket</code></li></ul><p><br><br><br></p><h4 id="错误和重试"><a href="#错误和重试" class="headerlink" title="错误和重试"></a>错误和重试</h4><p>Errors and retries</p><p>每当代理期间发生错误时，Kong将使用底层的Nginx重试机制将请求传递个下一个上游。</p><p>这里有两个可配置的元素：</p><ul><li>重试次数：可使用<code>retries</code>属性为每个服务配置</li><li>是什么构成错误：Kong使用Nginx默认值，这意味着与服务器建立连接，向其传递请求/读取响应 Header时发生错误或超时</li></ul><p><br><br><br></p><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>Response</p><p>Kong接收来自上游服务的响应，并以流(stream)的方式将其发送回下游客户端。此时，Kong将执行添加到路由或服务的后续插件，这些插件在<code>header_filter</code>阶段实现一个钩子。<br>一旦执行了所有已注册插件的<code>header_filter</code>阶段，Kong将添加以下Header，并将完整的header集发送到客户端：</p><ul><li><code>Via: kong/x.x.x</code>，其中<code>x.x.x</code>是Kong使用的版本</li><li><code>X-Kong-Proxy-Latency: &lt;latency&gt;</code>，其中<code>&lt;latency&gt;</code>是Kong收到客户端请求和向上游服务发送请求之间的时间(ms为单位)</li><li><code>X-Kong-Upstream-Latency: &lt;latency&gt;</code>，其中<code>&lt;latency&gt;</code>是Kong等待上游服务响应的第一个字节的时间(ms为单位)</li></ul><p>将Header发送到客户端后，Kong将开始为实现<code>body_filter</code>钩子的路由或服务之星已注册的插件。由于Nginx的流媒体特性，可多次调用此钩子。</p><p><br><br><br></p><h3 id="后备路由"><a href="#后备路由" class="headerlink" title="后备路由"></a>后备路由</h3><p>Configuring a fallback Route</p><p>作为一个实际的用例和Kong的代理功能所提供的灵活性的栗子，让我们尝试实现一个<strong>后备路由(fallback route)</strong>，这样为了避免Kong响应HTTP <code>4O4 no route found</code>，我们可以捕获这样的请求并将它们代理到特殊的上游服务，或者向其应用插件。</p><p>一个后备路由的栗子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"/"</span>],</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何向Kong发出的HTTP请求实际上都会匹配此路由，因为所有URI都以根字符(<code>/</code>)为前缀。最长的URL路径首先由Kong评估，因此<code>/</code>路径将由Kong最后评估，并有效地提供后备路由，仅作为最后的手段。然后，你可将流量发送到特殊服务或在此路由上应用任何插件。</p><p><br><br><br></p><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>Configuring SSL for a Route</p><p>Kong提供了一种基于每个连接动态(dynamically)提供SSL证书的方式。SSL证书由<strong>core</strong>直接处理，并可通过Admin API进行配置。通过TLS连接到Kong的客户端必须支持Server Name Indication(SNI)扩展才能使用此功能。</p><p>SSL证书由Kong Admin API中的两个资源处理：</p><ul><li><code>/certificates</code>，存储密钥(key)和证书(certificate)</li><li><code>/snis</code>，将注册的证书与Server Name Indication相关联</li></ul><p><br></p><p>以下是在给定路由上配置SSL证书的方法:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过Admin API上传证书和密钥</span></span><br><span class="line"><span class="comment"># snis表单参数，直接插入SNI并将其上传的证书与其关联</span></span><br><span class="line">curl -i -X POST http://localhost:8001/certificates \</span><br><span class="line">    -F <span class="string">"cert=@/path/to/cert.pem"</span> \</span><br><span class="line">    -F <span class="string">"key=@/path/to/cert.key"</span> \</span><br><span class="line">    -F <span class="string">"snis=ssl-example.com,other-ssl-example.com"</span></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现在必须在Kong内注册以下路由。一个简单的栗子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST http://localhost:8001/routes \</span><br><span class="line">    -d <span class="string">'hosts=ssl-example.com,other-ssl-example.com'</span> \</span><br><span class="line">    -d <span class="string">'service.id=d54da06c-d69f-4910-8896-915c63c270cd'</span></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你现在可以期望Kong通过HTTPS提供路由：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -i https://localhost:8443/ \</span><br><span class="line">  -H <span class="string">"Host: ssl-example.com"</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>建立连接并协商SSL握手时，如果客户端发送<code>ssl-example.com</code>作为SNI扩展的一部分，Kong将提供先前配置的<code>cert.pem</code>证书。 </p><p><br></p><h4 id="限制客户端协议"><a href="#限制客户端协议" class="headerlink" title="限制客户端协议"></a>限制客户端协议</h4><p>Restricting the client protocol (HTTP/HTTPS/TCP/TLS)</p><p>路由有一个<code>protocols</code>属性，以限制它们应该监听的客户端协议。此属性接受一组值:</p><ul><li><code>http/https</code></li><li><code>tcp/tls</code></li></ul><p>具有<code>http</code>和<code>https</code>的路由将接受两种协议中的流量：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"..."</span>],</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"..."</span>],</span><br><span class="line">    <span class="attr">"methods"</span>: [<span class="string">"..."</span>],</span><br><span class="line">    <span class="attr">"protocols"</span>: [<span class="string">"http"</span>, <span class="string">"https"</span>],</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未指定协议的路由默认为<code>[&quot;http&quot;, &quot;https&quot;]</code>。</p><p>但是，仅使用<code>https</code>的路由只接受通过<code>https</code>的流量。如果以前从信任的IP发生SSL终止(termination)，它也会接受未加密的流量。当请求来自<code>trusted_ip</code>中配置的IP并且如果设置了<code>X-Forwarded-Proto: https</code> Header头时，SSL终止被认为是有效：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"..."</span>],</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"..."</span>],</span><br><span class="line">    <span class="attr">"methods"</span>: [<span class="string">"..."</span>],</span><br><span class="line">    <span class="attr">"protocols"</span>: [<span class="string">"https"</span>],</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述路由与请求匹配，但该请求是没有有效的先前SSL终止的纯文本(plain-text)，则Kong响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 426 Upgrade Required</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: TLS/1.2, HTTP/1.1</span><br><span class="line">Server: kong/x.y.z</span><br><span class="line"></span><br><span class="line">&#123;&quot;message&quot;:&quot;Please use HTTPS protocol&quot;&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>从Kong v1.0开始，可以使用<code>protocols</code>属性中的<code>tcp</code>为原始TCP(不一定是HTTP)连接创建路由：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"..."</span>],</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"..."</span>],</span><br><span class="line">    <span class="attr">"methods"</span>: [<span class="string">"..."</span>],</span><br><span class="line">    <span class="attr">"protocols"</span>: [<span class="string">"tcp"</span>],</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，可使用<code>tls</code>值创建接受原始TLS流量(不一定是HTTPS)的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;hosts&quot;: [&quot;...&quot;],</span><br><span class="line">    &quot;paths&quot;: [&quot;...&quot;],</span><br><span class="line">    &quot;methods&quot;: [&quot;...&quot;],</span><br><span class="line">    &quot;protocols&quot;: [&quot;tls&quot;],</span><br><span class="line">    &quot;service&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;...&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅具有TLS的路由仅接受通过TLS的流量。</p><p>也可同时接受<code>tcp</code>和<code>tls</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"..."</span>],</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"..."</span>],</span><br><span class="line">    <span class="attr">"methods"</span>: [<span class="string">"..."</span>],</span><br><span class="line">    <span class="attr">"protocols"</span>: [<span class="string">"tcp"</span>, <span class="string">"tls"</span>],</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>Proxy WebSocket traffic</p><p>由于底层的Nginx实现，Kong支持WebSocket流量。如果希望通过Kong在客户端和上游服务之间建立WebSocket连接，则必须建立WebSocket握手。这是通过HTTP Upgrade mechanism 完成的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 栗子，客户端对Kong的请求</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: my-websocket-api.com</span><br><span class="line">Upgrade: WebSocket</span><br></pre></td></tr></table></figure><p>这使Kong将<code>Connection</code>和<code>Upgrade</code> header转发到上游服务，而不是由于标准HTTP proxy的逐跳(hop-by-hop)特性而将其解除。</p><p><br></p><h4 id="WebSocket和TLS"><a href="#WebSocket和TLS" class="headerlink" title="WebSocket和TLS"></a>WebSocket和TLS</h4><p>Kong将在其各自的<code>http</code>和<code>https</code>端口接受<code>ws</code>和<code>wss</code>连接。要从客户端强制执行TLS联结，请见路由的<code>protocols</code>属性设置为仅<code>https</code>。</p><p>将服务设置为指向上游WebSocket服务时，应仔细选择要在Kong和上游之间使用的协议。如果要使用TLS（<code>wss</code>），则必须使用上游WebSocket服务定义的服务<code>protocol</code>属性中的<code>https</code>协议和正确的端口(<code>443</code>)。要在没有TLS(<code>ws</code>)的情况下进行连接，则应在<code>protocol</code>中使用<code>http</code>协议和端口(<code>80</code>)。</p><p><br><br><br><br><br></p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p><a href="https://docs.konghq.com/1.1.x/auth/" target="_blank" rel="noopener">Authentication Reference</a></p><p>到上游服务(API/Microservice)的流量通常是由各种<strong>Kong 认证插件(authentication plugins)</strong>的应用程序和配置来控制。</p><p><br><br><br></p><h3 id="通用认证"><a href="#通用认证" class="headerlink" title="通用认证"></a>通用认证</h3><p>Generic authentication</p><p>最常见的情况是要求认证并且不允许任何未经认证的请求的访问。为此，可以使用任何认证插件。这些插件的通用流程如下：</p><ol><li>将认证插件应用于服务(service)或全局(global)</li><li>创建一个<strong>消费者(consumer)</strong>实体</li><li>为消费者提供特定认证方法(authentication method)的认证凭据(authentication credential)</li><li>现在每当有请求(request)进入时，Kong都会检查凭据，如果请求无法验证，它将阻止请求，或在Header中添加消费者和凭据的详细信息并转发请求</li></ol><p>上面的通用流程并不总是适用，例如在使用LDAP等外部认证时，则不会添加消费者，并且只会在转发的Header中添加凭据。</p><p><br><br><br></p><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>Consumers</p><p>理解消费者最简单的方法是将它们一对一地映射到用户(one-on-one to user)。然而，对Kong来说这并不重要。消费者的核心原则是你可以将插件附加到它们，从而定制请求行为。（例如，为每个移动应用的版本定义一个消费者，Android消费者、IOS消费者…）</p><p>这对Kong来说是一个不透明的概念，因此它们被称为<strong>消费者(consumer)</strong>而不是<strong>用户(user)</strong>。</p><p><br><br><br></p><h3 id="匿名访问"><a href="#匿名访问" class="headerlink" title="匿名访问"></a>匿名访问</h3><p>Anonymous Access</p><p>Kong能够配置给定服务以允许<strong>身份认证(Authentication)</strong>和<strong>匿名访问(Anonymous Access)</strong>。你可以使用此配置向具有低速率限制(rate-limit)的匿名用户授予访问权限，并授予对具有更高速率限制的认证的用户的访问权限。</p><p>要配置这样的服务，首先应用你选择的身份认证插件，然后创建一个新的消费者来表示匿名用户，然后配置身份认证插件以允许匿名访问。</p><p>栗子:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Create an example Service and a Route</span></span><br><span class="line">curl -i -X POST \</span><br><span class="line">   --url http://localhost:8001/services/ \</span><br><span class="line">   --data <span class="string">'name=example-service'</span> \</span><br><span class="line">   --data <span class="string">'url=http://mockbin.org/request'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a route to the Service:</span></span><br><span class="line">curl -i -X POST \</span><br><span class="line">   --url http://localhost:8001/services/example-service/routes \</span><br><span class="line">   --data <span class="string">'paths[]=/auth-sample'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># http://localhost:8000/auth-sample</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Configure the key-auth Plugin for your Service</span></span><br><span class="line">curl -i -X POST \</span><br><span class="line">   --url http://localhost:8001/services/example-service/plugins/ \</span><br><span class="line">   --data <span class="string">'name=key-auth'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意插件id，后面会用到</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Verify that the key-auth plugin is properly configured</span></span><br><span class="line">curl -i -X GET \</span><br><span class="line">   --url http://localhost:8000/auth-sample</span><br><span class="line"></span><br><span class="line"><span class="comment"># May be 403 Forbidden</span></span><br><span class="line">HTTP/1.1 403 Forbidden</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"message"</span>: <span class="string">"No API key found in headers or querystring"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Create an anonymous Consumer</span></span><br><span class="line"><span class="comment"># Kong代理的每个请求都必须与消费者关联</span></span><br><span class="line">curl -i -X POST \</span><br><span class="line">   --url http://localhost:8001/consumers/ \</span><br><span class="line">   --data <span class="string">"username=anonymous_users"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建响应</span></span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"username"</span>: <span class="string">"anonymous_users"</span>,</span><br><span class="line">  <span class="string">"created_at"</span>: 1428555626000,</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"bbdf1c48-19dc-4ab7-cae0-ff4f59d87dc9"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意消费者id，后面需要</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. Enable anonymous access</span></span><br><span class="line">curl -i -X PATCH \</span><br><span class="line">   --url http://localhost:8001/plugins/&lt;your-plugin-id&gt; \</span><br><span class="line">   --data <span class="string">"config.anonymous=&lt;your-consumer-id&gt;"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. Check anonymous access</span></span><br><span class="line">curl -i -X GET \</span><br><span class="line">   --url http://localhost:8000/auth-sample</span><br><span class="line"></span><br><span class="line"><span class="comment"># 响应（Mockbin）</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"headers"</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"x-consumer-id"</span>: <span class="string">"713c592c-38b8-4f5b-976f-1bd2b8069494"</span>,</span><br><span class="line">    <span class="string">"x-consumer-username"</span>: <span class="string">"anonymous_users"</span>,</span><br><span class="line">    <span class="string">"x-anonymous-consumer"</span>: <span class="string">"true"</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="多个认证"><a href="#多个认证" class="headerlink" title="多个认证"></a>多个认证</h3><p>Multiple Authentication</p><p>Kong支持给定服务的多个身份认证插件，允许不同客户端使用不同的身份认证方法来访问给定的服务或路由。</p><p>在评估多个身份认证凭据时，可将认证插件的行为设置为逻辑<code>AND</code>或逻辑<code>OR</code>。关键行为是<code>config.anonymous</code>属性：</p><ul><li><p><code>config.anonymous</code>未设置<br>如果未设置此属性，则认证插件将始终执行身份认证。如果未经过认证，则返回<code>40x</code>响应。当调用多个认证插件时，这会产生逻辑<code>AND</code>。</p></li><li><p><code>config.anonymous</code>设置为有效的消费者ID<br>在这种情况下，认证插件只会在尚未经过身份认证的情况下执行认证。认证失败时，让不会返回<code>40x</code>响应，而是将匿名消费者设置为消费者。当调用多个认证插件时，这会导致逻辑<code>OR</code>加上<code>anonymous access</code>。</p></li></ul><p><br></p><p>注意:</p><ul><li>必须为匿名访问配置所有认证插件，或不配置任何认证插件。如果它们是混合的，则并未是不确定的；</li><li>使用<code>AND</code>方法时，最后执行的插件将是传递给上游服务的设置凭据。使用<code>OR</code>方法时，它将成为第一个成功验证消费者的插件，或者是将设置其配置的匿名消费者的最后一个插件；</li><li>以<code>AND</code>方式使用OAuth2插件时，用于请求令牌(token)等的OAuth端点也需要其它已配置的认证插件进行身份认证。</li></ul><p><br><br><br><br><br></p><h2 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><a href="https://docs.konghq.com/1.1.x/loadbalancing/" target="_blank" rel="noopener">Loadbalancing reference</a></p><p>Kong提供了多种方式将请求负载均衡到多个后端服务：</p><ul><li><strong>基于DNS</strong>的方法</li><li>动态的<strong>环均衡器</strong>(ring-balancer)，它还允许服务注册，而无需DNS服务器</li></ul><p><br></p><h3 id="基于DNS"><a href="#基于DNS" class="headerlink" title="基于DNS"></a>基于DNS</h3><p>DNS-based loadbalancing</p><p>使用基于DNS的负载均衡时，后端服务的注册是在Kong之外完成的，而Kong只接收来自DNS服务器的更新。</p><p>如果名称解析为多个IP地址，则使用包含主机名（而不是IP地址）的<code>host</code>定义的每个服务将自动使用基于DNS的负载均衡，前提是主机名未解析为<code>upstream</code>名称或你的DNS hosts。</p><p>DNS记录<code>ttl</code>确定刷新信息的频率。当<code>ttl</code>为0时，将使用自己的DNS查询解析每个请求。虽然这会有性能损失，但更新/更改的延迟将非常低。</p><p><br></p><h4 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h4><p>A记录包含一个或多个IP地址。因此，当主机名解析为A记录时，每个后端服务必须具有自己的IP地址。</p><p>由于没有<code>weight</code>(权重)信息，所有条目在负载均衡器中被视为相等的权重，并且均衡器将直接转发轮询(straight forward round-robin)。</p><p><br><br><br></p><h4 id="SRV记录"><a href="#SRV记录" class="headerlink" title="SRV记录"></a>SRV记录</h4><p>SRV记录包含其所有IP地址的权重和端口信息。后端服务可通过IP地址和端口号的唯一组合来识别。因此，单个IP地址可以在不同的端口上托管同一个服务的多个实例。</p><p>由于<code>weight</code>(权重)信息可用，每个条目将在负载均衡器中获取自己的权重，并执行加权轮询(weighted round-robin)。</p><p>同样，任何给定的端口信息都将被来自DNS Server的端口信息覆盖。如果服务具有<code>host=myhost.com, port=123</code>，并且<code>myhost.com</code>被解析为<code>127.0.0.1:456</code>的SRV记录，则该请求将代理到<code>http://127.0.0.1:456/somepath</code>，因为端口<code>123</code>被4<code>56</code>覆盖了。</p><p><br><br><br></p><h4 id="DNS优先级"><a href="#DNS优先级" class="headerlink" title="DNS优先级"></a>DNS优先级</h4><p>DNS解析器将按顺序开始解析以下记录类型：</p><ol><li>The last successful type previously resolved</li><li>SRV record</li><li>A record</li><li>CNAME record</li></ol><p>此顺序可通过<code>dns_order</code>配置属性进行配置。</p><p><br><br><br></p><h4 id="DNS注意事项"><a href="#DNS注意事项" class="headerlink" title="DNS注意事项"></a>DNS注意事项</h4><ul><li>每当刷新DNS记录时，都会生成一个列表以正确处理权重。</li><li>某些nameserver不返回所有条目(由于UDP包大小)，给定的Kong节点将仅使用nameserver提供的少数上游服务实例。在这种情况下，上游实例池可能会不一致地加载，因为由于nameserver提供的信息有限，Kong节点实际上没有意识到某些实例。要减轻这种使用，请使用其它nameserver，使用IP地址而不是名称，或确保使用足够的Kong节点仍然使用上游服务。</li><li>当nameserver返回<code>3 name error</code>错误时，那是对Kong的有效响应。如果这是意外，请首先验证正在查询的正确名称，然后在检查你的nameserver的配置。</li><li>从DNS记录（A/SRV）初始选择IP地址不是随机的。因此，当使用<code>ttl</code>为0的记录时，nameserver应该随机化记录条目。</li></ul><p><br><br><br></p><h3 id="Ring-balancer"><a href="#Ring-balancer" class="headerlink" title="Ring-balancer"></a>Ring-balancer</h3><p>当使用<strong>环均衡器</strong>时，Kong将处理后端服务的添加(add)和移除(remove)，并且不需要DNS更新。Kong将担任服务注册。可以使用单个HTTP请求添加/删除节点，并立即开始/停止接收流量</p><p>配置环均衡器是通过<code>upstream</code>和<code>target</code>目标实例完成的：</p><ul><li><code>target</code>：带有后端服务所在端口的IP地址或主机名。每个目标都有一个附加的<code>weight</code>以指示它获得的相对负载。IP地址可以是IPv4或IPv6格式。</li><li><code>upstream</code>：可在路由<code>host</code>字段中使用的虚拟主机名。例如名为<code>weather.v2.service</code>的上游，将获得来自具有<code>host=weather.v2.service</code>的服务的所有请求。</li></ul><p><br></p><h4 id="Upstream"><a href="#Upstream" class="headerlink" title="Upstream"></a>Upstream</h4><p>每个上游都有自己的环均衡器。每个<code>upstream</code>都可以附加许多<code>target</code>条目，代理到虚拟主机名的请求将在目标上进行负载均衡。换均衡器具有预定数量的插槽(slot)，并且基于目标权重，插槽被分配给上游的目标。</p><p>可使用Admin API上的简单HTTP请求来添加/移除目标。这个操作相对便宜，更改上游本身更加昂贵，因为当插槽数量发生变化时需要重建均衡器。</p><p>自动重建均衡器的唯一情况是清理目标历史记录时，除此之外，它只会在变化时重建。</p><p>在均衡器上有位置（from 1 to <code>slots</code>），它们随机分布(randomly distributed)在环上。随机性是在运行时调用环均衡器所必需的。轮子上的简单轮询将在目标上提供分布均匀的加权轮询，同时在 插入/删除 目标时也具有廉价操作。</p><p>每个目标使用的插槽数量应该(至少)为100，以确保插槽的正确分布。例如，对于预期最多8个目标，上游应定义至少<code>slots=800</code>，即使初识设置仅具有两个目标。</p><p>这里的权衡是，插槽数越多，随机分布越好，但更改成本越高(添加/删除目标)。</p><p><br><br><br></p><h4 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h4><p>由于上游(upstream)维护更改的历史记录，因此只能添加目标，不能修改或删除目标。要更改目标，只需为目标添加新条目，然后更改权重(weight)值。最后一个条目是将要使用的条目，因此，设置<code>weight=0</code>将禁用目标，从而有效地将其从均衡器中删除。</p><p>当非活动条目(inactive entries)比活动条目(active)多10倍时，将自动清理目标(target)。清理将涉及重建均衡器，因此仅比添加目标条目更昂贵。</p><p>目标也可以具有主机名（而不是IP地址）。在这种情况下，名称将被解析，所有找到的条目将单独添加到环形均衡器。如，添加<code>api.host.com:123, weight=100</code>。注意，权重用于单个条目，而不是整个。</p><p>如果它解析为SRV记录，那么DNS中的端口和权重字段也将被拾取，并且将覆盖给定的端口和权重。</p><p>均衡器将遵守DNS记录的<code>ttl</code>设定并重新查询(requery)和更新到期的均衡器。</p><p><br><br><br></p><h4 id="均衡算法"><a href="#均衡算法" class="headerlink" title="均衡算法"></a>均衡算法</h4><p>Balancing algorithms</p><p>默认情况下，环均衡器(ringn-balancer)将使用加权轮询方案(weighted-round-robin scheme)。替代方案是使用基于哈希(hash)的算法。哈希的输入可以是<code>none</code>, <code>consumer</code>, <code>ip</code>, <code>header</code>, <code>cookie</code>。当设置为<code>none</code>时，将使用加权轮询方案，并禁用哈希。<br>有两个选项，primary和fallback，以防主要失败。</p><p>不同的哈希选项：</p><ul><li><code>none</code>，不使用哈希，而是使用加权轮询（default）。</li><li><code>consumer</code>，使用消费者ID作为哈希输入。如果没有可用的消费者ID，则将回退到凭据ID。</li><li><code>ip</code>，远程IP地址用作输入。使用此选项时，请查看用于确定实际IP的配置设置。</li><li><code>header</code>，使用指定的header作为哈希的输入。</li><li><code>cookie</code>，使用指定路径的指定cookie作为哈希的输入。如果请求中不存在cookie，则响应将设置该cookie。</li></ul><p>哈希算法基于<strong>一致性哈希</strong>(consistent-hashing)，确保通过更改目标(add, remove, fail, weight)修改均衡器时，只有最小数量的哈希损失发生。这将最大化上游缓存命中(cache hits)。</p><p><br><br><br></p><h4 id="均衡警告"><a href="#均衡警告" class="headerlink" title="均衡警告"></a>均衡警告</h4><p>Balancing caveats</p><p>环均衡器设计用于单个节点以及集群。对于加权轮询算法没有太大的区别，但当使用基于哈希的算法时，重要的是所有节点构建完全相同的环均衡器以确保它们全部相同。为此，必须以确定的方式构建均衡器。</p><ul><li>不要再均衡器中使用主机名，因为均衡器 可能/将 慢慢发散，DNS ttl仅具有第二精度，并且更新由实际请求名称确定。最重要的一些NameServer没有返回所有条目的为题，这加剧了这个问题。因此，在Kong集群中使用哈希方法时，仅通过其IP地址添加目标(target)实体，而不是通过名称添加目标实体。</li><li>在选择哈希输入时，请确保输入具有足够的方差(variance)以获得分布均匀的哈希。哈希值将使用CRC-32摘要计算。</li></ul><p><br><br><br></p><h3 id="蓝绿部署"><a href="#蓝绿部署" class="headerlink" title="蓝绿部署"></a>蓝绿部署</h3><p>Blue-Green Deployments</p><p>使用环均衡器可以轻松地为服务编排<strong>蓝绿部署</strong>(blue-green deployment)。切换目标基础结构仅需要服务上的<code>PATCH</code>请求，以更改其<code>host</code>值。</p><p><br></p><p>设置<code>Blue</code>环境，运行 v1 的服务地址：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create an upstream</span></span><br><span class="line">curl -X POST http://kong:8001/upstreams \</span><br><span class="line">    --data <span class="string">"name=address.v1.service"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add two targets to the upstream</span></span><br><span class="line">curl -X POST http://kong:8001/upstreams/address.v1.service/targets \</span><br><span class="line">    --data <span class="string">"target=192.168.34.15:80"</span></span><br><span class="line">    --data <span class="string">"weight=100"</span></span><br><span class="line">curl -X POST http://kong:8001/upstreams/address.v1.service/targets \</span><br><span class="line">    --data <span class="string">"target=192.168.34.16:80"</span></span><br><span class="line">    --data <span class="string">"weight=50"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create a Service targeting the Blue upstream</span></span><br><span class="line">curl -X POST http://kong:8001/services/ \</span><br><span class="line">    --data <span class="string">"name=address-service"</span> \</span><br><span class="line">    --data <span class="string">"host=address.v1.service"</span> \</span><br><span class="line">    --data <span class="string">"path=/address"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># finally, add a Route as an entry-point into the Service</span></span><br><span class="line">curl -X POST http://kong:8001/services/address-service/routes/ \</span><br><span class="line">    --data <span class="string">"hosts[]=address.mydomain.com"</span></span><br></pre></td></tr></table></figure><p>主机头设置为<code>address.mydomain.com</code>的请求由Kong代理到两个定义的目标： 2/3的请求将转到<code>http://192.168.34.15:80/address</code>(weight=100)，1/3的请求将转到<code>http://192.168.34.16:80/address</code>(weight=50)。</p><p><br></p><p>在部署服务的v2之前，设置<code>Green</code>环境：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create a new Green upstream for address service v2</span></span><br><span class="line">curl -X POST http://kong:8001/upstreams \</span><br><span class="line">    --data <span class="string">"name=address.v2.service"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add targets to the upstream</span></span><br><span class="line">curl -X POST http://kong:8001/upstreams/address.v2.service/targets \</span><br><span class="line">    --data <span class="string">"target=192.168.34.17:80"</span></span><br><span class="line">    --data <span class="string">"weight=100"</span></span><br><span class="line">curl -X POST http://kong:8001/upstreams/address.v2.service/targets \</span><br><span class="line">    --data <span class="string">"target=192.168.34.18:80"</span></span><br><span class="line">    --data <span class="string">"weight=100"</span></span><br></pre></td></tr></table></figure><p><br></p><p>要激活蓝/绿开关，只需要更新服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Switch the Service from Blue to Green upstream, v1 -&gt; v2</span></span><br><span class="line">curl -X PATCH http://kong:8001/services/address-service \</span><br><span class="line">    --data <span class="string">"host=address.v2.service"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主机头为address.mydomain.com的传入请求现在由Kong代理到新目标</span></span><br><span class="line"><span class="comment"># 1/2的请求将转至http://192.168.34.17:80/address(weight=100)</span></span><br><span class="line"><span class="comment"># 另外1/2将转至`http://192.168.34.18:80/address`(weight=100)</span></span><br></pre></td></tr></table></figure><p>与往常一样，通过Kong Admin API进行的更改是动态的，并将立即生效。不需要重载或重启，也不会丢弃正在进行的请求。</p><p><br><br><br></p><h3 id="金丝雀发布"><a href="#金丝雀发布" class="headerlink" title="金丝雀发布"></a>金丝雀发布</h3><p>Canary Releases</p><p>使用环均衡器，可以精确调整目标权重，从而实现平稳、受控的金丝雀发布(canary release)。</p><p><br></p><p>两个简单栗子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># first target at 1000</span></span><br><span class="line">curl -X POST http://kong:8001/upstreams/address.v2.service/targets \</span><br><span class="line">    --data <span class="string">"target=192.168.34.17:80"</span></span><br><span class="line">    --data <span class="string">"weight=1000"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># second target at 0</span></span><br><span class="line">curl -X POST http://kong:8001/upstreams/address.v2.service/targets \</span><br><span class="line">    --data <span class="string">"target=192.168.34.18:80"</span></span><br><span class="line">    --data <span class="string">"weight=0"</span></span><br></pre></td></tr></table></figure><p><br></p><p>通过重复请求，但每次都改变权重，流量将慢慢地路由到另一个目标。例如，将其设置为<code>10%</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># first target at 900</span></span><br><span class="line">curl -X POST http://kong:8001/upstreams/address.v2.service/targets \</span><br><span class="line">    --data <span class="string">"target=192.168.34.17:80"</span></span><br><span class="line">    --data <span class="string">"weight=900"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># second target at 100</span></span><br><span class="line">curl -X POST http://kong:8001/upstreams/address.v2.service/targets \</span><br><span class="line">    --data <span class="string">"target=192.168.34.18:80"</span></span><br><span class="line">    --data <span class="string">"weight=100"</span></span><br></pre></td></tr></table></figure><p>通过Kong Admin API进行的更改是动态的，并将立即生效。不需要重新加载或重新启动，也不会丢弃正在进行的请求。</p><p><br><br><br><br><br></p><h2 id="蓝绿部署-AB测试-金丝雀发布"><a href="#蓝绿部署-AB测试-金丝雀发布" class="headerlink" title="蓝绿部署/AB测试/金丝雀发布"></a>蓝绿部署/AB测试/金丝雀发布</h2><p><a href="https://blog.christianposta.com/deploy/blue-green-deployments-a-b-testing-and-canary-releases/" target="_blank" rel="noopener">Blue-green Deployments, A/B Testing, and Canary Releases</a></p><p>许多团队对<strong>DevOps</strong>越来越感兴趣，这里面就涉及到了热部署(hot deployments)、回滚(rollbacks)…</p><p>亚马逊等已经实施了十年以上的蓝绿部署，它是一种安全、经过验证的方法。但A/B测试呢？金丝雀测试呢？对于MicroService、DevOps和cloud-Native，这里阐述一下它们的不同之处。</p><p><br></p><h3 id="蓝绿部署-1"><a href="#蓝绿部署-1" class="headerlink" title="蓝绿部署"></a>蓝绿部署</h3><p>Blue Green Deployments</p><p>它基本上是一种以可预测的方式(predictable manner)发布应用程序的技术，目标是减少与发布相关的任何停机时间。这是在发布之前准备应用程序的快速方法，如果你发现问题，也可以快速回滚。</p><p>简单地说，你有两个相同的环境。</p><p>绿环境：</p><p><img src="/images/Kong/greendeployment.png" alt></p><p>现在，你准备对应用程序进行更改并将其升级为v2，你将在蓝环境中执行此操作。</p><p><img src="/images/Kong/bluedeployment.png" alt></p><p>你可以监控因发布而导致的任何异常。如果一切都好，你最终可以关闭绿环境并使用它来发布任何新版本。如果异常，亦可以通过负载均衡器切换回来以快速回滚的绿环境。</p><p><br><br><br></p><h3 id="A-B测试"><a href="#A-B测试" class="headerlink" title="A/B测试"></a>A/B测试</h3><p>A/B Testing</p><p>A/B测试不是蓝绿部署。它是一种在应用程序中测试功能的方法，出于各种原因(如可用性、流行性、吸引性…)，以及这些因素如何影响底线。它通常与应用程序的UI部分相关联，但当然后端服务需要可用于执行此操作。你可以使用应用程序级别的开关、静态开关以及金丝雀发布来实现此功能。</p><p><img src="/images/Kong/abtesting.png" alt></p><p>蓝绿部署和A/B测试之间的区别在于A/B测试用于测量应用程序中的功能。</p><p><br><br><br></p><h3 id="金丝雀发布-1"><a href="#金丝雀发布-1" class="headerlink" title="金丝雀发布"></a>金丝雀发布</h3><p>Canary releases</p><p>金丝雀发布是一种将新版本的应用程序发送到生产环境中的方式。它扮演金丝雀的角色，以了解它将如何执行。这是另一种发布策略，它可以环境这样一个事实，即无论你在较低环境中进行的测试水平如何，仍会在生产中遇到一些错误。金丝雀发布允许你在完全释放扳机之前测试水域。</p><p><img src="/images/Kong/canarydeployment.png" alt></p><p>你获得的反馈速度越快，部署失败的速度就越快，或谨慎行事。</p><p><br><br><br><br><br></p><h2 id="健康检查和熔断器"><a href="#健康检查和熔断器" class="headerlink" title="健康检查和熔断器"></a>健康检查和熔断器</h2><p><a href="https://docs.konghq.com/1.1.x/health-checks-circuit-breakers/" target="_blank" rel="noopener">Health Checks and Circuit Breakers Reference</a></p><p>你可以使用Kong 环均衡器代理API，通过添加包含一个或多个目标实体的上游实体进行配置，每个目标指向不同的IP和端口。环均衡器将平衡各种目标之间的负载，并且基于上游配置，将对目标执行健康检查，将判断它们是否健康，无论它们是否响应。然后，环均衡器仅将流量路由到健康目标。</p><p>Kong支持两种健康检查，可单独使用或结合使用：</p><ul><li><strong>主动检测(active checks)</strong>，定期请求目标中的特定HTTP/HTTPS端点，并根据其响应确定目标的运行状况；</li><li><strong>被动检测(passive checks)（也称为熔断器）</strong>，Kong分析正在进行的代理流量，并根据其行为响应请求确定目标的运行状况。</li></ul><p><br><br><br></p><h3 id="健康与不健康"><a href="#健康与不健康" class="headerlink" title="健康与不健康"></a>健康与不健康</h3><p>Healthy and unhealthy targets</p><p>健康检查功能的目的是为给定的Kong节点动态地将目标标记为健康或不健康。没有集群范围内的健康信息同步：每个Kong节点分别确定其目标的健康状况。这是可取的，因为在给定端点，一个Kong节点可能能够成功连接到目标而另一个Kong节点不能到达它：第一个节点将认为它是健康的，而另一个节点将其标记为不健康并开始将流量路由到上游的其它目标。</p><p>活动探测（主动健康检查）或代理请求（被动健康检查）会生成用于确定目标是健康还是不健康的数据。请求可能会产生<code>TCP error、timeout</code>, <code>HTTP status code</code>。基于此信息，健康检查器更新一些列内部计数器：</p><ul><li>如果返回的状态码是一个配置为<strong>健康(healthy)</strong>的状态码，它将递增目标的<strong>成功(Successes)</strong>计数器并清除其它计数器；</li><li>如果连接失败，它将递增目标的<strong>TCP failures</strong>计数器并清除<strong>Successes</strong>计数器；</li><li>如果超时，它将递增目标的<strong>超时(timeouts)</strong>计数器并清除<strong>Successes</strong>计数器；</li><li>如果返回的HTTP状态码是配置为<strong>不健康(unhealthy)</strong>的状态码，它将递增<code>HTTP failures</code>计数器并清除<strong>Successes</strong>计数器。</li></ul><p>如果任何<code>TCP failures</code>, <code>HTTP failures</code>, <code>timeouts</code>计数器达到其配置的阈值，则目标将被标记为不健康。<br>如果<code>Successes</code>计数器达到其配置的阈值，则目标将标记为健康。</p><p>HTTP状态码的列表是健康或不健康，并且每个计数器的各个阈值可以基于每个上游进行配置。下面的栗子中，我们有一个上游实体的配置示例。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"service.v1.xyz"</span>,</span><br><span class="line">    <span class="attr">"healthchecks"</span>: &#123;</span><br><span class="line">        <span class="attr">"active"</span>: &#123;</span><br><span class="line">            <span class="attr">"concurrency"</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="attr">"healthy"</span>: &#123;</span><br><span class="line">                <span class="attr">"http_statuses"</span>: [ <span class="number">200</span>, <span class="number">302</span> ],</span><br><span class="line">                <span class="attr">"interval"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"successes"</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"http_path"</span>: <span class="string">"/"</span>,</span><br><span class="line">            <span class="attr">"timeout"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"unhealthy"</span>: &#123;</span><br><span class="line">                <span class="attr">"http_failures"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"http_statuses"</span>: [ <span class="number">429</span>, <span class="number">404</span>, <span class="number">500</span>, <span class="number">501</span>,</span><br><span class="line">                                   <span class="number">502</span>, <span class="number">503</span>, <span class="number">504</span>, <span class="number">505</span> ],</span><br><span class="line">                <span class="attr">"interval"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"tcp_failures"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"timeouts"</span>: <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"passive"</span>: &#123;</span><br><span class="line">            <span class="attr">"healthy"</span>: &#123;</span><br><span class="line">                <span class="attr">"http_statuses"</span>: [ <span class="number">200</span>, <span class="number">201</span>, <span class="number">202</span>, <span class="number">203</span>,</span><br><span class="line">                                   <span class="number">204</span>, <span class="number">205</span>, <span class="number">206</span>, <span class="number">207</span>,</span><br><span class="line">                                   <span class="number">208</span>, <span class="number">226</span>, <span class="number">300</span>, <span class="number">301</span>,</span><br><span class="line">                                   <span class="number">302</span>, <span class="number">303</span>, <span class="number">304</span>, <span class="number">305</span>,</span><br><span class="line">                                   <span class="number">306</span>, <span class="number">307</span>, <span class="number">308</span> ],</span><br><span class="line">                <span class="attr">"successes"</span>: <span class="number">0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"unhealthy"</span>: &#123;</span><br><span class="line">                <span class="attr">"http_failures"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"http_statuses"</span>: [ <span class="number">429</span>, <span class="number">500</span>, <span class="number">503</span> ],</span><br><span class="line">                <span class="attr">"tcp_failures"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"timeouts"</span>: <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"slots"</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上游的所有目标都不健康，Kong将以<code>503 Service Unavailable</code>响应上游请求。</p><p>注意：</p><ul><li>健康检查操作仅在活跃目标(acti)上运行，不会修改Kong数据库中目标的活动状态；</li><li>不健康的目标不会从负载均衡器中移除，因此在使用HASH算法时不会对均衡器布局产生任何影响；</li><li><code>DNS caveats</code>和<code>balancer caveats</code>也适用于健康检查。如果为目标使用主机名，请确保DNS服务器始终返回名称的完整IP地址集，并且不限制响应。如果不这样做可能导致健康检查无法执行。</li></ul><p><br><br><br></p><h3 id="健康检查类型"><a href="#健康检查类型" class="headerlink" title="健康检查类型"></a>健康检查类型</h3><p><br></p><h4 id="主动检查"><a href="#主动检查" class="headerlink" title="主动检查"></a>主动检查</h4><p>Active health checks</p><p>顾名思义，主动检查会主动探索目标健康。当在上游实体中启用活动运行状况检查时，Kong将定期向上游的每个目标配置得路径发送HTTP/HTTPS请求。这允许Kong根据结果自动启用和禁用均衡器中的目标。</p><p>当目标健康或不健康时，可以单独配置主动健康检查的周期性。如果其中的一个<code>interval</code>值设置为0，则在相应的方案中禁用检查。当两者都为0时，将完全禁用主动健康检查。</p><blockquote><p><strong>注意：</strong><br>主动健康检查目前仅支持HTTP/HTTPS目标。它们不适用于分配给上游协议属性为<code>TCP</code>或<code>TLS</code>。</p></blockquote><p><br><br><br></p><h4 id="被动检查-熔断器"><a href="#被动检查-熔断器" class="headerlink" title="被动检查(熔断器)"></a>被动检查(熔断器)</h4><p>Passive health checks (circuit breakers)</p><p>被动健康检查(熔断器)，是根据Kong（HTTP/HTTPS/TCP）代理的请求执行的检查，不会产生额外的流量。当目标变得无响应时，被动检查程序将检测到该目标，并将目标标记为不健康。环均衡器将开始条多此目标，因此不再将流量路由到该目标。</p><p>一旦目标的问题解决了，并且它已准备好再次接收流量，Kong管理员可以通过Admin API端点手动通知健康检查器应该再次启用目标：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST http://localhost:8001/upstreams/my_upstream/targets/10.1.2.3:1234/healthy</span><br><span class="line">HTTP/1.1 204 No Content</span><br></pre></td></tr></table></figure><p>此命令将在集群内广播消息，以便将<code>healthy</code>状态传播到整个Kong集群。这将导致Kong节点重置在Kong节点的所有工作程序中运行的健康检查程序的运行状况计数器，从而允许环均衡器再次将流量路由到目标。<br>被动检查的优点是不是产生额外的流量，但是它们无法再自动将目标标记为健康：电路以损坏，并且管理员需要再次重新启用目标。</p><p><br><br><br></p><h3 id="利弊"><a href="#利弊" class="headerlink" title="利弊"></a>利弊</h3><p>Summary of pros and cons</p><ul><li>主动健康检查可在环均衡器再次恢复健康时自动重启环均衡器中的目标。被动健康检查则不能。</li><li>被动健康检查不会为目标产生额外的流量。主动健康检查会。</li><li>主动健康检查器要求在目标中具有可靠状态响应的已知的URL，以将其配置探测端点(probe endpoint)。被动模式不要求这样配置。</li><li>通过为主动健康检查程序提供自定义的探测端点，应用程序可确定自己的运行状态指标并生成由Kong使用的状态码。即使目标继续提供对被动健康检查其看起来健康的流量，它也能够响应具有故障状态的主动探测，基本上要求放心接收新的流量。</li></ul><p>可以组合这两种模式。例如，启用被动检查根据其流量监控目标的健康状态，并仅在目标运行状态不佳时使用主动检查，以便自动重新启用它。</p><p><br><br><br></p><h3 id="启用和禁用健康检查"><a href="#启用和禁用健康检查" class="headerlink" title="启用和禁用健康检查"></a>启用和禁用健康检查</h3><p><br></p><h4 id="启用主动检查"><a href="#启用主动检查" class="headerlink" title="启用主动检查"></a>启用主动检查</h4><p>Enabling active health checks</p><p>要启用主动健康检查，你需要在Upstream对象配置中指定<code>healthchecks.active</code>下的配置项。你需要指定必要的信息，以便Kong可以对目标执行定期探测，以及如何解释结果信息。</p><p>你可使用<code>healthchecks.active.type</code>字段指定执行哪种探测（HTTP/HTTPS），或者只测试与给定主机和端口的连接是否成功（TCP）。</p><p>要配置探针，你需要指定：</p><ul><li><code>healthchecks.active.http_path</code>： 默认为根目录(<code>/</code>)</li><li><code>healthchecks.active.timeout</code>： 默认为1s</li><li><code>healthchecks.active.concurrency</code>： 同时检查的目标数</li></ul><p>对于运行的探针，你还需要指定间隔值：</p><ul><li><code>healthchecks.active.healthy.interval</code>： 值为0，表示不执行健康目标的主动探测</li><li><code>healthchecks.active.unhealthy.interval</code>： 值为0，表示不执行不健康目标的主动探测</li></ul><p>如果使用HTTPS健康检查，则还可以指定一下字段：</p><ul><li><code>healthchecks.active.https_verify_certificate</code>： 是否检查远程主机的SSL证书的有效性</li><li><code>healthchecks.active.https_sni</code>： 使用SNI的主机名验证</li></ul><p>最后，你需要通过设置健康计数器上的各种阈值来配置Kong应该如何解释探测器，一旦达到该阈值将触发状态改变。计数器阈值字段：</p><ul><li><code>healthchecks.active.healthy.successes</code></li><li><code>healthchecks.active.healthy.http_statuses</code></li><li><code>healthchecks.active.unhealthy.tcp_failures</code></li><li><code>healthchecks.active.unhealthy.timeouts</code></li><li><code>healthchecks.active.unhealthy.http_failures</code></li></ul><p><br><br><br></p><h4 id="启用被动检查"><a href="#启用被动检查" class="headerlink" title="启用被动检查"></a>启用被动检查</h4><p>Enabling passive health checks</p><p>被动健康检查不具有探测功能，因为它们通过解释从目标流出的持续流量来工作。这意味着要启用被动检查，你只需要配置其计数器阈值：</p><ul><li><code>healthchecks.passive.healthy.successes</code></li><li><code>healthchecks.passive.healthy.http_statuses</code></li><li><code>healthchecks.passive.unhealthy.tcp_failures</code></li><li><code>healthchecks.passive.unhealthy.timeouts</code></li><li><code>healthchecks.passive.unhealthy.http_failures</code></li></ul><p><br><br><br></p><h4 id="禁用健康检查"><a href="#禁用健康检查" class="headerlink" title="禁用健康检查"></a>禁用健康检查</h4><p>Disabling health checks</p><p>在<code>healthchecks</code>配置中指定的所有计数器阈值和间隔中，将值设置为0意味着禁用该字段代表的功能。将探测间隔设置为0会禁用探针。同样，你可通过将其计数器阈值设置为0来禁用某些类型的检查。</p><p><br><br><br><br><br></p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p><a href="https://docs.konghq.com/1.2.x/clustering/" target="_blank" rel="noopener">Clustering Reference</a></p><p>Kong集群允许你通过添加更过计算机来处理更多的传入情趣，从而水平扩展系统。它们将共享相同的配置，因为它们指向同一个数据库。指向同一数据存储区(same datastore)的Kong Node将成为同一Kong集群的一部分。</p><p>你需要在Kong集群前安装负载均衡器，以便在可用节点之间分配流量。</p><p><br><br><br></p><h3 id="集群能做些什么"><a href="#集群能做些什么" class="headerlink" title="集群能做些什么"></a>集群能做些什么</h3><p>What a Kong cluster does and doesn’t do</p><p>拥有Kong集群并不意味着你的客户流量将在Kong节点之间进行负载均衡。你仍然需要在Kong节点前安装负载均衡器来分配流量。相反，Kong集群意味着这些节点将共享相同的配置。</p><p>出于性能原因，Kong在代理请求时避免数据库连接，并将数据库的内容缓存在内存中。缓存的实体包括<code>Services, Routes, Consumers, Plugins, Credentials...</code>，由于这些值在内存中，因此通过其中一个节点的Admin API进行的任何更改都需要传播到其它节点。</p><p><br><br><br></p><h3 id="单节点集群"><a href="#单节点集群" class="headerlink" title="单节点集群"></a>单节点集群</h3><p>Single node Kong clusters</p><p>连接到数据库(PgSQL/Cassandra)的单个Kong节点创建一个节点的Kong集群。通过此节点的Admin API应用的任何更改都将立即生效。</p><p><br><br><br></p><h3 id="多节点集群"><a href="#多节点集群" class="headerlink" title="多节点集群"></a>多节点集群</h3><p>Multiple nodes Kong clusters</p><p>在多节点的Kong集群中，连接到同一个数据库的其它节点不会立即被通知（如节点A删除了某个服务）。虽然此服务不再存在于数据库中（它被节点A删除），但它仍然在节点B的内存中。</p><p>所有节点执行定期后台作业以与可能由其它节点触发的更改进行同步。通过以下方式配置此作业的频率： <code>db_update_frequency</code>（(default: 5s）。每个频率时间，所有正在运行的Kong节点将轮询数据库以进行任何更新，并在必要时从其缓存中清除(purge)相关实体。</p><p>如果节点A删除了某个服务，则此更改在节点B中将无效，直到节点B的下一次数据库轮询。<br>这使得Kong集群最终保持一致(eventually consistent)。</p><p><br><br><br></p><h3 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h3><p>What is being cached?</p><p>所有核心实体（如Services, Routes, Plugins, Consumers, Credentials…)都由Kong缓存在内存中，并依赖于通过轮询机制进行的无效更新。<br>除此之外，Kong还缓存了<code>database misses</code>。这意味着如果你配置没有插件的服务，Kong将缓存此信息。</p><p><br><br><br></p><h3 id="配置数据库缓存"><a href="#配置数据库缓存" class="headerlink" title="配置数据库缓存"></a>配置数据库缓存</h3><p>How to configure database caching?</p><p>你可以在Kong配置文件中配置3个属性，最重要的一个是<code>db_update_frequency</code>，它确定Kong节点在性能与一致性权衡方面的位置。<br>Kong提供了一致性的默认值，以便让你在避免意外的同事试验其聚类功能。在准备生产环境设置时，应考虑调整这些值以确保遵守性能约束。</p><ul><li><code>db_update_frequency</code>，(default: 5s)</li><li><code>db_update_propagation</code>，(default: 0s)</li><li><code>db_cache_ttl</code>，(default: 0s)</li></ul><p><br><br><br></p><h3 id="通过Admin-API与Cache进行交互"><a href="#通过Admin-API与Cache进行交互" class="headerlink" title="通过Admin API与Cache进行交互"></a>通过Admin API与Cache进行交互</h3><p>Interacting with the cache via the Admin API</p><p>出于某些原因，你希望调查缓存的值，或手动使缓存的值无效（hit/miss），则可通过Admin API <code>/cache</code>端点执行此操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Inspect a cached value</span></span><br><span class="line">GET /cache/&#123;cache_key&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Purge a cached value</span></span><br><span class="line">DELETE /cache/&#123;cache_key&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Purge a node’s cache</span></span><br><span class="line">DELETE /cache</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p><a href="https://docs.konghq.com/1.2.x/logging/" target="_blank" rel="noopener">Logging Reference</a></p><p>日志级别在Kong的配置文件中配置。有以下几种日志级别：</p><ul><li><code>debug</code></li><li><code>info</code></li><li><code>notice</code>，默认和建议使用的日志级别。</li><li><code>warn</code></li><li><code>error</code></li><li><code>crit</code></li></ul><p><br><br><br><br><br></p><h2 id="网络和防火墙"><a href="#网络和防火墙" class="headerlink" title="网络和防火墙"></a>网络和防火墙</h2><p><a href="https://docs.konghq.com/1.2.x/network/" target="_blank" rel="noopener">Network and Firewall</a></p><p><br><br><br></p><h3 id="Ports"><a href="#Ports" class="headerlink" title="Ports"></a>Ports</h3><p>Kong为不同目的使用多个连接：</p><ul><li>Proxy<ul><li><code>8000</code> for proxying HTTP traffic</li><li><code>8443</code> for proxying HTTPS traffic</li></ul></li><li>Admin API<ul><li><code>8001</code> Admin API with HTTP</li><li><code>8444</code> Admin API with HTTPS</li></ul></li></ul><p><br><br><br></p><h3 id="Firewall"><a href="#Firewall" class="headerlink" title="Firewall"></a>Firewall</h3><p>以下是推荐的防火墙设置：</p><ul><li>Kong后面的上游服务将通过<code>proxy_listen</code>接口/端口值提供。根据你要授予上游服务的访问级别配置这些值；</li><li>如果要将Admin API绑定到公众接口（通过<code>admin_listen</code>），请将其保护为仅允许受信任的客户端访问；</li><li>你的代理需要为你配置的任何HTTP/HTTPS和TCP/TLS流监听器添加规则。</li></ul><p><br></p><p><strong>透明代理(Transparent Proxying)</strong></p><p><code>transparent</code> 监听选项可以应用于<code>proxy_listen</code>和<code>stream_listen</code>配置。</p><p><br><br><br><br><br></p><h2 id="保护Admin-API"><a href="#保护Admin-API" class="headerlink" title="保护Admin API"></a>保护Admin API</h2><p><a href="https://docs.konghq.com/1.2.x/secure-admin-api/" target="_blank" rel="noopener">Securing the Admin API</a></p><p>Kong Admin API提供了RESTful接口来管理和配置Services, Routes, Plugins, Consumers, Credentials…由于此API允许完全控制Kong，因此保护它的安全非常重要。</p><p><br><br><br></p><h3 id="网络层访问限制"><a href="#网络层访问限制" class="headerlink" title="网络层访问限制"></a>网络层访问限制</h3><p>Network Layer Access Restrictions</p><p><br></p><h4 id="最小化监听"><a href="#最小化监听" class="headerlink" title="最小化监听"></a>最小化监听</h4><p>Minimal Listening Footprint</p><p>默认情况下，Kong Admin将仅接受来自本地接口的请求。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">admin_listen</span> <span class="string">=</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8001,</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8444</span> <span class="string">ssl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 千万别使用0.0.0.0:8001</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="三层四层网络控制"><a href="#三层四层网络控制" class="headerlink" title="三层四层网络控制"></a>三层四层网络控制</h4><p>Layer 3/4 Network Controls</p><p>如果Admin API必须在localhost之外公开，则网络安全最佳实践要求尽可能限制网络层访问。基于主机的防火墙很有用，或云厂商的防火墙。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># assume that Kong is listening on the address defined below, as defined as a</span></span><br><span class="line"><span class="comment"># /24 CIDR block, and only a select few hosts in this range should have access</span></span><br><span class="line"></span><br><span class="line">$ grep admin_listen /etc/kong/kong.conf</span><br><span class="line">admin_listen 10.10.10.3:8001</span><br><span class="line"></span><br><span class="line"><span class="comment"># explicitly allow TCP packets on port 8001 from the Kong node itself</span></span><br><span class="line"><span class="comment"># this is not necessary if Admin API requests are not sent from the node</span></span><br><span class="line">$ iptables -A INPUT -s 10.10.10.3 -m tcp -p tcp --dport 8001 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># explicitly allow TCP packets on port 8001 from the following addresses</span></span><br><span class="line">$ iptables -A INPUT -s 10.10.10.4 -m tcp -p tcp --dport 8001 -j ACCEPT</span><br><span class="line">$ iptables -A INPUT -s 10.10.10.5 -m tcp -p tcp --dport 8001 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># drop all TCP packets on port 8001 not in the above IP list</span></span><br><span class="line">$ iptables -A INPUT -m tcp -p tcp --dport 8001 -j DROP</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="API-Loopback"><a href="#API-Loopback" class="headerlink" title="API Loopback"></a>API Loopback</h3><p>Kong的路由设计允许它作为Admin API自身的代理。通过这种方式，Kong本身可用于为Admin API提供细粒度的访问控制。（如需要为其定义服务的URL）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># assume that Kong has defined admin_listen as 127.0.0.1:8001, and we want to</span></span><br><span class="line"><span class="comment"># reach the Admin API via the url `/admin-api`</span></span><br><span class="line"></span><br><span class="line">$ curl -X POST http://localhost:8001/services \</span><br><span class="line">  --data name=admin-api \</span><br><span class="line">  --data host=localhost \</span><br><span class="line">  --data port=8001</span><br><span class="line"></span><br><span class="line">$ curl -X POST http://localhost:8001/services/admin-api/routes \</span><br><span class="line">  --data paths[]=/admin-api</span><br><span class="line"></span><br><span class="line"><span class="comment"># we can now transparently reach the Admin API through the proxy server</span></span><br><span class="line">$ curl localhost:8000/admin-api/apis</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"data"</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">"uris"</span>:[</span><br><span class="line">            <span class="string">"\/admin-api"</span></span><br><span class="line">         ],</span><br><span class="line">         <span class="string">"id"</span>:<span class="string">"653b21bd-4d81-4573-ba00-177cc0108dec"</span>,</span><br><span class="line">         <span class="string">"upstream_read_timeout"</span>:60000,</span><br><span class="line">         <span class="string">"preserve_host"</span>:<span class="literal">false</span>,</span><br><span class="line">         <span class="string">"created_at"</span>:1496351805000,</span><br><span class="line">         <span class="string">"upstream_connect_timeout"</span>:60000,</span><br><span class="line">         <span class="string">"upstream_url"</span>:<span class="string">"http:\/\/localhost:8001"</span>,</span><br><span class="line">         <span class="string">"strip_uri"</span>:<span class="literal">true</span>,</span><br><span class="line">         <span class="string">"https_only"</span>:<span class="literal">false</span>,</span><br><span class="line">         <span class="string">"name"</span>:<span class="string">"admin-api"</span>,</span><br><span class="line">         <span class="string">"http_if_terminated"</span>:<span class="literal">true</span>,</span><br><span class="line">         <span class="string">"upstream_send_timeout"</span>:60000,</span><br><span class="line">         <span class="string">"retries"</span>:5</span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="string">"total"</span>:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里，只需像往常一样对任何其它Kong API应用所需的特定于Kong的安全控件。</p><p><br><br><br></p><h3 id="自定Nginx配置"><a href="#自定Nginx配置" class="headerlink" title="自定Nginx配置"></a>自定Nginx配置</h3><p>Kong于Nginx紧密结合，作为HTTP daemon，因此可以集成到具有自定义Nginx配置的环境中。通过这种方式，具有复杂<code>security/access control</code>要求的用例可以使用Nginx/OpenResty的全部功能来构建<code>server/location</code>块以根据需要容纳Admin API。除了提供可以构建自定义、复杂安全性控件的OpenResty环境之外，这允许此类环境利用本机Nginx授权和身份认证机制、ACL模块等。</p><p><br><br><br></p><h3 id="基于角色的访问控制"><a href="#基于角色的访问控制" class="headerlink" title="基于角色的访问控制"></a>基于角色的访问控制</h3><p>Role Based Access Control</p><blockquote><p>Enterprise-Only This feature is only available with an Enterprise Subscription.</p></blockquote><p><br><br><br><br><br></p><h2 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h2><p><a href="https://docs.konghq.com/1.2.x/plugin-development/" target="_blank" rel="noopener">Plugin Development Introduction</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Admin-API"><a href="#Admin-API" class="headerlink" title="Admin API"></a>Admin API</h1><p><a href="https://docs.konghq.com/1.2.x/admin-api/" target="_blank" rel="noopener">Admin API</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="k8s-Ingress"><a href="#k8s-Ingress" class="headerlink" title="k8s Ingress"></a>k8s Ingress</h1><p><a href="https://konghq.com/solutions/kubernetes-ingress/" target="_blank" rel="noopener">Kong Kubernetes Ingress</a></p><p>控制你的集群。拥有而不需管理k8s集群。Kong Ingress Controller在k8s集群中实现了认证(authentication)、转换(transformation)和其它功能，无需停机。</p><p>弥合传统和云原生之间的差距。Kong将k8s集群于跨任何环境或平台运行的服务连接起来——从数据中心到多云、裸机到容器。</p><p><br></p><p><img src="/images/Kong/KongK8sIngress.png" alt></p><p><br></p><p><img src="/images/Kong/KongK8sIngress2.png" alt></p><p><br></p><p><img src="/images/Kong/KongK8sIngress3.png" alt></p><p><br><br><br></p><h2 id="Kong-on-K8s"><a href="#Kong-on-K8s" class="headerlink" title="Kong on K8s"></a>Kong on K8s</h2><p><a href="https://docs.konghq.com/install/kubernetes/" target="_blank" rel="noopener">Kong and Kong Enterprise on Kubernetes</a></p><p><br><br><br></p><h3 id="Announcing-the-Kubernetes-Ingress-Controller-for-Kong"><a href="#Announcing-the-Kubernetes-Ingress-Controller-for-Kong" class="headerlink" title="Announcing the Kubernetes Ingress Controller for Kong"></a>Announcing the Kubernetes Ingress Controller for Kong</h3><p><a href="https://konghq.com/blog/kubernetes-ingress-controller-for-kong/" target="_blank" rel="noopener">Announcing the Kubernetes Ingress Controller for Kong</a></p><p>今天，我们很高兴地宣布 Kubernetes Ingress Controller for Kong。</p><p>容器编排正在迅速变化，以满足软件基础架构的需求，这需要比以往更高的可靠性(reliability)、灵活性(flexibility)和效率(efficiency)。k8s正是这些工具的最前沿。</p><p>但是，这些工作负载的关键是一个网络堆栈（可以支持大规模集群容器协调器的高度动态化部署）。</p><p>Kong是一个高性能的开源API Gateway、 Traffic Control、MicroServices Management Layer，可支持这些工作负载所需的苛刻的网络要求。然而，Kong并没有强迫团队采用一刀切(one-size-fits-all)的解决方案。为了为深入的软件和企业生态系统提供流量，Kong提供了一个丰富的插件生态系统，扩展了Kong的认证、流量控制…</p><p>将Kong部署到k8s是一个简单的过程，但将k8s与Kongd的服务集成是一个手动过程。这就是为什么我们很高兴宣布 <a href="https://github.com/Kong/kubernetes-ingress-controller" target="_blank" rel="noopener">Kong Ingress Controller for Kubernetes</a>。</p><p>通过与<a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener">k8s Ingress Controller Spec</a>集成，Kong直接与k8s生命周期相关联。随着应用程序的部署和新服务的创建，Kong将自动进行实时配置。</p><p><br></p><p><img src="/images/Kong/kong-kubernetes-ingress-controller.png" alt></p><p><br><br><br></p><h4 id="配置Kong-Ingress-Controller"><a href="#配置Kong-Ingress-Controller" class="headerlink" title="配置Kong Ingress Controller"></a>配置Kong Ingress Controller</h4><p>可参考GitHub的相关文档设置Kong k8s Ingress Controller。只需安装必需的k8s清单，如Ingress Controller Deployment自身、前端服务、Kong访问k8s API paths需要的所有RBAC组件。</p><p>这些清单适用于任何k8s集群。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.githubusercontent.com/Kong/kubernetes-ingress-controller/master/deploy/single/all-in-one-postgres.yaml \</span><br><span class="line">| kubectl create -f -</span><br></pre></td></tr></table></figure><p>安装Kong Ingress Controller之后，我们现在可以开始部署Services和Ingress Resource，以便Kong可以开始为我们的集群资源提供流量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将测试服务部署到k8s集群</span></span><br><span class="line">curl https://raw.githubusercontent.com/Kong/kubernetes-ingress-controller/master/deploy/manifests/dummy-application.yaml \</span><br><span class="line">| kubectl create -f -</span><br></pre></td></tr></table></figure><p>这部署了我们的测试应用，但我们仍需要一个Ingress Resource来为它提供流量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用以下清单为测试应用创建一个Ingress</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"</span></span><br><span class="line"><span class="string">apiVersion: extensions/v1beta1</span></span><br><span class="line"><span class="string">kind: Ingress</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">name: foo-bar</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">rules:</span></span><br><span class="line"><span class="string">- host: foo.bar</span></span><br><span class="line"><span class="string">http:</span></span><br><span class="line"><span class="string">paths:</span></span><br><span class="line"><span class="string">- path: /</span></span><br><span class="line"><span class="string">backend:</span></span><br><span class="line"><span class="string">serviceName: http-svc</span></span><br><span class="line"><span class="string">servicePort: 80</span></span><br><span class="line"><span class="string">"</span> | kubectl create -f -</span><br></pre></td></tr></table></figure><p>通过部署我们的Kong Ingress Controller和我们的测试应用，我们现在可以开始为应用提供流量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># export PROXY_IP=$(minikube   service -n kong kong-proxy --url --format &quot;&#123;&#123; .IP &#125;&#125;&quot; | head -1)</span><br><span class="line"># export HTTP_PORT=$(minikube  service -n kong kong-proxy --url --format &quot;&#123;&#123; .Port &#125;&#125;&quot; | head -1)</span><br><span class="line"># curl -vvvv $PROXY_IP:$HTTP_PORT -H &quot;Host: foo.bar&quot;</span><br><span class="line">curl -vvvv kong-ip:kong-port -H &quot;Host: foo.bar&quot;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h4><p>Kong Ingress Controller中的插件作为<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" target="_blank" rel="noopener">k8s自定义资源(Custom Resource Definitions(CRDs))</a>来公开。它是k8s API Server上的第三方API对象，操作人员可以定义这些对象。</p><p>让我们在Kong示例中添加速率限制插件(rate limiting plugin)，并将其绑定到我们的Ingress Resource。Plugin与Ingress Resource一对一映射，使我们能够将插件应用于上游服务的方式进行细致的控制。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"</span></span><br><span class="line"><span class="string">apiVersion: configuration.konghq.com/v1</span></span><br><span class="line"><span class="string">kind: KongPlugin</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">name: add-ratelimiting-to-route</span></span><br><span class="line"><span class="string">config:</span></span><br><span class="line"><span class="string">hour: 100</span></span><br><span class="line"><span class="string">limit_by: ip</span></span><br><span class="line"><span class="string">second: 10</span></span><br><span class="line"><span class="string">"</span> | kubectl create -f -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl patch</span></span><br><span class="line"><span class="comment"># 使用 strategic merge patch 更新一个资源的 field(s)</span></span><br><span class="line">kubectl patch ingress foo-bar \</span><br><span class="line">-p <span class="string">'&#123;"metadata":&#123;"annotations":&#123;"rate-limiting.plugin.konghq.com":"add-ratelimiting-to-route\n"&#125;&#125;&#125;'</span></span><br></pre></td></tr></table></figure><p>现在应用了这个规则，我们再次访问我们的服务端点以获得以下响应：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">curl -vvvv <span class="variable">$PROXY_IP</span>:<span class="variable">$HTTP_PORT</span> -H <span class="string">"Host: foo.bar"</span></span><br><span class="line"></span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line"></span><br><span class="line">&gt; Host: foo.bar</span><br><span class="line"></span><br><span class="line">&gt; User-Agent: curl/7.54.0</span><br><span class="line"></span><br><span class="line">&gt; Accept: */*</span><br><span class="line"></span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">&lt; Content-Type: text/html; charset=ISO-8859-1</span><br><span class="line"></span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&lt; X-RateLimit-Limit-hour: 100</span><br><span class="line"></span><br><span class="line">&lt; X-RateLimit-Remaining-hour: 99</span><br><span class="line"></span><br><span class="line">&lt; X-RateLimit-Limit-second: 10</span><br><span class="line"></span><br><span class="line">&lt; X-RateLimit-Remaining-second: 9</span><br></pre></td></tr></table></figure><p>我们立即看到了我们的rate limiting headers已经应用，并可用于此端点。如果我们部署另一个Service和Ingress，我们的rate limit plugin将不适用，除非我们创建一个具有自己配置的新的KongPlugin资源并将注释添加到我们的新的Ingress。</p><p>现在我们有一个功能齐全的API Gateway Ingress Stack，完整的测试应用和速率限制插件。你已准备好使用Kong控制你的微服务！</p><p>跟上GitHub Kong Ingress Controller，请求新功能或报告问题。</p><p><br><br><br></p><h3 id="K8s-Ingress-Controller-for-Kong"><a href="#K8s-Ingress-Controller-for-Kong" class="headerlink" title="K8s Ingress Controller for Kong"></a>K8s Ingress Controller for Kong</h3><p>GitHub: <a href="https://github.com/Kong/kubernetes-ingress-controller" target="_blank" rel="noopener">https://github.com/Kong/kubernetes-ingress-controller</a></p><p>使用官方<a href="https://github.com/Kong/kubernetes-ingress-controller" target="_blank" rel="noopener">k8s Ingress Controller</a>安装Kong。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kong GitHub: &lt;a href=&quot;https://github.com/Kong/kong&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Kong/kong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kong Docs: &lt;a href=&quot;https://docs.konghq.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.konghq.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ELRH7x86_64&lt;/li&gt;
&lt;li&gt;Kong v1.2&lt;/li&gt;
&lt;li&gt;Docker CE v18.09&lt;/li&gt;
&lt;li&gt;K8s v1.11&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Service Mesh" scheme="https://zhang21.github.io/tags/Service-Mesh/"/>
    
      <category term="API" scheme="https://zhang21.github.io/tags/API/"/>
    
      <category term="APIGateway" scheme="https://zhang21.github.io/tags/APIGateway/"/>
    
      <category term="MicroService" scheme="https://zhang21.github.io/tags/MicroService/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://zhang21.github.io/2019/04/28/OperatingSystem/"/>
    <id>https://zhang21.github.io/2019/04/28/OperatingSystem/</id>
    <published>2019-04-28T00:59:12.000Z</published>
    <updated>2020-03-16T07:49:01.650Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>OS Three Easy Pieces: <a href="https://book.douban.com/subject/19973015/" target="_blank" rel="noopener">https://book.douban.com/subject/19973015/</a></li><li>OSTEP: <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/</a></li></ul><p><br></p><p>环境:</p><ul><li>ELRH7x86_64</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="操作系统介绍"><a href="#操作系统介绍" class="headerlink" title="操作系统介绍"></a>操作系统介绍</h1><p>Introduction to Operating Systems</p><p>如果你正在攻读本科操作系统课程，你应该已经知道计算机程序运行时的想法。如果没有，这本书将很难。</p><p>那么，程序运行时会发生什么呢？<br>好吧，正在运行的程序做了一件非常简单的事情: <strong>它执行指令(it executes instructions)</strong>。<br>每秒都有成千上万次，处理器从内存(mem)中取出(fetch)指令，对其进行解码(decode)——即确定这是哪条指令，并执行它。完成此指令后，进程将继续执行下一条指令，以此类推，直到程序最终完成。</p><p>刚刚描述了<strong>冯-诺依曼计算模型(Von Neumann model of computing)</strong>的基础知识。在本书中，我们将学习在程序运行的同时，还有许多其它的东西在运行，其主要目标是使系统易于使用。</p><p>事实上，有一大堆软件负责使应用程序运行变得容易，允许程序共享内存(share mem)，使程序与设备交互…该软件主体称为<strong>操作系统(Operating System)</strong>，它负责确保系统操作以易于使用的方式正确有效地运行。</p><p>操作系统执行此操作的主要方式是通过我们称为<strong>虚拟化(Virtualization)</strong>的通用技术。也就是说，操作系统采用<strong>物理资源(Physical Resource)</strong>(如处理器，内存，磁盘)并将其转换为更通用，功能强大且易于使用的虚拟形式。因此，我们有时将操作系统称为<strong>虚拟机(Virtual Machine)</strong>。</p><blockquote><p><strong>问题的关键: 如何虚拟化资源</strong><br>本书的一个核心问题：操作系统如何虚拟化资源？操作系统为什么要虚拟化资源——它使得系统更易于使用。因此，我们关注：操作系统使用什么机制和策略来实现虚拟化？操作系统如何有效地进行操作？需要什么硬件支持？</p></blockquote><p><br></p><p>当然，为了告诉用户操作系统做什么，从而利用虚拟机的功能(如运行程序、分配内存、访问文件…)，操作系统还提供了一些可调用的接口(API)。事实上，典型的操作系统会<strong>导出(Export)</strong>数百个可供应用程序访问的<strong>系统调用(System Call)</strong>。<br>由于操作系统提供这些系统调用来运行程序、访问内存和设备、以及其它相关操作，有时也会说操作系统为应用程序提供了一个<strong>标准库(Standard Library)</strong>。</p><p>最后，因为虚拟化允许多个程序运行(共享CPU)，并且许多程序同时(Concurrently)访问它们自己的指令和数据(共享内存)，以及许多程序访问设备(共享磁盘等)，操作系统有时被称为<strong>资源管理器(Resource Manager)</strong>。每个CPU、MEM、DISK都是系统的资源。因此，操作系统的角色是管理这些资源，有效或公平地执行。</p><p><br><br><br></p><h2 id="虚拟化CPU"><a href="#虚拟化CPU" class="headerlink" title="虚拟化CPU"></a>虚拟化CPU</h2><p>Virtualizing the CPU</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code That Loops and Prints (cpu.c)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: cpu &lt;string&gt;\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *str = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        Spin(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>上图的程序，它所做的只是调用<code>Spin()</code>——这是一个重复检查时间的函数。<br>接下来我们具有单个处理器的系统上编译和运行它:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此处遇到两个错误</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. cpu.c:(.text+0xe0)：对‘pthread_create’未定义的引用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. cpu.c:(.text+0x127)：对‘pthread_join’未定义的引用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 网上方法: 在编译时需要添加 -lpthread 参数来使用 libpthread.a 库进行编译</span></span><br><span class="line">gcc -o cpu cpu.c -Wall -lpthread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">./cpu "ABC"</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 需手动终止</span></span><br><span class="line">Ctrl+C</span><br></pre></td></tr></table></figure><p><br></p><p>现在让程序复杂一点:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">./cpu A &amp;  ./cpu B &amp;  ./cpu C &amp;  ./cpu D &amp;</span><br><span class="line"></span><br><span class="line">[1] 7353</span><br><span class="line">[2] 7354</span><br><span class="line">[3] 7355</span><br><span class="line">[4] 7356</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">D</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">D</span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">D</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现在事情变得更有趣了。即使只有一个处理器，但不知何故，所有四个程序都在同时运行！这种魔力是如何发生的呢？</p><p>事实证明，操作系统在硬件的帮助下负责这种<strong>错觉(illusion)</strong>——即系统具有大量虚拟CPU的错觉。将单个CPU转换为看似无限数量的CPU，从而允许许多程序看起来像是一次运行，这就是我们所说的虚拟化CPU，这是本书第一部分的重点。</p><p>当然，要运行程序并停止它，以及告诉操作系统运行哪些程序，需要使用一些接口(API)来将你的需求传递给操作系统。实际上，它们是大多数用于与操作系统交互的主要方式。</p><p>你可能还注意到，一次运行多个程序会引发各种新问题。如，如果两个程序需要在特定时间运行，哪个应该运行。这些问题由操作系统的策略来回答，策略在操作系统中的许多不同位置用户回答这些类型的问题。</p><p><br><br><br><br><br></p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>Virtualizing Memory</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Program that Accesses Memory (mem.c)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// a1</span></span><br><span class="line">    assert(p != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%d) memory address of p: %08x\n"</span>,</span><br><span class="line">        getpid(), (<span class="keyword">unsigned</span>) p); <span class="comment">// a2</span></span><br><span class="line">    *p = <span class="number">0</span>; <span class="comment">// a3</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        Spin(<span class="number">1</span>);</span><br><span class="line">        *p = *p + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(%d) p: %d\n"</span>, getpid(), *p); <span class="comment">// a4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>现在让我们考虑一下<strong>内存(memory)</strong>。现代机器提供的物理内存的模型非常简单。内存只是一个<strong>字节数组(a array of bytes)</strong>。要读取内存，必须指定一个地址才能访问存储在那里的数据。要写入或更新(write/update)内存，还必须指定要写入数据的给定地址。</p><p>程序运行时始终访问内存。程序的所有数据结构保存在内存中，并通过各种指令访问它们，如<code>loads</code>, <code>stores</code>或其它在执行工作时访问内存的显式指令。不要忘记程序的每条指令也在内存中，每次<strong>取(fetch)指令</strong>时访问内存。</p><p>让我们来看下通过调用<code>malloc()</code>来分配一些内存的上面那个程序:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">./mem</span><br><span class="line">(6941) memory address of p: 01f13010</span><br><span class="line">(6941) p: 1</span><br><span class="line">(6941) p: 2</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 该程序做了几件事。首先，它分配一些内存(a1)。然后，它打印出内存的地址(a2)，然后将数字零放入新分配的存储器的第一个插槽(a3)。最后，它循环，延迟1秒并递增存储在p中保存的地址的值。它还打出程序的PID。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Running The Memory Program Multiple Times</span></span><br><span class="line">./mem &amp; ./mem &amp;</span><br><span class="line">[1] 7544</span><br><span class="line">[2] 7545</span><br><span class="line">(7544) memory address of p: 012f3010</span><br><span class="line">(7545) memory address of p: 006cf010</span><br><span class="line">(7544) p: 1</span><br><span class="line">(7545) p: 1</span><br><span class="line">(7544) p: 2</span><br><span class="line">(7545) p: 2</span><br><span class="line">(7544) p: 3</span><br><span class="line">(7545) p: 3</span><br></pre></td></tr></table></figure><p>实际上，这正是这里发生的事情，因为操作系统正在虚拟化内存。每个进程都访问自己的<strong>私有虚拟地址空间(private virtual address space)</strong>(有时也称为地址空间)，操作系统以某种方式将其映射到计算机的物理内存中。一个正在运行的程序中的内存引用不会影响其它进程的地址空间。就运行程序而言，它具有物理内存。然而，现实是物理内存是由操作系统管理的共享资源。</p><p><br><br><br><br><br><br><br></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>Concurrency</p><p>本书另一个主题是<strong>并发性(concurrency)</strong>。使用这个术语来指代同一程序中同时处理多个事件(即并发)。并发问题首先出现在操作系统自身，如前面的虚拟化程序，操作系统同时处理多个事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMulti-threaded Program (threads.c)</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> loops;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> *<span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">         counter++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span></span><br><span class="line"> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: threads &lt;value&gt;\n"</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     loops = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">     <span class="keyword">pthread_t</span> p1, p2;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Initial value : %d\n"</span>, counter);</span><br><span class="line"></span><br><span class="line">     Pthread_create(&amp;p1, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">     Pthread_create(&amp;p2, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">     Pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">     Pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Final value : %d\n"</span>, counter);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;本程序使用Pthread create()创建两个线程</span></span><br><span class="line"><span class="comment">// 你可将线程视为与其它函数相同的内存空间中运行的函数，一次使用多个函数</span></span><br></pre></td></tr></table></figure><p><br></p><blockquote><p><strong>如何构建正确的并发程序?</strong><br>当同一个内存空间中有许多并发执行的线程时，我们如何构建一个正常工作的程序？操作系统需要哪些原语？硬件提供哪些机制？如何使用它们来解决并发问题？</p></blockquote><p><br></p><p>运行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">./threads</span><br><span class="line">usage: threads &lt;value&gt;</span><br><span class="line"></span><br><span class="line">./threads 1000</span><br><span class="line">Initial value : 0</span><br><span class="line">Final value : 2000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 看看更高的值</span></span><br><span class="line">./threads 10000</span><br><span class="line">Initial value : 0</span><br><span class="line">Final value : 17726</span><br><span class="line"></span><br><span class="line">./threads 10000</span><br><span class="line">Initial value : 0</span><br><span class="line">Final value : 18741</span><br><span class="line"></span><br><span class="line">./threads 10000</span><br><span class="line">Initial value : 0</span><br><span class="line">Final value : 20000</span><br></pre></td></tr></table></figure><p>上面出现了既正常又奇怪的结果。这些结果与指令的执行方式有关。不幸的是，上面程序的一个关键部分，共享计数器递增，需要三个指令：</p><ul><li>一个用于将计数器的值从内存加载到寄存器；</li><li>一个用于递增；</li><li>一个用于将其存储回内存。</li></ul><p>因为这三个指令不是原子地执行(一次全部执行)，所以会发生奇怪的事。</p><p><br><br><br><br><br><br><br></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Persistence</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Program That Does I/O (io.c)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/tmp/file"</span>, O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);</span><br><span class="line">    assert(fd &gt; <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> rc = write(fd, <span class="string">"hello world\n"</span>, <span class="number">13</span>);</span><br><span class="line">    assert(rc == <span class="number">13</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>第三个主题是<strong>持久化(persistence)</strong>。在系统内存中，数据很容易丢失，因为如DRAM的设备是以易失的方式存储值。当断电或系统奔溃时，内存中的任何数据都会丢失。因此，我们需要硬件和软件能够持久存储数据。硬件以某种I/O设备的形式出现。</p><p>通常，操作系统中管理磁盘的软件被称为<strong>文件系统(file system)</strong>。它负责将用户创建的任何文件以可靠和有效的方式存储在磁盘上。</p><p>与操作系统为CPU何MEM提供的抽象不同，操作系统不会为每个应用程序创建专用的虚拟化磁盘。相反，它假设用户经常想要共享文件中的信息。</p><p>来看下上面的代码，它打开<code>/tmp/file</code>文件，并将<code>hello world</code>写入文件。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./io</span><br><span class="line"></span><br><span class="line">cat /tmp/file</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p><br></p><blockquote><p><strong>如何持久存储数据？</strong><br>文件系统是负责管理持久化数据的操作系统的一部分。正确地处理需要哪些技术呢？面对硬件和软件故障，如何实现可靠性？</p></blockquote><p>要完成此任务，程序会对操作系统进行三次调用。这些系统调用被路由到称为文件系统的操作系统部分，然后处理请求并向用户返回某种错误代码。</p><ul><li>第一，调用<code>open()</code>打开文件；</li><li>第二，调用<code>write()</code>将数据写入文件；</li><li>第三，调用<code>close()</code>关闭文件。</li></ul><p>你可能想知道操作系统为了写入磁盘而执行的操作。文件系统必须完成相当多的工作，首先确定这些新数据将驻留在磁盘上的哪个位置，然后在文件系统维护的各种结构中跟踪它。这样做需要向底层存储设备发出I/O请求，以读取现有结构或更新它们。<br>任何编写设备驱动程序的人都知道，让设备代表你做某事是一个复杂和详细的过程。它需要深入了解低级设备接口及其确切语义。幸运的是，操作系统提供了一个的标准和简单的方式——通过系统调用(system call)访问设备。因此，操作系统有时被视为<strong>标准库(standard library)</strong>。</p><p>为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复杂的写入协议。(如journaling或copy-on-write)。仔细写入磁盘以确保在写入序列期间发生故障时，系统之后可以恢复到合理的状态。为了使不同额公共操作高效，文件系统采用许多不同的数据结构和访问方法，从简单的列表到复杂的BTREE。</p><p><br><br><br><br><br><br><br></p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>Design Goals</p><p>现在我们知道了操作系统实际上做了什么：它使用物理资源(CPU, MEM, DISK…)，并虚拟化它们。它处理与并发相关的棘手的问题。它可以持久存储文件，从而使它们长期安全。最基本的目标是建立一些抽象，以使系统方便和易于使用。抽象是我们计算机科学中所做的一切的基础。</p><p>设计和实现操作系统的一个目标是提供<strong>高性能(High Performance)</strong>；另一个目标是尽量减少操作系统的<strong>开销(overhead)</strong>。虚拟化和使操作系统易于使用是值得的，但不是不惜任何代价。因此，我们必须提供虚拟化和其它操作系统功能，而无需过多开销。这些开销以多种形式出现：额外时间、额外空间。</p><p>另一个目标是在应用程序之间，以及操作系统和应用程序之间提供<strong>保护(Protection)</strong>。由于我们系统多个程序同时运行，所有希望确保每一个程序的恶意或偶然的不良行为不会伤害到其它程序或操作系统。保护操作系统的主要核心原则始操作系统的<strong>隔离(Isolation)</strong>。将进程彼此隔离是保护的关键，因此是操作系统必须做的大部分工作的基础。</p><p>操作系统必须不间断地运行，当它失败时，系统上运行的所有应用程序也会失败。由于这种依赖性，操作系统通常努力提供<strong>高度可靠性(high degree of reliability)</strong>。随着操作系统越来越复杂，构建可靠的操作系统是一个相当大的挑战，这也是一个确切的研究性问题。</p><p>其它目标也是有意义的:</p><ul><li><strong>能源效率</strong>：在绿色世界中越发重要；</li><li><strong>安全</strong>：对恶意应用程序的安全性至关重要；</li><li><strong>可移植性</strong>：随着操作系统在越来越小的设备上运行，可移植性也变得很重要。</li></ul><p><br><br><br><br><br><br><br></p><h2 id="一些历史"><a href="#一些历史" class="headerlink" title="一些历史"></a>一些历史</h2><p>Some History</p><p>让我们简单介绍下操作系统的发展过程。与人类构建的任何系统一样，随着时间的推移，操作系统中积累了许多好的想法。</p><p><br></p><h3 id="Early-Operating-Systems-Just-Libraries"><a href="#Early-Operating-Systems-Just-Libraries" class="headerlink" title="Early Operating Systems: Just Libraries"></a>Early Operating Systems: Just Libraries</h3><p>一开始，操作系统并没有做太多。基本上，它只是一组常用函数库(function library)。</p><p>通常，在这些旧的主机系统上，一个程序由人工控制运行一次。许多你认为的现代操作系统将执行的大部分操作是由人工执行的。如果你和操作员很好，则他可以将你的工作移动到队列的前面。<br>这种计算方式称为<strong>批处理(batch processing)</strong>，因为设置了很多作业，然后由人工以批处理的方式运行。到目前为止，计算机并没有以<strong>交互式(interactive)</strong>方式使用。因为成本：让用户坐在电脑面前使用它太昂贵了，因为大多数时候它只是闲置，而每小时需要花费数十万美元。</p><p><br><br><br></p><h3 id="Beyond-Libraries-Protection"><a href="#Beyond-Libraries-Protection" class="headerlink" title="Beyond Libraries: Protection"></a>Beyond Libraries: Protection</h3><p>作为一个简单的常用服务库，操作系统在管理机器方面发挥了中心角色的作用。其中一个重要的方面是认识到运行操作系统自身的代码是特殊的。它控制了设备，因此应该与正常的应用程序代码区别对待。<br>为什么这样？设想一下，如果你允许任何应用程序可以从磁盘的任何地方读取，隐私的概念就会消失，因为任何程序都可以读取任何文件。因此，实现文件系统作为一个库是没有任何意义的。</p><p>因此，<strong>系统调用(system call)</strong>的想法产生了。这里的想法是添加一对特殊的硬件指令和硬件状态，以便将操作系统转换为更正式、受控制的流程，而不是将操作系统例程(routine)作为库提供(你只需要进行过程调用以访问它们)。</p><p><strong>系统调用(system call)</strong>和<strong>过程调用(procedure call)</strong>之间的关键区别在于，系统调用将控制转移到中，同时提高<strong>硬件权限级别(hardware privilege level)</strong>。用户应用程序在所谓的<strong>用户模式(user mode)</strong>下运行，这意味着硬件限制应用程序可以执行的操作。例如，以用户模式运行的应用程序通常不能发起对磁盘的I/O请求，但可以访问物理内存页面或在网络上发送数据包。<br>当启动系统调用时，硬件将控制转移到预先指定的陷阱处理程序(trap handler)，并同时将特权级别提升到<strong>内核模式(kernel mode)</strong>。在内核模式下，操作系统可以完全访问系统的硬件，因此可以执行如启动I/O请求等操作。当操作系统完成对服务的请求时，它通过特殊返回陷阱指令(return-from-trap instrction)将控制权传递给用户，该指令恢复到用户模式，同事将控制权传递回应用程序停止的位置。</p><p><br><br><br></p><h3 id="The-Era-of-Multiprogramming"><a href="#The-Era-of-Multiprogramming" class="headerlink" title="The Era of Multiprogramming"></a>The Era of Multiprogramming</h3><p>操作系统真正起飞的时代是超大型计算时代，即minicomputer时代。成本的下降影响了使用者和开发者，从而使计算机系统更加有趣和美好。</p><p>特别是，由于希望更好地利用机器资源，<strong>多程序设计(multiprogramming)</strong>变得司空见惯。操作系统不是一次只运行一个作业，而是将大量作业加载到内存中并在它们之间快速切换，从而提高CPU利用率。这种切换特别重要，因为I/O设备很慢，而CPU很快。在I/O正在服务时让CPU等待程序是在浪费CPU时间。相反，为什么不切换到另一个工作运行呢？</p><p>在存在I/O和中断的情况下支持多程序设计和重叠的愿望迫使操作系统的概念开发沿着多个方向进行创新。内存保存等问题变得很重要，我们不希望一个程序能够访问另一个程序的内存。了解如何处理多程序设计引入的并发问题也很关键，尽管存在中断，确保操作系统正常运行是一项巨大的挑战。</p><p>当时一个主要的进步是Unix操作系统的引入。Unix从不同的操作系统获得了很多好主意，但使它们更简单易用。很快，这个团队向世界各地的人们发送了包含Unix源代码的磁带，随后有许多人加入到了这个项目中来。</p><p><br><br><br></p><h3 id="The-Modern-Era"><a href="#The-Modern-Era" class="headerlink" title="The Modern Era"></a>The Modern Era</h3><p>除了minicomputer之外，还出现了一种更便宜、速度更快的新机器，我们今天称之为PC(personal computer)。</p><p>不幸的是，对于操作系统而言，PC最初代表了一个巨大的飞跃，因为早期的系统忘记了在minicomputer时代学到的经验教训。例如，早期的操作系统，如DOS(the Disk Operating System, from Microsoft)，并不认为内存保护很重要。因此，恶意(或编程不佳)的应用程序可能会乱写内存。第一代Mac OS采用合作方式进行作业调度。因此，一个意外陷入无限循环的线程可以接管整个系统，迫使重启。这一代系统中缺少的操作系统功能的痛苦太多了…</p><p>幸运的是，经过几年的苦难，微机操作系统的旧功能开始找到它们的方式进入桌面系统。例如，Mac OS X/Mac OS的核心是Unix，包含了人们对这种成熟系统所期望的所有功能。Windows同样采用了计算历史中的许多好主意，特别是从Windows NT开始，这是Microsoft OS技术的一次重大飞跃。即便是今天的手机也运行这操作系统(如Linux)，这些操作系统更像是1970s年代的微型机，而不是1980s年代的PC。</p><p><br></p><blockquote><p>旁白：<strong>Unix的重要性</strong><br>在操作系统的历史中，很难夸大Unix的重要性。受其它早期系统的影响，Unix汇集了许多伟大的想法，并使得系统既简单又强大。<br>贝尔实验室的基础Unix是构建小型且强大程序的统一原则，这些程序可以连接在一起形成更大的工作流。shell提供了mete-level programing，当你输入命令，它将程序串联起来以完成更大的任务变得很容易。<br>Unix环境对编程人员和开发人员都很友好，同时也为C编程语言提供了编译器。编程人员可以轻松编写自己的程序并共享它们，这使得Unix非常受欢迎。它还是免费的。<br>同样重要的是代码的可读性和可访问性。拥有一个用C编写的漂亮的小内核(kernel)并邀请别人试玩、添加新的酷的功能。<br>不幸的是，随着公司试图主张版权并从中获利，Unix的传播速度便有所放缓。许多公司都有自己的变体，如SunOS、HPUX…贝尔实验室和其它玩家之间的法律纠纷在Unix上投下了一片乌云，许多人想知道它是否能够活下来，特别是在Windows被引入并占据了PC市场的大部分时…</p></blockquote><p><br></p><blockquote><p>旁白：<strong>然后来了Linux</strong>(ASIDE: AND THEN CAME LINUX)<br>对于Unix，幸运的是，一位名叫<strong>Linus Torvalds</strong>的年轻芬兰Hacker决定编写它自己的Unix版本，该版本大量借用原始系统背后的原则和思想，但不是来自代码库，因此避免了合法性问题。他获得了世界各地许多人的帮助，利用了已经存在的复杂的GNU工具，很快Linux就诞生了(以及现代开源软件运动)。<br>随着互联网时代的带来，大多数公司(如Google、Amazon、Facebook..)选择运行Linux，因为它是免费的，可以随时修改以满足自己的实际需求。随着智能手机成为一个占主导地位的面向用户的平台，由于许多相同的原因，Linux也在那里找到了一个据点(Android)。</p></blockquote><p><br><br><br></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Summary</p><p>因此，我们介绍了操作系统。今天的操作系统相对易于使用，而你今天使用的几乎所有操作系统都受到将在本书中讨论的发展的影响。<br>不幸的是，书中不会介绍的很详细。例如，网络代码、图形设备、安全性。</p><p>但是，我们将介绍许多重要的主题，包括CPU和MEM的虚拟化知识，并发性以及通过设备和文件系统的持久性。别担心，虽然有很多方面可以覆盖，但大部分内容都非常酷，而且在路的尽头，你将对计算机系统的真正工作方式有了新的认识。现在开始吧！</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><p>Virtualization</p><p>CPU虚拟化：</p><ul><li>A Dialogue on Virtualization</li><li>The Abstraction: The Process</li><li>Interlude: Process API</li><li>Mechanism: Limited Direct Execution</li><li>CPU Scheduling</li><li>Scheduling: The Multi-Level Feedback Queue</li><li>Scheduling: Proportional Share</li><li>Multi-CPU Scheduling</li><li>Summary Dialogue on CPU Virtualization</li></ul><p><br></p><p>MEM虚拟化：</p><ul><li>A Dialogue on Memory Virtualization</li><li>The Abstraction: Address Spaces</li><li>Interlude: Memory API</li><li>Mechanism: Address Translation</li><li>Segmentation</li><li>Free-Space Management</li><li>Paging</li><li>Paging: Faster Translations</li><li>Paging: Smaller Tables</li><li>Beyond Physical Memory: Swapping Mechanisms</li><li>Beyond Physical Memory: Swapping Policies</li><li>Complete Virtual Memory Systems</li><li>Summary Dialogue on Memory Virtualization</li></ul><p><br><br><br></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf" target="_blank" rel="noopener">The Abstraction: The Process</a></p><p>本章，我们将讨论操作系统为用户提供的最基本的抽象之一：<strong>进程(process)</strong>。进程的定义非常简单：它是一个<strong>正在运行的程序(running program)</strong>。程序本身是一个没有生命的东西，它位于磁盘上，一对指令(可能是一些静态数据)，等待开始行动。操作系统采用这些字节并使它们运行，将程序转换为有用的东西。</p><p>事实证明，人们经常想要同时运行多个程序。如运行浏览器、音乐播放器、邮件程序…实际上，典型的操作系统似乎可能同时运行数百个进程。这样做使系统易于使用，因为不需要关心CPU是否可用。</p><p><br></p><blockquote><p>TIP: USE TIME SHARING (AND SPACE SHARING)<br><strong>时间共享(time sharing)</strong>是操作系统用于共享资源的基本技术。通过允许资源被一个实体使用一段时间，然后另一个实体使用一段时间…资源可以被许多实体共享。时间共享对应于<strong>空间共享(space sharing)</strong>，其中资源在希望使用它的人之间被划分。例如，磁盘空间是一个空间共享资源，一旦将块分配给文件，在用户删除原始文件之前，通常不会将其分配给另一个文件。</p></blockquote><p><br></p><p>我们的挑战是:</p><blockquote><p>如何提供许多CPU的错觉？<br>虽然只有少数物理CPU可用，但操作系统如何提供几乎无穷无尽的CPU供应的错觉？</p></blockquote><p>操作系统通过虚拟化(virtualizating)CPU来提供这种错觉。通过运行一个进程，然后停止它并运行另一个进程，等等。操作系统可以促使存在许多虚拟CPU存在的错觉，而实际上只有一个(几个)物理CPU。这种基本技术称为CPU的<strong>时间共享/分时(time sharing)</strong>，允许用户运行任意数量的并发进程(concurrent process)。潜在的成本是性能(Performance)，因为如果必须共享CPU，每个进程都会运行得更慢。</p><p>要实现CPU的虚拟化，操作系统需要一些低级机制(low-level machinery)和一些高级智能(high-level intelligence):</p><ul><li><strong>低级机制(low-level machinery mechanisms)</strong>，此机制是实现所需功能的低级方法或协议。例如，我们稍后将学习如何实现<strong>上下文切换(context switch)</strong>，这使操作系统能够停止运行一个程序并在给定的CPU上开始运行另一个程序。所有现代操作系统都采用这个<strong>分时机制(time-sharing mechanism)</strong>。</li><li>操作系统中还存在一些智能的<strong>策略(policy)</strong>，策略是在操作系统中做出某种决定的算法。例如，给定一些可能在CPU上运行的程序，操作系统运行哪个程序？操作系统中的调度策略将做出此决定，可能使用历史信息，工作负载信息，性能指标…来做出决定。</li></ul><p><br><br><br></p><h3 id="一个进程"><a href="#一个进程" class="headerlink" title="一个进程"></a>一个进程</h3><p>The Abstraction: A Process</p><p>为了理解进程的构成，我们必须了解其<strong>机器状态(machine state)</strong>：程序在运行时可以读取(read)或更新(update)的内容。在任何给定的时间，机器的哪些部分对于执行该程序很重要？包含进程的机器状态的一个明显组件是其内存(memory)。指令行在内存中，运行程序读写的数据也在内存中。因此，进程可以寻址的内存(称为其地址空间(address space))是进程的一部分。</p><p><strong>寄存器(registers)</strong>也是进程机器状态的一部分。许多指令明确地读取或更新寄存器，因此它们对于执行过程很重要。</p><p>请注意，有一些特殊的寄存器构成了这种机器状态的一部分。如，<strong>program counter(instruction pointer)</strong>告诉我们当前正在运行哪个程序指令；<strong>Stack Pointer</strong>和相关的<strong>frame pointer</strong>用于管理函数参数、局部变量和返回地址的堆栈。</p><p>最后，程序通常也访问持久存储设备。此类I/O信息可能包括进程当前打开的文件列表。</p><p><br></p><blockquote><p>TIP: SEPARATE POLICY AND MECHANISM<br>在许多操作系统中，常见的设计范例是将高级策略与其低级机制分开。如，操作系统如何执行上下文切换？操作系统现在应该运行哪个进程？将两者分开可以很容易地改变策略，而不必重新考虑该机制，因此是一种模块化形式，一般的软件设计原则。</p></blockquote><p><br><br><br></p><h3 id="Process-API"><a href="#Process-API" class="headerlink" title="Process API"></a>Process API</h3><p>先了解操作系统的任何接口中必须包含的内容，这些API以某种形式可用于任何现代操作系统。</p><ul><li><strong>Create</strong>：操作系统必须包含一些创建新进程的方法；</li><li><strong>Destroy</strong>：由于存在创建进程的接口，因此系统还提供了强制销毁进程的接口。当然，许多进程都会运行并在完成后自动退出。然而，当它们不这样做时，用户可能希望杀死它们；</li><li><strong>Wait</strong>：有时，等待进程停止运行时有用的；</li><li><strong>Miscellaneous Control</strong>：除了杀死或等待进程之外，有时还有其它可能的控制措施。如暂停进程，然后恢复它；</li><li><strong>Status</strong>：通常还有接口来获取有关进程的一些状态信息，如运行了多久…</li></ul><p><img src="/images/OSTEP/processToProcess.png" alt></p><p><br><br><br></p><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>Process Creation: A Little More Detail</p><p>我们应揭开的一个谜团是如何将<strong>程序(program)</strong>转换为<strong>进程(process)</strong>。具体来说，操作系统如何启动并运行程序？进程创建实际上如何运作？</p><p>操作系统运行程序必须做的第一件事是将其代码和任何静态文件数据(如变量…)加载(load)到程序的地址空间中(address space of process)。程序最初以某种可执行格式驻留在磁盘(disk)上。因此，将程序和静态数据加载到内存中的过程需要操作系统从磁盘读取这些字节，并将它们放在内存中。<br>在早期操作系统中，加载过程是<strong>热切地(eagerly)</strong>完成，即在运行程序之前一次完成；现代操作系统<strong>懒惰地(lazily)</strong>执行该过程，即仅在程序执行期间需要加载代码或数据。要真正了解代码和数据的延迟加载是如何工作的，你必须更多地了解<strong>分页(paging)</strong>和<strong>交换(swapping)</strong>的机制，这将在内存虚拟化里讨论。现在只需记住，在运行任何操作之前，操作系统显然必须要做一些工作才能将重要的程序从磁盘放入内存。</p><p>一旦将代码和静态数据加载到内存中，操作系统在运行该进程之前还需要执行一些其它操作。必须为程序的<strong>运行时栈(runtime stack)</strong>分配一些内存。如C程序将堆栈用于局部变量、函数参数和返回地址。操作系统分配此内存并将其提供给进程。操作系统也可能使用参数初始化堆栈，具体来说，它将填充<code>main()</code>函数的参数(<code>argc, argv</code>数组)。</p><p>操作系统还可以为程序的<strong>堆(heap)</strong>分配一些内存。在C程序中，堆用于显式请求的动态分配数据调用<code>malloc()</code>来请求这样的空间，并通过调用<code>free()</code>显式释放它。数据结构需要堆，如链表(linked list)、哈希表(hash table)、树(tree)和其它又去的数据结构。堆最初会很小，当程序运行并通过<code>malloc()</code>库API请求更多内存时，操作系统可能会参与并为进程分配更多内存以满足此类调用。</p><p>操作系统还将执行一些其它初始化任务，尤其是与I/O相关的任务。例如，在Unix系统中，默认情况下每个进程都有三个打开的<strong>文件描述符(file descriptors)</strong>，用于stdin, stdout, stderr。这些描述符使程序可以轻松地从终端读取输入并将输出打印到屏幕。将在持久化中详细介绍I/O和文件描述符。</p><p>通过将代码和静态数据加载到内存中，通过创建和初始化堆，通过执行与I/O设置相关的其它工作，操作系统最终为程序执行设置了阶段。它还有最后一个任务：启动在入口点运行的程序，即<code>main()</code>。通过跳转到<code>main()</code>例程，操作系统将CPU的控制权转移到新创建的进程，从而程序开始执行。</p><p><br><br><br></p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>Process States</p><p>现在我们已经知道一个进程是什么以及如何创建它。现在来看看一个进程在给定事件可以处于的不同状态。进程可处以以下三种状态：</p><ul><li><strong>Running</strong>：进程正在处理器上运行，这意味着它正在执行指令；</li><li><strong>Ready</strong>：进程已准备好，但由于某种原因，操作系统已选择不在此刻运行它；</li><li><strong>Blocked</strong>：进程执行某种操作，使其在其它事件发生之前不准备运行。例如，当进程向磁盘发起I/O请求时，它会被阻塞，因此其它一些进程可以使用该处理器。</li></ul><p>如下图所示，可以根据系统的判断在准备和运行之间移动进程。从准备到运行意味着该进程已<strong>调度(scheduled)</strong>好；从运行转移到准备意味着该进程被<strong>取消调度(discheduled)</strong>。一旦进程被<strong>阻塞(blocked)</strong>，操作系统将保持这样知道某些事件完成，此时进程再次进入就绪状态。</p><p><img src="/images/OSTEP/processStateTransitions.png" alt></p><p><br></p><p>来看一个栗子，两个进程如果通过其中一些状态转换的示例。</p><div class="table-container"><table><thead><tr><th>Time</th><th>Process0</th><th>Process1</th><th>Notes</th></tr></thead><tbody><tr><td>1</td><td>Running</td><td>Ready</td><td></td></tr><tr><td>2</td><td>Running</td><td>Ready</td><td></td></tr><tr><td>3</td><td>Running</td><td>Ready</td><td></td></tr><tr><td>4</td><td>Running</td><td>Ready</td><td>Process0 now done</td></tr><tr><td>5</td><td>–</td><td>Running</td><td></td></tr><tr><td>6</td><td>–</td><td>Running</td><td></td></tr><tr><td>7</td><td>–</td><td>Running</td><td></td></tr><tr><td>8</td><td>–</td><td>Running</td><td>Process1 now done</td></tr></tbody></table></div><p><br></p><p>这个栗子中，process0在运行一段时间后发出I/O请求。此时，该进程被阻塞，使另一个进程有机会运行。<br>更具体地说，process0启动I/O并被阻塞等待它完成。例如，从磁盘读取或等待来自网络的数据包时，进程会被阻止。操作系统识别process0未使用CPU并开始运行process1。当process1运行时，process0的I/O完成，将process0移回准备状态。最后，process1完成，process0运行然后完成。</p><div class="table-container"><table><thead><tr><th>Time</th><th>Process0</th><th>Process1</th><th>Notes</th></tr></thead><tbody><tr><td>1</td><td>Running</td><td>Ready</td><td></td></tr><tr><td>2</td><td>Running</td><td>Ready</td><td></td></tr><tr><td>3</td><td>Running</td><td>Ready</td><td>Process0 initiates I/O</td></tr><tr><td>4</td><td>Blocked</td><td>Running</td><td>Process0 is blocked</td></tr><tr><td>5</td><td>Blocked</td><td>Running</td><td>so Process1 runs</td></tr><tr><td>6</td><td>Blocked</td><td>Running</td><td></td></tr><tr><td>7</td><td>Ready</td><td>Running</td><td>I/O done</td></tr><tr><td>8</td><td>Ready</td><td>Running</td><td>Process1 now done</td></tr><tr><td>9</td><td>Running</td><td>–</td><td></td></tr><tr><td>10</td><td>Running</td><td>–</td><td>Process0 now done</td></tr></tbody></table></div><p>请注意，即使在这个简单的示例中，操作系统也必须做出许多决定。首先，系统必须在process0发出I/O时运行process1；这样做可以通过保持CPU忙碌来提高资源利用率。其次，系统决定在其I/O完成时不切换会process0。目前尚不清楚这是否是一个好的决定。这些类型的决策是由操作系统调度程序做出的。</p><p><br><br><br></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Data Structures</p><p>操作系统是一个程序，与任何程序一样，它有一些追踪各种相关信息的关键<strong>数据结构(data structure)</strong>。例如，为了追踪每个进程的状态，操作系统可能会为所有准备好的进程保留某种进程列表，并提供一些其它信息来追踪当前正在运行的进程。操作系统还必须以某种方式追踪被阻塞的进程；当I/O事件完成时，操作系统应确保唤醒正确的进程并准备好再次运行。</p><p>下面显示了操作系统需要跟踪内核中每个进程的信息类型。类似的过程结构存在于真实操作系统中，如Linux、Mac OSX、Windows…看看它们有多复杂。你可以看到操作系统追踪进程的几个重要信息。<br>对于已停止的进程，<strong>寄存器上下文(register context)</strong>将保持其寄存器的内容。当进程停止时，其寄存器将保持到该内存位置(memory location)。通过恢复这些寄存器，操作系统可以恢复运行该进程。这在以后上下文切换中详细介绍。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the registers xv6 will save and restore</span></span><br><span class="line"><span class="comment">// to stop and subsequently restart a process</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> eip;</span><br><span class="line"><span class="keyword">int</span> esp;</span><br><span class="line"><span class="keyword">int</span> ebx;</span><br><span class="line"><span class="keyword">int</span> ecx;</span><br><span class="line"><span class="keyword">int</span> edx;</span><br><span class="line"><span class="keyword">int</span> esi;</span><br><span class="line"><span class="keyword">int</span> edi;</span><br><span class="line"><span class="keyword">int</span> ebp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the different states a process can be in</span></span><br><span class="line"><span class="keyword">enum</span> proc_state &#123; UNUSED, EMBRYO, SLEEPING,</span><br><span class="line">                  RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the information xv6 tracks about each process</span></span><br><span class="line"><span class="comment">// including its register context and state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *mem; <span class="comment">// Start of process memory</span></span><br><span class="line">  uint sz; <span class="comment">// Size of process memory</span></span><br><span class="line">  <span class="keyword">char</span> *kstack; <span class="comment">// Bottom of kernel stack</span></span><br><span class="line">        <span class="comment">// for this process</span></span><br><span class="line">  <span class="keyword">enum</span> proc_state state; <span class="comment">// Process state</span></span><br><span class="line">  <span class="keyword">int</span> pid; <span class="comment">// Process ID</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span> <span class="comment">// Parent process</span></span><br><span class="line">  <span class="keyword">void</span> *chan; <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed; <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span> <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span> <span class="comment">// Current directory</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span> <span class="comment">// Switch here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span> <span class="comment">// Trap frame for the</span></span><br><span class="line">        <span class="comment">// current interrupt</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还可从图中看出，除了running, ready, blocked之外，还有一些进程可以处于其它状态。<br>有时，系统将具有该进程在创建是所处的<strong>初始状态(initial state)</strong>。此外，可将进程置于已退出但尚未清除的<strong>最终状态(final state)</strong>(在基于Unix的系统中，这称为<strong>僵尸状态(zombie state)</strong>)。这个最终状态非常有用，因为它允许其它进程(通常是创建此进程的父进程)检查进程的返回代码并查看刚刚完成的进程是否成功运行(通常，程序在基于Unix系统中的返回码为0时，表示已成功完成任务，否则返回非0)。完成后，父进程将进行最后一次调用以等待孩子进程的完成，并且还向操作系统指示它可以清理任何涉及现在已经灭绝的进程的相关数据结构。</p><p><br></p><blockquote><p>ASIDE: DATA STRUCTURE — THE PROCESS LIST<br>操作系统充满了各种重要的数据结构。进程列表(process list)，也称为任务列表(task list)。它是比较简单的一个，都是现在能够同时运行多个程序的操作系统都会有类似于这种结构的东西，以便追踪系统中所有正在运行的程序。有时，人们会将存储过程信息的单个结构称为<strong>进程控制块(PCB, process control block)</strong>。</p></blockquote><p><br></p><blockquote><p>ASIDE: KEY PROCESS TERMS(关键进程术语)<br><strong>进程(process)</strong>是正在运行的程序的主要操作系统抽象。在任何时间点，该进程都可以通过其状态来描述：其地址空间中的内存内容、CPU寄存器的内容、有关I/O的信息。<br><strong>进程API</strong>由可使进程相关联的调用程序组成。通常，这包括创建、销毁、其它有用的调用。<br>进程存在许多不同的<strong>进程状态(process state)</strong>，包括running、ready、blocking。不同的时间将进程从这些状态之一转换到另一个状态。<br><strong>进程列表(process list)</strong>包含有关系统中所有进程的信息。每个条目有时称为进程控制块(PCB)，它实际上只是一个包含特定进程信息的结构。</p></blockquote><p><br><br><br><br><br><br><br></p><h2 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h2><p><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf" target="_blank" rel="noopener">Process API</a></p><blockquote><p>ASIDE: INTERLUDES<br><strong>插曲(interludes)</strong>将涵盖系统的多个实际方面，包括特别关注系统API以及如何使用它们。如果你不喜欢实际的事物(practical things)，你可跳过它。但你应该了解它，因为它们通常在现实生活中很有用。</p></blockquote><p><br></p><blockquote><p>CRUX: HOW TO CREATE AND CONTROL PROCESSES<br>操作系统应该为进程创建和控制提供哪些接口？如何设计这些接口以实现强大的功能、易用性和高性能？</p></blockquote><p><br></p><p>在此插曲中，将讨论Unix系统中的进程创建。Unix提供了一种使用一对<strong>系统调用(system call)</strong>创建新进程的最有趣的方法:</p><ul><li><code>fork()</code></li><li><code>exec()</code></li></ul><p>第三个例程，可以由希望等待进程创建完成的进程使用：</p><ul><li><code>wait()</code></li></ul><p><br><br><br></p><h3 id="fork系统调用"><a href="#fork系统调用" class="headerlink" title="fork系统调用"></a>fork系统调用</h3><p>The fork() System Call</p><p><code>fork()</code>系统调用用于创建新进程。但是，要预先警告：这是你将要调用的最奇怪的例行程序。更具体的说，你有一个正在运行的程序，代码如下所示。输入并运行它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calling fork() (p1.c)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world (pid:%d)\n"</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123; <span class="comment">// &gt;&gt;&gt;fork failed; exit</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fork failed\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123; <span class="comment">// child (new process)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello, I am child (pid:%d)\n"</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// parent goes down this path (main)</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"hello, I am parent of %d (pid:%d)\n"</span>,</span><br><span class="line">            rc, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./p1</span><br><span class="line">hello world (pid:14506)</span><br><span class="line">hello, I am parent of 14507 (pid:14506)</span><br><span class="line">hello, I am child (pid:14507)</span><br></pre></td></tr></table></figure><p>当它第一次运行时，该进程打印出<code>hello world</code>消息，包含在该消息中的<strong>进程标识符(PID, process identifier)</strong>。在Unix系统中，如果想要对进程执行某些操作(如停止它)，则使用PID来命名进程。</p><p>现在有趣的部分开始了：该进程调用<code>fork()</code>系统调用，操作系统提供该此方法来创建新进程。奇怪的部分：创建的进程是调用进程的精确副本。这意味着对于操作系统来说，现在看起来的两个进程都是p1程序运行的副本，并且两个进程都从<code>fork()</code>系统调用返回。新创建的进程(child)不会像<code>main()</code>那样开始在<code>main()</code>上运行(hello world只打印了一次)。相反，它刚出现时，好像它已经调用了<code>fork()</code>本身。</p><p>你可能注意到，子进程不是一个精确的副本。尽管它有自己的地址空间、寄存器、PC…，它返回给<code>fork()</code>调用者的值是不同的。具体来说，当父进程接收新创建的子进程PID时，子进程接收返回码0.</p><p>你可能还注意到：p1的输出不确定。系统中有两个活动的父进程和子进程。假设在单个CPU的系统上运行，可能会发生相反的情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./p1</span><br><span class="line">hello world (pid:29146)</span><br><span class="line">hello, I am child (pid:29147)</span><br><span class="line">hello, I am parent of 29147 (pid:29146)</span><br></pre></td></tr></table></figure><p>CPU调度器，确定哪个进程在给定时刻运行。因为调度程序很复杂，我们通常不能对它将选择做什么做出强有力的假设，如最先运行哪个进程。这些不确定性导致了一些有趣的问题，特别是在多线程程序中，这将在并发中讨论。</p><p><br><br><br></p><h3 id="wait系统调用"><a href="#wait系统调用" class="headerlink" title="wait系统调用"></a>wait系统调用</h3><p>The wait() System Call</p><p>到目前为止，我们还没有做太多工作：只创建了一个打印消息并退出的子进程。有时，事实证明，父进程等待子进程完成它一直在做的事情时非常有用的。这个任务是通过<code>wait()</code>系统调用完成的。</p><p>在下面的栗子中，父进程调用<code>wait()</code>以延迟执行，直到子进程执行完毕。子进程完成后，<code>wait()</code>返回父进程。添加了<code>wait()</code>调用使得数据具有稳定性，你们明白为什么吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calling fork() And wait() (p2.c)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world (pid:%d)\n"</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123; <span class="comment">// &gt;&gt;&gt;fork failed; exit</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fork failed\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123; <span class="comment">// child (new process)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello, I am child (pid:%d)\n"</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// parent goes down this path (main)</span></span><br><span class="line">        <span class="keyword">int</span> rc_wait = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello, I am parent of %d (rc_wait:%d) (pid:%d)\n"</span>,</span><br><span class="line">            rc, rc_wait, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> ./p2</span><br><span class="line">hello world (pid:29266)</span><br><span class="line">hello, I am child (pid:29267)</span><br><span class="line">hello, I am parent of 29267 (rc_wait:29267) (pid:29266)</span><br></pre></td></tr></table></figure><p>使用此代码，我们现在知道子进程将首先打印。但是，如果父进程碰巧先运行，它会立即调用<code>wait()</code>，这个系统调用在子进程运行并退出之前不会返回。因此，即使父进程先运行，它礼貌地等待子进程完成运行，然后<code>wait()</code>返回，然后父进程打印它的消息。</p><p><br><br><br></p><h3 id="exec系统调用"><a href="#exec系统调用" class="headerlink" title="exec系统调用"></a>exec系统调用</h3><p>The exec() System Call</p><p>进程创建API的最后一个重要部分是<code>exec()</code>系统调用。当你想要运行与调用程序不同的程序时，此系统调用很有用。例如，在p2中调用<code>fork()</code>仅在你希望继续运行同一程序的副本时才有用。但是，通常你想运行一个不同的程序，<code>exec()</code>就是这么做的。</p><p>在下面的栗子中，子进程调用<code>execvp()</code>以运行程序wc(word count)。实际上，它从p3上运行wc，返回行数、词数和字节数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calling fork(), wait(), And exec() (p3.c)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world (pid:%d)\n"</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123; <span class="comment">// &gt;&gt;&gt;fork failed; exit</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fork failed\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123; <span class="comment">// child (new process)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello, I am child (pid:%d)\n"</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">        <span class="keyword">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = strdup(<span class="string">"wc"</span>); <span class="comment">// program: "wc" (word count)</span></span><br><span class="line">        myargs[<span class="number">1</span>] = strdup(<span class="string">"p3.c"</span>); <span class="comment">// argument: file to count</span></span><br><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>; <span class="comment">// marks end of array</span></span><br><span class="line">        execvp(myargs[<span class="number">0</span>], myargs); <span class="comment">// runs word count</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"this shouldn’t print out"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// parent goes down this path (main)</span></span><br><span class="line">    <span class="keyword">int</span> rc_wait = wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, I am parent of %d (rc_wait:%d) (pid:%d)\n"</span>,</span><br><span class="line">         rc, rc_wait, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./p3</span><br><span class="line">hello world (pid:29383)</span><br><span class="line">hello, I am child (pid:29384)</span><br><span class="line">29 107 1030 p3.c</span><br><span class="line">hello, I am parent of 29384 (rc_wait:29384) (pid:29383)</span><br></pre></td></tr></table></figure><p><code>fork()</code>系统调用很奇怪，它的伙伴<code>exec()</code>也不是那么正常。它的作用：给定可执行文件的名称和一些参数，从该可执行文件加载代码和静态数据并覆盖其当前代码段，重新初始化堆和栈以及程序内存空间的其它部分。然后操作系统运行该程序，传入任意参数为该进程的argv。因此，它不会创建新的进程。相反，它将当前运行的程序(p3)转换为不同的运行程序(wc)。在子进程的<code>exec()</code>之后，几乎就好像p3从未运行过，成功调用<code>exec()</code>永远不会有返回。</p><p><br><br><br></p><h3 id="Motivating-The-API"><a href="#Motivating-The-API" class="headerlink" title="Motivating The API"></a>Motivating The API</h3><p>Why? Motivating The API</p><p>当然，可能会遇到一个大问题：为什么要建立一个奇怪的接口来创建一个新进程？事实证明，<code>fork()</code>和<code>exec()</code>的分离对于构建Unix shell至关重要，因为它允许shell在调用<code>fork()</code>之后，在调用<code>exec()</code>之前运行代码。此代码可以改变即将运行的程序的环境，从而可以轻松构建各种有趣的功能。</p><p><br></p><blockquote><p>TIP: GETTING IT RIGHT<br>简单和抽象都不能代替正确。有很多方法可以为进程创建设计API，但是，<code>fork()</code>和<code>exec()</code>的组合非常简单和强大。在这里，Unix设计师做对了。</p></blockquote><p><br></p><p>shell只是一个用户程序。它会向你显示提示，然后等待你输入内容。你输入一个命令，在大多数情况下，shell确定文件系统中可执行文件所在的位置，调用<code>fork()</code>创建一个新的子进程来运行命令，调用<code>exec()</code>的某个变体来运行命令，然后通过调用<code>wati()</code>命令来等待命令的完成。当子进程完成时，shell从<code>wait()</code>返回并再次打印出一个提示，为下一个命令做好准备。</p><p><code>fork()</code>和<code>exec()</code>的分离允许shell很容易地完成一堆有用的东西。例如: <code>wc p3.c &gt; 1.txt</code><br>shell完成此任务的方式非常简单，在创建子进程时，在调用<code>exec()</code>之前，shell关闭stdout并打开文件<code>1.txt</code>。通过这样做，即将运行的此程序的任何输出都被发送到文件而不是屏幕。</p><p>下面的程序便完成这样的操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All Of The Above With Redirection (p4.c)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123; <span class="comment">// &gt;&gt;&gt;fork failed; exit</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fork failed\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123; <span class="comment">// child: redirect standard output to a file</span></span><br><span class="line">        close(STDOUT_FILENO);</span><br><span class="line">        open(<span class="string">"./p4.output"</span>, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);</span><br><span class="line">        <span class="comment">// now exec "wc"...</span></span><br><span class="line">        <span class="keyword">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">        myargs[<span class="number">0</span>] = strdup(<span class="string">"wc"</span>); <span class="comment">// program: "wc" (word count)</span></span><br><span class="line">        myargs[<span class="number">1</span>] = strdup(<span class="string">"p4.c"</span>); <span class="comment">// argument: file to count</span></span><br><span class="line">        myargs[<span class="number">2</span>] = <span class="literal">NULL</span>; <span class="comment">// marks end of array</span></span><br><span class="line">        execvp(myargs[<span class="number">0</span>], myargs); <span class="comment">// runs word count</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// parent goes down this path (main)</span></span><br><span class="line">        <span class="keyword">int</span> rc_wait = wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./p4</span><br><span class="line"></span><br><span class="line">cat p4.output</span><br><span class="line"> 29 116 874 p4.c</span><br></pre></td></tr></table></figure><p>首先，当运行p4时，看起来好像什么也没有发生过。shell只是打印命令提示符，并立即为下一个命令做准备。但事实并非如此，p4确实调用<code>fork()</code>来创建一个新子节点，然后通过调用<code>execvp()</code>来运行wc程序。你没有看到任何输出打印到屏幕是因为它已被重定向到文件中。</p><p>Unix <strong>管道(pipe)</strong> 以类似的方式实现，但使用<code>pipe()</code>系统调用。这种情况下，一个进程的输出连接到一个内核管道(即队列)，另一个进程的输入连接到同一个管道。因此，一个进程的输出无缝地用作下一个进程的输入，并且长而有用的命令链可以串在一起。如这个栗子: <code>grep -o foo file | wc -l</code>。</p><p>现在，只需说<code>fork()</code>和<code>exec()</code>组合是一种创建和操作进程的强大方法就足够了。</p><p><br></p><blockquote><p>ASIDE: <strong>READ THE MAN PAGES</strong><br>本书中，当提到特定的系统调用或库调用时，会让你阅读<strong>手册(man/manual pages)</strong>。花时间阅读手册石喜彤程序员成长的关键一步，这些手册页中隐藏了大量有用的花絮。<br>最后，阅读手册可让你避免一些尴尬。当你向别人询问问题是，别人可能会叫你阅读文档。</p></blockquote><p><br><br><br></p><h3 id="进程控制和用户"><a href="#进程控制和用户" class="headerlink" title="进程控制和用户"></a>进程控制和用户</h3><p>Process Control And Users</p><p>在Unix系统中，除了<code>fork()</code>, <code>exec()</code>, <code>wait()</code>之外，还有许多其它接口可与进程进行交互。例如，<code>kill()</code>系统调用用于向进程发送<strong>信号(signal)</strong>，包括暂停(pause)、死亡(die)和其它有用的指令。为了方便起见，在大多数Unix Shell中，某些键组合被配置为向当前运行的进程传递特定信号。栗子如下:</p><div class="table-container"><table><thead><tr><th>键组合</th><th>信号</th><th>描述</th></tr></thead><tbody><tr><td><code>ctrl+c</code></td><td>SIGINT(2)</td><td>中断</td></tr><tr><td><code>ctrl+z</code></td><td>SIGTSTOP(19)</td><td>停止(暂停)</td></tr></tbody></table></div><p>整个信号子系统提供了丰富的基础设施，可为进程提供外部事件，包括在各个进程中接收和处理这些信号的方法，以及向各个进程以及整个进程组(process groups)发送信号的方法。要使用这种通信形式，进程应使用<code>signal()</code>系统调用来捕获(catch)各种信号。这样做可确保当特定信号传递到进程时，它将暂停正常执行并运行特定代码以响应该信号。</p><p>这自然会提出一个问题：<strong>谁可以向进程发送信号，谁不能发送？</strong><br>通常，系统可以让多个用户同时使用。如果其中一个人可以随意发送信号(如<code>SIGINT</code>)，则系统的可用性和安全性将受到影响。因此，现代系统包含用户的强烈概念。用户在输入密码建立凭据后，登录以获取对系统资源的访问权限。然后，用户可以启动一个或多个进程，并对它们进行完全控制(pause, kill…)，用户通常只能控制自己的进程。操作系统的工作是将资源(cpu, mem, disk…)分配给每个用户(及其进程)以满足整体系统目标。</p><p><br><br><br></p><h3 id="有用的工具"><a href="#有用的工具" class="headerlink" title="有用的工具"></a>有用的工具</h3><p>Useful Tools</p><p>有许多命令行工具也很有用。如下:</p><ul><li><code>ps</code></li><li><code>top</code></li><li><code>sar</code></li><li><code>kill</code></li><li><code>killall</code></li></ul><p><br><br><br></p><h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><p>Summary</p><p>我们介绍了一些处理Unix进程创建的API: <code>fork(), exec(), wait()</code>。但是，我们刚刚撇去了表面。</p><p><strong>ASIDE: KEY PROCESS API TERMS</strong></p><ul><li>每个进程都有一个名字，在大多数系统中，该名称为<strong>PID</strong>；</li><li><code>fork()</code>系统调用在Unix系统中用于创建新进程。创建者被称为<strong>父进程（parent）</strong>，被创建的新进程被称为<strong>子进程（child）</strong>；</li><li><code>wait()</code>系统调用允许父进程等待其子进程完成执行；</li><li><code>exec()</code>系统调用允许子进程摆脱与父进程的相似性并执行一个全新的程序；</li><li>Unix Shell通常使用<code>fork(), exec(), wait()</code>来启动用户命令。<code>fork()</code>和<code>exec()</code>的分离支持I/O重定向、管道…；</li><li>进程控制以信号的方式提供，这可能导致作业停止、继续或终止；</li><li>可由特定用户控制哪些进程被封装在用户的概念中。操作系统允许多个用户同时登录，并确保用户只能控制自己的进程；</li><li><strong>超级用户(superuser)</strong>可以控制所有进程。出于安全考虑，请不要使用此用户进行直接操作。</li></ul><p><br><br><br><br><br></p><h2 id="直接执行"><a href="#直接执行" class="headerlink" title="直接执行"></a>直接执行</h2><p><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf" target="_blank" rel="noopener">Mechanism: Limited Direct Execution</a></p><p>为了虚拟化CPU，操作系统需要以某种方式在同时运行的许多作业中共享物理CPU。基本思路很简单：运行一个进程一段时间，然后运行另一个进程，以此类推。通过<strong>分时共享(time sharing)</strong>CPU，实现了虚拟化。</p><p>然而，构建这样的虚拟化也存在一些挑战：</p><ul><li>首先是<strong>性能（Performance）</strong>：如何在不增加系统过多开销的情况下实现虚拟化？</li><li>第二是<strong>控制（Control）</strong>：如何保持在对CPU的控制的同时有效地运行进程？控制对操作系统尤其重要，，因为它控制资源。如果没有控制权，进程就可以永远运行并接管机器，或者访问不应该被它访问的信息。</li></ul><p>因此，要在保持控制的同时获得高性能是构建操作系统的核心挑战之一。</p><blockquote><p>关键：<strong>如何通过控制有效地虚拟化CPU</strong><br>操作系统必须以有效地方式虚拟化CPU，同时保持对系统的控制。为此，需要硬件和操作系统的支持。操作系统通常会使用明智的硬件支持来完成其工作。</p></blockquote><p><br><br><br></p><h3 id="基本技术：有限的直接执行"><a href="#基本技术：有限的直接执行" class="headerlink" title="基本技术：有限的直接执行"></a>基本技术：有限的直接执行</h3><p>Basic Technique: Limited Direct Execution</p><p>为了使程序以预期的速度运行，操作系统开发人员提出了一种技术——<strong>有限的直接执行（limited direct execution）</strong>。<strong>直接执行（direct execution）</strong>的想法很简单：只需在CPU上直接运行程序即可。因此，当操作系统启动一个程序运行时，它会在进程列表中为它创建一个进程条目，为它分配一些内存，将程序代码加载到内存中，找到它的入口点(<code>main()</code>例程或类似的东西)，跳转到它，并开始运行用户的代码。</p><p><br></p><p><strong>Direct Execution Protocol (Without Limits)</strong></p><div class="table-container"><table><thead><tr><th>OS</th><th>Program</th></tr></thead><tbody><tr><td>创建进程列表条目<br>为程序分配内存<br>将程序加载到内存<br>使用<code>argc/argv</code>设置堆栈<br>清除寄存器<br>执行调用<code>main()</code></td><td></td></tr><tr><td></td><td>运行<code>main()</code><br>从main执行return</td></tr><tr><td>释放进程内存<br>从进程列表中删除条目</td></tr></tbody></table></div><p>听起来很简单，但这种方法在我们尝试虚拟化CPU的过程中会产生一些问题：</p><ul><li>如果我们只运行一个程序，操作系统如何确保程序不执行我们不希望它执行的操作，同时仍然有效地运行它？</li><li>当运行一个程序时，操作系统如何阻止它运行并切换到另一个进程，从而实现我们虚拟化CPU所需的分时共享？</li></ul><p><br><br><br></p><h3 id="问题1：受限制的操作"><a href="#问题1：受限制的操作" class="headerlink" title="问题1：受限制的操作"></a>问题1：受限制的操作</h3><p>Problem1: Restricted Operations</p><p>直接执行具有快速的明显优势，程序直接在原生CPU硬件上运行，因此可按照预期的速度执行。但是在CPU上运行会引发一个问题：如果进程希望执行某种受限制的操作（如向磁盘发出I/O请求，访问更多系统资源(cpu, kernel)…），该怎么办？</p><blockquote><p><strong>如何执行受限制的操作</strong><br>进程必须能够执行I/O或其它一些受限制的操作，但不能让进程完全控制系统。操作系统和硬件该如何协同工作？</p></blockquote><p><br></p><blockquote><p><strong>为什么系统调用看起来像程序调用</strong><br>你可能想知道为什么对系统调用（如<code>open(), read()...</code>）的调用看起来与C中的典型过程调用（procedure call）完全相同。也就是说，它看起来就像一个过程调用，系统如何知道它是一个系统调用，并做了所有正确的事情？原因很简单：它是一个过程调用，但隐藏在过程调用内部的是著名的<strong>陷阱指令（trap instruction）</strong>。举个栗子，当调用<code>open()</code>时，你正在执行对C library的过程调用。其中，无论是对于<code>open()</code>还是其它的系统调用，库都使用与内核达成一致的调用约定，将参数放在众所周知的位置（stack或register），也将系统调用号放入一个众所周知的位置(stack或register)，然后执行上述陷阱指令。陷阱解压后库中的代码将返回值，并将控制权返回给发出系统调用的程序。因此，进行系统调用的C库部分是在汇编中手工编码的，因为它们需要仔细准遵循约定，以便正确处理参数和返回值，以及执行特定于硬件的陷阱指令。这个汇编代码已经有人替你做了。</p></blockquote><p><br></p><p>一种方法是让任何进程在I/O和其它相关操作方面做任何它们想做的事情。然而，这样做会妨碍构建所需的多种操作系统。例如，如果我们希望构建一个在授予文件访问权限之前检查权限的文件系统，我们不能简单地让任何用户进程向磁盘发出I/O。如果这样做了，一个进程可以简单地读写整个磁盘，因此所有的保护都将丢失。</p><p>因此，我们采用一种新的处理器模式——<strong>用户模式（user mode）</strong>。在用户模式下运行的代码受限于它们可以执行的操作。例如，在用户模式下运行时，进程无法发出I/O请求，这样做了会导致处理器引发异常，操作系统可能会杀死这个进程。</p><p>与用户模式相反，<strong>内核模式（kernel mode）</strong>是操作系统运行的模式。在此模式下，运行的代码可以执行其喜欢的操作，包括发出I/O请求、执行所有类型的受限制的指令。</p><p>但是，当<strong>用户进程（user process）</strong>希望执行某种特权操作（如I/O）时应该做什么？为了实现这一点，几乎所有的现代硬件都为用户程序提供了执行系统调用的能力。系统调用允许内核小心地将某些关键功能部件暴露给用户程序。如访问文件系统、创建和销毁进程、与其它进程通信以及分配更多内存…大多数操作系统提供了几百个调用（详情请参考POSIX标准）。</p><p><br></p><blockquote><p><strong>使用受保护的控制转移</strong><br>硬件通过提供不同的执行模式来协助操作系统。<br>在用户模式下，应用程序无法完全访问硬件资源。<br>在内核模式下，操作系统可以访问机器的全部资源。<br>还提供了从陷阱（trap）到内核（kernel）并<strong>从陷阱返回（return-from-trap）</strong>到用户模式的特殊指令，以及允许操作系统告知硬件陷阱表（trap table）驻留在内存中的指令。</p></blockquote><p><br></p><p>要执行系统调用，程序必须执行特殊的陷阱指令。该指令同时跳转到内核并将权限级别提升为内核模式。一旦进入内核，系统现在可以执行所需的任何特权操作（如果允许），从而为调用进程执行所需的工作。完成后，操作系统会调用一个特殊的<strong>从陷阱返回（return-from-trap）</strong>指令，该指令将返回到调用用户程序，同时将权限级别降低到用户模式。</p><p>执行陷阱(trap)时硬件需要小心，它必须确保保存足够的调用程序寄存器（caller’s register），以便在操作系统发出<code>return-from-trap</code>指令时能够正确返回。例如，在x86上，处理器会将程序计数器（counter）、标志（flag）和一些其它寄存器（register）推送（push）到每个进程的<strong>内核栈（kernel stack）</strong>。<code>return-from-trap</code>会将这些值从栈中弹出（pop）并继续执行用户模式的程序。其它硬件系统可能有所不同，但基本概念在不同平台上是相同的。</p><p>还有一个重要细节：陷阱如何知道在操作系统中运行哪些代码？显然，调用进程无法指定要跳转的地址。这样做会让程序跳转到内核，这显然是一个非常糟糕的想法。因此内核必须消息控制在陷阱（trap）上执行的代码。</p><p>内核通过在启动时设置<strong>陷阱表（trap table）</strong>来实现。当机器启动时，它在特权（内核）模式下，因此可以根据需要自由配置机器硬件。操作系统首先要做的事情之一就是告诉硬件在发生某些异常事件时要运行什么代码。<br>例如，当发生硬盘中断、发生键盘中断或程序进行系统调用时，应该运行什么代码？操作系统通常通过某种特殊指令通知硬件这些<strong>陷阱处理程序（trap handler）</strong>的位置。一旦通知硬件，它会记住这些处理程序的位置，直到机器下次重启，因此当系统调用或其它异常事件发生时，硬件知道该做什么。</p><p><br></p><p><strong>Limited Direct Execution Protocol</strong></p><div class="table-container"><table><thead><tr><th>os@boot</th><th>hardware</th></tr></thead><tbody><tr><td>initialize trap table</td><td></td></tr><tr><td></td><td>remember address of… <br> syscall handler</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>os@run</th><th>hardware</th><th>program(user mode)</th></tr></thead><tbody><tr><td>Create entry for process list<br>Allocate memory for program<br>Load program into memory<br>Setup user stack with argv<br>Fill kernel stack with reg/PC<br>return-from-trap</td><td></td><td></td></tr><tr><td></td><td>restore regs(from kernel stack)<br>move to user mode<br>jump to main</td><td></td></tr><tr><td></td><td></td><td>Run main()<br>…<br>Call system call<br>trap into OS</td></tr><tr><td></td><td>save regs(to kernel stack)<br>move to kernel mode<br>jump to trap handler</td><td></td></tr><tr><td>Handle trap<br>Do work of syscall<br>return-from-trap</td><td></td><td></td></tr><tr><td></td><td>restore regs(from kernel stack)<br>move to user mode<br>jump to PC after trap</td><td></td></tr><tr><td></td><td></td><td>…<br>return from main<br>trap (via exit())</td></tr><tr><td>Free memory of process<br>Remove from process list</td><td></td></tr></tbody></table></div><p>此时间线总结了协议。假设每个进程都有一个内核寄存器，其中寄存器在进入和退出内核时保存到硬件，并从硬件恢复。</p><p><br></p><blockquote><p><strong>警惕安全系统中的用户输入</strong><br>即使我们在系统调用期间都非常努力地保护操作系统（通过添加硬件陷阱机制），但实现安全操作系统还有许多其它方面必须考虑。其中之一是在系统调用边界梳理参数，操作系统必须检查用户传入的内容并确保正确指定了参数，否则拒绝该调用。例如，通过<code>write()</code>调用，用户将缓冲区的地址指定为write调用的源。如果用户(意外或恶意)传入坏地址（如，内核地址空间的一部分），操作系统必须检测到这一点并拒绝该调用。否则，用户可以读取所有内核内存。鉴于kernel（virtual）内存通常还包括其它的所有物理内存，这个小的滑动将使程序能够读取系统中的任何其它进程的内存，这是非常危险的。<br>通常，安全系统必须非常怀疑地（great suspicion）处理用户输入。不这样做容易导致软件被黑，世界是一个不安全和可怕的地方。</p></blockquote><p><br></p><p>要指定确切地系统调用，通常会为每个系统调用分配<strong>系统调用号（system call number）</strong>。因此，用户代码负责将所有所需的系统调用号放在寄存器或栈上的特定位置。操作系统在陷阱处理程序内部处理系统调用时，检查此号码，确保它有效。如果有效，则执行相应的代码。这种间接性是一种保护形式，用户代码无法指定要跳转确切地址，而是必须通过号码请求特定服务。</p><p>能够执行指令告诉硬件陷阱表所在的位置是一个非常强大的功能。因此，如你所猜，它也是一种特权操作（ privileged operation）。如果你在用户模式下执行此指令，硬件不会鸟你。<br>如果你可以安装自己的陷阱表，你可以对系统做些什么可怕的事情？你能接管机器吗？</p><p><br></p><p>有限的直接执行（LDE）有两个阶段：</p><ul><li>启动时，内核初始化陷阱表，CPU会记住它的位置以供后续使用；</li><li>内核通过特权指令执行此操作。<br>内核在使用<code>return-from-trap</code>指令开始执行进程之前设置了一些东西（分配进程列表、内存…）。这会将CPU切换到用户模式并开始运行此进程。当进程希望发出系统调用时，操作系统处理进程并再次通过<code>return-from-trap</code>将控制权返回给进程。然后进程完成其工作，并从<code>main()</code>返回。它通常会返回存根代码，它将正确地退出程序。此时操作系统清理完毕，就完成了。</li></ul><p><br><br><br></p><h3 id="问题2：在进程间切换"><a href="#问题2：在进程间切换" class="headerlink" title="问题2：在进程间切换"></a>问题2：在进程间切换</h3><p>Problem2: Switching Between Processes</p><p>直接执行的下一个问题是实现<strong>进程之间的切换（switch between process）</strong>。进程之间的切换很简单吗？操作系统应该决定停止一个进程并启动另一个进程。这看起来简单，但实际上有点棘手。具体来说，如果一个进程在CPU上运行，这意味着操作系统没有运行。如果操作系统没有运行，它怎么能做任何事情？吐过操作系统没有在CPU上运行，它显然没有办法采取行动。</p><blockquote><p><strong>如何恢复控制CPU</strong><br>操作系统如何重新获得对CPU的控制，以便它可在进程间切换？</p></blockquote><p><br><br><br></p><h4 id="合作方法：等待系统调用"><a href="#合作方法：等待系统调用" class="headerlink" title="合作方法：等待系统调用"></a>合作方法：等待系统调用</h4><p>A Cooperative Approach: Wait For System Calls</p><p>一些系统过去采用一种<strong>合作方法（cooperative approach）</strong>。在这种风格中，操作系统信任系统的进程以合理地运行。假定运行时间过长的进程会定期放弃CPU，以便操作系统可以决定运行其它任务。</p><p>因此，你可能会问，友好的进程如何在这个乌托邦世界中放弃CPU？事实证明，大多数进程通过进行系统调用来非常频繁地将CPU的控制权转移到操作系统。像这样的系统通常包括一个显式的<code>yield</code>系统调用，除了将控制权转移到操作系统（以便操作系统可以运行其进程）之外什么都不做。</p><p>应用程序在执行非法操作时也会将控制权转移到操作系统。举个栗子，如果应用程序除以零，或者尝试访问它无法访问的内存，则会为操作系统生成陷阱（trap）。然后操作系统再次获得CPU控制权（并可能终止非法进程）。</p><p>因此，在协同调度（cooperative scheduling）系统中，操作系统通过等待系统调用或某种非法操作来重新获得CPU的控制权。你可能回想，这种被动方法也不理想呀！如果一个进程（恶意或错误）最终在无限循环中结束，并且从不进行系统调用，会发生什么？操作系统可以做什么？</p><p><br><br><br></p><h4 id="非合作方法：操作系统取得控制权"><a href="#非合作方法：操作系统取得控制权" class="headerlink" title="非合作方法：操作系统取得控制权"></a>非合作方法：操作系统取得控制权</h4><p>A Non-Cooperative Approach: The OS Takes Control</p><p>如果没有硬件的额外帮助，当一个进程拒绝进行系统调用并因此将控制权返回给操作系统时，操作系统根本无法做很多事情。事实上，在合作方法中，当一个进程陷入无限循环时，你唯一的办法就是采用古老的办法解决计算机系统中的所有问题：重启（Reboot）。因此，我们再次提出了获得CPU控制权的一个子问题。</p><p><br></p><blockquote><p><strong>如何在没有合作的情况下获得控制权（HOW TO GAIN CONTROL WITHOUT COOPERATION）</strong><br>即使进程没有合作，操作系统如何才能获得对CPU的控制？操作系统可以做些什么确保流氓进程不会接管机器？</p></blockquote><p><br></p><p>答案很简单，许多人在许多年前构建操作系统时已经发现了：<strong>定时器终端（timer interrupt）</strong>。可以对定时器设备进行编程，以便每隔几毫秒(ms)产生一次中断。当中断被引发时，当前正在运行的进程停止（halted），并且操作系统中预配置的中断处理程序运行。此时，操作系统重新获得CPU的控制权。因此可以随心所欲：停止当前进程并启动另一个进程。</p><p>如前面讨论的那样，系统调用时，操作系统必须通知硬件当中断定时器发生时执行什么代码。因此，在启动时，操作系统就是这样做的。其次，在引导序列期间，操作系统必须启动定时器（这当然是特权操作）。一旦计时器开始，操作系统就可以感觉安全，因为控制权最终将返回给它，因此操作系统可以自由运行用户程序。</p><p><br></p><blockquote><p><strong>处理应用程序的坏事（DEALING WITH APPLICATION MISBEHAVIOR）</strong><br>操作系统通常必须处理行为不当的进程，这些进程（恶意或错误）尝试做它们不应该做的事情。在现代操作系统中，操作系统处理此类不当行为的方式是简单地终止（terminate）违法者。但当你试图非法访问内存或执行非法指令时，操作系统应该做什么呢？</p></blockquote><p><br></p><p>请注意，当发生中断时硬件有一定的责任，特别是为了保存中断发生时运行的程序的足够的状态，以便后续的<code>return-from-trap</code>指令能够正确地恢复正在运行的程序。这组操作非常类似与在显式系统调用陷阱到内核期间硬件的行为，因此各种寄存器被保存，因此可通过<code>return-from-trap</code>轻松恢复。</p><p><br><br><br></p><h4 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h4><p>Saving and Restoring Context</p><p>现在操作系统已经重新获得了控制权，无论是通过系统调用，还是通过定时器中断，都必须做出决定——是继续运行当前进程，还是切换到另一个进程。该决定由称为<strong>调度程序（scheduler）</strong>的操作系统的一部分做出，这将在后面学习。</p><p>如果决定做切换，则操作系统执行低级代码。我们称之为<strong>上下文切换（context switch）</strong>。上下文切换的概念很简单：所有操作系统必须做的是为当前正在执行的进程保存一些寄存器值（如，在其内核栈上），并为即将执行的进程恢复（如，来自其内核栈）。通过这样做，操作系统因此确保当最终执行<code>return-from-trap</code>指令时，系统继续执行另一个进程，而不是返回到正在运行的进程。</p><p>为了保存当前正在运行的进程的上下文，操作系统将执行一些低级汇编代码（low-level assembly code），以保存和运行当前正在运行的进程的通用寄存器、PC、内核栈指针，然后恢复所述寄存器、PC，并切换到内核堆栈，以便于即将执行的进程。通过切换栈，内核在一个进程（被中断的进程）的上下文中进行切换代码的调用，并在另一个进程（将被执行的进程）的上下文中返回。操作系统最终执行<code>return-from-trap</code>指令，即将执行的进程将成为当前正在运行的进程。因此上下文切换完成。</p><p><br></p><blockquote><p><strong>使用定时器中断来重新获得控制权</strong><br>定时器中断使操作系统能够在CPU上再次运行，即使进程以非协作方式运行。因此，此硬件功能对于帮助操作系统维护机器的控制至关重要。</p></blockquote><p><br></p><blockquote><p><strong>重启是有用的</strong><br>早些时候，我们注意到在协作下抢占无限循环（infinite loops）的唯一解决办法是重启机器。虽然你可能会嘲笑，但研究人员已经证明重启可以成为构建健壮系统的一个非常有用的工具。<br>具体来时，重启是有用的。因为它将软件移回到已知且更加可测试的状态。重启还会回收陈旧或泄露的资源（如，memory），否则这些资源可能难以处理。最后，重启很容易实现自动化。</p></blockquote><p><br></p><p>整个进程的时间线如下所示。在此示例中，进程A正在运行，然后被定时器中断所中断。硬件保存其寄存器（在其内核栈上）并进入内核（切换到内核模式）。在定时器中断处理程序中，操作系统决定从正在运行的进程A切换到进程B。此时，它调用<code>switch()</code>例程，该例程小心地保存当前寄存器值（进入A的进程结构），恢复进程B的寄存器（来自其进程结构条目），然后切换上下文，特别是通过更改栈指针来使用B的内核栈（而不是A的）。最后，操作系统执行<code>return-from-trap</code>，它恢复B的寄存器并开始运行它。</p><p><strong>: Limited Direct Execution Protocol (Timer Interrupt)</strong></p><div class="table-container"><table><thead><tr><th>os@boot<br>kernel mode</th><th>hardware</th></tr></thead><tbody><tr><td>initialize trap table</td><td></td></tr><tr><td></td><td>remember addresses of…<br>syscall handler<br>timer handler</td></tr><tr><td>start interrupt timer</td><td></td></tr><tr><td></td><td>start timer<br>interrupt CPU in X ms</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>os@boot<br>kernel mode</th><th>hardware</th><th>program<br> user mode</th></tr></thead><tbody><tr><td></td><td></td><td>Process A<br>…</td></tr><tr><td></td><td>timer interrupt<br>save regs(A) → k-stack(A)<br>move to kernel mode<br>jump to trap handler</td><td></td></tr><tr><td>Handle the trap<br>Call <code>switch()</code> routine<br>save regs(A) → proc t(A)<br>restore regs(B) ← proc t(B)<br>switch to k-stack(B)</td><td></td><td></td></tr><tr><td>return-from-trap (into B)</td><td></td><td></td></tr><tr><td></td><td>restore regs(B) ← k-stack(B)<br>move to user mode<br>jump to B’s PC</td><td></td></tr><tr><td></td><td></td><td>Process B<br>…</td></tr></tbody></table></div><p><br><br><br></p><h3 id="担心并发？"><a href="#担心并发？" class="headerlink" title="担心并发？"></a>担心并发？</h3><p>Worried About Concurrency?</p><p>细心的读者可能会想到：在系统调用期间发生定时器中断，会发生什么？或，当你在处理一个中断时而另一个中断发生会发生什么？在内核中难处理吗？……</p><p>操作系统确实需要关注在中断或陷阱处理期间发生其它中断会发生什么。事实上，这是本书后面关于<strong>并发（concurrency）</strong>的内容。为了满足读者的胃口，这里介绍操作系统如何处理这些棘手情况的一些基础知识。</p><p>操作系统可能做的一件简单的事情，在中断处理期间<strong>禁用中断(disable interrupts)</strong>。这样做可确保在处理一个中断时，不会将其它任何中断传递到CPU。当然，操作系统必须小心这样做，长时间禁用可能会导致中断丢失，这是不好的。</p><p>操作系统还开发了许多复杂的<strong>锁定（locking）</strong>方案，以保护对内部数据结构的并发访问。这使得许多活动可以同时在内核中进行，特别适用于多处理器（multiprocessors）。这种锁定可能很复杂，并导致各种有趣且难以发现的错误(bugs)。</p><p><br><br><br></p><h3 id="摘要-2"><a href="#摘要-2" class="headerlink" title="摘要"></a>摘要</h3><p>我们描述了一些实现CPU虚拟化的关键低级机制，这是一组我们统称为<strong>有限直接执行（limited direct execution）</strong>的技术。基本思路很简单：只需运行你想在CPU上运行的程序，但首先要确保设置硬件以便在没有操作系统辅助的情况下限制进程可以执行的操作。</p><p>我们具有虚拟化CPU的基本机制。但是一个主要问题没有回答：我们应该在给定时间运行哪个进程？<strong>调度器</strong>必须回答这个问题，这是后面讨论的问题。</p><p><br></p><blockquote><p><strong>上下文切换会花费多长时间</strong><br>你可能回想：上下文切换需要多长时间？或系统调用？有一些工作可以准确测量这些东西，以及一些其它可能的指标。<br>这当然也和硬件配置有关系。应当注意，并非所有操作系统都追踪CPU性能。许多操作系统是内存密集型的，并且内存带宽并没有像处理器速度那样显著提高。所以，购买强大的硬件配置能加速你的操作系统。</p></blockquote><p><br></p><p><strong>CPU虚拟化术语</strong></p><ul><li>CPU至少支持两种执行模式：<strong>受限的用户模式</strong>和<strong>特权内核模式（非受限）</strong></li><li>典型的用户应用程序以用户模式运行，并使用系统调用来陷阱(trap)到内核中以请求操作系统服务</li><li>陷阱指令小心保存寄存器状态，将硬件状态更改为内核模式，并跳转到操作系统到预先指定的目标：<strong>陷阱表（trap table）</strong></li><li>当操作系统完成对系统调用的服务时，它会通过另一个特殊的<code>return-from-trap</code>指令返回到用户程序，这会降低权限并在跳转到操作系统的陷阱后将控制权返回给指令</li><li>操作系统必须在引导（boot）时设置陷阱表，并确保用户程序无法轻松修改它们。所有这些都是有限直接执行协议的一部分，改写以有效地运行程序但不会丢失操作系统控制</li><li>程序运行后，操作系统必须使用<strong>硬件机制（定时器中断）</strong>来确保用户程序不会永远运行。这种方法是CPU调度的非协作方法</li><li>有时，在定时器中断或系统调用期间，操作系统可能希望从运行当前进程切换到另一个进程，这是一种被称为<strong>上下文切换（context switch）</strong>的低级技术</li></ul><p><br><br><br><br><br></p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched.pdf" target="_blank" rel="noopener">CPU Scheduling</a></p><p>到现在为止，运行进程的低级机制（上下文切换）应该是清楚的。但是，我们尚未了解操作系统调度程序使用的高级策略。<br>事实上，调度的起源早于计算机系统。早期的方法来自运营管理领域并应用于计算机。</p><p><br></p><blockquote><p><strong>如何制定调度策略（SCHEDULING POLICY）</strong><br>如何开发一个思考型调度策略的基本框架？关键假设是什么？哪些指标很重要？在最早的计算机系统中使用了哪些方法？</p></blockquote><p><br><br><br></p><h3 id="工作负载假设"><a href="#工作负载假设" class="headerlink" title="工作负载假设"></a>工作负载假设</h3><p>Workload Assumptions</p><p>在介绍可能的策略范围之前，让我们首先对系统中运行的进程做一些简化的假设，有时统称为<strong>工作负载（workload）</strong>。确定工作负载是构建策略的关键部分，对工作负载了解的越多，你的策略就越精细。</p><p>我们将对系统中的进程（有时称为作业(jobs)）做出以下假设：</p><ul><li>每个作业运行相同的时间</li><li>所有作业都在同一时间完成</li><li>一旦启动，每个作业都会运行完成</li><li>所有作业仅使用CPU</li><li>每个作业的运行时间都是已知的</li></ul><p>这些假设很多是不现实的，正如乔治奥威尔《动物农场》中的一些动物比其它动物更平等，本章的一些假设比其它假设更不切实际。特别是，每个作业的运行时间都是已知的。这样做使调度程序无所不知。</p><p><br><br><br></p><h3 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h3><p>Scheduling Metrics</p><p>除了进行工作负载假设之外，还需要一件事来使我们能够比较不同的调度策略：<strong>调度指标（Scheduling Metrics）</strong>。指标用来衡量某些事物，不同的指标在调度中也有不同的意义。<br>但是，就目前而言。我们来看一个简单的指标：<strong>周转时间（turnaround time）</strong>。作业的周转时间定义为作业完成时间减去作业到达系统的时间：</p><script type="math/tex; mode=display">T_{turnaround} = T_{completion} − T_{arrival}</script><p>应该注意，周转时间是一个性能指标。这将是本章的主要关注点。另一个有趣的指标是<strong>公平性（fairness）</strong>。在调度方面，性能和公平性往往不一致，这也告诉我们生活并不总是完美的。</p><p><br><br><br></p><h3 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h3><p>First In, First Out (FIFO)</p><p>一个最基本的算法为<strong>先进先出（First In First Out (FIFO)）</strong>调度。它具有许多积极的属性，简单且易于实现。并且根据假设，它运作良好。</p><p>让我们做一个快速的栗子。想象一下，有三个作业A, B, C在大致相同的时间到达系统（<script type="math/tex">T_{arrival}=0</script>）。由于先进先出必须放置一些工作，让我们假设A-B-C的顺序，假设每个作业运行10s。这些作业的平均周转时间是多少？</p><p><img src="/images/OSTEP/fifo71.png" alt></p><p>如图，A在10时完成，B在20时完成，C在30时完成。因此，三个作业的平均周转时间仅为<script type="math/tex">\frac{10+20+30}{3}=30</script>。</p><p><br></p><p>让我们举个栗子来说明不同长度的作业如何导致先进先出调度出现问题。特别是，假设A运行100s,B和C还是10s。</p><p><img src="/images/OSTEP/fifo72.png" alt></p><p>如图所示，在B或C有机会运行之前，作业A首先整整运行100s。因此，系统的平均周转时间很长：<script type="math/tex">\frac{100+110+120}{3}=110</script>，痛苦的110s。<br>这个问题通常被称为<strong>车队效应（convoy effect）</strong>，其中资源的一些小型消费者排在重量级消费者后面。那该怎么办？我们如何开发一种更好的算法来处理？</p><p><br><br><br></p><h3 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h3><p>Shortest Job First (SJF)</p><blockquote><p><strong>最短作业优先的原则</strong><br>最短作业优先表示可用于任何系统的一般调度原则，其中每个作业的感知周转时间很重要。如果有关机构关心客户满意度的话，很可能他们已经考虑使用最短作业优先。</p></blockquote><p><br></p><p><strong>最短作业优先（Shortest Job First(SJF)）</strong>，它首先运行最短的作业，然后是下一个最短的作业，依此类推。</p><p><img src="/images/OSTEP/sjf73.png" alt></p><p>如图，该图表明了最短作业优先在平均周转时间方面的表现要好得多。它将之前的平均周转时间从110s减少到50s（<script type="math/tex">\frac{10+20+120}{3}=50</script>），这是极大的改善。<br>事实上，鉴于我们对所有作业的假设都是同时到达，所以证明它是最优调度算法。但我们的假设相当不切实际。</p><p><br></p><p>这里再举个例子。假设A在<code>t=0</code>时到达并且需要运行100s，而B和C在<code>t=10</code>时到达并且每个需要运行10s。</p><p><img src="/images/OSTEP/sjf74.png" alt></p><p>如图，即使B和C在A之后不久到达，他们仍然被迫等到A完成，因此遭遇了同样的车队问题。平均周转时间为103.33s（<script type="math/tex">\frac{100+(110-10)+(120-10)}{3}</script>）。调度程序能做什么？</p><p><br></p><blockquote><p><strong>预备调度器</strong><br>事实上，所有现代调度程序都是先发制人，并且非常愿意停止一个运行的进程以运行其它进程。这意味着调度程序采用我们之前学习的机制。特别是，调度程序可以进行上下文切换，暂时停止一个正在运行的进程并恢复另一个进程。</p></blockquote><p><br><br><br></p><h3 id="最短完成时间优先"><a href="#最短完成时间优先" class="headerlink" title="最短完成时间优先"></a>最短完成时间优先</h3><p>Shortest Time-to-Completion First (STCF)</p><p>我们还需要调度程序本身内的一些机制。鉴于前面关于计时器中断和上下文切换的讨论，调度程序当然可以在B和C到达时执行其它操作：它可以抢占作业A并决定运行另一个作业，可能会在执行继续作业A。最短作业优先是<strong>非抢先式（non-preemptive）</strong>调度程序，因此会遇到上述问题。<br>幸运的是，有一个调度程序正是这样做：向最短作业优先添加抢占，称为<strong>最短完成时间优先（Shortest Time-to-Completion First (STCF)）</strong>，或<strong>抢先最短作业优先（Preemptive Shortest Job First (PSJF)）</strong>调度程序。每当新作业进入系统时，最短完成时间优先调度程序就会确定剩余作业（包括新作业）中的哪一个剩余时间最少，并安排该作业。</p><p><img src="/images/OSTEP/stcf75.png" alt></p><p>如图，最短完成时间优先将抢占作业A并运行作业B和作业C以完成。只有当它们完成时才会安排作业A的剩余时间。<br>这会大大改善平均周转时间：<script type="math/tex">\frac{(120-0)+(20-10)+(30-10)}{3}=50</script>。根据假设，可证明最短完成时间优先是最优。但假设相当不切实际。</p><p><br><br><br></p><h3 id="响应时间指标"><a href="#响应时间指标" class="headerlink" title="响应时间指标"></a>响应时间指标</h3><p>A New Metric: Response Time</p><p>如果我们知道工作长度，并且工作只使用了CPU，并且我们唯一的指标是周转时间。那个STCF将是一个很好的策略。实际上，对于早期的批处理计算系统，这些类型的算法有一定意义。然而，分时（shared time）机器的引入改变了这一切。现在，用户将坐在终端上并要求系统提供交互式性能。因此，一个新的指标诞生了：<strong>响应时间（response time）</strong>。</p><p>响应时间：<script type="math/tex">T_{response=T_{firstrun}-T_{arrival}}</script></p><p>例如，作业A在0时到达，作业B和作业C在10时到达。则每个作业的相应时间如下：A(0-0)，B(10-10)，C(20-10)，平均值(3.33)。</p><p>正如你可能认为那样，STCF和相关方法对响应时间并不是特别好。如果三个作业同时到达，则第三个作业必须等待前两个作业完全运行才能安排一次。虽然周转时间很好，但这种方法对于响应时间和交互性来说非常糟糕。事实上，想象一下坐在终端前，打字输入，并且不得不等待10s才能看到系统的响应，因为其它工作已安排在你前面：非常不爽。</p><p>因此，我们还有另外一个问题：如果构建一个对响应时间敏感的调度程序？</p><p><br><br><br></p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>Round Robin</p><p>为了解决这个问题，将引入一种新的调度算法，通常称为<strong>轮询调度（RR, Round Robin）</strong>。基本思路很简单：轮询不是运行作业完成，而是运行<strong>时间切片（time slice）</strong>作业，然后切换到运行队列中的下一个作业。它重复这样做，知道工作完成。因此，轮询有时被称为时间切片（ time-slicing）。注意，时间片的长度必须是定时器中断周期的倍数。例如，如果定时器中断每10ms中断一次，则时间片可以是10ms, 20ms, 10Nms。</p><p><br></p><p>为了更详细的了解轮询，让我们来看一个栗子。假设有三个作业A, B, C在系统中同时到达，并且每个作业都希望运行5s。最短作业优先在运行另一个作业之前运行每个作业（图7.6），相比之下，时间切片为1s的轮询将快速循环作业（图7.7）。</p><p><img src="/images/OSTEP/sjf76.png" alt></p><p><img src="/images/OSTEP/rr77.png" alt></p><p>平均响应时间：</p><ul><li>轮询（RR）：<script type="math/tex">\frac{0+1+2}{3}=1</script></li><li>最短作业优先（SJF）：<script type="math/tex">\frac{0+5+10}{3}=5</script></li></ul><p>如你所见，时间片的长度对轮询至关重要。它越短，响应时间的指标度量下轮询的性能越好。然而，使时间片太短是有问题的：上下文切换的成本将主导整体的性能。因此，决定时间片的长度给系统设计者带来了折中，使其足够长以<strong>分摊（amortize）</strong>切换成本不会使系统不再响应。</p><p><br></p><blockquote><p><strong>分摊可以降低成本（ AMORTIZATION CAN REDUCE COSTS）</strong><br>当某些操作存在固定成本时，一般的分摊技术通常用于系统中。通过较少地产生该成本，降低了系统的总成本。例如，如果时间片设置为10ms，并且上下文切换成本为1ms，则大约10%的时间用于上下文切换，浪费了。如果我们想分摊此成本，我们可以增加时间片（如100ms）。在这种情况下，上下文切换花费的时间少于1%，因此时间切片的成本已经分摊。</p></blockquote><p><br></p><p>请注意，上下文切换的成本不仅仅来自于操作系统保存和恢复一些寄存器的操作。程序运行时，它们在CPU Cache、TLBs、Branch Predictors和其它分片上构建了大量状态(state)。切换到另一个作业会导致刷新(flush)此状态，并且将引入与当前正在运行的作业相关的新状态，这可能导致显著的性能成本。</p><p>因此，如果响应时间是我们的唯一指标，那么具有合理时间片的轮询将是一个出色的调度程序。但我们的老朋友周转时间呢？来看个栗子。A、B、C各自需要5s运行时间，它们同时到达，并且轮询的时间片为1s。从上面轮序的运行图可看出，A在13完成，B在14完成，C在15完成，平均时间为14。</p><p>如果周转时间使我们的指标，则轮序是最糟的策略之一。轮序正在做的是延长每个作业，只要它可以，只需在移动到下一个作业之前运行每个作业一小段。由于周转时间紧关注作业何时完成，因此在很多情况下，轮询几乎是悲观的，甚至比简单的先进先出更差。</p><p>任何公平的策略（如RR），即在小时间范围内在活跃进程之间均匀划分CPU，将在如周转时间的指标上表现不佳。实际上，这是一种固有的权衡：如果你愿意不公平，你可以完成更短的工作，按时以响应时间为代价；如果你更重视公平，那么响应时间会降低，但会以周转时间为代价。这种权衡(trade-off)在系统中很常见。you can’t have your cake and eat it too.</p><p>我们介绍了两种类型的调度程序，当然这些都是基于假设下：</p><ul><li>SJF, STCF优化了周转时间，但对响应时间不利；</li><li>RR优化了响应时间，但对周转时间不利；</li></ul><p><br><br><br></p><h3 id="合并I-O"><a href="#合并I-O" class="headerlink" title="合并I/O"></a>合并I/O</h3><p>Incorporating I/O</p><blockquote><p><strong>重叠使得更高的使用率(OVERLAP ENABLES HIGHER UTILIZATION)</strong><br>如果可能，重叠(overlap)操作以最大化系统的利用率。重叠在许多不同的域中都很有用，包括执行磁盘I/O或向远程计算机发送消息时。在任何一种情况下，启动操作然和切换到其它作业是一个好主意，并提高系统的整体利用率和效率。</p></blockquote><p><br></p><p>放松假设4，假设所有程序都执行I/O。想象一个没有任何输入的程序，它每次会产生相同的输出。</p><p>当作业启动I/O请求时，调度程序明会做一个明确地决定。因为当前正在运行的作业在I/O期间不会使用CPU，它被阻止(blocked)以等待I/O完成。如果将I/O发送到磁盘驱动器，则该进程可能会被阻塞几毫秒或更长时间，具体取决于驱动器当前的I/O负载。因此，调度程序应该可能在那时在CPU上安排另一个作业。</p><p>调度程序还必须在I/O完成时做出决定。发生这种情况时，会引发中断，并且操作系统会运行并将发出I/O请求的进程从阻塞状态(blocked back)移回就绪状态(ready state)。当然，它甚至可以决定在那时开展工作。操作系统应如何处理每个工作？</p><p>为了更好地理解这个问题，让我们假设有两个作业A和B，每个作业需要50ms的CPU时间。但有一个明显的区别：A运行10ms然后发出I/O请求（假设也许10ms），而B只使用CPU 50ms并且不执行I/O。调度程序首先运行A，然后运行B。</p><p><img src="/images/OSTEP/incorporatingIO78.png" alt></p><p><br></p><p>假设正在尝试构建STCF调度程序。显然，只运行一个工作然后运行另一个工作而不考虑I/O是没有意义的。</p><p>一种常见的方法是将A的每个10ms子作业视为独立工作。因此，当系统启动时，它的选择是是否安排10ms A或50ms B。使用STCF是明确的。当A的第一个子作业完成时，只剩下B，它开始运行。接着提交一个A的新子作业，它会抢占B并运行10ms。这样做允许重叠，一个进程在等待另一个进程的I/O完成时使用CPU，这样可以更好地利用该系统。</p><p><img src="/images/OSTEP/incorporatingIO79.png" alt></p><p><br></p><p>因此，我们看到调度程序如何合并I/O。通过将每个CPU突发视为作业，调度程序可确保<strong>交互(interactive)</strong>的进程进程运行。当这些交互式作业执行I/O时，其它CPU密集型作业会运行，从而更好地利用处理器。</p><p><br><br><br></p><h3 id="摘要-3"><a href="#摘要-3" class="headerlink" title="摘要"></a>摘要</h3><p>我们前面假设知道每个作业的长度，这可能是最糟糕的假设。实际上，在通用操作系统中，操作系统对每项工作的长度知之甚少。</p><p>我们介绍了调度背后的基本思想，并开发了两类方法。第一个运行剩余的最短作业，从而优化周转时间；第二个在所有作业之间交替运行，从而优化响应时间。两者都有好有坏，在系统中需要一个权衡。我们还看到了如何将I/O合并到调度中，但仍然没有解决操作系统基本无法看到未来的问题。<br>不久我们将通过构建一个使用最近过去预测未来的调度程序，来了解如何克服这个问题。此调度程序称为<strong>多级反馈队列(multi-level feedback queue)</strong>，它是下一章的主题。</p><p><br><br><br><br><br></p><h2 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h2><p><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-mlfq.pdf" target="_blank" rel="noopener">Scheduling: The Multi-Level Feedback Queue</a></p><p>在本章中，我们将解决一种最著名的调度算法问题，称为<strong>多级反馈队列(MLFQ, Multi-level Feedback Queue)</strong>。多级反馈队列调度程序获得了图灵奖(Turing Award)。随后，调度程序经过多年的改进，完成了现代操作系统中的一些实现。</p><p>多级反馈队列试图解决的根本问题是双重的：</p><ul><li>首先，它希望优化周转时间(turnaround time)。这是通过先运行较短的作业来完成。不幸的是，操作系统通常不知道作业运行的时间长短，这这是SJF, STCF等算法所需要的；</li><li>其次，它希望系统能够对交互式用户的敏感响应，从而最大限度地缩短响应时间。不幸的是，像RR这样的算法会缩短响应时间，但对于周转时间来说却很糟糕。</li></ul><p>因此，问题是：鉴于我们通过对进行一无所知，如何构建调度程序来实现这些目标？在系统运行时，调度程序如何了解正在运行的作业的特征，从而做出更好的调度决策？</p><p><br></p><blockquote><p><strong>如何在没有完美知识的情况下安排调度？</strong><br>如何设计一个调度程序，既可以最大限度地缩短交互式作业的响应时间，又可以在不事先了解作业长度的情况下做大限度地缩短周转时间？<br><br><br>多级反馈队列是从学习过去预测未来的系统的一个很好的栗子。这些方法在操作系统中很常见。当工具具有行为阶段并且因此可预测时，这种方法起作用。当然，必须小心使用这些技术，因为它们很容易出错，并且驱使系统做出比没有任何知识的情况更糟糕的决策。</p></blockquote><p><br><br><br></p><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><p>Basic Rule</p><p>为了构建这样的调度程序(scheduler)，在本章中我们将描述多级反馈队列背后的基本算法。虽然许多实施的MLFQ的细节不同，但大多数方法都是相似的。</p><p>在我们的处理中，MLFQ有许多不同的队列(queue)，每个队列分配不同的优先级(priority level)。在任何给定时间，准备运行的作业都在单个队列中。MLFQ使用优先级来决定在给定时间应该运行哪个作业：选择具有较高优先级的作业来运行。</p><p>当然，在给定队列上可能有多个作业，因此具有相同的优先级。在这种情况下，我们将在这些作业中使用轮询调度(round-robin scheduling)。<br>因此，我们得出了MLFQ的前两个基本规则：</p><ul><li>Rule 1: If <code>Priority(A) &gt; Priority(B)</code>, A runs (B doesn’t)；</li><li>Rule 2: If <code>Priority(A) = Priority(B</code>), A and B run in RR。</li></ul><p><br></p><p>因此，MLFQ调度的关键在于调度程序如何设置优先级。MLFQ不是为每个作业提供固定的优先级，而是根据其观察到的行为(observed behavior)改变(varies)作业的优先级。<br>例如，如果作业在等待键盘输入是反复放弃CPU，MLFQ将保持其高优先级，因为这是交互式进程的行为方式。相反，如果作业长时间集中使用CPU，MLFQ将降低其优先级。通过这种方式，MLFQ将尝试在进程运行时了解进程，从而使用作业历史(history)来预测其未来(future)行为。</p><p>一个特定时刻可能的队列可能如下图这样。在此图中，作业(A和B)处于最高优先级，作业C处于中间，作业D处于最低优先级。<br>当然，只显示某些队列的静态快照并不能真正让你了解MLFQ的工作原理。我们需要的是了解作业优先级如何随时间变化。</p><p><img src="/images/OSTEP/mlfq81.png" alt></p><p><br><br><br></p><h3 id="如何改变优先级"><a href="#如何改变优先级" class="headerlink" title="如何改变优先级"></a>如何改变优先级</h3><p>How To Change Priority</p><p>我们现在必须决定MLFQ如何在作业的生命周期内更改作业的优先级。要做到这一点，我们必须牢记我们的工作负载：<strong>short-running</strong>（可能经常放弃CPU）的交互式作业的混合，以及一些需要大量CPU时间的<strong>longer-running</strong>的<strong>CPU-bound</strong>作业，但响应时间不重要。这将是我们首次尝试优先级调整算法：</p><ul><li>Rule 3： When a job enters the system, it is placed at the highest priority (the topmost queue).</li><li>Rule 4a： If a job uses up an entire time slice while running, its priority is reduced (i.e., it moves down one queue).</li><li>Rule 4b： If a job gives up the CPU before the time slice is up, it stays at the same priority level.</li></ul><p><br></p><h4 id="长作业栗子"><a href="#长作业栗子" class="headerlink" title="长作业栗子"></a>长作业栗子</h4><p>Example 1: A Single Long-Running Job</p><p>让我们看一个简单的栗子。首先我们来看一下当系统中存在长时间运行的作业时会发生什么。</p><p><img src="/images/OSTEP/mlfq-82.png" alt></p><p>如图所示，作业以最高优先级(Q2)进入。在10ms的单个时间片后，调度程序将作业的优先级降低1，因此作业位于Q1上。在Q1运行一段时间后，作业最终降低到系统中最低优先级(Q0)，并保留。</p><p><br><br><br></p><h4 id="短作业栗子"><a href="#短作业栗子" class="headerlink" title="短作业栗子"></a>短作业栗子</h4><p>Example 2: Along Came A Short Job</p><p>让我们看一个复杂的栗子，看看MLFQ如何尝试接近近似SJF。在这个栗子中，有两个作业： A（长时间运行的CPU密集型作业）和B（短时间运行的交互式作业）。假设A已运行一段时间，然后B到达。会发生什么？MLFQ是否会接近B的SJF？</p><p>A（黑色）在最低优先级队列中运行；B（灰色）在<code>T=100</code>到达，因此被插入最高队列；因为它的运行时间很短(20ms)，所以B在到达底部队列之前完成，在两个时间片中；然后A恢复运行(低优先级)。</p><p>从这个栗子中，你可了解该算法的主要目标：因为它不知道工作是短期还是长期，所以它首先假设它可能是一项短期作业，从而使工作成为高优先级。如果它确实是一个短期作业，它将快速完成；如果它不是，它将慢慢向下排队，因此很快证明自己是一个长期运行的批处理进程。以这种方式，MLFQ近似于SJF。</p><p><img src="/images/OSTEP/mlfq-83.png" alt></p><p><br><br><br></p><h4 id="I-O的栗子"><a href="#I-O的栗子" class="headerlink" title="I/O的栗子"></a>I/O的栗子</h4><p>Example 3: What About I/O?</p><p>让我们看一些I/O的栗子。如果交互式作业正在执行大量I/O，它将在时间片完成前放弃CPU。在这种情况下，我们不希望惩罚工作，因此只是将其保持在同一水平。</p><p>图示显示了一个示例，其中交互式作业B在执行与长时间运行的批处理作业A的CPU的I/O竞争之前仅需要CPU 1ms。MLFQ方法将B保持在最高优先级，因此B不断释放CPU；如果B是一个交互式作业，MLFQ进一步实现快速运行交互式工作的目标。</p><p><img src="/images/OSTEP/mlfq-84.png" alt></p><p><br><br><br></p><h3 id="优先级提升"><a href="#优先级提升" class="headerlink" title="优先级提升"></a>优先级提升</h3><p>The Priority Boost</p><p>我们可以做些什么来保证CPU绑定的工作会取得一些进展。<br>这里的简单想法是定期提高系统中所有作业的优先级。有很多方法可以实现这一点，但我们做一些简单的事情：将它们全部放在最顶层的队列中。因此，一条新规则：</p><ul><li>Rule 5： After some time period S, move all the jobs in the system to the topmost queue.</li></ul><p>新规则同时解决了两个问题：保证进程不会挨饿(starve)，通过在最顶层队列中，作业将以循环方式与其它高优先级作业共享CPU，从而获得服务；其次，如果CPU绑定的作业已成为交互式，则调度程序在收到优先级提升后会对其进行正确处理。</p><p><img src="/images/OSTEP/mlfq-85.png" alt></p><p>来看个栗子，在这种情况下，我们只是在与两个短时间运行的交互式作业竞争CPU时显示长时间运行作业的行为。在左边没有优先级提升，因此一旦两个短作业到来，长作业就会挨饿。在右边，每50ms有一个优先级提升，因此我们至少保证长作业取得一些进展，得到提升到每50ms最高优先级，因此定期运行。</p><p><br><br><br></p><h3 id="更好的计算"><a href="#更好的计算" class="headerlink" title="更好的计算"></a>更好的计算</h3><p>Better Accounting</p><p><br><br><br><br><br></p><h2 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h2><p><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-lottery.pdf" target="_blank" rel="noopener">Lottery Scheduling</a></p><p>在本章中，我们将研究一种称为<strong>proportional-share</strong>调度器，有时也称为<strong>fair share</strong>调度器。比例共享基于一个简单的概念：调度程序可能会尝试保证每个作业获得一定比例的CPU时间，而不是优化周转时间或响应时间。</p><p><strong>彩票调度(lottery scheduler)</strong>是共享比例调度一个很好的早期栗子。基本想法非常简单：经常抽奖，以确定下一步应该运行哪一个进程。应该更频繁地运行的进程应该有更多机会赢得彩票，不是吗？</p><p><br></p><blockquote><p>如何按比例共享CPU？<br>如何设计调度程序以按比例的方式共享CPU？这样的关键机制是什么？它们的效果如何？</p></blockquote><p><br><br><br></p><h3 id="票代表你的份额"><a href="#票代表你的份额" class="headerlink" title="票代表你的份额"></a>票代表你的份额</h3><p>Tickets Represent Your Share</p><p>抽奖调度是一个非常基本的概念：<strong>tickets</strong>，用于表示进程应该接收的资源的份额。进程所拥有的票百分比代表其所涉系统资源的份额。</p><p>来看个栗子。两个进程A（75票）和B（25票）。因此，我们想要的是A接收<code>75%</code>的CPU而B接收剩余的<code>25%</code>。</p><p>彩票调度每隔一段时间持有彩票来概率地实现这一点。持有彩票很简单：调度程序必须知道有多少总票数。调度程序从这里面选择一张中奖票。</p><p><br></p><blockquote><p>使用票代表份额<br>彩票调度设计中最强大的机制之一就是票。在这些示例中，票用于表示进程的CPU份额，但可更广泛地应用。例如，在最近关于虚拟机程序的虚拟内存管理的作业中，展示如何使用票来表示操作系统的内存份额。因此，如果你需要一种机制来代表一定比例的所有权，这个概念可能就是票。</p></blockquote><p><br><br><br></p><h3 id="票机制"><a href="#票机制" class="headerlink" title="票机制"></a>票机制</h3><p>Ticket Mechanisms</p><p>彩票调度还提供了许多以不同且有时有用的方式操作票的机制。一种方式就是<strong>票货币(ticket currency)</strong>的概念。货币允许拥有一组票的用户在他们自己的工作中以他们想要的任何货币分配票，然后系统自动将所述货币转换为正确的全球价值。</p><p>例如，用户A和B每人都获得100张票。A正在运行两个作业A1和A2，并以A的货币向他们提供各500张票(共1000张)。用户B只运行一个作业并给它10张票(共10张)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User A -&gt; 500 (A’s currency) to A1 -&gt; 50 (global currency)</span><br><span class="line">-&gt; 500 (A’s currency) to A2 -&gt; 50 (global currency)</span><br><span class="line">User B -&gt; 10 (B’s currency) to B1 -&gt; 100 (global currency)</span><br></pre></td></tr></table></figure><p>其它拥有的机制是<strong>票务转移(ticket transfer)</strong>。通过转移，一个进程可暂时将其票交给另一个进程。</p><p><br><br><br><br><br></p><h2 id="多CPU调度"><a href="#多CPU调度" class="headerlink" title="多CPU调度"></a>多CPU调度</h2><p>Multi-CPU Scheduling</p><p>本章将会介绍<strong>多处理器调度(multiprocessor scheduling)</strong>的基础知识。由于此主题相对较高级，因此在你详细研究并发主题后，最好先介绍它。 多核处理器(multicore processor)（多个CPU核心被打包到单个芯片上）。</p><p>当然，随着多个CPU的到来，会出现很多困难。主要的一个典型是应用程序只使用一个CPU，添加更多CPU并不能使单个应用程序运行得更快。要解决此问题，你必须重新编写应用程序以<strong>并行(parallel)</strong>运行或使用<strong>线程(threads)</strong>。多线程应用程序可以在多个CPU之间传播工作，因此在获得更多CPU资源时运行速度更快。</p><p>除了应用程序之外，操作系统出现的新问题是<strong>多处理器调度(multiprocessor scheduling)</strong>的问题。到目前为止，我们已经讨论了单处理器背后的一些原则。如何将这些想法扩展到多CPU上？我们必须克服哪些问题？</p><p><br><br><br></p><h3 id="多处理器架构"><a href="#多处理器架构" class="headerlink" title="多处理器架构"></a>多处理器架构</h3><p>Multiprocessor Architecture</p><p>我们需要了解单CPU硬件和多CPU硬件之间的区别。这种差异主要围绕硬件缓存的使用，以及如何跨越多个处理器共享数据。这就涉及到了复杂的计算机架构问题。</p><p>在单CPU的系统中，存在<strong>硬件高速缓存(hardware<br>caches )</strong>的层次结构，其通常帮助处理器更快地运行程序。高速缓存是小而快速的存储器，通常保存在系统主存储器中找到的数据的副本。相反，主存储器保存所有数据，但访问较大的存储器的速度较慢。通常将频繁访问的数据保存在高速缓存中，系统可以使大而慢的存储器看起来很快。</p><p>例如，考虑一个发出显式加载指令以从内存中获取值的程序，以及一个单CPU的简单系统。CPU有一个小缓存（64KB）和一个大的主内存。程序第一次发出负载时，数据驻留在主存储器中，因此需要很长时间才能获取。与其数据可以被重用的处理器将加载的数据的副本放入CPU的高速缓存中。如果程序稍后再次获取该相同的数据项，则CPU首先在高速缓存中检查它。如果在那里找到它，数据的获取速度要快的多，因此程序会运行得更快。</p><p>因此，高速缓存基于局部性的概念：<strong>时间局部性(temporal locality)</strong>和<strong>空间局部性(spatial locality)</strong>。时间局部性背后的想法是，当访问一条数据时，很可能在不就的将来再次访问它，想象变量设置指令本身在循环中反复访问。空间局部性的想法是，如果程序访问地址x处的数据项，则它也可以访问x附件的数据项。想想通过数组流式传输的程序，或者一个接一个地执行指令。由于这些类型的位置存在于许多程序中，因此硬件系统可以很好地擦侧哪些数据要放入缓存中，从而可以很好地工作。</p><p><img src="/images/OSTEP/multi-10-1.png" alt></p><p><img src="/images/OSTEP/multi-10-2.png" alt></p><p><br></p><p>事实证明，使用多个CPU进行缓存要复杂得多。想象一下，在CPU 1上运行的程序读取地址A的数据项（值D）；因为数据不在CPU 1的缓存中，系统从主存储器中取出数据，并获得值D。程序然后修改地址A的值，用新值D更新其缓存，将数据一直写入主存的速度很慢，因此系统稍后执行此操作。然后假设操作系统决定停止运行程序并将其移至CPU 2。然后程序重新读取地址A的值，CPU 2的缓存没有这样的数据，因此系统从主存中取值，并获得旧的值D而不是正确的值D。 这个一般性问题被称为<strong>缓存一致性(cache coherence)</strong>。</p><p>基本解决方案有硬件提供：通过监视内存访问，硬件可以确保基本上发生正确的事情并保留单个共享内存的视图。在基于总线的系统上执行此操作的每一种方法是使用称为<strong>总线侦听(bus snooping)</strong>，每个缓存通过观察它们连接到主存储器的总线来关注内存更新。当CPU然后看到它在缓存中保存的数据项的更新时，它将注意到该更改并使其副本无效，或更新它。如上所述，会写缓存会使这更加复杂，但你可以想象基本方案可能如何工作。</p><p><br><br><br></p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>Don’t Forget Synchronization</p><p>鉴于缓存完成所有这些工作以提供一致性，程序在访问共享数据时是否必须担心什么？<br>当跨CPU访问共享数据项或结构时，应该使用互斥来保证正确性。例如，假设我们在多个CPU上访问共享队列。没有锁，即使使用底层的一致性协议，同时在队列中添加或删除元素也不会按预期工作；一个需要锁定以原子方式将数据结构更新为新状态。</p><p>为了使其更具体，想象一下这个代码序列，它用于从共享链表中删除一个元素。如下图所示，如果两个CPU上的线程同时进入此例程。</p><p>Simple List Delete Code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">Node_t</span> &#123;</span></span><br><span class="line"> <span class="keyword">int</span> value;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> __<span class="title">Node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node_t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Node_t *tmp = head; <span class="comment">// remember old head ...</span></span><br><span class="line"> <span class="keyword">int</span> value = head-&gt;value; <span class="comment">// ... and its value</span></span><br><span class="line"> head = head-&gt;next; <span class="comment">// advance head to next pointer</span></span><br><span class="line"> <span class="built_in">free</span>(tmp); <span class="comment">// free old head</span></span><br><span class="line"> <span class="keyword">return</span> value; <span class="comment">// return value at head</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="缓存关联"><a href="#缓存关联" class="headerlink" title="缓存关联"></a>缓存关联</h3><p>Cache Affinity</p><p>最后一个问题出现在构建多处理器缓存调度程序，称为<strong>缓存关联(cache affinity)</strong>。这个概念很简单：一个进程，当在特定的CPU上运行时，在CPU的高速缓存中建立一个相当大的状态。下一次进程运行时，在同一个CPU上运行它通常是有利的，因为如果它的某些状态已经存在于该CPU的高速缓存中，它将运行得更快。相反，如果每次在不同的CPU上运行进程，则进程的性能会更差，因为每次运行都必须重新加载状态。因此，多处理器调度程序在进行调度决策时应该考虑缓存关联，如果可能的话，可能更愿意将进程保留在同一CPU上。</p><p><br><br><br></p><h3 id="单队列调度"><a href="#单队列调度" class="headerlink" title="单队列调度"></a>单队列调度</h3><p>Single-Queue Scheduling</p><p>现在讨论为多处理器系统构建调度程序。最简单的方法是通过将需要调度的所有作业放入单个队列中，从而简单地将基本框架重用与单处理器调度。简称为<strong>单队列多处理器调度(singel queue multi processor scheduling)SQMS</strong>。这种方法的优点就是简单；采取现有策略选择下一个要运行的最优作业并使其适应与一个以上CPU的工作并不需要太多工作（例如，如果有两个CPU，它可以选择两个最优作业来运行。）</p><p>然而，SQMS有明显的缺点。</p><p>第一个问题是缺乏可伸缩性(scalability)。为了确保调度程序可以在多个CPU上正常工作，开发人员将在代码中插入某种形式的锁(locking)，如前所述。锁确保当SQMS代码访问单队列时（如，找到要运行的下一个作业），产生正确的结果。</p><p>不幸的是，锁会极大地降低性能，尤其是随着系统中CPU数量的增长。随着对单个锁的争夺增加，系统在锁开销(overhead)上花费的时间越来越多，而系统本应该执行的工作所花费的时间却越来越少。</p><p>第二个主要问题是缓存关联(cache affinity)。例如，假设我们有五个作业要运行(A, B, C, D, E)和四个处理器。调度队列如下所示：</p><p><img src="/images/OSTEP/sqms-1.png" alt></p><p>因为每个CPU只是从全局共享队列中选择要运行的下一个作业，所以每个作业最终都会在各个CPU之间跳动，因此，与从缓存关联的角度来看完全相反。为了解决此问题，大多数SQMS调度程序都包含某种关联机制，以尽可能使进程仅能在在同一CPU上继续运行。具体来说，一个CPU可能为某些作业提供了亲和力，单四处移动以负载均衡。如，假设按照以下方式调度相同的五个作业：</p><p><img src="/images/OSTEP/sqms-2.png" alt></p><p>在这种安排中，作业A到D不会在处理器之间移动，只有作业E从一个CPU迁移到另一个CPU，伊尼茨保留了大多数的亲和力。然后，你可以决定下一次迁移另一个作业，从而也实现某种亲和力公平性。但是，实施这种方案可能很复杂。</p><p>因此，我们可以看到SQMS方法有其有点和缺点。在给定现有的单CPU调度程序的情况下，实现起来很简单，根据定义，该调度程序只有一个队列。但是，它的伸缩性不好（由于同步开销），并且不容易保留缓存关联。</p><p><br><br><br></p><h3 id="多队列调度"><a href="#多队列调度" class="headerlink" title="多队列调度"></a>多队列调度</h3><p>Multi-Queue Scheduling</p><p>由于单队列调度程序中的问题，某些系统选择多队列。我们称这种方法为<strong>多队列多处理器调度(multi queue multiprocessor scheduling)MQMS</strong>。</p><p>在MQMS中，我们的基本调度框架由多个调度队列组成。尽管当然可以使用任何算法，但每个队列都可能遵循特定的调度规则，例如RR。<br>当一个作业进入系统时，根据某种启发式方法（如，随机、选择一项作业比其他作业少的作业…），该作业将恰好放在一个调度队列中。它基本上是独立调度的，从而避免了在单队列方法中发现的信息共享和同步问题。</p><p>例如，假设我们有一个只有两个CPU（cpu0、cpu1）的系统，并有一些作业(A、B、C、D)进入系统。假设每个CPU现在都有一个调度队列，则操作系统必须决定将每个作业放入哪个队列。它可能会执行以下操作：</p><p><img src="/images/OSTEP/mqms-1.png" alt></p><p>现在，根据队列调度策略，每个CPU在确定应该运行什么时都可以选择两个作业。例如，使用RR，系统可能会生产一个如下所示的时间表：</p><p><img src="/images/OSTEP/mqms-2.png" alt></p><p>它具有更大的可伸缩性。随着CPU数量的增加，队列数量也随之增加，因此锁和缓存争用不应该成为中心问题。此外，MQMS本质上提供了缓存亲和力，作业保持在同一CPU上，从而获得了在其中重用缓存内容的优势。</p><p>但是，如果你注意到，可能会发现一个心问题，这是基于多队列方法的根本问题：负载不均衡(load imbalance)。假设作业C完成了，现在，我们有以下调度队列：</p><p><img src="/images/OSTEP/mqms-3.png" alt></p><p>那么多队列多处理器调度程序一你改改怎么做？才能克服负载不均衡的隐患…</p><p><br></p><blockquote><p>CRUX: HOW TO DEAL WITH LOAD IMBALANCE<br>How should a multi-queue multiprocessor scheduler handle load imbalance, so as to better achieve its desired scheduling goals?</p></blockquote><p>明显的答案是移动作业，我们再次将其称为迁移(migration)。通过将作业从一个CPU迁移到另一个CPU，可以实现真正的负载均衡。</p><p><img src="/images/OSTEP/mqms-4.png" alt></p><p><br></p><p>当然，存在许多其它可能的迁移模式。但现在棘手的是：系统应该如何决定实施这种迁移？</p><p>一种基本方法是使用一种成为<strong>work stealing</strong>的技术。使用工作窃取方法，工作量低的(source)队列有时会偷窥另一个(target)队列，以查看其填充(full)程度。如果目标队列比源队列更满，则源将从目标窃取一个或多个作业以帮助负载均衡。</p><p>当然，这种方法具有自然的张力。如果经常查看其它队列，那么将会遭受高昂的开销并难以扩展。另一方面，如果不经常查看其它队列，则有遭受负载不均衡的危险。在系统策略设计中很常见，找到正确的阈值是一件黑手艺。</p><p><br><br><br></p><h3 id="Linux多处理器调度程序"><a href="#Linux多处理器调度程序" class="headerlink" title="Linux多处理器调度程序"></a>Linux多处理器调度程序</h3><p>Linux Multiprocessor Schedulers</p><p>有趣的是，在Linux社区中，没有通用的解决方案来构建多处理器调度程序。随着时间的推移，出现了三种不同的调度程序：</p><ul><li>O(1) scheduler</li><li>the Completely Fair scheduler(CFS)</li><li>the BF scheduler</li></ul><p>O(1)和CFS都是用多队列，二BFS使用单队列，这表明两种方法都可以成功。例如，O(1)调度程序是基于优先级的（类似于前面讨论的MLFQ），随着时间的推移更改进程的优先级，然后调度优先级最高的进程，以满足各种给调度目标。交互性是另一个特别的重点。相比之下，CFS是确定性的比例共享(proportional-share)方法（更像前面讨论的Stride schedulig）。BFS是这三种方法中唯一的但队列方法，也是按比例共享，但它基于更复杂的方案，即Earliest Eligible Virtual Deadline First(EEVDF)。</p><p><br><br><br></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Summary</p><p>我们已经看到了多处理器调度的各种方法。单队列方法(SQMS)构建起来很简单，并且可以很好地负载均衡，但是固有地很难扩展到多处理器并具有缓存关联。多队列方法(MQMS)可以更好地处理缓存亲和关系，但是在负载不均衡方面存在麻烦，并且更加复杂。无论采用哪种方法，都没有简单的答案：构建通用调度程序仍然是一项艰巨的任务，因为小的代码的更改可能会导致巨大的行为差异。仅当您确切地知道自己在做什么或者至少为此而获得了很多钱时，才进行这样的练习。</p><p><br><br><br><br><br></p><h2 id="CPU虚拟化总结"><a href="#CPU虚拟化总结" class="headerlink" title="CPU虚拟化总结"></a>CPU虚拟化总结</h2><p>Summary Dialogue on CPU Virtualization: <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-dialogue.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-dialogue.pdf</a></p><p><br><br><br><br><br></p><h2 id="内存虚拟化对话"><a href="#内存虚拟化对话" class="headerlink" title="内存虚拟化对话"></a>内存虚拟化对话</h2><p>A dialogue on Memory Virtualization: <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-vm.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-vm.pdf</a></p><p><br><br><br><br><br></p><h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><p>Address Spaces: <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-intro.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/vm-intro.pdf</a></p><p>在早期，构建计算机系统很容易。因为那时用户期望不高。正是那些对易用性(ease of use)，高性能(high performance)，可靠性(reliability)…这些寄予厚望的用户确实导致了所有这些麻烦。</p><p><br><br><br></p><h3 id="早期系统"><a href="#早期系统" class="headerlink" title="早期系统"></a>早期系统</h3><p>Early System</p><p>从内存的角度来看，早期的机器并没有为用户提供太多抽象(abstraction)。基本上，计算机的物理内存类似于下图:</p><p><img src="/images/OSTEP/13-1.png" alt></p><p>操作系统是一组位语内存中的例程(routines)(实际上是一个库)（图中从物理地址0开始），并且将有一个正在运行的程序(process)当前位于内存中(从物理地址开始，图中为64k)，并使用了其余的内存。</p><p><br><br><br></p><h3 id="多编程和时间共享"><a href="#多编程和时间共享" class="headerlink" title="多编程和时间共享"></a>多编程和时间共享</h3><p>Multiprogramming and Time Sharing</p><p>一段时间之后，由于机器价格昂贵，人们开始更有效地共享机器。因此，多重编程诞生了，在该时代，多进程准备在给定的时间运行，并且操作系统将在它们之间切换。例如，当一个人决定执行一个I/O时。这样做可以提高CPU的有效利用率(effective utilization)。在每台机器高达数十万百万的那些日子里，这种效率的提高尤其重要。</p><p>很快，人们开始需求更多的机器，时间共享(time share)诞生了。具体来说，许多人意识到批处理(batch computing)的局限性，特别是对程序员本身，因为他们厌倦了漫长的程序调试周期。交互性(interacttivity)的概念变得很重要，因为许多用户可能正在同时使用一台计算机，每个用户都在等待（或希望）他们当前正在执行的任务的及时响应。</p><p>实现时间共享的一种方法是短暂运行一个进程，使其完全访问所有的内存，然后停止它。将其所有状态保存到某种磁盘中（包括所有物理内存）。加载其它进程的状态，运行一段时间，从而实现对机器的某种粗略共享。</p><p>不幸的是，这种方法有一个大问题：它太慢了，特别是随着内存的增长。虽然保存和恢复寄存器级别状态(PC, general-purpose registers…)相对较快，但将整个内存内容保存到磁盘上却无法执行。因此，我们宁愿将进程留在内存中，同时在它们之间进行切换，从而使操作系统能够有效地实现时间共享。如下图所示:</p><p><img src="/images/OSTEP/13-2.png" alt></p><p>该图有三个进程(A, B, C)，每个进程都为它们分配了512KB物理内存的一部分。假设一个单CPU，操作系统选择其中一个进程(如A)，而其它进程(B, C)在准备队列中等待运行。</p><p>随着时间共享变得越来越流行，您可能会猜到对操作系统提出了新的要求。尤其是，允许多个程序同时驻留(reside)在内存中使保护成为一个重要问题。您不希望某个进程能够读取(read)，更糟的是，写入其它进程的内存。</p><p><br><br><br></p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>The Address Space</p><p>但是，我们必须牢记那些讨厌的用户，并且这样做需要操作系统创建易于使用(easy to use)的物理内存抽象(abstraction)。我们称这种抽象为<strong>地址空间</strong>(address space)，它是运行在系统中的程序的内存视图。了解内存的这种基本操作系统抽象是了解如何虚拟化内存的关键。</p><p>进程的地址空间包含正在运行的程序的所有内存状态。例如，程序代码(指令)必须驻留在内存中的某个位置，因此它们位于地址空间中。该程序在运行时会使用<strong>栈</strong>(stack)来追踪(track)它在函数调用链中的位置，并分配局部变量，并在例程之间传递参数以及返回值。最后，<strong>堆</strong>(heap)用于动态分配(dynamically allocated)、用户管理的内存。例如，您可能会从C中的<code>malloc()</code>调用或以面向对象语言(C++, Java)通过<code>new</code>调用中接收到。当然，其中也有其他内容（如，statically-initialized variables)，但是现在让我们假设这三个组件:</p><ul><li>code</li><li>stack</li><li>heap</li></ul><p>在下图中，有一个小地址空间(16KB)。程序代码位于地址空间的顶部（此例中，从0开始，并打包到地址空间的前1K）。代码是静态的，因此很容易放置在内存中，因此我们可以将其放在地址空间的顶部，并知道在程序运行时不需要任何空间。</p><p><img src="/images/OSTEP/13-3.png" alt></p><p>接下来，我们在程序运行时拥有地址空间的两个区域，它们可能增长(grow)或收缩(shrink)。这些是堆(heap)(在顶部)和栈(stack)(在底部)。之所以这样放置它们，是因为每个人都希望能够增长，并且通过将它们放在地址空间的相对两端(opposite ends)，我们可以允许这种增长：它们只需要朝相反的方向增长。这样，堆就在代码之后(1KB)开始向下增长（如，用户通过<code>malloc()</code>请求更多内存时），栈从底部(16KB)开始并向上增长（如，用户进行过程调用时）。但是，栈和堆的这种放置只是一个约定(convention)。您可以根据需要以不同的方式安排地址空间（将在后面看到，当多线程(multi threads)共存(co-exist)于一个地址空间时，再也没有一种很好的方法来划分地址空间了）。</p><p>当然，当我们描述地址空间时，我们所描述的操作系统为正在运行的程序提供的抽象(abstraction)。该程序实际上不在物理地址0到16KB的内存中，而是将其加载到某个任意物理地址。查看图13-2中的进程A, B, C，您可以看到每个进程如何以不同的地址加载到内存中。因此，问题来了。</p><blockquote><p>THE CRUX: HOW TO VIRTUALIZE MEMORY<br>How can the OS build this abstraction of a private, potentially large address space for multiple running processes (all sharing memory) on top of a single, physical memory?</p></blockquote><p>当操作系统执行此操作时，我们说操作系统正在虚拟化内存(virtualizing memory)，因为正在运行的程序认为它已加载到特定地址的内存中，并且具有很大的地址空间（如32-bits或64-bits）。现实是完全不同的。</p><p>例如，当13-2图中的进程A尝试在地址0（我们称其为虚拟地址）上执行加载时，以某种方式，操作系统与某些硬件支持相结合。将必须确保加载实际上并没有转到物理地址0，而是物理地址320KB（将A加载到内存中的地址）。这是内存虚拟化的关键，而内存虚拟化是世界上每个现代计算机系统的基础。</p><p><br><br><br></p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>Goals</p><p>因此，我们在注释中完成了操作系统的工作：虚拟化内存。但是，操作系统不仅会虚拟化内存，还会以某种风格来做。为了确保操作系统能够做到这一点，我们需要一些目标来指导我们。我们之前已经看过这些目标，我们将再次看到它们，但肯定是值得重复的。</p><p>虚拟化内存(VM)系统的一个主要目标是<strong>透明度</strong>(transparency)。操作系统应以对运行的程序不可见的方式实现虚拟内存。因此，程序不应意识到内存已虚拟化。而是，程序行为就像具有自己的专用物理内存一样。在后台，操作系统（和硬件）完成了所有工作，以在许多不同的作业之间多路复用内存，从而实现了这种错觉。</p><p>虚拟化内存的另一个目标是<strong>效率</strong>(efficiency)。操作系统应努力在时间(不使程序运行速度更慢)和空间(不为支持虚拟化所需的结构使用过多内存)方面使虚拟化尽可能高效。在实现高效的虚拟化时，操作系统将不得不依赖硬件支持，包括诸如TLB的硬件功能。</p><p>最后，虚拟化内存的第三个目标是<strong>保护</strong>(protection)。操作系统应确保保护进程彼此之间以及操作系统本身不受进程影响。当一个进程执行加载、存储、指令获取时，它不应以任何方式访问或影响任何其它进程或操作系统本身（即，其地址空间之外的任何内容）的内存内容。因此，保护使我们能够在流程之间提供隔离(isolation)的特性。每个进程都以你敢再自己的隔离茧中运行，以免遭受其它故障甚至恶意进程的破坏。</p><p>在下一章中，我们将重点研究虚拟化内存所需的基本机制，包括硬件和操作系统支持。我们还将研究您在操作系统中会遇到的一些更相关的策略，包括如何管理可用空间(free space)以及当空间不足时要从内存中踢出(kick out of)哪些页面。这样，我们将加深您对现代虚拟内存系统实际工作方式的了解。</p><blockquote><p>TIP: THE PRINCIPLE OF ISOLATION<br>Isolation is a key principle in building reliable systems. If two entities are properly isolated from one another, this implies that one can fail without affecting the other. Operating systems strive to isolate processes from each other and in this way prevent one from harming the other. By using memory isolation, the OS further ensures that running programs cannot affect the operation of the underlying OS. Some modern OS’s take isolation even further, by walling off pieces of the OS from other pieces of the OS. Such microkernels thus may provide greater reliability than typical monolithic kernel designs.</p></blockquote><p><br><br><br><br><br></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Summary</p><p>我们已经看到了一个主要的操作系统子系统的引入：虚拟化内存。虚拟化内存系统分则为程序提供庞大、稀疏的专用地址空间的错觉，这些程序将所有指令和数据保存在其中。操作系统将在一些严重的硬件帮助下获取这些虚拟化内存引用中的每一个，并将其转换为物理地址，可以将其提供给物理内存，以获取所需的信息。操作系统将一次对多个进程执行此操作，请确保相互保护程序并保护操作系统。整个方法需要大量的机制以及一些关键的策略才能起作用。我们将从头开始，首先描述关键机制。因此，继续。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">ASIDE: EVERY ADDRESS YOU SEE IS VIRTUAL</span><br><span class="line"></span><br><span class="line">Ever write a C program that prints out a pointer? The value you see</span><br><span class="line">(some large number, often printed in hexadecimal), is a virtual address.</span><br><span class="line">Ever wonder where the code of your program is found? You can print</span><br><span class="line">that out too, and yes, if you can print it, it also is a virtual address. In</span><br><span class="line">fact, any address you can see as a programmer of a user-level program</span><br><span class="line">is a virtual address. It’s only the OS, through its tricky techniques of</span><br><span class="line">virtualizing memory, that knows where in the physical memory of the</span><br><span class="line">machine these instructions and data values lie. So never forget: if you</span><br><span class="line">print out an address in a program, it’s a virtual one, an illusion of how</span><br><span class="line">things are laid out in memory; only the OS (and the hardware) knows the</span><br><span class="line">real truth.</span><br><span class="line"></span><br><span class="line">Here’s a little program (va.c) that prints out the locations of the main()</span><br><span class="line">routine (where code lives), the value of a heap-allocated value returned</span><br><span class="line">from malloc(), and the location of an integer on the stack:</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">  printf(&quot;location of code : %p\n&quot;, main);</span><br><span class="line">  printf(&quot;location of heap : %p\n&quot;, malloc(100e6));</span><br><span class="line">  int x = 3;</span><br><span class="line">  printf(&quot;location of stack: %p\n&quot;, &amp;x);</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">When run on a 64-bit Mac, we get the following output:</span><br><span class="line"></span><br><span class="line">location of code : 0x1095afe50</span><br><span class="line">location of heap : 0x1096008c0</span><br><span class="line">location of stack: 0x7fff691aea64</span><br><span class="line"></span><br><span class="line">From this, you can see that code comes first in the address space, then</span><br><span class="line">the heap, and the stack is all the way at the other end of this large virtual</span><br><span class="line">space. All of these addresses are virtual, and will be translated by the OS</span><br><span class="line">and hardware in order to fetch values from their true physical locations.</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="内存API"><a href="#内存API" class="headerlink" title="内存API"></a>内存API</h2><p>Memory API: <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-api.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/vm-api.pdf</a></p><p>在这个插曲中，我们讨论Unix系统中内存分配接口。所提供的接口非常简单，因此本章简短而切合实际。主要问题如下:</p><blockquote><p>CRUX: HOW TO ALLOCATE AND MANAGE MEMORY<br>In UNIX/C programs, understanding how to allocate and manage memory is critical in building robust and reliable software. What interfaces are commonly used? What mistakes should be avoided?</p></blockquote><p><br><br><br></p><h3 id="内存类型"><a href="#内存类型" class="headerlink" title="内存类型"></a>内存类型</h3><p>Types of Memory</p><p>在运行C程序时，分配了两种类型的内存。第一种称为<strong>stack memory</strong>，由编译器为您隐式管理其分配(allocation)和释放(deallocation)。因此，有时称为<strong>automatic memory</strong>。</p><p>在C中的stack上声明内存很容易。例如，假设您在<code>func()</code>函数中需要一些空间来存放一个名为<code>x</code>的整数。要声明这样的一片内存，只需执行以下操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x; <span class="comment">//  declares an integer on the stack</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余部分由编译器完成，请确保在调用<code>func()</code>时在stack上留出空间。当您从函数返回时，编译器会为你释放内存。因此，如果你希望某些信息活到调用之后，你最好不要将该信息保留在stack中。</p><p>正是这种对long-lived memory的需求将我们带到了第二种类型的内存，称为<strong>heap memory</strong>，其中所有分配和释放都由您明确处理。毫无疑问，这是一个沉重的责任！无疑是许多bug的原因。但是，如果您小心翼翼并注意，您将可以正确使用此类接口，而不会遇到太多麻烦。如下是一个如何在堆(heap)上分配整数的示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *x = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于此小代码段的一些注意事项。首先，您可能会注意到stack和heap分配都发生在这一行：首先，编译器在看到您的指针声明(<code>int *x</code>)时就知道为整数指针腾出空间。随后，当程序调用<code>malloc()</code>时，它将在heap上为整数请求空间。例程返回这样一个整数的地址（成功时返回，失败时返回NULL），然后将其存储在stack中以供程序使用。</p><p>由于其显式的性质以及更广泛的用途，<strong>heap memory</strong>对内存和系统都提出了更多挑战。因此，这是我们其余讨论的重点。</p><p><br><br><br></p><h3 id="malloc调用"><a href="#malloc调用" class="headerlink" title="malloc调用"></a>malloc调用</h3><p>The malloc() Call</p><p><code>malloc()</code>调用十分简单：向其传递一个大小，以要求在heap上留出一定的空间。它要么成功并返回给您指向新分配的空间的指针，要么失败并返回NULL。在命令行中输入<code>man malloc</code>以获取帮助。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>从此信息中，您可以看到你需要做的就是包含头文件<code>stdlib.h</code>来使用<code>malloc</code>。实际上，您根本不需要这样做。因为默认情况下，所有C程序都链接到C library，之中包含了<code>malloc()</code>的代码。添加header只是让编译器检查你是否正确调用了<code>malloc()</code>（例如，向其传递了正确数量或类型的参数）。</p><p><code>malloc()</code>的单个参数的大小为t，它简单地描述了您需要缩少字节。但是，大多数编程人员不会在此处直接输入数字。（实际上，这样做会被认为是糟糕的形式。）而是使用各种例程(routines)和宏(macros)。例如，要为双精度浮点值分配空间，只需执行以下操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> *b = (<span class="keyword">double</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br></pre></td></tr></table></figure><p>这种对<code>malloc()</code>的调用使用<code>sizeof()</code>运算符来请求正确的空间量。在C语言中，通常将其视为编译时(compile-time)运算符，这意味着实际大小在编译时已知，因此将一个数字替换为<code>malloc()</code>的参数。因此，将<code>sizeof()</code>正确地视为运算符，而不是函数调用（函数调用将在运行时发生）。</p><p>您还可以将变量名（而不只是类型）传递给<code>sizeof()</code>，但是在某些情况下，您可能无法获得所需的结果，因此请小心。例如，让我们看下面的代码片段:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *x = <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(x));</span><br></pre></td></tr></table></figure><p>在第一行中，我们声明了一个由10个整数组成的数组的空间，即好又花哨。但是，当我们在下一行中使用<code>sizeof()</code>时，它将返回一个较小的值，如4(32-bit机器)或8(64-bit机器)。原因是在这种情况下，<code>sizeof()</code>认为我们只是在问整数的指针有多大，而不是动态分配了多少内存。然而，有时<code>sizeof()</code>确实可以按你于其的那样工作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(x));</span><br></pre></td></tr></table></figure><p>在这种情况下，有足够的静态信息供编译器知道已经分配了40Bytes。</p><p>另一个要注意的地方是字符串(string)。在声明字符串的空间时，请使用以下管用法：<code>malloc(strlen(s) + 1)</code>，该字符串使用<code>strlen()</code>函数旱区字符串的长度，并向其加1为末尾字符串字符留出空间。在这里使用<code>sizeof()</code>可能会导致麻烦。</p><p>你可能还会注意到，<code>malloc()</code>返回了一个指向void类型的指针。这样做只是C语言中传回地址并让编程人员决定如何处理该地址的方法。编程人员通过使用强制转换来进一步提供帮助。</p><p><br></p><blockquote><p>TIP: WHEN IN DOUBT, TRY IT OUT<br>If you aren’t sure how some routine or operator you are using behaves, there is no substitute for simply trying it out and making sure it behaves as you expect. While reading the manual pages or other documentation is useful, how it works in practice is what matters. Write some code and test it! That is no doubt the best way to make sure your code behaves as you desire. Indeed, that is what we did to double-check the things we were saying about sizeof() were actually true!</p></blockquote><p><br><br><br></p><h3 id="free调用"><a href="#free调用" class="headerlink" title="free调用"></a>free调用</h3><p>The free() Call</p><p>事实证明，分配内存时方程式最简单的部分。知道何时、如何释放内存是最困难的部分。要释放不再使用的heap memory，编程人员只需调用<code>free()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *x = <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">...</span><br><span class="line"><span class="built_in">free</span>(x);</span><br></pre></td></tr></table></figure><p>该例程采用一个参数，即<code>malloc()</code>返回的指针。因此，您可能会注意到，分配的区域的大小不是由用户传递的，必须由内存分配本身进行跟踪。</p><p><br><br><br></p><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>Common Errors</p><p>使用<code>malloc()</code>和<code>free()</code>时会出现许多常见错误。这是我们在本科操作系统中反复看到的一些内容。所有这些示例都可以编译，并且无需编译器即可窥视。</p><p>正确的内存管理一直是一个问题，事实上，许多更新的语言都支持自动内存管理(automatic memory management)。在这样的语言中，当您调用类似于<code>malloc()</code>的东西来分配内存时，您不必调用任何东西来释放空间。相反，垃圾收集器(grabage collector)将运行并找出您不在引用的内存，并为您释放它。</p><p><br></p><blockquote><p>TIP: IT COMPILED OR IT RAN 6= IT IS CORRECT<br>Just because a program compiled(!) or even ran once or many times correctly does not mean the program is correct. Many events may have conspired to get you to a point where you believe it works, but then something changes and it stops. A common student reaction is to say (or yell) “But it worked before!” and then blame the compiler, operating system, hardware, or even (dare we say it) the professor. But the problem is usually right where you think it would be, in your code. Get to work and debug it before you blame those other components.</p></blockquote><p><br></p><p><strong>忘记分配内存</strong><br>Forgetting To Allocate Memory</p><p>许多例程(rutines)希望在调用它们之前先分配内存。例如，例程<code>strcpy(dst, src)</code>将字符串从源指针复制到目标指针。但是，如果您不小心，可能会这样做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *src = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *dst; <span class="comment">// oops! unallocated</span></span><br><span class="line"><span class="built_in">strcpy</span>(dst, src); <span class="comment">// segfault and die</span></span><br></pre></td></tr></table></figure><p>当您运行此代码时，可能导致分段错误，这是您对内存有错误的幻想，因为您对程序感到迷惑，并且很生气。<br>在这种情况下，正确的代码可能看起来像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *src = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *dst = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src) + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(dst, src); <span class="comment">// work properly</span></span><br></pre></td></tr></table></figure><p>或者您可以使用<code>strdup()</code>使您的生活更加轻松。</p><p><br></p><p><strong>没有分配足够的内存</strong><br>Not Allocating Enough Memory</p><p>一个相关的错误是没有分配足够的内存(allocate enough memory)，有时称为<strong>缓存区溢出</strong>(buffer overflow)。在上面的示例中，常见的错误是为目标缓存区腾出几乎足够的空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *src = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *dst = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src)); <span class="comment">// too small!</span></span><br><span class="line"><span class="built_in">strcpy</span>(dst, src); <span class="comment">// work properly</span></span><br></pre></td></tr></table></figure><p>奇怪的是，取决于malloc的实现方式和许多其它细节，该程序通常看似正确运行。在某些情况下，执行字符串复制时，它会在已分配空间的末尾写入一个字节，但这在某些情况下是无害的，可能会覆盖一个不再使用的变量。在某些情况下，这些溢出可能非常有害，并且实际上是许多安全漏洞(security vulnerabilities)的根源。在其它情况下，无论如何，malloc库都会分配一些额外的空间，因此，您的程序实际上不会在其它变量的值上乱写，并且可以正常工作。在其它情况下，该程序的确会出错并崩溃。因此，我们吸取了另一个宝贵的教训：即使正确运行了一次，也并不意味着它是正确的。</p><p><br></p><p><strong>忘记初始化分配的内存</strong><br>Forgetting to Initialize Allocated Memory</p><p>遇到此错误，您可以正确地调用<code>malloc()</code>，但是忘记将某些值填写到新分配的数据类型中。不要这样做！如果您忘记了，您的程序最终将遇到未初始化的读取(uninitialized read)，即从heap中读取一些未知值的数据。谁知道里面会有什么？如果幸运的话，您可以通过一些值使程序仍然可以运行（如0）。如果不走运，那是随机和有害的事情。</p><p><br></p><p><strong>忘记释放内存</strong><br>Forgetting To Free Memory</p><p>另一个常见的错误称为<strong>内存泄漏</strong>(memory leak)，当您忘记释放内存时就会发生。在长时间运行的应用程序或系统中，这是一个巨大的问题，因为缓慢泄露内存最终会导致内存用完(OOM)，此时需要重新启动。因此，通常，当您完成了一块内存后，应该确保释放它。请注意，使用垃圾回收的语言在这里无济于事。如果您仍然引用某些内存块，则没有垃圾回收器会释放它，因此即使在更现代的语言中，内存泄漏仍然时一个问题。</p><p>在某些情况下，似乎不用调用<code>free()</code>是合理的。例如，您的程序寿命很短，将很快推出。在这种情况下，当进程终止时，操作系统将清除其所有分配的页面，因此本身不会发生内存泄漏。尽管这肯定是有效的，但养成这种习惯可能是个坏习惯，因此请谨慎选择这种策略。从长远来看，作为程序员的目标之一是养成良好的习惯。这些习惯一是了解如何管理内存，以及释放已分配的内存块。即使您可以避免这样做，也应该养成释放显式分配的每个字节的习惯。</p><p><br></p><p><strong>完成之前释放内存</strong><br>Freeing Memory Before You Are Done With It</p><p>有时，程序会在使用完成内存之前释放内存。这样的错误称为<strong>悬空指针</strong>(dangling pointer)，如您所猜测的那样，这也是一件坏事。后续使用可能会导致程序崩溃，或覆盖有效内存。</p><p><br></p><p><strong>反复释放内存</strong><br>Freeing Memory Repeatedly</p><p>程序有时还不止一次释放内存，这就是所谓的<strong>double free</strong>。这样做的结果是不确定的。可以想象，内容分配库可能会感到困惑，并且会做各种奇怪的事情，崩溃是常见的结果。</p><p><br></p><blockquote><p>ASIDE: WHY NO MEMORY IS LEAKED ONCE YOUR PROCESS EXITS<br>When you write a short-lived program, you might allocate some space using <code>malloc()</code>. The program runs and is about to complete: is there need to call <code>free()</code> a bunch of times just before exiting? While it seems wrong not to, no memory will be “lost” in any real sense. The reason is simple: there are really two levels of memory management in the system.<br>The first level of memory management is performed by the OS, which hands out memory to processes when they run, and takes it back when processes exit (or otherwise die). The second level of management is within each process, for example within the heap when you call <code>malloc()</code> and <code>free()</code>. Even if you fail to call <code>free()</code> (and thus leak memory in the heap), the operating system will reclaim all the memory of the process (including those pages for code, stack, and, as relevant here, heap) when the program is finished running. No matter what the state of your heap in your address space, the OS takes back all of those pages when the process dies, thus ensuring that no memory is lost despite the fact that you didn’t free it.<br>Thus, for short-lived programs, leaking memory often does not cause any operational problems (though it may be considered poor form). When you write a long-running server (such as a web server or database management system, which never exit), leaked memory is a much bigger issue, and will eventually lead to a crash when the application runs out of memory. And of course, leaking memory is an even larger issue inside one particular program: the operating system itself. Showing us once again: those who write the kernel code have the toughest job of all…</p></blockquote><p><br></p><p><strong>错误地调用free</strong><br>Calling free() Incorrectly</p><p>我们讨论的最后一个问题是对<code>free()</code>的错误调用。<code>free()</code>希望您仅将您从<code>mallo()</code>收到的指针之一传递给它。当您传递其它一些值时，可能会发生糟糕的事。因此，这种无效的释放是危险的，当然也应该避免。</p><p><br></p><p><strong>总结</strong><br>Summary</p><p>如您所见，有很多滥用内存的方式。用于经常发生内存错误，因此开发了整个工具生态圈来帮助您在代码中查找此类问题。检出purify和valgrind，两者都很擅长帮助您找到与内存相关的问题的根源。一旦您习惯了使用这些强大的工具，您会想知道如果没有这些工具，您将如何生存。</p><p><br><br><br></p><h3 id="底层操作系统支持"><a href="#底层操作系统支持" class="headerlink" title="底层操作系统支持"></a>底层操作系统支持</h3><p>Underlying OS Support</p><p>您可能已经注意到，在讨论<code>malloc()</code>和<code>free()</code>时，我们并未谈论系统调用。原因很简单，它们不是系统调用，而是库调用。因此，malloc库管理您的虚拟地址空间内的空间，但它本身是建立在某些系统调用之上，这些系统调用会向操作系统发出请求以请求更多内存或将一些内存释放回系统。</p><p>一个这样的系统调用称为<code>brk</code>，用于更改程序的中断(break)的位置：heap末尾的位置。它采用一个参数(新中断的地址)，因此根据新中断是大于还是小于当前中断来增加或减少heap的大小。一个附加的<code>sbrk</code>调用传递一个增量，起类似的作用。</p><p>请注意，永远不要直接调用<code>brk</code>或<code>sbrk</code>。它们由内存分配库使用。如果尝试使用它们，则可能会导致某些错误（非常严重）。坚持使用<code>malloc()</code>和<code>free()</code>。</p><p>最后，您还可以通过<code>mmap</code>调用从操作系统获取内存。通过传入正确的参数，<code>mmap()</code>可以在程序内创建一个匿名(anonymous)内存区域，该区域与任何特定文件都没有关联，而是与交换空间(swap space)关联，将在稍后详细讨论。</p><p><br><br><br></p><h3 id="其它调用"><a href="#其它调用" class="headerlink" title="其它调用"></a>其它调用</h3><p>Other Calls</p><p>内存分配库还支持其它一些调用。例如，<code>calloc()</code>分配内存，并在返回之前将其清零。这样可以防止某些错误（假设您认为内存已清零）而忘记自己进行初始化。当您为某物分配了空间，然后需要向其中添加一些东西时，例程<code>realloc()</code>也会很有用。<code>realloc()</code>会创建一个更大的新内存区域，将旧区域复制到并返回指向新区域的指针。</p><p><br><br><br><br><br></p><h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><p>Address Translation</p><p>在开发CPU的虚拟化过程中，我们集中于一种称为受限的直接执行(limited direct execution, LDE)。它背后的想法很简单：在大多数情况下，让程序直接在硬件上运行。但是，在某些关键的时间点（如，当进程发出系统调用或发生计时器中断时），请安排好操作系统，以确保正确的事情发生。因此，在几乎没有硬件支持的情况下，操作系统将尽最大努力拜托正在运行的程序，从而提供有效的虚拟化。但是，通过在这些关键时刻进行干预，操作系统可确保对硬件进行控制。效率(efficiency)和控制(control)是任何现代操作系统的两个主要目标。</p><p>在虚拟化内存中，我们将采取类似的策略，在提供所需的虚拟化的同时实现效率和控制力。效率要求我们利用硬件支持，起初会很基本（如，只有几个寄存器），但会变得相当复杂(如，TLB，page-table支持)。控制意味着操作系统确保除了自身的内存外，不允许使用其它任何应用程序访问任何内存。因此，为了保护应用程序彼此之间以及操作系统与应用程序之间的相互帮助，我们在这里也需要硬件的帮助。最后，就灵活性而言，我们将需要从VM系统中获取更多信息。具体来说，我们希望程序能够以任意方式使用其地址空间，从而使系统更易于编程。因此，我们找出了症结所在:</p><blockquote><p>HOW TO EFFICIENTLY AND FLEXIBLY VIRTUALIZE MEMORY<br>How can we build an efficient virtualization of memory? How do we provide the flexibility needed by applications? How do we maintain control over which memory locations an application can access, and thus ensure that application memory accesses are properly restricted? How do we do all of this efficiently?</p></blockquote><p>我们将使用的通用技术可以被视为<strong>基于硬件的地址转换</strong>(hardware-based address translation)，简称为<strong>地址转换</strong>(address translation)，它是对有限直接执行(lde)的一般方法的补充。借助地址转换，硬件转换每个内存访问（如，fetch指令、load、store），将指令提供的虚拟地址更改为所需信息实际所在的物理地址。因此，在每个内存引用上，硬件都会执行地址转换，以将应用程序内存引用重定向到它们在内存中的实际位置。</p><p>当然，仅硬件本身不能虚拟化内存，因为它只是提供了低级机制来有效地进行虚拟化。操作系统必须在关键点接入以设置硬件，以便进行正确的转换。因此，它必须管理内存，跟踪那些位置空闲以及正在使用那些位置，并明智地进行干预以保持对内存使用方式的控制。</p><p>所有这些工作的目标是再次营造一种美好的幻想：该程序具有自己的私有内存，其自身代码和数据驻留在其中。虚拟现实的背后隐藏这丑陋的物理事实：当一个或多个CPU在运行一个程序与另一个程序之间切换时，许多程序实际上在同时共享内存。通过虚拟化，操作系统（在硬件的帮助下）将丑陋的机器现实转变为有用的，强大且易于使用的抽象。</p><p><br><br><br></p><h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h3><p>Assumptions</p><p>我们首次关于虚拟化内存的尝试将非常简单，几乎时可笑的。当您视图了解TLB，multi-level page tables和其它技术的来龙去脉时，这就是操作系统的运行方式。</p><p>具体来说，我们现在假设用户的地址空间必须连续(contiguously)放置在物理内容中。为了简单起见，我们还将假定地址空间的大小不是太大（小于物理内存）。最后，我们还将假定每个地址空间的大小完全相同。如果这些假设听起来不切实际，请不要担心，我们将在使用过程中放松它，从而实现逼真的内存虚拟化。</p><p><br><br><br></p><h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><p>An Example</p><p>为了更好地了解实现地址转换所需做的事情以及为什么需要这种机制，我们来看一个简单的栗子。想象有一个进程的地址空间如图15-1所示。我们将在这里检查的是一个简短的代码序列，该序列从内存中加载值，将其递增3，然后将值存储回内存中。你可以想象此C语言的代码可能如下所示。编译器将这一行代码转换为汇编，可能看起来像着这样（在x86汇编中）。在Linux上使用<code>objdmp</code>进行反汇编。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">3000</span>; <span class="comment">// thanks, Perry.</span></span><br><span class="line">  x = x + <span class="number">3</span>; <span class="comment">// line of code we are interested in</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">128: movl 0x0(%ebx), %eax ;load 0+ebx into eax</span><br><span class="line">132: addl $0x03, %eax ;add 3 to eax register</span><br><span class="line">135: movl %eax, 0x0(%ebx) ;store eax back to mem</span><br></pre></td></tr></table></figure><p>该段代码相对简单。假定x的地址已放置在寄存器ebx中，然后使用movl指令将该地址处的值加载到通用寄存器eax中。下一条指令将eax加3，最后一条指令将eax中的值存储在同一位置的内存中。</p><p>在图15-1中，观察代码和数据在进程的地址空间中的布局方式。三指令代码序列位于地址128（在顶部附近的代码部分）中，变量x的值位于地址15KB(在底部附近的stack中)。在图中，x的初始值为300，如其在栈中的位置所示。</p><p><img src="/images/OSTEP/15-1.png" alt></p><p>当这些指令运行时，从进程的角度来看，将进行以下内存访问:</p><ul><li>Fetch instruction at address 128</li><li>Execute this instruction (load from address 15 KB)</li><li>Fetch instruction at address 132</li><li>Execute this instruction (no memory reference)</li><li>Fetch the instruction at address 135</li><li>Execute this instruction (store to address 15 KB)</li></ul><p>从程序的角度来看，其地址空间从地址0开始，最大增加到16KB。它生成的所有内存引用都应该在这些范围内。但是，为了虚拟化内存，操作系统希望将进程放置在物理内存中的其它位置，而不必放在地址0。因此，我们遇到了一个问题：如何以一种对进程透明的方式将进程重新放置在内存中？当实际上地址空间位于其它物理地址时，我们如何提供从0开始的虚拟地址空间的错觉？</p><p>在图15-2中找到了此进程的地址空间放置在内存中后，物理内存样子的栗子。在改图中，您可以看到操作系统本身使用了物理内存的第一个插槽，并且它已将上述示例中的过程重新定位到从32KB物理内存地址开始的插槽中。其它两个插槽时空闲的（16-32KB和48-64KB）。</p><p><img src="/images/OSTEP/15-2.png" alt></p><p><br><br><br></p><h3 id="动态-基于硬件-重定位"><a href="#动态-基于硬件-重定位" class="headerlink" title="动态(基于硬件)重定位"></a>动态(基于硬件)重定位</h3><p>Dynamic (Hardware-based) Relocation</p><p>为了对基于硬件的地址转换有一定的了解，我们将首先讨论第一代产品。在1950年代后期的第一台分时(time-sharing)机器中引入了一个简单的概念——基准(base)和边界(bounds)。该技术也称为动态重定位(dylamic relocation)。</p><p>具体来说，我们在每个CPU中需要两个硬件寄存器：</p><ul><li>base register</li><li>bounds register（有时称为limitregister）</li></ul><p>这个base-and-bounds对将使我们能够将地址空间放置在物理内粗中所需的任何位置，并在确保进程只能访问自己的地址空间的同时这样做。在这种设置下，每个程序都被编写和编译，就好像加载到地址0一样。但是，当程序开始运行时，操作系统会决定将其加载到物理内存中的哪个位置，并将base register设置为该值。在上面的栗子中，操作系统决定将进程加载到32KB的物理地址，因此将base register设置为此值。</p><p>进程运行时，有趣的事情开始发生。现在，当进程生成任何内存引用时，处理器将按以下方式对其进行转换: <code>physical address = virtual address + base</code></p><p>进程生成的每个内存引用都是一个虚拟地址。硬件又将base register的内容添加到该地址，结果是可以发布到内存系统的物理地址。</p><p>为了更好地理解这一点，让我们追溯一条指令执行时发生的情况。具体来说，让我们看一下先前序列中的一条指令：<code>128: movl 0x0(%ebx), %eax</code></p><p>程序计数器(program counter)设置为128，当硬件需要fetch(提取)该指令时，它首先将该值增加到32KB(32768)的base register值中，以得到32896的物理地址。然后，硬件从该物理地址获取指令。接下来，处理器开始执行指令。然后，在某个时候，该进程从虚拟地址15KB发出负载，处理器将其加载，然后再次添加到base register(32KB)，获得最终物理地址47KB，从而获得所需的内容。</p><p>将虚拟地址转换为物理地址正是我们称为地址转换的技术。也就是说，硬件获取进程认为正在引用的虚拟地址，并将其转换为数据实际驻留的物理地址。因为地址的这种重定位(relocation)发生在运行时，并且因为即使进程开始运行后我们也可以移动地址空间，所以该技术通常称为动态重定位(dynamic relocation)。</p><p>现在你那可能会问： bounds(limit) register发生了什么？您可能已经猜到了，bounds register在那里可以提供保护。具体来说，处理器将首先检查内存引用是否在范围之内，以确保它是否合法。在上面的简单示例中，bounds register始终设置为16KB。如果某个进程生成的虚拟地址大于边界(bound)，或为负数，则CPU将引发异常，并且该进程可能会终止。因此，边界点要确保进程生成的所有地址都是合法的，并且在进程的边界内。</p><p>我们应该注意，base和bounds寄存器是芯片上保留的硬件结构（每个CPU一对）。有时人们将处理器中有助于地址转换的部分称为<strong>内存管理单元</strong>(memory management unit, MMU)。随着我们开发更复杂的内存管理技术，我们将向MMU添加更多电路。</p><p>关于bound register的一些说明，可以在以下两种方式的其中一项定义：一种方式(如上所述)，它保持地址空间的大小，因此硬件在添加base之前首先针对它检查虚拟地址。第二种方式，它确保地址空间末端的物理地址，因此硬件首先添加base，然后确保该地址在范围之内。两种方法在逻辑上是等效的，为简单起见，我们通常采用前一种方法。</p><p><br></p><blockquote><p>ASIDE: SOFTWARE-BASED RELOCATION<br>In the early days, before hardware support arose, some systems performed a crude form of relocation purely via software methods. The basic technique is referred to as static relocation, in which a piece of software known as the loader takes an executable that is about to be run and rewrites its addresses to the desired offset in physical memory.<br>For example, if an instruction was a load from address 1000 into a register (e.g., movl 1000, %eax), and the address space of the program was loaded starting at address 3000 (and not 0, as the program thinks), the loader would rewrite the instruction to offset each address by 3000 (e.g., movl 4000, %eax). In this way, a simple static relocation of the process’s address space is achieved.<br>However, static relocation has numerous problems. First and most importantly, it does not provide protection, as processes can generate bad addresses and thus illegally access other process’s or even OS memory; in general, hardware support is likely needed for true protection [WL+93]. Another negative is that once placed, it is difficult to later relocate an address space to another location</p></blockquote><p><br></p><blockquote><p>TIP: HARDWARE-BASED DYNAMIC RELOCATION<br>With dynamic relocation, a little hardware goes a long way. Namely, a base register is used to transform virtual addresses (generated by the program) into physical addresses. A bounds (or limit) register ensures that such addresses are within the confines of the address space. Together they provide a simple and efficient virtualization of memory.</p></blockquote><p><br><br><br></p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><p>Example Translations</p><p>要更详细地了解基于base-and-bound的地址转换，我们来看个栗子。想象一下，地址空间大小为4KB(假设)的进程已在16KB的物理地址处加载。以下是许多地址转换的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Virtual Address    Physical Address</span><br><span class="line">0 → 16 KB</span><br><span class="line">1 KB → 17 KB</span><br><span class="line">3000 → 19384</span><br><span class="line">4400 → Fault (out of bounds)</span><br></pre></td></tr></table></figure><p>从示例中可以看到，您很容易将base address简单地添加到虚拟地址（可以正确地视为地址空间的偏移量）来获得最终的物理地址。仅当虚拟地址太大或负数时，结果才是错误，从而引发异常。</p><p><br><br><br></p><h3 id="硬件支持：摘要"><a href="#硬件支持：摘要" class="headerlink" title="硬件支持：摘要"></a>硬件支持：摘要</h3><p>Hardware Support： A Summary</p><p>现在让我们总结一下我们需要硬件的支持(图15-3)。首先，正如有关CPU虚拟化的章节所讨论的，我们需要两种不同的CPU模式。操作系统以特权模式(privileged mode)(内核模式 kernel mode)，在该模式下，它可以访问整个机器。应用程序在用户模式(user mode)模式下运行，在此模式下它们只能有限制的做些什么。A single bit指示CPU当前正在运行的模式。在某些特殊场合（如系统调用或其它类型的异常或中断），CPU会切换模式。</p><p>硬件还必须自己提供base and bounds registers。因此，每个CPU都有一对额外的寄存器，它们是CPU的内存管理单元(MMU)的一部分。当用户程序运行时，硬件将通过将base value添加到用户程序生成的虚拟地址中来转换每个地址。硬件还必须能够检查地址是否有效，这可以通过使用bounds register的CPU中的某些电路来实现。</p><p>硬件应提供特殊的指令来修改base and bounds registers，从而允许操作系统在运行不同进程时对其进行改变。这些指令是特权的(privilegegd)，仅在内核模式下才能修改寄存器。想象一下，如果用户进程在运行时可以任意修改base register，则会给用户造成严重破坏，则会给用户造成严重破坏。想象一下，多可怕呀！</p><p>最后，CPU必须能够在某些情况下生成异常(exceptions)，如一个用户程序试图非法访问内存（地址超出边界）。在这种情况下，CPU应该停止执行用户程序，并安排操作系统运行 out of bounds exception handler。操作系统处理程序(OS Handler)可以弄清楚如何做出反应，在这种情况下，可能会终止进程。同样，如果用户程序尝试更改(privileged) base and bounds registers，则CPU应引发异常并运行在用户模式下的处理程序来执行一个特权操作。CPU还必须提供一种方法来通知这些处理程序(handler)的位置。因此，需要更多特权指令。</p><p><img src="/images/OSTEP/15-3.png" alt></p><p><br><br><br></p><h3 id="操作系统问题"><a href="#操作系统问题" class="headerlink" title="操作系统问题"></a>操作系统问题</h3><p>Operating System Issues</p><p>正如硬件提供了支持动态重定位的新功能一样，该操作系统现在也必须解决新问题。硬件支持和操作系统管理的结合导致实现简单的虚拟内存。具体而言，在一些关键时刻，操作系统必须介入以实现我们的虚拟内存的base-and-bounds。</p><p>首先，操作系统必须在创建进程时采取措施，在内存中为其地址空间找到空间。幸运的是，假设每个地址空间小于物理内存的大小，并且每个空间大小相同，这对操作系统而言很容易。它可以简单地讲武里内u你视为一组插槽，并跟踪每个插槽是空闲的还是正在使用的。创建新进程时，操作系统必须搜索数据结构（通常称为空闲列表），以找到用于新地址空间的空间，然后将其标记为已使用。对于可变大小的地址空间，会更复杂，在后面的章节中讲解。</p><p>看个栗子。在图15-2中，您可以看到操作系统本身使用了物理内存的第一个插槽，并且它已将上述示例中的进程重新定位到从32KB物理内存地址开始的插槽中。其它两个插槽是空闲的（16-32KB, 48-94KB）。因此，空闲列表(free list)应该包含这两个条目。</p><p>其次，操作系统必须在进程终止时（即，它正常退出或由于行为不当而被强制杀死）做一些工作，回收其所有内存以供其它进程或操作系统使用。进程终止后，操作系统将其内存存放回空闲列表，并根据需要清楚所有相关联的数据结构。</p><p>第三，当发生上下文切换时，操作系统还必须执行一些其它步骤。毕竟，每个CPU上只有一对base and bounds register，并且它们的值对于每个正在运行的程序都是不同的，因为每个程序都加载到内存中不同的物理地址。因此，操作系统必须在进程之间进行切换时恢复 base-and-bounds register 对。具体来说，当操作系统决定停止运行某个进程时，它必须以某些按进程的结构将 base-and-bounds registers 的值保存到内存中。如process structure or process control block(PCB)。同样，当操作系统恢复正在运行的进程时，它必须将CPU的 base and bounds 的值设置为该进程的正确值。</p><p>我们应该注意，当进程停止时(即未运行)时，操作系统可能很容易地将地址空间从内存中一个位置移动到另一个位置。要移动进程的地址空间，操作系统首先要对进程进行调度。然后，操作系统将地址空间从当前位置复制到新位置。最后，操作系统会更新已保存的base register（在进程结构中）以指向新位置。恢复该过程后，将恢复其(新的) base registers，并再次开始运行，而不必担心其指令和数据现在位于内存中的全新位置。</p><p>第四，操作系统必须提供异常处理(exception handler)，或要调用的功能，如上所述，操作系统会在引导时(boot time)（via privileged instructions）安装这些处理程序(handler)。例如，如果某个进程视图访问边界之外的内存，则CPU将引发异常。当一个异常抛出时，操作系统必须准备好采取措施。操作系统的普遍反应将会有敌意：它可能会终止恶意程序。草最系统应高度保护正在运行的计算机，因此，它对于尝试访问内存或执行不应执行的指令的进程没有帮助。再见，行为异常。</p><p>图15-5和图15-6说明了许多硬件/操作系统时间轴上的互动。第一个显示了操作系统在引导时为准备使用机器所做的工作，第二个显示了进程(A)开始运行时发生的情况。请注意，在没有操作系统干预的情况下，硬件如何处理其内存转换。咋某个时间点(第二图的中间)，发生了计时器中断，并且操作系统切换到进程B，该进程执行错误的加载(到非法内存地址)。到那时，操作系统必须参与进来，终止进程并通过释放B的内存并将其条目从进程表中删除来进行清理。</p><p>从图中可看出，我们仍然遵循有限直接执行(limited direct execution)的基本方法。在大多数情况下，操作系统只是适当地设置硬件，然后让进程直接在CPU上运行。仅当进程异常时，才必须介入操作系统。</p><p><img src="/images/OSTEP/15-4.png" alt></p><p><img src="/images/OSTEP/15-5.png" alt></p><p><img src="/images/OSTEP/15-6.png" alt></p><p><br><br><br></p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Summary</p><p>在本章中，我们用虚拟内存中使用的一种称为地址转换的特定机制扩展了LDE(limited direct execution)的概念。通过地址转换，操作系统可以控制进程中的每个内存访问，从而确保访问保持在地址空间的范围内。这项技术效率的关键是硬件支持，它可以为每次访问执行转换，将虚拟地址（进程的内存视图）转换为物理地址（实际视图）。</p><p>所有这些都以对已重定位的进程以透明的方式执行。该进程不知道其内存引用正在被转换，从而产生一种奇妙的幻想。</p><p>我们还看到了一种特殊的虚拟化形式，称为 base and bounds 或 dynamic relocation。 它非常有效，因为只需要一点硬件逻辑就可以将 base register 添加到虚拟地址并检查进程生成的地址是否在在边界内。base and bounds同样提供保护，操作系统和硬件相结合，以确保没有进程可以在其自身的地址空间之外生成内存引用。保护无疑是操作系统最重要的目标之一。没有它，操作系统将无法控制机器（如果进程可以自由覆盖内存，则它们可以轻松地执行令人讨厌的事情，例如覆盖陷阱表并接管系统）。</p><p>不幸的是，这种简单的动态重定位技术确实没有效率。如，图15-2中所看到的，重定位的过程正在使用32-48KB的物理内存。但是，由于进程stack和heap不是太大，因此两者之间的所有空间都被浪费掉了。这种类型的浪费通常被称为内部碎片(internal fragmentation)，因为分配的单元的内部的空间并未全部用完（即碎片化, fragmented），因此被浪费了。在我们目前的方法中，尽管可能有足够的物理内存用于更多进程，但是我们目前仅限于将地址孔家放置在固定大小的插槽中，因此可能产生内部碎片。因此，我们将需要更复杂的机制，以尝试更好地利用物理内存并避免内部碎片。第一个尝试是对 base and bounds 进行细微的概括，即分段(segmentaion)，接下来将进行讨论。</p><p><br><br><br><br><br></p><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>Segmentation</p><p>到目前为止，我们已经将每个进程的整个地址空间都放在了内存中。借助 base and bounds registers，操作系统可以轻松地将进程重定位到物理内存的不同部分。但是，您可能已经注意到关于我们的这些地址空间的一些有趣之处：在 stack 和 heap 之间的中间有一大块空闲(free)空间。</p><p>从图16-1可以想象，虽然进程没有使用 stack 和 heap 之间的空间，但是当我们将整个地址空间重新放置在物理内存中的某个位置时，它仍在占用物理内存。因此，使用 base and bounds registers pair 来虚拟化内存的简单方法很浪费。当整个地址空间都无法容纳到内存中时，这也使得运行程序变得非常困难。因此， base and bounds 并不像我们所希望的那样灵活。</p><p><br></p><blockquote><p>THE CRUX: HOW TO SUPPORT A LARGE ADDRESS SPACE<br>How do we support a large address space with (potentially) a lot of free space between the stack and the heap? Note that in our examples, with tiny (pretend) address spaces, the waste doesn’t seem too bad. Imagine, however, a 32-bit address space (4 GB in size); a typical program will only use megabytes of memory, but still would demand that the entire address space be resident in memory.</p></blockquote><p><br></p><p><img src="/images/OSTEP/16-1.png" alt="16-1"></p><p><br><br><br></p><h3 id="Generalized-Base-Bounds"><a href="#Generalized-Base-Bounds" class="headerlink" title="Generalized Base/Bounds"></a>Generalized Base/Bounds</h3><p>为了解决这个问题，一个想法诞生了。它被称为<strong>分段</strong>(segmentation)。这是一个很老的想法，至少可以追溯到1960年代。这个想法很简单：为什么在我们的MMU中不仅有一对 base and bounds pair，而且为什么地址空间的每个逻辑段(logical segment)都没有 base and bounds pair？段只是特定长度的地址空间的连续部分，在我们的规范地址空间中，我们具有三个逻辑上的不同的段： code, stack, heap。分段允许操作系统执行的操作是将这些分段中的每个分段放置在物理内存的不同部分中，从而避免用未使用的虚拟地址空间填充物理内存。</p><p>让我们看一个栗子。假设我们想将图16-1中的地址空间放入物理内存中。通过每个段的 base and bounds pair，我们可以将每个段独立地放置在物理内存中。例如，请参见图16-2。在那，您看到一个64KB的物理内存，其中有这三个段（并且为操作系统保留了16KB）。</p><p><img src="/images/OSTEP/16-2.png" alt="16-2"></p><p>从图中可以看出，只有已使用的内存才在物理内存中分配了空间，因此可以容纳具有大量未使用地址空间的大地址空间（有时称为稀疏地址空间(sparse address space)）。MMU中支持分段所需的硬件结构正是您所期望的：在这种情况下，一组三个 base and bounds register pairs。下图6-3显示了上面示例的寄存器值，每个边界寄存器保存段的大小。</p><p><img src="/images/OSTEP/16-3.png" alt="16-3"></p><p>从图中可以看到，代码段位于物理地址32KB，大小为2KB，heap segment位于34KB，大小为3KB。这里的段大小(size segment)与之前介绍的边界寄存器完全相同。它准确地告诉硬件该段中有多少字节有效（因此，使硬件能够确定程序何时在那些界限之外进行了非法访问）。</p><p>让我们使用图16-1中的地址空间进行示例转换。假定引用了虚拟地址100（位于代码段中，如图16-1中那样）。发生引用时（如，fetch指令），硬件会将base value添加到段的偏移量(offset)中（这里为100），以达到所需的物理地址：<code>100+32KB(32768)</code>（或32868）。它将检查该地址是否在范围之内（100小于2KB），找到该地址，然后发出对物理内存地址32868的引用。</p><p>现在让我们看一下堆中的一个地址，虚拟地址4200（图16-1）。如果仅将虚拟地址4200添加到heap的base（34KB），则会得到一个物理地址39016，这不是正确的物理地址。我们首先要做的是将偏移量(offset)提取到堆(heap)中，即地址指向该段中的哪个字节。因为heap从虚拟地址4KB(4096)开始，所以4200的偏移量实际上是4200减去4096（或104）。然后，我们将此偏移量添加到base register 物理地址(34K)中以获得所需的结果：34920。</p><p>如果我们试图引用一个超出堆末尾的非法地址（即7KB或更大的虚拟地址）怎么办？您可以想象会发生什么：硬件检测到地址超出范围，trap os，可能会终止违规进程。现在您知道了所有C程序员都学过的著名术语的起源：分段违规(segmentation violation)或分段错误(segmentation fault)。</p><p><br></p><blockquote><p>ASIDE: THE SEGMENTATION FAULT<br>The term segmentation fault or violation arises from a memory access on a segmented machine to an illegal address. Humorously, the term persists, even on machines with no support for segmentation at all. Or not so humorously, if you can’t figure out why your code keeps faulting.</p></blockquote><p><br><br><br></p><h3 id="我们指的是哪个段"><a href="#我们指的是哪个段" class="headerlink" title="我们指的是哪个段"></a>我们指的是哪个段</h3><p>Which Segment Are We Referring To?</p><p>硬件在转换期间使用段寄存器(segment registers)。它如何知道一个段的偏移量，以及地址指向哪个段？</p><p>一种常见的方法（有时称为显式方法）是根据虚拟地址的前几位将地址空间划分为多个段。该技术一再VAX/VMS系统中使用。在上面的栗子中，我们有三个段。因此我们需要2bits来完成我们的任务。如果我们使用14-bit虚拟地址的前两位来选择段，我们的虚拟地址看起来如下：</p><p><img src="/images/OSTEP/segment-1.png" alt></p><p>然后，在我们的示例中。如果高两位为00，则硬件知道虚拟地址在代码段(code segment)中，因此使用 code base and bounds pair 来重新定位到正确的物理位置。如果高两位为01，则硬件知道地址在heap中，因此使用heap base and bounds。让我们以上面栗子的堆虚拟地址(4200)进行转换，以确保其清晰明了。虚拟地址4200的二进制形式如下：</p><p><img src="/images/OSTEP/segment-2.png" alt></p><p>从图中可看到，高两位(01)告诉硬件我们指的是哪个段。低12位是该段的偏移量（<code>0000 0110 1000</code>，十六进制<code>0x068</code>，或十进制<code>104</code>）。因此，硬件仅使用前两位来确定要使用的段寄存器，然后将接下来的12位用作段中的偏移量。通过将base register添加到offset，硬件达到最终的物理地址。请注意，偏移量也使边界检查(bounds check)变得很容易：我们可以简单地检查偏移量是否小于边界。因此，只需要检查偏移量是否小于边界即可。如果不是，则该地址是非法的。因此，如果base and bounds是数组（每段只有一个条目），则硬件将执行以下操作以获得所需的物理地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get top 2 bits of 14-bit VA</span></span><br><span class="line">Segment = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SEG_SHIFT</span><br><span class="line"><span class="comment">// now get offset</span></span><br><span class="line">Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line"><span class="keyword">if</span> (Offset &gt;= Bounds[Segment])</span><br><span class="line">    RaiseException(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    PhysAddr = Base[Segment] + Offset</span><br><span class="line">    Register = AccessMemory(PhysAddr)</span><br></pre></td></tr></table></figure><p>在我们运行的栗子中，我们可以填写上述上述常量的值。具体来说，将SEG MASK设置为<code>0x3000</code>，将SEG SHIFT设置为<code>12</code>，将OFFSET MASK设置为<code>0xFFF</code>。</p><p>您可能还注意到，当我们使用前两位时，并且只有三个段(code, heap, stack)，地址空间的一个段将不使用。为了充分利用虚拟地址空间（并避免使用未使用的段），某些系统将代码(code)与堆(heap)放在同一段中，因此仅使用一位(1bit)来选择要使用的段。使用顶部这么多的最高位来选择段的另一个问题是，它限制了虚拟地址空间的使用。具体来说，每个段都被限制为最大大小，在我们的示例中为4KB（使用前两位选择意味着16KB的地址空间被分成4部分，在本例中为4KB）。如果正在运行的程序希望将段(stack, heap)增加到该最大值意外，则该程序不走运。</p><p>硬件还有其它方法可以确定特定地址位于哪个段中。在隐式方法中，硬件通过地址的形成方式来确定段。例如，如果该地址是从程序计数器生成的(fetch指令)，则该地址在代码段内；如果该地址是基于 stack或base pointer，则它必须在stack segment中；其它地址都必须的heap segment中。</p><p><br><br><br></p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>What About The Stack?</p><p>到目前为止，我们省略了地址空间的一个重要组成部分：栈(stack)。上图中，栈以重定位到物理地址28KB，但有一个关键的区别：它向后增长（即向较低的地址）。在物理内存中，它从28KB开始，然后增长回26KB，对应于16KB至14KB的虚拟地址。转换必须以不同的方式进行。</p><p>我们需要的第一件事是额外的硬件支持。硬件不仅需要base and bounds values，还需要知道段增长的方式（例如，当段向正方向增长时，将其设置为1，反之为0）。我们对硬件轨迹的更新视图如图16-4所示：</p><p><img src="/images/OSTEP/16-4.png" alt="16-4"></p><p>有了硬件的了解，即段可能会向负方向增长，因此硬件现在必须稍微转换这些虚拟地址。让我们以栈虚拟地址为例，并对其进行转换以了解该过程。在此栗子中，假设我们希望访问虚拟地址15KB，该地址映射到物理地址27KB。因此，我们的虚拟地址的二进制形式：<code>11 1110 0000 0000</code>（十六进制<code>0x3C00</code>）。硬件使用最高的两位(11)来指定段，但随后我们留下了3KB的偏移量。为了获取正确的负偏移，我们必须从3KB中减去最大的段大小：在此示例中，一个段可以为4KB，因此正确的负偏移为<code>3KB - 4KB = -1KB</code>。我们秩序将负偏移量(<code>-1KB</code>)加到基数(base)(<code>28KB</code>)即可得到正确的物理地址(<code>27KB</code>)。可以通过确保负偏移的绝对值小于等于段的当前大小(2KB)来计算边界检查。</p><p><br><br><br></p><h3 id="支持分享"><a href="#支持分享" class="headerlink" title="支持分享"></a>支持分享</h3><p>Support for Sharing</p><p>随着对分段的支持的增加，系统设计人员很快意识到，只要多一点硬件支持，它们就可以实现新型的效率。具体来说，为了节省内存，有时在地址空间之间共享某些内存段很有用。特别是，代码共享(code sharing)是常见的，并且仍在当今的系统中使用。</p><p>为了支持共享，我们需要硬件以保护位(protection bits)的形式提供一些额外的支持。基本的支持在每个段上增加了几位，只是程序是否可以读取或写入段，或者执行段内的代码。通过将代码段设置为只读(read-only)，可在多个进程之间共享同一段代码，而不必担心隔离问题。尽管每个进程仍认为自己正在访问自己的私有内存，但操作系统秘密地共享了无法被进程修改的内存，因此保留了这种幻觉。</p><p>硬件和操作系统追踪的附加信息如图16-5所示。如您所见，代码段被设置为read和exe，因此内存中的同一物理段可以映射到多个虚拟空间。</p><p><img src="/images/OSTEP/16-5.png" alt="16-5"></p><p>使用保护位，先前描述的硬件算法将不得不更改。除了检查虚拟地址是否在范围之内，硬件还必须检查是否允许特定访问。如果用户进程尝试写入只读段或执行不可执行的段，则硬件应引发异常，从而让操作系统处理有问题的进程。</p><p><br><br><br></p><h3 id="细粒度与粗粒度分段"><a href="#细粒度与粗粒度分段" class="headerlink" title="细粒度与粗粒度分段"></a>细粒度与粗粒度分段</h3><p>Fine-grained vs. Coarse-grained Segmentation</p><p>到目前为止，我们的大多数示例都集中在只有几个段(code, stack, heap)的系统上。我们可以认为这种分段是<strong>粗粒度</strong>(coarse-grained)的，因为它将地址空间切分为相对较大的粗块(coarse chunks)。但是，某些早期的系统更加灵活，并且允许地址空间由大量较小的段组成，称为<strong>细粒度分段</strong>(fine-grained segmentation)。</p><p>支持许多段需要进一步的硬件支持，并将某种类型的分段表(segmentation table)存储在内存中。这样的分段表通常支持创建大量的段，因此使系统能够以比我们目前为止讨论的方式更灵活的方式使用段。例如，诸如Burroughs B5000之类的早期机器就支持数千个段，并期望编译器将代码和数据分成单独的段，然后操作系统和硬件将支持这些段。当时的想法是，通过拥有细粒度的段，操作系统可以更好地了解正在使用的段以及哪些未使用的段，从而更有效地利用主内存。</p><p><br><br><br></p><h3 id="操作系统支持"><a href="#操作系统支持" class="headerlink" title="操作系统支持"></a>操作系统支持</h3><p>OS Support</p><p>您现在应该对分段的工作原理有了一个基本的了解。随着系统的运行，许多片(pieces of)地址空间会重新放置到物理内存中。因此相对与我们的更简单的方法（整个地址空间只有一个base/bound对），可以节省大量的物理内存。具体来说，不需要在物理内存中分配分配stack和heap之间未使用的空间，这使我们将更多地址空间放入物理内存中，并为每个进程支持较大且稀疏的虚拟地址空间。</p><p>但是，分段为操作系统带来了许多新问题：</p><ul><li>第一个是一个老问题：操作系统应该在上下文切换上做什么？您现在应该有一个很好的猜测：段寄存器必须保存(saved)和恢复(restored)。显然，每个进程都有自己的虚拟地址空间，操作系统必须确保正确设置这些寄存器，然后才能再次运行该进程。</li><li>第二个是当段增长时的操作系统交互(interaction)。例如，程序可以调用<code>malloc()</code>分配对象。在某些情况下，现有的堆将能够处理请求，因此<code>malloc()</code>将为对象找到可用空间，并将指向该对象的指针返回给调用者(caller)。但是，在其它情况下，heap segment本身可能需要增长。在这种情况下，内存分配库将执行系统调用以增长堆（如，传统的UNIX <code>sbrk()</code> 系统调用）。然后，操作系统将提供更多孔家，将segment size register更新为新的(bigger)大小，并通知库成功。然后，库可以为新对象分配空间，并成功返回到调用程序。请注意，如果没有更多的物理内存可用，或操作系统确定调用进程已经有太多内存，则操作系统可能会拒绝该请求。</li><li>最后，也许是最重要的问题是管理物理内存中的可用空间(free space)。创建新的地址空间时，操作系统必须能够在物理内存中为其segment找到空间。先前，我们假设每个地址空间的大小相同，因此可以将物理内存视为一堆插槽(slots)，其中可以容纳多个进程。现在，每个进程有多个段，每个段可能不同大小。</li></ul><p>出现的一般问题是物理内存很快就充满了可用空间的小洞(little holes of free space)，这使得分配新段或扩展现有的段变得困难。我们将此问题称为<strong>外部碎片</strong>(external fragmentation)，如图16-6左边。</p><p>在该示例中，出现了一个进程，并希望分配20KB的段。此例中，有24KB的可用空间，但不是在一个连续的段中（而是在三个非连续的块中）。因此，操作系统无法满足20KB的请求。当增长段的请求到达时，可能会发生类似的问题。如果物理空间的下一个如此之多的字节不可用，则操作系统将不得不拒绝该请求，即使物理内存中其它位置可能有可用的字节。</p><p>解决此问题的一种方法是通过重新布置现有的段来<strong>压缩</strong>(compact)物理内存。例如，操作系统可以停止任何正在运行的进程，将其数据复制到内存的一个连续区域，更改其段寄存器值以指向新的物理位置，从而可以使用很大的可用内存空间。通过这样做，操作系统使新的分配请求成功。但是，压缩是很昂贵的。因为复制段(copying segments)占用大量内存，并且通常会占用大量的处理器时间。请参见图16-6右边以获取压缩物理内存的示意图。压缩还会使增加现有的段的请求难以满足，因此可能会导致进一步调整以适应此类请求。</p><p>相反，一种更简单的方法可能是使用空闲列表(free list)管理法，该算法视图使大量内存可用于分配人们实际上采用了数百种方法，包括经典算法，例如最佳拟合（保留最佳空间列表，并返回大小最接近的空闲空间，满足对请求者的期望分配），最不适合(worst-fit, first-fit)以及更复杂的方案，如伙伴算法(buddy algorithm)。不幸的是，尽管算法多么聪明，但外部碎片仍然存在。因此，好的算法只是试图将其最小化。</p><p><br><br><br></p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>Summary</p><p>分段解决了许多问题，并帮助我们构建了更有效的内存虚拟化。除了动态重定位之外，分段还可以避免地址空间逻辑段之间潜在的巨大内存浪费，从而更好地支持稀疏地址空间。它很快，因为进行算术分段所需的操作很容易且非常适合硬件。转换的开销很小。附带的好处：代码共享。如果将代码放在单独的段中，则可能在多个正在运行的程序之间共享该段。</p><p>但是，据我们了解，在内存中分配大小可变的段会导致一些我们需要克服的问题。如上所述，第一个是外部碎片(external fragmentation)。因为段是可变的，所以空闲内存会被切成奇数大小的片段，因此很难满足内存分配请求。可以尝试使用智能算法或定期压缩内存，但是问题是根本的，很难避免。</p><p>第二个也许是更重要的问题是，分段仍然不够灵活，无法支持我们完全通用的稀疏地址空间。例如，如果我们在一个逻辑段中有一个大型但稀疏使用的堆，则整个堆仍必须驻留在内存中才能被访问。换句话说，如果我们关于地址空间使用方式的模型与底层分段的支持方式完全不匹配，那么分段就不能很好地工作。因此，我们需要找到一些新的解决方案。</p><p><br><br><br><br><br></p><h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><p>Free-Space Management</p><p>在本章中，我们从虚拟内存的讨论中走了一段弯路，以讨论任何内存管理系统的基本方面。无论是malloc库（管理进程堆的页面）还是操作系统本身（管理进程地址空间的各个部分）。具体来说，我们将讨论有关<strong>空闲空间管理</strong>(free memory management)的问题。</p><p>让我们使问题更具体。正如我们在讨论<strong>分页</strong>(paging)的概念时将看到的那样，管理可用空间肯定很容易。将要管理的空间划分为固定大小的单元很容易。在这种情况下，您只需保留这些固定大小单元的列表即可。当客户端请求其中一个时，返回第一个条目。</p><p>当您管理的空闲空间由大小可变的单元组成时，空闲空间管理会变得更加困难（有趣）。当使用分段实现虚拟内存时，这会在用户级(user level)内存分配库(memory allocation library)（如<code>malloc()</code>和<code>free()</code>）以及管理物理内存的操作系统中出现。无论哪种情况，存在的问题都称为外部碎片：空闲空间被切成不同大小的小碎片，因此碎片化。后续请求可能会失败，以为即使可用空间总量超过了请求的大小，也没有单个连续的空间可以满足请求。</p><p><img src="/images/OSTEP/freespace-1.png" alt></p><p>该图显示了此问题的示例。在这种情况下，可用的总可用空间为20Byte。不幸的是，它被分为两个大小为10的块。结果，即使有20个可用字节，对15Byte的请求也将失败。因此，我们得出了本章要解决的问题。</p><blockquote><p>CRUX: HOW TO MANAGE FREE SPACE<br>How should free space be managed, when satisfying variable-sized requests? What strategies can be used to minimize fragmentation? Whatare the time and space overheads of alternate approaches?</p></blockquote><p><br><br><br></p><h3 id="假设-1"><a href="#假设-1" class="headerlink" title="假设"></a>假设</h3><p>Assumptions</p><p>大部分讨论将集中于用户级内存分配库中分配器的悠久历史。</p><p>我们假定一个基本接口，如<code>malloc()</code>和<code>free()</code>提供的接口。具体来说，<code>void * malloc(size)</code>采用单个参数，即应用程序请求的字节数。它会将一个指针交还给该大小(或更大)的区域。互补例程<code>void free(void *ptr</code>获取一个指针并释放相应的块。注意接口的含义：用户在释放空间时不会将其大小通知库。因此，该库必须能够弄清楚仅将指针分配给它时有多大的内存量。本章稍后将讨论如何执行此操作。</p><p>该库管理的空间在历史上称为堆(heap)，用于管理堆中空闲空间的通用数据结构是某种空闲列表(free list)。此结构包含对内存的托管区域中所有空闲空间块的引用。淡然，此数据结构本身不必是列表，而只需某种数据结构即可追踪空闲空间。</p><p>如上所述，我们进一步假设我们主要关注于外部碎片(external fragmentation)。分配器当然也有可能存在内部碎片(internal fragmentation)的问题。如果分配器分发(hand out)的内存块大于请求的内存块，则此类中未分配(因此未使用)的空间将被视为内部碎片（因为浪费发生在分配的单元内部），这是空间浪费的另一个示例。但是，为了简单起见，并且由于它是两种碎片类型中比较有趣的一种，我们将主要关注外部碎片。</p><p>我们还将假设，一旦将内存交付给客户端，便无法将其重定位到内存中的其它位置。例如，如果程序调用<code>malloc()</code>并被赋予指向堆中某些空间的指针，则该内存区域实质上该程序拥有的（并且不能被库移动），直到该程序通过相应的<code>free()</code>将其返回为止。因此，不可能压缩空闲空间，这将有助于对抗碎片。但是，在实现分段时，可在操作系统中使用压缩来处理分段。</p><p>最后，我们假设分配器管理一个连续的字节区域。在某些情况下，分配器可以要求该区域增长。例如，用户级内存分配库可能会在内核空间不足时调用内核来扩大堆（如调用sbrk之类）。但是，为了简单起见，我们仅假设该区域在整个生命周期中都是一个固定的大小。</p><p><br><br><br></p><h3 id="低级机制"><a href="#低级机制" class="headerlink" title="低级机制"></a>低级机制</h3><p>Low-level Mechanisms</p><p>在深入研究一些政策细节之前，我们将首先介绍大多数分配器中使用的一些常见机制。首先，我们将讨论拆分(splitting)和合并(coalescing)的基础知识，以及大多数分配器中的常用技术。其次，我们将展示如何快速轻松地追踪分配区域的大小。最后，我们将讨论如何在可用空间内构建一个简单列表，以追踪什么是空闲的以及什么不是。</p><p><br></p><p><strong>拆分和合并</strong><br>Splitting and Coalescing</p><p>空闲列表包含了一组元素，这些元素描述了堆中仍剩余的可用空间。因此，假定以下30字节堆：</p><p><img src="/images/OSTEP/freespace-2.png" alt></p><p>该堆的空闲列表上将包含两个元素。一个条目描述了前十个字节空闲段(Bytes 0-9)，一个条目描述了另一个空闲段(Bytes 20-29)。</p><p><img src="/images/OSTEP/freespace-3.png" alt></p><p>如上所述，任何大于10字节的请求都将失败（返回NULL）。只有一个连续的大内存块不可用。任意一个空闲块都可以轻松满足对大小恰好为10字节的请求。但是，如果请求的内容小于十个字节，会发生什么呢？</p><p>假设我们只请求一个字节的内存，在这种情况下，分配器将执行称为拆分(splitting)的操作：它将找到一个可以满足请求的空闲内存块，并将其拆分为两个。它的第一个块将返回给调用者，第二个块将保留在列表中。因此，在上面的示例中，如果请求了1Byte，并且分配器决定使用列表中的第二个元素来满足请求，则对<code>malloc()</code>的调用将返回20(1Byte的分配区域)，列表最终看起来像这样：</p><p><img src="/images/OSTEP/freespace-4.png" alt></p><p>在图中，您可以看到列表基本保持不变。唯一的变化是，空闲区域现在从21开始，而不是20，并且该空闲区域的长度现在只有9。因此，当请求小于任何特定空闲块的大小时，拆分通常在分配器中使用。</p><p>在许多分配器中发现的推论机制被称为空闲空间合并(coalescing)。再次以上面的示例为例。给定这个heap，当应用程序调用<code>free(10)</code>并返回堆中间的空间时会发生什么？如果我们不加考虑就简单地将此可用空间添加会列表中，则最终可能会得到一个如下所示的列表：</p><p><img src="/images/OSTEP/freespace-5.png" alt></p><p>注意此问题：虽然整个堆现在都是空闲的，但似乎将其分成三个块，每个块10个字节因此，如果用户请求20字节，则简单的列表遍历将找不到这样的空闲块，并返回失败。</p><p>为了避免此问题，分配器要做的是在释放一块内存时合并可用空间。这个想法很简单：在返回内存中的空闲块时，请仔细查看块的地址以及附近的空闲空间块。如果新释放的空间紧邻一个现有的空闲块，请将它们合并为一个等大的空闲块。因此，通过合并，我们的最终列表应如下表示：</p><p><img src="/images/OSTEP/freespace-6.png" alt></p><p>确实，这是在进行任何分配之前首先出现的堆列表。通过合并，分配器可以更好地确保可以为应用程序提供较大的空闲扩展区。</p><p><br></p><p><strong>追踪分配区域的大小</strong><br>Tracking The Size Of Allocated Regions</p><p>您可能已经注意到<code>free(void *ptr)</code>的接口没有采用size参数。因此，假设给定一个指针，malloc库可以快速确定要释放的内存区域的大小，从而将空间合并放回空闲列表。</p><p>为了完成此任务，大多数分配器将一些额外的信息存储在header block中，该header block通常在分配的内存块之前保留在内存中。让我们再来看一个栗子（图17-1）。此例中，我们正在检查分配的大小为20Bytes的块，由ptr指向。假设用户调用了<code>malloc()</code>并将结果存储在ptr中，如<code>ptr=malloc(20)</code>。</p><p><img src="/images/OSTEP/17-1.png" alt="17-1"></p><p>header至少包含分配的区域的大小（此例下为20）。它可能还包含其它用于加速释放(deallocation)的指针，用于提供其它完整性检查的幻数以及其它信息。让我们假设一个简单的header，其中包含区域的大小和一个魔幻数字，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> magic;</span><br><span class="line">&#125; <span class="keyword">header_t</span>;</span><br></pre></td></tr></table></figure><p>上面的栗子看起来像图17-2所示。当用户调用<code>free(ptr)</code>时，该库将使用简单的指针算法找出header的起始位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">header_t</span> *hptr = (<span class="keyword">header_t</span> *) ptr - <span class="number">1</span>;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><img src="/images/OSTEP/17-2.png" alt="17-2"></p><p>在获得指向header的指标之后，库可以轻松地确定魔术数字是否与期望值匹配，作为健全性检查(<code>assert(hptr-&gt;magic == 1234567</code>))，并可以通过以下方式计算新释放区域的总大小：简单的数学运算（即，将header的大小添加到区域的大小）。请注意一个细节：空闲区域的大小是header的大小加上分配给用户的空间的大小。因此，当用户请求N个字节的内容时，库不搜索大小为N的空闲块，而实搜索大小为N加上header大小的空闲块。</p><p><br></p><p><strong>嵌入空闲列表</strong><br>Embedding A Free List</p><p>到目前为止，我们已经将简单的空闲列表视为概念实体。它只是描述堆中可用内存块的列表。但是，我们如何在空闲空间本身中建立这样的列表呢？</p><p>在一个更典型的列表中，当分配新节点时，仅在需要节点空间时才调用<code>malloc()</code>。不幸的是，在内存分配库中，您无法执行此操作！相反，您需要在可用空间本身内部(inside)构建列表。</p><p>假设我们要管理一个4096字节的内存块（即，堆为4KB）。为了将其作为空闲列表进行管理，我们首先必须初始化所述列表。最初，列表应具有一个条目，大小为4096（减去header大小）。这是列表节点的描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="keyword">node_t</span>;</span><br></pre></td></tr></table></figure><p>现在，让我们看一些代码。该代码初始化堆并将空闲列表的第一个元素放入该空间。我们假设堆是在铜鼓调用系统调用<code>mmap()</code>获得的一些可用空间内构建的。这不是构建此类堆的唯一方法，但在此示例中对我们有好处，代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mmap() returns a pointer to a chunk of free space</span></span><br><span class="line"><span class="keyword">node_t</span> *head = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                    MAP_ANON|MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">head-&gt;size = <span class="number">4096</span> - <span class="keyword">sizeof</span>(<span class="keyword">node_t</span>);</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>运行此代码后，列表的状态是它只有一个条目，大小为4088。这是一个很小的堆，当为我们提供了一个很好的栗子。header 指针包含该范围的起始地址。假设它是16KB。因此，堆看起来如图17-3所示。</p><p><img src="/images/OSTEP/17-3.png" alt="17-3"></p><p>现在，让我们想象一下，请求了一块内存，大小为100Bytes。为了满足该请求，库将首先找到一个足够大的块以容纳该请求。因为只有一个空闲块(4088)，所以选择此块。然后，该块将分为两部分：一个足以满足请求的块，以及剩余的空闲块。假设header为8字节，则堆中的空间现在看起来如图17-4所示。</p><p><img src="/images/OSTEP/17-4.png" alt="17-4"></p><p>因此，在请求100字节时，库从现有的一个空闲块中分配了108个字节，并向其返回一个指针(ptr)，在分配的空间之前立即存储了header 信息，以便以后使用<code>free()</code>，并将列表中的一个空闲节点缩小到3980字节(<code>4088-108</code>)。</p><p>现在让我们看一下分配了三个区域，每个区域100字节（包括header是108）。此堆的可视化效果如图17-5所示：</p><p><img src="/images/OSTEP/17-5.png" alt="17-5"></p><p>如您所见，现在分配了堆的前324个字节，因此我们看到该空间中的三个header以及调用程序正在使用的三个100字节区域。空闲列表仍然没有意思：只有一个节点(指向header)，但是在三个分割之后，现在只有3764个字节。但是，当调用程序通过<code>free()</code>返回一些内存时会发生什么呢？</p><p>在此示例中，应用程序通过调用<code>free(16500)</code>返回分配的内存的中间块。该值在上图中由指针sptr显示。</p><p>该库立即计算空闲区域的大小，然后将空闲块添加回空闲列表中。假设我们在空闲列表的开头插入，现在该空间看起来像图17-6所示：</p><p><img src="/images/OSTEP/17-6.png" alt="17-6"></p><p>现在，我们有了一个列表，该列表以一个小的可用块(100字节，由列表的开头指向)和一个较大的空闲块(3764字节)开始。最后，我们的清单上有多个要素。是的，空闲空间是零散的，这是不幸的但却是很常见的情况。</p><p>最后一个栗子：现在假设释放了最后两个使用中的块。没有合并，最终会产生碎片，如图17-7。</p><p><img src="/images/OSTEP/17-7.png" alt="17-7"></p><p>从图中可以看出，我们现在一团糟。为什么？很简单，我们忘记了合并列表。尽管所有内存都是空闲的，但它被切成碎片，因此尽管不是一个内存，但仍显示为碎片内存。解决方案很简单：遍历列表并合并相邻的块。完成后，堆将再次完整。</p><p><br></p><p><strong>堆越来越大</strong><br>Growing The Heap</p><p>我们应该讨论在许多分配库找到的最后一种机制。具体来说，如果堆空间不足，该怎么办？最简单的方法就是失败(fail)。在某些情况下，这是唯一的选择，因此返回NULL是一种明智的方法。</p><p>大多数传统的分配器从小堆(small-sized)开始，然后在耗尽时从操作系统请求更多内存。通常，这意味着它们进行某种系统调用（如，在大多数UNIX系统中为sbrk）来增长堆，然后从那里分配新的块。</p><p>为了满足<code>sbrk</code>请求，操作系统找到了空闲的物理页面，将它们映射到请求进程的地址空间中，然后返回新堆结尾的值。此时，可以使用更大的堆，并且可以成功处理请求。</p><p><br><br><br></p><h3 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h3><p>Basic Strategies</p><p>让我们再来看一些管理空闲空间的基本策略。这些方法主要基于您可以考虑的非常简单的策略。在阅读之前尝试一下，看看是否有所有其它选择。</p><p>理想的分配器既快速有可以最大程度地减少碎片。不幸的是，由于分配和释放请求的流(stream)可以是任意的（毕竟，它们由程序员确定），因此，如果输入设置错误，任何特定的策略都可能表现不佳。因此，我们将不描述最佳方法，而实讨论一些基础知识并讨论其优缺点。</p><p><br></p><p><strong>最佳拟合(best fit)</strong></p><p>最佳拟合的策略非常简单：首先，搜索空闲列表，找到大于请求大小的空闲内存块。然后，返回该组候选人中最小的一个。这就是所谓的最适合的块（也称为最小拟合）。遍历空闲列表就足以找到要返回的正确的块。</p><p>最佳拟合的直觉很简单：通过返回与用户请求接近的块，，最适合将尝试减少浪费的空间。但是，这是有代价的。幼稚的实现在对正确的空闲块进行详尽搜索时会付出沉重的性能损失。</p><p><br></p><p><strong>最差拟合(worst fit)</strong></p><p>最差拟合方法与最佳拟合相反。找到最大的块并返回请求的数量，将其余块保留在空闲列表中。因此，最差的拟合尝试使大块空闲，而不是由最佳拟合方法产生很多小块空闲。但是，再次需要完全搜索空闲空间，因此这种方法可能会很昂贵。大多数研究表明它的性能很差，导致碎片过多，同时开销仍然很高。</p><p><br></p><p><strong>首先拟合(first fit)</strong></p><p>首先拟合方法只是找到足够大的第一个块，然后将请求的量返回给用户。和以前一样，剩余的空闲空间将保留供后续请求使用。首次拟合具有速度优势——无需详尽搜索所有空闲空间，但有时会用小对象污染空闲列表的开头。因此，分配器如何管理空闲列表的顺序(order)成为一个问题。一种方法是使用基于地址的排序。通过使列表按空闲空间的地址排序，合并变得更加容易，并且碎片减少了。</p><p><br></p><p><strong>下一个拟合(next fit)</strong></p><p>下一个拟合算法不会始终在列表的开头开始首次拟合搜索，而实保留了指向列表中最后看的为止的额外指针。这个想法是将对空闲空间的搜索更均匀地分布在整个列表中，从而避免分散列表的开头。这种方法的性能与首次拟合非常相似，因此再次避免了详尽的搜索。</p><p><br></p><p><strong>栗子</strong></p><p>下面是上述策略的一些栗子。设想一个空闲列表，上面有三个元素，大小分别为10、30、20（在此我们将忽略head和其它详细信息，而只关注策略的运行方式）：</p><p><img src="/images/OSTEP/freespace-7.png" alt></p><p>假设一个分配请求的大小为15。最佳拟合将搜索整个列表，并发现20是最适合的，因为它是可容纳请求的最小空闲空间。产生的空闲列表：</p><p><img src="/images/OSTEP/freespace-8.png" alt></p><p>正如本例中所发生的，并且通常是采用最佳拟合的方法发生的，现在剩下了一个小的空闲块。最差拟合找到了最大的块，此例中为30。产生的空闲列表：</p><p><img src="/images/OSTEP/freespace-9.png" alt></p><p>在此栗子中，最佳拟合和最差拟合执行相同的操作，还找到了可以满足请求的第一个空闲块。区别在于搜索成本。最佳拟合和最差拟合都在整个列表中浏览。首次拟合仅检查空闲块，直到找到合适的块，从而降低了搜索成本。</p><p>这些栗子只是分配策略的表面。为了更深入地了解，需要对实际工作负载和更复杂的分配器行为进行更详细的分析。</p><p><br><br><br></p><h3 id="其余方法"><a href="#其余方法" class="headerlink" title="其余方法"></a>其余方法</h3><p>Other Approaches</p><p>除了上述基本方法外，还有许多建议的技术和算法可以通过某种方式改善内存分配。我们在这里列出一些供您考虑。</p><p><br></p><p><strong>隔离列表(Segregated Lists)</strong></p><p>一段时间以来，一种有趣的方法是使用隔离列表。基本思想很简单：如果一个特定的应用程序发出一个（或几个）流行大小(popular-sized)的请求，则保留一个单独的列表以管理该大小的对象。所有其它请求都转发到更通用的内存分配器。</p><p>这种方法的好处是显而易见的。通过拥有一块专用于一个特定大小的请求的内存，碎片问题就不再那么重要了。此外，当分配和免费请求的大小合适时，它们可以很快得到服务，因为不需要复杂的列表搜索。</p><p>就像其它好主意一样，这种方法也将新的复杂性引入到系统中。例如，与通用池(general pool)相比，一个专用于给定大小的专用请求的内存池应占用多少内存？一个特殊的分配器——slab分配器，以一种相当不错的方式来处理此问题。</p><p>具体来说，当内核启动时，它将为可能经常被请求的内核对象（如，lock, file-system inode…）分配许多对象缓存。因此，每个对象高速缓存都是给定大小的空闲列表，它们分别为内存分配和空闲请求提供服务。当给定的高速缓存的空闲空间不足时，它会从更通用的内存分配器中请求一些内存块(slabs of memory)（请求的总量为页面大小和相关对象的倍数）。相反，当给定slab中对象的引用技术全部变为零时，通用分配器可以从专用分配器中回收它们，这通常在VM系统需要更多内存时执行。slab分配器还将通过将列表上的空闲对象保持在预先初始化的状态而超越了大多数隔离列表的方法。初始化和销毁数据结构的成本很高。通过将特定列表中的释放对象保持在其初始化状态，slab分配器避免了每个对象的频繁初始化和销毁周期，从而显着降低了开销。</p><p><br></p><blockquote><p>ASIDE: GREAT ENGINEERS ARE REALLY GREAT<br>Engineers like Jeff Bonwick (who not only wrote the slab allocator mentioned herein but also was the lead of an amazing file system, ZFS) are the heart of Silicon Valley. Behind almost any great product or technology is a human (or small group of humans) who are way above average in their talents, abilities, and dedication. As Mark Zuckerberg (of Facebook) says: “Someone who is exceptional in their role is not just a little better than someone who is pretty good. They are 100 times better.” This is why, still today, one or two people can start a company that changes the face of the world forever (think Google, Apple, or Facebook). Work hard and you might become such a “100x” person as well. Failing that, work with such a person; you’ll learn more in a day than most learn in a month. Failing that, feel sad.</p></blockquote><p><br></p><p><strong>Buddy Allocation</strong></p><p>因为合并对于分配器至关重要所以围绕简化合并设计了一些方法。在binary buddy allocator中找到了一个很好的栗子。在这样的系统中，首先从概念上将空闲内存视为大小为<code>2^N</code>的一个大空间。发出请求后，对可用空间的搜索将可用空间递归地除以2，直到找到一个足够大的块来容纳该请求。此时，所请求的块将返回给用户。这是一个在搜索7KB时划分64KB可用空间的栗子，如图17-8：</p><p><img src="/images/OSTEP/17-8.png" alt></p><p>在该示例中，分配了最左边的8KB块并返回给用户。请注意，此方案可能会遭受内部碎片的困扰，因为只允许您给出2的幂次方的块。buddy allocation的美妙之处在于释放该块时会发生什么。当将8KB块返回到空闲列表时，分配器检查buddy 8KB是否空闲。如果空闲，它将两个块合并为一个16KB的块。然后，分配器检查16KB的buddy是否仍然空闲。如果是，它将合并这两个块。该递归合并过程在树上继续进行，恢复了整个可用空间，或者发现buddy正在使用时停止。</p><p>buddy allocation之所以有效的原因是，确定特定块的buddy很简单。考虑上面的可用空间中块的地址。如果您仔细考虑，就会发现每个buddy pair的地址仅仅相差一位(a single bit)。因此，您对binary buddy allocation方案的工作原理有基本了解。</p><p><br></p><p><em>*其它想法</em>(Other Ideas)*</p><p>上述许多方法的一个主要原因是它们缺乏伸缩性(scaling)。具体来说，搜索列表可能会非常慢。因此，高级分配器使用更复杂的数据结构来解决这些成本，从而简化性能。栗子包括平衡二叉树(balanced binary trees)、八叉树(splay trees)、部分有序树(partially-ordered trees)。</p><p>鉴于现代系统通常具有多个处理器并运行多线程工作负载，因此，在基于多处理器的系统上，花费了大量的精力使分配器正常工作也就不足为奇了 。</p><p><br><br><br></p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>在本章中，我们讨论了最基本的内存分配形式。这样的分配器无处不在，它链接到您编写的每个C程序，也存在于底层操作系统中，该操作系统为自己的数据结构管理内存。与许多系统一样，在构建这样的系统时需要进行很多权衡，并且您对分配给分配器的确切工作量了解的越多，您就可以做的越多，就需要对其进行调整以使其更好地适应该工作量。在现代计算机系统中，制造一种快速、节省空间、可扩展的分配器，使其能够很好地适用于各种工作负载，仍然是一个持续的挑战。</p><p><br><br><br><br><br></p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>Paging</p><p>有时候，在解决大多数空间管理问题时，操作系统会采用两种方法之一。第一种方法是将事物切成大小可变(variable-sized)的段，如我们在虚拟内存中的分段所见。不幸的是，该解决方案具有固定的困难。特别是，将空间分成不同大小的块时，空间本身可能会变得碎片化，因此随着时间的推移分配会变得更具有挑战性。</p><p>因此，可能值得考虑第二种方法：将空间切成固定大小(fixed-sized)的片。在虚拟内存中，我们称这种想法为<strong>分页</strong>(paging)，它可以追溯到早期的重要系统Atlas。我们没有将进程的地址空间划分为一些可变大小的逻辑段（如，代码、堆、栈），而是将其划分为固定大小的单元，每个单元成为一个<strong>页面</strong>(page)。相应地，我们将物理内存视为固定大小的插槽数组，称为<strong>页帧</strong>(page frame)。这些帧中的每一个都可以包含一个虚拟内存页面(virtual memory page)。我们的挑战:</p><blockquote><p>HOW TO VIRTUALIZE MEMORY WITH PAGES<br>How can we virtualize memory with pages, so as to avoid the problems of segmentation? What are the basic techniques? How do we make those techniques work well, with minimal space and time overheads?</p></blockquote><p><br><br><br></p><h3 id="栗子和概述"><a href="#栗子和概述" class="headerlink" title="栗子和概述"></a>栗子和概述</h3><p>A Simple Example And Overview</p><p>为了使这种方法更清晰，让我们以一个简单的栗子进行说明。图18-2提供了一个很小的地址空间的栗子，该地址空间的总大小仅为64字节，具有四个16字节的页面（虚拟页面0、1、2、3）。当然，实际的地址空间要大得多，通常是32位(4GB)，甚至64位的地址空间。</p><p><img src="/images/OSTEP/18-1.png" alt="18-1"></p><p>如图18-2所示，物理内存由多个大小固定的插槽组成，在这种情况下位八个页面帧(page frame)（用于128字节的物理内存）。如图所示，虚拟地址空间的页面已放置在整个物理内存中的不同位置。该图还显示了操作系统本身使用了一些物理内存。</p><p><img src="/images/OSTEP/18-2.png" alt="18-2"></p><p>分页与以前的方法相比具有许多优点。可能最重要的改进是灵活性：通过完全开发的分页方法，该系统将能够有效地支持地址空间的抽象性，而与进程如何使用地址空间无关。</p><p>另一个优点是分页提供的空闲空间管理的简单性。例如，当操作系统希望将我们的64字节地址空间放入我们的八个页面物理内存时，它只会找到四个空闲页。也许操作系统为此保留了所有空闲页面的空闲列表，而只是从该列表中获取了前四个空闲页面。在此例中，操作系统将地址空间(AS)的虚拟页面0(page 0)放置在物理页帧3(page frame 3)中…页面帧4和6当前时空闲的。</p><p>为了记录地址空间的每个虚拟页在物理内存中的放置位置，操作系统通常保留每个进程的数据结构——称为<strong>分页表</strong>(page table)。分页表的主要作用是为地址空间的每个虚拟页面存储地址转换。对于我们的栗子，分页表将具有一下四个条目:</p><ul><li>virtual page 0 -&gt; physical frame 3</li><li>vp 1 -&gt; pf 7</li><li>vp 2 -&gt; pf 5</li><li>vp 3 -&gt; pf 2</li></ul><p>重要的是要记住，此分页表是按进程的数据结构。如果在上面的示例中要运行其它进程，则操作系统将不得不为其管理一个不同的分页表，因为其虚拟页面显然映射到了不同的物理页面。</p><p>让我们想象一下，地址空间很小(64Bytes)的进程正在执行内存访问：<code>movl &lt;virtual address&gt;, %eax</code></p><p>具体来说，我们要注意将地址 virtual address 中的数据显式加载到寄存器eax中。</p><p>为了转换该进程生成的虚拟地址，我们必须首先将其分为两个部分：</p><ul><li>virtual page number(VPN)</li><li>page offset</li></ul><p>对于此栗子，由于进程的虚拟地址空间为64字节，因此我们总共需要6位虚拟地址(<code>2^6=64</code>)。因此，可将我们的虚拟地址概念化：</p><p><img src="/images/OSTEP/paging-1.png" alt></p><p>在图中，Va5是虚拟地址的最高位，而Va0是虚拟地址的最低位。因为我们知道页面大小(16Bytes)，所以我们可以进一步划分地址。如下：</p><p><img src="/images/OSTEP/paging-2.png" alt></p><p>在64字节的地址空间中，页面大小为16字节。因此，我们需要能够选择4个页面，并且地址的高两位就可以做到这一点。因此，我们有一个两位虚拟页码(vpn)。其余的位告诉我们页面的字节，在这种情况下为4位。我们称其为偏移量(offset)。</p><p>当进程生成虚拟地址时，操作系统和硬件必须结合起来才能将其转换为有意义的物理地址。例如，让我们假设上面的负载是虚拟地址21：<code>movl 21, %eax</code></p><p>将21转换为二进制格式(<code>010101</code>)，因此我们可以检查该虚拟地址，并查看它如何分解为虚拟页码和偏移量：</p><p><img src="/images/OSTEP/paging-3.png" alt></p><p>因此，虚拟地址21在虚拟页面(01)的第五个字节上(0101)。使用虚拟页码，我们现在可以索引我们的分页表并找到虚拟页面1(vp 1)驻留在哪个物理帧页中。在上面的分页表中，物理帧码(physical frame number, PFN)，有时又称为物理页面号(physical page numer, PPN)是7(pf 7, 二进制111)。因此，我们可以通过PFN替换VPN来转换此虚拟地址，然后将负载发布到物理内存。如图18-3。</p><p><img src="/images/OSTEP/18-3.png" alt="18-3"></p><p>请注意，偏移量保持不变（即，不进行转换），因为偏移量仅告诉我们所需页面中的哪个字节。我们的最终物理地址为<code>1110101</code>（十进制117），正是我们希望从中获取数据的位置，如图18-2。</p><p>考虑到这一基本概述，我们现在可以问有关分页的一些基本问题。例如，这些分页表存储在哪里？分页表的典型内容是什么，有多大？分页会使系统变慢吗？</p><p><br><br><br></p><h3 id="分页表存储在哪里"><a href="#分页表存储在哪里" class="headerlink" title="分页表存储在哪里"></a>分页表存储在哪里</h3><p>Where Are Page Tables Stored?</p><p>分页表(page table)会变得非常大，比我们之前讨论的小段(small segment)或base/bound pair要大得多。例如，设想一个典型的32位地址空间，4KB pages。该虚拟地址分为20位VPN和12位偏移量。</p><p>20位VPN表示操作系统必须为每个进程管理<code>2^20</code>个转换，假设每个分页表条目(page table entry)需要4字节来保存物理转换以及其它任何有用的东西，我们将为每个分页表获得4MB的巨大内存。那是很大的，现在想象有100个进程正在运行：这意味这操作系统仅需要所有这些地址转换就需要400MB内存！即使在机器拥有GB内存的现代时代，将很大一部分内存用于翻译也似乎有些疯狂，不是吗？而且，我们甚至都不会考虑这样的分页表对于64位地址空间会有多大。那太可怕了，也许会把你吓跑。</p><p>由于分页表非常大，因此我们不在MMU中保留任何特殊的片上硬件来存储当前正在运行的进程的分页表。相反，我们将每个进程的分页表存储在内存中的某个位置。现在假设分页表位于操作系统管理的物理内存中。稍后我们将看到许多操作系统内存本身可以被虚拟化，因此分页表可以存储在操作系统虚拟内存中（甚至交换到磁盘上），但是现在这太令人困惑了，因此我们将其忽略。图18-4中显示了操作系统内存中的分页表，在那看到很小的转换集。</p><p><img src="/images/OSTEP/18-4.png" alt="18-4"></p><p><br></p><blockquote><p>ASIDE: DATA STRUCTURE — THE PAGE TABLE<br>One of the most important data structures in the memory management subsystem of a modern OS is the page table. In general, a page table stores virtual-to-physical address translations, thus letting the system know where each page of an address space actually resides in physical memory. Because each address space requires such translations, in general there is one page table per process in the system. The exact structure of the page table is either determined by the hardware (older systems) or can be more flexibly managed by the OS (modern systems).</p></blockquote><p><br><br><br></p><h3 id="分页表中实际上是什么？"><a href="#分页表中实际上是什么？" class="headerlink" title="分页表中实际上是什么？"></a>分页表中实际上是什么？</h3><p>What’s Actually In The Page Table?</p><p>让我们谈谈分页表的组织方式。分页表只是一个数据结构，用于将虚拟地址(virtual page number)映射到物理地址(physical frame number)。因此，任何数据结构都可以工作。最简单的形式称为线性分页表(linear page table)，它只是一个数组。操作系统通过虚拟页码(vpn)位阵列建立索引(index)，并在该索引处查找分页表条目(pte)，以查找所需的物理帧号(pfn)。现在，我们将假定这种简单的线性结构。在后面的章节中，我们将使用更高级的数据结构来帮助解决分页中的某些问题。</p><p>至于每个pte的内容，我们在中有许多不同的地方值得一定程度的理解。<strong>有效位</strong>(valid bit)是通用的，用于指示特定转换是否有效。例如，当程序开始运行时，它将在其地址空间的一端具有代码和堆，而在另一端则具有栈。两者之间所有未使用的空间将被标记为无效(invalid)，并且如果该进程尝试访问此类内存，它将生成操作系统陷阱(trap)，这很可能会终止该进程。因此，有效位对于支持稀疏地址空间至关重要。通过简单地将地址空间中所有未使用的页面标记为无效，我们无需为这些页面分配物理帧，从而节省了大量内存。</p><p>我们还可能有<strong>保护位</strong>(protection bits)，指示是否可以读取、写入或执行页面。同样，以这些位不允许的方式访问页面将产生对操作系统的陷阱。</p><p>还有其它一些重要的方面，但我们暂时不会多谈。<strong>当前位</strong>(present bit)指示页面是在物理内存中还是在磁盘上(swapped out)。当我们研究如何将部分地址空间交换(swap)到磁盘以支持大于物理内存的地址空间时，我们将进一步理解这种机制。交换(swapping)使操作系统可以通过将很少使用的页面移动到磁盘来释放物理内存。<strong>脏位</strong>(dirty bit)也很常见，指示该页从进入内存以来是否已被修改。</p><p><strong>引用位</strong>(reference bit, accessed bit)来跟踪页面是否已被访问，并且对于确定哪些页面受欢迎并因此应将其保留在内存中很有用。此类知识在页面替换期间至关重要，我们将在随后的章节中详细研究该主题。</p><p>图18-5显示了x86体系结构中的示例分页表条目(pte)。它包含：</p><ul><li>present bit(P)；</li><li>read/write bit(R/W)，是否允许对该页面进行写操作；</li><li>user/supervisor bit(U/S)，用于确定用户模式进程是否可以访问该页面；</li><li>一些位(PWT, PCD, PAT, G)确确定这些页面的硬件缓存工作方式；</li><li>accessed bit(A)；</li><li>dirty bit(D)；</li><li>page frame number(PFN)；</li></ul><p><img src="/images/OSTEP/18-5.png" alt="18-5"></p><p><br></p><blockquote><p>ASIDE: WHY NO VALID BIT?<br>You may notice that in the Intel example, there are no separate valid and present bits, but rather just a present bit (P). If that bit is set (P=1), it means the page is both present and valid. If not (P=0), it means that the page may not be present in memory (but is valid), or may not be valid. An access to a page with P=0 will trigger a trap to the OS; the OS must then use additional structures it keeps to determine whether the page is valid (and thus perhaps should be swapped back in) or not (and thus the program is attempting to access memory illegally). This sort of judiciousness is common in hardware, which often just provide the minimal set of features upon which the OS can build a full service.</p></blockquote><p><br><br><br></p><h3 id="分页-也很慢"><a href="#分页-也很慢" class="headerlink" title="分页: 也很慢"></a>分页: 也很慢</h3><p>Paging: Also Too Slow</p><p>内存中的分页表，我们已经知道它们可能太大。事实证明，它们也可以放慢脚步。例如，采用简单的指令：<code>movl 21, %eax</code></p><p>同样，让我们仅检查对地址21的显式引用，而不用担心指令提取(fetch)。此例中，我们假设硬件为我们执行转换。为了获取所需数据，系统必须首先将虚拟地址(21)转换为正确的物理地址(117)。因此，在从地址117提取数据之前，系统必须首先从进程的分页表中提取适当的页表项(page table entry)，执行转换，然后从物理内存中加载数据。</p><p>为此，硬件必须知道当前正在运行的进程的分页表所在的位置。现在让我们假设一个page table base register包含分页表起始位置的物理地址。为了找到所需PTE的位置，硬件将执行以下功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line">PTEAddr = PageTableBaseRegister + (VPN * <span class="keyword">sizeof</span>(PTE))</span><br></pre></td></tr></table></figure><p>在我们的栗子中，VPN_MASK将设置为<code>0x30</code>，这将从完整的虚拟地址中提取VPN位。SHIFT设置为4（偏移量中的位数），以便我们将VPN位向下移动以形成正确的整数虚拟页码。例如，使用虚拟地址21(010101)，并通过mask将其值转换为010000；转换后可根据需要将其转换为01或virtual page 1。然后，我们将此值用作page table base register指向的分页表条目(pte)数组的索引。</p><p>一旦知道了该物理地址，硬件就可以从内存中获取PTE，提取PFN，并将其与虚拟地址的偏移量连接起来以形成所需要的物理地址。具体来说，您可以考虑将PFN通过SHIFT左移，然后将其与偏移量按位或操作(OR)，以形成最终地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">PhysAddr = (PFN &lt;&lt; SHIFT) | offset</span><br></pre></td></tr></table></figure><p>最后，硬件可以从内存中获取所需的数据，并将其放入寄存器eax中。该程序现在以成功从内存中加载值！</p><p>总而言之，我们现在描述每个内存引用上发生的事情的初始协议。对于每个内存引用（无论是获取指令还是显式加载或存储），分页都要求我们执行一个额外的内存引用，以便首先从分页表中获取转换。那是很多工作！额外的内存引用成本很高，在这种情况下，可能会使处理速度减慢两倍或更多。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accessing Memory With Paging</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extract the VPN from the virtual address</span></span><br><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line"></span><br><span class="line"><span class="comment">// Form the address of the page-table entry (PTE)</span></span><br><span class="line">PTEAddr = PTBR + (VPN * <span class="keyword">sizeof</span>(PTE))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the PTE</span></span><br><span class="line">PTE = AccessMemory(PTEAddr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if process can access the page</span></span><br><span class="line"><span class="keyword">if</span> (PTE.Valid == False)</span><br><span class="line">    RaiseException(SEGMENTATION_FAULT)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False)</span><br><span class="line">    RaiseException(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// Access is OK: form physical address and fetch it</span></span><br><span class="line">    offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">    PhysAddr = (PTE.PFN &lt;&lt; PFN_SHIFT) | offset</span><br><span class="line">    Register = AccessMemory(PhysAddr)</span><br></pre></td></tr></table></figure><p>现在您可以看到有两个必须解决的实际问题。没有对硬件和软件进行仔细设计，分页表将导致系统运行太慢，并占用太多内存。虽然这似乎是满足我们的内存虚拟化需求的绝佳解决方案，但必须首先克服这两个关键问题。</p><p><br><br><br></p><h3 id="内存追踪"><a href="#内存追踪" class="headerlink" title="内存追踪"></a>内存追踪</h3><p>A Memory Trace</p><p>在结束之前，我们现在追踪(trace)一个简单的内存访问示例，以演示使用分页时内存访问发生的所有的结果。示例代码片段(<code>array.c</code>文件)如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">1000</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    <span class="built_in">array</span>[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&gt; 编译</span></span><br><span class="line"><span class="comment">// gcc -o array array.c -Wall -O</span></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line"><span class="comment">// ./array</span></span><br></pre></td></tr></table></figure><p>当然，要真正访问此代码段（只需初始化一个数组）的内存，我们就必须知道几件事。首先，我们必须对生成的二进制文件进行反汇编(disassemble)（在Linux上使用<code>objdump</code>，Mac上使用<code>otool</code>），以查看使用哪些汇编指令在循环中初始化数组。如下是生成的汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1024 movl $0x0,(%edi,%eax,4)</span><br><span class="line">1028 incl %eax</span><br><span class="line">1032 cmpl $0x03e8,%eax</span><br><span class="line">1036 jne 0x1024</span><br></pre></td></tr></table></figure><p>如果了解一些x86的知识，则实际上很容易理解此代码。第一条指令将值0移至数组位置的虚拟内存地址。该地址通过将<code>%edi</code>的内容加上<code>%eax</code>乘4得出。因此，<code>%edi</code>保存数据的基地址，而<code>%eax</code>保存数组index(i)。将其乘4，因为该数组是一个整数数组，每个数组的大小为四字节。</p><p>第二条指令递增<code>%eax</code>中保存的数组索引。第三条指令将寄存器的内容与十六进制值<code>0x03e8</code>，或十进制1000进行比较。如果比较显示两个值还不相等(jne指令测试)，则第四条指令跳回循环的顶部。</p><p>为了了解该指令序列访问哪个内存（虚拟和物理级别上），我们必须假设一些有关代码片段和数组在虚拟内存中的位置以及分页表的内容和位置的信息。</p><p>对于此示例，我们假定虚拟地址空间的大小为64KB，我们还假定页面大小为1KB。现在我们只需要知道分页表的内容及其在物理内存中的位置。假设我们有一个基于数组的线性分页表，它位于物理地址1KB。至于它的内容，我们需要担心的几个虚拟页面，已经为此栗子映射了。首先，代码所在的虚拟页面。因为页面大小为1KB，所以虚拟地址1024位于虚拟地址空间的第二个页面上。假设此虚拟页面映射到物理帧4（vpn 1 -&gt; pfn 4)。</p><p>接下来，是数组本身。它的大小为4000字节(1000个整数)，我们假定它位于40000到44000的虚拟地址。此范围的虚拟页面为vpn=39…42。因此，我们需要这些页面的映射。如：</p><ul><li>vpn 39 -&gt; pfn 7</li><li>vpn 40 -&gt; pfn 8</li><li>vpn 41 -&gt; pfn 9</li><li>vpn 42 -&gt; pfn 10</li></ul><p>现在，我们准备追踪程序的内存引用。在运行时，每条fetch指令将生成两个内存引用：一个指向分页表以查找指令所在的物理帧，另一个指向指令本身以将其提取给CPU以进行处理。另外，有一个以<code>mov</code>执行形式的显式内存引用。这将首先添加另一个分页表访问，然后添加阵列本身。</p><p>图18-7描述了前五个循环迭代的整个过程。</p><p><img src="/images/OSTEP/18-7.png" alt="18-7"></p><p><br><br><br></p><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>Summary</p><p>我们介绍了分页(paging)的概念，以解决我们虚拟化内存的挑战。与以前的方法（如，分段）相比，分页具有许多优点。首先，它不会导致外部碎片，因为分页将内存划分为固定大小的单元。其次，它非常灵活，可以稀疏地使用虚拟地址空间。</p><p>但是，不加注意地实现分页支持将导致机器速度变慢（具有许多额外的内存访问权限来访问分页表），以及内存浪费（内存被分页表填充，而不是有用的应用程序数据）。因此，我们将不得不更加努力地想出一种不仅可以工作而且很好运行的分页系统。幸运的是，接下来的两章将向我们展示如何做到这一点。</p><p><br><br><br><br><br></p><h2 id="地址转换缓存"><a href="#地址转换缓存" class="headerlink" title="地址转换缓存"></a>地址转换缓存</h2><p>Paging: Faster Translations (TLBs)</p><p>Translation Lookaside Buffer</p><p>使用分页作为支持虚拟内存的核心机制可能会导致高性能开销。通过将地址空间切成固定大小的小单元(即，页面)，分页需要打两个的映射信息。因为映射信息通常存储在物理内存中，所以分页逻辑上需要对程序生成的每个虚拟地址进行额外的内存查找。在每条fetch指令或显示加载或存储之前进入内存获取转换信息的速度过慢。因此，我们的问题是：</p><blockquote><p>HOW TO SPEED UP ADDRESS TRANSLATION<br>How can we speed up address translation, and generally avoid the extra memory reference that paging seems to require? What hardware support is required? What OS involvement is needed?</p></blockquote><p>当我们想要加快速度时，操作系统通常需要一些帮助。而且帮助通常来自操作系统的老朋友：硬件。为了加快地址转换的速度，我们将添加所谓的<strong>转换后备缓冲器</strong>(translation lookaside buffer, TLB)。TLB是内存管理单元(MMU)的一部分，并且只是流行的虚拟到物理地址转换的一个硬件缓存。因此，更好的名称是<strong>地址转换缓存</strong>(address translation cache)。在引用每个虚拟内存时，硬件首先检查TLB。如果是，执行转换(快速地)而无需查阅分页表。由于它们对性能的巨大影响，真正意义上的TLB使虚拟内存成为可能。</p><p><br><br><br></p><h3 id="TLB基本算法"><a href="#TLB基本算法" class="headerlink" title="TLB基本算法"></a>TLB基本算法</h3><p>TLB Basic Algorithm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// TLB Control Flow Algorithm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line"> (Success, TlbEntry) = TLB_Lookup(VPN)</span><br><span class="line"> if (Success == True) // TLB Hit</span><br><span class="line">      if (CanAccess(TlbEntry.ProtectBits) == True)</span><br><span class="line">          Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">          PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset</span><br><span class="line">          Register = AccessMemory(PhysAddr)</span><br><span class="line">      else</span><br><span class="line">          RaiseException(PROTECTION_FAULT)</span><br><span class="line"> else // TLB Miss</span><br><span class="line">     PTEAddr = PTBR + (VPN * sizeof(PTE))</span><br><span class="line">     PTE = AccessMemory(PTEAddr)</span><br><span class="line">     if (PTE.Valid == False)</span><br><span class="line">         RaiseException(SEGMENTATION_FAULT)</span><br><span class="line">     else if (CanAccess(PTE.ProtectBits) == False)</span><br><span class="line">         RaiseException(PROTECTION_FAULT)</span><br><span class="line">     else</span><br><span class="line">         TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)</span><br><span class="line">         RetryInstruction()</span><br></pre></td></tr></table></figure><p>以上给出了硬件如何处理虚拟地址转换的示意图，假设有一个简单的线性分页表和由硬件管理的TLB（即，硬件承担了分页表访问的大部分责任）。硬件遵循的算法是这样的：首先，从虚拟地址中提取虚拟页码(vpn)，然后检查TLB是否有该vpn的转换。如果是，我们将获得一个TLB命中，这意味着TLB将保留转换。成功！现在，我们可以从相关的TLB条目中提取页帧号(pfn)，并将其连接到与原始虚拟地址的偏移量上，并形成所需的物理地址(pa)和访问内存，假设保护检查不会失败。</p><p>如果CPU在TLB中找不到转换(TLB miss)，我们还有更多工作要做。在此栗子中，硬件访问分页表以查找转换，并且假设该进程生成的虚拟内存引用是有效且可访问的，则使用此转换来更新TLB。这些操作的成本很高，主要是因为访问分页表需要额外的内存引用。最后，一旦更新了TLB，硬件将重新尝试该指令。这次，可在TLB中找到转换，并且可以快速地处理内存引用。</p><p>像所有高速缓存一样，TLB的构建前提是在通常情况下，在高速缓存中找到转换（即，命中(hit)）。如果是这样，则几乎不会增加任何开销，因为TLB位于处理核心附近，并且设计得非常快。发生未命中(miss)时，会产生很高的分页成本。必须访问分页表以查找转换，并获得额外的内存引用（更复杂的分页表则需要更多的内存引用）。如果这种情况经常发生，则程序运行速度可能会明显变慢。相对于大多数CPU指令，内存访问成本很高，而且TLB丢失会导致更多的内存访问。因此，我们希望尽可能避免TLB未命中。</p><p><br><br><br></p><h3 id="访问数组的栗子"><a href="#访问数组的栗子" class="headerlink" title="访问数组的栗子"></a>访问数组的栗子</h3><p>Example: Accessing An Array</p><p>为了清楚说明TLB的操作，让我们检查一个简单的虚拟地址追踪，看看TLB如何改善其性能。在此例中，假设内存中有一个10个4字节整数的数组，从虚拟地址100开始。进一步假设我们有一个小的16位页面和8位虚拟地址空间。因此，虚拟地址分为4位vpn(16 virtual pages)和4位偏移量。</p><p>图19-2显示了排列在系统的16个16字节页面上的数组。如您所见，数组的第一个条目<code>a[0]</code>开始于(vpn=06, offset=04)。该页面上只能容纳三个4字节整数。数组继续到下一页(vpn=07)，在此找到下四个条目(<code>a[3]..a[6]</code>)。下面也是如此。</p><p><img src="/images/OSTEP/19-2.png" alt="19-2"></p><p>现在，让我们考虑一个访问每个数组元素的简单循环，在C中看起来如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    sum += a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&gt;</span></span><br></pre></td></tr></table></figure><p>为了简单起见，我们将假装循环生成的唯一内存访问是对数组的访问。当访问第一个数组元素(<code>a[0]</code>)时，CPU将看到虚拟地址100的负载。硬件从中提取vpn，并使用该地址检查TLB的有效转换。假设这是程序第一次访问数组，结果将是TLB丢失(miss)。</p><p>下一步访问(<code>a[1]</code>)，这里有一些好消息：TLB命中！由于数组的第二个元素紧挨着第一个元素，因此它位于同一个页上。因为我们在访问数组的第一个元素时已经刚问了此页面，所以转换已经加载到了TLB中。这是我们成功的原因。访问(<code>a[2]</code>)会遇到类似的成功，因为它与(<code>a[0]</code>)和(<code>a[1]</code>)位于同一页面上。</p><p>不幸的是，当程序访问(<code>a[3]</code>)时，我们遇到了另一个TLB丢失。但是，下一个条目(<code>a[4]..a[6]</code>)将再次位于TLB中，因为它们都位于内存中的同一个页上。</p><p>最后，访问(<code>a[7]</code>)会导致最后一个TLB丢失。硬件再次查询分页表以找出该虚拟分页在物理内存中的位置，并相应地更新TLB。最后两个访问(<code>a[8]</code>, <code>a[9]</code>)将获得此TLB更新的好处。当硬件在TLB中查找其转换时，又产生了两次命中。</p><p>让我们总结一下对数组的十次访问期间的TLB活动：miss, hit, hit, miss, hit, hit, hit, miss, hit, hit。因此，我们的TLB命中率为70%（实际上，我们希望命中率接近百分百）。即使这是程序第一次访问数组，TLB仍会由于空间位置而提高性能。数组的元素紧密地包装在页面中（即，它们在空间上彼此靠近），因此只有第一次访问页面上的元素才会产生TLB丢失。</p><p>还要注意在此栗子中页面大小的作用。如果页面大小是原来的两倍，则数组访问将遭受更小的丢失。由于典型的页面大小更像是4KB，因此这些类型的密集，基于数组的访问可实现出色的TLB性能，每页访问仅遇到一次丢失。</p><p>关于TLB性能的最后一点：如果程序在此循环完成后不久再次访问了数组，则假设我们有足够大的TLB来缓存所需的转换，那么我们可能会看到更好的结果: hit, hit, hit, hit, hit, hit, hit, hit, hit, hit。在这种情况下，由于时间上的局限性，即时间上的内存项快速重新引用，TLB命中率很高。像任何高速缓存(cache)一样，TLB依赖于空间和时间的局部性来获得成功，这是程序属性。如果感兴趣的程序表现出这种局限性，则TLB的命中率可能会很高。</p><p><br></p><blockquote><p>TIP: USE CACHING WHEN POSSIBLE<br>Caching is one of the most fundamental performance techniques in computer systems, one that is used again and again to make the “commoncase fast” [HP06]. The idea behind hardware caches is to take advantage of locality in instruction and data references. There are usually two types of locality: temporal locality and spatial locality. With temporal locality, the idea is that an instruction or data item that has been recently accessed will likely be re-accessed soon in the future. Think of loop variables or instructions in a loop; they are accessed repeatedly over time. With spatial locality, the idea is that if a program accesses memory at address x, it will likely soon access memory near x. Imagine here streaming through an array of some kind, accessing one element and then the next. Of course, these properties depend on the exact nature of the program, and thus are not hard-and-fast laws but more like rules of thumb. Hardware caches, whether for instructions, data, or address translations (as in our TLB) take advantage of locality by keeping copies of memory in small, fast on-chip memory. Instead of having to go to a (slow) memory to satisfy a request, the processor can first check if a nearby copy exists in a cache; if it does, the processor can access it quickly (i.e., in a few CPU cycles) and avoid spending the costly time it takes to access memory (many nanoseconds).<br>You might be wondering: if caches (like the TLB) are so great, why don’t we just make bigger caches and keep all of our data in them? Unfortunately, this is where we run into more fundamental laws like those of physics. If you want a fast cache, it has to be small, as issues like the speed-of-light and other physical constraints become relevant. Any large cache by definition is slow, and thus defeats the purpose. Thus, we are stuck with small, fast caches; the question that remains is how to best use them to improve performance.</p></blockquote><p><br><br><br></p><h3 id="谁处理TLB缺失"><a href="#谁处理TLB缺失" class="headerlink" title="谁处理TLB缺失"></a>谁处理TLB缺失</h3><p>Who Handles The TLB Miss?</p><p>我们必须回答一个问题：谁处理TLB缺失？可能有两个答案：硬件或软件。</p><p>在过去，硬件具有复杂的指令集(complex instruction sets)（对于复杂指令集计算机，称为CISC），而构建硬件的人并不十分信任那些狡猾的操作系统用户。因此，硬件将完全处理TLB丢失。为此，硬件必须准确地知道分页表在内存中的位置（使用 page table base register），以及它们的确切格式。如果丢失，则硬件将遍历(walk)分页表，找到正确的分页表条目并提取所需的转换并更新TLB，然后重试指令。硬件管理的TLB的旧架构的一个示例是Intel x86架构，该架构使用固定的多级页表。</p><p>更加现代的架构（如，精简指令集计算机(reduced instruction set computers, RISC)）都具有所谓的软件管理的TLB。在发生TLB丢失时，硬件仅引发异常（如下代码），该异常将暂停当前指令流(instruction stream)，将权限级别提升至内核模式，然后跳转至陷阱处理程序(trap handler)。您可能会猜测，此陷阱处理程序是操作系统中的代码，其明确目的是处理TLB丢失。当它运行时，代码将在分页表中查找转换，使用特殊的特权指令(privileged instruction)更新TLB，然后从陷阱返回。此时，硬件重试指令（TLB将命中）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// TLB Control Flow Algorithm (OS Handled)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line">  (Success, TlbEntry) = TLB_Lookup(VPN)</span><br><span class="line">  if (Success == True) // TLB Hit</span><br><span class="line">      if (CanAccess(TlbEntry.ProtectBits) == True)</span><br><span class="line">          Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">          PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset</span><br><span class="line">          Register = AccessMemory(PhysAddr)</span><br><span class="line">      else</span><br><span class="line">         RaiseException(PROTECTION_FAULT)</span><br><span class="line">  else // TLB Miss</span><br><span class="line">      RaiseException(TLB_MISS) //上面的引发异常</span><br></pre></td></tr></table></figure><p>让我们讨论几个重要的细节。首先，从陷阱返回(return-from-trap)指令与我们在为系统调用提供服务之前所看到的从陷阱返回指令稍有不同。在后一种情况下，从陷阱返回应在陷阱进入操作系统之后的指令处恢复执行，就像从过程调用返回到调用该过程之后的指令一样。在前一种情况下，当从TLB丢失处理陷阱返回时，硬件必须在引起陷阱的指令处继续执行。否则，硬件将继续执行该指令。因此，此重试将使指令再次运行，这一次导致TLB命中。因此，根据导致陷阱或异常的方式，硬件必须在捕获到操作系统中时保存不同的PC，以便在需要时才能正确恢复。</p><p>其次，在运行TLB缺失处理代码时，操作系统需要格外小心，以免发生无限数量的TLB丢失链。存在许多解决方案。例如，您可以将TLB缺失处理程序保留在物理内存中（在这些内存中并未映射它们，并且不进行地址转换），或者在TLB中保留一些条目以进行永久有效的转换，并将在某些永久转换插槽用于处理程序代码本身。these wired translations always hit in the TLB.</p><p>软件管理方法的主要有点是灵活性：操作系统可以使用它实现想要实现分页表的任何数据结构，而无需更改硬件。从TLB控制流程中可以看出，另一个优点是简单。硬件在缺失方面没有做太多事情：仅引发异常，然后让操作系统TLB缺失处理程序完成其余工作。</p><p><br></p><blockquote><p>ASIDE: RISC VS. CISC<br>In the 1980’s, a great battle took place in the computer architecture community. On one side was the CISC camp, which stood for Complex Instruction Set Computing; on the other side was RISC, for Reduced Instruction Set Computing [PS81]. The RISC side was spear-headed by David Patterson at Berkeley and John Hennessy at Stanford (who are also co-authors of some famous books [HP06]), although later John Cocke was recognized with a Turing award for his earliest work on RISC [CM00]. CISC instruction sets tend to have a lot of instructions in them, and each instruction is relatively powerful. For example, you might see a string copy, which takes two pointers and a length and copies bytes from source to destination. The idea behind CISC was that instructions should be high-level primitives, to make the assembly language itself easier to use, and to make code more compact.<br>RISC instruction sets are exactly the opposite. A key observation behind RISC is that instruction sets are really compiler targets, and all compilers really want are a few simple primitives that they can use to generate high-performance code. Thus, RISC proponents argued, let’s rip out as much from the hardware as possible (especially the microcode), and make what’s left simple, uniform, and fast.<br>In the early days, RISC chips made a huge impact, as they were noticeably faster [BC91]; many papers were written; a few companies were formed (e.g., MIPS and Sun). However, as time progressed, CISC manufacturers such as Intel incorporated many RISC techniques into the core of their processors, for example by adding early pipeline stages that transformed complex instructions into micro-instructions which could then be processed in a RISC-like manner. These innovations, plus a growing number of transistors on each chip, allowed CISC to remain competitive. The end result is that the debate died down, and today both types of processors can be made to run fast.</p></blockquote><p><br></p><blockquote><p>ASIDE: TLB VALID BIT 6= PAGE TABLE VALID BIT<br>A common mistake is to confuse the valid bits found in a TLB with those found in a page table. In a page table, when a page-table entry (PTE) is marked invalid, it means that the page has not been allocated by the process, and should not be accessed by a correctly-working program. The usual response when an invalid page is accessed is to trap to the OS, which will respond by killing the process.<br>A TLB valid bit, in contrast, simply refers to whether a TLB entry has a valid translation within it. When a system boots, for example, a common initial state for each TLB entry is to be set to invalid, because no address translations are yet cached there. Once virtual memory is enabled, and once programs start running and accessing their virtual address spaces, the TLB is slowly populated, and thus valid entries soon fill the TLB.<br>The TLB valid bit is quite useful when performing a context switch too, as we’ll discuss further below. By setting all TLB entries to invalid, the system can ensure that the about-to-be-run process does not accidentally use a virtual-to-physical translation from a previous process.&gt;</p></blockquote><p><br><br><br></p><h3 id="TLB内容是什么"><a href="#TLB内容是什么" class="headerlink" title="TLB内容是什么"></a>TLB内容是什么</h3><p>TLB Contents: What’s In There?</p><p>让我们更详细地了解硬件TLB的内容。一个典型的TLB可能有32、64或128个条目，这就是所谓的完全关联(a fully-associative)。基本上，这仅意味着任何给定的转换都可以在TLB中的任何位置，并且硬件将并行搜索整个TLB以找到所需的转换。一个TLB条目像这样：<code>VPN | PFN | other bits</code>。</p><p>请注意，VPN和PFN都存在于每个条目中，因为转换可能会发生在这些位置中的任何一个位置结束（就硬件而言，TLB被称为完全关联缓存）。硬件会并行搜索条目，以查看是否存在匹配项。</p><p>更有趣的是<code>other bits</code>。例如，TLB通常具有有效位，该位表明条目是否具有有效的转换。保护位也很常见，它们确定如何访问页面。例如，代码页可能被标记为read和execute，而堆页面可能被标记为read和write。可能还有一些其它字段，包括地址空间标识符、脏位…</p><p><br><br><br></p><h3 id="TLB问题：上下文切换"><a href="#TLB问题：上下文切换" class="headerlink" title="TLB问题：上下文切换"></a>TLB问题：上下文切换</h3><p>TLB Issue: Context Switches</p><p>使用TLB，在进程（以及地址空间）之间切换时会出现一些问题。具体来说，TLB包含从虚拟到物理的转换，这些转换仅对当前正在运行的进程有效，对其它进程没有意义。因此，从一个进程切换到另一个进程时，硬件或操作系统必须小心，以确保即将运行的进程不会意外地使用某些先前运行的进程的转换。</p><p>为了更好地了解这种情况，我们来看一个栗子。当一个进程(p1)正在运行时，它假定TLB可能正在缓存对其有效的转换，即来自p1的分页表的转换。对于此栗子，假定p1的第十个虚拟页面被映射到物理帧100。在此例中，假定存在领域给进程(p2)，并且操作系统很快可能会决定执行上下文切换并运行它。这里假设p2的第十个虚拟页面被映射到物理帧170。如果这两个进程的条目都在TLB中，则TLB的内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vpn | pfn | valid | prot</span><br><span class="line">10  | 100 |  1    | rwx</span><br><span class="line">-   |  -  |  0    |  -</span><br><span class="line">10  | 170 |  0    | rwx</span><br><span class="line">-   |  -  |  0    |  -</span><br></pre></td></tr></table></figure><p>在上面的TLB中，我们显然有一个问题：vpn(10) 转换为 pfn(100)(p1) 或 pfn(170)(p2)？但是硬件无法区分哪个条目代表哪个进程。因此，我们需要做更多的工作，以便TLB正确有效地支持跨多个进程的虚拟化。因此，症结如下：</p><blockquote><p>HOW TO MANAGE TLB CONTENTS ON A CONTEXT SWITCH<br>When context-switching between processes, the translations in the TLB for the last process are not meaningful to the about-to-be-run process. What should the hardware or OS do in order to solve this problem?</p></blockquote><p>有许多解决此问题的方法。一种方法是简单地<strong>刷新</strong>(flush)上下文切换上的TLB，从而在运行下一个进程之前将其清空。在基于软件的系统上，这可以通过明确的硬件指令来完成。如果使用硬件管理的TLB，则可以在更改page table base register时执行刷新操作。无论哪种情况，刷新操作都将所有有效位简单地设置为0，这实质上清除了TLB的内容。</p><p>通过刷新每个上下文切换上的TLB，我们现在有了一个可行的解决方案。因为一个进程将永远不会偶然在TLB中遇到错误的转换。但是，这是有代价的：每次运行进程时，它在接触其数据和代码页时都会导致TLB缺失。如果操作系统频繁在进程之间切换，则此成本可能很高。</p><p>为了减少这种开销，某些系统添加了硬件支持，以实现在上下文切换之间共享TLB。特别地，某些硬件系统在TLB中提供了<strong>地址空间标识符</strong>(address space identifier, ASID)字段。您可以将ASID视为与PID类似，只不过它的位数更少。</p><p>如果我们从上面的示例TLB并添加ASID，很明显，进程可以轻松共享TLB：仅需要ASID字段即可区分其它相同的转换。这是带有添加的ASID字段的TLB的描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vpn | pfn | valid | prot | ASID</span><br><span class="line">10  | 100 |  1    | rwx  | 1</span><br><span class="line">-   |  -  |  0    | -    | -</span><br><span class="line">10  | 170 |  1    | rwx  | 2</span><br><span class="line">-   |  -  |  0    | -    | -</span><br></pre></td></tr></table></figure><p>因此，借助地址空间标识符，TLB可以同时保存来自不同进程的转换，而不会造成任何混淆。当然，硬件还需要知道当前正在运行哪个进程才能执行转换，因此操作系统必须在上下文切换时将一些特权寄存器(privileged register)设置为当前进程的ASID。</p><p>顺便说一句，您可能还想到了另一种情况。其中TLB的两个条目非常相似。在此示例中，两个不同进程的两个条目具有两个指向相同物理页面的不同VPN：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vpn | pfn | valid | prot | ASID</span><br><span class="line">10  | 101 |  1    | r-x  | 1</span><br><span class="line">-   | -   |  0    | -    | -</span><br><span class="line">50  | 101 |  1    | r-x  | 2</span><br><span class="line">-   | -   |  0    | -    | -</span><br></pre></td></tr></table></figure><p>例如，当两个进程共享一个页面时，可能会出现这种情况。在上面的栗子中，p1与p2共享物理页面101。p1将该页面映射到其地址空间的第10页，而p2将该页面映射到其地址空间的第50页。共享代码页（在二进制文件或共享库中）很有用，因为它减少了正在使用的物理页面的数量，从而减少了内存开销。</p><p><br><br><br></p><h3 id="问题：替换策略"><a href="#问题：替换策略" class="headerlink" title="问题：替换策略"></a>问题：替换策略</h3><p>Issue: Replacement Policy</p><p>与任何缓存一样，因此对于TLB，我们还必须考虑的另一个问题时<strong>缓存替换</strong>(cache replacement)。具体来说，当我们在TLB中安装新条目时，我们必须替换旧条目，从而产生了一个问题。我们要替换哪个条目？</p><p><br></p><blockquote><p>HOW TO DESIGN TLB REPLACEMENT POLICY<br>Which TLB entry should be replaced when we add a new TLB entry? The goal, of course, being to minimize the miss rate (or increase hit rate) and thus improve performance.</p></blockquote><p><br></p><p>在解决将页面交换到磁盘的问题时，我们将详细研究此类策略。在这里，我们只重点介绍一些典型的策略。一种常见的方法时逐出最近最少使用的LRU条目(least recently used)。LRU尝试利用内存引用流中的局部性，并假设最近未使用的条目很可能是驱逐的良好候选者。另一种典型的方法是使用随机策略，该策略会随机驱逐TLB映射。这样的策略由于其简单性和避免极端情况行为的能力而非常有用。</p><p><br><br><br></p><h3 id="真实的TLB条目"><a href="#真实的TLB条目" class="headerlink" title="真实的TLB条目"></a>真实的TLB条目</h3><p>A Real TLB Entry</p><p>最后，让我们简要看一下真正的TLB。该示例来自MIPS R4000。它是使用软件管理的TLB的现代系统。在图19-4中可看到简化的MIPS TLB条目。</p><p>MIPS R4000支持具有4KB页面的32位地址空间。因此，我们期望在典型的虚拟地址中有20位的VPN和12位的偏移量。但是，正如您在TLB中所看大的，VPN只有19位。事实证明，用户地址将仅来自地址空间的一般（其余部分保留给内核），因此仅需19位VPN。VPN最多可转换为24位物理帧(pfn)，因此可以支持具有64GB(物理)主内存(<code>2^24</code> 4KB pages)。</p><p>MIPS TLB中还有一些其它有趣的地方。我们看到一个全局为(global bit, G)，用于进程之间全局共享的页面。因此，如果设置了全局位，则将忽略ASID。我们也看到了8位ASID，操作系统可以使用它来区分地址空间。您遇到一个问题：如果一次运行的进程超过256(<code>2^8</code>)个，操作系统应怎么做？最后，我们看到3个 Coherence(C) bits，这些位确定硬件如何缓存页面。当页面被写入时被标记的脏位；一个有效位，该值高速硬件条目中是否存在有效的转换。还有一个页面掩码字段，它支持多种页面大小。我们将在后面看到为什么较大的页面可能会有用。最后，这64位中的一些未使用。</p><p>MIPS TLB通常包含32或64个条目，其中大多数在运行时由用户进程使用。但是，为操作系统保留了一些。可以由操作系统设置wired register，以告知硬件为操作系统保留多少个TLB插槽。操作系统会使用这些保留的映射来存储要在关键时间访问的代码和数据，而这在TLB丢失中会造成问题。</p><p>由于MIPS TLB是软件管理的，因此需要一些说明来更新TLB。MIPS 提供了以下四个这样的指令。操作系统使用这些说明来管理TLB的内容。当然，这些指令必须具有特权。想象一下，如果用户进程可以修改TLB的内容（几乎任何事情，包括接管机器，运行自己的恶意操作系统），该怎么办？</p><ul><li>TLBP，它探测TLB以查看其中是否存在特定转换；</li><li>TLBR，它将TLB条目的内容读入寄存器；</li><li>TLBWI，用于替换特定的TLB条目；</li><li>TLBWR，它将替换随机的TLB条目。</li></ul><p><br><br><br></p><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>Summary</p><p>我们已经了解了硬件如何帮助我们更快地进行地址转换。通过提供一个小型的专用片上TLB作为地址转换缓存，可以希望处理大多数内存引用，而不必访问主内存中的分页表。因此，在通常情况下，程序的性能几乎就像完全没有对内存进行虚拟化一样，这对于操作系统来说是一项出色的成就，并且对于现代操作系统中的分页使用必不可少。</p><p>但是，TLB并不会使每个存在的程序都变得乐观。特别是，如果程序在短时间内访问的页面数据超过了适合TLB的页面数，则该程序生成大量的TLB丢失，因此运行起来会慢得多。我们称这种现象超出了TLB的覆盖范围(coverage)，对于某些程序来说可能是个问题。正如我们将在下一章中讨论的那样，一种解决方案是包括对更大页面尺寸的支持。通过将关键数据结构映射到程序地址空间的较大页面所映射的区域中，可以提高TLB的有效覆盖率。</p><p>对大型页面的支持经常被诸如数据库管理系统(DBMS)之类的程序所利用，这些程序具有某些即大又随机访问的数据结构。</p><p>值得一提的另一个TLB问题：TLB访问很容易成为CPU pipeline的瓶颈，尤其是所谓的物理索引缓存。使用这种高速缓存，必须在访问高速缓存之前进行地址转换，这可能会大大降低速度。由于存在这个潜在的问题，人们已经研究了各种巧妙的方法来访问具有虚拟地址的缓存，从而避免在缓存命中的情况下进行昂贵的转换步骤。这种虚拟索引的缓存解决了一些性能问题，但也将新问题引入了硬件机制。</p><p><br><br><br><br><br></p><h2 id="高级的分页表"><a href="#高级的分页表" class="headerlink" title="高级的分页表"></a>高级的分页表</h2><p>Advanced page table</p><p>Paging: Smaller Tables</p><p>现在，我们解决介绍引入的第二个问题：分页表太大，因此消耗了太多内存。从线性分页表开始，您可能还记得，线性分页表变得很大。再次假定一个32位地址空间(<code>2^32</code>Bytes)，其中包含4KB(<code>2^12</code>Bytes)分页和4Bytes分页表条目。因此，一个地址空间中大约有一百万个虚拟页面(<code>2^32/2^12</code>)，乘以分页表条目大小，您会发现我们的分页表大小为4MB。还记得，我们通常为系统中的每个进程提供一个分页表！拥有一百个活跃的进程（在现代系统中并不罕见），我们仅为分页表分配数百兆的内容！结果，我们正在寻找减轻这种沉重负担的一些技术。这里有很多，让我们看看症结在哪：</p><blockquote><p>HOW TO MAKE PAGE TABLES SMALLER?<br>Simple array-based page tables (usually called linear page tables) are too big, taking up far too much memory on typical systems. How can we make page tables smaller? What are the key ideas? What inefficiencies arise as a result of these new data structures?</p></blockquote><p><br><br><br></p><h3 id="简单的解决方案：更大的页面"><a href="#简单的解决方案：更大的页面" class="headerlink" title="简单的解决方案：更大的页面"></a>简单的解决方案：更大的页面</h3><p>Simple Solution: Bigger Pages</p><p>我们可以通过一种简单的方法来减少分页表的大小：使用更大的页面。再次使用32位地址空间，但这次假设使用16KB页面。因此，我们将拥有一个18位的VPN和一个14位的偏移量。假设每个PTE的大小相同(4Bytes)，则我们现在有<code>2^18</code>个条目，因此每个分页表的总大小为1MB，这是分页表大小减少4倍的原因。</p><p>但是，这种方法的主要问题在于，大页面会导致每个页面内部的浪费，这就是内部化碎片的问题。因此，应用程序最终只能分配页面，但每个页面只使用很少的点滴，而内存很会被这些过大的页面填满。因此，在通常情况下，大多数系统使用相对较小的页面大小：4KB(x86)或8KB(SPARC V9)。</p><blockquote><p>ASIDE: MULTIPLE PAGE SIZES<br>As an aside, do note that many architectures (e.g., MIPS, SPARC, x86-64) now support multiple page sizes. Usually, a small (4KB or 8KB) page size is used. However, if a “smart” application requests it, a single large page (e.g., of size 4MB) can be used for a specific portion of the address space, enabling such applications to place a frequently-used (and large) data structure in such a space while consuming only a single TLB entry. This type of large page usage is common in database management systems and other high-end commercial applications. The main reason for multiple page sizes is not to save page table space, however; it is to reduce pressure on the TLB, enabling a program to access more of its address space without suffering from too many TLB misses. However, as researchers have shown [N+02], using multiple page sizes makes the OS virtual memory manager notably more complex, and thus large pages are sometimes most easily used simply by exporting a new interface to applications to request large pages directly</p></blockquote><p><br><br><br></p><h3 id="混合方法：分页和段"><a href="#混合方法：分页和段" class="headerlink" title="混合方法：分页和段"></a>混合方法：分页和段</h3><p>Hybrid Approach: Paging and Segments</p><p>每当您对生活中的某件事有两种合理但不同的方法时，都应始终检查这两种情况的组合，以了解是否可以同时兼顾两者。我们称这种组合为<strong>混合</strong>(hybrid)。</p><p>多年前，Multics的创造者在Multics虚拟内存系统的构建中碰巧出现了这种想法。具体来说，他将分页和分段结合在一起，以减少分页表的内存开销。我们可以通过更详细地检查典型的线性分页表来了解为什么这样做可行。假设我们有一个地址空间，其中堆和栈的已用部分很小。在此栗中，我们使用一个很小的16KB的地址空间和1KB页面（图20-1）。此地址空间和分页表在图20-2中。</p><p><img src="/images/OSTEP/20-1.png" alt="20-1"></p><p><img src="/images/OSTEP/20-2.png" alt="20-2"></p><p>此例中假定单个代码页(vpn 0)映射到pfn 10， 单个堆页面(vpn 4)映射到pfn 23，地址空间另一端的两个栈页面(vpn 14, 15)分别映射到(pfn 28, 4)。从图中可看出，大多数分页表都是未使用的，充满了无效的条目。真是浪费！这是一个很小的16KB地址空间。想象一下32位地址空间的分页表以及其中所有潜伏的浪费空间。太可怕了！</p><p>因此，我们采用了混合方法：不在进程的整个地址空间中使用分页表，而在每个逻辑段(logical segment)中使用分页表。因此，在此栗子中，我们可能有三个分页表：一个用于代码，一个用于堆、一个用于栈。</p><p>现在，请记住分段。我们有一个base register，告诉我们每个段在物理内存中的位置，还有一个bound register，告诉我们该段的大小。在我们的混合方法中，我们在MMU中仍然具有这些结构。在这里，我们使用base不是指向该段本身，而是保存该段的分页表的物理地址。bound register用于指示分页表的末尾（即，它具有多少有效页面）。</p><p>一个栗子。假定一个具有4KB页面的32位虚拟地址空间，并将一个地址空间分为四段。在此栗中，我们仅使用三个段：code, heap, stack。为了确定地址所指向的段，我们将使用地址空间的前两位。假设00是未使用的段，其中01代表代码，10代表堆，11代表栈。因此，虚拟地址可能像这样：</p><p><img src="/images/OSTEP/20-1122.png" alt></p><p>因此，在硬件中，假设有三对 base/bound，每对用于代码、堆、栈。当进程正在运行时，这些段中的base register都包含该段线性分页表的物理地址。因此，系统中的每个进程现在都具有与其关联的三个分页表。在上下文切换时，必须更改这些寄存器以反映新运行的进程的分页表的位置。</p><p>在TLB丢失时（假设由硬件管理TLB），硬件使用segment bits(SN)来确定要使用的base/bound pair。然后，硬件在其中获取物理地址，并将其与VPN结合，如下所示以形成分页表项(PTE)的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SN = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SN_SHIFT</span><br><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; VPN_SHIFT</span><br><span class="line">AddressOfPTE = Base[SN] + (VPN * sizeof(PTE))</span><br></pre></td></tr></table></figure><p>这个顺序看起来应该很熟悉。它实际上与我们之前在线性分页表中看到的相同。当然，唯一的区别是使用了三个 segment base registers，而不是一个。</p><p>混合方案中的关键差异是每个段都有一个base register，基寄存器保存该段中最大有效页面的值。例如，如果代码正在使用其前三个页面(0, 1, 2)，则代码段分页表将仅分配三个条目，并且bound register将设置位3。段末尾以外的内存访问将产生异常，并可能导致进程终止。通过这种方式，混合方法与线性分页表相比节省了大量内存。栈和堆之间未分配的页面不在占用分页表中的空间（只是将其标记为无效）。</p><p>但是，您可能会注意到，这种方法并非没有问题。首先，它仍然需要我们使用分段。正如前面所讨论的，分段并不像我们所希望的那样灵活，因为它假定了地址空间的某种使用模式。例如，如果我们有一个很大但稀疏使用的堆，那么仍然会导致很多分页表浪费。其次，这种混合方法导致外部碎片再次出现。尽管大多数内存以页面大小为单位进行管理，但现在分页表可以具有任意大小(pte的倍数)。因此，在内存中为其找到空闲空间更加复杂。由于这些原因，人们继续寻找更好的方法来实现较小的分页表。</p><blockquote><p>TIP: USE HYBRIDS<br>When you have two good and seemingly opposing ideas, you should always see if you can combine them into a hybrid that manages to achieve the best of both worlds. Hybrid corn species, for example, are known to be more robust than any naturally-occurring species. Of course, not all hybrids are a good idea; see the Zeedonk (or Zonkey), which is a cross of a Zebra and a Donkey. If you don’t believe such a creature exists, look it up, and prepare to be amazed.</p></blockquote><p><br><br><br></p><h3 id="多级分页表"><a href="#多级分页表" class="headerlink" title="多级分页表"></a>多级分页表</h3><p>Multi-level Page Tables</p><p>一种不同的方法不依赖于分段，而是攻击相同的问题：如果摆脱分页表中所有无效区域，而不是将它们全部保留在内存中？我们将这种方法称为<strong>多级分页表</strong>(multi level page table)，因为它将线性分页表变成了像树一样的东西。这种方法非常有效，以至于许多现代操作系统都采用这种方法（如，x86）。</p><p>多级分页表的基本思想很简单。首先，将页面切成页面大小(page-sized)的单位。然后，如果整个分页表条目(pte)无效，则根本不要分配该分页表的整个页面。若要追踪分页表的页面是否有效（如果有效，则在内存中的位置），请使用称为<strong>页目录</strong>(page directory)的新结构。因此，页目录可以用来告诉您分页表的页面在哪里，或者分页表的整个页面不包含有效页面。</p><p><img src="/images/OSTEP/20-3.png" alt="20-3"></p><p>图20-3显示了一个栗子。图的左侧是经典的线性分页表。即地址空间的大多数中间区域无效，我们仍然需要为这些区域分配分页表空间。右边是一个多级分页表。页面目录仅将分页表的两个页面标记为有效（第一个和最后一个）。因此，只有分页表的那两个页驻留在内存中。因此，您可以看到一种可视化多级表正在执行的方法：它只是使线性分页表的某些部分消失（将那些框架释放出来供其它用途），并跟踪分页表中的哪些页与页目录一起分配。</p><p>页目录在一个简单的两级表中，在分页表的每页中包含一个条目。它由许多页目录条目(page directory entry, PDE)组成。PDE（至少）具有一个有效位(valid bit)和一个页帧号(pfn)，类似于PTE。但是，如前所述，该有效位的含义略有不同：如果PDE有效，则意味着该条目指向的分页表中的至少一个页面(通过pfn)是有效的，即在此PDE指向的页面上的至少一个PTE中，该PTE中的有效位设置为1.如果PDE无效(0)，则未定义PDE的其余部分。</p><p>到目前为止，多级分页表具有一些明显的优势。首先，也许是最明显的是，多级表仅根据您正在使用的地址空间量分配分页表空间。因此，它通常是紧凑的，并且支持稀疏的地址空间。其次，如果精心构建，分页表的每个部分都可以整齐地放在一个页面中，从而更易于管理内存。当操作系统需要分配或增加分页表时，操作系统可以简单地获取下一个空闲页。将此与一个简单的（非分页）线性分页表进行对比，该表只是一个由VPN索引的PTE数组。采用这种结构，整个线性分页表必须连续地驻留在物理内存中。对于大的分页表(如，4MB)，找到这么大的未使用的连续可用物理内存可能是一个挑战。通过多级结构，我们通过使用页面目录添加了一个间接级别(level of indirection)，该目录指向分页表的各个部分。这种间接允许我们将分页表页面放置在物理内存中的任何位置。</p><p>应该注意的是，多级表是有代价的。在TLB丢失时，将需要两次从内存中加载来从分页表中获取正确的转换信息（一个用于页目录，一个用于PTE自身），而线性分页表仅需要一次加载。因此，多级表只是时空(time-space)权衡(trade-off)的一个小栗子。我们想要更小的表（并得到它），但不是免费的。尽管在常见情况下(TLB hit)，性能显然是相同的，但使用较小的表会导致TLB丢失而导致成本较高。</p><p>另一个明显的负面影响是复杂性(complexity)。无论是硬件还是操作系统处理分页表查找，与简单的线性分页表查找相比，这样做无疑涉及更多。通常，我们愿意增加复杂性以提高性能或减少开销。对于多级表，为了节省宝贵的内存，我们使分页表查找更加复杂。</p><p><br></p><blockquote><p>TIP: UNDERSTAND TIME-SPACE TRADE-OFFS<br>When building a data structure, one should always consider time-space trade-offs in its construction. Usually, if you wish to make access to a particular data structure faster, you will have to pay a space-usage penalty for the structure.</p></blockquote><p><br></p><p><strong>详细的多级示例</strong><br>A Detailed Multi-Level Example</p><p>为了更好地理解多级分页表背后的思想，让我们举个栗子。想象一下一个小的16KB地址空间，具有64Bytes的页面。因此，我们有一个14位的虚拟地址空间，其中8位用于VPN，6位用于offset。即使只使用一小部分地址空间，线性分页表也将具有(<code>2^8=256</code>)个条目。图20-4给出了这种地址空间的一个栗子。</p><p><img src="/images/OSTEP/20-4.png" alt></p><p>在此栗子中，vp 0, 1用于代码，vp 4, 5用于堆，vp 254, 255用于栈。地址空间的其余页面未使用。为了为该地址空间构建要给两级分页表，我们从完整的线性分页表开始，然后将其分解为页面大小的单元。假设每个PTE的大小为4Bytes。因此，我们的分页表大小为1KB(<code>256*4Bytes</code>)。假设有64Bytes的页面，则1KB分页表可以分为16个64Bytes的页面。每个页面可以容纳16个PTE。现在，我们需要了解的是如何使用VPN并使用它索引到页面目录，然后再索引到分页表的页面。请记住，每个条目都是一个数组。因此，我们需要弄清楚的是如何从VPN的各个部分构建索引。</p><p>让我们首先索引页目录。在此示例中，我们的分页表很小：256个条目，分布在16个页面上。页目录在分页表的每页上需要一个条目。因此，我们需要VPN的四位索引到目录中。我们使用VPN的前四位，如下：</p><p><img src="/images/OSTEP/page-directory-index.png" alt="page-directory-index"></p><p>一旦从VPN中提取了页目录索引(page-directory index, PDIndex)，我们就可以使用它通过简单的计算来找到页目录条目(PDE)的地址：<code>PDE Addr = PageDirBase + (PDIndex*sizeof(PDE))</code>。此结果在我们的页目录中，现在我们将对其进行检查以在转换中取得进一步的进展。</p><p>如果页目录条目被标记为无效，则我们知道该访问无效。因此引发异常。但是，如果PDE有效，我们还有更多工作要做。具体来说，我们现在必须从此页目录条目指向的分页表的页面中获取分页表条目(PTE)。要找到此PTE，我们必须使用VPN的其余位来索引分页表的一部分：</p><p><img src="/images/OSTEP/page-directory-index-2.png" alt></p><p>然后可以使用此分页表索引(PTIndex)来索引分页表本身，从而为我们提供PTE的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PTEAddr = (PDE.PFN &lt;&lt; SHIFT) + (PTIndex * sizeof(PTE))</span><br><span class="line"></span><br><span class="line">// &gt;&gt;</span><br></pre></td></tr></table></figure><p>请注意，从页目录获得的页面帧号(pfn)必须显左移到适当位置，然后再将其与分页表索引组合以形成PTE的地址。在图20-5中，您可以看到每个页目录条目(PDE)都描述了有关地址空间的分页表页面的内容。在这个例子中，我们在地址空间（开头和结尾）两个有效的区域，以及一些无效的映射在两者之间的。在物理页100（分页表第0页的物理帧号）中，我们在地址空间中具有前16个VPN的16页分页表条目的第一个页面。有关分页表此部分的内容，请参见图20-5。</p><p>分页表的此页面包含前16个映射VPN。在此例中，vpn 0, 1有效()code，vpn 4, 5有效(heap)。因此，该表具有每个页面的映射信息。其余条目被标记为无效。</p><p><img src="/images/OSTEP/20-5.png" alt="20-5"></p><p>分页表的另一个有效页位于pfn 101内。此页包含地址空间的最后16个VPN的映射。</p><p>在该栗子中，vpn 254, 255(stack)具有有效的映射。希望从本示例中可以看到，使用多级索引结构可以节省多少空间。在此示例中，我们没有为线性分页表分配完整的十六个页面，而是仅分配了三个：一个用于页目录，两个用于具有映射的分页表的块。大型地址空间(32bit/64bit)的节省显然会更大。</p><p>最后，让我们使用此信息来执行转换。这是引用VPN 254的第0个字节的地址：0x3F80或二进制的11 111 1000 0000。</p><p>回想一下，我们将使用VPN的高4位索引到页目录。因此，1111将选择上面页目录的最后一个条目。这将我们指向位于地址101的分页表的有效页。然后，我们使用VPN的下4位(1110)索引到分页表的该页并找到所需的PTE。1110是页面上的倒数第二个条目，它告诉我们虚拟地址空间的页面254映射到物理页面55。通过将PFN=55（或十六进制<code>0x37</code>)与<code>offset=000000</code>串联，我们这样就可以形成我们想要的物理地址，并向存储系统发出请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PhysAddr = (PTE.PFN &lt;&lt; SHIFT) + offset = 00 1101 1100 0000 = 0x0DC0</span><br><span class="line"></span><br><span class="line">// &gt;&gt;</span><br></pre></td></tr></table></figure><p>您现在应该对如何使用指向分页表页面的页目录构造一个二级分页表有所了解。然而不幸的是，我们的工作还没有完成。正如我们现在要讨论的那样，有时两个级别的分页表是不够的。</p><p><br></p><p><strong>不止两级</strong><br>More Than Two Levels</p><p>到目前为止，在示例中。我们假设多级分页表只有两个级别：页目录，然后是分页表的各个部分。在某些情况下，更深的树是可能的（确实的、必需的）。</p><p>举个栗子，并用它来说明为什么更深层的多级表很有用。假设有一个30位的虚拟地址空间和一个小的页面(512Bytes)。因此，我们的虚拟地址具有21位的虚拟页码部分和9位偏移量。记住我们构建多级分页表的目标：使分页表的每个部分都适合单个页面。到目前为止，我们仅考虑了分页表本身。但是，如果页目录太大，该怎么办？</p><p>为了确定多级表中需要多少级才能使分页表的所有部分都适合一个页面，我们首先确定一个页面中可以容纳多少分页表条目。给定的页面大小位512Bytes，并假设PTE大小为4Bytes，您应该看到可以在单个页面上容纳128个PTE。当我们索引到分页表的页面时，我们将需要vpn的最低有效位7位(<code>2^7=128</code>)作为索引：</p><p><img src="/images/OSTEP/page-directory-index-3.png" alt></p><p>您还可能从上图中注意到，页目录中还剩下多少位：14。如果我们的页目录有<code>2^14</code>个条目，那么它跨越的不是一页而是128个，因此我们使多级分页表的每个部分都适合一个页面的目标就消失了。</p><p>为了解决此问题，我们通过将页目录本身拆分为多个页面，然后在该页面之上添加另一个页目录，以指向该页目录的页面，来构建树的进一步层次。因此，我们可以如下拆分虚拟地址：</p><p><img src="/images/OSTEP/page-directory-index-4.png" alt></p><p>现在，在索引上级(upper-level)页目录时，我们使用虚拟地址的最高位（PDIndex 0）。该索引可用于从顶级页目录中获取页目录条目。如果有效，则通过组合来自顶层PDE和VPN的下一部分(PDIndex 1)的物理帧号来查询页目录的第二层。最后，如果有效，则可以通过使用页表索引与第二级PDE中的地址相结合来形成PTE地址。这是很多工作，所有这些只是为了在多级表中查找内容。</p><p><br></p><p><strong>转换进程：记住TLB</strong><br>The Translation Process: Remember the TLB</p><p>为了总结使用两级分页表的地址转换的整个过程，我们再次以算法形式给出如下控制流。它显示了在每个内存引用中硬件中发生的情况（假设由硬件管理的TLB）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// Multi-level Page Table Control Flow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line">(Success, TlbEntry) = TLB_Lookup(VPN)</span><br><span class="line">if (Success == True) // TLB Hit</span><br><span class="line">  if (CanAccess(TlbEntry.ProtectBits) == True)</span><br><span class="line">    Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">    PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset</span><br><span class="line">    Register = AccessMemory(PhysAddr)</span><br><span class="line">  else</span><br><span class="line">    RaiseException(PROTECTION_FAULT)</span><br><span class="line">else // TLB Miss</span><br><span class="line">  // first, get page directory entry</span><br><span class="line">  PDIndex = (VPN &amp; PD_MASK) &gt;&gt; PD_SHIFT</span><br><span class="line">  PDEAddr = PDBR + (PDIndex * sizeof(PDE))</span><br><span class="line">  PDE = AccessMemory(PDEAddr)</span><br><span class="line">  if (PDE.Valid == False)</span><br><span class="line">    RaiseException(SEGMENTATION_FAULT)</span><br><span class="line">  else</span><br><span class="line">  // PDE is valid: now fetch PTE from page table</span><br><span class="line">  PTIndex = (VPN &amp; PT_MASK) &gt;&gt; PT_SHIFT</span><br><span class="line">  PTEAddr = (PDE.PFN &lt;&lt; SHIFT) + (PTIndex * sizeof(PTE))</span><br><span class="line">  PTE = AccessMemory(PTEAddr)</span><br><span class="line">  if (PTE.Valid == False)</span><br><span class="line">    RaiseException(SEGMENTATION_FAULT)</span><br><span class="line">  else if (CanAccess(PTE.ProtectBits) == False)</span><br><span class="line">    RaiseException(PROTECTION_FAULT)</span><br><span class="line">  else</span><br><span class="line">    TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)</span><br><span class="line">    RetryInstruction()</span><br><span class="line"></span><br><span class="line">// &gt;&gt;over</span><br></pre></td></tr></table></figure><p>从图中可以看出，在进行任何复杂的多级页表访问之前，硬件首先检查TLB。命中后，就像以前一样直接形成物理地址，而根本不访问分页表。只有在TLB未命中时，硬件才需要执行完整的多级查找。在这条路径上，您可以看到传统的两级分页表的成本：两个额外的内存访问以查找有效的转换。</p><p><br><br><br></p><h3 id="反向分页表"><a href="#反向分页表" class="headerlink" title="反向分页表"></a>反向分页表</h3><p>Inverted Page Tables</p><p>使用<strong>反向分页表</strong>(inverted page tables)可以在分页表世界中节省更多空间。在这里，没有许多分页表（每个系统进程一个），而是保留了一个分页表，该表为系统的每个物理页面都有一个条目。该条目告诉我们哪个进程正在使用该页面，以及该进程的哪个虚拟页面映射到该物理页面。</p><p>现在，查找正确的条目只是搜索此数据结构的问题。线性扫描会很昂贵，因此通常在基本结构上构建哈希表以加快查找速度。PowerPC就是这种架构的一个示例。</p><p>更一般而言，反向分页表从一开始就说明了我们所说的话：分页表只是数据结构。您可以使用数据结构做很多疯狂的事情，使它们变小或变大、变快或变慢。多级和反向分页表只是一个人可以做的许多事情的两个栗子。</p><p><br><br><br></p><h3 id="将分页表交换到磁盘"><a href="#将分页表交换到磁盘" class="headerlink" title="将分页表交换到磁盘"></a>将分页表交换到磁盘</h3><p>Swapping the Page Tables to Disk</p><p>最后，我们讨论一个最终假设。到目前为止，我们已经假定分页表驻留在内核拥有的物理内存中。即使我们有很多减少分页表大小的技巧，但是仍然有可能它们太大而无法一次全部放入内存中。因此，某些系统将这样的分页表放置在内核虚拟内存(kerl virtual memory)中，从而允许系统在内存压力变紧时将这些分页表中的某些交换(swap)到磁盘上。一旦我们了解了如何更详细将页面移入和移出内存，我们将在以后的章节中进一步讨论这一点。</p><p><br><br><br></p><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>Summary</p><p>现在，我们已经看到了如何构建真实的分页表。不一定只是线性数组，而是更复杂的数据结构。这种表的权衡是在时间和空间上进行的，表越大，TLB丢失可以得到更快的服务。反之亦然。因此，结构的正确选择在很大程度上取决于给定环境的约束。</p><p>在受内存限制的系统中（旧的系统），小型结构是有意义的。在内存合理且工作负载主动使用大量页面的系统中，加快TLB丢失速度的较大表可能是正确的选择。借助软件管理的TLB，整个数据结构空间将为操作系统创新者带来惊喜。</p><p><br><br><br><br><br></p><h2 id="交换机制"><a href="#交换机制" class="headerlink" title="交换机制"></a>交换机制</h2><p>Beyond Physical Memory(Swap) Mechanisms: <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-beyondphys.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/vm-beyondphys.pdf</a></p><p>到目前为止，我们已经假定地址空间不切实际地小并且适合物理内存。实际上，我们一直假设每个运行进程的每个地址空间都适合内存。现在，我们将放宽这些大的假设，并假设我们希望支持许多同时运行的大地址空间。为此，我们需要在内存层次结构中增加一个级别。到目前为止，我们已经假设所有页面都驻留在物理内存中。但是，为了支持较大的地址空间，操作系统将需要一个地方来存放当前需求不大的部分地址空间。通常，这种位置的特征是它的容量应大于内存。结果，它通常会比较慢。在现代系统中，通常由硬盘驱动器(hard disk drive)担当此角色。因此，在我们的内存层次结构中，大而慢的硬盘驱动器位于底部，而内存位于上方。因此，我们得出了问题的症结：</p><blockquote><p>THE CRUX: HOW TO GO BEYOND PHYSICAL MEMORY<br>How can the OS make use of a larger, slower device to transparently provide the illusion of a large virtual address space?</p></blockquote><p>您可能会有一个问题，为什么我们要为一个进程支持一个大地址空间？答案再次是方便和易用。地址空间很大，您不必担心程序中的数据结构是否有足够的内存空间。相反，您只是自然地编写程序，并根据需要分配内存。操作系统提供了一种强大的幻觉，使您的生活大大简化。在使用内存覆盖(memory overlays)的旧系统中发现了一种对比，这要求程序员在需要时手动将代码或数据片段移入或移出内存。试想一下这是什么样的：在调用函数或访问某些数据之前，您需要首相将代码或数据安排在内存中。</p><p>除了单个进程外，交换空间(swap space)的增加还使操作系统能够为多个同时运行的进程提供大型虚拟内存的支持。多程序的发明（一次运行多个程序，以更好地利用机器）几乎需要交换掉某些页面的能力，因为早期的机器显然不能同时容纳所有进程所需的所有页面。因此，多程序和易用性的结合使我们想要支持使用比物理可用内存更多的内存。所有现代虚拟内存系统都可以做到这一点。现在，我们将了解更多信息。</p><p><br></p><blockquote><p>ASIDE: STORAGE TECHNOLOGIES<br>We’ll delve much more deeply into how I/O devices actually work later (see the chapter on I/O devices). So be patient! And of course the slower device need not be a hard disk, but could be something more modern such as a Flash-based SSD. We’ll talk about those things too. For now, just assume we have a big and relatively-slow device which we can use to help us build the illusion of a very large virtual memory, even bigger than physical memory itself.</p></blockquote><p><br><br><br></p><h3 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h3><p>Swap Space</p><p>我们需要做的第一件事是在磁盘上保留一些空间来回移动页面。在操作系统中，我们通常将此类空间称为<strong>交换空间</strong>(swap space)，因为我们将页面从内存中交换到该空间，并将页面从其中交换到内存。因此，我们仅假设操作系统可以以页面大小为单位读取和写入交换空间。为此，操作系统需要记住给定页面的磁盘地址(disk space)。</p><p>交换空间的大小很重要，因为它最终决定了系统在给定时间可以使用的最大内存页面数量。为了简单起见，让我们假设它现在很大。</p><p>在图21-1的栗子中，您可以看到一个4页面物理内存和8页面交换空间。在此例中，三个进程(P0, P1, P2)正在主动共享物理内存。但是，这三个中的每一个在内存中仅具有其部分有效页面，区域部分位于磁盘上的交换空间中。第四个进程(P3)将所有页面交换到磁盘，因此显然当前未运行。一块交换空间仍然是空闲的。即使从这个很小的栗子，也希望您能看到使用交换空间如何使系统假装内存大于实际内存。</p><p><img src="/images/OSTEP/21-1.png" alt="21-1"></p><p>我们应该注意到，交换空间不是交换流量(swapping traffic)的唯一磁盘位置。例如，假设您正在运行一个二进制程序（如，ls）。最初在磁盘上找到此二进制文件的代码页(code pages)，并且在程序运行时将它们加载到内存中（既可以在程序开始执行时一次全部加载，也可以在现代系统中需要时一次加载一页）。但是，如果系统需要在物理内存中腾出空间来满足其它需求，则可以安全地重用这些代码页的存储空间，因为它知道以后可以从文件系统中的磁盘二进制文件中再次交换它们。</p><p><br><br><br></p><h3 id="当前位"><a href="#当前位" class="headerlink" title="当前位"></a>当前位</h3><p>The Present Bit</p><p>现在，我们有一些空间在磁盘上。我们需要在系统中增加一些机制，以支持在磁盘之间交换页面。为了简单起见，让我们假设我们有一个带有硬件管理的TLB的系统。</p><p>首先回想一下内存引用中发生的情况。正在运行的进程会生成虚拟内存引用（用于指令提取，或数据访问），在这种情况下，硬件会在从内存中提取所需数据之前将其转换为物理地址。</p><p>请记住，硬件首先从虚拟地址中提取VPN，检查TLB是否匹配（TLB hit）。如果命中，将产生结果的物理地址并从内存中获取它。希望这是常见的情况，因为它速度很快（不需要额外的内存访问）。</p><p>如果在TLB中未找到VPN（TLB miss），则硬件会在内存中找到分页表（使用page table base register)，并使用VPN作为索引查找该页的分页表条目(PTE)。如果该页面有效并且存在于物理内存中，则硬件将从PTE中提取PFN，并将其写入TLB，然后重试指令，这一次将产生TLB命中，到目前为止，岁月静好。</p><p>但是，如果我们希望将页面交换到磁盘，则必须添加更多的设备。具体来说，当硬件在PTE中查找时，它可能会发现内存中不存在(not present)该页面。硬件确定这一点的方式是通过每个分页表条目中的一条信息——称为<strong>当前位</strong>(present bit)。如果当前位设置为1，则意味着该页存在于物理内存中，并且一切按上述步骤进行；如果其设置为0，则该页面不在内存中，而是在磁盘上的某个位置。访问不在物理内存中的页面的行为通常称为<strong>页面错误</strong>(page fault)。</p><p>出现页面错误时，将调用操作系统来服务该页面错误。正如我们现在所描述的，称为页面错误处理程序(page-fault handler)的特定代码运行，并必须服务于页面错误。</p><p><br></p><blockquote><p>ASIDE: SWAPPING TERMINOLOGY AND OTHER THINGS<br>Terminology in virtual memory systems can be a little confusing and variable across machines and operating systems. For example, a page fault more generally could refer to any reference to a page table that generates a fault of some kind: this could include the type of fault we are discussing here, i.e., a page-not-present fault, but sometimes can referto illegal memory accesses. Indeed, it is odd that we call what is definitely a legal access (to a page mapped into the virtual address space of a process, but simply not in physical memory at the time) a “fault” at all; really, it should be called a page miss. But often, when people say a program is “page faulting”, they mean that it is accessing parts of its virtual address space that the OS has swapped out to disk.<br>We suspect the reason that this behavior became known as a “fault” relates to the machinery in the operating system to handle it. When something unusual happens, i.e., when something the hardware doesn’t know how to handle occurs, the hardware simply transfers control to the OS, hoping it can make things better. In this case, a page that a process wants to access is missing from memory; the hardware does the only thing it can, which is raise an exception, and the OS takes over from there. As this is identical to what happens when a process does something illegal, it is perhaps not surprising that we term the activity a “fault.”</p></blockquote><p><br><br><br></p><h3 id="页面错误"><a href="#页面错误" class="headerlink" title="页面错误"></a>页面错误</h3><p>The Page Fault</p><p>回想一下，对于TLB未命中，我们有两种类型的系统：硬件管理的TLB和软件管理的TLB。在这两种类型的系统中，如果页面不存在，则由操作系统负责处理页面错误。操作系统页面错误处理程序将运行以确定要执行的操作。实际上，所有系统都可以处理软件中的页面错误。即使使用硬件管理的TLB，硬件也信任操作系统来管理这一重要职责。</p><p>如果页面不存在并且已被交换到磁盘，则操作系统需要将页面交换到内存中已解决页面错误。因此，出现一个问题：操作系统如何知道在哪里可以找到所需的页面？在许多系统中，分页表时存储此类信息的天然场所。因此，操作系统可以将通常用于数据(pfn)的PTE中的位用于磁盘地址。当操作系统收到页面的页面错误时，它会在PTE中查找地址，然后向磁盘发出请求以将该页面读取到内存中。</p><p>磁盘I/O完成后，操作系统将更新分页表以将该页面标记为present，更新分页表条目(pte)的pfn字段以记录新获取的页面在内存中的位置，然后重试指令。下一个尝试可能会生成TLB未命中，然后服务并使用转换来更新TLB（为错误页面提供服务时，可以交替更新TLB以避免此步骤）。最后，最后一次重新启动将在TLB中找到转换，并因此从转换后的物理地址出的内存中获取所需的数据或指令。</p><p>请注意，在运行I/O时，该进程将处于阻塞状态(blocked state)。因此，在为页面错误提供服务时，操作系统将可以自由运行其它准备就绪的进程。因为I/O昂贵，所以一个进程的I/O和另一个进程的执行的这种重叠(overlap)是多程序系统可以最有效地利用其硬件的另一种方式。</p><p><br><br><br></p><h3 id="如果内存满了怎么办"><a href="#如果内存满了怎么办" class="headerlink" title="如果内存满了怎么办"></a>如果内存满了怎么办</h3><p>What If Memory Is Full?</p><p>在上述描述中，您可能会注意到我们假设有足够的可用内存在交换空间中的页面中进行分页。然而，事实并非如此。内存可能已满。因此，操作系统可能希望首先剔出一个或多个页面，以便为操作系统将要引入的新页面腾出空间。挑选要踢出或替换的页面的过程称为<strong>页面替换策略</strong>(page-replacement policy)。</p><p>事实证明，创建一个好的页面替换策略引起了很多思考，因为踢错页面(kicki out of the wrong page)可能会导致程序性能损失巨大。错误的决定会导致程序以磁盘速度而不是内存速度运行。在目前的技术中，这意味着程序的运行可能会慢一万倍。因此，这种政策是我们应该详细研究的。实际上，这正是我们将在下一章中进行的操作。到目前为止，了解存在这样的策略已经足够了。</p><p><br><br><br></p><h3 id="页面错误控制流"><a href="#页面错误控制流" class="headerlink" title="页面错误控制流"></a>页面错误控制流</h3><p>Page Fault Control Flow</p><p>掌握了所有这些知识之后，我们现在可以大致概述内存访问的完整控制流程。换句话说，当有人问您程序从内存中获取一些数据时会发生什么？您应该对所有不同的可能性都有一个很好的了解。有关更多详细信息，请参考图21-2和21-3的控制流程。第一个图显示了硬件在转换过程中的作用，第二个图显示了页面错误时操作系统的作用。</p><p><img src="/images/OSTEP/21-2.png" alt="21-2"></p><p><img src="/images/OSTEP/21-3.png" alt="21-3"></p><p>从图21-2的硬件控制流程图中，请注意，当发生TLB丢失时，现在需要了解三个重要情况：</p><ul><li>首先，该页面既存在又有效(line 18-21)。在这种情况下，TLB未命中处理程序可以简单地从PTE中获取PFN，重试指令（这一次导致TLB命中），从而按照前面所述继续操作。</li><li>在第二种情况下(line 22-23)，必须运行页面错误处理程序。尽管这是供进程访问的合放页面（毕竟它是有效的），但它不存在于物理内存中。</li><li>第三，访问可能是无效页面。例如由于程序中的错误(line 13-14)。在这种情况下，PTE中的其它位都不重要。硬件会批捕此无效访问，并且操作系统给陷阱处理程序将运行，可能会终止有问题的进程。</li></ul><p>从图21-3的软件控制流程中，我们可以看到操作系统大致必须执行的操作才能解决页面错误。首先，操作系统必须为即将出现故障的页面找到驻留在其中的物理框架。如果没有这样的页面，我们将不得不等待替换算法进行并将其部分页面踢出内存，从而释放它们供此处使用。有了一个物理框架，处理程序便发出I/O请求以从交换空间中读取页面。最后，当该缓慢的操作完成时，操作系统将更新分页表并重试该指令。重试将导致TLB丢失，然后在再次重试时TLB命中，此时硬件将能够访问所需的项目。</p><p><br><br><br></p><h3 id="真正发生替换时"><a href="#真正发生替换时" class="headerlink" title="真正发生替换时"></a>真正发生替换时</h3><p>When Replacements Really Occur</p><p>到目前为止，我们描述替换的方式是假设操作系统一直等到内存完全用完，然后才替换（逐出）页面为其它页面腾出空间。可以想象，这有点不切实际，并且操作系统有很多原因可以更主动地释放一小部分内存。</p><p>为了使少量内存可用，大多数操作系统因此具有某种<strong>高水位</strong>(high watermark, HW)和<strong>低水位</strong>(low watermark, LW)来帮助确定何时开始从内存中逐出页面。它的工作方式如下：当操作系统注意到可用的页面少于LW时，负责释放内存的后台线程将运行。该线程逐出页面，直到有可用的HW为止。后台线程（有时称为swap daemon，或page daemon）随后进入睡眠状态，很高兴它释放了一些内存以供正在运行的进程和操作系统使用。</p><p>通过一次执行许多替换，新的性能优化成为可能。例如，许多系统将集群(cluster)和分组(group)并将它们立即写出到交换分区，从而提高磁盘的效率。正如我们稍后将更详细地讨论磁盘时所看到的那样，这种集群减少了磁盘的查找和旋转开销，从而显著提高了性能。要使用后台分页进程，应略微修改图21-3中的控制流程。该算法将直接检查是否有可用的空闲页面，而不是直接执行替换。如果没有，它将通知后台分页线程需要空闲页面。当线程释放一些页面时，它将重新唤醒原始线程，然后可以在所需的页面中分页并继续其工作。</p><blockquote><p>TIP: DO WORK IN THE BACKGROUND<br>When you have some work to do, it is often a good idea to do it in the background to increase efficiency and to allow for grouping of operations. Operating systems often do work in the background; for example, many systems buffer file writes in memory before actually writing the data to disk. Doing so has many possible benefits: increased disk efficiency, as the disk may now receive many writes at once and thus better be able to schedule them; improved latency of writes, as the application thinks the writes completed quite quickly; the possibility of work reduction, as the writes may need never to go to disk (i.e., if the file is deleted); and better use of idle time, as the background work may possibly be done when the system is otherwise idle, thus better utilizing the hardware.</p></blockquote><p><br><br><br></p><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>Summary</p><p>在简短的本章节中，我们介绍了访问比系统中实际存在的内存更多的内存的概念。这样做需要分页表结构中的更多复杂性，因为必须包括当前位(present bit)以告诉我们该页面是否存在于内存中。否则，操作系统页面错误处理程序将运行以处理页面错误，从而安排将所需的页面从磁盘传输到内存，也许首先替换内存中的某些页面以为即将被交换的那些页面腾出空间。</p><p>重要的是，记得这些动作对进程来说都是透明的。就进程而言，它只是在访问自己的私有连续虚拟内存。在幕后，页面被放置在物理内存中的任意(不连续)位置中，有时它们甚至不存在于内存中，需要从磁盘中获取。尽管我们希望在通常情况下可以快速访问内存，但在某些情况下仍需要多个磁盘操作来进行访问。在最坏的情况下，执行一条指令之类的简单操作可能需要花费几毫秒的时间才能完成。</p><p><br><br><br><br><br></p><h2 id="交换策略"><a href="#交换策略" class="headerlink" title="交换策略"></a>交换策略</h2><p>Beyond Physical Memory(Swap) Policies: <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-beyondphys-policy.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/vm-beyondphys-policy.pdf</a></p><p>在虚拟内存呢管理器中，当您有大量可用内存时，生活很轻松。发生页面错误时，您在空闲页面列表中找到一个空闲页面，并将其分配给错误页面。不幸的是，只有很少的内存可用时，事情才会变得更加有趣。在这种情况下，<strong>内存压力</strong>(memory pressure)迫使操作系统开始调出页面，以便为活跃使用的页面腾出空间。使用包含在操作系统中的替换策略确定逐出哪个页面。从历史上看，这是早期虚拟内存系统做出的最重要的决定之一，因为旧的系统只有很少的物理内存。至少，这是一组有趣的策略，值得更多地了解。因此，我们的问题是：</p><blockquote><p>THE CRUX: HOW TO DECIDE WHICH PAGE TO EVICT<br>How can the OS decide which page (or pages) to evict from memory? This decision is made by the replacement policy of the system, which usually follows some general principles (discussed below) but also includes certain tweaks to avoid corner-case behaviors.</p></blockquote><p><br><br><br></p><h3 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h3><p>Cache Management</p><p>在深入讨论策略之前，我们首先详细描述我们要解决的问题。假设主内存保存系统中所有页面的一些子集，那么可以正确地将其视为系统中虚拟内存页面的高速缓存(cache)。因此，我们为该高速缓存选择替换策略的目标是最小化高速缓存丢失(cache miss)的次数，即最小化我们必须从磁盘获取页面的次数。或，可以将我们的目标视为最大化高速缓存命中(cache hit)的次数，即在内存中找到被访问的页面的次数。</p><p>知道高速缓存命中和未命中的数量后，我们就可以计算程序的<strong>平均内存访问时间</strong>(average memory access time, AMAT)。具体来说，给定这些值，我们可以计算程序的AMAT：</p><script type="math/tex; mode=display">AMAT=T_{M}+(P_{miss}*T_{D})</script><ul><li><script type="math/tex">T_{M}</script>: 表示访问内存的成本</li><li><script type="math/tex">T_{D}</script>: 表示访问磁盘的成本</li><li><script type="math/tex">P_{miss}</script>: 表示在高速缓存中找不到数据的可能性(未命中)，在<code>0.0-1.0</code>之间变化，有时我们使用百分比来表示</li></ul><p>请注意，您始终要支付访问内存中数据的费用。但是，当您错过时，您必须另外支付从磁盘中获取数据的费用。</p><p>例如，让我们想象一下一个具有微小地址空间的机器：4KB，具有256Bytes的页面。因此，虚拟地址的两个部分：4为VPN（最高有效位）和8位偏移（最低有效位）。因此，此示例中的进程可以访问<code>2^4=16</code>个虚拟页面。在此示例中，该进程生成如下内存引用（即，虚拟地址）：<code>0x000, 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700, 0x800, 0x900</code>。这些虚拟地址指的是地址空间的前十个页面中每个页面的第一个字节。让我们进一步假设除虚拟页面3之外的每个页面都已经在内存中。因此，我们的内存引用序列将遇到以下行为：hit, hit, hit, miss, hit, hit, hit, hit, hit, hit。我们可以计算出命中率为90%，而未命中率为10%。</p><p>要计算AMAT，我们需要知道访问内存的成本和访问磁盘的成本。假设访问内存的成本约为100ns，访问磁盘的成文约为10ms。<code>AMAT=100ns+(0.1*10ms)=1.0001ms</code>，大约为1ms。如果我们的命中率很高(<code>99.9%</code>)，则结果将快100倍。</p><p>不幸的时，正如您所看到的那样，现代系统中磁盘访问的成本如此之高，以至于即使是很小的未命中也将很快主导正在运行的程序的整体AMAT。显然，我们需要以磁盘速度避免尽可能多的丢失。</p><p><br><br><br></p><h3 id="最优替换策略"><a href="#最优替换策略" class="headerlink" title="最优替换策略"></a>最优替换策略</h3><p>The Optimal Replacement Policy</p><p>为了更好地了解特定替换策略的工作原理，最好将其与最佳替换策略进行比较。事实证明，这样的最优策略是Belady多年前开发的（最初称为MIN）。最佳的提花策略导致总体上的遗漏最少。一种简单的方法（不幸的是，实现起来很困难）替代了将来被最远访问(furthest in the future)的页面，这是最佳策略，从而导致了最少的高速缓存丢失。</p><p>最优策略背后的直觉是有意义的。如果您必须扔掉一些页面，为什么不扔掉从现在开始最远的那一页呢？这样，您实际上是在说高速缓存中的所有其它页面比最远的页面更重要。这个原因很简单：在引用最远的内容之前，您将显先引用其它页面。</p><p>让我们通过一个简单的示例进行追踪，以了解最优策略的决策。假设程序访问以下虚拟页面流：0, 1, 2, 0, 1, 3, 0, 3, 1, 2, 1。图22-1显示了优化的行为，假设缓存是很三个页面。</p><p><img src="/images/OSTEP/22-1.png" alt="22-1"></p><p>在该图中，您可以看到以下操作。毫不奇怪，由于高速缓存以空状态(empty state)开始，因此前三个访问是未命中。有时将这种丢失称为<strong>冷启动丢失</strong>(cold-start miss)（或强制丢失, compulsory miss）。然后，我们再次引用页面0和1，它们都在缓存中命中。最后，我们遇到另一个未命中的问题(page 3)，但这次缓存已满。必须进行替换！我们应该替换哪个页面？使用最佳策略，我们检查缓存中当前每个页面的未来(0, 1, 2)，发现几乎立即要访问0，稍后再访问1，将来访问最远的2。因此，最佳策略有一个简单的选择：逐出2，在缓存中生成0, 1, 3。接下来的三个引用会命中，但随后我们转到了之前逐出的2，但遭到了另一个丢失。在这，最佳策略再次检查缓存中每个页面(0, 1, 3)的未来，并发现只要不逐出页面1（将要访问的页面）就可以了。该示例显示page 3被驱逐，尽管page 0也是一个不错的选择。最后，我们命中page 1，追踪完成。</p><p>我们还可以计算缓存的命中率：6 hits and 5 misses， <code>6/(6+5)=54.5%</code>。您还可以计算强制丢失的命中率（即，忽略给定页面的第一个丢失），得出的命中率为85.7%。</p><p>不幸的是，正如我们之前在指定调度策略中所看到的那样，未来并不为人所知。您无法为通用操作系统构建最佳策略。因此，在指定实际的、可部署的策略时，我们将集中于找到其它方法来确定要逐出哪个页面。因此，最优策略将仅用作比较，以了解我们与完美的距离。</p><p><br></p><blockquote><p>TIP: COMPARING AGAINST OPTIMAL IS USEFUL<br>Although optimal is not very practical as a real policy, it is incredibly useful as a comparison point in simulation or other studies. Saying that<br>your fancy new algorithm has a 80% hit rate isn’t meaningful in isolation; saying that optimal achieves an 82% hit rate (and thus your new approach is quite close to optimal) makes the result more meaningful and gives it context. Thus, in any study you perform, knowing what the optimal is lets you perform a better comparison, showing how much improvement is still possible, and also when you can stop making your policy better, because it is close enough to the ideal.</p></blockquote><p><br></p><blockquote><p>ASIDE: TYPES OF CACHE MISSES<br>In the computer architecture world, architects sometimes find it useful to characterize misses by type, into one of three categories: compulsory, capacity, and conflict misses, sometimes called the Three C’s [H87]. A compulsory miss (or cold-start miss [EF78]) occurs because the cache is<br>empty to begin with and this is the first  eference to the item; in contrast, a capacity miss occurs because the cache ran out of space and had to evict an item to bring a new item into the cache. The third type of miss (a conflict miss) arises in hardware because of limits on where an item can be placed in a hardware cache, due to something known as setassociativity; it does not arise in the OS page cache because such caches are always fully-associative, i.e., there are no restrictions on where in memory a page can be placed. See HP for details [HP06].</p></blockquote><p><br><br><br></p><h3 id="先进先出策略"><a href="#先进先出策略" class="headerlink" title="先进先出策略"></a>先进先出策略</h3><p>A Simple Policy: FIFO</p><p>许多早期的系统避免了尝试达到最佳状态的复杂性，并采用了非常简单的替换策略。例如，某些系统使用了<strong>先进先出</strong>(first-in, first-out FIFO)替换，将页面在进入系统时仅放入队列中。当发生替换时，队列尾部的页面（先进入的页面）将被逐出。FIFO具有强大的优势：实现起来非常简单。FIFO有一个强大的优势：实现起来非常简单。让我们研究一下FIFO在引用流中的作用，如图2-2。</p><p><img src="/images/OSTEP/22-2.png" alt="22-2"></p><p>我们再次从三个强制性丢失开始追踪，分别指向page 0, 1, 2，然后同时命中0和1。接下来，引用3，从而导致丢失。使用FIFO可以很容易地决定替换：选择作为先进入的第一个页面(page 0)。不幸的是，我们的下一个访问页面是page 0，从而导致另一个丢失和替换。然后，我们在3上命中，但在1和2上丢失，最后在3上命中。</p><p>将FIFO与最优进行比较，FIFO明显更糟：命中率为36.4%（不包括强制性丢失为57.1%）。先进先出根本无法确定块的重要性：即使page 0已被访问过多次，但FIFO仍将其踢出去，原因仅在于它是第一个进入内存的页面。</p><p><br></p><blockquote><p>ASIDE: BELADY’S ANOMALY<br>Belady (of the optimal policy) and colleagues found an interesting reference stream that behaved a little unexpectedly [BNS69]. The memoryreference stream: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5. The replacement policy they were studying was FIFO. The interesting part: how the cache hit rate changed when moving from a cache size of 3 to 4 pages.<br>In general, you would expect the cache hit rate to increase (get better) when the cache gets larger. But in this case, with FIFO, it gets worse! Calculate the hits and misses yourself and see. This odd behavior is generally referred to as Belady’s Anomaly (to the chagrin of his co-authors).<br>Some other policies, such as LRU, don’t suffer from this problem. Can you guess why? As it turns out, LRU has what is known as a stack property [M+70]. For algorithms with this property, a cache of size N + 1 naturally includes the contents of a cache of size N. Thus, when increasing the cache size, hit rate will either stay the same or improve. FIFO and Random (among others) clearly do not obey the stack property, and thus are susceptible to anomalous behavior.</p></blockquote><p><br><br><br></p><h3 id="其它简单策略：随机"><a href="#其它简单策略：随机" class="headerlink" title="其它简单策略：随机"></a>其它简单策略：随机</h3><p>Another Simple Policy: Random</p><p>另一个类似的替换策略是<strong>随机</strong>(Random)，它只是在内存压力下仅选择一个随机页面进行替换。随机具有类似于FIFO的属性，实施起来很简单，但是在选择块驱逐时并没有太聪明。让我们看一下随机策略的效果，如图22-3。</p><p><img src="/images/OSTEP/22-3.png" alt="22-3"></p><p>当然，随机策略的表现完全取决于随机在其选择中的幸运度（或，不幸运度）。实际上，我们可以运行随机策略数千次，并确定其总体性能图22-4显示了随机进行一万多次实验的命中次数，每个实验都有不同的随机种子。如您所见，有时随机策略的效果最佳，有时效果会更差。随机策略的表现取决于抽奖的运气。</p><p><img src="/images/OSTEP/22-4.png" alt="22-4"></p><p><br><br><br></p><h3 id="使用历史记录"><a href="#使用历史记录" class="headerlink" title="使用历史记录"></a>使用历史记录</h3><p>Using History: LRU(Least Rcently Used)</p><p>不幸的是，任何诸如FIFO或Random这样简单的策略都有可能会遇到一个普遍的问题：它可能会剔出一个重要的页面，该页面将再次被引用。FIFO踢出最先进入的页面，如果此页面上恰好有重要代码或数据结构，则无论如何都会被扔掉，即使它很快会被重新分页。因此，FIFO、Random和其它类似策略不太可能达到最佳状态。需要更聪明的东西。</p><p>与调度策略一样，为了提高对未来的猜测，我们再次依赖过去(past)，并以历史(history)为指导。例如，如果某个程序在近期访问过某个页面，则很可能在不久的将来再次访问该页面。</p><p>页面替换策略可以使用的一种历史信息是频率(frequency)。如果某个页面已被多次访问，则可能不应该替换该页面，因为它显然具有某些价值。页面最常用的属性是页面的访问频率。访问页面的时间越近，也许再次访问该页面的可能性就越大。</p><p>这一系列策略基于人们所说的本地性原则(principle of locality)，基本上只是对程序及其行为的观察。这个原理的意思很简单，就是程序倾向于非常频繁地访问某些代码序列和数据结构。因此，我们应尝试使用历史记录找出哪些页面很重要，并在驱逐时间(eviction time)将这些页面保留在内存中。</p><p>因此，诞生了一系列简单的基于历史的算法。<strong>最不常使用</strong>(Least Frenquently Used, LFU)策略将在必须进行逐出时替换最不常用的页面。同样，<strong>最近最少使用</strong>(Least Recently Used, LRU)策略替换了最近最少使用的页面。这些算法很容易记住，一旦知道名词，就确切知道它的作用。</p><p>为了更好地了解LRU，让我们检查一下LRU的表现。如图22-5。从图中可以看到，LRU如何使用历史记录来比无状态策略（如FIFO、Random）做得更好。</p><p><img src="/images/OSTEP/22-5.png" alt="22-5"></p><p>我们还应注意到，这些算法存在相反的情况：<strong>最常用</strong>(Most Frequently Used, MFU)和<strong>最近使用</strong>(Most Recently Used, MRU)。在大多数情况下，这些策略效果不佳，因为它们忽略了大多数程序所展示的位置，而不是拥抱(embracing)它。</p><p><br></p><blockquote><p>ASIDE: TYPES OF LOCALITY<br>There are two types of locality that programs tend to exhibit. The first is known as spatial locality, which states that if a page P is accessed, it is likely the pages around it (say P − 1 or P + 1) will also likely be accessed. The second is temporal locality, which states that pages that have been accessed in the near past are likely to be accessed again in the near future. The assumption of the presence of these types of locality plays a large role in the caching hierarchies of hardware systems, which deploy many levels of instruction, data, and address-translation caching to help programs run fast when such locality exists.<br>Of course, the principle of locality, as it is often called, is no hard-andfast rule that all programs must obey. Indeed, some programs access memory (or disk) in rather random fashion and don’t exhibit much or any locality in their access streams. Thus, while locality is a good thing to keep in mind while designing caches of any kind (hardware or software), it does not guarantee success. Rather, it is a heuristic that often proves useful in the design of computer systems.</p></blockquote><p><br><br><br></p><h3 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a>工作负载</h3><p>Workload Examples</p><p>让我们再看几个栗子，以更好地理解其中一些策略的行为。在这里，我们将研究更复杂的工作负载，而不是细小的痕迹。但是，即使是这些工作量也大大简化。更好的研究应该包括应用程序追踪。</p><p>我们的第一个工作负载没有局部性，这意味着每个引用都是针对所访问页面集合的随机页面。在这个简单示例中，工作负载会随着时间访问100个唯一的页面，选择下一个页面进行随机引用。总共访问一万个页面。在实验中，我们将缓存大小从很小(1)更改为足以容纳所有唯一页面(100)，以查看每种策略在缓存大小范围内的行为。</p><p><img src="/images/OSTEP/22-6.png" alt="22-6"></p><p>图22-6显示了最优、LRU、Random、FIFO的实验结果。我们可从图中得出许多结论。首先，当工作负载没有局限性时，使用哪种实际策略都无关紧要。它们都执行相同的操作，命中率完全由缓存的大小确定。其次，当缓存足够大以适合整个工作负载时，使用哪种策略页无关紧要。当所有引用的块都放入高速缓存中时，所有策略都收敛到100%的命中率。最后，您可以看到最优执行比实际策略要好得多。</p><p>我们检查的下一个工作负载称为80-20工作负载，它有局部性：80%的引用指向20%的页面(the hot pages)，区域20%的引用指向其余80%的页面(the cold pages)。在我们的工作量中，共有100个唯一页面。因此，热页面是大多数时候都引用的页面，冷页面是其余页面。图22-7显示了策略在此工作负载下的执行情况。</p><p><img src="/images/OSTEP/22-7.png" alt="22-7"></p><p>从图中可以看出，尽管Random和FIFO都表现不错，但LRU表现更好，因为它更有可能保留在热页面上。由于这些页面在过去经常被引用，因此它们可能会在不久的将来在此被引用。优化策略再一次做的更好，表明LRU的历史的并不完美。</p><p>您现在可能想知道：LRU对Random和FIFO的改进真的有那么大的意义吗？答案通常是取决于情况。如果每个丢失的代价都很高（并不罕见），那么命中率的小幅度提高也会对性能产生巨大的影响。如果丢失不是那么昂贵，那么LRU可能带来的好处当然就不那么重要了。</p><p>让我们来看一个最终的工作负载，我们称其为<strong>循环顺序</strong>(looping sequential)工作负载 ，其中，我们依次引用了50个页面，从0、1…一直到49。然后我们循环、重复进行这些访问。总共一万次访问50个唯一页面。图22-8的最后一个图显示了此工作负载下的行为。</p><p><img src="/images/OSTEP/22-8.png" alt="22-8"></p><p>在许多应用程序中常见的这种工作量对于LRU和FIFO都是最坏的情况。在循环顺序的工作量下，这些算法会淘汰旧页面。不幸的是，由于工作负载的循环性质，这些旧页面的访问时间将比策略希望保留在缓存中的页面要早。确实，即使使用大小为49的缓存，循环顺序的50页工作负载也导致命中率为0%。有趣的是，Random明显更好，没有达到最佳状态，但至少达到了非零的命中率。事实证明，Random有一些不错的特性。这样的属性之一就是没有奇怪的极端情况行为。</p><p><br><br><br></p><h3 id="实施历史算法"><a href="#实施历史算法" class="headerlink" title="实施历史算法"></a>实施历史算法</h3><p>Implementing Historical Algorithms</p><p>如您所见，诸如LRU之类的算法通常可以比诸如FIFO或Random之类的简单策略做的更好，后者可能会抛出重要页面。不幸的是，历史记录策略给我们带来了新的挑战：我们如何执行它们？</p><p>以LRU为例。要完美实现它，我们需要做很多工作。具体而言，在每次页面访问(page access)时，我们都必须更新某些数据结构，以将该页面移至列表的开头。将此与FIFO进行对比，仅当逐出页面或将新页面添加到列表中时，才访问FIFO页面列表。为了追踪使用最少的页面、最近使用的页面，系统必须对每个内存引用(every memory reference)进行一些统计工作。显然，如果不加小心，这种统计可能会大大降低性能。</p><p>可以帮助加快速度的一种方法是添加一点硬件支持。例如，一台机器可以在每次访问页面时更新内存中的时间字段。因此，当访问页面时，硬件将当前时间设置为时间字段的值。然后，在替换页面时，操作系统可以简单地扫描系统中的所有时间字段以找到最近最少使用的页面。</p><p>不幸的是，随着系统中页面数量的增长，扫描大量的时间来查找最近最少使用的绝对页面的成本过高。想象一下，一台具有4GB内存的现代机器，它被切成4KB的页面，这台机器有100万页面。即使在现代CPU速度下，查找LRU也将花费很长时间。我们真的需要找到绝对最旧的页面来替换吗？我们可以近似地生存吗？</p><p><br></p><blockquote><p>CRUX: HOW TO IMPLEMENT AN LRU REPLACEMENT POLICY<br>Given that it will be expensive to implement perfect LRU, can we approximate it in some way, and still obtain the desired behavior?</p></blockquote><p><br><br><br></p><h3 id="近似地LRU"><a href="#近似地LRU" class="headerlink" title="近似地LRU"></a>近似地LRU</h3><p>Approximating LRU</p><p>事实证明，答案是肯定的：从计算开销的角度来看，近似地LRU更可行，而实际上这是许多现代系统所做的。这个想法需要硬件支持，使用位(use bit)（有时称为参考位(reference bit)）的形式。系统每页有一个使用位，这些使用位生活在内存中的某个位置（它们可以在每个进程的分页表中，也可以仅在数组中的某个位置）。每当引用页面时，使用位都会由硬件设置位1.尽管硬件也不会清除该位。这是操作系统的责任。</p><p>操作系统如何用使用位(use bit)来近似LRU？可能有很多方法，但是对于<strong>时钟算法</strong>(clock algorithm)，建议一种简单的方法。想象一下以循环列表排列的系统的所有页面。<strong>clock hand</strong>指向某个特定的页面。当必须进行替换时，操作系统会检查当前指向的page P的使用位是1还是0.如果为1，则表明页面P最近被使用过，因此不是很好的替换对象。因此，P的使用位被设置为0，并且时针增加到下一页(P+1)。该算法继续进行，直到找到设置为0的使用位，这表明该页面最近未使用过。</p><p>注意，该方法不是采用使用位来近似LRU的唯一方法。实际上，任何定期清除使用位，然后区分哪些页面的使用位是1还是0来决定替换哪个页面的方法都可以。时钟算法只是一种早期的方法，取得了一些成功，并且具有不重复扫描所有内存以查找未使用页面的优点。</p><p>时钟算法变体的行为如图22-9所示。进行替换时，此变体会随机扫描页面。当遇到参考位设置为1的页面时，清除该位（将其设置为0）。当找到参考位设置位0的页面时，将其选择为牺牲品。如您所见，尽管它的LRU效果不如LRU完美，但比完全不考虑历史记录的方法要好。</p><p><img src="/images/OSTEP/22-9.png" alt="22-9"></p><p><br><br><br></p><h3 id="脏页"><a href="#脏页" class="headerlink" title="脏页"></a>脏页</h3><p>Considering Dirty Pages</p><p>通常对时钟算法的一个小修改是对内存中的页面是否已修改的其它考虑。这样做的原因是：如果页面已被修改(dirty)，则必须将其写回磁盘以驱逐它，这很昂贵。如果尚未修改(clean)，则驱逐是免费的。物理帧可以简单地重用于其它目的，而无需额外的I/0。因此，某些虚拟内存系统更喜欢将干净的页面移出脏页。</p><p>为支持此行为，硬件应包括一个修改后的位(modified bit, 又称dirty bit)。每次写入页面时都会设置此位，因此可以将其合并到页面替换算法中。例如，可以通过更改时钟算法，以扫描未使用的页面和干净的页面以优先逐出。找不到这些，然后找到脏的未使用的页面，依此类推。</p><p><br><br><br></p><h3 id="其它虚拟内存策略"><a href="#其它虚拟内存策略" class="headerlink" title="其它虚拟内存策略"></a>其它虚拟内存策略</h3><p>Other VM Policies</p><p>页面替换不是虚拟内存子系统采用的唯一策略（尽管它可能是最重要的）。例如，操作系统还必须决定何时将页面放入内存。该策略有时称为页面选择(page selection)策略，它为操作系统提供了一些不同的选项。</p><p>对于大多数页面，操作系统仅使用<strong>按需分页</strong>(demand page)，这意味着操作系统在访问页面时将页面按需地带入内存。当然，操作系统可能会猜测将要使用一个页面，从而提前将其带入内存。这种行为称为<strong>预取</strong>(prefetching)，只有在有合理的成功机会时才应该这样做。例如，某些系统假定，如果将代码页P带入内存中，则该代码页(P+1)可能很快就会被访问，因此也应将其放入内存中。</p><p>另一个策略确定操作系统如何将页面写出到磁盘。当然，可以一次将它们写出来。但是，许多系统会在内存中收集大量待处理的写入，然后通过一次写入(更高效)将它们写入磁盘。此行为通常称为集群(clustering)或写操作的简单分组(grouping of writes)，并且由于磁盘驱动器的性质有效，因为磁盘驱动器必许多小型驱动器更有效地执行单个大型写入。</p><p><br><br><br></p><h3 id="Thrashing"><a href="#Thrashing" class="headerlink" title="Thrashing"></a>Thrashing</h3><p>Thrashing</p><p>在结束之前，我们要解决一个最后的问题：如果仅是简单地过度地使用内存，并且正在运行的进程集合的内存需求仅超过可用的物理内存时，操作系统应该怎么做？在这种情况下，系统将不断进行分页，这种情况有时被称为<strong>颠簸</strong>(thrashing)。</p><p>一些较早的操作系统具有一套相当复杂的机制，可以在发生颠簸时检测并应对颠簸。例如，给定一组进程，系统可以决定不运行进程的子集，希望减少进程的工作集(working sets)的适合内存并因此可以取得进展。这种通常被称为准入控制(admission control)的方法指出，有时做好一些工作总比尝试一次做不好所有事情要好。，这是现实生活中以及现代操作系统中经常遇到的一种情况。</p><p>一些当前的系统对内存过载(memory overload)采取了更为严格的方法。例如，某些版本的Linux在内存超额(oversubscribed)时运行<strong>out of memory killer</strong>。此守护进程选择一个内存密集型(memory intensive)进程并将其终止，从而以一种不太微妙的方式减少了内存。在成功减少了内存压力的同时，此方法可能会遇到问题。例如，如果它终止了X Server，从而使任何需要显示(display)的应用程序无法使用。</p><p><br><br><br></p><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>Summary</p><p>我们已经看到了许多页面替换策略的引入，它们是所有现代操作系统的虚拟内存子系统的一部分。现代系统对简单的LRU近似值进行了一些调整。例如，扫描电阻(scan resistance)是许多现代算法（如，ARC）的重要组成部分。它类似于LRU，但也尝试避免LRU的最坏情况行为，这在循环顺序工作负载中可以看到。因此，页面替换算法的发展还将继续。</p><p>但是，在许多情况下，随着内存访问时间和磁盘访问时间之间的差异增加，所述算法的重要性降低了。因为分页到磁盘是如此昂贵，所以频繁地分页的成本令人望而却步。因此，过度分页的最佳解决方案通常是一种简单的方法：购买更多内存。</p><p><br><br><br><br><br></p><h2 id="完整的虚拟内存系统"><a href="#完整的虚拟内存系统" class="headerlink" title="完整的虚拟内存系统"></a>完整的虚拟内存系统</h2><p>Complete Virtual Memory Systems: <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/vm-complete.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/vm-complete.pdf</a></p><p>在结束对内存虚拟化的研究之前，让我们仔细研究一下如何将整个虚拟内存系统组合在一起。我们已经看到了此类系统的关键要素，包括众多的分页表设计、与TLB的交互、确定哪些页面要保留在内存中以及哪些页面应该被踢出去的策略。但是，还有许多其它功能可以构成一个完整的虚拟内存系统，包括许多用于性能、功能和安全性的功能。</p><p><br></p><blockquote><p>THE CRUX: HOW TO BUILD A COMPLETE VM SYSTEM<br>What features are needed to realize a complete virtual memory system? How do they improve performance, increase security, or otherwise improve the system?</p></blockquote><p><br></p><p>我们将介绍两个系统来完成此操作。<br>第一个是1970年代早期开发的<strong>VAX/VMS</strong>操作系统中发现的现代虚拟内存管理器的最早示例之一。直到今天，这种系统中无数的技术和方法一直存在，因此值得研究。<br>第二个是Linux，原因显而易见。Linux是一种广泛使用的系统，可以在像电话这样的小型且功能不足的系统上有效运行，而该系统却不像现代数据中心中可扩展性最高的多核系统那样。因此，虚拟内存操作系统必须足够灵活才能在所有这些情况下成功运行。我们将讨论每个系统，以说明前面几章提出的概念如何在完整的内存管理器中结合在一起。</p><p><br><br><br></p><h3 id="VAX-VMS虚拟内存"><a href="#VAX-VMS虚拟内存" class="headerlink" title="VAX/VMS虚拟内存"></a>VAX/VMS虚拟内存</h3><p>VAX/VMS Virtual Memory</p><p>VAX-11微型计算机体系结构是由Digital Equipment Corporation(DEC)在1970年代末期引入的。在小型计算机时代，DEC在计算机行业扮演着重要的角色。该体系结构通过多种方式实现，包括VAX-11/780和较弱的VAX-11/750。</p><p>该系统称为VAX/VMS，其主要架构师之一有Dave Cutler，他后来领带开发了Microsoft Windows NT。VMS存在一个普遍的问题，那就是它可以在各种机器上运行，包括非常便宜的VAXen到同一体系结构家族中的高端机器和功能强大的机器。因此，操作系统必须具有能够在如此庞大的系统范围内运行的机制和策略。</p><p>作为一个附加问题，VMS用于隐藏体系结构某些固有缺陷的软件创新的一个很好的栗子。尽管操作系统通常依靠硬件来构建有效的抽象和错觉，但有时硬件设计人员并不能完全正确地完成所有工作。</p><p><br></p><p><strong>内存管理硬件(Memory Management Hardware)</strong></p><p>VAX-11为每个进程提供了32位虚拟地址空间，分为512-byte pages。因此，虚拟地址由23位VPN和9位偏移量组成。此外，VPN的高两位用来区分页面驻留在哪个段中。因此，如前所述，该系统是分页(paging)和分段(segmentation)的混合体。</p><p>地址空间的下半部分被称为<strong>进程空间</strong>(process space)，并且对每个进程都是唯一的。在进程空间的前半部分中(称为P0)，找到了用户程序以及向下增长的堆(heap)。在进程空间的后半部分(P1)，我们找到了向上增长的栈(stack)。<br>地址空间的上半部分称为<strong>系统空间</strong>(system space, S)，尽管仅使用了一半。受保护的操作系统代码和数据位于此处，并且操作系统以这种方式在进程之间共享。VMS设计人员的一个主要问题是VAX硬件中的页面大小极小(512Bytes)。由于历史原因而选择此大小，其基本问题是使简单的线性分页表过大。因此，VMS设计人员的首要目标之一就是确保VMS不会因分页表而淹没(overwhelm)内存。</p><p>系统通过两种方式减少了内存中压力分页表的位置(reduced the pressure page tables place)。首先，通过分段将用户地址空间分成两部分，VAX 11为每个进程的的区域(P0和P1)提供了一个分页表。因此，在栈和堆之间的地址空间的未使用部分不需要分页表空间。the base and bounds registers按预期使用。base registers保存该段的分页表地址，boungds register保存其大小（即，分页表条目的数量）。</p><p>其次，操作系统通过将用户分页表(P0和P1，因此每个进程有两个)放置在内核虚拟系统中，从而进一步降低了内存压力。因此，当分配和增加分页表时，内核会在Segment S中从自己的虚拟内存中分配空间。如果内存承受这巨大的压力，内核可以将这些分页表的分页换(out to)到磁盘上，从而使物理内存对其它用途可用。</p><p>将分页表放入内核虚拟内存(kernel virtual memory)意味着地址转换更加复杂。例如，要转换P0和P1中的虚拟地址，硬件必须首先尝试在其分页表（该进程的P0和P1）中查找该页面的分页表条目。但是，这样做，硬件可能首先必须查询系统分页表（位于物理内存中）。完成转换后，硬件可以了解分页表的页面地址，然后最终了解所需的内存访问地址。幸运的是，VAX的硬件管理的TLB使所有这些操作变得更快，这些TLB通常(希望)绕过这种费力的查找。</p><p><br></p><blockquote><p>ASIDE: THE CURSE OF GENERALITY<br>Operating systems often have a problem known as the curse of generality, where they are tasked with general support for a broad class of applications and systems. The fundamental result of the curse is that the OS is not likely to support any one installation very well. In the case of VMS, the curse was very real, as the VAX-11 architecture was realized in a number of different implementations. It is no less real today, where Linux is expected to run well on your phone, a TV set-top box, a laptop computer, desktop computer, and a high-end server running thousands of processes in a cloud-based datacenter.</p></blockquote><p><br></p><p><strong>真实的地址空间(A Real Address Space)</strong></p><p>研究VMS的一个巧妙方面是，我们可以看到如何构造真正的地址空间（如图23-1）。到目前为止，我们已经假定了一个仅包含用户代码、用户数据、用户堆的简单地址空间，但是正如我们在上面看到的，实际的地址空间要复杂的多。</p><p><img src="/images/OSTEP/23-1.png" alt="23-1"></p><p>例如，代码段从不从page 0开始。该页面被标记为不可访问(inaccessible)，以便为检测空指针(null pointer)访问提供一些支持。因此，在设计地址空间时需要考虑的一个问题是调试的支持，此处无法访问的page 0以某种形式提供了调试。</p><p>也许更重要的是，内核虚拟地址空间（即其数据结构和代码）是每个用户地址空间的一部分。在上下文切换中，操作系统将P0和P1寄存器更改为指向即将运行(soon-to-be-run)的进程的相应分页表。但是，它不会更改S base and bounds registers。因此，相同内核结构并映射到每个用户地址空间。</p><p>出于多种原因，内核被映射到每个地址空间。这种构造使内核的工作轻松。例如，当操作系统收到来自用户程序的指针（如，<code>write()</code>系统调用）时，很容易将数据从该指针复制到自己的结构中。操作系统是自然编写和编译的，无需担心其访问的数据来自何处。相反，如果内核完全位于物理内存中，则很难进行诸如将分页表的页面交换到(swap)磁盘的操作。如果给内核提供了自己的地址空间，则在用户应用程序和内核之间移动数据将再次变得复杂而痛苦。通过这种构造(construction)（现已被广泛使用），内核几乎是应用程序的库(library)，尽管它是受保护的。</p><p>关于该地址空间的最后一点与保护有关。显然，操作系统不希望用户程序读取或写入操作系统数据和代码。因此，硬件必须支持页面的不同保护级别才能启用此功能。VAX通过在分页表中的保护位中指定CPU必须处于什么特权级别才能访问特定页面来做到这一点。因此，与用户数据和代码相比，将系统数据和代码设置为更高的保护级别。试图从用户代码访问此类信息将在操作系统中生成陷阱(trap)，并且可能会终止违规进程。</p><p><br></p><blockquote><p>ASIDE: WHY NULL POINTER ACCESSES CAUSE SEG FAULTS<br>You should now have a good understanding of exactly what happens on a null-pointer dereference. A process generates a virtual address of 0, by doing something like this。<br>The hardware tries to look up the VPN (also 0 here) in the TLB, and suffers a TLB miss. The page table is consulted, and the entry for VPN 0 is found to be marked invalid. Thus, we have an invalid access, which transfers control to the OS, which likely terminates the process (on UNIX systems, processes are sent a signal which allows them to react to such a fault; if uncaught, however, the process is killed).</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p = NULL; // set p = 0</span><br><span class="line">*p = 10; // try to store 10 to virtual addr 0</span><br></pre></td></tr></table></figure><p><br></p><p><strong>页面替换(Page Replacement)</strong></p><p>VAN中的分页表条目(PTE)包含以下位：有效位(a valid bit), 保护字段(protection bit 4 bits), 修改(脏)位(modify/dirty bit), 保留给操作系统使用的字段(5 bits), 将页面的位置存储在物理内存中的物理帧号(PFN)。机敏的读者可能会注意到：没有引用位(reference bit)！因此，VMS替换算法必须在没有硬件支持的情况下确定哪些页面处于活动状态。</p><p>开发人员还担心<strong>内存消耗</strong>(memory hogs)，程序占用大量内存，并使其它程序难以运行。迄今为止，我们研究的大多数策略都容易受到这种束缚。例如，LRU是一项全局策略，它不会在进程之间公平地共享内存。</p><p><br></p><blockquote><p>ASIDE: EMULATING REFERENCE BITS<br>As it turns out, you don’t need a hardware reference bit in order to get some notion of which pages are in use in a system. In fact, in the early 1980’s, Babaoglu and Joy showed that protection bits on the VAX can be used to emulate reference bits [BJ81]. The basic idea: if you want to gain some understanding of which pages are actively being used in a system, mark all of the pages in the page table as inaccessible (but keep around the information as to which pages are really accessible by the process, perhaps in the “reserved OS field” portion of the page table entry). When a process accesses a page, it will generate a trap into the OS; the OS will then check if the page really should be accessible, and if so, revert the page to its normal protections (e.g., read-only, or read-write). At the time of a replacement, the OS can check which pages remain marked inaccessible, and thus get an idea of which pages have not been recently used.<br>The key to this “emulation” of reference bits is reducing overhead while still obtaining a good idea of page usage. The OS must not be too aggressive in marking pages inaccessible, or overhead would be too high. The OS also must not be too passive in such marking, or all pages will end up referenced; the OS will again have no good idea which page to evict.</p></blockquote><p><br></p><p>为了解决这两个问题，开发人员提出了<strong>分段FIFO替换策略</strong>(segmented FIFO)。这个想法很简单：每个进程最多可以保留在内存中的页面数称为<strong>驻留集大小</strong>(resident set size, RSS)。这些页面的每一个都保存在FIFO列表中。当进程超出其RSS时，将驱逐<strong>先进入(first-in)</strong>页面。FIFO显然不需要任何硬件的支持，因此易于实现。</p><p>当然，如我们先前所见，纯FIFO的性能不是特别好。为了提高FIFO的性能，VMS引入了两种<strong>第二机会列表</strong>(second chance lists)，在从内存中逐出页面之前先放置页面，特别是<strong>a global clean-page free list</strong>和<strong>dirty-page list</strong>。当进程P超过其RSS时，将从每个进程的FIFO中删除页面。如果是干净的(未修改)，则将其放在干净页面列表的末尾。如果是脏的(已修改)，则将其放在脏页列表的末尾。</p><p>如果另一个进程Q需要一个空闲页，它将第一个空闲页从全局干净列表中删除。但是，如果原始进程P在被回收之前在该页面上出错，则P从空闲（或脏）列表中回收该进程，从而避免了昂贵的磁盘访问。全局第二机会列表越大，分段FIFO算法对LRU的执行越接近。</p><p>VMS中使用的另一种优化还有助于克服VMS中较小的页面使用。特别是，使用如此小的页面(small pages)，交换过程中的磁盘I/O效率可能非常低，因为磁盘在进行大传输时表现更好。为了使swapping I/O更加有效，VMS添加了许多优化，但最重要的是<strong>集群</strong>(clustering)。通过集群，VMS将全局脏列表中的大批页面组合在一起，并一口气将它们写入磁盘（从而使它们干净）。在大多数现代系统中都使用集群，因为自由地将页面放置在交换空间的任何位置都可以使操作系统组页面(group pages)执行更少和更大的写入，从而提高性能。</p><p><br></p><p><strong>其它整洁的技巧(Other Neat Tricks)</strong></p><p>VMS还有另外两个现在的标准技巧：demand zero, copy on write。现在我们来描述这些惰性优化。VMS中的一种惰性形式是页面需求归零(demand zeroing of pages)。为了更好地理解这一点，让我们考虑将页面添加到地址空间的示例，如，在堆中。在幼稚的实现中，操作系统通过在物理内存中查找页面并将其归零来响应将页面添加到堆中的请求，然后将其映射到您的地址空间。但是，幼稚的实现可能会付出高昂的代价，特别是如果该页面没有被进程使用的话。</p><p>当需求归零时，将页面添加到您的地址空间后，操作系统几乎不会执行任何工作。它将在分页表中放置一个条目，标记该页不可访问。如果该进程随后读取或写入页面，则会在操作系统中产生陷阱。处理陷阱时，操作系统会注意到这实际上是零需求页面。此时，操作系统完成了查找物理页面，将其归零并将其映射到进程的地址空间所需的工作。如果该进程从不访问该页面，则可以避免所有此类工作，从而可以将需求归零。</p><p>另一个很酷的优化是写时复制(copy on write, COW)。这个想法至少可以追溯到TENEX操作系统，它很简单：当操作系统需要将页面从一个地址空间复制到另一个地址空间，而不是复制它时，它可以将页面映射到目标地址空间并在两个地址空间中将其标记为只读。如果两个地址空间都只读取该页面，则不采取进一步的措施，因此操作系统实现了快速复制，而实际上没有移动任何数据。</p><p>但是，如果其中一个地址空间确实试图写入该页面，则它将触发操作系统的陷阱。然后，操作系统注意到该页面是COW页面，因此（懒惰地）分配一个新页面，用数据填充它，将此新页面映射到故障进程的地址空间中。然后，该进程继续进行，现在具有其页面的自己的私有副本。</p><p>出于多种原因，COW很有用。当然，任何类型的共享库都可以映射写时复制到许多进程的地址空间，从而节省了宝贵的内存空间。在Unix系统中，由于<code>fork()</code>和<code>exec()</code>的语义，COW更为重要。您可能还记得，<code>fork()</code>创建了调用程序地址空间的精确副本。如果地址空间较大，则运行此类复制的速度将很慢且数据密集。更糟的是，大多数地址空间被随后对<code>exec()</code>的调用所立即覆盖，该调用将调用进程的地址空间与即将执行的程序的地址空间覆盖在一起。通过代之以执行写时复制<code>fork()</code>，操作系统避免了很多不必要的复制，从而在提高性能的同时保留了正确的语义。</p><p><br></p><blockquote><p>TIP: BE LAZY<br>Being lazy can be a virtue in both life as well as in operating systems. Laziness can put off work until later, which is beneficial within an OS for a number of reasons. First, putting off work might reduce the latency of the current operation, thus improving responsiveness; for example, operating systems often report that writes to a file succeeded immediately, and only write them to disk later in the background. Second, and more importantly, laziness sometimes obviates the need to do the work at all; for example, delaying a write until the file is deleted removes the need to do the write at all. Laziness is also good in life: for example, by putting off your OS project, you may find that the project specification bugs are worked out by your fellow classmates; however, the class project is unlikely to get canceled, so being too lazy may be problematic, leading to a late project, bad grade, and a sad professor. Don’t make professors sad!</p></blockquote><p><br><br><br></p><h3 id="Linux虚拟内存系统"><a href="#Linux虚拟内存系统" class="headerlink" title="Linux虚拟内存系统"></a>Linux虚拟内存系统</h3><p>The Linux Virtual Memory System</p><p>现在，我们将讨论Linux虚拟内存系统的一些更有趣的方面。Linux工程师解决了生产中遇到的实际问题，推动了Linux的发展。因此，大量功能已缓慢地集成到现在已完全可用的功能齐全的虚拟内存系统中。</p><p>虽然我们无法讨论Linux虚拟内存的各个方面，但我们将介绍最重要的方面，尤其是超出了经典的虚拟内存系统（如，VAX/VMS）的范围。我们还将强调Linux与旧系统之间的共性。</p><p>在本次讨论中，我们将重点介绍Linux for Intel x86。尽管Linux可以并且确实可以在许多不同的处理器结构上运行，但是x86上的Linux是其最主要和最重要的部署，因此也是我们关注的焦点。</p><p><br></p><p><strong>The Linux Address Space</strong></p><p>与其它现代操作系统一样，也与VAX/VMS类似，Linux虚拟地址空间由用户部分和内核部分组成。与其它系统一样，在上下文切换时，当前运行的用户部分的地址空间也会更改。跨进程的内核部分是相同的。与其它系统一样，在用户模式下运行的程序无法访问内核虚拟页面。只有陷入内核(trapping into the kernel)并转换为特权模式，才能访问此类内存。</p><ul><li><strong>用户部分</strong>(user portion)：user program code, stack, heap, other parts reside</li><li><strong>内核部分</strong>(kernel prtion)：kernel code, stack, heap, other parts reside</li></ul><p>在典型的32位Linux中(即具有32位虚拟地址空间的Linux)中，地址空间中的用户部分和内核部分之间的拆分发生在地址<code>0xC0000000</code>或地址空间的四分之三处。64位Linux的拆分方式相似，但略有不同。图23-2显示了典型(简化)的地址空间。</p><ul><li>用户虚拟地址范围：<code>0-0xBFFFFFFF</code></li><li>内核虚拟地址范围：<code>0xC0000000-0xFFFFFFFF</code></li></ul><p><br></p><p><img src="/images/OSTEP/23-2.png" alt="23-2"></p><p><br></p><p>Linux的一个有趣的方面是它包含两种类型的内核虚拟地址。</p><p>第一种称为<strong>内核逻辑地址</strong>(kernel logic address)。这就是您需要考虑的内核的正常虚拟地址空间。为了获得更多这种类型的内存，内核代码仅需要调用<code>kmalloc</code>。大多数内核数据结构都存在于此，例如分页表，每个进程的内核栈等等。与系统中的其它大多数内存不同，内核逻辑内存无法交换到磁盘。</p><p>内核逻辑地址最有趣的方面使它们与物理内存的连接。具体而言，内核逻辑地址与物理内存的第一部分之间存在直接映射。因此，内核逻辑地址<code>0xC0000000</code>转换为物理地址<code>0x00000000</code>，<code>0xC0000FFF</code>转换为<code>0x00000FFF</code>，依此类推。这种直接映射有两个含义。首先，在内核逻辑地址和物理地址之间来回转换很简单。因此，这些地址通常被视为确实是物理地址。第二个问题是，如果一块内存在内核逻辑地址空间中是连续的，那么它在物理内存中也是连续的。这使得内核地址空间的此部分中分配的内存适合需要连续物理内存才能正常工作的操作，例如通过目录内存访问(directory memory access, DMA)与设备之间的I/O传输。</p><p>内核地址的另一种类型是<strong>内核虚拟地址</strong>(kernel virtual address)。为了获得这种类型的内存，内核代码调用了另一个分配器<code>vmalloc</code>，该分配器返回一个指向所需大小的虚拟连续区域的指针。与内核逻辑内存不同，内核虚拟内存通常是不连续的。每个内核虚拟页面都可以映射到不连续的物理页面（因此不适合DMA）。但是，这样的内存因此更易于分配，因此可用于大型缓冲区(large buffer)，这些缓冲区中查找连续的大块物理内存将非常困难。</p><p>在32位Linux中，存在内核虚拟地址的原因是，它们使内核能够寻址超过(大约)1GB的内存。几年前，计算机的内存远少于此，并且可以访问超过1GB的内存也不成问题。但是，技术进步了，很快就需要使内核能够使用更多的内存。内核虚拟地址以及严格的从一对一映射到物理内存的断开连接使之成为可能。但是，随着向64位Linux的迁移，这一需求已不再那么紧迫，因为内核不仅限于虚地址的的最后1GB。</p><p><br></p><p><strong>分页表结构(Page Table Structure)</strong></p><p>因为我们专注于<code>x86</code>的Linux，所以我们的讨论将集中在<code>x86</code>提供的分页表结构的类型上，因为它决定了Linux可以做什么和不能做什么。如前所述，<code>x86</code>提供了一种硬件管理的多层分页表结构，每个进程一个分页表。操作系统仅在其内存中设置映射，将特权寄存器指向页面目录的开始，然后由硬件处理其余部分。如预期那样，操作系统会参与进程创建、删除、上下文切换，请确保在每种情况下，硬件MMU都使用正确的分页表来执行转换。</p><p>如上所述，近年来最大的变化可能是从32位x86到64位x86的转变。正如在VAX/VMS系统中看到的那样，32位地址空间已经存在了很长时间，并且随着技术的变化，它们最终开始真正成为程序的限制。虚拟内存使对系统进行编程变得很容易，但是对于包含许多GB内存的现代系统而言，32位已不足以引用每个内存。因此，下一个飞跃变得很必要。</p><p>移至64位地址会以预期的方式影响x86中的分页表结构。由于x86使用多级分页表，因此当前的64位系统使用四级表(four level table)。虚拟地址空间的完整64位性质尚未使用，但是仅使用了最低的48位。因此，虚拟地址可以如下查看：</p><p><img src="/images/OSTEP/64-bit-vm.png" alt></p><p>如图所示，虚拟地址的前16位未使用（因此在转换中不起作用），后12位（由于4KB页面大小）用作偏移量（直接使用，不进行转换），剩下的虚拟地址的中间36位将参与转换。地址的P1部分用于索引到最顶层的页面目录中，然后从那里开始一次转换级别，直到分页表的实际页面被P4索引为止，从而生成所需的分页表条目。</p><p>随着系统内存的增大，此庞大的地址空间的更多部分将被启用。从而导致五级分页表、六级分页表…想象一下，一个简单的分页表查找需要六级转换，只是要弄清楚某个数据在内存中的位置。</p><p><br></p><p><strong>大页面支持(Large Page Support)</strong></p><p>Intel x86允许使用多种页面大小，而不仅仅是标准的4KB页面。具体而言，最近的设计在硬件上支持2MB甚至1GB的页面。因此，随着时间的流逝，Linux逐渐发展为允许应用程序利用这些巨大的页面(huge page)。</p><p>如前所述，使用大页面会带来很多好处。从VAX/VMS中可以看出，这样做可以减少分页表中所需的映射数。页面越大，映射越少。但是，较少的分页表条目并不是大页面背后的驱动力。相反，这是更好的TLB行为和相关的性能提升。当某个进程主动使用大量内存时，它将迅速用转换填充TLB。如果这些转换是针对4KB页面的，则只能访问少量的总内存，而不会导致TLB丢失。结果是，对于在具有大量GB内存的计算机上运行的现代大内存工作负载而言，这将带来明显的性能成本。最近的研究表明，某些应用程序将其周期的10%用于服务TLB丢失。</p><p>大页面允许进程通过使用更少的TLB插槽来访问大容量内存而不会TLB丢失，因此这是主要优势。但是，巨大的页面还有其它好处：较短的TLB丢失路径，这意味着当确实发生TLB丢失时，可以更快地提供服务。此外，分配可能非常快，这虽然很小但是有时很重要。</p><p>Linux对大页面的支持的一个有趣方面是它如何逐步完成的。刚开始，Linux开发人员直到这种支持仅对少数应用程序很重要，例如对性能有严格要求的大型数据库。因此，决定允许应用程序显式请求大页面的内存分配（通过<code>mmap()</code>或<code>shmget()</code>调用）。这样，大多数应用程序将不会受到影响。</p><p>最近，由于在许多应用程序中更常见的是需要更好的TLB行为，因此，Linux开发人员增加了透明的大页面支持。启用此功能后，操作系统会自动寻找分配大型页面（通常为2MB，但在某些系统上为1GB）的机会，而无需修改应用程序。</p><p>庞大的页面并非没有代价。潜在的最大成本是内部碎片(internal fragmentation)，即页面很大但是用稀疏的页面。这种浪费形式可以用很大但很少使用的页面填充内存。交换也不适用于大页面，有时会大大放大系统的I/O数量。分配的开销也可能不好。总的来说，有一件事很清楚：4KB的页面大小可以很好地服务于系统很多年，这并不是曾经的通用解决方案。不断增长的内存需求要求我们将大页面和其它解决方案视为VM系统必要发展的一部分。Linux对这种基于硬件的技术的缓慢采用证明了即将到来的变化。</p><p><br></p><p><strong>页面缓存(The Page Cache)</strong></p><p>为了降低访问持久化存储(persistent storage)的成本，大多数系统使用积极的<strong>缓存(caching)</strong>子系统将刘翔的数据项保留在内存中。在这方面，Linux与传统操作系统没有什么不同。</p><p>Linux页面缓存(page cache)是统一的，可以从三个主要来源将页面保留在内存中。这些实体保存在页面缓存哈希表中(page cache hash table)，以便在需要所述数据时进行快速查找。</p><ul><li>内存映射文件(memory mapped files)</li><li>来自设备的文件数据(file data)和元数据(metadata)：通常通过将<code>read()</code>和<code>write()</code>调用定向到文件系统来访问</li><li>堆和栈(heap and stack)组成每个进程的页面：有时称为匿名内存(anonmous memory)，因为其下没有命名文件，而是交换空间</li></ul><p>页面缓存追踪条目是干净的还是脏的。脏数据通过后台线程(称为<code>pdflush</code>)定期写入后备存储（即，写入文件的特定文件，或为匿名区域交换空间），从而确保最终将修改后的数据写回到持久性存储。此后台活动或者在特定时间段之后进行，或者如果认为太多页面是脏页面。</p><p>在某些情况下，系统的内存不足，Linux必须确定踢出内存的页面以释放空间。为此，Linux使用修改后的<code>2Q</code>替换，我们将在此进行描述。<br>基本思想很简单：标准LRU替换是有效的，但是可以通过某些常见的访问模式来破坏。例如，如果某个进程重复访问一个大文件，则LRU会将所有其它文件踢出内存。更糟糕的是：将该文件的部分保留在内存中，因为在被踢出内存之前，它们从未被重新引用过。</p><p>Linux版本的<code>2Q</code>替换算法通过保留两个列表并在两个列表之间划分内存来解决此问题。首次访问时，页面被放在一个队列中（Linux中称为 inactive list）。重新引用该页面后，该页面将被提升到另一个队列（Linux中为active list）。当需要进行替换时，替换候选者将从不活跃列表中获取。Linux还定期将页面从活跃列表的底部移至不活跃列表，使活跃列表保持在页面高速缓存总大小的三分之二处。</p><p>Linux最好以完美的LRU顺序管理这些列表，但是，正如前面各章所讨论的那样，这样做非常昂贵。因此，与许多操作系统一样，使用LRU的近似值。</p><p>这种2Q方法的行为通常与LRU相当，但是特别地通过将周期性访问的页面限制在不活跃列表中来处理周期性大文件访问的情况。因为所述页面在被踢出内存之前从未被重新引用，所以它们不会清除活跃列表中找到的其它有用页面。</p><blockquote><p>ASIDE: THE UBIQUITY OF MEMORY-MAPPING<br>Memory mapping predates Linux by some years, and is used in many places within Linux and other modern systems. The idea is simple: by calling mmap() on an already opened file descriptor, a process is returned a pointer to the beginning of a region of virtual memory where the contents of the file seem to be located. By then using that pointer, a process can access any part of the file with a simple pointer dereference.<br>Accesses to parts of a memory-mapped file that have not yet been brought into memory trigger page faults, at which point the OS will page in the relevant data and make it accessible by updating the page table of the process accordingly (i.e., demand paging).<br>Every regular Linux process uses memory-mapped files, even the code in main() does not call mmap() directly, because of how Linux loads code from the executable and shared library code into memory. Below is the (highly abbreviated) output of the pmap command line tool, which shows what different mapping comprise the virtual address space of a running program (the shell, in this example, tcsh). The output shows four columns: the virtual address of the mapping, its size, the protection bits of the region, and the source of the mapping:<br>0000000000400000 372K r-x— tcsh<br>00000000019d5000 1780K rw—- [anon ]<br>00007f4e7cf06000 1792K r-x— libc-2.23.so<br>00007f4e7d2d0000 36K r-x— libcrypt-2.23.so<br>00007f4e7d508000 148K r-x— libtinfo.so.5.9<br>00007f4e7d731000 152K r-x— ld-2.23.so<br>00007f4e7d932000 16K rw—- [stack ]<br>As you can see from this output, the code from the tcsh binary, as well as code from libc, libcrypt, libtinfo, and code from the dynamic linker itself (ld.so) are all mapped into the address space. Also present are two anonymous regions, the heap (the second entry, labeled anon) and the stack (labeled stack). Memory-mapped files provide a straightforward and efficient way for the OS to construct a modern address space.</p></blockquote><p><br></p><p><strong>安全性和缓冲区溢出(Security And Buffer Overflows)</strong></p><p>现代VM系统(Linux, Solaris, BSD)与旧VM系统(VAX/VMS)之间最大的区别可能是现代对安全性的重视。保护一直是操作系统的一个严重问题，但是随着计算机之间比以往任何时候都更加互联，开发人员实施了各种防御性对策以阻止哪些狡猾的黑客获得对系统的控制，这不足为奇。</p><p>缓冲区溢出(buffer overflow)攻击是一种主要威胁，可以用于普通用于程序，甚至内核本身。这些攻击的目的是在目标系统中发现一个漏洞，攻击者可以利用该漏洞将任意数据注入目标的地址空间。之所以会出现这种情况，是因为开发人员(错误地)认为输入不会太长，因此(可信地)将输入复制到缓冲区。因为输入实际上太长，所以它会使缓冲区溢出，从而覆盖目标的内存。如下所示的代码可能是问题的根源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">some_function</span><span class="params">(<span class="keyword">char</span> *input)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> dest_buffer[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(dest_buffer, input); <span class="comment">// oops, unbounded copy!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在许多情况下，这样的溢出并不是灾难性的。例如，无意中给用户程序甚至操作系统造成的错误输入都可能导致崩溃，但并不糟。<br>但是，恶意程序员可以精心设计会使缓冲区溢出的输入，以便将自己的代码注入目标系统，从本质上允许他们接管并进行自己的竞标。如果在连接网络的用户程序上获得成功，则攻击者可以在受感染的系统上运行任意计算。如果在操作系统本身上获得成功，则攻击可以访问更多资源，并且是所谓的特权升级(privilege escalation)的一种形式（即，用户获得内核访问权限）。如果您无法猜测，这些都是坏事。</p><p>防止缓冲区溢出的第一个也是最简单的防御措施是防止执行在地址空间的某些区域中找到任何代码（如，栈内）。AMD在其x86版本中引入了NX bit，它是一种防御措施。它只是阻止从在相应分页表条目中设置了该位的任何页面执行。该方法可阻止攻击者注入到目标栈中的代码，从而减轻了问题。</p><p>但是，攻击者是聪明的。即使攻击者无法明确添加注入的代码，恶意代码也可以执行任意代码序列。这个想法以其一般的形式被称为<strong>面向返回的编程(return-oriented programming, ROP)</strong>，并且确实很棒。ROP背后的观察结果是，任何程序的地址空间中都有很多代码，尤其是与大量C库链接的C程序。因此，攻击者可以覆盖栈，以使当前执行功能中的返回地址指向所需的恶意指令，然后再返回指令。通过将大量小工具串在一起（即，确保每次返回都跳到下一个小工具），攻击者可以执行任意代码。</p><p>为了防御ROP，Linux添加了另一种防御，称为<strong>地址空间布局随机化(address space layout randomization, ASLR)</strong>。操作系统没有将代码、栈、堆放在虚拟地址空间内的固定位置上，而是将它们的放置位置随机化，从而使制作实现此类攻击所需的复杂代码变得颇具挑战性。因此，对易受攻击的用户程序的大多数攻击都将崩溃，但无法控制正在运行的程序。</p><p>有趣的是，您可以在实践中很容易地观察到这种随机性。这是一段在现代Linux系统上进行演示的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码只是在栈上打印处变量的(虚拟)地址。在较旧的non-ASLR系统中，该值每次都相同。但是，如下所示，该值随每次运行而变化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./random</span><br><span class="line">0x7ffd3e55d2b4</span><br><span class="line"></span><br><span class="line">prompt&gt; ./random</span><br><span class="line">0x7ffe1033b8f4</span><br><span class="line"></span><br><span class="line">prompt&gt; ./random</span><br><span class="line">0x7ffe45522e94</span><br></pre></td></tr></table></figure><p>ASLR是对用户级程序的一种有用防御措施，它还被并入内核，这是一种没有想象的功能，称为内核地址空间布局随机化(kernel address space layout randomization, KASLR)。但是，事实证明，内核可能还有更大的问题要处理。</p><p><br></p><p><strong>Other Security Problems: Meltdown And Spectre</strong></p><p>系统安全领域已经被两次新的相关攻击所颠覆。第一个称为<strong>崩溃(Meltdown)</strong>，第二个称为<strong>(Spectre)</strong>。它们是由四个不同的研究人员/工程师同时发现的，并引起了对上述计算机硬件和操作系统提供的基本保护的深切质疑。</p><p>这些攻击中每种漏洞利用的普遍缺点是，现代系统中发现的CPU会执行各种幕后花招，以提高性能。问题核心的一类技术称为<strong>推测执行(speculative execution)</strong>，其中CPU猜测将来会很快执行哪些指令，并提前开始执行它们。如果猜测正确，则程序运行速度更快；如果不是，则CPU再次尝试取消对架构状态（如，寄存器）的影响，这一次是正确的。</p><p>推测执行的问题在于，它倾向于在系统的各个部分（如，处理器缓存）中留下执行痕迹。因此，问题就来了：正如攻击者所表明的那样，这种状态会使内存的内容变得脆弱，甚至我们认为受MMU保护的内存也是如此。</p><p>因此，增加内核保护的一种方法是从每个用户进程中删除尽可能多的内核地址空间，而为大多数内核数据提供单独的内核分页表（kernel page table isolatio, KPTI)。因此，没有将内核的代码和数据结构映射到每个进程中，而是仅保留最小的最小值。当切换到内核时，现在需要切换到内核分页表。这样做可以提高安全性并避免某些攻击源，但是要付出代价：性能。切换分页表的成本很高。嗯，安全性成本：便利性和性能。</p><p>不幸的是，KPTI不能解决上面列出的所有安全问题，只是其中一些问题。而简单的解决方案（如，关闭推测）将毫无意义，因为系统运行速度会慢数千倍。因此，如果您需要系统安全，那么这是一个有趣的时代。</p><p>要真正了解这些攻击，您必须先学习很多知识。首先了解现代计算机体系结构，这是该主题的高级书籍中的内容，重点是推测以及实现该体系结构所需的所有机制。</p><p><br><br><br></p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>现在，您已经看到了两个虚拟内存系统的从上到下(top-to-bottom)的回顾。希望大多数细节都易于理解，因为您应该已经对基本机制和政策有了很好的理解。您还了解了一些关于Linux的知识，尽管它是一个又大又复杂的系统，但它继承了过去的许多好主意，其中许多我们没有余地进行详细讨论。例如，Linux在<code>fork()</code>上执行页面的惰性写时复制(lazy copy-on-write)，从而通过避免不必要的复制来降低开销。Linux还要求将页面清零（使用<code>/dev/zero</code>设备的内存映射），并具有后台交换守护进程(swapd)，它将页面交换到磁盘以减少内存压力。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="并发-1"><a href="#并发-1" class="headerlink" title="并发"></a>并发</h1><p>Concurrency</p><p><br></p><h2 id="并发和线程"><a href="#并发和线程" class="headerlink" title="并发和线程"></a>并发和线程</h2><p>Concurrency and Thread: <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/threads-intro.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/threads-intro.pdf</a></p><p>到目前为止，我们已经看到了操作系统执行的基本抽象的发展。我们已经看到了如何采用单个物理CPU并将其转变为多个虚拟CPU，从而使人们幻想同时运行多个程序。我们还看到了如何为每个进程创建大型私有虚拟内存的错觉。当操作系统确实在物理内存之间秘密地复用地址空间时，地址空间的这种抽象使每个程序的行为就好像它具有自己的内存一样。</p><p>在本章中，我们为单个正在运行的进程引入了新的抽象——<strong>线程</strong>(thread)。多线程程序具有一个以上的执行点(point of execution)（如，多台PC，每台PC都从中获取并执行），而不是我们对程序中的单个执行点的经典观点（即，从中获取并执行指令的单个PC）。也许另一种思考方式是：每个线程都非常像一个单独进程，只是有一个区别——它们共享相同的地址空间，因此可以访问相同的数据。</p><p>单线程的状态与进程的状态非常相似。它具有一个程序计数器(program conter, PC)，用于追踪程序从哪里获取指令。每个线程都有自己的专用寄存器集(private set of registers)，用于计算。因此，如果在单个处理器上运行着两个线程，当从运行的T1切换到运行另一个T2时，必须进行上下文切换(context switch)。线程之间的下上文切换与进程之间的上下文切换非常相似，因为在运行T2之前必须保存T1的寄存器状态并恢复T2的寄存器状态。我们将进程的状态保存到<strong>进程控制块</strong>(process control block, PCB)，将线程的的状态保存到<strong>线程控制块</strong>(thread control block, TCB)。但是，线程的上下文切换与进程相比，有一个主要区别：线程的地址空间保持不变（即，无需切换我们正在使用的分页表）。</p><p>线程和进程之间的另一个主要区别在于<strong>栈</strong>(stack)。在经典的地址空间的简单模型（称其为单线程进程(single-threaded process)）中，有一个栈，通常位于地址空间的底部，如图16-2左侧。但是，在多线程进程(multi-threaded process)中，每个线程都独立运行，并且当然可以调用各种例程来执行其正在执行的任何工作。不同于地址空间中的单个栈，每个线程将有一个栈。假设我们有一个多线程进程，其中有两个线程，则它的地址空间看起来有所不同，如图26-1右侧。</p><p><img src="/images/OSTEP/26-2.png" alt="26-1"></p><p>在此图中，您可以看到两个栈分布在整个进程的地址空间中。因此，我们放在栈上的任何栈分配的变量(variables)、参数(parameters)、返回值(return values)和其它内容，都放置在有时称为<strong>线程局部存储</strong>(thread-local storage)的位置，即相关线程的栈中。</p><p>您可能还会注意到，这是如何破坏我们美丽的地址空间布局的。以前，栈和堆可以独立地增长，并且在地址空间不足时会出现麻烦。在这里，我们再也不会遇到这样的情况了。幸运的是，这通常时可以的。因为栈通常不必很大（例外是在大量使用递归的程序中）。</p><p><br><br><br></p><h3 id="为什么要使用线程"><a href="#为什么要使用线程" class="headerlink" title="为什么要使用线程"></a>为什么要使用线程</h3><p>Why Use Threads?</p><p>在详细介绍线程以及编写多线程程序可能遇到的一些问题，让我们首先回答一个更简单的问题。为什么要完全使用线程？</p><p>事实证明，使用线程至少有两个主要原因。<br>第一个很简单：<strong>并行</strong>(parallelism)。想象一下，您正在编写一个非常大的数组执行操作的程序。如，将两个大数组加在一起，或者将数组中的每个元素的值增加一定量。如果仅在单处理器上运行，则任务很简单：只需执行每个操作即可。但是，如果要在具有多个处理器的系统上执行程序，则有可能通过使用处理器分别执行部分工作来大大加快此进程。将标准单线程程序转换为可在多个CPU上进行此类工作的程序的任务称为<strong>并行化</strong>(parallelization)，而使用每个CPU的线程来执行此工作是使程序在现代硬件上更快运行的自然而典型的方法。<br>第二个原因更加微妙：避免由于I/O缓慢而阻塞程序进度。想象一下，您正在编写一个执行不同类型I/O的程序：等待发送或接受消息，完成显式磁盘I/O或隐式页面错误。您的程序可能希望执行其它操作，而不是等待，包括利用CPU执行计算，甚至发出其它I/O请求。使用线程是避免阻塞(block)的一个自然方法。当程序中的一些线程等待时（即被阻塞等待I/O时），CPU调度程序可以切换到其它线程，这些线程准备好运行并可以执行一些有用的操作。线程使I/O与单个程序中的其它活动重叠，就像多程序对跨程序的进程所做的一样。结果，许多现代的基于服务器的应用程序(Web, DB…)在其实现中都使用了线程。</p><p>当然，在上述情况下，您可以使用多进程取代多线程。但是，线程共享一个地址空间，因此很容易共享数据。因此在构造这些类型的程序时自然是一个选择。对于逻辑上独立的任务、对于几乎不需要共享内存中的数据结构的任务，进程是一个更合理的选择。</p><p><br><br><br></p><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>An Example: Thread Creation</p><p>让我们来探讨一些细节。假设我们要运行一个创建两个线程的程序，每个线程执行一些独立的工作，本例中打印A或B。代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simple Thread Creation Code (t0.c)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common_threads.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, (<span class="keyword">char</span> *) arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> p1, p2;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main: begin\n"</span>);</span><br><span class="line">    Pthread_create(&amp;p1, <span class="literal">NULL</span>, mythread, <span class="string">"A"</span>);</span><br><span class="line">    Pthread_create(&amp;p2, <span class="literal">NULL</span>, mythread, <span class="string">"B"</span>);</span><br><span class="line">    <span class="comment">// join waits for the threads to finish</span></span><br><span class="line">    Pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main: end\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个线程（T1和T2）后，主线程(main thread)调用线程<code>`join()，它等待特定线程完成。它执行两次，从而确保T1和T2在最终允许主线程再次运行之前可以运行并完成。总体而言，在此运行期间使用了三个线性:</code>main<code>,</code>T1<code>,</code>T2`。</p><p>让我们检查一下这个程序的可能执行顺序。如执行图26-3中所示。</p><p><img src="/images/OSTEP/26-3.png" alt="26-3"></p><p>但是请注意，此排序不是唯一的排序。实际上，给定一系列指令，取决于调度程序决定在给定点运行哪个线程。例如，一旦创建线程，它可能立即运行，这将导致执行图26-4中所示的操作。</p><p><img src="/images/OSTEP/26-4.png" alt="26-4"></p><p>如果说调度程序决定先运行T2（即使T1是较早创建的），我们甚至还可以看到在A之前打印B。没有理由假定首先创建的线程将首先运行。图26-5显示了此最终执行顺序，其中T2在T1之前执行任务。</p><p><img src="/images/OSTEP/26-5.png" alt="26-5"></p><p>如您所见，思考线程创建的一种方法是它有点像运行函数调用。但是，系统不是先执行函数然后返回调用程序，而是为正在调用的例程创建一个新的执行线程，并且它独立于调用程序运行，可能在从创建返回之前，也有可能之后。接下来运行的内容由操作系统调度程序确定，尽管调度程序(scheduler)可能实现了一些明智的算法，但很难知道在任何给定的时间将运行什么。</p><p>从这个栗子中您还可以看出，线程使生活变得复杂。何时运行什么已经很难了！没有并发性(concurrency)，计算机就很难理解。不幸的是，并发只会使情况变得更糟。</p><p><br><br><br></p><h3 id="为什么变得更糟：共享数据"><a href="#为什么变得更糟：共享数据" class="headerlink" title="为什么变得更糟：共享数据"></a>为什么变得更糟：共享数据</h3><p>Why It Gets Worse: Shared Data</p><p>上面显示的简单线程示例对于显示线程的创建方式以及如何根据调度程序决定如何运行它们的顺序以不同的顺序运行很有用。但是，它并没有向您显示线程在访问共享数据时如何交互。</p><p>让我们想象一个简单的栗子，其中两个线程希望更新全局共享变量。代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sharing Data</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common_threads.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mythread()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Simply adds 1 to counter repeatedly, in a loop</span></span><br><span class="line"><span class="comment">// No, this is not how you would add 10,000,000 to</span></span><br><span class="line"><span class="comment">// a counter, but it shows the problem nicely.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: begin\n"</span>, (<span class="keyword">char</span> *) arg);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1e7</span>; i++) &#123;</span><br><span class="line">        counter = counter + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: done\n"</span>, (<span class="keyword">char</span> *) arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Just launches two threads (pthread_create)</span></span><br><span class="line"><span class="comment">// and then waits for them (pthread_join)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> p1, p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main: begin (counter = %d)\n"</span>, counter);</span><br><span class="line">    Pthread_create(&amp;p1, <span class="literal">NULL</span>, mythread, <span class="string">"A"</span>);</span><br><span class="line">    Pthread_create(&amp;p2, <span class="literal">NULL</span>, mythread, <span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// join waits for the threads to finish</span></span><br><span class="line">    Pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main: done with both (counter = %d)\n"</span>,</span><br><span class="line">    counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;over</span></span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c -Wall -pthread</span><br><span class="line">./main</span><br><span class="line"></span><br><span class="line">main: begin (counter = 0)</span><br><span class="line">A: begin</span><br><span class="line">B: begin</span><br><span class="line">A: done</span><br><span class="line">B: done</span><br><span class="line">main: done with both (counter = 20000000)</span><br></pre></td></tr></table></figure><p>不幸的是，即使在单个处理器上运行此代码，也不一定能够获得理想的结果。有时，我们得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br><span class="line"></span><br><span class="line">main: begin (counter = 0)</span><br><span class="line">A: begin</span><br><span class="line">B: begin</span><br><span class="line">A: done</span><br><span class="line">B: done</span><br><span class="line">main: done with both (counter = 19345221)</span><br></pre></td></tr></table></figure><p>让我们再尝试一次。计算机不应该产生确定性的结果吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br><span class="line"></span><br><span class="line">main: begin (counter = 0)</span><br><span class="line">A: begin</span><br><span class="line">B: begin</span><br><span class="line">A: done</span><br><span class="line">B: done</span><br><span class="line">main: done with both (counter = 19221041)</span><br></pre></td></tr></table></figure><p>每次运行不仅错误，而且产生不同的结果。还有一个大问题：为什么会这样？</p><p><br></p><blockquote><p>TIP: KNOW AND USE YOUR TOOLS<br>You should always learn new tools that help you write, debug, and understand computer systems. Here, we use a neat tool called a disassembler. When you run a disassembler on an executable, it shows you what assembly instructions make up the program. For example, if we wish to understand the low-level code to update a counter (as in our example), we run objdump (Linux) to see the assembly code: <code>objdump -d main</code>.<br>Doing so produces a long listing of all the instructions in the program, neatly labeled (particularly if you compiled with the -g flag), which includes symbol information in the program. The objdump program is just one of many tools you should learn how to use; a debugger like gdb, memory profilers like valgrind or purify, and of course the compiler itself are others that you should spend time to learn more about; the better you are at using your tools, the better systems you’ll be able to build.</p></blockquote><p><br><br><br></p><h3 id="问题的核心：不受控制的调度"><a href="#问题的核心：不受控制的调度" class="headerlink" title="问题的核心：不受控制的调度"></a>问题的核心：不受控制的调度</h3><p>The Heart Of The Problem: Uncontrolled Scheduling</p><p>要了解为什么会发生这种情况，我们必须了解编译器生成的代码序列，来更新<code>counter</code>。在这种情况下，我们希望简单地在计数器上添加一个<code>number(1)</code>。因此，这样做的代码序列可能看起来像这样(x86中)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov 0x8049a1c, %eax</span><br><span class="line">add $0x1, %eax</span><br><span class="line">mov %eax, 0x8049a1c</span><br></pre></td></tr></table></figure><p>本示例假定变量<code>counter</code>位于地址<code>0x8049a1c</code>。在此三个指令序列中，首先使用x86 <code>mov</code> 指令获取该地址处的内存值，并将其放入寄存器eax中。然后，执行<code>add</code>，将1(0x1)加到寄存器的内容中。最后，eax的内容存储到同一地址的内存中。</p><p>让我们想象一下，我们的两个线程之一的T1进入此代码区域，因此即将使计数器(counter)增加1。它将计数器的值（假设是50）加载到其寄存器eax中。因此，T1的<code>eax=50</code>。将其加1，因此，<code>eax=51</code>。现在，不幸的事情发生了。定时器中断关闭了(timer interrupt goes off)。因此，操作系统将当前正在运行的线程（其PC，包括eax的寄存器等）的状态保存到该线程的TCB中。</p><p>现在，更糟的事情发生了。选择运行T2，并进入相同的代码片。它同样也执行第一条指令，获取计数器的值并将其放入eax中（请记住，每个线程在运行时都有自己的专用寄存器。这些寄存器由保存和恢复它们的上下文切换代码虚拟化）。此时计数器的值仍为50，因此T2的<code>eax=50</code>。然后，假设T2执行了以下两条指令，将eax加1(<code>eax=51</code>)，然后将eax的内容保存的计数器(地址0x8049a1c)。因此，全局变量counter现在的值为51。</p><p>最后，发生另一个上下文切换，T1恢复运行。回想一下，它刚刚执行了<code>mov</code>和<code>add</code>，现在将要执行最终的<code>mov</code>指令。还记得<code>eax=51</code>。因此，最终的<code>mov</code>指令将执行，并将该值保存到内存中。计数器再次设置为51。</p><p>简而言之，发生的事情是这样的：递增counter的代码已经运行了两次，但是从50开始的counter现在仅等于51。该程序的正确版本应该是<code>counter=52</code>。</p><p>让我们看一下详细的执行追踪。对此例，假定上面的代码在内存中的地址100处加载，如下序列所示（请注意那些曾经使用过类似RISC的指令集：x86具有可变长度指令。此mov指令占用5个字节的内存，而add只有3个字节）。</p><p><img src="/images/OSTEP/26-7.png" alt="26-7"></p><p>基于这些假设，发生的情况如图26-7所示。假定counter从值50开始，并通过此示例进行追踪以确保您了解发生了什么。我们在这里展示的内容称为<strong>竞争条件(race conditon)</strong>（或，<strong>数据竞争</strong>(data race)），结果取决于代码的时序执行。如果运气不好（即，在执行中不合时宜的时刻发生上下文切换），我们会得到错误的结果。实际上，我们每次都可能得到不同的结果。因此，我们将这个结果称为<strong>不确定的</strong>(indeterminate)，而不是一个好的确定性的计算(deterministic computation)。我们习惯于从计算机中使用该确定性计算。在这种情况下，未知的输出将是什么，并且在各次运行之间确实可能有所不同。</p><p>由于执行此代码的多个线程可能会导致竞争条件，因此我们将代码称为<strong>关键部分</strong>(critical section)。关键部分是用于访问共享变量（共享资源）的一段代码，并且不得由多个线程并发执行。</p><p>我们真正想要用于此代码的是所谓的<strong>互斥</strong>(mutual exclusion)。此属性保证如果一个线程在关键部分内执行，则其它线程将无法执行。</p><p>顺便说一下，几乎所有这些术语都是由Essger Dijkstra创造的，他是该领域的先去，并由于这项工作和其它工作而获得了图灵奖(Turing Award)。</p><p><br></p><blockquote><p>TIP: USE ATOMIC OPERATIONS<br>Atomic operations are one of the most powerful underlying techniques in building computer systems, from the computer architecture, to concurrent code (what we are studying here), to file systems (which we’ll study soon enough), database management systems, and even distributed systems [L+93].<br>The idea behind making a series of actions atomic is simply expressed with the phrase “all or nothing”; it should either appear as if all of the actions you wish to group together occurred, or that none of them occurred, with no in-between state visible. Sometimes, the grouping of many actions into a single atomic action is called a transaction, an idea developed in great detail in the world of databases and transaction processing [GR92].<br>In our theme of exploring concurrency, we’ll be using synchronization primitives to turn short sequences of instructions into atomic blocks of execution, but the idea of atomicity is much bigger than that, as we will see. For example, file systems use techniques such as journaling or copyon-write in order to atomically transition their on-disk state, critical for operating correctly in the face of system failures. If that doesn’t make sense, don’t worry — it will, in some future chapter</p></blockquote><p><br><br><br></p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>The Wish For Atomicity</p><p>解决此问题的一种方法是拥有更强大的指令，只需一步即可完全完成我们需要的一切，从而消除了不及时中断的可能性。例如，如果我们有一个看起来像这样的超级指令怎么办：<code>memory-add 0x8049a1c, $0x1</code>。</p><p>假设该指令将一个值添加到内存位置，并且硬件保证其原子化执行。当指令需要执行时，它将根据需要执行更新。它不能再指令中间(mid-instrction)被中断，因为这恰恰是我们从硬件获得的保证：当发生中断时，指令要么根本没有运行，要么已经完成。没有中间状态。</p><p>原子化(atomically)，在此上下文中是指<code>as a unit</code>，有时我们将其视为<code>all or none</code>。我们想要以原子化执行这三个指令序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov 0x8049a1c, %eax</span><br><span class="line">add $0x1, %eax</span><br><span class="line">mov %eax, 0x8049a1c</span><br></pre></td></tr></table></figure><p>正如我们所说，如果只有一条指令来执行此操作，则必须发出(issue)该指令即可完成。但在一般情况下，我们不会有这样的指令。想象我们正在构建并发的B树(B-tree)，并希望对其进行更新。我们是否真的希望硬件支持B树的原子更新指令？至少在一个健全的指令集中，可能不是。</p><p>因此，我们要做的是向硬件询问一些有用的指令，在这些指令上我们可以构建通用的所谓<strong>同步原语(synchronization primitives)</strong>集。通过使用这种硬件支持，再结合操作系统的一些帮助，我们将能够构建多线程代码，以同步(synchronized)和受控制(controlled)的方式访问关键部分，从而尽管并发执行具有挑战性，但仍然可靠地产生正确的结果。非常棒，不是吗？</p><p><br></p><blockquote><p>THE CRUX: HOW TO SUPPORT SYNCHRONIZATION<br>What support do we need from the hardware in order to build useful synchronization primitives? What support do we need from the OS? How can we build these primitives correctly and efficiently? How can programs use them to get the desired results?</p></blockquote><p><br><br><br></p><h3 id="等待另一个"><a href="#等待另一个" class="headerlink" title="等待另一个"></a>等待另一个</h3><p>One More Problem: Waiting For Another</p><p>本章设置了并发问题，就好像线程之间仅发生一种交互类型一样，即访问共享变量的交互类型以及对关键部分支持原子性的需求。事实证明，出现了另一种常见的交互作用，其中一个线程必须等待另一个线程完成某些操作才能继续。例如，当进程执行磁盘I/O并使其进入睡眠状态时，就会发生这种交互。当I/O完成时，需要从休眠状态唤醒该进程，以便继续进行。</p><p>因此，在接下来的章节中，我们将不仅研究如何构建对同步原语(synchronization primitives)的支持以支持原子性，而且还将研究如何支持这种在多线程程序中常见的<strong>sleeping/waking</strong>交互机制。如果现在没有理解，没关系。当您阅读到<strong>条件变量</strong>(condition variables)章节时就会学习相关内容。</p><p><br></p><blockquote><p>ASIDE: KEY CONCURRENCY TERMS CRITICAL SECTION, RACE CONDITION, INDETERMINATE, MUTUAL EXCLUSION<br>These four terms are so central to concurrent code that we thought it worth while to call them out explicitly. See some of Dijkstra’s early work [D65,D68] for more details.<br>A critical section is a piece of code that accesses a shared resource, usually a variable or data structure.<br>A race condition (or data race [NM92]) arises if multiple threads of execution enter the critical section at roughly the same time; both attempt to update the shared data structure, leading to a surprising (and perhaps undesirable) outcome.<br>An indeterminate program consists of one or more race conditions; the output of the program varies from run to run, depending on which threads ran when. The outcome is thus not deterministic, something we usually expect from computer systems.<br>To avoid these problems, threads should use some kind of mutual exclusion primitives; doing so guarantees that only a single thread ever enters a critical section, thus avoiding races, and resulting in deterministic program outputs.</p></blockquote><p><br><br><br></p><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>Summary: Why in OS Class?</p><p>在总结之前，您可能会遇到一个问题是：为什么要在OS Class中研究它？历史(history)是一句话的答案。操作系统是第一个并发程序，并且创建了许多技术供自己使用。后来，对于多线程进程，程序员还必须考虑这些事情。</p><p>例如，假设有两个进程正在运行。假设它们都调用<code>write()</code>写入文件，并且都希望将数据追加到文件中（即，将数据添加到文件的末尾）。为此，双方都必须分配一个新块(new block)，在该块所在的文件的inode中记录该文件，并更改文件的大小以反映新的更大的大小。由于随时可能发生中断，因此更新这些共享结构(shared structures)的代码的关键部分。因此，操作系统的设计者从引入中断的一开始就不得不担心操作系统如何更新内部结构。不及时的中断会导致上述所有问题。毫不奇怪，必须使用适当的同步原语仔细地访问分页表，进程列表、文件系统结构以及几乎每个内核数据结构，以使其正常工作。</p><p><br><br><br><br><br></p><h2 id="Thread-API"><a href="#Thread-API" class="headerlink" title="Thread API"></a>Thread API</h2><p>Thread API: <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/threads-api.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/threads-api.pdf</a></p><p>本章简要介绍了Thread API的主要部分。当我们展示如何使用API时，将在后续章节中进一步解释每个部分。我们应该注意，后面的章节将以许多示例更慢地介绍锁(lock)和条件变量(condition variables)的概念。因此，本章可以更好地用作参考。</p><blockquote><p>CRUX: HOW TO CREATE AND CONTROL THREADS<br>What interfaces should the OS present for thread creation and control? How should these interfaces be designed to enable ease of use as well as utility?</p></blockquote><p><br><br><br></p><h3 id="线程创建-1"><a href="#线程创建-1" class="headerlink" title="线程创建"></a>线程创建</h3><p>Thread Creation</p><p>编写多线程程序必须要做的第一件事是创建新线程，因此必须存在某种线程创建接口(thread creation interface)。在POSIX中，这很容易：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">pthread_create(<span class="keyword">pthread_t</span>      *thread,</span><br><span class="line">         <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span><br><span class="line">               <span class="keyword">void</span>           *(*start_routie) (<span class="keyword">void</span>*),</span><br><span class="line">               <span class="keyword">void</span>           *arg);</span><br></pre></td></tr></table></figure><p>该声明可能看起来有点复杂，特别是如果您没有在C语言中使用函数指针，但实际上它还不错。有四个参数：</p><ul><li><code>thread</code>：指向<code>pthread_t</code>类型结构的指针。我们将使用此结构与线程进行交互，因此我们需要将其传递个<code>pthread_create()</code>进行初始化。</li><li><code>attr</code>：指定此线程可能具有的任何属性。一些示例包括设置栈大小，或者可能设置有关线程的调度优先级的信息。通过对<code>pthread_attr_init()</code>的单独调用来初始化属性。但是，在大多数情况下，默认设置会很好。在这种情况下，我们将简单地传入NULL值。</li><li><code>start routine</code>：第三个参数是最复杂的，但实际上只是在问：该线程应该在哪个函数开始运行？在C语言中，我们将其称为<strong>函数指针</strong>(function pointer)，它告诉我们以下内容：函数名称(start routine)，该函数名称传递了单个类型为<code>void *(start routine)</code>，并且它返回<code>void *</code>类型的值（即void pointer）。</li><li><code>arg</code>：传递给线程开始执行的函数的参数。您可能会问：为什么我们需要这些空指针？好吧，答案很简单——将void pointer用作函数start routine的参数可以使我们传入任何类型的参数。将其作为返回值允许线程返回任何类型的结果。</li></ul><p>如果此例程(routine)需要整数参数而不是void pointer，则声明将如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(..., <span class="comment">// first two args are the same</span></span></span></span><br><span class="line">                   void *(*start_routine) (int),</span><br><span class="line">                   <span class="keyword">int</span> arg);</span><br></pre></td></tr></table></figure><p>如果例程将void pointer作为参数，但返回整数，则它将如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(..., <span class="comment">// first two args are the same</span></span></span></span><br><span class="line">                   int (*start_routine) (void *),</span><br><span class="line">                   <span class="keyword">void</span> *args);</span><br></pre></td></tr></table></figure><p><br></p><p>让我们看一下下面代码的示例。在这里，我们只创建一个传递两个参数的线程，这些参数打包为我们自己定义的单个类型(<code>myart_t</code>)。线程一旦创建，就可以简单地将其参数转换为所需的类型，从而根据需要解压参数。</p><p>创建线程后，您实际上将拥有另一个活着的执行实体(live executing entity)，该实体具有其自己的调用栈(call stack)，并在与程序中所有当前现有线程相同的地址空间中运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// Creating a Thread</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125; <span class="keyword">myarg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(vid *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">myarg_t</span> *args = (<span class="keyword">myarg_t</span> *) args;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, args-&gt;a, args-&gt;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mmain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> p;</span><br><span class="line">    <span class="keyword">myarg_t</span> args = &#123; <span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc = pthread_create(&amp;p, <span class="literal">NULL</span>, mythread, $args);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="线程完成"><a href="#线程完成" class="headerlink" title="线程完成"></a>线程完成</h3><p>Thread Complete</p><p>上面的栗子显示了如何创建线程。但是，如果您要等待线程完成怎么办？您需要做一些特殊的事情才能等待线程完成。特别是，您需要调用<code>pthread_join()</code>例程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **value_ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>该例程有两个参数:</p><ul><li><code>pthread_t</code>：用于指定要等待的线程。该变量由线程创建例程初始化（当您将指向它的指针作为参数传递给<code>pthread_create()</code>）。如果保留它，则可以使用它来等待该线程终止。</li><li>第二个参数是指向您希望返回的返回值的指针。由于该例程可以返回任何内容，因此将其定义为返回指向void的指针。因为<code>pthread_join()</code>例程会更改传入参数的值，所以您需要传递指向该值的指针，而不仅仅是传递值本身。</li></ul><p>让我们看看下面的代码示例。在代码中，再次创建了一个线程，并通过<code>myarg_t</code>结构传递几个参数。要返回值，请使用<code>myret_t</code>类型。线程完成运行后，一直在<code>pthread_join()</code>例程中等待返回的主线程将返回，并且我们可以访问从线程返回的值，即<code>myret_t</code>的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Waiting for Thread Completion</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">int</span> a; <span class="keyword">int</span> b; &#125; <span class="keyword">myarg_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">int</span> x; <span class="keyword">int</span> y; &#125; <span class="keyword">myret_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">myret_t</span> *rvals = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">myret_t</span>));</span><br><span class="line">    rvals-&gt;x = <span class="number">1</span>;</span><br><span class="line">    rvals-&gt;y = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) rvals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> p;</span><br><span class="line">    <span class="keyword">myret_t</span> *rvals;</span><br><span class="line">    <span class="keyword">myarg_t</span> args = &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line">    Pthread_create(&amp;p, <span class="literal">NULL</span>, mythread, &amp;args);</span><br><span class="line">    Pthread_join(p, (<span class="keyword">void</span> **) &amp;rvals);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"returned %d %d\n"</span>, rvals-&gt;x, rvals-&gt;y);</span><br><span class="line">    <span class="built_in">free</span>(rvals);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关此示例的一些注意事项。首先，通常情况下，我们不必进行所有痛苦的参数的打包和拆包操作。例如，如果我们仅创建一个不带参数的线程，则可在创建线程时将NULL作为参数传递。通用，如果我们不关心返回值，则可以将NULL传递给<code>pthread_join()</code>。</p><p>其次，如果我们只是传递单个值（如，a long long int)，则不必将其打包为参数。下面的代码显示了一个示例。在这种情况下，生活会更简单一些，因为我们不必在结构内部打包参数和返回值。第三，我们应该注意，从线程返回值的防止必须格外小心。具体来说，永远不要返回指向该线程的调用栈(call stack)中分配的内容的指针。如果这样做，想下会发生什么？下面有一段危险的代码，它从上面示例的代码修改而来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simpler Argument Passing to a Thread</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> value = (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>) arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, value);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) (value + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> p;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> rvalue;</span><br><span class="line">    Pthread_create(&amp;p, <span class="literal">NULL</span>, mythread, (<span class="keyword">void</span> *) <span class="number">100</span>);</span><br><span class="line">    Pthread_join(p, (<span class="keyword">void</span> **), &amp;rvalue);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"returnd %lld\n"</span>, rvalue);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a dangerous piece of code</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mythread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">myarg_t</span> *args = (<span class="keyword">myarg_t</span> *) arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, args-&gt;a, args-&gt;b);</span><br><span class="line">    <span class="keyword">myret_t</span> oops; <span class="comment">// ALLOCATED ON STACK: BAD!</span></span><br><span class="line">    oops.x = <span class="number">1</span>;</span><br><span class="line">    oops.y =<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) &amp;oops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，变量oops分配在<code>mythread</code>栈上。但是，当它返回时，该值会自动释放(deallocated)（这就是为什么栈是如此易于使用的原因！）因此，将指针传递回现在释放的变量将导致各种不良结果。当然，当您尝试打印出您认为返回的值时，您可能回感到惊讶。</p><p>最后，您可能会注意到，使用<code>pthread_create()</code>创建线程，然后立即调用<code>pthread_join()</code>，是创建线程的一种很奇怪的方法。实际上，有一种更简单的方法可以完成此确切任务。它称为<strong>过程调用</strong>(produre call)。显然，我们通常会创建多个线程并等待其完成，否则根本就没有太多用途。</p><p>我们应该注意到，并非所有多线程代码都使用join routine。例如，多线程Web Server可能会创建多个工作线程，然后使用主线程无限期地接受请求并将其传递给工作线程。这样的长期存在的程序因此可能不需要join。但是，创建线程以并行执行特定任务的并行程序很可能会使用join来确保所有此类工作在退出或进入下一阶段之前完成。</p><p><br><br><br><br><br></p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>Locks: <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/threads-locks.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/threads-locks.pdf</a></p><p>从介绍到并发，我们看到了并发编程中的一个基本问题：我们希望原子地执行一系列指令，但是由于单个处理器（多处理器上同时执行多个线程）存在中断，我们不能。因此，在本章中，我们通过引入称为<strong>锁(lock)</strong>的方法来直接解决此问题。程序员用锁来注释源代码，将它们放在关键部分周围，从而确保任何这样的关键部分都像单个原子指令一样执行。</p><p><br><br><br></p><h3 id="锁的基本思想"><a href="#锁的基本思想" class="headerlink" title="锁的基本思想"></a>锁的基本思想</h3><p>Locks: The Basic Idea</p><p>例如，假设我们的关键部分如下所示，即共享变量的规范更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">balance = balance + 1;</span><br></pre></td></tr></table></figure><p>当然，其它关键部分也是可能的，例如将元素添加到链表或对共享结构进行其它更复杂的更新，但是我们现在仅继续简单的示例。要使用锁，我们在关键部分周围添加一些代码，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock_t mutex; // some globally-allocated lock &apos;mutex&apos;</span><br><span class="line">...</span><br><span class="line">lock(&amp;mutex);</span><br><span class="line">balance = balance + 1;</span><br><span class="line">unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><p>锁只是一个变量，因此要使用一个锁，您必须声明某种类型的锁变量(lock variable)（如上面的互斥锁）。这个锁变量在任何时候都保持锁的状态。它是可用的（available, unlocked or free），因此没有线程持有该锁，也没有线程获得(acquired, locked or held)，因此恰好有一个线程持有该锁，并且大概在关键部分。我们可以将其它信息存储在数据类型中，例如哪个线程持有锁，或者用于订购锁的队列，但是诸如此类的信息对于锁的用户是隐藏的。</p><p><code>lock()</code>和<code>unlock()</code>例程的语义很简单。调用例程<code>lock()</code>尝试获取锁，如果没有其它线程持有该锁（即，它是空闲的），则该线程将将获取该锁并进入关键部分。有时将此线程称为锁的<strong>所有者</strong>(owner)。如果另一个线程然后对同一个锁(示例中的mutex)调用<code>lock()</code>，则当另一个线程持有该锁时它将不会返回。这样，可以防止其它线程进入关键部分，而持有锁的第一个线程在那里。</p><p>一旦锁的拥有者调用<code>unlock()</code>，锁现在就可以再次使用了(free)。如果没有其它线程在等待锁（即，没有其它线程调用<code>lock()</code>并停留在其中），则锁的状态将简单地更改为空闲(free)。如果有等待线程（卡在<code>lock()</code>中），其中一个将通知该锁状态的变化，获取该锁，然后进入关键部分。</p><p>锁为程序员提供了对调度的最小控制量。通常，我们将线程视为由程序员创建但由操作系统以操作系统选择的任何方式计划的实体。锁将某些控制权交还给程序员。通过在一段代码周围加一个锁，程序员可以保证在该代码中活动的线程最多为一个。因此，锁有助于将传统操作系统调度的混乱转变为更加受控的活动。</p><p><br><br><br></p><h3 id="Pthread-Locks"><a href="#Pthread-Locks" class="headerlink" title="Pthread Locks"></a>Pthread Locks</h3><p>POSIX library用于锁的名称是一个<strong>互斥锁</strong>(mutex)，因为它用于提供线程之间的互斥(mutex exclusion)。即，如果一个线程在关键部分中，它会在该部分完成之前阻止其它进入。因此，当您看到以下POSIX线程代码时，您应该了解它正在执行与上述相同的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">Pthread_mutex_lock(&amp;lock); // wrapper; exits on failure</span><br><span class="line">balance = balance + 1;</span><br><span class="line">Pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><p>您可能还会在这里注意到POSIX版本传递了一个变量来锁定和解锁，因为我们使用不同的锁来保护不同的变量。这样做可以提高并发性：代替访问任何关键部分时都使用的一个大锁（粗粒度(coarse-grained)锁策略），通常可以保护不同的数据和具有不同锁的数据结构，从而可以一次将更多线程放入锁代码中（一种更细粒度(fine-grained)的方法）。</p><p><br><br><br></p><h3 id="建立锁"><a href="#建立锁" class="headerlink" title="建立锁"></a>建立锁</h3><p>Building A Lock</p><p>到目前为止，您应该从程序员的角度对锁的工作原理有所了解。但是，我们应该如何建立锁？需要什么样的硬件支持？什么样的操作系统支持？将在本章的其余部分中讨论这些问题。</p><p>要建立工作锁，我们将需要硬件和操作系统的帮助。多年以来，许多不同的硬件原语已被添加到各种计算机体系结构的指令集中。尽管我们不会研究这些指令的实现方式，但我们将如何研究如何使用它们来构建互斥锁原语。我们还将研究操作系统如何参与完成图片并使我们能够构建复杂的locking library。</p><p><br><br><br></p><h3 id="评估锁"><a href="#评估锁" class="headerlink" title="评估锁"></a>评估锁</h3><p>Evaluating Locks</p><p>在构建任何锁之前，我们应该首先了解我们的目标是什么，因此我们要问如何评估特定锁实现的功效。为了评估锁是否有效，我们应该建立一些基本标准。<br>首先是锁是否执行其基本任务，即提供互斥(mutual exclusion)。基本上，该锁是否起作用，从而防止多个线程进入关键部分。<br>第二个是<strong>公平</strong>(fairness)。争夺锁的每个线程一旦获得空闲，都可以获得公平的机会吗？另一种看待这种情况的方法是检查更极端的情况：争夺锁的线程是否在这样做的时候挨饿了(starve)，因此从不获取锁？<br>最终的标准是<strong>性能</strong>(performance)，特别是使用锁增加的时间开销。这里有一些不同的情况值得考虑。一种是不争夺的情况。当单个线程正在运行并获取和释放锁时，这样做的开销是多少？另一种情况是多个线程争用单个CPU上的锁。在这种情况下，是否存在性能问题？最后，当涉及多个CPU且每个线程争用该锁时，锁如何执行？通过比较这些不同的方案，我们可以更好地了解使用各种锁技术对于性能的影响，如下所述。</p><p><br><br><br></p><h3 id="控制中断"><a href="#控制中断" class="headerlink" title="控制中断"></a>控制中断</h3><p>Controlling Interrupts</p><p>提供互斥的最早解决方案之一是禁用关键部分的中断。此解决方案是为单处理器系统发明的。代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DisableInterrupts();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EnableInterrupts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们在单处理器系统上运行。通过在进入关键部分之前关闭中断（使用某种特殊的硬件指令），我们确保关键部分内的代码不会被中断，因此将像执行原子操作一样执行。完成后，我们重新启用中断（同样是通过硬件指令），因此程序照常进行。这种方法的主要优点是它的简单性。您当然不必太费力气，以弄清楚为什么这行得通。在不中断的情况下，线程可以确保其执行的代码将执行，并且没有其它线程会干扰它。</p><p>不幸的是，负面因素很多。首先，这种方法要求我们允许任何调用线程执行执行<strong>特权操作(privileged operation)</strong>（打开和关闭中断），并因此相信不会滥用此功能。如您所知，每当我们信任任意程序时，我们都可能会遇到麻烦。在这里，问题以多种方式表现出来：贪婪的程序可能在执行开始时调用<code>lock()</code>，从而垄断(monopolize)了处理器。更糟糕的是，一个错误或恶意的程序可能会调用<code>lock()</code>并进入一个无限循环(endless loop)。在后一种情况下，操作系统永远不会重新获得对系统的控制，并且只有一种方法：重启系统。将中断禁用作为通用同步解决方案需要对应用程序的过多信任。<br>其次，该方法不适用于多处理器。如果多个线程在不同的CPU上运行，并且每个线程都尝试进入相同的关键部分，则是否禁用中断都无关紧要。线程能够在其它处理器上运行，因此可以进入关键部分。由于多处理器现在很普遍，因此我们的通用解决方案必须做的更好。<br>第三，长时间关闭中断可能导致中断丢失，从而导致严重的系统问题。例如，如果CPU错过了磁盘设备已完成读取请求的事实。操作系统将如何知道唤醒等待读的进程？<br>最后，可能也是最不重要的，这种方法效率低下。与普通指令执行相比，屏蔽或取消屏蔽中断的代码往往会被现代CPU缓慢执行。</p><p>由于这些原因，关闭中断仅在有限的上下文中用作互斥原语。例如，在某些情况下，操作系统本身将使用中断屏蔽来确保访问其自己的数据结构时的原子性，或至少防止某些混乱的中断处理情况发生。这种用法很有意义，因为信任问题不再存在于操作系统内部，而操作系统始终信任自己以执行特权操作。</p><p><br><br><br></p><h3 id="一个失败的尝试：仅使用Loads-Stores"><a href="#一个失败的尝试：仅使用Loads-Stores" class="headerlink" title="一个失败的尝试：仅使用Loads/Stores"></a>一个失败的尝试：仅使用Loads/Stores</h3><p>A Failed Attempt: Just Using Loads/Stores</p><p>为了建立基于中断的技术，我们将不得不依靠CPU硬件机器提供的指令来建立适当的锁。首先，我们尝试使用单个标志变量来构建简单的锁。在这次失败的尝试中，我们将看到构建锁所需的一些基本思想，并看到了为什么仅使用单个变量并通过常规加载和存储访问它是不够的。</p><p>在第一次尝试中（下面代码），想法很简单：使用简单变量(标志)指示某个线程是否拥有锁。进入关键区域的第一个线程将调用<code>lock()</code>，该线程测试该标志是否等于1（这种情况下，它不等于1），然后将标志设置为1以指示该线程现在持有该锁。完成关键部分后，线程将调用<code>unlock()</code>病清除该标志，从而指示该锁已不再持有。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// A Simple Flag</span><br><span class="line"></span><br><span class="line">typedef struct __lock_t &#123; int flag; &#125; lock_t;</span><br><span class="line"></span><br><span class="line">void init(lock_t, *mutex) &#123;</span><br><span class="line">    // 0 -&gt; lock is available, 1 -&gt; held</span><br><span class="line">    mutex -&gt; flag = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lock(lock_t, *mutex) &#123;</span><br><span class="line">    while (mutex-&gt;flag == 1)  // TEST the flag</span><br><span class="line">        ; // spin-wait (do nothing)</span><br><span class="line">    mutex-&gt;flag = 1;  // now SET it!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void unlock(lock_t *mutex) &#123;</span><br><span class="line">    mutex-&gt;flag = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在第一个线程处于关键部分时另一个线程恰巧调用<code>lock()</code>，则它将仅在while循环中自旋等待(spin-wait)，以便该线程调用<code>unlock()</code>并清除标志。一旦第一个线程执行了此操作，等待线程将退出while循环，将其自身的标志设置为1，然后进入关键部分。不幸的是，代码有两个问题：一是正确性，另一个是性能。一旦习惯了并发编程，就很容易看到正确性问题。想象一下下面的代码，假定<code>flag=0</code>。</p><p>Trace: No Mutual Exclusion</p><div class="table-container"><table><thead><tr><th>Thread 1</th><th>Thread 2</th></tr></thead><tbody><tr><td><code>call lock()</code> <br> <code>while(flag == 1)</code> <br> interrupt: switch to Thread 2</td><td></td></tr><tr><td>-</td><td><code>call lock()</code> <br> <code>while(flag == 1)</code> <br> <code>flag =1;</code> <br> interrupt: switch to Thread 1</td></tr><tr><td><code>flag = 1</code>; //set flag to 1 (too!)</td></tr></tbody></table></div><p>从这种交错(interleaving)中可以看到，通过及时地(timely)（不及时地(untimely)）中断，我们可以很容易地产生一种情况——将两个线程的标志设置为1，因此两个线程都可以进如关键部分。这种行为被专业人员称为<code>bad</code>——我们显然未能提供最基本的要求：提供互斥。</p><p>性能问题是线程等待获取已持有的锁的方式：它无休止地检查标志的值，这是一种称为<strong>自旋等待(spin-wait)</strong>的技术。</p><p>自旋等待浪费时间等待另一个线程释放锁。在单处理器上浪费非常多，在单处理器上，等待者正在等待的线程甚至无法运行（至少在发生上下文切换之前）！因此，随着我们前进并开发更复杂的解决方案，我们还应该考虑避免这种浪费的方法。</p><p><br><br><br></p><h3 id="通过test-and-set建立工作自旋锁"><a href="#通过test-and-set建立工作自旋锁" class="headerlink" title="通过test and set建立工作自旋锁"></a>通过<code>test and set</code>建立工作自旋锁</h3><p>Building Working Spin Locks with Test-And-Set</p><p>由于禁用中断在多处理器上不起作用，并且由于使用loads and stores的简单方法不起作用，因此系统设计人员开始发明对锁定的硬件支持。最早的多处理器系统都提供这种支持。如今，即使对于单CPU系统，所有系统都提供这种类型的支持。</p><p>最简单的硬件支持称为<code>test and set</code>（或<code>atomic exchange</code>）指令。我们通过以下C代码片段定义<code>test and set</code>指令的作用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *old_ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *old_ptr; <span class="comment">//fetch old value at old_ptr</span></span><br><span class="line">    *old_ptr = <span class="keyword">new</span>; <span class="comment">// store 'new' into old_ptr</span></span><br><span class="line">    <span class="keyword">return</span> old; <span class="comment">// return the old value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在1960年代，Dijkstra向他的朋友们提出了并发问题，其中一位叫Dekker的数学家提出了一个解决方案。与我们在此讨论的解决方案使用特殊的硬件指令甚至是操作系统支持不同，Dekker的算法仅使用<code>loads and stores</code>。</p><p>Peterson后来完善了Dekker的方法。再一次，仅使用<code>loads and stores</code>，其思想是确保两个线程永远不会同时进入关键部分。下面是Peterson的算法（针对两个线程），看看您是否能够理解代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> turn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// indicate you intend to hold the lock 2/ 'flag'</span></span><br><span class="line">    flag[<span class="number">0</span>] = flag[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// whose turn is it? (thread 0 or 1)</span></span><br><span class="line">    turn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 'self' is the thread ID of caller</span></span><br><span class="line">    flag[self] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// make it other thread's turn</span></span><br><span class="line">    turn = <span class="number">1</span> - self;</span><br><span class="line">    <span class="keyword">while</span> ((flag[<span class="number">1</span>-self] == <span class="number">1</span>) &amp;&amp; (turn == <span class="number">1</span> - self)); <span class="comment">//spin-wait while it's not your turn</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// simply undo your intent</span></span><br><span class="line">    flag[self] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于某种原因，开发在没有特殊硬件支持的情况下工作的锁已成为一种流行，这给理论类型带来了很多需要解决的问题。当然，当人们意识到承担一点硬件支持要容易得多时，这一工作就变得毫无用处。此外，由于宽松的内存一致性模型，上述算法无法在现代硬件上运行。因此，它们的功能比以前更加有用。</p><p><code>test and set</code>指令的作用如下。它返回<code>old_ptr</code>指向的旧值，并同时将该值更新为<code>new</code>。当然，关键是此操作是原子执行的。之所以称之为<code>test and set</code>，是因为它使您可以测试旧值，同时将内存位置设置为新值。事实证明，此功能稍强的指令足以构建一个简单的自旋锁(spin-lock)，如下面代码所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0: lock is available, 1: lock is held</span></span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保我们了解此锁的作用。首先想象一下一个线程调用<code>lock()</code>而当前没有其它线程持有该锁的情况。因此，标志应为0。当线程调用<code>TestAndSet(flag, 1)</code>时，例程将返回flag的旧值，即0。因此，正在测试flag值的调用线程不会在while循环中被不获，而将获得锁。该线程还将原子地将该值设置为1，从而指示该锁现在已被持有。当线程的关键部分结束时，它将调用<code>unlock()</code>将标志设置回零。</p><p>第二种情况是，一个线程已经持有了锁（即标志为1）。在这种情况下，该线程将调用<code>lock()</code>，然后也调用<code>TestAndSet(flag, 1)</code>。这次，<code>TestAndSet()</code>将在标志处返回旧值(1)（因为持有了锁），同时将其再次设置为1。只要锁由另一个线程持有，<code>TestAndSet()</code>将重复返回1，因此该线程自旋，知道最终释放该锁为止。当该标志最终被其它某个线程设置为0时，该线程将再次调用<code>TestAndSet()</code>，该调用现在将返回0，同时原子地将值设置为1，从而锁定并进入临界区。</p><p>通过将测试(旧锁值)和设置(新值)都将女性单个原子操作，我们确保只有一个线程获得该锁。这就是建立有效的互斥原语的方法。</p><p>您现在也可以理解为什么通常将这种类型的锁称为自旋锁(spin lock)。它是最简单的锁类型，可以使用CPU周期简单地自旋，直到锁可用。为了在单个处理器上正常工作，它需要一个抢<strong>先式调度程序</strong>(preemptive scheduler)（即，一个调度程序将通过计时器中断线程，以便不时运行另一个线程）。没有抢占，自旋锁在单个CPU上就没有多大意义，因为在CPU上旋转的线程永远不会放弃它。</p><p><br></p><blockquote><p>TIP: THINK ABOUT CONCURRENCY AS A MALICIOUS SCHEDULER<br>From this example, you might get a sense of the approach you need to take to understand concurrent execution. What you should try to do is to pretend you are a malicious scheduler, one that interrupts threads at the most inopportune of times in order to foil their feeble attempts at building synchronization primitives. What a mean scheduler you are! Although the exact sequence of interrupts may be improbable, it is possible, and that is all we need to demonstrate that a particular approach does not work. It can be useful to think maliciously! (at least, sometimes)</p></blockquote><p><br><br><br></p><h3 id="评估自旋锁"><a href="#评估自旋锁" class="headerlink" title="评估自旋锁"></a>评估自旋锁</h3><p>Evaluating Spin Locks</p><p>有了基本的自旋锁，我们现在就可以评估先前描述的轴(zxes)的有效性。锁最重要的方面是<strong>正确性(correctness)</strong>：它是否提供互斥？答案是肯定的：自旋锁一次仅允许单个线程进入关键部分。因此，我们有一个正确的锁。</p><p>下一个轴是<strong>公平性(fairness)</strong>。自旋锁对正在等待的线程有多公平？您能否保证等待的线程会进入关键部分？不幸的是，答案是个坏消息：自旋锁不提供任何公平性保证。实际上，在争用的情况下，自旋锁可能会永远自旋。简单的自旋锁是不公平的，可能会导饥饿(starvation)。</p><p>最终的轴是<strong>性能(performance)</strong>。使用自旋锁的开销是多少？为了更仔细地分析这一点，我们建议考虑一些不同的情况。首先，想象一下线程争夺单个处理器上的锁；其次，考虑线程分布在多个CPU上。</p><p>对于自旋锁，在单CPU的情况下，性能开销可能会非常痛苦。设想在关键部分内抢占持有锁的线程的情况。然后，调度程序可能会运行其它所有线程（假设，还有N-1个线程），每个线程都试图获取锁。在这种情况下，这些线程中的每个线程都会在放弃CPU之前的一段时间内自旋，这浪费了CPU周期。</p><p>但是，在多个CPU上，自旋锁运行的很好（如果线程数大致等于CPU数）。思路如下：设想CPU1上的线程A与CPU2上的线程B都在争夺锁。如果线程A(CPU1)抓住了锁，然后线程B(CPU2)尝试这样做，则B将自旋。但是，假设关键部分很短，因此很快就可以使用该锁，并被线程B获取。在这种情况下，自旋等待另一个处理器上持有的锁不会浪费很多周期，因此很有效。</p><p><br><br><br></p><h3 id="Compare-And-Swap"><a href="#Compare-And-Swap" class="headerlink" title="Compare-And-Swap"></a>Compare-And-Swap</h3><p>一些系统提供的另一种硬件原语称为<code>compare-and-swap</code>(在SPARC上)或<code>compare-and-exchange</code>(在x86上)指令。下面是该指令的C伪代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare and swap</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> expected, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> original = *ptr;</span><br><span class="line">    <span class="keyword">if</span> (original == expected)</span><br><span class="line">        *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> original;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compare and swap</code>的基本思想是测试<code>ptr</code>地址处的值是否等于<code>expected</code>。如果是，请使用新值更新ptr指向的内存地址。如果不是，什么也不做。无论哪一种情况，都应在该内存位置返回原始值，从而使调用<code>compare-adn-swap</code>的代码知道其是否成功。</p><p>使用<code>compare-and-swap</code>指令，我们可以以<code>test-and-set</code>非常相似的放肆构建锁。例如，我们可将上面的<code>lock()</code>例程替换为一下内容:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (CompareAndSwap(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余代码与<code>test-and-set</code>示例相同。它只是检查标志是否为0，如果是，则原子地交换为1，从而获得锁。试图在持有锁的同时获取锁的线程将卡住，知道锁最终被释放。<br>最后，您可能已经感觉到了，<code>compare-and-swap</code>比<code>test-and-set</code>更强大。将来，当我们简要研究诸如<strong>lock-free synchronization</strong>之类的主题时，我们将利用这种功能。但是，如果仅使用它构建一个简单的自旋锁，则其行为与我们上面分析的自旋锁相同。</p><p><br><br><br></p><h3 id="Load-Linked-and-Store-Conditional"><a href="#Load-Linked-and-Store-Conditional" class="headerlink" title="Load-Linked and Store-Conditional"></a>Load-Linked and Store-Conditional</h3><p>一些平台提供了一对协同工作的指令，以帮助构架关键部分。例如，在MIPS架构上，可使用<code>load-linked</code>和<code>store-conditional</code>指令来构建锁和其它并发结构。这些指令的C伪代码如下所示。Alpha、PowerPC、ARM提供类似的指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load-linked And Store-conditional</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadLinked</span><span class="params">(<span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StoreConditional</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (no update to *ptr since LoadLinked to <span class="keyword">this</span> address) &#123;</span><br><span class="line">        *ptr = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// success!</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// failed to update</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>load-linked</code>的操纵非常类似于典型的<code>load</code>指令，并仅从内存中获取一个值并将其放置在寄存器中。关键的区别在于<code>store-conditional</code>，只有在没有发生中间存储到地址的情况下，该条件才会成功（并更新存储在刚刚<code>load-linked</code>的地址上的值）。如果成功，则存储条件返回1并将<code>ptr</code>处的值更新为<code>value</code>，如果失败，则不会更新<code>ptr</code>的值，并返回0。</p><p>作为对自己的挑战，请尝试考虑如何使用<code>load-linked</code>和<code>store-confitional</code>的方式构建锁。完成后，查看下面的代码。改代码提供了一种简单的解决方案，如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using LL/SC To Build A Lock</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (LoadLinked(&amp;lock-&gt;flag) == <span class="number">1</span>); <span class="comment">// spin until it's zero</span></span><br><span class="line">        <span class="keyword">if</span> (StoreConditional(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// if set-it-to-1 was success: all done</span></span><br><span class="line">                    <span class="comment">// otherwise: try it all over again</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span>, *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lock()</code>代码是唯一有趣的部分。首先，线程自旋以等待将标志设置为0（从而指示为持有该锁）。一旦这样，线程尝试通过存储条件获取锁。如果成功，则该线程自动将标志的值更改为1，因此可以进入关键部分。</p><p>请注意<code>store-conditional</code>的失败可能如何发生。一个线程调用<code>lock()</code>并执行<code>load-linked</code>，由于未持有该锁，因此返回0。在尝试<code>store-conditional</code>之前，它被中断，另一个线程进入锁代码，同时执行<code>load-linked</code>指令，并获得0并继续。在这一点上，两个线程已经执行了<code>load-linked</code>，并且每个线程都将尝试执行<code>store-conditional</code>。这些指令的关键特征是这些线程中只有一个可以成功将标志更新为1，从而获得锁。第二个尝试尝试<code>store-conditional</code>的线程将失败（因为另一个线程更新了其load-linked和store-conditional之间的标志的值），因此必须尝试再次获取该锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (LoadLinked(&amp;lock-&gt;flag) ||</span><br><span class="line">           !StoreConditional(&amp;lock-&gt;flag, <span class="number">1</span>)); <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Fetch-And-Add"><a href="#Fetch-And-Add" class="headerlink" title="Fetch-And-Add"></a>Fetch-And-Add</h3><p>最后一个硬件原语是<code>fetch-and-add</code>指令，该指令原子地递增值，同时在特定地址返回旧值。它的C伪代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FetchAndAdd</span><span class="params">(<span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *ptr;</span><br><span class="line">    *ptr = old + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此示例中，我们将使用<code>fetch-and-add</code>来构建一个更有趣的<strong>ticket lock</strong>。代码在下面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ticket;</span><br><span class="line">    <span class="keyword">int</span> turn;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span>, *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn); <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;turn = lock-&gt;turn + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该解决方案使用单个票(ticket)和转向变量(turn variable)来组合以构建锁，而不是使用单个值。基本操作非常简单：当线程希望获取锁时，它首先对票值进行原子<code>fetch-and-add</code>，现在将该值视为该线程的转向(turn)。然后使用全局共享的<code>lock-&gt;turn</code>来确定它是哪个线程。当给定线程<code>myturn == turn</code>时，轮到线程进入关键部分。只需通过增加转向即可完成解锁，以便下一个等待线程现在可以进入关键部分。</p><p>请注意，此解决方案与我们之前的尝试有一个重要区别：它确保所有线程的进度。一旦线程分配了票值(ticket value)，它将在将来的某个时间进行调度（一旦前面的通过了关键部分并释放了锁）。在我们以前的尝试中，不存在这样的保证。即使在其它线程获得并释放锁的情况下，它也可能永远自旋。</p><p><br></p><blockquote><p>TIP: LESS CODE IS BETTER CODE (LAUER’S LAW)<br>Programmers tend to brag about how much code they wrote to do something. Doing so is fundamentally broken. What one should brag about, rather, is how little code one wrote to accomplish a given task. Short, concise code is always preferred; it is likely easier to understand and has fewer bugs. As Hugh Lauer said, when discussing the construction of the Pilot operating system: “If the same people had twice as much time, they could produce as good of a system in half the code.” [L81] We’ll call this Lauer’s Law, and it is well worth remembering. So next time you’re bragging about how much code you wrote to finish the assignment, think again, or better yet, go back, rewrite, and make the code as clear and concise as possible.</p></blockquote><p><br><br><br></p><h3 id="自旋太多：现在怎么办"><a href="#自旋太多：现在怎么办" class="headerlink" title="自旋太多：现在怎么办"></a>自旋太多：现在怎么办</h3><p>Too Much Spinning: What Now?</p><p>我们简单的基于硬件的锁很简单（只有几行代码），并且可以正常工作（您甚至可以通过编写一些代码来证明这一点），这是任何系统或代码的两个出色特性。然而，在某些情况下，这些解决方案可能效率很低。假设您在单处理器上运行两个线程。现在，想象一个线程(T0)在关键部分中，因此持有锁，不幸的是被中断了。现在，第二个线程(T1)尝试获取该锁，但发现它已被持有。因此，它开始自旋、自旋…最后，定时器中断消失，T0再次运行，从而释放锁。最后，T1不必自旋太多，就能获得锁。因此，在此情况下，每当线程陷入自旋状态时，它都会浪费时间片只检查不会改变的值，而什么都不做。随着N个线程争用锁，问题变得更加严重。可以以类似的方式浪费N-1个时间片，只需自旋并等待单个线程释放锁即可。因此，我们的下一个问题是：</p><blockquote><p>THE CRUX: HOW TO AVOID SPINNING<br>How can we develop a lock that doesn’t needlessly waste time spinning on the CPU?</p></blockquote><p>单靠硬件支持无法解决问题。我们也需要操作系统执支持！现在，让我们弄清楚这可能如何工作。</p><p><br><br><br></p><h3 id="Just-Yield"><a href="#Just-Yield" class="headerlink" title="Just Yield"></a>Just Yield</h3><p>A Simple Approach: Just Yield, Baby</p><p>硬件支持使我们走得很远：工作锁，甚至在获取锁方面的公平性。但是，我们仍然有一个问题：当关键部分发生上下文切换时，并且线程开始无休止地旋转，等待被中断的线程再次运行，该怎么办？</p><p>我们的第一个尝试是一种简单而友好的方法：当要自旋时，将CPU放弃给另一个线程。正如Davis可能说的那样，”Just yield, baby!” 下面显示了此方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock With Test-and-set And Yield</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet (&amp;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        yield();  <span class="comment">// give up the CPU</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag =  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此方法中，我们假设一个操作系统原始的<code>yield()</code>，当一个线程想要放弃CPU并让另一个线程运行时，该线程可以调用它。线程可处于三种状态（running, ready, blocked）。yield只是一个系统调用，它将调用程序从运行状态转(running)移到就绪状态(ready)，从而将另一个线程提升为运行状态。因此，yielding线程本质上使自身调度(deschedules)。</p><p>考虑一个CPU上有两个线程的例子。在这种情况下，我们基于屈服的方法效果很好。如果一个线程恰巧调用<code>lock()</code>并找到一个持有锁，则它只会屈服CPU，因此另一个线程将运行并完成起关键部分。在这种简单情况下，屈服方法效果很好。</p><p>现在，让我们考虑有很多线程（假如100个）反复争用锁的情况。在这种情况下，如果一个线程获取了该锁并在释放前被抢占，则另外的99个线程将分别调用<code>lock()</code>，找到持有锁，并屈服于CPU。假设采用某种循环调度(RR)程序，则在持有该锁的线程再次运行之前，这99个轮询程序将执行<code>run-and-yield</code>模式。尽管比我们的自旋方法方法更好（浪费99个时间片进行自旋），但这种方法仍然昂贵。上下文切换的成本可能很高，因此有很多浪费。</p><p>更糟的是，我们根本没有解决饥饿问题(starvation)。一个线程可能陷入无限的屈服循环中，而其它线程则反复进入和退出关键部分。显然，我们将需要一种直接解决此问题的方法。</p><p><br><br><br></p><h3 id="Using-Queues"><a href="#Using-Queues" class="headerlink" title="Using Queues"></a>Using Queues</h3><p>Using Queues: Sleeping Instead Of Spinning</p><p>我们以前的方法的真正问题在于它们留下了太多机会。调度程序确定下一步运行哪个线程。如果调度程序做出了错误地选择，则线程必须自旋以等待锁来运行线程（第一种方法），或立即屈服于CPU（第二种方法）。无论哪种方法，都有浪费的可能，并且无法阻止饥饿。</p><p>因此，我们必须明确地控制当前持有者释放锁之后，下一个线程将获得锁。为此，我们将需要更多的操作系统的支持，以及一个队列来跟踪哪些线程正在等待获取锁。</p><p>为了简单起见，我们将通过使用由Solaris提供支持的两个调用程序：<code>park()</code>调用线程进入睡眠状态(sleep)，<code>unpark(threadID)</code>唤醒由threadID指定的特定线程。可以串联使用这两个例程来构建一个锁，如果调用放可以使其进入睡眠状态，并在锁释放时将其唤醒。来看下下面的代码，以了解此类原语。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock With Queues, Test-and-set, Yield, And Wakeup</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">int</span> guard;</span><br><span class="line">    <span class="keyword">queue_t</span> *q;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">    m-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    queue_init(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">    whild (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line">        m-&gt;flag = <span class="number">1</span>; <span class="comment">//lock is acquired</span></span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue_add(m-&gt;q, gettid());</span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">        park();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet (&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">// acquire guard lock by spinning</span></span><br><span class="line">    <span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line">        m-&gt;flag = <span class="number">0</span>; <span class="comment">// let go of lock; no now wats it</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        unpark(queue_remove(m-&gt;q)); <span class="comment">// hold lock</span></span><br><span class="line">                                    <span class="comment">// for next thread!</span></span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>ASIDE: MORE REASON TO AVOID SPINNING: PRIORITY INVERSION<br>One good reason to avoid spin locks is performance: as described in the main text, if a thread is interrupted while holding a lock, other threads that use spin locks will spend a large amount of CPU time just waiting for the lock to become available. However, it turns out there is another interesting reason to avoid spin locks on some systems: correctness. The problem to be wary of is known as priority inversion, which unfortunately is an intergalactic scourge, occurring on Earth [M15] and Mars [R97]!<br>Let’s assume there are two threads in a system. Thread 2 (T2) has a high scheduling priority, and Thread 1 (T1) has lower priority. In this example, let’s assume that the CPU scheduler will always run T2 over T1, if indeed both are runnable; T1 only runs when T2 is not able to do so (e.g., when T2 is blocked on I/O).<br>Now, the problem. Assume T2 is blocked for some reason. So T1 runs, grabs a spin lock, and enters a critical section. T2 now becomes unblocked (perhaps because an I/O completed), and the CPU scheduler immediately schedules it (thus descheduling T1). T2 now tries to acquire the lock, and because it can’t (T1 holds the lock), it just keeps spinning. Because the lock is a spin lock, T2 spins forever, and the system is hung.<br>Just avoiding the use of spin locks, unfortunately, does not avoid the problem of inversion (alas). Imagine three threads, T1, T2, and T3, with T3 at the highest priority, and T1 the lowest. Imagine now that T1 grabs a lock. T3 then starts, and because it is higher priority than T1, runs immediately (preempting T1). T3 tries to acquire the lock that T1 holds, but gets stuck waiting, because T1 still holds it. If T2 starts to run, it will have higher priority than T1, and thus it will run. T3, which is higher priority than T2, is stuck waiting for T1, which may never run now that T2 is running. Isn’t it sad that the mighty T3 can’t run, while lowly T2 controls the CPU? Having high priority just ain’t what it used to be.<br>You can address the priority inversion problem in a number of ways. In the specific case where spin locks cause the problem, you can avoid using spin locks (described more below). More generally, a higher-priority thread waiting for a lower-priority thread can temporarily boost the lower thread’s priority, thus enabling it to run and overcoming the inversion, a technique known as priority inheritance. A last solution is simplest: ensure all threads have the same priority</p></blockquote><p><br><br><br></p><h3 id="不同的操作系统，不同的支持"><a href="#不同的操作系统，不同的支持" class="headerlink" title="不同的操作系统，不同的支持"></a>不同的操作系统，不同的支持</h3><p>Different OS, Different Support</p><p>到目前为止，我们已经看到了操作系统可以提供的一种支持，以便在线程库中建立更有效的锁。其它操作系统也提供类似的支持，细节各不相同。例如，Linux提供了一个于Solaris接口相似的<code>futex</code>，但提供了更多的内核功能。具体来说，每个<code>futex</code>都与一个特定的物理内存位置以及每个<code>futex</code>内核队列相关联。调用程序可以根据需要使用futex calls进行睡眠和唤醒工作。</p><p>具体来说，有两个调用可用。假定地址处的值等于预期值，调用<code>futex_wait(address, expected)</code>会使线程进入睡眠状态。如果不相等，则调用立即返回。调用例程<code>futex_wake(address)</code>将唤醒正在队列中等待的一个线程。Linux互斥锁中这些调用的用法如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Linux-based Futex Locks</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_lock</span> <span class="params">(<span class="keyword">int</span> *mutex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="comment">/* Bit 31 was clear, we got the mutex (the fastpath) */</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_bit_test_set (mutex, <span class="number">31</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    atomic_increment (mutex);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (atomic_bit_test_set (mutex, <span class="number">31</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            atomic_decrement (mutex);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* We have to waitFirst make sure the futex value</span></span><br><span class="line"><span class="comment">           we are monitoring is truly negative (locked). */</span></span><br><span class="line">        v = *mutex;</span><br><span class="line">        <span class="keyword">if</span> (v &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        futex_wait (mutex, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_unlock</span> <span class="params">(<span class="keyword">int</span> *mutex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Adding 0x80000000 to counter results in 0 if and</span></span><br><span class="line"><span class="comment">       only if there are not other interested threads */</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_add_zero (mutex, <span class="number">0x80000000</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* There are other threads waiting for this mutex,</span></span><br><span class="line"><span class="comment">        wake one of them up. */</span></span><br><span class="line">    futex_wake (mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nptl库(gnu libc库的一部分)中<code>lowlevellock.h</code>中的代码很有趣，原因有几个。首先，它使用单个整数来跟踪是否持有锁和锁上的等待数。因此，如果锁为负，则将其保留。其次，代码片段展示了如何针对常见情况进行优化，特别是在没有争用锁的情况下；仅使用一个线程来获取和释放锁，就完成了很少的工作。</p><p><br><br><br></p><h3 id="Two-Phase-Locks"><a href="#Two-Phase-Locks" class="headerlink" title="Two-Phase Locks"></a>Two-Phase Locks</h3><p>最后一点要注意：Linux方法具有一种古老的方法，这种方法已经使用了好几年，至少可以追溯的1960年代初期的Dahm Locks，现在称为<code>two-phase lock</code>。它意识到自旋很有用，特别是在锁即将被释放时。</p><p>因此，在第一阶段，锁自旋了一段时间，希望它可以获取锁。但是，如果在第一个自旋阶段未获取锁，则进入第二阶段，在此阶段，调用者进入睡眠状态，并且仅在以后释放锁时才唤醒。上面的Linux锁是这种锁的一种形式，但是它只会自旋一次。对此的一般化可能会在使用futex支持进入睡眠之前，在固定的时间内自旋一个循环。</p><p>两阶段锁是混合方法的又一实例，其中结合两个好主意确实可以产生更好的主意。当然，它是否确定取决于很多因素，包括硬件环境，线程数和其它工作负载详细信息。与往常一样，制作一个适用于所有可能用例的通用锁是很大的挑战。</p><p><br><br><br></p><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>上面的方法显示了如何构建真正的锁：某些硬件支持加上某些操作系统的支持。当然，细节有所不同，执行这种锁的确切代码通常经过高度调整。如果要查看更多详细信息，请查看Solaris或Linux代码库。</p><p><br><br><br><br><br></p><h2 id="基于锁的并发数据结构"><a href="#基于锁的并发数据结构" class="headerlink" title="基于锁的并发数据结构"></a>基于锁的并发数据结构</h2><p>Lock-based Concurrent Data Structures: <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/threads-locks-usage.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/threads-locks-usage.pdf</a></p><p>在离开锁之前，我们将首先介绍如何在一些常见的数据结构中使用锁。在数据结构中添加锁以使其可被线程使用，使该结构线程安全(thread safe)。当然，准确地添加此类锁的方式决定了数据结构的正确性和性能。因此，我们面临的挑战是：</p><blockquote><p>CRUX: HOW TO ADD LOCKS TO DATA STRUCTURES<br>When given a particular data structure, how should we add locks to it, in order to make it work correctly? Further, how do we add locks such that the data structure yields high performance, enabling many threads to access the structure at once, i.e., concurrently?</p></blockquote><p><br><br><br></p><h3 id="并发计数器"><a href="#并发计数器" class="headerlink" title="并发计数器"></a>并发计数器</h3><p>Concurrent Counters</p><p>计数器(counter)是最简单的数据结构之一。它是一种常用的结构，具有简单的接口。下面定义了一个简单的非并行计数器(non-concurrent counter)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Counter without Locks</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">cunter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p><strong>简单但不可扩展(Simple But Not Scalable)</strong></p><p>如您所见，非同步计数器(non-synchronized)是一个微不足道的数据结构，需要少量的代码来实现。现在，我们面临下一个挑战：如何使此代码线程安全？下面展示了我们怎样做。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Counter With Locks</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;value = <span class="number">0</span>;</span><br><span class="line">    Pthread_mutex_init(&amp;c-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    c-&gt;value++;</span><br><span class="line">    Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    c-&gt;value--;</span><br><span class="line">    Phread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">counter_t</span> *c)</span> </span>&#123;</span><br><span class="line">    Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line">    <span class="keyword">int</span> rc = c-&gt;value;</span><br><span class="line">    Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>此并发计数器很简单，并且可以正常工作。实际上，它遵循最简单和最基本的并发数据结构共有的设计模式：它仅添加一个锁，该锁在调用操纵数据结构的例程时获取，并在从调用返回时释放。以这种方式，它类似于使用监视器构建的数据结构，其中在您从对象方法调用和返回时自动获取并释放锁。至此，您已经有了一个有效的并发数据结构。您可能回遇到性能问题。如果您的数据结构太慢，则您不仅需要添加一个锁，还需要做更多的事情。因此，如有必要，此类优化是本章其余部分的主题。</p><p>为了了解这种简单方法的性能成本，我们运行了一个基准测试(benchmark)，每个线程将一个共享计数器更新固定的次数。然后，我们更改线程数。图29-5显示了总的时间花费，其中一到四线程处于活动状态。每个线程将计数器更新一百万次。该实验是在具有四个CPU的Intel 2.7GHZ i5的iMac上运行的。随着更多CPU的活动，我们希望每单位时间(per unit time)完成更多的工作。</p><p><img src="/images/OSTEP/29-5.png" alt="29-5"></p><p>理想情况下，您希望看到线程在多个处理器上完成的速度与单个线程在单处理器上完成的速度一样快。实现这一目标称为完美伸缩(perfect scaling)。即使要完成更多工作，它也是并行完成的，因此完成任务所需的时间不会增加。</p><p><br></p><p><strong>伸缩计数(Scalable Counting)</strong></p><p>令人惊讶的是，研究人员多年来研究如何构建更多可扩展的计数器。正如操作系统性能分析的最新研究结果表明的那样，可扩展计数器至关重要。如果不进行可扩展计算，Linux上运行的某些工作负载将在多核计算机上遭受严重的可扩展性问题。</p><p>已经开发出的许多技术来解决这个问题。我们将介绍一种称为近似计数器(approximate counter)的方法。<br>近似计数器的工作原理是通过多个本地物理计数器(local physical counter)（每个CPU core一个），和一个全局计数器(global counter)来表示单个逻辑计数器。具体来说，在一台具有四个CPU的计算机上，有四个本地计数器和一个全局计数器。除了这些计数器外，还有锁：每个本地计数器一个、全局计数器一个。</p><p>近似计数器的基本思想如下。当运行在给定core上的线程希望增加计数器时，它会增加其本地计数器。通过相应的本地锁同步对此本地计数器的访问。因为每个CPU都有自己的本地计数器，所以CPU上的线程可以在不争用的情况下更新本地计数器，因此该计数器的更新是可伸缩的。</p><p>但是，为了使全局计数器保持更新，通过获取全局锁并将其递增本地计数器的值，本地值会定期传输到全局计数器。然后将本地计数器归零。此本地到全局(local-to-global)传输的发生频率由阈值S决定。S越小，计数器的行为就越类似于上面的不可伸缩计数器；S越大，计数器的可伸缩性就越大，但是全局值与实际计数的距离可能越远。可以简单地获取所有本地锁和全局锁来获取确切的值，但这是不可伸缩的。</p><p>为了清楚起见，我们来看一个示例。下面的例子中，阈值S设置为5，并且四个CPU的每一个上都有线程更新其本地计数器L1…L4。追踪还显示了全局计数器值，随着时间的增加而下降。在每个时间步长，本地计数器都可以增加；如果本地值达到了阈值S，则将本地值传输到全局计数器并重置本地计数器。</p><p><img src="/images/OSTEP/29-3.png" alt="29-3"></p><p>图29-5显示了阈值S为1024的近似计数器的性能。性能出色。在四个处理器上更新计数器四百万次所花费的时间几乎不比在一个处理器上更新计数器一百万次所花费的时间高。</p><p>图29-6显示了阈值S的重要性，四个线程在四个CPU上分别使计数器递增100万次。如果S低，则性能不佳；如果S高，则性能出色，但全局计数器滞后。这种精度/性能的折衷是近似计数器实现的。</p><p><img src="/images/OSTEP/29-6.png" alt="29-6"></p><p><br></p><blockquote><p>TIP: MORE CONCURRENCY ISN’T NECESSARILY FASTER<br>If the scheme you design adds a lot of overhead (for example, by acquiring and releasing locks frequently, instead of once), the fact that it is more concurrent may not be important. Simple schemes tend to work well, especially if they use costly routines rarely. Adding more locks and complexity can be your downfall. All of that said, there is one way to really know: build both alternatives (simple but less concurrent, and complex but more concurrent) and measure how they do. In the end, you can’t cheat on performance; your idea is either faster, or it isn’t.</p></blockquote><p><br><br><br></p><h3 id="并发链接列表"><a href="#并发链接列表" class="headerlink" title="并发链接列表"></a>并发链接列表</h3><p>Concurrent Linked Lists</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OS Three Easy Pieces: &lt;a href=&quot;https://book.douban.com/subject/19973015/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://book.douban.com/subject/19973015/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OSTEP: &lt;a href=&quot;http://pages.cs.wisc.edu/~remzi/OSTEP/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://pages.cs.wisc.edu/~remzi/OSTEP/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ELRH7x86_64&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Linux" scheme="https://zhang21.github.io/tags/Linux/"/>
    
      <category term="OperatingSystem" scheme="https://zhang21.github.io/tags/OperatingSystem/"/>
    
      <category term="操作系统" scheme="https://zhang21.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Optimization" scheme="https://zhang21.github.io/tags/Optimization/"/>
    
      <category term="性能优化" scheme="https://zhang21.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Istio</title>
    <link href="https://zhang21.github.io/2019/04/26/Istio/"/>
    <id>https://zhang21.github.io/2019/04/26/Istio/</id>
    <published>2019-04-25T18:21:15.000Z</published>
    <updated>2019-04-26T06:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>Istio docs: <a href="https://istio.io/docs" target="_blank" rel="noopener">https://istio.io/docs</a></li><li>Istio中文文档: <a href="https://istio.io/zh/docs/" target="_blank" rel="noopener">https://istio.io/zh/docs/</a></li><li>Istio github: <a href="https://github.com/istio/istio" target="_blank" rel="noopener">https://github.com/istio/istio</a></li></ul><p><br></p><p>环境:</p><ul><li>RHEL7x86_64</li><li>Istio v1.1</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><a href="https://istio.io/docs/concepts/" target="_blank" rel="noopener">Concepts</a></p><p><br></p><h2 id="Istio是什么"><a href="#Istio是什么" class="headerlink" title="Istio是什么"></a>Istio是什么</h2><p><a href="https://istio.io/docs/concepts/what-is-istio/" target="_blank" rel="noopener">What is Istio?</a></p><p>Istio允许您连接(connect)，保护(secure)，控制(control)和观察(observe)服务。<br>在较高的层级上，Istio有助于降低部署的复杂性，减轻开发团队的压力。它是一个完全开源的<strong>服务网格(service mesh)</strong>，可透明地分层到现有的分布式应用程序上。它也是一个平台，包括可以将其集成到任何日志记录平台或策略系统的API。Istio的多样化功能使你能够成功，高效地运行分布式微服务(microservice)架构，并提供安全，连接和监控微服务的统一方法。</p><p><br></p><h3 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h3><p>Service Mesh</p><p>Istio解决了开发人员和运营商在单片应用程序向分布式微服务架构过渡时所面临的挑战。有必要详细了解Istio服务网格。</p><p>术语服务网格用于描述构成此类应用程序的微服务网络以及它们之间的交互。随着服务网格的大小和复杂性的增加，理解和管理变得更加困难。其要求包括:</p><ul><li><strong>发现(discovery)</strong></li><li><strong>负载均衡(load balancing)</strong></li><li><strong>故障恢复(failure recovery)</strong></li><li><strong>指标(metrics)</strong></li><li><strong>监控(monitoring)</strong></li></ul><p>服务网格通常还具有更复杂的操作要求，如:</p><ul><li><strong>A/B测试</strong></li><li><strong>金丝片部署(canary rollouts)</strong></li><li><strong>速率限制(rate limiting)</strong></li><li><strong>访问控制(access control)</strong></li><li><em>*端到端认证()</em>end-to-end authentication*</li></ul><p>Istio作为一个整体提供对服务网格的行为洞察和操作控制。</p><p><br><br><br></p><h3 id="为什么使用它"><a href="#为什么使用它" class="headerlink" title="为什么使用它"></a>为什么使用它</h3><p>Why use Istio?</p><p>通过负载均衡，服务到服务的身份认证，监控…使用服务代码中很少或不需要更改代码，Istio可以轻松创建已部署的服务网格。通过在整个环境中部署特殊的sidecar代理来拦截服务的Istio支持，该代理拦截微服务之间的所有网络通信，然后使用其控制平面配置和管理Istio。包括:</p><ul><li>HTTP, gRPC, WebSocket, TCP流量的自动负载均衡；</li><li>通过丰富的路由规则，重试(retries)，故障转移(failovers)，故障注入(fault injection)，对流量欣慰 进行细粒度控制；</li><li>可插入的策略层和API配置，支持访问控制，速率限制和配额；</li><li>集群中所有流浪的自动度量、日志和追踪，包括集群的ingress, egress；</li><li>通过强大的基于身份的认证和授权，在鸡群中实现安全的服务到服务的通信。</li></ul><p><br><br><br></p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><p>Core features</p><p><br></p><h4 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h4><p>Traffic management</p><p>通过Istio简单的规则配置和流量路由，你可以控制服务之间的流量和API调用。它简化了服务级别的属性配置，如熔断器(circuit breakers)，超时(timeouts)，重试(retries)，并且可以轻松设置A/B测试，金丝片部署(canary rollouts)，基于百分比流量分割的分阶段部署等重要任务。</p><p>通过更好地了解流量和开箱即用的故障恢复功能，你可在问题出现之前发现问题，使调用更加可靠、网络更加强大。</p><p><br><br><br></p><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>Security</p><p>Istio的安全功能使开发人员可以更加专注于应用程序级别的安全性。Istio提供了底层安全通信信道，并大规模管理服务通信的认证、授权和加密。使用Istio，服务通信在默认情况下是安全的，允许你跨多种协议和运行时一致地实施策略。所有这些基本都不用对应用程序进行更改。</p><p>虽然Istio与平台无关，但与k8s网络策略一起使用时，其优势更大，包括在网络层和应用层保护<code>pod-to-pod</code>或<code>service-to-service</code>通信的能力。</p><p><br><br><br></p><h4 id="可观察性"><a href="#可观察性" class="headerlink" title="可观察性"></a>可观察性</h4><p>Observability</p><p>Istio强大的追踪、监控和日志记录功能可以让你更深入了解服务网格部署。通过Istio的监控功能，真正了解服务性能如何影响上下游(upstream, downstream)的功能，而其自定义的仪表盘可提供对所有服务性能的可视性，并让你了解该性能如何影响你的其他进程。</p><p>Istio的<strong>混合器（Mixer)</strong>组件负责策略控制和遥测收集。它提供后端抽象和中间媒介，将Istio的其余部分与各个基础架构后端的实现细节隔离开来，并为运营商提供对网格网络和基础架构后端之间所有交互的细粒度控制。</p><p>这些功能使你可以更有效地设置，监控和实施服务上的SLOs。当然，最重要的是，你可以快速有效地检测和修复问题。</p><p><br><br><br></p><h4 id="平台支持"><a href="#平台支持" class="headerlink" title="平台支持"></a>平台支持</h4><p>Platform support</p><p>Istio是独立于平台的，旨在各种环境中运行。包括跨云，内在部署，k8s，Mesos…<br>你可在k8s上部署Istio，或在带有Nomad的Consul上部署它。Istio目前支持:</p><ul><li>Service deployment on Kubernetes</li><li>Services registered with Consul</li><li>Services running on individual virtual machines</li></ul><p><br><br><br></p><h4 id="集成和自定义"><a href="#集成和自定义" class="headerlink" title="集成和自定义"></a>集成和自定义</h4><p>Integration and customization</p><p>可以扩展和自定义Istio的策略实施组件，来与现有的ACL，日志记录，监控，配额，审计等方案集成。</p><p><br><br><br></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>Architecture</p><p>Istio服务网格逻辑上分为<strong>数据平面(data plane)</strong>和<strong>控制平面(data plane)</strong>。</p><ul><li>数据平面由一组以 sidecar 方式部署的<strong>智能代理(Envoy)</strong>组成。这些代理可以调节和控制微服务及Mixer之间所有的网络通信。</li><li>控制平面负责管理和配置代理来路由流量。此外控制平面配置Mixer以实施策略和收集遥测数据。</li></ul><p><img src="images/Istio/arch.svg" alt></p><p><br></p><h4 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h4><p>Istio使用<strong>Envoy</strong>代理的扩展版本，Envoy是以<code>C++</code>开发的高性能代理，用于调解服务网格中所有服务的所有入站和出站流量。<br>Envoy 的许多内置功能被 Istio 发扬光大，如:</p><ul><li>动态服务发现(Dynamic service discovery)</li><li>负载均衡(Load balancing)</li><li>TLS termination</li><li>HTTP/2 and gRPC proxies</li><li>熔断器(Circuit breakers)</li><li>健康检查(Health checks)</li><li>基于百分比流量拆分的灰度发布</li><li>故障注入(Fault injection)</li><li>丰富的度量指标(Rich metrics)</li></ul><p>Envoy 被部署为 sidecar，和对应服务在同一个 k8s pod 中。这允许 Istio 将大量关于流量行为的信号作为属性提取出来，而这些属性又可以在 Mixer 中用于执行策略决策，并发送给监控系统，以提供整个网格行为的信息。<br>Sidecar 代理模型还可以将 Istio 的功能添加到现有部署中，而无需重新构建或重写代码。</p><p><br><br><br></p><h4 id="Mixer"><a href="#Mixer" class="headerlink" title="Mixer"></a>Mixer</h4><p><strong>Mixer</strong> 是一个独立于平台的组件，负责在服务网格上执行访问控制和使用策略，并从 Envoy 代理和其他服务收集遥测数据。代理提取请求级属性，发送到 Mixer 进行评估。</p><p>Mixer 中包括一个灵活的插件模型，使其能够接入到各种主机环境和基础设施后端，从这些细节中抽象出 Envoy 代理和 Istio 管理的服务。</p><p><br><br><br></p><h4 id="Pilot"><a href="#Pilot" class="headerlink" title="Pilot"></a>Pilot</h4><p><strong>Pilot</strong> 为 Envoy sidecar 提供服务发现功能，为智能路由（如 A/B测试、金丝雀部署）和弹性（超时、重试、熔断器）提供流量管理功能。</p><p>它将控制流量行为的高级路由规则转换为特定于 Envoy 的配置，并在运行时将它们传播到 sidecar。Pilot 将平台特定的服务发现机制抽象化并将其合成为符合 Envoy 数据平面 API 的任何 sidecar 都可以使用的标准格式。这种松散耦合使得 Istio 能够在多种环境下运行（如 k8s、Consul、Nomad），同时保持用于流量管理的相同操作界面。</p><p><br><br><br></p><h4 id="Citadel"><a href="#Citadel" class="headerlink" title="Citadel"></a>Citadel</h4><p><strong>Citadel</strong> 通过内置身份和凭证管理赋能强大的服务间和最终用户身份验证。可用于升级服务网格中未加密的流量，并为运维人员提供基于服务标识而不是网络控制的强制执行策略的能力。</p><p><br><br><br></p><h4 id="Galley"><a href="#Galley" class="headerlink" title="Galley"></a>Galley</h4><p><strong>Galley</strong> 代表其他的 Istio 控制平面组件，用来验证用户编写的 Istio API 配置。随着时间的推移，Galley 将接管 Istio 获取配置、 处理和分配组件的顶级责任。它将负责将其他的 Istio 组件与从底层平台(如k8s)获取用户配置的细节中隔离开来。</p><p><br><br><br></p><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><p>Design Goals</p><p>Istio的架构设计中有几个关键目标，这些目标对于使系统能够应对大规模流量和高性能地服务处理至关重要。</p><ul><li>最大化透明度(Maximize Transparency)</li><li>可扩展性(Extensibility)</li><li>可移植性(Portability)</li><li>策略一致性(Policy Uniformity)</li></ul><p><br><br><br><br><br></p><h2 id="流量管理-1"><a href="#流量管理-1" class="headerlink" title="流量管理"></a>流量管理</h2><p><a href="https://istio.io/docs/concepts/traffic-management/" target="_blank" rel="noopener">Traffic Management</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Istio docs: &lt;a href=&quot;https://istio.io/docs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://istio.io/docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Istio中文文档: &lt;a href=&quot;https://istio.io/zh/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://istio.io/zh/docs/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Istio github: &lt;a href=&quot;https://github.com/istio/istio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/istio/istio&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RHEL7x86_64&lt;/li&gt;
&lt;li&gt;Istio v1.1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="k8s" scheme="https://zhang21.github.io/tags/k8s/"/>
    
      <category term="Service Mesh" scheme="https://zhang21.github.io/tags/Service-Mesh/"/>
    
      <category term="Microservice" scheme="https://zhang21.github.io/tags/Microservice/"/>
    
      <category term="微服务" scheme="https://zhang21.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="服务网格" scheme="https://zhang21.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>CuckooSandbox</title>
    <link href="https://zhang21.github.io/2019/04/16/CuckooSandbox/"/>
    <id>https://zhang21.github.io/2019/04/16/CuckooSandbox/</id>
    <published>2019-04-16T07:25:45.000Z</published>
    <updated>2019-04-17T01:14:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>github: <a href="https://github.com/cuckoosandbox/cuckoo" target="_blank" rel="noopener">https://github.com/cuckoosandbox/cuckoo</a></li><li>docs: <a href="https://cuckoo.sh/docs/" target="_blank" rel="noopener">https://cuckoo.sh/docs/</a></li></ul><p><br></p><p>环境:</p><ul><li>REL7x86_64</li><li>Cuckoo v2.0.6</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="https://cuckoo.sh/docs/introduction/index.html" target="_blank" rel="noopener">Introduction</a></p><p>本章节介绍 Cuckoo Sandbox。它解释了一些基本的恶意软件(malware)分析概念，什么是CuckooSanbox以及它如何适应恶意软件分析。</p><p><br><br><br></p><h2 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h2><p><a href="https://cuckoo.sh/docs/introduction/sandboxing.html" target="_blank" rel="noopener">Sandboxing</a></p><p>如维基百科所定义，“在计算机安全中，沙箱是一种用于分离正在运行的程序的安全机制。它通常用于执行未经验证的代码，或来自未经验证的第三方、供应商、不受信任的用户或网站或程序。”</p><p>这个概念也适用于恶意软件分析的沙箱：我们的目标是在隔离的环境中运行位置和不受信任的应用程序或文件，并获取有关它的功能的信息。</p><p>恶意软件沙箱是动态分析方法的实际应用：它不是静态分析二进制文件，而是实事执行和监视。</p><p>这种方法显然有利有弊，但它获取有关恶意软件的其它详细信息的有价值的技术(如网络行为)。因此，在检查恶意软件时执行<strong>静态分析</strong>(static)和<strong>动态分析</strong>(dynamic analysis)是一种很好的做法，以便更深入地了解它。</p><p>简单来说，Cuckoo是一个允许你执行沙箱恶意软件分析的工具。</p><p><br><br><br></p><h3 id="使用沙箱"><a href="#使用沙箱" class="headerlink" title="使用沙箱"></a>使用沙箱</h3><p>在考虑安装、配置和使用Cuckoo之前，你应该花时间考虑一下你希望用它实现什么功能，以及如何实现。</p><p>你应该考虑的一些问题:</p><ul><li>我想分析那种文件？</li><li>我希望能够处理多少分析？</li><li>我想用哪个平台来运行我的分析？</li><li>我想要关于文件的哪些信息？</li></ul><p>隔离环境(如虚拟机)的创建时沙箱部署中最关键和最重要的部分：应该仔细进行并进行适当的规划。</p><p><br></p><p>在掌握你选择的虚拟化产品之前，你应该已经有一个设计的计划:</p><ul><li>使用哪种操作系统(os)、语言(language)和修补(patching)级别；</li><li>要安装哪个软件和版本。</li></ul><p><br></p><p>考虑到自动恶意软件(malware)分析不是确定性的，它的成功可能取决于很多因素：你试图在虚拟化系统中运行恶意软件，就像在本机系统上运行一样，这可能很难实现，并且可能并不总是如此成功。你的目标应该是创建一个能够满足你所有要求的系统，并尽可能使其尽可能真实。</p><p>例如，你可以考虑留下一些正常使用的故意的痕迹(如历史记录、Cookie、文档、图像…)。如果恶意软件旨在操作、操纵、窃取此类文件，你将能够注意到它。</p><p>虚拟化操作系统通常带有很多痕迹，使它们容易被检测到。即使你不应高估此问题，也可能需要处理此问题并尝试因此尽可能多的虚拟化跟踪。互联网上有很多关于虚拟化检测技术和对策的文献。</p><p>完成设计和准备所需系统原型后，你可以继续创建并部署它。你将总是及时改变或略微修复它们，但要记住，一开始的良好规划意味着从长远来看减少麻烦。</p><p><br><br><br><br><br></p><h2 id="Cuckoo是什么"><a href="#Cuckoo是什么" class="headerlink" title="Cuckoo是什么"></a>Cuckoo是什么</h2><p><a href="https://cuckoo.sh/docs/introduction/what.html" target="_blank" rel="noopener">What is Cuckoo</a></p><p>Cuckoo是一个开源的自动恶意软件分析系统。<br>它用于自动运行和分析文件，并收集全面的分析结果，概述恶意软件在隔离操作系统内运行时的作用。</p><p><br><br><br></p><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>Use Cases</p><p>由于其机极为模块化的设计，Cuckoo既可以作为独立应用程序使用，也可以集成到更大的框架中。</p><p>它可用来分析:</p><ul><li>通用Windows EXE可执行文件</li><li>DLL文件</li><li>PDF文档</li><li>MS OFFICE文档</li><li>URLs和HTML文件</li><li>PHP脚本</li><li>CPL文件</li><li>VB脚本</li><li>ZIP文件</li><li>Python文件</li><li>Almost anything else</li></ul><p>由于其模块化和强大的脚本功能，使用Cuckoo可实现的目标没有限制。</p><p><br><br><br></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>Architecture</p><p>Cuckoo Sandbox由一个处理样本执行(Execution)和分析(Analysis)的中央管理软件组成。</p><p>每个分析都在一个新的和隔离的虚拟(物理)机器中启动。Cuckoo架构的主要组件是<strong>Host machine</strong>(管理软件)和许多<strong>Guest machines</strong>(用于分析的虚拟机或物理机)。<br>Host运行整个沙箱的分析进程的核心组件，而Guest是实际执行和分析恶意软件样本的隔离环境。</p><p><br></p><p>Cuckoo的主要架构图:</p><p><img src="/images/Cuckoo/architecture-main.png" alt></p><p><br><br><br></p><h3 id="获取Cuckoo"><a href="#获取Cuckoo" class="headerlink" title="获取Cuckoo"></a>获取Cuckoo</h3><p>Obtaining Cuckoo</p><p>虽然可以从官网上下载Cuckoo，也可从github下载，但还是建议使用<code>pip</code>安装。</p><p><br><br><br><br><br></p><h2 id="许可证"><a href="#许可证" class="headerlink" title="许可证"></a>许可证</h2><p><a href="https://cuckoo.sh/docs/introduction/license.html" target="_blank" rel="noopener">License</a></p><p>Cuckoo Foundation是一家非盈利组织，在荷兰成立，主要致力于支持开源的恶意软件分析系统Cuckoo Sandbox以及周边项目和计划的开发和发展。</p><p>该基金会致力于为软件项目提供财务和基础设施支持，并协调社区的发展和贡献。</p><p><br><br><br><br><br></p><h2 id="社区准则"><a href="#社区准则" class="headerlink" title="社区准则"></a>社区准则</h2><p><a href="https://cuckoo.sh/docs/introduction/community.html" target="_blank" rel="noopener">Community guidelines</a></p><p>Cuckoo Sandbox是一个开源项目，我们感谢任何形式的贡献。这些指南旨在帮助你和我们尽快回答问题、解决问题和合并代码。所以，你正在阅读的这些指南是很棒的！</p><p><br><br><br></p><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>这些指南有:</p><ul><li>创建Issue要包含的内容<ul><li>Reporting bugs/errors/unexpected behavior</li><li>Feature suggestions/requests</li></ul></li><li>Contributing code/documentation</li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://cuckoo.sh/docs/installation/index.html" target="_blank" rel="noopener">Installation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github: &lt;a href=&quot;https://github.com/cuckoosandbox/cuckoo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/cuckoosandbox/cuckoo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;docs: &lt;a href=&quot;https://cuckoo.sh/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cuckoo.sh/docs/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;REL7x86_64&lt;/li&gt;
&lt;li&gt;Cuckoo v2.0.6&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Cuckoo" scheme="https://zhang21.github.io/tags/Cuckoo/"/>
    
      <category term="Sandbox" scheme="https://zhang21.github.io/tags/Sandbox/"/>
    
      <category term="Security" scheme="https://zhang21.github.io/tags/Security/"/>
    
      <category term="Test" scheme="https://zhang21.github.io/tags/Test/"/>
    
      <category term="DynamicAnalysis" scheme="https://zhang21.github.io/tags/DynamicAnalysis/"/>
    
      <category term="MalwareAnalysis" scheme="https://zhang21.github.io/tags/MalwareAnalysis/"/>
    
  </entry>
  
  <entry>
    <title>OpenShift</title>
    <link href="https://zhang21.github.io/2019/03/26/OpenShift/"/>
    <id>https://zhang21.github.io/2019/03/26/OpenShift/</id>
    <published>2019-03-26T09:50:11.000Z</published>
    <updated>2019-06-17T06:56:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>Wikipedia</li><li>OpenShift docs: <a href="https://docs.openshift.com" target="_blank" rel="noopener">https://docs.openshift.com</a></li></ul><p><br></p><p>环境:</p><ul><li>RHELx86_64</li><li>OpenShift v4.1</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="OpenShift是什么"><a href="#OpenShift是什么" class="headerlink" title="OpenShift是什么"></a>OpenShift是什么</h1><p><a href="https://www.openshift.com/learn/what-is-openshift" target="_blank" rel="noopener">What is Red Hat OpenShift?</a></p><p>Red Hat OpenShift is a hybrid cloud(混合云), enterprise Kubernetes application platform.</p><p><img src="/images/OpenShift/whatIsOpenShift.png" alt></p><p><br></p><p>功能和特点：</p><ul><li><p><strong>Container host and runtime</strong><br>它为k8s Master提供了企业级的Linux CoreOS，并为工作节点提供了企业级Linux支持。它支持标准的Docker和CRI-O runtime。</p></li><li><p><strong>Enterprise Kubernetes</strong><br>它包含针对多个上游K8s版本的缺陷、安全和性能问题的修复程序。它采用了多种技术进行测试，是一个强大而紧密的集成平台，支持9年的生命周期。</p></li><li><p><strong>Validated integrations</strong><br>它包含了软件定义的网络，并验证其它常见的网络解决方案。</p></li><li><p><strong>Integrated container registry</strong><br>它附带了一个集成的私有容器注册中心。</p></li><li><p><strong>Developer workflows</strong><br>它包含了简化的工作流程，以帮助团队更快地投入到生产。包括内置的Jenkins Pipeline和source-to-image，从应用程序代码直接到容器。它也可以扩展像Istio和Knative这样的新框架。</p></li><li><p><strong>Easy access to services</strong><br>它通过嵌入式OperatorHub帮助管理员和支持团队，服务代理（包括直接访问AWS服务），经过验证的第三方解决方案和Kubernetes操作员。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wikipedia&lt;/li&gt;
&lt;li&gt;OpenShift docs: &lt;a href=&quot;https://docs.openshift.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.openshift.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RHELx86_64&lt;/li&gt;
&lt;li&gt;OpenShift v4.1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="OpenShift" scheme="https://zhang21.github.io/tags/OpenShift/"/>
    
      <category term="PaaS" scheme="https://zhang21.github.io/tags/PaaS/"/>
    
      <category term="DevOps" scheme="https://zhang21.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper</title>
    <link href="https://zhang21.github.io/2019/03/15/ZooKeeper/"/>
    <id>https://zhang21.github.io/2019/03/15/ZooKeeper/</id>
    <published>2019-03-15T08:57:20.000Z</published>
    <updated>2019-03-18T03:24:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>维基百科</li><li>ZooKeeper: <a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">https://zookeeper.apache.org/</a></li><li>Docs: <a href="https://zookeeper.apache.org/doc/" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/</a></li></ul><p>环境:</p><ul><li>RHEL7x86_64</li><li>ZooKeeper v3.5</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><img src="/images/ZooKeeper/zookeeper_logo.jpg" alt></p><p><br></p><p>ZooKeeper: Because Coordinating Distributed Systems is a Zoo.</p><p><strong>Apache ZooKeeper</strong> 是Apache软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册，实现高度可靠的分布式协调。ZooKeeper曾经是Hadoop的一个子项目，但现在是一个独立的顶级项目。</p><p>ZooKeeper 是一种集中式服务，用于维护<strong>配置信息</strong>(conf info)，<strong>命名</strong>(naming)，<strong>分布式同步</strong>(distributed synchronization)，<strong>组服务</strong>(group service)。所有这些类型的服务都以分布式应用程序的某种形式应用。每次实施它们都需要做很多工作来修复不可避免的错误和竞争条件。由于难以实现这些类型的服务，应用程序最初通常会吝啬它们，这使得它们在变化的情况下变得脆弱并且难以管理。即使正确完成，这些服务的不同实现也会在部署应用程序时导致管理复杂性。</p><p><strong>ZooKeeper的架构通过冗余服务实现高可用性</strong>。因此，如果第一次无应答，客户端就可以询问另一台ZooKeeper主机。ZooKeeper节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。更新是全序的。</p><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://zookeeper.apache.org/doc/r3.5.4-beta/zookeeperOver.html" target="_blank" rel="noopener">ZooKeeper: A Distributed Coordination Service for Distributed Applications</a></p><p>ZooKeeper 是一种用于分布式应用程序的分布式开源协调(coordination)服务。它被设计为易于编程，并使用在熟悉的文件系统目录树结构之后设计的数据模型。它在Java中运行，并具有Java和C的绑定。</p><p>众所周知，协调服务很难做到。他们特别容易出现竞赛条件(race conditions)和死锁(deadlock)。ZooKeeper背后的动机是减轻分布式应用程序从头开始实施协调服务的责任。</p><p><br></p><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><p>Design Goals</p><ul><li><strong>ZooKeeper is simple</strong></li></ul><p>ZooKeeper允许分布式进程通过 <strong>共享的层级命名空间</strong>(shared hierarchal namespace) 相互协调，该命名空间的组织方式与标准文件系统类似。命名空间由 <strong>数据寄存器</strong>(data registers) 组成——在ZooKeeper用语中被称为 <code>znodes</code>，这些与文件和目录类似。与专为存储而设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量(high throughput)和低延迟数(latency numbers)。</p><p>ZooKeeper的实现非常重视 <strong>高性能(high performance)</strong>， <strong>高可用(highly available)</strong>， <strong>严格有序的访问(strictly ordered access)</strong>。性能方面意味着它可以在大型分布式系统中使用。可靠性方面使其不会成为单点故障(a single point of failure)。严格的排序意味着可以在客户端实现复杂的同步原语。</p><p><br></p><ul><li><strong>ZooKeeper is replicated</strong></li></ul><p>与它协调的分布式进程一样，ZooKeeper本身也可以在称为 <strong>集合(ensemble)</strong> 的一组主机上进行 副本复制(replicated)。</p><p><img src="/images/ZooKeeper/zkservice.jpg" alt></p><p>组成ZooKeeper服务的Server必须了解彼此。它们维护一个内存中的状态镜像，以及持久性存储的事务日志和快照。只要大多数Servers可用，ZooKeeper服务就可用。</p><p>Client连接到单个Server。Client维护TCP连接，通过该连接发送请求，获取响应，获取监视事件(watch events)，以及发送心跳(heart beats)。如果与Server的TCP连接中断，则Client将连接到其它Server。</p><p><br></p><ul><li><strong>ZooKeeper is ordered</strong></li></ul><p>ZooKeeper使用反映所有ZooKeeper事务顺序的数字标记每个更新。后续操作可以使用该顺序来实现更高级别的抽象，例如同步原语。</p><p><br></p><ul><li><strong>ZooKeeper is fast</strong></li></ul><p>它在读取 <code>read-doninant</code> 工作负载中特别快。ZooKeeper应用程序运行在成千上万的计算机上，并且在读取别写入更常见的情况下(比率<code>10:1</code>)表现最佳。</p><p><br><br><br></p><h3 id="数据模型和分层命名空间"><a href="#数据模型和分层命名空间" class="headerlink" title="数据模型和分层命名空间"></a>数据模型和分层命名空间</h3><p>Data model and the hierarchical namespace</p><p>ZooKeeper提供的命名空间非常类似于标准文件系统。名称是由斜杠(<code>/</code>)分隔的路径元素序列。ZooKeeper命名空间中的每个节点都由路径标识。</p><p><img src="/images/ZooKeeper/zknamespace.jpg" alt></p><p><br><br><br></p><h3 id="节点和短暂节点"><a href="#节点和短暂节点" class="headerlink" title="节点和短暂节点"></a>节点和短暂节点</h3><p>Nodes and ephemeral nodes</p><p>与标准文件系统不同，ZooKeeper命名空间中的每个节点都可包含与之关联的数据以及孩子。这就像拥有一个允许文件也是目录的文件系统。ZooKeeper旨在存储协调数据：状态信息，配置，位置信息等，因此存储在每个节点的数据通常很小。我们使用术语 <strong>znode</strong> 来表明我们正在谈论的ZooKeeper数据节点。</p><p>Znodes 维护一个 <strong>状态结构(stat structure)</strong>，其中包括数据更改、ACL更改、时间戳更改，以允许缓存验证和协调更新。每次znode的数据更改时，版本号都会增加。例如，每当Client检索数据时，它也接收数据的版本。</p><p>存储在每个znode命名空间中的数据以原子(atomically)方式进行读写。读取与znode关联的所有数据字节，写入替换所有的数据。每个节点都有一个ACL限制谁可以做什么。</p><p>ZooKeeper也有 <strong>短暂节点(ephemeral nodes)</strong> 的概念。只要创建的znode处于活动状态，就会存在这些znode，回话结束时，znode将被删除。当你想要实现 <code>[tbd]</code> 时，短暂节点很有用。</p><p><br><br><br></p><h3 id="协调更新和监视"><a href="#协调更新和监视" class="headerlink" title="协调更新和监视"></a>协调更新和监视</h3><p>Conditional updates and watches</p><p>ZooKeeper支持监视(watch)的概念。Client可以在znode上设置监视。当znode更改时，将触发并删除监视。触发监视时，Client会受到一个数据包，指出znode已更改。如果Client与其中一个ZooKeeper Server之间的连接中断，则Client将收到本地通知。这可以用于 <code>[tbd]</code> 。</p><p><br><br><br></p><h3 id="保证"><a href="#保证" class="headerlink" title="保证"></a>保证</h3><p>Guarantees</p><p>ZooKeeper非常快速和简单。但是，由于基于目标是构建更复杂的服务(如同步)的基础，因此它提供了一系列保证。这些是:</p><ul><li><strong>顺序一致性(Sequential Consistency)</strong>: Client的更新将按发送顺序来应用</li><li><strong>原子性(Atomicity)</strong>: 更新成功或失败，没有其它结果</li><li><strong>单系统镜像(Single System Image)</strong>: 无论连接到哪个Server，Client都将看到相同的服务视图</li><li><strong>可靠性(Reliability)</strong>: 一旦更新被应用，它将从该时间开始持续，知道Client覆盖此更新</li><li><strong>时宜性(Timeliness)</strong>: 系统的Client视图保证在特定的时间范围内是最新的</li></ul><p><br><br><br></p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>ZooKeeper的设计目标之一是提供非常简单的编程接口。因此，它仅支持以下操作:</p><ul><li>create: creates a node at a location in the tree</li><li>delete: deletes a node</li><li>exists: tests if a node exists at a location</li><li>get data: reads the data from a node</li><li>set data: writes data to a node</li><li>get children: retrieves a list of children of a node</li><li>sync: waits for data to be propagated</li></ul><p><br><br><br></p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>Implementation</p><p>ZooKeeper组件显示了ZooKeeper服务的高级组件。除了请求处理器，构成ZooKeeper服务的每个Server都复制自己每个组件的副本。</p><p><img src="/images/ZooKeeper/zkcomponents.jpg" alt></p><ul><li>副本数据库是一个包含整个数据树的内存数据库。更新将记录到磁盘以获得可恢复性，并且在写入内存数据库之前会序列化的磁盘</li><li>每个ZooKeeper Server都为Client服务。Client只连接到一台Server以提交请求。读取请求由每个Server数据库的本地副本提供。更改服务状态的请求，写请求由 协定协议(agreement protocol) 处理</li><li>作为协定协议的一部分，来自Client的所有写入请求都被转发到称为 <strong>leader</strong> 的单个Server。其余的ZooKeeper Server，称为<strong>follower</strong>，接收来自<strong>leader</strong>的消息提议并同意消息传递。消息传递层负责替换失败的leader，并将follower与leader同步</li><li>ZooKeeper使用自定义的原子消息(atomic messaging)协议。由于消息传递层是原子的，因此ZooKeeper可以保证本地副本永远不会发散。当leader收到写入请求时，它会计算应用写入时系统的状态，并将其转换为捕获此新状态的事务。</li></ul><p><br><br><br></p><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>ZooKeeper的编程接口非常简单。但是，通过它，您可以实现更高阶的操作，例如同步原语，组成员身份，所有权等。</p><p><br><br><br></p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Performance</p><p>ZooKeeper旨在提供高性能。在读取数量超过写入的应用程序中，它的性能尤其高，因为写入涉及同步所有Server的状态。</p><p><img src="/images/ZooKeeper/zkperfRW.jpg" alt></p><p>The events marked in the figure are the following:</p><ul><li>Failure and recovery of a follower</li><li>Failure and recovery of a different follower</li><li>Failure of the leader</li><li>Failure and recovery of two followers</li><li>Failure of another leader</li></ul><p><br><br><br><br><br></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><a href="https://zookeeper.apache.org/doc/r3.5.4-beta/zookeeperStarted.html" target="_blank" rel="noopener">ZooKeeper Getting Started Guide</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维基百科&lt;/li&gt;
&lt;li&gt;ZooKeeper: &lt;a href=&quot;https://zookeeper.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zookeeper.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docs: &lt;a href=&quot;https://zookeeper.apache.org/doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zookeeper.apache.org/doc/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RHEL7x86_64&lt;/li&gt;
&lt;li&gt;ZooKeeper v3.5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Apache" scheme="https://zhang21.github.io/tags/Apache/"/>
    
      <category term="DataAnalysis" scheme="https://zhang21.github.io/tags/DataAnalysis/"/>
    
      <category term="ZooKeeper" scheme="https://zhang21.github.io/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>HBase</title>
    <link href="https://zhang21.github.io/2019/03/15/HBase/"/>
    <id>https://zhang21.github.io/2019/03/15/HBase/</id>
    <published>2019-03-15T02:57:20.000Z</published>
    <updated>2019-03-15T09:00:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>维基百科</li><li>HBase: <a href="https://hbase.apache.org/" target="_blank" rel="noopener">https://hbase.apache.org/</a></li><li>Reference Guide: <a href="http://hbase.apache.org/book.html" target="_blank" rel="noopener">http://hbase.apache.org/book.html</a></li></ul><p>环境:</p><ul><li>RHEL7x86_64</li><li>HBase v3.0</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><img src="/images/HBase/hbase_logo.png" alt></p><p><br></p><p><strong>Apache HBase</strong> 是Hadoop数据库，是一个分布式(distributed)，可扩展(scalable)的大数据存储。</p><p>当你需要对大数据进行随机(random)，实时(realtime)R/W访问时，请使用Apache HBase。它的目标是在硬件集群上托管非常大的表——数十亿行数百万列。</p><p>HBase是一个开源的非关系型分布式数据库（NoSQL），它参考了谷歌的BigTable建模，实现的编程语言为 Java。它是Apache软件基金会的Hadoop项目的一部分，运行于HDFS文件系统之上，为 Hadoop 提供类似于BigTable 规模的服务。因此，它可以对稀疏文件提供极高的容错率。</p><p>HBase在列上实现了BigTable论文提到的压缩算法、内存操作和布隆过滤器。HBase的表能够作为MapReduce任务的输入和输出，可以通过Java API来访问数据，也可以通过REST、Avro或者Thrift的API来访问。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>Features</p><ul><li>线性和模块化可扩展性</li><li>严格一致的读写操作</li><li>表的自动和可配置分片</li><li>支持RegionServers之间的自动故障转移</li><li>方便的基类，用于使用Apache HBase表支持Hadoop MapReduce作业</li><li>易于使用的Java API，用于客户端访问</li><li>阻止缓存和bloom过滤器以进行实时查询</li><li>Query predicate push down via server side Filters</li><li>Thrift gateway和REST-ful Web service，支持XML， Protobuf， binary data encoding</li><li>可扩展的基于JRuby的（JIRB）shell</li><li>支持通过Hadoop Metrics子系统将指标导出到文件或其它</li><li>…</li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>Getting Started</p><p><br></p><h2 id="Standalone-HBase"><a href="#Standalone-HBase" class="headerlink" title="Standalone HBase"></a>Standalone HBase</h2><p>本节介绍在单节点的standalone实例上运行HBase。<strong>Standalone instance</strong> 包含了所有的<strong>HBase Daemons(Master, RegionServers, Zookeeper)</strong>，在单个JVM中运行并持久化到本地文件系统。这是一个最基本的配置，将展示如何使用HBase shell CLI在HBase中创建表、在表中插入行、对表执行放置和扫描操作、启用/禁用表、启动和停止HBase。</p><p><br></p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>HBase要求安装JDK。</p><p><br><br><br></p><h3 id="使用HBase"><a href="#使用HBase" class="headerlink" title="使用HBase"></a>使用HBase</h3><p>步骤:</p><ul><li>下载</li><li>配置</li><li>启动</li><li>使用</li><li>停止</li></ul><p><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># 访问Apache DownLoad Mirrors，下载对应版本HBase</span><br><span class="line"># https://www.apache.org/dyn/closer.lua/hbase/</span><br><span class="line">cd opt</span><br><span class="line">wget http://mirror.bit.edu.cn/apache/hbase/3.0.0/hbase-3.0.0-bin.tar.gz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">tar xzvf hbase-3.0.0-SNAPSHOT-bin.tar.gz</span><br><span class="line">mv hbase-3.0.0-SNAPSHOT hbase</span><br><span class="line">cd hbase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 启动前必须先设置JAVA_HOME环境变量</span><br><span class="line"># conf/hbase-env.sh</span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_191-amd64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 编辑conf/hbase-site.xml，这是主要的HBase配置文件</span><br><span class="line"># 您需要在本地文件系统上指定HBase和ZooKeeper写入数据并确认一些风险的目录</span><br><span class="line"># 栗子</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.rootdir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;file:///home/testuser/hbase&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/home/testuser/zookeeper&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;</span><br><span class="line">      Controls whether HBase will check for stream capabilities (hflush/hsync).</span><br><span class="line"></span><br><span class="line">      Disable this if you intend to run on LocalFileSystem, denoted by a rootdir</span><br><span class="line">      with the &apos;file://&apos; scheme, but be mindful of the NOTE below.</span><br><span class="line"></span><br><span class="line">      WARNING: Setting this to false blinds you to potential data loss and</span><br><span class="line">      inconsistent system state in the event of process and/or node failures. If</span><br><span class="line">      HBase is complaining of an inability to use hsync or hflush it&apos;s most</span><br><span class="line">      likely not a false positive.</span><br><span class="line">    &lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># start a standalone instance of HBase</span><br><span class="line"># 一个JVM运行 HMaster, HRegionServer, Zookeeper</span><br><span class="line">bin/start-hbase.sh</span><br><span class="line"></span><br><span class="line"># http://localhost:16010 查看HBase Web UI</span><br></pre></td></tr></table></figure><p><br></p><p>你不需要创建HBase数据目录，它会自动做这件事。如果你创建目录，HBase将尝试进行迁移，这不是你想要的。</p><p>要在现有的HDFS实例上安装HBase，请将 <code>hbase.rootdir</code> 设置为指向实例上的目录(如: <code>hdfs://namenode.example.org:8020/hbase</code>)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用hbase shell命令连接到HBase</span></span><br><span class="line">/bin/hbase shell</span><br><span class="line">xxxx</span><br><span class="line">xxxx</span><br><span class="line">2.3.7 :001 &gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示帮助</span></span><br><span class="line">&gt; <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建表，你必须指定 Table name和ColumnFamily name</span></span><br><span class="line">&gt; create <span class="string">'t-test'</span>, <span class="string">'c-test'</span></span><br><span class="line">Took 1.7627 seconds</span><br><span class="line"> =&gt; Hbase::Table - t-test</span><br><span class="line"><span class="comment"># 也可在Web UI上查看相关信息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出表信息</span></span><br><span class="line">&gt; list <span class="string">'c-test'</span></span><br><span class="line">TABLE</span><br><span class="line">t-test</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0520 seconds</span><br><span class="line"> =&gt; [<span class="string">"t-test"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; describe <span class="string">'t-test'</span></span><br><span class="line">Table t-test is ENABLED</span><br><span class="line">t-test</span><br><span class="line">COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; <span class="string">'c-test'</span>, VERSIONS =&gt; <span class="string">'1'</span>, EVICT_BLOCKS_ON_CLOSE =&gt; <span class="string">'false'</span>, NEW_VERSION_BEHAVIOR =&gt; <span class="string">'false'</span>, KEEP_DELETED_CELLS =&gt; <span class="string">'FALSE'</span>, CACHE_DATA_ON_WRITE =&gt; <span class="string">'false'</span>, DATA_BLOCK_ENCODING</span><br><span class="line">=&gt; <span class="string">'NONE'</span>, TTL =&gt; <span class="string">'FOREVER'</span>, MIN_VERSIONS =&gt; <span class="string">'0'</span>, REPLICATION_SCOPE =&gt; <span class="string">'0'</span>, BLOOMFILTER =&gt; <span class="string">'ROW'</span>, CACHE_INDEX_ON_WRITE =&gt; <span class="string">'false'</span>, IN_MEMORY =&gt; <span class="string">'false'</span>, CACHE_BLOOMS_ON_WRITE =&gt; <span class="string">'false'</span>,</span><br><span class="line"> PREFETCH_BLOCKS_ON_OPEN =&gt; <span class="string">'false'</span>, COMPRESSION =&gt; <span class="string">'NONE'</span>, BLOCKCACHE =&gt; <span class="string">'true'</span>, BLOCKSIZE =&gt; <span class="string">'65536'</span>&#125;</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.2293 seconds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据放入表中</span></span><br><span class="line">&gt;put <span class="string">'t-test'</span>,  <span class="string">'row1'</span>, <span class="string">'c-test:a'</span>, <span class="string">'value1'</span></span><br><span class="line">Took 0.2116 seconds</span><br><span class="line">&gt; put <span class="string">'t-test'</span>,  <span class="string">'row2'</span>, <span class="string">'c-test:b'</span>, <span class="string">'value2'</span></span><br><span class="line">Took 0.0082 seconds</span><br><span class="line">&gt; &gt; put <span class="string">'t-test'</span>,  <span class="string">'row3'</span>, <span class="string">'c-test:c'</span>, <span class="string">'value3'</span></span><br><span class="line">Took 0.0085 seconds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次扫描表中所有数据</span></span><br><span class="line">&gt; scan <span class="string">'t-test'</span></span><br><span class="line">&gt;   scan <span class="string">'t-test'</span></span><br><span class="line">ROW                                             COLUMN+CELL</span><br><span class="line"> row1                                           column=c-test:a, timestamp=1552630577582, value=value1</span><br><span class="line"> row2                                           column=c-test:b, timestamp=1552630591734, value=value2</span><br><span class="line"> row3                                           column=c-test:c, timestamp=1552630598817, value=value3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取单行数据</span></span><br><span class="line">&gt; get <span class="string">'t-test'</span> <span class="string">'row1'</span></span><br><span class="line">COLUMN                                          CELL</span><br><span class="line"> c-test:a                                       timestamp=1552630577582, value=value1</span><br><span class="line">1 row(s)</span><br><span class="line">Took 0.0225 seconds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用/启用表</span></span><br><span class="line">&gt; <span class="built_in">disable</span> <span class="string">'t-test'</span></span><br><span class="line">&gt; <span class="built_in">enable</span> <span class="string">'t-test'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除表</span></span><br><span class="line">&gt; drop <span class="string">'t-test'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出HBase Shell</span></span><br><span class="line">&gt; quit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># stop a standalone instance of HBase</span></span><br><span class="line"><span class="comment"># 可能需要几分钟，请耐心等待</span></span><br><span class="line">bin/stop-hbase.sh</span><br></pre></td></tr></table></figure><p><img src="/images/HBase/hbase_standalone.png" alt></p><p><br><br><br><br><br></p><h3 id="伪分布式本地安装"><a href="#伪分布式本地安装" class="headerlink" title="伪分布式本地安装"></a>伪分布式本地安装</h3><p>Pseudo-Distributed Local Install</p><p>通过standalone模式之后，你可以重新配置HBase以<strong>伪分布式模式(Pseudo-Distributed)</strong>运行。伪分布式意味着HBase仍然在单个主机上运行，但每个HBase Daemons(HMaster, HRegionServer, Zookeeper)作为一个单独的进程运行。默认数据存储在<code>/tmp</code>下，除非你像Standalone一样配置了<code>rootdir</code>。</p><p>假设将数据存储在HDFS中，并且HDFS可用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Stop HBase if it is running.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置HBase</span></span><br><span class="line"><span class="comment"># 编辑hbase-site.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指示HBase以分布式模式运行，每个守护进程有一个JVM实例</span></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 hdfs://// URI语法将hbase.rootdir从本地文件系统更改为HDFS实例的地址，地址请查看HDFS配置</span></span><br><span class="line"><span class="comment"># 请确保删除hbase.unsafe.stream.capability.enforce的条目或将其设置为true</span></span><br><span class="line"><span class="comment"># 你不需要在HDFS中创建目录，HBase会为你做这件事。如果您创建目录，HBase将尝试进行迁移，这不是您想要的</span></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hbase.rootdir&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;hdfs://localhost:8020/hbase&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动HBase</span></span><br><span class="line">bin/start-hbase.sh</span><br><span class="line"><span class="comment"># 如果系统配置正确，则jps显示正在运行的HBase进程</span></span><br><span class="line">jps</span><br><span class="line">20065 HMaster</span><br><span class="line">20006 HQuorumPeer</span><br><span class="line">20137 HRegionServer</span><br><span class="line">20521 Jps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查HDFS中的HBase目录</span></span><br><span class="line"><span class="comment"># 如果一切正常，HBase会在HDFS中创建它的目录</span></span><br><span class="line"><span class="comment"># 注意HDFS的安全模式</span></span><br><span class="line">bin/hadoop fs -ls /hbase</span><br><span class="line">Found 1 items</span><br><span class="line">drwxr-xr-x   - zhang supergroup          0 2019-03-15 15:33 /hbase/.tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个表，并用数据填充它</span></span><br><span class="line"><span class="comment"># 创建放入和前面一样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动/停止一个 backup HBase Master Server(HMaster)</span></span><br><span class="line"><span class="comment"># 在同一硬件上运行多个HMaster实例在生产环境中没有意义，就像运行伪分布式集群对生产没有意义一样。此步骤仅用于测试和学习</span></span><br><span class="line">/bin/<span class="built_in">local</span>-master-backup.sh start 2 3 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在不杀死整个集群的情况下终止backup master</span></span><br><span class="line">cat /tmp/hbase-testuser-1-master.pid |xargs <span class="built_in">kill</span> -9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动/停止additional RegionServers</span></span><br><span class="line"><span class="comment"># 在同一系统上运行多个HRegionServers对于以伪分布式模式进行测试非常有用。</span></span><br><span class="line">bin/<span class="built_in">local</span>-regionservers.sh start 2 3 4</span><br><span class="line">bin/<span class="built_in">local</span>-regionservers.sh stop 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止HBase</span></span><br><span class="line">bin/stop-hbase.sh</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>Advanced - Fully Distributed</p><p>实际上，你需要完全分布式(fully-distributed)配置才能完全测试HBase并在实际场景中使用它。在分布式配置中，集群包含多个节点，每个节点运行一个或多个HBase守护进程(包括: Primary Master, Backup Master, Multiple ZooKeeper nodes, Multiple RegionServer nodes)。</p><p><br></p><h4 id="分布式集群架构"><a href="#分布式集群架构" class="headerlink" title="分布式集群架构"></a>分布式集群架构</h4><p>Distributed Cluster Demo Architecture</p><div class="table-container"><table><thead><tr><th>Node Name</th><th>Master</th><th>ZooKeeper</th><th>RegionServer</th></tr></thead><tbody><tr><td><code>node-a.example.com</code></td><td>yes</td><td>yes</td><td>no</td></tr><tr><td><code>node-b.example.com</code></td><td>backup</td><td>yes</td><td>yes</td></tr><tr><td><code>node-c.example.com</code></td><td>no</td><td>yes</td><td>yes</td></tr></tbody></table></div><p>确保集群之间的可访问性。</p><p><br><br><br></p><h4 id="SSH免密"><a href="#SSH免密" class="headerlink" title="SSH免密"></a>SSH免密</h4><p>Configure Passwordless SSH Access</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成公钥</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入公钥</span></span><br><span class="line">cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意修改权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试免密登录</span></span><br><span class="line">ssh user@hostname</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="准备集群"><a href="#准备集群" class="headerlink" title="准备集群"></a>准备集群</h4><p>node-a 将运行 Primary Master, ZooKeeper, no RegionServers.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置conf/regionservers</span></span><br><span class="line"><span class="comment"># 删除node-a的RegionServer地址，并添加node-b, node-c的RegionServer地址</span></span><br><span class="line"><span class="comment"># node-b.example.com, node-c.example.com</span></span><br><span class="line">conf/regionservers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置HBase使用node-b作为 Backup Master</span></span><br><span class="line"><span class="comment"># 创建 conf/backup-masters，并使用 node-b的主机名为其添加新行</span></span><br><span class="line">conf/backup-masters</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置ZooKeeper</span></span><br><span class="line"><span class="comment"># 实际情况中，你应该仔细考虑ZooKeeper配置</span></span><br><span class="line"><span class="comment"># node-a, conf/hbase-site.xml</span></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;node-a.example.com,node-b.example.com,node-c.example.com&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;/usr/<span class="built_in">local</span>/zookeeper&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><br></p><p>node-b 将运行 backup master, ZooKeeper instance。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制 node-a conf/ 到 node-b, node-c conf/</span></span><br><span class="line"><span class="comment"># 集群中的每个节点都需要具有相同的配置</span></span><br><span class="line"><span class="comment"># 请注意不同节点的localhost这个地址</span></span><br></pre></td></tr></table></figure><p><br></p><p>配置完成后，便要启动并测试集群。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Be sure HBase is not running on any node</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Start the cluster</span></span><br><span class="line"><span class="comment"># On node-a, node-b, node-c</span></span><br><span class="line">bin/start-hbase.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># ZooKeeper starts first, followed by the master, then the RegionServers, and finally the backup masters.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Verify that the processes are running</span></span><br><span class="line">jps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Browse to the Web UI</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Test what happens when nodes or services disappear</span></span><br><span class="line"><span class="comment"># 测试可用性</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>Apache HBase Configuration</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维基百科&lt;/li&gt;
&lt;li&gt;HBase: &lt;a href=&quot;https://hbase.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hbase.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Reference Guide: &lt;a href=&quot;http://hbase.apache.org/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://hbase.apache.org/book.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RHEL7x86_64&lt;/li&gt;
&lt;li&gt;HBase v3.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Apache" scheme="https://zhang21.github.io/tags/Apache/"/>
    
      <category term="DataAnalysis" scheme="https://zhang21.github.io/tags/DataAnalysis/"/>
    
      <category term="HBase" scheme="https://zhang21.github.io/tags/HBase/"/>
    
      <category term="NoSQL" scheme="https://zhang21.github.io/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>Flume</title>
    <link href="https://zhang21.github.io/2019/03/07/Flume/"/>
    <id>https://zhang21.github.io/2019/03/07/Flume/</id>
    <published>2019-03-07T01:32:20.000Z</published>
    <updated>2019-03-15T02:24:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>wikipedia</li><li>Flume: <a href="https://flume.apache.org/" target="_blank" rel="noopener">https://flume.apache.org/</a></li><li>Flume docs: <a href="https://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html" target="_blank" rel="noopener">https://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html</a></li></ul><p>环境:</p><ul><li>ELRH7x86_64</li><li>Flume v1.9.0</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="https://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#introduction" target="_blank" rel="noopener"></a></p><p><strong>Apache Flume</strong> 是一种分布式，可靠且可用的软件，使用Java编写，用于高效收集(collecting)，聚合(aggregating)和移动(moving)大量日志数据。它具有基于流数据流(stream data flows)的简单灵活的架构。它具有可靠性机制和许多故障转移和恢复机制，具有强大的容错能力。它使用简单的可扩展数据模型，允许在线分析应用程序。</p><p>Apache Flume的使用不仅限于日志数据聚合。由于数据源是可定制的，因此Flume可用于传输大量事件数据，包括但不限于网络流量数据，社交媒体生成的数据，电子邮件消息以及几乎任何可能的数据源。</p><p><img src="/imags/Flume/flume-logo.png" alt></p><p><br></p><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><ul><li><strong>Java</strong>: Java 1.8+</li><li><strong>Mem</strong>: sources, channels, sinks有足够的内存</li><li><strong>Disk</strong>: channels, sinks有足够的磁盘空间</li><li><strong>Directory Permissions</strong>: Agent使用的目录的读写权限</li></ul><p><br><br><br><br><br></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><br></p><h3 id="数据流模型"><a href="#数据流模型" class="headerlink" title="数据流模型"></a>数据流模型</h3><p>Data flow model</p><ul><li><strong>源(Source)</strong></li><li><strong>通道(Channel)</strong></li><li><strong>接收器(Sink)</strong></li><li><strong>事件(Event)</strong></li></ul><p><br></p><p><strong>Flume event</strong> 被定义为具有字节(byte)有效负载可可选字符串属性集的数据流单元(unit of data flow)。<strong>Flume agent</strong>是一个(JVM)进程，它承载事件从外部源流向下一个目标的组件。</p><p><img src="/images/Flume/flume-architecture.png" alt></p><p><br></p><p><strong>Flume源消费事件</strong>(source consumes events)通过<strong>外部源</strong>(external source)(如WebServer)传递给它。外部源通过<strong>目标Flume源</strong>(target Flume source)识别的格式向Flume发送事件。当Flume源接收事件时，它会将其存储到一个或多个<strong>通道</strong>(channels)中。通道是一个被动存储，可以保持事件直到它被<strong>Flume sink</strong>所消费。接收器从通道中移除事件，并将其放入外部存储库(如HDFS)或将其转发到流中的下一个Flume Agent(next hop)的Flume Source。给定Agent中的Source和Sink与Channel中暂存的Events异步运行。</p><p><br><br><br></p><h3 id="复杂流"><a href="#复杂流" class="headerlink" title="复杂流"></a>复杂流</h3><p>Complex flows</p><p>Flume允许用户构建多跳(hop)流，其中事件在到达最终目的地之前经过多个代理。它还允许 fan-in 和 fan-out flows, 上下文路由(contextual routing), 故障跳跃的备份路由(故障转移)。</p><p><br><br><br></p><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>Reliability</p><p>事件在每个Agent的通道中进行，然后将事件传递到流中的下一个代理或终端存储库(如HDFS)。只有将事件存储在下一个代理的通道或终端存储库之后，才会从通道中删除这些事件。这就是Flume中的单跳消息传递语义如何提供流的端到端可靠性。</p><p>Flume使用事务方法来保证事件的可靠传递。源和接收器分别在事务中封装由信道提供的事务中放置/提供的事件的存储(storage)/检索(retrieval)。这可确保事件集在流中从一个点到另一个点可靠地传递。在多跳流的情况下，来自前一跳的接收器和来自下一跳的源都运行其事务以确保数据安全地存储在下一跳的信道中。</p><p><br><br><br></p><h3 id="可恢复性"><a href="#可恢复性" class="headerlink" title="可恢复性"></a>可恢复性</h3><p>Recoverability</p><p>事件在通道中进行，该通道管理从故障中恢复。Flume支持由本地文件系统支持的持久化(durable)文件通道。还有一个内存通道(memory channel)，它将事件存储到内存中的队列中，这更快，但是当代理进程死亡时仍然存留在内存通道中的任何事件都无法恢复。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><p><a href="https://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#setup" target="_blank" rel="noopener">Setup</a></p><p><br></p><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>Setting up an agent</p><p>Flume Agent配置文件存储在本地配置文件中。这是一个Java properties文件格式的文本文件。可以在同一个配置文件中指定一个或多个代理的配置。配置文件包括代理中的每个Source, Sink, Channel的属性，以及它们如何连接在一起以形成数据流。</p><p><br></p><h3 id="配置单个组件"><a href="#配置单个组件" class="headerlink" title="配置单个组件"></a>配置单个组件</h3><p>Configuring individual components</p><p>流中的每个组件(source, sink, channel)都具有特定于类型和实例化的名称(name)，类型(type)，属性集(properties)。</p><p><br><br><br></p><h3 id="连接各个部分"><a href="#连接各个部分" class="headerlink" title="连接各个部分"></a>连接各个部分</h3><p>Wiring the pieces together</p><p>Agent需要知道加载哪些组件，以及它们如何连接以构成流。这是通过列出代理中每个源，接收器和通道的名称，然后为每个接收器和源指定连接通道来完成的。</p><p><br><br><br></p><h3 id="启动代理"><a href="#启动代理" class="headerlink" title="启动代理"></a>启动代理</h3><p>Starting an agent</p><p>下载Flume发型版，使用名为<code>flume-ng</code>的shell脚本启动代理程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你需要在命令行上指定代理名称、配置目录、配置文件</span></span><br><span class="line">bin/flume-ng agent -n <span class="variable">$agent_name</span> -c conf -f conf/flume-conf.properties.template</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在，代理开始运行在给定属性文件中配置的源和接收器</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><p>下面给出一个示例配置文件。此配置允许用户生成事件，并将其记录到console:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># example.conf: A single-node Flume configuration</span><br><span class="line"></span><br><span class="line"># Name the components on this agent</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = localhost</span><br><span class="line">a1.sources.r1.port = 44444</span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><p><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行它</span></span><br><span class="line">bin/flume-ng agent --conf conf --conf-file example.conf --name a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="在配置文件中使用环境变量"><a href="#在配置文件中使用环境变量" class="headerlink" title="在配置文件中使用环境变量"></a>在配置文件中使用环境变量</h3><p>Using environment variables in configuration files</p><p>Flume能够替换配置中的环境变量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a1.sources = r1</span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = 0.0.0.0</span><br><span class="line">a1.sources.r1.port = $&#123;NC_PORT&#125;</span><br><span class="line">a1.sources.r1.channels = c1</span><br></pre></td></tr></table></figure><p><strong>注意: 环境变量目前只使用于Value，不适用于Key。</strong></p><p><br><br><br></p><h3 id="记录原始数据"><a href="#记录原始数据" class="headerlink" title="记录原始数据"></a>记录原始数据</h3><p>Logging raw data</p><p>在许多生产环境中记录流经管道的原始数据流不是所希望的行为，因为这可能导致泄露敏感数据或安全相关配置到Flume日志文件。默认情况下，Flume不会记录此类信息。另一方法，如果数据管道出错，Flume也将尝试提供DEBUG信息。</p><p>为了能够记录事件和配置相关的数据，除了 <code>log4j</code> 属性外，还必须设置一些Java系统属性。<br>要启用与配置相关的日志记录，请设置Java系统属性 <code>-Dorg.apache.flume.log.printconfig=true</code> 。这也可以在命令行上进行传递，也可以在 <code>flume-env.sh</code> 中的 <code>JAVA_OPTS</code> 变量中设置。</p><p>要启用数据记录，请按照上述相同方式设置Java系统属性 <code>-Dorg.apache.flume.log.rawdata=true</code> 。对于大多数组件，还必须将 <code>log4j</code> 日志记录级别设置为DEBUG或TRACE，以使特定于事件的日志记录显示在Flume日志中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启用配置日志记录和原始数据日志记录的示例，同时还将Log4j日志级别设置为DEBUG以用于控制台输出</span><br><span class="line">bin/flume-ng agent --conf conf --conf-file example.conf --name a1 -Dflume.root.logger=DEBUG,console -Dorg.apache.flume.log.printconfig=true -Dorg.apache.flume.log.rawdata=true</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Zookeeeper基础配置"><a href="#Zookeeeper基础配置" class="headerlink" title="Zookeeeper基础配置"></a>Zookeeeper基础配置</h3><p>Zookeeper based Configuration</p><p>Flume支持通过<strong>Zookeeper</strong>配置Agent的配置。这是一个实验性功能。配置文件需要在可配置前缀下的Zookeeper中上传。配置文件存储在Zookeeper Node Data中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Agent1和Agent2的Zookeeper Node Tree的示例</span><br><span class="line">- /flume</span><br><span class="line"> |- /a1 [Agent config file]</span><br><span class="line"> |- /a2 [Agent config file]</span><br></pre></td></tr></table></figure><p>一旦上传了配置文件，使用以下选项启动Agent:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -z, Zookeeper connection string. Comma separated list of hostname:port</span></span><br><span class="line"><span class="comment"># -p, Base Path in Zookeeper to store Agent configurations</span></span><br><span class="line"></span><br><span class="line"> bin/flume-ng agent –conf conf -z zkhost:2181,zkhost1:2181 -p /flume –name a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="安装第三方插件"><a href="#安装第三方插件" class="headerlink" title="安装第三方插件"></a>安装第三方插件</h3><p>Installing third-party plugins</p><p>Flume拥有完整的基于插件的架构。虽然Flume附带了许多开箱即用的sources, channels, sinks, serializers…但许多实现斗鱼Flume分开运行。</p><p>虽然通过将自己的jar包添加到 <code>flume-env.sh</code> 文件中的 <code>FLUME_CLASSPATH</code> 变量值，始终可以包含自定义Flume组件。但Flume现在支持一个名为 <code>plugins.d</code> 的特殊目录，该目录会自动获取以特定格式打包的插件。</p><p><br></p><p><strong>插件目录</strong><br>The plugins.d directory</p><p><code>plugins.d</code> 目录位于 <code>$FLUME_HOME/plugins.d</code>。在启动时，<code>flume-ng</code> 启动脚本在 <code>plugins.d</code> 目录中查找符合以下格式的插件，并在启动java时将它们包含在正确的路径中。</p><p><br></p><p><strong>插件目录布局</strong><br>Directory layout for plugins</p><p><code>plugins.d</code> 中的每个插件(子目录)最多可以有三个子目录:</p><ol><li><code>lib</code> - the plugin’s jar(s)</li><li><code>libext</code> - the plugin’s dependency jar(s)</li><li><code>native</code> - any required native libraries, such as <code>.so</code> files</li></ol><p>栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins.d/</span><br><span class="line">plugins.d/custom-source-1/</span><br><span class="line">plugins.d/custom-source-1/lib/my-source.jar</span><br><span class="line">plugins.d/custom-source-1/libext/spring-core-2.5.6.jar</span><br><span class="line">plugins.d/custom-source-2/</span><br><span class="line">plugins.d/custom-source-2/lib/custom.jar</span><br><span class="line">plugins.d/custom-source-2/native/gettext.so</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="数据摄取"><a href="#数据摄取" class="headerlink" title="数据摄取"></a>数据摄取</h2><p>Data ingestion</p><p>Flume支持许多从外部源摄取数据的机制。</p><p><br></p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>可使用RPC机制将给定文件发送到Flume Source:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 栗子</span></span><br><span class="line"><span class="comment"># 将日志内容发送到监听该端口的Flume Source</span></span><br><span class="line">bin/flume-ng avro-client -H localhost -p 41414 -F /usr/logs/log.10</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>Executing commands</p><p>有一个exec source执行给定的命令并消费输出。</p><p><br><br><br></p><h3 id="网路流"><a href="#网路流" class="headerlink" title="网路流"></a>网路流</h3><p>Network streams</p><p>Flume支持以下机制从常用日志流(log stream)类型中读取数据。如:</p><ul><li>Avro</li><li>Thrift</li><li>Syslog</li><li>Netcat</li></ul><p><br><br><br><br><br></p><h2 id="多个代理流"><a href="#多个代理流" class="headerlink" title="多个代理流"></a>多个代理流</h2><p>Setting multi-agent flow</p><p><img src="/images/Flume/flume-multi-agent-flow.png" alt></p><p>为了跨多个代理/跳(multiple agents/hops)的数据流，先前代理的接收器和当前代理的源是同一类型，接收器指向源的hostname/ip和port。</p><p><br><br><br><br><br></p><h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><p>Consolidation</p><p>日志收集中非常常见的情况是生成大量日志的客户端将数据发送到连接到存储子系统的少数消费者代理。例如，从数百个Web服务器收集的日志发送给写入HDFS集群的十几个代理。</p><p>这可以通过在Flume中使用接收器配置多个第一层代理，所有这些代理都指向单个源。第二层代理商的源将接收的事件合并到单个通道中，该通道有接收器消费到最终的目的地。</p><p><img src="/images/Flume/flume-consolidation.png" alt></p><p><br><br><br><br><br></p><h2 id="多路复用流"><a href="#多路复用流" class="headerlink" title="多路复用流"></a>多路复用流</h2><p>Multiplexing the flow</p><p>Flume支持将事件流多路复用到一个或多个目的地。这是通过定义可以复制或选择性地将事件路由到一个或多个通道的流复用器来实现的。</p><p><img src="/images/Flume/flume-multiplexing-flow.png" alt></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><a href="https://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#configuration" target="_blank" rel="noopener">Configuration</a></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h1><p><a href="https://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#configuration-filters" target="_blank" rel="noopener">Configuration Filters</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wikipedia&lt;/li&gt;
&lt;li&gt;Flume: &lt;a href=&quot;https://flume.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://flume.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Flume docs: &lt;a href=&quot;https://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ELRH7x86_64&lt;/li&gt;
&lt;li&gt;Flume v1.9.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Apache" scheme="https://zhang21.github.io/tags/Apache/"/>
    
      <category term="DataAnalysis" scheme="https://zhang21.github.io/tags/DataAnalysis/"/>
    
      <category term="Flume" scheme="https://zhang21.github.io/tags/Flume/"/>
    
  </entry>
  
  <entry>
    <title>Sqoop</title>
    <link href="https://zhang21.github.io/2019/03/07/Sqoop/"/>
    <id>https://zhang21.github.io/2019/03/07/Sqoop/</id>
    <published>2019-03-07T01:25:20.000Z</published>
    <updated>2019-03-07T01:30:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>wikipedia</li><li>sqoop: <a href="https://sqoop.apache.org/" target="_blank" rel="noopener">https://sqoop.apache.org/</a></li></ul><p>环境:</p><ul><li>ELRH7x84_64</li><li>Sqoop v1.4.7</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>Apache Sqoop</strong> 是一个命令行界面(CLI)的应用程序工具，使用Java开发，用于在<strong>关系型数据库</strong>和<strong>Hadoop</strong>之间传输数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wikipedia&lt;/li&gt;
&lt;li&gt;sqoop: &lt;a href=&quot;https://sqoop.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://sqoop.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ELRH7x84_64&lt;/li&gt;
&lt;li&gt;Sqoop v1.4.7&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Apache" scheme="https://zhang21.github.io/tags/Apache/"/>
    
      <category term="DataAnalysis" scheme="https://zhang21.github.io/tags/DataAnalysis/"/>
    
      <category term="Sqoop" scheme="https://zhang21.github.io/tags/Sqoop/"/>
    
  </entry>
  
  <entry>
    <title>Hive</title>
    <link href="https://zhang21.github.io/2019/03/06/Hive/"/>
    <id>https://zhang21.github.io/2019/03/06/Hive/</id>
    <published>2019-03-06T00:57:20.000Z</published>
    <updated>2019-03-15T02:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>wikipedia</li><li>Hive: <a href="https://hive.apache.org/" target="_blank" rel="noopener">https://hive.apache.org/</a></li><li>Hive Wiki: <a href="https://cwiki.apache.org/confluence/display/Hive/Home" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/Home</a></li></ul><p>环境:</p><ul><li>ELRH7x86_64</li><li>Hive v3.1</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>Apache Hive</strong> 是一个建立在Hadoop架构之上的数据仓库，由Java编写，能够提供数据的精炼，查询和分析。</p><p>Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的SQL查询功能，可以将SQL语句转换为MapReduce任务进行运行。其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p><p>Apache Hive 数据仓库软件有助于使用SQL读取，编写和管理驻留在分布式存储中的大型数据集。可以将结构投影到已存储的数据中。还提供了命令行工具和JDBC驱动程序以将用户连接到Hive。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wikipedia&lt;/li&gt;
&lt;li&gt;Hive: &lt;a href=&quot;https://hive.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hive.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Hive Wiki: &lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/Home&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cwiki.apache.org/confluence/display/Hive/Home&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ELRH7x86_64&lt;/li&gt;
&lt;li&gt;Hive v3.1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Apache" scheme="https://zhang21.github.io/tags/Apache/"/>
    
      <category term="Hive" scheme="https://zhang21.github.io/tags/Hive/"/>
    
      <category term="DataAnalysis" scheme="https://zhang21.github.io/tags/DataAnalysis/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop</title>
    <link href="https://zhang21.github.io/2019/03/06/Hadoop/"/>
    <id>https://zhang21.github.io/2019/03/06/Hadoop/</id>
    <published>2019-03-05T16:57:11.000Z</published>
    <updated>2019-03-25T03:37:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>wikipeadia</li><li>Hadoop官网: <a href="https://hadoop.apache.org/" target="_blank" rel="noopener">https://hadoop.apache.org/</a></li><li>Apache Software Foundation: <a href="https://www.apache.org/" target="_blank" rel="noopener">https://www.apache.org/</a></li></ul><p><br></p><p>环境:</p><ul><li>RHEL7x86_64</li><li>Hadoop v3.2.0</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>Apache Hadoop</strong> 是一款支持数据密集型分布式应用程序，使用Java编写，并以Apache 2.0许可协议发布的开源软件框架。<br>Hadoop是根据谷歌公司发表的MapReduce和Google文件系统的论文自行实现而成。所有的Hadoop模块都有一个基本假设，即硬件故障是常见情况，应该由框架自动处理。</p><p>Apach Hadoop项目开发了用于可靠(Reliable)，可扩展(Scalable)的分布式计算(Distributed Computing)的开源软件。</p><p>Hadoop框架透明地为应用提供可靠性和数据移动。它实现了名为MapReduce的编程范式：应用程序被分割成许多小部分，而每个部分都能在集群中的任意节点上运行或重新运行。此外，Hadoop还提供了分布式文件系统，用以存储所有计算节点的数据，这为整个集群带来了非常高的带宽。MapReduce和分布式文件系统的设计，使得整个框架能够自动处理节点故障。它使应用程序与成千上万的独立计算的计算机和PB级的数据连接起来。</p><p><img src="/images/Hadoop/hadoop-logo.jpg" alt></p><p><br></p><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>Hadoop 项目包括以下模块:</p><ul><li><strong>Hadoop Common</strong>: 支持其它Hadoop模块的常用实用程序</li><li><strong>Hadoop Distributed File System (HDFS)</strong>: 一种分布式文件系统，提供对应用程序数据的高吞吐量访问</li><li><strong>Hadoop YARN</strong>: 用于作业调度和集群资源管理的框架</li><li><strong>Hadoop MapReduce</strong>: 基于YARN的系统，用于并行处理大型数据集</li><li><strong>Hadoop Ozone</strong>: Hadoop的对象存储</li><li><strong>Hadoop Submarine</strong>: Hadoop的机器学习引擎</li></ul><p><br><br><br><br><br></p><h2 id="相关项目"><a href="#相关项目" class="headerlink" title="相关项目"></a>相关项目</h2><p>现在普遍认为整个 <strong>Apache Hadoop Platform</strong> 包括了许多项目:</p><ul><li><strong>Ambari</strong>: 一个基于Web的工具，用于配置，管理和监控Apache Hadoop集群。包括对HDFS, MapReduce, Hive, HBase, ZooKeeper, Pig, Sqoop…的支持。它还提供了一个用于查看群集运行状况的仪表板，用于查看各个程序的状态</li><li><strong>Avro</strong>：数据序列化系统。新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制</li><li><strong>Cassandra</strong>: 可扩展的多主数据库，没有单点故障</li><li><strong>Chukwa</strong>: 用于管理大型分布式系统的数据收集系统</li><li><strong>Flume</strong>: 一种分布式，可靠且可用的软件。用于高效收集(collecting)，聚合(aggregating)和移动(moving)大量日志数据</li><li><strong>HBase</strong>：可扩展的分布式NoSQL列数据库，支持大型表的结构化数据存储。类似谷歌公司BigTable</li><li><strong>Hive</strong>：一种数据仓库基础结构，提供数据摘要和即席查询。构建于hadoop之上的数据仓库，通过一种类SQL语言HiveQL为用户提供数据的归纳、查询和分析等功能。Hive最初由Facebook贡献</li><li><strong>Mahout</strong>：可扩展的机器学习和数据挖掘库</li><li><strong>Pig</strong>: 用于并行计算的高级数据流语言和执行框架</li><li><strong>Spark</strong>: 适用于Hadoop数据的快速通用计算引擎。Spark提供了一种简单而富有表现力的编程模型，支持广泛的应用程序</li><li><strong>Sqoop</strong>：结构化数据（如关系数据库）与Apache Hadoop之间的数据转换工具</li><li><strong>Tez</strong>: 基于Hadoop YARN的通用数据流编程框架，它提供了一个强大而灵活的引擎来执行任意DAG任务来处理批处理和交互式用例的数据</li><li><strong>ZooKeeper</strong>：适用于分布式应用程序的高性能协调服务。提供类似Google Chubby的功能，由Facebook贡献</li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="General"><a href="#General" class="headerlink" title="General"></a>General</h1><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Overview</p><p><strong>Node Attributes Support in YARN</strong></p><p>节点属性(Node Attribute)有助于根据节点标记(tag)节点上的多个标签(label)，并支持根据这些标签的表达式放置容器。</p><p><br></p><p><strong>Hadoop Submarine on YARN</strong></p><p>Hadoop Submarine 使数据工程师能够在数据所在的同一Hadoop YARN集群上轻松开发(develop)、训练(train)和部署(deploy)深度学习模型(TensorFlow)。</p><p><br></p><p><strong>Storage Policy Satisfier</strong></p><p>支持HDFS(Hadoop Distributed File System)应用程序，以便在文件/目录上设置存储策略时在存储类型之间移动块(block)。</p><p><br></p><p><strong>ABFS Filesystem connector</strong></p><p>支持最新的Azure Datalake Gen2 Storage。</p><p><br></p><p><strong>Enhanced S3A connector</strong></p><p>支持增强型S3A连接器，包括更好地恢复受限制的AWS S3和DynamoDB IO。</p><p><br></p><p><strong>Upgrades for YARN long running services</strong></p><p>支持通过YARN Native Service API和CLI对长时间运行的容器进行就地无缝(seamless)升级。</p><p><br><br><br><br><br></p><h2 id="单节点集群"><a href="#单节点集群" class="headerlink" title="单节点集群"></a>单节点集群</h2><p>Setting up a Single Node Cluster</p><p><br></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>本节介绍如何设置和配置单节点Hadoop集群，以便你可以快速使用Hadoop MapReduce和HDFS执行简单的操作。</p><p><br><br><br></p><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><ul><li><p><strong>支持的平台</strong></p><ul><li>GNU/Linux: Hadoop has been demonstrated on GNU/Linux clusters with 2000 nodes</li><li>Windows is also a supported platform but the followings steps are for Linux only.</li></ul></li><li><p><strong>依赖软件(Linux)</strong></p><ul><li>Java: 具体版本参考 <a href="https://wiki.apache.org/hadoop/HadoopJavaVersions" target="_blank" rel="noopener">HadoopJavaVersions</a></li><li>ssh: 必须运行sshd才能使用管理远程Hadoop守护程序的Hadoop脚本，建议按照pdsh以实现更好的ssh资源管子</li></ul></li><li><p><strong>安装软件</strong></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">sudo apt-get install ssh pdsh</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>获取Hadoop发行版，请从<a href="http://www.apache.org/dyn/closer.cgi/hadoop/common/" target="_blank" rel="noopener">Apache Download Mirrors</a>下载。</p><p><br><br><br></p><h3 id="准备启动Hadoop集群"><a href="#准备启动Hadoop集群" class="headerlink" title="准备启动Hadoop集群"></a>准备启动Hadoop集群</h3><p>解压前面下载的Hadoop发行版，编辑<code>hadoop/etc/hadoop/hadoop-env.sh</code>以定义一些参数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hadoop/etc/hadoop/hadoop-env.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set to the root of your Java installation</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8.0_191-amd64</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME= /opt/hadoop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于我是使用rpm安装jdk8，所以为/usr/java/jdk1.8.0_191-amd64</span></span><br><span class="line"><span class="comment"># 我的hadoop放置于/opt/hadoop</span></span><br></pre></td></tr></table></figure><p>接着运行以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bin/hadoop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这将显示Hadoop的使用文档</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>有三种方式来启动Hadoop集群:</strong></p><ul><li>Local (Standalone) Mode</li><li>Pseudo-Distributed Mode</li><li>Fully-Distributed Mode</li></ul><p><br><br><br><br><br></p><h3 id="Standalone"><a href="#Standalone" class="headerlink" title="Standalone"></a>Standalone</h3><p>默认情况下，Hadoop配置为non-distibuted模式运行，作为单个Java进程。这对调试很有用。</p><p><br><br><br></p><h3 id="Pseudo-Distributed-Operation"><a href="#Pseudo-Distributed-Operation" class="headerlink" title="Pseudo-Distributed Operation"></a>Pseudo-Distributed Operation</h3><p>Hadoop也可以运行在伪分布模式下的单节点上，其中每个Hadoop Daemon在单独的java进程中运行。</p><p><br></p><p><strong>配置</strong><br><code>hadoop/etc/hadoop/core-site.xml</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>hadoop/etc/hadoop/hdfs-site.xml</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>设置 passphraseless ssh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查是否可以下无密码(passphrase)的情况下ssh到localhost</span></span><br><span class="line">ssh localhost</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不行，请执行无密码登录操作</span></span><br><span class="line">ssh-keygen -t rsa -P <span class="string">''</span> -f ~/.ssh/id_rsa</span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">chmod 0600 ~/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后再执行此操作</span></span><br><span class="line">ssh localhost</span><br></pre></td></tr></table></figure><p><br></p><p><strong>执行</strong></p><p>以下说明在本地运行MapReduce job。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，以下位于hadoop目录</span></span><br><span class="line"><span class="comment"># 我的为 /opt/hadoop</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Format the filesystem</span></span><br><span class="line"><span class="comment"># namenode - run the DFS namenode</span></span><br><span class="line">bin/hdfs namenode -format</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Start NameNode daemon and DataNode daemon</span></span><br><span class="line">sbin/start-dfs.sh</span><br><span class="line"><span class="comment"># 日志输出到$HADOOP_HOME/logs</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Browse the web interface for the NameNode; by default it is available at:</span></span><br><span class="line">NameNode - http://localhost:9870/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Make the HDFS directories required to execute MapReduce jobs</span></span><br><span class="line">bin/hdfs dfs -mkdir /user</span><br><span class="line">bin/hdfs dfs -mkdir /user/&lt;username&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. Copy the input files into the distributed filesystem</span></span><br><span class="line">bin/hdfs dfs -mkdir input</span><br><span class="line">bin/hdfs dfs -put etc/hadoop/*.xml input</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. Run some of the examples provided</span></span><br><span class="line">bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.0.jar grep input output <span class="string">'dfs[a-z.]+'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. Examine the output files: Copy the output files from the distributed filesystem to the local filesystem and examine them</span></span><br><span class="line">bin/hdfs dfs -get output output</span><br><span class="line"><span class="comment"># cat output/*</span></span><br><span class="line"><span class="comment"># bin/hdfs dfs -cat output/*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. When you’re done, stop the daemons with</span></span><br><span class="line">sbin/stop-dfs.sh</span><br></pre></td></tr></table></figure><p><br></p><p><strong>YARN on a Single Node</strong></p><p>你可以通过设置一些参数并运行ResourceManager Daemon和NodeManager Daemon，以伪分布模式在YARN上运行MapReduce Job。<br>以下指令假设你已运行上面的1-4步。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Configure parameters as follows</span></span><br><span class="line"><span class="comment"># etc/hadoop/mapred-site.xml</span></span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.application.classpath&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;<span class="variable">$HADOOP_MAPRED_HOME</span>/share/hadoop/mapreduce/*:<span class="variable">$HADOOP_MAPRED_HOME</span>/share/hadoop/mapreduce/lib/*&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># etc/hadoop/yarn-site.xml</span></span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Start ResourceManager daemon and NodeManager daemon</span></span><br><span class="line">sbin/start-yarn.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Browse the web interface for the ResourceManager; by default it is available at</span></span><br><span class="line"><span class="comment"># ResourceManager - http://localhost:8088/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Run a MapReduce job</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. When you’re done, stop the daemons with</span></span><br><span class="line">sbin/stop-yarn.sh</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="集群设置"><a href="#集群设置" class="headerlink" title="集群设置"></a>集群设置</h2><p>Hadoop Cluster Setup</p><p>本节描述了如何安装和配置Hadoop集群，范围从几个节点到数千个节点。<br>但本节不包括安全性和高可用性等高级主题。</p><p><br></p><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><ul><li>Java</li><li>Hadoop</li></ul><p><br><br><br></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>通常，集群中的一台主机被指定为<strong>NameNode</strong>，而另一台主机被指定为<strong>ResourceManager</strong>，这些都是<strong>Master</strong>。其它服务(Web App Proxy Server, MapReduce…)通常在专用硬件或共享基础架构上运行，具体取决于负载。</p><p>集群中的其余主机充当<strong>DataNode</strong>和<strong>NodeManager</strong>。这些都是<strong>Worker</strong>。</p><p><br><br><br></p><h3 id="在非安全模式下配置Hadoop"><a href="#在非安全模式下配置Hadoop" class="headerlink" title="在非安全模式下配置Hadoop"></a>在非安全模式下配置Hadoop</h3><p>Configuring Hadoop in Non-Secure Mode</p><p>Hadoop的Java配置由两种类型的重要配置文件驱动:</p><ul><li><strong>只读(ReadOnly)的默认配置</strong><ul><li><code>core-default.xml</code></li><li><code>hdfs-default.xml</code></li><li><code>yarn-default.xml</code></li><li><code>mapred-default.xml</code></li></ul></li><li><strong>特定站点(site-specific)的配置</strong><ul><li><code>etc/hadoop/core-site.xml</code></li><li><code>etc/hadoop/hdfs-site.xml</code></li><li><code>etc/hadoop/yarn-site.xml</code></li><li><code>etc/hadoop/mapred-site.xml</code></li></ul></li></ul><p>此外，你可以通过<code>etc/hadoop/hadoop-env.sh</code>和<code>etc/hadoop/yarn-env.sh</code>配置特定于站点的值来控制分发的<code>bin/</code>目录下的Hadoop脚本。</p><p><br></p><p>要配置Hadoop Cluster，你需要配置Hadoop Daemon执行的<code>environment</code>以及<code>configuration parameters</code>。</p><ul><li>HDFS Daemon是 <strong>NameNode</strong>, <strong>SecondaryNameNode</strong> 和 <strong>DataNode</strong></li><li>YARN Daemon是 <strong>ResourceManager</strong>, <strong>NodeManager</strong> 和 <strong>WebAppProxy</strong></li><li>如果要使用MapReduce，则 <strong>MapReduce Job History Server</strong> 也将运行</li><li>对于大型安装，这些通常在不同的主机上运行</li></ul><p><br></p><h4 id="配置Hadoop守护进程的环境"><a href="#配置Hadoop守护进程的环境" class="headerlink" title="配置Hadoop守护进程的环境"></a>配置Hadoop守护进程的环境</h4><p>Configuring Environment of Hadoop Daemons</p><p>管理员应该使用 <code>etc/hadoop/hadoop-env.sh</code>， 可选择 <code>etc/hadoop/mapred-env.sh</code>, 以及 <code>etc/hadoop/yarn-env.sh</code>脚本来对Hadoop守护进程的进程环境进行特定站点的自定义配置。</p><p>至少，您必须指定 <code>JAVA_HOME</code>，以便在每个远程节点上正确定义它。</p><p>管理员可使用下表中的配置项配置各个守护进程:</p><div class="table-container"><table><thead><tr><th>Daemon</th><th>Environment Variable</th></tr></thead><tbody><tr><td>NameNode</td><td>HDFS_NAMENODE_OPTS</td></tr><tr><td>DataNode</td><td>HDFS_DATANODE_OPTS</td></tr><tr><td>Secondary NameNode</td><td>HDFS_SECONDARYNAMENODE_OPTS</td></tr><tr><td>ResourceManager</td><td>YARN_RESOURCEMANAGER_OPTS</td></tr><tr><td>NodeManager</td><td>YARN_NODEMANAGER_OPTS</td></tr><tr><td>WebAppProxy</td><td>YARN_PROXYSERVER_OPTS</td></tr><tr><td>Map Reduce Job History Server</td><td>MAPRED_HISTORYSERVER_OPTS</td></tr></tbody></table></div><p><br></p><p>其它你可自定义的有用的配置项包括:</p><ul><li><code>HADOOP_PID_DIR</code>:  The directory where the daemons’ process id files are stored</li><li><code>HADOOP_LOG_DIR</code>:  The directory where the daemons’ log files are stored. Log files are automatically created if they don’t exist</li><li><code>HADOOP_HEAPSIZE_MAX</code>:  The maximum amount of memory to use for the Java heapsize. Units supported by the JVM are also supported here. If no unit is present, it will be assumed the number is in megabytes. By default, Hadoop will let the JVM determine how much to use. This value can be overriden on a per-daemon basis using the appropriate _OPTS variable listed above. For example, setting HADOOP_HEAPSIZE_MAX=1g and HADOOP_NAMENODE_OPTS=”-Xmx5g” will configure the NameNode with 5GB heap.</li></ul><p>在大多数情况下，你需要指定 <code>HADOOP_PID_DIR</code> 和 <code>HADOOP_LOG</code> 目录，以便它们只能由将要运行Hadoop守护进程的用户写入。否则可能会发生符号链接攻击。</p><p><br><br><br></p><h4 id="配置Hadoop守护进程"><a href="#配置Hadoop守护进程" class="headerlink" title="配置Hadoop守护进程"></a>配置Hadoop守护进程</h4><p>Configuring the Hadoop Daemons</p><p>本节介绍给定配置文件中指定的重要参数。</p><ul><li><code>etc/hadoop/core-site.xml</code></li></ul><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>fs.defaultFS</code></td><td>NameNode URI</td><td>hdfs://host:port/</td></tr><tr><td><code>io.file.buffer.size</code></td><td>131072</td><td>Size of read/write buffer used in SequenceFiles.</td></tr></tbody></table></div><p><br></p><ul><li><code>etc/hadoop/hdfs-site.xml</code></li><li><strong>NameNode配置</strong></li></ul><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>dfs.namenode.name.dir</code></td><td>Path on the local filesystem where the NameNode stores the namespace and transactions logs persistently.</td><td>If this is a comma-delimited list of directories then the name table is replicated in all of the directories, for redundancy.</td></tr><tr><td><code>dfs.hosts /</code> <br> <code>dfs.hosts.exclude</code></td><td>List of permitted/excluded DataNodes.</td><td>If necessary, use these files to control the list of allowable datanodes.</td></tr><tr><td><code>dfs.blocksize</code></td><td>268435456</td><td>HDFS blocksize of 256MB for large file-systems.</td></tr><tr><td><code>dfs.namenode.handler.count</code></td><td>100</td><td>More NameNode server threads to handle RPCs from large number of DataNodes.</td></tr></tbody></table></div><p><br></p><ul><li><strong>DataNode配置</strong></li></ul><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td>dfs.datanode.data.dir</td><td>Comma separated list of paths on the local filesystem of a DataNode where it should store its blocks.</td><td>If this is a comma-delimited list of directories, then data will be stored in all named directories, typically on different devices.</td></tr></tbody></table></div><p><br></p><ul><li><code>etc/hadoop/yarn-site.xml</code></li><li><strong>ResourceManager和NodeManager配置</strong></li></ul><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>yarn.acl.enable</code></td><td>true / false</td><td>Enable ACLs? Defaults to false.</td></tr><tr><td><code>yarn.admin.acl</code></td><td>Admin ACL</td><td>ACL to set admins on the cluster. ACLs are of for comma-separated-usersspacecomma-separated-groups. Defaults to special value of * which means anyone. Special value of just space means no one has access.</td></tr><tr><td><code>yarn.log-aggregation-enable</code></td><td>false</td><td>Configuration to enable or disable log aggregation</td></tr></tbody></table></div><br><ul><li><strong>ResourceManager配置</strong></li></ul><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>yarn.resourcemanager.address</code></td><td>ResourceManager host:port for clients to submit jobs.</td><td>host:port If set, overrides the hostname set in yarn.resourcemanager.hostname.</td></tr><tr><td><code>yarn.resourcemanager.scheduler.address</code></td><td>ResourceManager host:port for ApplicationMasters to talk to Scheduler to obtain resources.</td><td>host:port If set, overrides the hostname set in yarn.resourcemanager.hostname.</td></tr><tr><td><code>yarn.resourcemanager.resource-tracker.address</code></td><td>ResourceManager host:port for NodeManagers.</td><td>host:port If set, overrides the hostname set in yarn.resourcemanager.hostname.</td></tr><tr><td><code>yarn.resourcemanager.admin.address</code></td><td>ResourceManager host:port for administrative commands.</td><td>host:port If set, overrides the hostname set in yarn.resourcemanager.hostname.</td></tr><tr><td><code>yarn.resourcemanager.webapp.address</code></td><td>ResourceManager web-ui host:port.</td><td>host:port If set, overrides the hostname set in yarn.resourcemanager.hostname.</td></tr><tr><td><code>yarn.resourcemanager.hostname</code></td><td>ResourceManager host.</td><td>host Single hostname that can be set in place of setting all yarn.resourcemanager*address resources. Results in default ports for ResourceManager components.</td></tr><tr><td><code>yarn.resourcemanager.scheduler.class</code></td><td>ResourceManager Scheduler class.</td><td>CapacityScheduler (recommended), FairScheduler (also recommended), or FifoScheduler.</td></tr><tr><td><code>yarn.scheduler.minimum-allocation-mb</code></td><td>Minimum limit of memory to allocate to each container request at the Resource Manager.</td><td>In MBs</td></tr><tr><td><code>yarn.scheduler.maximum-allocation-mb</code></td><td>Maximum limit of memory to allocate to each container request at the Resource Manager.</td><td>In MBs</td></tr><tr><td><code>yarn.resourcemanager.nodes.include-path</code> / <br> <code>yarn.resourcemanager.nodes.exclude-path</code></td><td>List of permitted/excluded NodeManagers.</td><td>If necessary, use these files to control the list of allowable NodeManagers.</td></tr></tbody></table></div><p><br></p><ul><li><strong>NodeManager配置</strong></li></ul><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>yarn.nodemanager.resource.memory-mb</code></td><td>Resource i.e. available physical memory, in MB, for given NodeManager</td><td>Defines total available resources on the NodeManager to be made available to running containers</td></tr><tr><td><code>yarn.nodemanager.vmem-pmem-ratio</code></td><td>Maximum ratio by which virtual memory usage of tasks may exceed physical memory</td><td>The virtual memory usage of each task may exceed its physical memory limit by this ratio. The total amount of virtual memory used by tasks on the NodeManager may exceed its physical memory usage by this ratio.</td></tr><tr><td><code>yarn.nodemanager.local-dirs</code></td><td>Comma-separated list of paths on the local filesystem where intermediate data is written.</td><td>Multiple paths help spread disk i/o.</td></tr><tr><td><code>yarn.nodemanager.log-dirs</code></td><td>Comma-separated list of paths on the local filesystem where logs are written.</td><td>Multiple paths help spread disk i/o.</td></tr><tr><td><code>yarn.nodemanager.log.retain-seconds</code></td><td>10800</td><td>Default time (in seconds) to retain log files on the NodeManager Only applicable if log-aggregation is disabled.</td></tr><tr><td><code>yarn.nodemanager.remote-app-log-dir</code></td><td>/logs</td><td>HDFS directory where the application logs are moved on application completion. Need to set appropriate permissions. Only applicable if log-aggregation is enabled.</td></tr><tr><td><code>yarn.nodemanager.remote-app-log-dir-suffix</code></td><td>logs</td><td>Suffix appended to the remote log dir. Logs will be aggregated to ${yarn.nodemanager.remote-app-log-dir}/${user}/${thisParam} Only applicable if log-aggregation is enabled.</td></tr><tr><td><code>yarn.nodemanager.aux-services</code></td><td>mapreduce_shuffle</td><td>Shuffle service that needs to be set for Map Reduce applications.</td></tr><tr><td><code>yarn.nodemanager.env-whitelist</code></td><td>Environment properties to be inherited by containers from NodeManagers</td><td>For mapreduce application in addition to the default values HADOOP_MAPRED_HOME should to be added. <br> 可能的值有: <code>JAVA_HOME</code>, <code>HADOOP_COMMON_HOME</code>, <code>HADOOP_HDFS_HOME</code>, <code>HADOOP_CONF_DIR</code>, <code>CLASSPATH_PREPEND_DISTCACHE</code>, <code>HADOOP_YARN_HOME</code>, <code>HADOOP_MAPRED_HOME</code></td></tr></tbody></table></div><p><br></p><ul><li><strong>History Server配置</strong></li></ul><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>yarn.log-aggregation.retain-seconds</code></td><td>-1</td><td>How long to keep aggregation logs before deleting them. -1 disables. Be careful, set this too small and you will spam the name node.</td></tr><tr><td><code>yarn.log-aggregation.retain-check-interval-seconds</code></td><td>-1</td><td>Time between checks for aggregated log retention. If set to 0 or a negative value then the value is computed as one-tenth of the aggregated log retention time. Be careful, set this too small and you will spam the name node.</td></tr></tbody></table></div><p><br></p><ul><li><code>etc/hadoop/mapred-site.xml</code></li><li><strong>MapReduce Applications配置</strong></li></ul><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>mapreduce.framework.name</code></td><td>yarn</td><td>Execution framework set to Hadoop YARN.</td></tr><tr><td><code>mapreduce.map.memory.mb</code></td><td>1536</td><td>Larger resource limit for maps.</td></tr><tr><td><code>mapreduce.map.java.opts</code></td><td>-Xmx1024M</td><td>Larger heap-size for child jvms of maps.</td></tr><tr><td><code>mapreduce.reduce.memory.mb</code></td><td>3072</td><td>Larger resource limit for reduces.</td></tr><tr><td><code>mapreduce.reduce.java.opts</code></td><td>-Xmx2560M</td><td>Larger heap-size for child jvms of reduces.</td></tr><tr><td><code>mapreduce.task.io.sort.mb</code></td><td>512</td><td>Higher memory-limit while sorting data for efficiency.</td></tr><tr><td><code>mapreduce.task.io.sort.factor</code></td><td>100</td><td>More streams merged at once while sorting files.</td></tr><tr><td><code>mapreduce.reduce.shuffle.parallelcopies</code></td><td>50</td><td>Higher number of parallel copies run by reduces to fetch outputs from very large number of maps.</td></tr></tbody></table></div><p><br></p><ul><li><strong>MapReduce JobHistory Server配置</strong></li></ul><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>mapreduce.jobhistory.address</code></td><td>MapReduce JobHistory Server host:port</td><td>Default port is 10020.</td></tr><tr><td><code>mapreduce.jobhistory.webapp.address</code></td><td>MapReduce JobHistory Server Web UI host:port</td><td>Default port is 19888.</td></tr><tr><td><code>mapreduce.jobhistory.intermediate-done-dir</code></td><td><code>/mr-history/tmp</code></td><td>Directory where history files are written by MapReduce jobs.</td></tr><tr><td><code>mapreduce.jobhistory.done-dir</code></td><td><code>/mr-history/done</code></td><td>Directory where history files are managed by the MR JobHistory Server.</td></tr></tbody></table></div><p><br><br><br></p><h3 id="监控NodeManager健康"><a href="#监控NodeManager健康" class="headerlink" title="监控NodeManager健康"></a>监控NodeManager健康</h3><p>Monitoring Health of NodeManagers</p><p>Hadoop提供了一种机制，管理员可通过该机制将NodeManager定期运行提供的脚本，以确定节点是否健康。</p><p>管理员可通过在脚本中执行对其选择的任何检查来确定节点是否处于正常状态。如果脚本检测到节点处于不健康状态，则必须以<strong>ERROR</strong>开头的字符串将其行输出到标准输出(std out)。NodeManager定期生成脚本并检查其输出。如果脚本的输出包含字符串<strong>ERROR</strong>(如上所述)，则节点的状态将报告为不健康(<strong>unhealthy</strong>)，并且ResourceManager将节点列入黑名单。之后便不会为此节点分配其它任务。但是，NodeManager继续运行脚本，因此如果节点再次变为健康(<strong>healthy</strong>)，它将自动从ResourceManager上的黑名单节点中被删除。在ResourceManger Web UI中，管理员可以使用节点的运行状况以及脚本的输出(如果不健康)。自节点健康依赖的时间也显示在Web UI上。</p><p>以下 <code>etc/hadoop/yarn-site.xml</code> 文件中的参数可用于控制节点健康监控脚本:</p><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>yarn.nodemanager.health-checker.script.path</code></td><td>Node health script</td><td>Script to check for node’s health status.</td></tr><tr><td><code>yarn.nodemanager.health-checker.script.opts</code></td><td>Node health script options</td><td>Options for script to check for node’s health status.</td></tr><tr><td><code>yarn.nodemanager.health-checker.interval-ms</code></td><td>Node health script interval</td><td>Time interval for running health script.</td></tr><tr><td><code>yarn.nodemanager.health-checker.script.timeout-ms</code></td><td>Node health script timeout interval</td><td>Timeout for health script execution.</td></tr></tbody></table></div><p>如果只有部分本地磁盘变坏，则运行健康检查的脚本不应该给出<strong>ERROR</strong>信息。NodeManager能够定期检查本地磁盘的运行状况（具体检查 <code>nodemanager-local-dirs</code> 和 <code>nodemanager-log-dirs</code> ），并在根据为配置属性 <code>yarn.nodemanager.disk-health-checker.min-healthy-disks</code> 设置的值达到坏目录数阈值(threshold of number of bad directories)，整个节点被标记为不健康，此信息也被发送到ResourceManager。引导磁盘(boot disk)中的故障也会被检查脚本所识别。</p><p><br><br><br></p><h3 id="Slaves-File"><a href="#Slaves-File" class="headerlink" title="Slaves File"></a>Slaves File</h3><p>在 <code>etc/hadoop/workers</code> 文件中列出所有Worker的hostname或IP addr，每行一个。帮助脚本将使用 <code>etc/hadoop/workers</code> 文件一次在多个主机上运行命令。它不用于任何基于Java的Hadoop配置。要使用此功能，必须为用于运行Hadoop的账户建立SSH信任(SSH无秘钥或Kerberos)。</p><p><br><br><br></p><h3 id="Rack-Awareness"><a href="#Rack-Awareness" class="headerlink" title="Rack Awareness"></a>Rack Awareness</h3><p>许多Hadoop组件都具有机架感知(<strong>rack-aware</strong>)功能，并利用网络拓扑结构提高性能和安全。Hadoop Daemons通过调用管理员配置的模块来获取集群中Workers的机架信息。</p><p>强烈建议在启动HDFS之前配置Rack Awareness！</p><p><br><br><br></p><h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p>Hadoop通过Apache Commons Logging框架使用<strong>Apache log4j</strong>进行日志记录。编辑 <code>etc/hadoop/log4j.properties</code> 文件以自定义Hadoop Daemons的日志记录配置。</p><p><br><br><br></p><h3 id="操作集群"><a href="#操作集群" class="headerlink" title="操作集群"></a>操作集群</h3><p>Operating the Hadoop Cluster</p><p>完成所有必要的配置后，将文件分发到所有主机上的 <code>HADOOP_CONF_DIR</code> 目录。这应该是所有主机上的同一个目录。</p><p>通常，建议HDFS和YARN使用分开的用户来运行。在大多数安装中，HDFS进程以<code>hdfs</code>用户运行；YARN使用<code>yarn</code>用户运行。</p><p><br></p><h4 id="Startup-and-Shutdown"><a href="#Startup-and-Shutdown" class="headerlink" title="Startup and Shutdown"></a>Startup and Shutdown</h4><p>Hadoop Startup and Hadoop Shutdown</p><p><strong>要启动Hadoop集群，你需要启动HDFS和YARN集群。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次启动HDFS时，必须对其进行格式化。将新的分布式文件系统(distributed fs)格式化为hdfs</span></span><br><span class="line">[hdfs]$ <span class="variable">$HADOOP_HOME</span>/bin/hdfs namenode -format &lt;cluster_name&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在指定节点以hdfs启动HDFS NameNode</span></span><br><span class="line">[hdfs]$ <span class="variable">$HADOOP_HOME</span>/bin/hdfs --daemon start namenode</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止NameNode</span></span><br><span class="line">[hdfs]$ <span class="variable">$HADOOP_HOME</span>/bin/hdfs --daemon stop namenode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在每个指定节点以hdfs启动HDFS DataNode</span></span><br><span class="line">[hdfs]$ <span class="variable">$HADOOP_HOME</span>/bin/hdfs --daemon start datanode</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止DataNode</span></span><br><span class="line">[hdfs]$ <span class="variable">$HADOOP_HOME</span>/bin/hdfs --daemon stop datanode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果配置了 etc/hadoop/worker 和 SSH信任，则可以使用使用程序脚本以hdfs启动HDFS进程</span></span><br><span class="line">[hdfs]$ <span class="variable">$HADOOP_HOME</span>/sbin/start-dfs.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止HDFS进程</span></span><br><span class="line">[hdfs]$ <span class="variable">$HADOOP_HOME</span>/sbin/stop-dfs.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># SSH trusted access</span></span><br><span class="line">ssh-keygen -t rsa -P <span class="string">''</span> -f ~/.ssh/id_rsa</span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">chmod 0600 ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment"># 也可将已有的公钥直接写入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以yarn在指定的ResourceManager上启动YARN</span></span><br><span class="line">[yarn]$ <span class="variable">$HADOOP_HOME</span>/bin/yarn --daemon start resourcemanager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止ResourceManager</span></span><br><span class="line">[yarn]$ <span class="variable">$HADOOP_HOME</span>/bin/yarn --daemon stop resourcemanager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以yarn在每台指定主机上运行脚本启动NodeManager</span></span><br><span class="line">[yarn]$ <span class="variable">$HADOOP_HOME</span>/bin/yarn --daemon start nodemanager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止NodeManager</span></span><br><span class="line">[yarn]$ <span class="variable">$HADOOP_HOME</span>/bin/yarn --daemon stop nodemanager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以yarn在WebAppProxy Server上启动Standalone WebAPPProxy Server</span></span><br><span class="line"><span class="comment"># 如果使用多个Server进行负载均衡，则应在每台Server上运行</span></span><br><span class="line">[yarn]$ <span class="variable">$HADOOP_HOME</span>/bin/yarn --daemon start proxyserver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止WebAppProxy server</span></span><br><span class="line">[yarn]$ <span class="variable">$HADOOP_HOME</span>/bin/yarn stop proxyserver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果配置了 etc/hadoop/workers 和 SSH信任，则可以以yarn实用程序脚本启动YARN进程</span></span><br><span class="line">[yarn]$ <span class="variable">$HADOOP_HOME</span>/sbin/start-yarn.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止YARN进程</span></span><br><span class="line">[yarn]$ <span class="variable">$HADOOP_HOME</span>/sbin/stop-yarn.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以mapred在指定的服务器上运行MapReduce JobHistory Server</span></span><br><span class="line">[mapred]$ <span class="variable">$HADOOP_HOME</span>/bin/mapred --daemon start historyserver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止MapReduce JobHistory Server</span></span><br><span class="line">[mapred]$ <span class="variable">$HADOOP_HOME</span>/bin/mapred --daemon stop historyserver</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Web-Interfaces"><a href="#Web-Interfaces" class="headerlink" title="Web Interfaces"></a>Web Interfaces</h3><p>一旦Hadoop Cluster启动并运行，请检查组件的Web UI。具体如下:</p><div class="table-container"><table><thead><tr><th>Daemon</th><th>Web Interface</th><th>Notes</th></tr></thead><tbody><tr><td>NameNode</td><td><code>http://nn_host:port/</code></td><td>Default HTTP port is 9870</td></tr><tr><td>ResourceManager</td><td><code>http://rm_host:port/</code></td><td>Default HTTP port is 8088</td></tr><tr><td>MapReduce JobHistory Server</td><td><code>http://jhs_host:port/</code></td><td>Default HTTP port is 19888</td></tr></tbody></table></div><p><br><br><br><br><br></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>Hadoop Commands Guide</p><p><br></p><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>所有Hadoop命令和子项目都遵循相同的基本结构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Usage</span></span><br><span class="line">shellcommand [SHELL_OPTIONS] [COMMAND] [GENERIC_OPTIONS] [COMMAND_OPTIONS]</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Shell Options</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--buildpathsEnables developer versions of jars.</span><br><span class="line"></span><br><span class="line">--config confdirOverwrites the default Configuration directory. Default is $HADOOP_HOME/etc/hadoop.</span><br><span class="line"></span><br><span class="line">--daemon modeIf the command supports daemonization (e.g., hdfs namenode), execute in the appropriate mode. Supported modes are start to start the process in daemon mode, stop to stop the process, and status to determine the active status of the process. status will return an LSB-compliant result code. If no option is provided, commands that support daemonization will run in the foreground. For commands that do not support daemonization, this option is ignored.</span><br><span class="line"></span><br><span class="line">--debugEnables shell level configuration debugging information</span><br><span class="line"></span><br><span class="line">--helpShell script usage information.</span><br><span class="line"></span><br><span class="line">--hostnamesWhen --workers is used, override the workers file with a space delimited list of hostnames where to execute a multi-host subcommand. If --workers is not used, this option is ignored.</span><br><span class="line"></span><br><span class="line">--hostsWhen --workers is used, override the workers file with another file that contains a list of hostnames where to execute a multi-host subcommand. If --workers is not used, this option is ignored.</span><br><span class="line"></span><br><span class="line">--loglevel loglevelOverrides the log level. Valid log levels are FATAL, ERROR, WARN, INFO, DEBUG, and TRACE. Default is INFO.</span><br><span class="line"></span><br><span class="line">--workersIf possible, execute this command on all hosts in the workers file.</span><br></pre></td></tr></table></figure><p><br></p><p><strong>Generic Options</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-archives &lt;comma separated list of archives&gt;Specify comma separated archives to be unarchived on the compute machines. Applies only to job.</span><br><span class="line">-conf &lt;configuration file&gt;Specify an application configuration file.</span><br><span class="line">-D &lt;property&gt;=&lt;value&gt;Use value for given property.</span><br><span class="line">-files &lt;comma separated list of files&gt;Specify comma separated files to be copied to the map reduce cluster. Applies only to job.</span><br><span class="line">-fs &lt;file:///&gt; or &lt;hdfs://namenode:port&gt;Specify default filesystem URL to use. Overrides ‘fs.defaultFS’ property from configurations.</span><br><span class="line">-jt &lt;local&gt; or &lt;resourcemanager:port&gt;Specify a ResourceManager. Applies only to job.</span><br><span class="line">-libjars &lt;comma seperated list of jars&gt;Specify comma separated jar files to include in the classpath. Applies only to job.</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>Hadoop Common Commands</p><p>所有这些命令都是从<code>hadoop</code>命令执行的。它分为:</p><ul><li>用户命令(User Commands): 对hadoop集群的用户有用的命令</li><li>管理命令(Administration Commands): 对hadoop集群的管理员有用的命令</li></ul><p><br></p><h4 id="用户命令"><a href="#用户命令" class="headerlink" title="用户命令"></a>用户命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">archive    <span class="comment">#Creates a hadoop archive</span></span><br><span class="line">checknative    <span class="comment">#This command checks the availability of the Hadoop native code</span></span><br><span class="line">classpath    <span class="comment">#Prints the class path needed to get the Hadoop jar and the required libraries</span></span><br><span class="line">conftest    <span class="comment">#Validates configuration XML files</span></span><br><span class="line">credential    <span class="comment">#Command to manage credentials, passwords and secrets within credential providers.</span></span><br><span class="line">distch    <span class="comment">#Change the ownership and permissions on many files at once.</span></span><br><span class="line">distcp    <span class="comment">#Copy file or directories recursively.</span></span><br><span class="line">dtutil    <span class="comment">#Utility to fetch and manage hadoop delegation tokens inside credentials files</span></span><br><span class="line">fs    <span class="comment">#This command is documented in the File System Shell Guide.</span></span><br><span class="line">gridmix    <span class="comment">#Gridmix is a benchmark tool for Hadoop cluster</span></span><br><span class="line">jar    <span class="comment">#Runs a jar file.</span></span><br><span class="line">jnipath    <span class="comment">#Print the computed java.library.path.</span></span><br><span class="line">kerbname    <span class="comment">#Convert the named principal via the auth_to_local rules to the Hadoop user name.</span></span><br><span class="line">kdiag    <span class="comment">#Diagnose Kerberos Problems</span></span><br><span class="line">key    <span class="comment">#Manage keys via the KeyProvider</span></span><br><span class="line">kms    <span class="comment">#Run KMS, the Key Management Server.</span></span><br><span class="line">trace    <span class="comment">#View and modify Hadoop tracing settings</span></span><br><span class="line">version    <span class="comment">#Prints the version.</span></span><br><span class="line">CLASSNAME    <span class="comment">#Runs the class named CLASSNAME. The class must be part of a package.</span></span><br><span class="line">envvars    <span class="comment">#Display computed Hadoop environment variables.</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Usage</span></span><br><span class="line">hadoop daemonlog -getlevel &lt;host:port&gt; &lt;classname&gt; [-protocol (http|https)]</span><br><span class="line">hadoop daemonlog -setlevel &lt;host:port&gt; &lt;classname&gt; &lt;level&gt; [-protocol (http|https)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 栗子</span></span><br><span class="line">bin/hadoop daemonlog -setlevel 127.0.0.1:9870 org.apache.hadoop.hdfs.server.namenode.NameNode DEBUG</span><br><span class="line">bin/hadoop daemonlog -getlevel 127.0.0.1:9871 org.apache.hadoop.hdfs.server.namenode.NameNode DEBUG -protocol https</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有以下守护进程</span></span><br><span class="line">Common    <span class="comment">#key management server</span></span><br><span class="line">HDFS    <span class="comment">#name node, secondary name node, data node, journal node, HttpFS server</span></span><br><span class="line">YARN    <span class="comment">#resource manager, node manager, Timeline server</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># hadoop shell commands全局设置</span><br><span class="line">etc/hadoop/hadoop-env.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 此文件允许高级用户覆盖某些shell 功能</span><br><span class="line">etc/hadoop/hadoop-user-functions.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 用户个人环境</span><br><span class="line">~/.hadooprc</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="FS-Shell"><a href="#FS-Shell" class="headerlink" title="FS Shell"></a>FS Shell</h2><p>FileSystem Shell</p><p>FS Shell包括了各种类似于shell的命令，它们直接与Hadoop分布式文件系统(HDFS)以及Hadoop支持的其它文件系统交互(如: Local FS, WebHDMIFS, S3 FS…)</p><p>All FS shell commands take path URIs as arguments.</p><p><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用方式</span></span><br><span class="line">bin/hadoop fs &lt;args&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Append single src, or multiple srcs from local file system to the destination file system</span></span><br><span class="line"> hadoop fs -appendToFile &lt;localsrc&gt; ... &lt;dst&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copies source paths to stdout.</span></span><br><span class="line">hadoop fs -cat [-ignoreCrc] URI [URI ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Returns the checksum information of a file</span></span><br><span class="line">hadoop fs -checksum URI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change group association of files</span></span><br><span class="line">hadoop fs -chgrp [-R] GROUP URI [URI ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Similar to the fs -put command, except that the source is restricted to a local file reference.</span></span><br><span class="line">hadoop fs -copyFromLocal &lt;localsrc&gt; URI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Similar to get command, except that the destination is restricted to a local file reference</span></span><br><span class="line">hadoop fs -copyToLocal [-ignorecrc] [-crc] URI &lt;localdst&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Count the number of directories, files and bytes under the paths that match the specified file pattern</span></span><br><span class="line">hadoop fs -count [-q] [-h] [-v] [-x] [-t [&lt;storage <span class="built_in">type</span>&gt;]] [-u] [-e] &lt;paths&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy files from source to destination</span></span><br><span class="line">hadoop fs -cp [-f] [-p | -p[topax]] URI [URI ...] &lt;dest&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">createSnapshot</span><br><span class="line">deleteSnapshot</span><br><span class="line">renameSnapshot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Displays free space</span></span><br><span class="line">hadoop fs -df [-h] URI [URI ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Displays sizes of files and directories contained in the given directory or the length of a file in case its just a file.</span></span><br><span class="line">hadoop fs -du [-s] [-h] [-v] [-x] URI [URI ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Displays a summary of file lengths.</span></span><br><span class="line">hadoop fs -dus &lt;args&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Permanently delete files in checkpoints older than the retention threshold from trash directory, and create new checkpoint.</span></span><br><span class="line">hadoop fs -expunge</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Finds all files that match the specified expression and applies selected actions to them</span></span><br><span class="line">hadoop fs -find &lt;path&gt; ... &lt;expression&gt; ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy files to the local file system</span></span><br><span class="line">hadoop fs -get [-ignorecrc] [-crc] [-p] [-f] &lt;src&gt; &lt;localdst&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy files to the local file system</span></span><br><span class="line">hadoop fs -get [-ignorecrc] [-crc] [-p] [-f] &lt;src&gt; &lt;localdst&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Displays the Access Control Lists (ACLs) of files and directories</span></span><br><span class="line">hadoop fs -getfacl [-R] &lt;path&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Displays the extended attribute names and values (if any) for a file or directory</span></span><br><span class="line">hadoop fs -getfattr [-R] -n name | -d [-e en] &lt;path&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Takes a source directory and a destination file as input and concatenates files in src into the destination local file</span></span><br><span class="line">hadoop fs -getmerge [-nl] &lt;src&gt; &lt;localdst&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Displays first kilobyte of the file to stdout.</span></span><br><span class="line">hadoop fs -head URI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Return usage output.</span></span><br><span class="line">hadoop fs -<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hadoop fs -ls [-C] [-d] [-h] [-q] [-R] [-t] [-S] [-r] [-u] [-e] &lt;args&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive version of ls</span></span><br><span class="line">hadoop fs -lsr &lt;args&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Takes path uri’s as argument and creates directories.</span></span><br><span class="line">hadoop fs -mkdir [-p] &lt;paths&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Similar to put command, except that the source localsrc is deleted after it’s copied.</span></span><br><span class="line">hadoop fs -moveFromLocal &lt;localsrc&gt; &lt;dst&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Displays a “Not implemented yet” message.</span></span><br><span class="line">hadoop fs -moveToLocal [-crc] &lt;src&gt; &lt;dst&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Moves files from source to destination. This command allows multiple sources as well in which case the destination needs to be a directory. Moving files across file systems is not permitted.</span></span><br><span class="line">hadoop fs -mv URI [URI ...] &lt;dest&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy single src, or multiple srcs from local file system to the destination file system. Also reads input from stdin and writes to destination file system if the source is set to “-”</span></span><br><span class="line">hadoop fs -put [-f] [-p] [-l] [-d] [ - | &lt;localsrc1&gt; .. ]. &lt;dst&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete files specified as args</span></span><br><span class="line">hadoop fs -rm [-f] [-r |-R] [-skipTrash] [-safely] URI [URI ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete a directory</span></span><br><span class="line">hadoop fs -rmdir [--ignore-fail-on-non-empty] URI [URI ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive version of delete</span></span><br><span class="line">hadoop fs -rmr [-skipTrash] URI [URI ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets Access Control Lists (ACLs) of files and directories</span></span><br><span class="line">hadoop fs -setfacl [-R] [-b |-k -m |-x &lt;acl_spec&gt; &lt;path&gt;] |[--<span class="built_in">set</span> &lt;acl_spec&gt; &lt;path&gt;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets an extended attribute name and value for a file or directory</span></span><br><span class="line">hadoop fs -setfattr -n name [-v value] | -x name &lt;path&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Changes the replication factor of a file. If path is a directory then the command recursively changes the replication factor of all files under the directory tree rooted at path. The EC files will be ignored when executing this command</span></span><br><span class="line">hadoop fs -setrep [-R] [-w] &lt;numReplicas&gt; &lt;path&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Print statistics about the file/directory at &lt;path&gt; in the specified format</span></span><br><span class="line">hadoop fs -<span class="built_in">stat</span> [format] &lt;path&gt; ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Displays last kilobyte of the file to stdout</span></span><br><span class="line">hadoop fs -tail [-f] URI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hadoop fs -<span class="built_in">test</span> -[defsz] URI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Takes a source file and outputs the file in text format. The allowed formats are zip and TextRecordInputStream.</span></span><br><span class="line">hadoop fs -text &lt;src&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Updates the access and modification times of the file specified by the URI to the current time.</span></span><br><span class="line">hadoop fs -touch [-a] [-m] [-t TIMESTAMP] [-c] URI [URI ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a file of zero length. An error is returned if the file exists with non-zero length</span></span><br><span class="line">hadoop fs -touchz URI [URI ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Truncate all files that match the specified file pattern to the specified length.</span></span><br><span class="line">hadoop fs -truncate [-w] &lt;length&gt; &lt;paths&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Return the help for an individual command</span></span><br><span class="line">hadoop fs -usage <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="使用对象存储"><a href="#使用对象存储" class="headerlink" title="使用对象存储"></a>使用对象存储</h3><p>Working with Object Storage</p><p>The Hadoop FileSystem shell works with Object Stores such as Amazon S3, Azure WASB and OpenStack Swift.</p><p><br><br><br><br><br></p><h2 id="兼容性规范"><a href="#兼容性规范" class="headerlink" title="兼容性规范"></a>兼容性规范</h2><p><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-common/Compatibility.html" target="_blank" rel="noopener">Apache Hadoop Compatibility Specification</a></p><p><br></p><h3 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h3><p>本节介绍Apache Hadoop项目的兼容性目标。所有Hadoop Interface都根据目标受众和稳定性进行分类，以保持与先前版本的兼容性。</p><p>本文档供Hadoop开发人员社区使用。</p><p><br><br><br><br><br></p><h2 id="开发者兼容指南"><a href="#开发者兼容指南" class="headerlink" title="开发者兼容指南"></a>开发者兼容指南</h2><p><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-common/DownstreamDev.html" target="_blank" rel="noopener">Apache Hadoop Downstream Developer’s Guide</a></p><p><br></p><h3 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h3><p>本文档的目的是为下游开发人员提供明确的参考，以便在针对Hadoop源代码库构建应用程序时提供什么。本文档主要是Hadoop兼容性指南的精华，因此重点介绍了跨版本的各种Hadoop接口的兼容性保证。</p><p><br><br><br><br><br></p><h2 id="管理兼容指南"><a href="#管理兼容指南" class="headerlink" title="管理兼容指南"></a>管理兼容指南</h2><p><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-common/AdminCompatibilityGuide.html" target="_blank" rel="noopener">Apache Hadoop Admin Compatibility Guide</a></p><p><br></p><h3 id="目的-3"><a href="#目的-3" class="headerlink" title="目的"></a>目的</h3><p>本文档的目的是将Hadoop兼容性指南提炼为与系统管理员相关的信息。</p><p>目标受众是负责维护Apache Hadoop集群以及必须规划和执行集群升级的管理员。</p><p><br><br><br></p><h3 id="发行版"><a href="#发行版" class="headerlink" title="发行版"></a>发行版</h3><p>Hadoop Releases</p><p>Hadoop开发社区定期发布新的Hadoop Release，以引入新功能并修复现有问题。发新版分为三类:</p><ul><li><strong>Major</strong>: 主要版本通常包含重要的新功能，通常代表最大的升级兼容性风险。(如 2.8.2 to 3.0.0)</li><li><strong>Minor</strong>: 次要版本通常会包含一些新功能以及针对某些值得注意的问题的修复程序。在大多数情况下，次要版本不应造成太大的升级风险。(如2.8.2 to 2.9.0)</li><li><strong>Maintenance</strong>: 维护版本不应包含任何新功能。维护版本的目的是解决开发人员社区认为足够重要的一组问题，以便推动新版本解决这些问题。维护版本的升级风险很小。(如2.8.2 to 2.8.3)</li></ul><p><br><br><br></p><h3 id="平台依赖"><a href="#平台依赖" class="headerlink" title="平台依赖"></a>平台依赖</h3><p>Platform Dependencies</p><p>Hadoop所依赖的本机组件集被视为Hadoop ABI的一部分。Hadoop开发社区致力于尽可能地保持ABI兼容性。在次要版本之间，除非必要，否则不会增加Hadoop本机依赖项的最低支持版本号，例如安全性或许可问题。</p><p>Hadoop依赖于JVM(Java Virtual Machine)。支持的最低版本的JVM在主要版本的Hadoop之间不会发生变化。</p><p><br><br><br></p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>Network</p><p>Hadoop依赖于某些传输层技术，如SSL。除非必要，否则不会增加这些依赖项的最低支持版本，例如安全性或许可问题。</p><p>Hadoop服务端口号将在主要版本中保持不变，但可能会在次要版本中更改。</p><p>Hadoop内部线程协议(wire protocol)将在同一主要版本中的次要版本进行向后和向前兼容，以实现滚动升级。</p><p><br><br><br></p><h3 id="脚本和自动化"><a href="#脚本和自动化" class="headerlink" title="脚本和自动化"></a>脚本和自动化</h3><p>Scripting and Automation</p><p><br></p><h4 id="REST-APIs"><a href="#REST-APIs" class="headerlink" title="REST APIs"></a>REST APIs</h4><p>Hadoop REST APTs提供了一种简单的机制，用于收集有关Hadoop系统状态的信息。为了支持REST客户端，Hadoop REST API是版本化的，并且在版本中不会发生不兼容的更改。<br>REST API版本是单个数字，与Hadoop版本号无关。</p><p><br><br><br></p><h4 id="解析Hadoop输出"><a href="#解析Hadoop输出" class="headerlink" title="解析Hadoop输出"></a>解析Hadoop输出</h4><p>Parsing Hadoop Output</p><p>Hadoop可以生成各种输出，可通过自动化工具进行解析。在使用Hadoop输出时，请考虑一下事项:</p><ul><li>除非解决了正确性问题，否则Hadoop日志输出不会随维护版本而更改</li><li>Hadoop为各种操作生成审计日志(audit log)。审计日志旨在是机器可读，但新纪录和字段的添加被认为是兼容的更改</li><li>Hadoop生成的度量数量(metrics data)主要用于自动化处理。</li></ul><p><br><br><br></p><h4 id="CLIs"><a href="#CLIs" class="headerlink" title="CLIs"></a>CLIs</h4><p>Hadoop的命令行集提供了管理系统各个方面以及发现系统状态信息的能力。请注意，CLI工具输出与CLI工具生成的日志输出不同。日志输出不适合自动消费，可能随时更改。</p><p><br><br><br></p><h4 id="Web-UI"><a href="#Web-UI" class="headerlink" title="Web UI"></a>Web UI</h4><p>Hadoop公开的Web UI供人类使用。</p><p><br><br><br></p><h3 id="状态数据"><a href="#状态数据" class="headerlink" title="状态数据"></a>状态数据</h3><p>Hadoop State Data</p><p>Hadoop内部系统状态是私有的，不应直接被修改。以下策略管理各种内部状态存储的升级特征:</p><ul><li>内部MapReduce状态数据在同一主要版本中的次要版本之间保持兼容，以便在MapReduce工作负载执行时促进滚动升级</li><li>HDFS以版本化的私有内部格式维护存储在HDFS中的数据的元数据。</li><li>AWS S3防护保留了版本化的私有内部元数据存储。不兼容的更改将导致版本号递增。</li><li>YARN 资源管理器保留版本化的应用程序和调度程序信息的内部状态存储。</li><li>YARN联合身份验证服务保留应用程序的私有内部状态存储以及版本化的群集信息。</li></ul><p><br><br><br></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Hadoop Configurations</p><p>Hadoop使用两种主要形式的配置文件: XML配置文件和日志记录配置文件。</p><p><br></p><p><strong>XML配置文件</strong></p><p>XML配置文件包含了一组属性作为键值对。属性的名称和含义由Hadoop定义，并保证在次要版本中稳定。属性只能在主要版本中删除，并且只有在至少完整主要版本被标记为已弃用时才能删除。大多数属性都有一个默认值，如果未在XML配置文件中显式设置该属性，则将使用该值。</p><p>下游项目和用户可以将自己的属性添加到XML配置文件中，以供其工具和应用程序使用。虽然Hadoop对定义新属性没有任何正式限制，但与Hadoop定义的属性冲突的新属性可能会导致意外和不良结果。建议用户避免使用与Hadoop定义的属性的名称空间冲突的自定义配置属性名称。</p><p><br></p><p><strong>日志记录配置文件</strong></p><p>Hadoop Daemon和CLI生成的日志输出由一组配置文件控制。这些文件控制将由Hadoop的各个组件输出的最小日志消息级别，以及这些消息的存储位置和方式。</p><p><br></p><p><strong>其它配置文件</strong></p><p>Hadoop使用各种格式的许多其它类型的配置文件，如JSON或XML。</p><p><br><br><br></p><h3 id="发行版-1"><a href="#发行版-1" class="headerlink" title="发行版"></a>发行版</h3><p>Hadoop Distribution</p><p><br></p><p><strong>配置文件</strong></p><p>Hadoop配置文件的位置和一般结构，作业历史信息和Hadoop生成的日志文件将在维护版中得到维护。</p><p><br></p><p><strong>JARs</strong></p><p>Hadoop发行版的内容，如JAR文件可能随时更改，Client artifact除外，不应视为可靠。当前客户端工具有:</p><ul><li>hadoop-client</li><li>hadoop-client-api</li><li>hadoop-client-minicluster</li><li>hadoop-client-runtime</li><li>hadoop-hdfs-client</li><li>hadoop-hdfs-native-client</li><li>hadoop-mapreduce-client-app</li><li>hadoop-mapreduce-client-common</li><li>hadoop-mapreduce-client-core</li><li>hadoop-mapreduce-client-jobclient</li><li>hadoop-mapreduce-client-nativetask</li><li>hadoop-yarn-client</li></ul><p><br></p><p><strong>ENV</strong></p><p>一些Hadoop组件通过环境变量接收信息。</p><p><br></p><p><strong>库依赖</strong></p><p>Hadoop依赖于大量第三方库来运行。</p><p><br></p><p><strong>硬件和系统依赖</strong></p><p>Hadoop目前由运行在x86和AMD处理器上的Linux和Windows上的Hadoop开发人员社区提供支持。<br>无法保证Hadoop守护程序所需的最低资源如何在发行版之间发生变化，甚至是维护版本。<br>任何支持Hadoop的文件系统，例如通过FileSystem API，在大多数情况下将继续在主要版本中得到支持。</p><p><br><br><br><br><br></p><h2 id="接口分类"><a href="#接口分类" class="headerlink" title="接口分类"></a>接口分类</h2><p><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-common/InterfaceClassification.html" target="_blank" rel="noopener">Interface Classification</a></p><p><br><br><br><br><br></p><h2 id="文件系统规范"><a href="#文件系统规范" class="headerlink" title="文件系统规范"></a>文件系统规范</h2><p><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-common/filesystem/index.html" target="_blank" rel="noopener">The Hadoop FileSystem API Definition</a></p><p>这是Hadoop FS API的规范，它将文件系统的内容建模为一组路径(目录、文件、符号链接)。<br>Unix文件系统有多种规范作为inode树，但没有任何公开定义 <em>Unix文件系统作为数据存储访问的概念模型</em> 的概念。</p><p>该规范视图这样做，定义Hadoop FS模型和API，以便多个文件系统可实现API并向应用程序提供其数据的一致模型。除了记录HDFS所展示的行为之外，它不会尝试正式指定文件系统的任何并发行为，因为这些行为是Hadoop客户端应用程序通常所期望的。</p><p><br></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><br><br><br></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Notation</p><p><br><br><br></p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>Model</p><p><br><br><br></p><h3 id="文件系统类"><a href="#文件系统类" class="headerlink" title="文件系统类"></a>文件系统类</h3><p>FileSystem class</p><p><br><br><br></p><h3 id="FSDataInputStream-class"><a href="#FSDataInputStream-class" class="headerlink" title="FSDataInputStream class"></a>FSDataInputStream class</h3><p><br><br><br></p><h3 id="FSDataOutputStreamBuilder-class"><a href="#FSDataOutputStreamBuilder-class" class="headerlink" title="FSDataOutputStreamBuilder class"></a>FSDataOutputStreamBuilder class</h3><p><br><br><br></p><h3 id="使用文件系统规范进行测试"><a href="#使用文件系统规范进行测试" class="headerlink" title="使用文件系统规范进行测试"></a>使用文件系统规范进行测试</h3><p>Testing with the Filesystem specification</p><p><br><br><br></p><h3 id="扩展规范及测试"><a href="#扩展规范及测试" class="headerlink" title="扩展规范及测试"></a>扩展规范及测试</h3><p>Extending the specification and its tests</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Common"><a href="#Common" class="headerlink" title="Common"></a>Common</h1><p><br></p><h2 id="CLI-MiniCluster"><a href="#CLI-MiniCluster" class="headerlink" title="CLI MiniCluster"></a>CLI MiniCluster</h2><p><br></p><h3 id="目的-4"><a href="#目的-4" class="headerlink" title="目的"></a>目的</h3><p>使用 CLI MiniCluster，用户只需使用一个命令即可启动和停止单节点Hadoop集群，而无需设置任何环境变量或管理配置文件。CLI MiniCluster启用 YARN、MapReduce和HDFS集群。</p><p>这对于希望快速试验Hadoop集群或测试依赖于Hadoop工具的程序的用户来说非常有用。</p><p><br><br><br></p><h3 id="Hadoop-Tarball"><a href="#Hadoop-Tarball" class="headerlink" title="Hadoop Tarball"></a>Hadoop Tarball</h3><p>你要从发行版中获取Hadoop Tarball。此外，你也可以从源直接创建Tarball:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请首先下载源码包并解压</span></span><br><span class="line"><span class="comment"># tarball在hadoop-dist/target/目录</span></span><br><span class="line"><span class="comment"># cd hadoop-3.2.0-src</span></span><br><span class="line">mvn clean install -DskipTests</span><br><span class="line">mvn package -Pdist -Dtar -DskipTests -Dmaven.javadoc.skip</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="运行MiniCluster"><a href="#运行MiniCluster" class="headerlink" title="运行MiniCluster"></a>运行MiniCluster</h3><p>从提取的Tarball目录内部，你可使用以下命令启动CLI MiniCluster:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RM_PORT, JHS_PORT应替换为用户对这些端口号的选择，如果未指定，将使用随机空闲端口</span></span><br><span class="line">bin/mapred minicluster -rmport RM_PORT -jhsport JHS_PORT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行参数</span></span><br><span class="line">$ -D &lt;property=value&gt;    Options to pass into configuration object</span><br><span class="line">$ -datanodes &lt;arg&gt;       How many datanodes to start (default 1)</span><br><span class="line">$ -format                Format the DFS (default <span class="literal">false</span>)</span><br><span class="line">$ -<span class="built_in">help</span>                  Prints option <span class="built_in">help</span>.</span><br><span class="line">$ -jhsport &lt;arg&gt;         JobHistoryServer port (default 0--we choose)</span><br><span class="line">$ -namenode &lt;arg&gt;        URL of the namenode (default is either the DFS</span><br><span class="line">$                        cluster or a temporary dir)</span><br><span class="line">$ -nnport &lt;arg&gt;          NameNode port (default 0--we choose)</span><br><span class="line">$ -nnhttpport &lt;arg&gt;      NameNode HTTP port (default 0--we choose)</span><br><span class="line">$ -nodemanagers &lt;arg&gt;    How many nodemanagers to start (default 1)</span><br><span class="line">$ -nodfs                 Don<span class="string">'t start a mini DFS cluster</span></span><br><span class="line"><span class="string">$ -nomr                  Don'</span>t start a mini MR cluster</span><br><span class="line">$ -rmport &lt;arg&gt;          ResourceManager port (default 0--we choose)</span><br><span class="line">$ -writeConfig &lt;path&gt;    Save configuration to this XML file.</span><br><span class="line">$ -writeDetails &lt;path&gt;   Write basic information to this JSON file.</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="原生库"><a href="#原生库" class="headerlink" title="原生库"></a>原生库</h2><p>Native Libraries Guide</p><p>本节介绍原生(native)Hadoop库，并包含了有关共享库的讨论。</p><p>出于性能原因和Java实现的不可用性，Hadoop具有某些组件的原生实现。这些组件在单个动态链接的本机库可用，称为本机(原生)Hadoop库(<code>libhadoop.so</code>)。</p><p><br></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用原生Hadoop库相当容易:</p><ul><li>审阅组件</li><li>审阅支持的平台</li><li>下载Hadoop发行版(库名: <code>libhadoop.so</code>)</li><li>安装解码器开发包(<code>&gt;zlib-1.2</code>, <code>&gt;gzip-1.2</code>)</li><li>检查运行日志</li></ul><p><br><br><br></p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>原生Hadoop库包括各种组件:</p><ul><li>Compression Codecs (<code>bzip2</code>, <code>lz4</code>, <code>snappy</code>, <code>zlib</code>)</li><li>Native IO utilities for HDFS Short-Circuit Local Reads and Centralized Cache Management in HDFS</li><li>CRC32 checksum implementation</li></ul><p><br><br><br></p><h3 id="支持的平台"><a href="#支持的平台" class="headerlink" title="支持的平台"></a>支持的平台</h3><p>原生Hadoop库主要用于GNU/Linux平台，并在这些发行版上进行测试:</p><ul><li>RHEL4/Fedora</li><li>Ubuntu</li><li>Gentoo</li></ul><p><br><br><br></p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>原生Hadoop库使用 ANSI C编写，使用GNU autotools-chain 构建。<br>你需要在目标平台上安装的软件包:</p><ul><li>C compiler (e.g. GNU C Compiler)</li><li>GNU Autools Chain: autoconf, automake, libtool</li><li>zlib-development package (stable version &gt;= 1.2.0)</li><li>openssl-development package(e.g. libssl-dev)</li></ul><p>安装必备软件包后，使用标准的Hadoop <code>Pox.xml</code> 文件来构建原生Hadoop库:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn package -Pdist,native -DskipTests -Dtar</span><br><span class="line"></span><br><span class="line"><span class="comment"># You should see the newly-built library in</span></span><br><span class="line">hadoop-dist/target/hadoop-3.2.0/lib/native</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p><code>bin/hadoop</code> 脚本通过系统属性(<code>-Djava.library.path=&lt;path&gt;</code>)确保原生Hadoop库位于库路径上。</p><p>在运行时，检查hadoop日志文件以查找MapReduce任务。</p><p><br><br><br></p><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 原生库检查其检查是否正确加载</span><br><span class="line">hadoop checknative -a</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="Proxy-User"><a href="#Proxy-User" class="headerlink" title="Proxy User"></a>Proxy User</h2><p><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-common/Superusers.html" target="_blank" rel="noopener">Proxy user - Superusers Acting On Behalf Of Other Users</a></p><p>本节介绍超级用户(super user)如何代表另一个用户提交作业(submit job)或访问HDFS。</p><p><br></p><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>用户名为<code>super</code>的超级用户希望代表用户<code>userA</code>提交作业并访问HDFS。某人任务需要以<code>userA</code>身份运行，并且namenode上的任何文件都需要以<code>userA</code>的身份完成。这要求用户<code>userA</code>可连接到使用<code>super</code>用户的kerberos凭据连接到namenode。换句话说，<code>super</code>模仿用户<code>userA</code>。</p><p><br><br><br></p><h3 id="代码栗子"><a href="#代码栗子" class="headerlink" title="代码栗子"></a>代码栗子</h3><p><code>super</code>超级用户的凭据用于登录，并为<code>joe</code>创建代理用户对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">//Create ugi for joe. The login user is &apos;super&apos;.</span><br><span class="line">UserGroupInformation ugi =</span><br><span class="line">        UserGroupInformation.createProxyUser(&quot;joe&quot;, UserGroupInformation.getLoginUser());</span><br><span class="line">ugi.doAs(new PrivilegedExceptionAction&lt;Void&gt;() &#123;</span><br><span class="line">  public Void run() throws Exception &#123;</span><br><span class="line">    //Submit a job</span><br><span class="line">    JobClient jc = new JobClient(conf);</span><br><span class="line">    jc.submitJob(conf);</span><br><span class="line">    //OR access hdfs</span><br><span class="line">    FileSystem fs = FileSystem.get(conf);</span><br><span class="line">    fs.mkdir(someFilePath);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>你可以使用<code>hadoop.proxyuser</code>属性(properties)来配置代理用户。<code>$superuser.hosts</code>以及<code>hadoop.proxyuser.$superuser.groups</code>, <code>hadoop.proxyuser.$superuser.users</code>其中的一个或两个。</p><p>在<code>core-site.xml</code>中，名为<code>super</code>的超级用户只能充<code>host1, host2</code>上进行连接，用于模拟<code>group1</code>, <code>group2</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hadoop.proxyuser.super.hosts&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;host1,host2&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hadoop.proxyuser.super.groups&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;group1,group2&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><br></p><p>如果需要更为宽松的安全性，则可以使用通配符:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hadoop.proxyuser.oozie.hosts&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;*&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hadoop.proxyuser.oozie.groups&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;*&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><br></p><p>当然，它也接受CIDR格式的ip地址范围或主机名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hadoop.proxyuser.super.hosts&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;10.222.0.0/16,10.113.221.221&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hadoop.proxyuser.super.users&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;user1,user2&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h3><p>如果集群运行在安全模式(secure mode)下，则超级用户必须具有<code>kerberos</code>凭据才能模拟其他用户。</p><p><br><br><br><br><br></p><h2 id="Rack-Awareness-1"><a href="#Rack-Awareness-1" class="headerlink" title="Rack Awareness"></a>Rack Awareness</h2><p><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-common/RackAwareness.html" target="_blank" rel="noopener">Rack Awareness</a></p><p>Hadoop组件具有机架感知功能(rack-aware)。例如，通过将一个块副本(block replica)放在不同的机架上，HDFS块放置将使用机架感知来实现容错(fault tolerance)。可以在网络故障或分区时提供数据可用性。</p><p>Hadoop主守护进程(master daemon)通过调用配置文件指定的<code>external scripts</code>或<code>java class</code>来获取集群工作者的<strong>rack id</strong>。输出必须遵守 java org.apache.hadoop.net.DNSToSwitchMapping interface，接口需要保持一对一的对应关系。</p><p>要使用 java class 进行拓扑映射，类名由配置文件中的 <code>net.topology.node.switch.mapping.impl</code> 参数指定。<br>如果想实现外部脚本，将使用配置文件中的 <code>net.topology.script.file.name</code> 参数指定它。<br>如果 <code>net.topology.script.file.name</code> 或 <code>net.topology.node.switch.mapping.impl</code> 没有设置，则会为任何IP返回机器ID。</p><p><br></p><h3 id="python栗子"><a href="#python栗子" class="headerlink" title="python栗子"></a>python栗子</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># this script makes assumptions about the physical environment.</span></span><br><span class="line"><span class="comment">#  1) each rack is its own layer 3 network with a /24 subnet, which</span></span><br><span class="line"><span class="comment"># could be typical where each rack has its own</span></span><br><span class="line"><span class="comment">#     switch with uplinks to a central core router.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#             +-----------+</span></span><br><span class="line"><span class="comment">#             |core router|</span></span><br><span class="line"><span class="comment">#             +-----------+</span></span><br><span class="line"><span class="comment">#            /             \</span></span><br><span class="line"><span class="comment">#   +-----------+        +-----------+</span></span><br><span class="line"><span class="comment">#   |rack switch|        |rack switch|</span></span><br><span class="line"><span class="comment">#   +-----------+        +-----------+</span></span><br><span class="line"><span class="comment">#   | data node |        | data node |</span></span><br><span class="line"><span class="comment">#   +-----------+        +-----------+</span></span><br><span class="line"><span class="comment">#   | data node |        | data node |</span></span><br><span class="line"><span class="comment">#   +-----------+        +-----------+</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2) topology script gets list of IP's as input, calculates network address, and prints '/network_address/ip'.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> netaddr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.argv.pop(<span class="number">0</span>)                                                  <span class="comment"># discard name of topology script from argv list as we just want IP addresses</span></span><br><span class="line"></span><br><span class="line">netmask = <span class="string">'255.255.255.0'</span>                                        <span class="comment"># set netmask to what's being used in your environment.  The example uses a /24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> sys.argv:                                              <span class="comment"># loop over list of datanode IP's</span></span><br><span class="line">    address = <span class="string">'&#123;0&#125;/&#123;1&#125;'</span>.format(ip, netmask)                      <span class="comment"># format address string so it looks like 'ip/netmask' to make netaddr work</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        network_address = netaddr.IPNetwork(address).network     <span class="comment"># calculate and print network address</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"/&#123;0&#125;"</span>.format(network_address)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"/rack-unknown"</span>                                    <span class="comment"># print catch-all value if unable to calculate network address</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="bash栗子"><a href="#bash栗子" class="headerlink" title="bash栗子"></a>bash栗子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment"># Here's a bash example to show just how simple these scripts can be</span></span><br><span class="line"><span class="comment"># Assuming we have flat network with everything on a single switch, we can fake a rack topology.</span></span><br><span class="line"><span class="comment"># This could occur in a lab environment where we have limited nodes,like 2-8 physical machines on a unmanaged switch.</span></span><br><span class="line"><span class="comment"># This may also apply to multiple virtual machines running on the same physical hardware.</span></span><br><span class="line"><span class="comment"># The number of machines isn't important, but that we are trying to fake a network topology when there isn't one.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       +----------+    +--------+</span></span><br><span class="line"><span class="comment">#       |jobtracker|    |datanode|</span></span><br><span class="line"><span class="comment">#       +----------+    +--------+</span></span><br><span class="line"><span class="comment">#              \        /</span></span><br><span class="line"><span class="comment">#  +--------+  +--------+  +--------+</span></span><br><span class="line"><span class="comment">#  |datanode|--| switch |--|datanode|</span></span><br><span class="line"><span class="comment">#  +--------+  +--------+  +--------+</span></span><br><span class="line"><span class="comment">#              /        \</span></span><br><span class="line"><span class="comment">#       +--------+    +--------+</span></span><br><span class="line"><span class="comment">#       |datanode|    |namenode|</span></span><br><span class="line"><span class="comment">#       +--------+    +--------+</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># With this network topology, we are treating each host as a rack.  This is being done by taking the last octet</span></span><br><span class="line"><span class="comment"># in the datanode's IP and prepending it with the word '/rack-'.  The advantage for doing this is so HDFS</span></span><br><span class="line"><span class="comment"># can create its 'off-rack' block copy.</span></span><br><span class="line"><span class="comment"># 1) 'echo $@' will echo all ARGV values to xargs.</span></span><br><span class="line"><span class="comment"># 2) 'xargs' will enforce that we print a single argv value per line</span></span><br><span class="line"><span class="comment"># 3) 'awk' will split fields on dots and append the last field to the string '/rack-'. If awk</span></span><br><span class="line"><span class="comment">#    fails to split on four dots, it will still print '/rack-' last field value</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span> | xargs -n 1 | awk -F <span class="string">'.'</span> <span class="string">'&#123;print "/rack-"$NF&#125;'</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h2><p><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-common/SecureMode.html" target="_blank" rel="noopener">Hadoop in Secure Mode</a></p><p>本节介绍如何在 <strong>安全模式(secure mode)</strong> 下为Hadoop配置身份认证。当Hadoop配置为以安全模式运行时，Hadoop的每个服务和每个用户都必须由Kerberos进行身份认证。<br>必须正确配置所有服务主机的正向(forward)和反向(reverse)查找，以允许服务互相进行身份验证。可使用DNS或<code>/etc/hosts</code>文件配置主机查找(lookup)。在尝试以安全模式配置Hadoop服务之前，建议先了解Kerberos和DNS的工作知识。</p><p><br><br><br></p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>Authentication</p><p><br></p><h4 id="End-User-Accounts"><a href="#End-User-Accounts" class="headerlink" title="End User Accounts"></a>End User Accounts</h4><p>启用服务级别身份验证之后，最终用户必须在与Hadoop服务交互之前进行身份认证。最简单的方式是用户使用<code>kerberos kinit cmd</code>以交互方式进行身份认证，或者使用<code>Kerberos keytab</code>文件的编程身份进行认证。</p><p><br><br><br></p><h4 id="用户账户"><a href="#用户账户" class="headerlink" title="用户账户"></a>用户账户</h4><p>User Accounts for Hadoop Daemons</p><p>确保HDFS和YARN 守护进程以不同的Unix用户运行(如hdfs, yarn)。此外，确保 MapDrduce JobHistory Server以不同的用户运行(如mapred)。<br>建议让他们共享同一个Unix Group。</p><div class="table-container"><table><thead><tr><th>User:Group</th><th>Daemons</th></tr></thead><tbody><tr><td>hdfs:hadoop</td><td>NameNode, Secondary NameNode, JournalNode, DataNode</td></tr><tr><td>yarn:hadoop</td><td>ResourceManager, NodeManager</td></tr><tr><td>mapred:hadoop</td><td>MapReduce JobHistory Server</td></tr></tbody></table></div><p><br><br><br></p><h4 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h4><p>Kerberos principals for Hadoop Daemons</p><p>必须使用其<strong>Kerberos pricipal</strong>和<strong>keytab file</strong>配置每个Hadoop Service 实例。服务准则的一般格式是: <code>ServiceName/_HOST@REALM.TLD. e.g. dn/_HOST@EXAMPLE.COM</code>。</p><p>Hadoop通过允许将服务主体的主机名组件指定为<code>_HOST</code>通配符来简化配置文件的部署。每个服务实例将在运行时使用自己的完全限定主机名替换<code>_HOST</code>。这允许管理员在所有节点上部署同一组配置文件，但 keytab 文件有所不同。</p><p><br></p><p><strong>HDFS</strong></p><p>每个NameNode主机上的<strong>keytab</strong>文件，如下所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -e shows the encryption type</span></span><br><span class="line"><span class="comment"># -t shows keytab entry timestamps</span></span><br><span class="line"><span class="comment"># -k specifies keytab</span></span><br><span class="line">klist -e -k -t /etc/security/keytab/nn.service.keytab</span><br><span class="line">Keytab name: FILE:/etc/security/keytab/nn.service.keytab</span><br><span class="line">KVNO Timestamp         Principal</span><br><span class="line">   4 07/18/11 21:08:09 nn/full.qualified.domain.name@REALM.TLD (AES-256 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 nn/full.qualified.domain.name@REALM.TLD (AES-128 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 nn/full.qualified.domain.name@REALM.TLD (ArcFour with HMAC/md5)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (AES-256 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (AES-128 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (ArcFour with HMAC/md5)</span><br></pre></td></tr></table></figure><p>第二个NameNode主机的<strong>keytab</strong>文件，如下所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">klist -e -k -t /etc/security/keytab/sn.service.keytab</span><br><span class="line">Keytab name: FILE:/etc/security/keytab/sn.service.keytab</span><br><span class="line">KVNO Timestamp         Principal</span><br><span class="line">   4 07/18/11 21:08:09 sn/full.qualified.domain.name@REALM.TLD (AES-256 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 sn/full.qualified.domain.name@REALM.TLD (AES-128 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 sn/full.qualified.domain.name@REALM.TLD (ArcFour with HMAC/md5)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (AES-256 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (AES-128 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (ArcFour with HMAC/md5)</span><br></pre></td></tr></table></figure><p>每台主机上的DataNode的<strong>keytab</strong>文件，如下所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">klist -e -k -t /etc/security/keytab/dn.service.keytab</span><br><span class="line">Keytab name: FILE:/etc/security/keytab/dn.service.keytab</span><br><span class="line">KVNO Timestamp         Principal</span><br><span class="line">   4 07/18/11 21:08:09 dn/full.qualified.domain.name@REALM.TLD (AES-256 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 dn/full.qualified.domain.name@REALM.TLD (AES-128 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 dn/full.qualified.domain.name@REALM.TLD (ArcFour with HMAC/md5)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (AES-256 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (AES-128 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (ArcFour with HMAC/md5)</span><br></pre></td></tr></table></figure><p><br></p><p><strong>YARN</strong></p><p>位于ResourceManager主机上的ResourceManager的<strong>keytab</strong>文件，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">klist -e -k -t /etc/security/keytab/rm.service.keytab</span><br><span class="line">Keytab name: FILE:/etc/security/keytab/rm.service.keytab</span><br><span class="line">KVNO Timestamp         Principal</span><br><span class="line">   4 07/18/11 21:08:09 rm/full.qualified.domain.name@REALM.TLD (AES-256 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 rm/full.qualified.domain.name@REALM.TLD (AES-128 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 rm/full.qualified.domain.name@REALM.TLD (ArcFour with HMAC/md5)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (AES-256 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (AES-128 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (ArcFour with HMAC/md5)</span><br></pre></td></tr></table></figure><p>每台主机上的NodeManager的<strong>keytab</strong>文件，如下所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">klist -e -k -t /etc/security/keytab/nm.service.keytab</span><br><span class="line">Keytab name: FILE:/etc/security/keytab/nm.service.keytab</span><br><span class="line">KVNO Timestamp         Principal</span><br><span class="line">   4 07/18/11 21:08:09 nm/full.qualified.domain.name@REALM.TLD (AES-256 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 nm/full.qualified.domain.name@REALM.TLD (AES-128 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 nm/full.qualified.domain.name@REALM.TLD (ArcFour with HMAC/md5)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (AES-256 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (AES-128 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (ArcFour with HMAC/md5)</span><br></pre></td></tr></table></figure><p><br></p><p><strong>MapReduce JobHistory Server</strong></p><p>该主机上的MapReduce JobHistory Server的<strong>keytab</strong>文件，如下所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">klist -e -k -t /etc/security/keytab/jhs.service.keytab</span><br><span class="line">Keytab name: FILE:/etc/security/keytab/jhs.service.keytab</span><br><span class="line">KVNO Timestamp         Principal</span><br><span class="line">   4 07/18/11 21:08:09 jhs/full.qualified.domain.name@REALM.TLD (AES-256 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 jhs/full.qualified.domain.name@REALM.TLD (AES-128 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 jhs/full.qualified.domain.name@REALM.TLD (ArcFour with HMAC/md5)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (AES-256 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (AES-128 CTS mode with 96-bit SHA-1 HMAC)</span><br><span class="line">   4 07/18/11 21:08:09 host/full.qualified.domain.name@REALM.TLD (ArcFour with HMAC/md5)</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="从kerberos映射到系统用户账户"><a href="#从kerberos映射到系统用户账户" class="headerlink" title="从kerberos映射到系统用户账户"></a>从kerberos映射到系统用户账户</h4><p>Mapping from Kerberos principals to OS user accounts</p><p>Hadoop使用<code>hadoop.security.auth_to_local</code>指定的规则将kerberos principal映射到系统账户。Hadoop如何评估这些规则取决于<code>hadoop.security.auth_to_local.mechanism</code>的设置。</p><p>在默认的hadoop模式下，必须将Kerberos主体与将主体转换为简单形式的规则匹配，即不带<code>@, /</code>的用户帐户名，否则将不会授权主体并记录错误。<br>另外，请注意，您不应该将 <code>auth_to_local</code> 规则作为ACL并使用适当的(OS)机制。</p><p><code>auth_to_local</code>可能的值:</p><ul><li><code>RULE:exp</code>, 本地名称将由exp指定</li><li><code>DEFAULT</code>, 当且仅当域与 <code>default_realm</code> 匹配时，才将主体名称的第一个组件选为系统用户名</li></ul><p>请注意，Hadoop不支持多个默认域。此外，Hadoop不会对映射是否存在本地系统帐户进行验证。</p><p><br><br><br></p><h4 id="规则栗子"><a href="#规则栗子" class="headerlink" title="规则栗子"></a>规则栗子</h4><p>Example rules</p><p>在典型的集群中，HDFS和YARN服务将分别作为系统hdfs和yarn用户启动。<code>hadoop.security.auth_to_local</code>可做如下配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;hadoop.security.auth_to_local&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;</span><br><span class="line">    RULE:[2:$1/$2@$0]([ndj]n/.*@REALM.\TLD)s/.*/hdfs/</span><br><span class="line">    RULE:[2:$1/$2@$0]([rn]m/.*@REALM\.TLD)s/.*/yarn/</span><br><span class="line">    RULE:[2:$1/$2@$0](jhs/.*@REALM\.TLD)s/.*/mapred/</span><br><span class="line">    DEFAULT</span><br><span class="line">  &lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>可以使用 <code>hadoop kerbname</code> 命令测试自定义规则。此命令允许指定主体并应用Hadoop的当前 <code>auth_to_local</code> 规则集。</p><p><br><br><br></p><h4 id="用户到组的映射"><a href="#用户到组的映射" class="headerlink" title="用户到组的映射"></a>用户到组的映射</h4><p>Mapping from user to group</p><p>可以通过 <code>hadoop.security.group.mapping</code> 配置系统用户到系统组的映射机制。<br>实际上，您需要使用Kerberos和LDAP for Hadoop以安全模式管理SSO环境。</p><p><br><br><br></p><h4 id="代理用户"><a href="#代理用户" class="headerlink" title="代理用户"></a>代理用户</h4><p>Proxy user</p><p>Some products such as Apache Oozie which access the services of Hadoop on behalf of end users need to be able to impersonate end users.</p><p><br><br><br></p><h4 id="Secure-DataNode"><a href="#Secure-DataNode" class="headerlink" title="Secure DataNode"></a>Secure DataNode</h4><p>由于DataNode数据传输协议不使用Hadoop RPC框架，因此DataNode必须使用由<code>dfs.datanode.address</code>和<code>dfs.datanode.http.address</code>指定的特权端口对自身进行身份验证。此认证基于以下假设: 攻击者无法在DataNode主机上获得root权限。</p><p>当以root身份执行<code>hdfs datanode</code>命令时，服务进程首先绑定特定端口，然后删除特权并以<code>HDFS_DATANODE_SECURE_USER</code>指定的用户账户运行。此启动过程安装到<code>JSVC_HOME</code>的jsvc程序。你必须在启动时将<code>JDFS_DATANODE_SECURE_USER</code>和<code>JSVC_HOME</code>指定为环境变量。(<code>hadoop-env.sh</code>文件中可配置)</p><p><br><br><br><br><br></p><h3 id="数据机密性"><a href="#数据机密性" class="headerlink" title="数据机密性"></a>数据机密性</h3><p><br></p><h4 id="Data-Encryption-on-RPC"><a href="#Data-Encryption-on-RPC" class="headerlink" title="Data Encryption on RPC"></a>Data Encryption on RPC</h4><p>在Hadoop Service 和 Client之间传输的数据可以在线路上加密。在 <code>core-site.xml</code> 中将 <code>hadoop.rpc.protection</code> 设置为 <code>privacy</code> 可激活数据加密。</p><p><br><br><br></p><h4 id="Data-Encryption-on-Block-data-transfer"><a href="#Data-Encryption-on-Block-data-transfer" class="headerlink" title="Data Encryption on Block data transfer"></a>Data Encryption on Block data transfer</h4><p>需要在 <code>hdfs-site.xml</code> 中将 <code>dfs.encrypt.data.transfer</code> 设置为 <code>true</code>，以便为DataNode 的数据传输协议激活数据加密。</p><p>或者，你可将 <code>dfs.encrypt.data.transfer.algorithm</code> 设置为 <code>3des</code>, <code>rc4</code> 以选择特定的加密算法。如果未指定，则使用系统上配置的JCE默认值(3des)。<br>将 <code>dfs.encrypt.data.transfer.cipher.suites</code> 设置为 <code>AES/CTR/NoPadding</code> 可激活AES加密。默认未指定，也就是不使用AES。使用AES时，在初始密钥交换期间仍会使用 <code>dfs.encrypt.dta.transfer.algorithm</code>的算法。可通过将 <code>dfs.encrypt.data.transfer.cipher.key.bitlength</code> 设置为128, 192, 256来配置AES密钥位长度(默认128)</p><p>AES提供最大的加密强度和最佳性能。目前，3DES和RC4在Hadoop集群中的使用频率更高。</p><p><br><br><br></p><h4 id="Data-Encryption-on-HTTP"><a href="#Data-Encryption-on-HTTP" class="headerlink" title="Data Encryption on HTTP"></a>Data Encryption on HTTP</h4><p>web-console和client之间的数据传输使用SSL(HTTPS)保护。在使用Kerberos配置Hadoop安全时，推荐使用SLL，但不是必须。</p><p>要为HDFS Daemon的 web-console 启用SSL，将<code>hdfs-site.xml</code>文件中的<code>dfs.http.policy</code>设置为<code>HTTPS_ONLY</code>或<code>HTTP_AND_HTTPS</code>两者之一。<br>要为YARN Daemon的 web-console 启用SSL，将<code>yarn-site.xml</code>文件中的<code>yarn.http.policy</code>设置为<code>HTTPS_ONLY</code>。<br>要为MapReduce JobHistory Server的 web-console 启用SSL，将<code>mapred-site.xml</code>文件中的<code>mapreduce.jobhistory.http.policy</code>设置为<code>HTTPS_ONLY</code>。</p><p><br><br><br></p><h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p><br></p><h4 id="HDFS和本地文件系统路径的权限"><a href="#HDFS和本地文件系统路径的权限" class="headerlink" title="HDFS和本地文件系统路径的权限"></a>HDFS和本地文件系统路径的权限</h4><p>Permissions for both HDFS and local fileSystem paths</p><p>下表列出了HDFS和本地文件系统的各种路径，建议权限为:</p><div class="table-container"><table><thead><tr><th>Filesystem</th><th>Path</th><th>User:Group</th><th>Permissions</th></tr></thead><tbody><tr><td>local</td><td><code>dfs.namenode.name.dir</code></td><td>hdfs:hadoop</td><td>drwx———</td></tr><tr><td>local</td><td><code>dfs.datanode.data.dir</code></td><td>hdfs:hadoop</td><td>drwx———</td></tr><tr><td>local</td><td><code>$HADOOP_LOG_DIR</code></td><td>hdfs:hadoop</td><td>drwxrwxr-x</td></tr><tr><td>local</td><td><code>$YARN_LOG_DIR</code></td><td>yarn:hadoop</td><td>drwxrwxr-x</td></tr><tr><td>local</td><td><code>yarn.nodemanager.local-dirs</code></td><td>yarn:hadoop</td><td>drwxr-xr-x</td></tr><tr><td>local</td><td><code>yarn.nodemanager.log-dirs</code></td><td>yarn:hadoop</td><td>drwxr-xr-x</td></tr><tr><td>local</td><td><code>container-executor</code></td><td>root:hadoop</td><td>—Sr-s—*</td></tr><tr><td>local</td><td><code>conf/container-executor.cfg</code></td><td>root:hadoop</td><td>r———-*</td></tr><tr><td>hdfs</td><td><code>/</code></td><td>hdfs:hadoop</td><td>drwxr-xr-x</td></tr><tr><td>hdfs</td><td><code>/tmp</code></td><td>hdfs:hadoop</td><td>drwxrwxrwxt</td></tr><tr><td>hdfs</td><td><code>/user</code></td><td>hdfs:hadoop</td><td>drwxr-xr-x</td></tr><tr><td>hdfs</td><td><code>yarn.nodemanager.remote-app-log-dir</code></td><td>yarn:hadoop</td><td>drwxrwxrwxt</td></tr><tr><td>hdfs</td><td><code>mapreduce.jobhistory.intermediate-done-dir</code></td><td>mapred:hadoop</td><td>drwxrwxrwxt</td></tr><tr><td>hdfs</td><td><code>mapreduce.jobhistory.done-dir</code></td><td>mapred:hadoop</td><td>drwxr-x—-</td></tr></tbody></table></div><p><br><br><br></p><h4 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h4><p>要在Hadoop中启用RPC身份认证，请将<code>hadoop.security.authentication</code>属性设置为<code>kerberos</code>，并适当地设置下面列出的安全相关的配置。</p><p>以下属性应位于集群中所有节点的<code>core-site.xml</code>中:</p><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>hadoop.security.authentication</code></td><td><code>kerberos</code></td><td>simple : No authentication. (default)  kerberos : Enable authentication by Kerberos.</td></tr><tr><td><code>hadoop.security.authorization</code></td><td><code>true</code></td><td>Enable RPC service-level authorization.</td></tr><tr><td><code>hadoop.rpc.protection</code></td><td><code>authentication</code></td><td>authentication : authentication only (default); integrity : integrity check in addition to authentication; privacy : data encryption in addition to integrity</td></tr><tr><td><code>hadoop.security.auth_to_local</code></td><td><code>RULE:exp1 RULE:exp2 … DEFAULT</code></td><td>The value is string containing new line characters. See Kerberos documentation for the format of exp.</td></tr><tr><td><code>hadoop.proxyuser.superuser.hosts</code></td><td>-</td><td>comma separated hosts from which superuser access are allowed to impersonation. * means wildcard.</td></tr><tr><td><code>hadoop.proxyuser.superuser.groups</code></td><td>-</td><td>comma separated groups to which users impersonated by superuser belong. * means wildcard.</td></tr></tbody></table></div><p><br><br><br></p><h4 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h4><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>dfs.block.access.token.enable</code></td><td><code>true</code></td><td>Enable HDFS block access tokens for secure operations.</td></tr><tr><td><code>dfs.namenode.kerberos.principal</code></td><td><code>nn/_HOST@REALM.TLD</code></td><td>Kerberos principal name for the NameNode.</td></tr><tr><td><code>dfs.namenode.keytab.file</code></td><td><code>/etc/security/keytab/nn.service.keytab</code></td><td>Kerberos keytab file for the NameNode.</td></tr><tr><td><code>dfs.namenode.kerberos.internal.spnego.principal</code></td><td><code>HTTP/_HOST@REALM.TLD</code></td><td>The server principal used by the NameNode for web UI SPNEGO authentication. The SPNEGO server principal begins with the prefix HTTP/ by convention. If the value is ‘*’, the web server will attempt to login with every principal specified in the keytab file dfs.web.authentication.kerberos.keytab. For most deployments this can be set to ${dfs.web.authentication.kerberos.principal} i.e use the value of dfs.web.authentication.kerberos.principal.</td></tr><tr><td><code>dfs.web.authentication.kerberos.keytab</code></td><td><code>/etc/security/keytab/spnego.service.keytab</code></td><td>SPNEGO keytab file for the NameNode. In HA clusters this setting is shared with the Journal Nodes.</td></tr></tbody></table></div><p>以下设置允许配置对NameNode Web UI的SSL访问(可选):</p><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>dfs.http.policy</code></td><td><code>HTTP_ONLY</code> or <code>HTTPS_ONLY</code> or <code>HTTP_AND_HTTPS</code></td><td>HTTPS_ONLY turns off http access. This option takes precedence over the deprecated configuration dfs.https.enable and hadoop.ssl.enabled. If using SASL to authenticate data transfer protocol instead of running DataNode as root and using privileged ports, then this property must be set to HTTPS_ONLY to guarantee authentication of HTTP servers. (See dfs.data.transfer.protection.)</td></tr><tr><td><code>dfs.namenode.https-address</code></td><td><code>0.0.0.0:9871</code></td><td>This parameter is used in non-HA mode and without federation. See HDFS High Availability and HDFS Federation for details.</td></tr><tr><td><code>dfs.https.enable</code></td><td><code>true</code></td><td>This value is deprecated. Use dfs.http.policy</td></tr></tbody></table></div><p><br><br><br></p><h4 id="Secondary-NameNode"><a href="#Secondary-NameNode" class="headerlink" title="Secondary NameNode"></a>Secondary NameNode</h4><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>dfs.namenode.secondary.http-address</code></td><td><code>0.0.0.0:9868</code></td><td>HTTP web UI address for the Secondary NameNode.</td></tr><tr><td><code>dfs.namenode.secondary.https-address</code></td><td><code>0.0.0.0:9869</code></td><td>HTTPS web UI address for the Secondary NameNode.</td></tr><tr><td><code>dfs.secondary.namenode.keytab.file</code></td><td><code>/etc/security/keytab/sn.service.keytab</code></td><td>Kerberos keytab file for the Secondary NameNode.</td></tr><tr><td><code>dfs.secondary.namenode.kerberos.principal</code></td><td><code>sn/_HOST@REALM.TLD</code></td><td>Kerberos principal name for the Secondary NameNode.</td></tr><tr><td><code>dfs.secondary.namenode.kerberos.internal.spnego.principal</code></td><td><code>HTTP/_HOST@REALM.TLD</code></td><td>The server principal used by the Secondary NameNode for web UI SPNEGO authentication. The SPNEGO server principal begins with the prefix HTTP/ by convention. If the value is ‘*’, the web server will attempt to login with every principal specified in the keytab file dfs.web.authentication.kerberos.keytab. For most deployments this can be set to ${dfs.web.authentication.kerberos.principal} i.e use the value of dfs.web.authentication.kerberos.principal.</td></tr></tbody></table></div><p><br><br><br></p><h4 id="JournalNode"><a href="#JournalNode" class="headerlink" title="JournalNode"></a>JournalNode</h4><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>dfs.journalnode.kerberos.principal</code></td><td><code>jn/_HOST@REALM.TLD</code></td><td>Kerberos principal name for the JournalNode.</td></tr><tr><td><code>dfs.journalnode.keytab.file</code></td><td><code>/etc/security/keytab/jn.service.keytab</code></td><td>Kerberos keytab file for the JournalNode.</td></tr><tr><td><code>dfs.journalnode.kerberos.internal.spnego.principal</code></td><td><code>HTTP/_HOST@REALM.TLD</code></td><td>The server principal used by the JournalNode for web UI SPNEGO authentication when Kerberos security is enabled. The SPNEGO server principal begins with the prefix HTTP/ by convention. If the value is ‘*’, the web server will attempt to login with every principal specified in the keytab file dfs.web.authentication.kerberos.keytab. For most deployments this can be set to ${dfs.web.authentication.kerberos.principal} i.e use the value of dfs.web.authentication.kerberos.principal.</td></tr><tr><td><code>dfs.web.authentication.kerberos.keytab</code></td><td><code>/etc/security/keytab/spnego.service.keytab</code></td><td>SPNEGO keytab file for the JournalNode. In HA clusters this setting is shared with the Name Nodes.</td></tr><tr><td><code>dfs.journalnode.https-address</code></td><td><code>0.0.0.0:8481</code></td><td>HTTPS web UI address for the JournalNode.</td></tr></tbody></table></div><p><br><br><br></p><h4 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h4><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>dfs.datanode.data.dir.perm</code></td><td><code>700</code></td><td>-</td></tr><tr><td><code>dfs.datanode.address</code></td><td><code>0.0.0.0:1004</code></td><td>Secure DataNode must use privileged port in order to assure that the server was started securely. This means that the server must be started via jsvc. Alternatively, this must be set to a non-privileged port if using SASL to authenticate data transfer protocol. (See dfs.data.transfer.protection.)</td></tr><tr><td><code>dfs.datanode.http.address</code></td><td><code>0.0.0.0:1006</code></td><td>Secure DataNode must use privileged port in order to assure that the server was started securely. This means that the server must be started via jsvc.</td></tr><tr><td><code>dfs.datanode.https.address</code></td><td><code>0.0.0.0:9865</code></td><td>HTTPS web UI address for the Data Node.</td></tr><tr><td><code>dfs.datanode.kerberos.principal</code></td><td><code>dn/_HOST@REALM.TLD</code></td><td>Kerberos principal name for the DataNode.</td></tr><tr><td><code>dfs.datanode.keytab.file</code></td><td><code>/etc/security/keytab/dn.service.keytab</code></td><td>Kerberos keytab file for the DataNode.</td></tr><tr><td><code>dfs.encrypt.data.transfer</code></td><td><code>false</code></td><td>set to true when using data encryption</td></tr><tr><td><code>dfs.encrypt.data.transfer.algorithm</code></td><td>-</td><td>optionally set to 3des or rc4 when using data encryption to control encryption algorithm</td></tr><tr><td><code>dfs.encrypt.data.transfer.cipher.suites</code></td><td>-</td><td>optionally set to AES/CTR/NoPadding to activate AES encryption when using data encryption</td></tr><tr><td><code>dfs.encrypt.data.transfer.cipher.key.bitlength</code></td><td>-</td><td>optionally set to 128, 192 or 256 to control key bit length when using AES with data encryption</td></tr><tr><td><code>dfs.data.transfer.protection</code></td><td>-</td><td>authentication : authentication only; integrity : integrity check in addition to authentication; privacy : data encryption in addition to integrity This property is unspecified by default. Setting this property enables SASL for authentication of data transfer protocol. If this is enabled, then dfs.datanode.address must use a non-privileged port, dfs.http.policy must be set to HTTPS_ONLY and the HDFS_DATANODE_SECURE_USER environment variable must be undefined when starting the DataNode process.</td></tr></tbody></table></div><p><br><br><br></p><h4 id="WebHDFS"><a href="#WebHDFS" class="headerlink" title="WebHDFS"></a>WebHDFS</h4><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>dfs.web.authentication.kerberos.principal</code></td><td><code>http/_HOST@REALM.TLD</code></td><td>Kerberos principal name for the WebHDFS. In HA clusters this setting is commonly used by the JournalNodes for securing access to the JournalNode HTTP server with SPNEGO.</td></tr><tr><td><code>dfs.web.authentication.kerberos.keytab</code></td><td><code>/etc/security/keytab/http.service.keytab</code></td><td>Kerberos keytab file for WebHDFS. In HA clusters this setting is commonly used the JournalNodes for securing access to the JournalNode HTTP server with SPNEGO.</td></tr></tbody></table></div><p><br><br><br></p><h4 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h4><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>yarn.resourcemanager.principal</code></td><td><code>rm/_HOST@REALM.TLD</code></td><td>Kerberos principal name for the ResourceManager.</td></tr><tr><td><code>yarn.resourcemanager.keytab</code></td><td><code>/etc/security/keytab/rm.service.keytab</code></td><td>Kerberos keytab file for the ResourceManager.</td></tr><tr><td><code>yarn.resourcemanager.webapp.https.address</code></td><td><code>${yarn.resourcemanager.hostname}:8090</code></td><td>The https adddress of the RM web application for non-HA. In HA clusters, use yarn.resourcemanager.webapp.https.address.rm-id for each ResourceManager. See ResourceManager High Availability for details.</td></tr></tbody></table></div><p><br><br><br></p><h4 id="NodeManager"><a href="#NodeManager" class="headerlink" title="NodeManager"></a>NodeManager</h4><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>yarn.nodemanager.principal</code></td><td><code>nm/_HOST@REALM.TLD</code></td><td>Kerberos principal name for the NodeManager.</td></tr><tr><td><code>yarn.nodemanager.keytab</code></td><td><code>/etc/security/keytab/nm.service.keytab</code></td><td>Kerberos keytab file for the NodeManager.</td></tr><tr><td><code>yarn.nodemanager.container-executor.class</code></td><td><code>org.apache.hadoop.yarn.server.nodemanager.LinuxContainerExecutor</code></td><td>Use LinuxContainerExecutor.</td></tr><tr><td><code>yarn.nodemanager.linux-container-executor.group</code></td><td><code>hadoop</code></td><td>Unix group of the NodeManager.</td></tr><tr><td><code>yarn.nodemanager.linux-container-executor.path</code></td><td><code>/path/to/bin/container-executor</code></td><td>The path to the executable of Linux container executor.</td></tr><tr><td><code>yarn.nodemanager.webapp.https.address</code></td><td><code>0.0.0.0:8044</code></td><td>The https adddress of the NM web application.</td></tr></tbody></table></div><p><br><br><br></p><h4 id="Configuration-for-WebAppProxy"><a href="#Configuration-for-WebAppProxy" class="headerlink" title="Configuration for WebAppProxy"></a>Configuration for WebAppProxy</h4><p>WebAppProxy在应用程序和用户导出的Web应用程序之间提供代理。如果启用了安全性，它将在访问可能不安全的Web应用程序之前警告用户。使用代理的身份验证和授权与任何其他特权Web应用程序一样处理。</p><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>yarn.web-proxy.address</code></td><td>WebAppProxy host:port for proxy to AM web apps.</td><td>host:port if this is the same as yarn.resourcemanager.webapp.address or it is not defined then the ResourceManager will run the proxy otherwise a standalone proxy server will need to be launched.</td></tr><tr><td><code>yarn.web-proxy.keytab</code></td><td><code>/etc/security/keytab/web-app.service.keytab</code></td><td>Kerberos keytab file for the WebAppProxy.</td></tr><tr><td><code>yarn.web-proxy.principal</code></td><td><code>wap/_HOST@REALM.TLD</code></td><td>Kerberos principal name for the WebAppProxy.</td></tr></tbody></table></div><p><br><br><br></p><h4 id="LinuxContainerExecutor"><a href="#LinuxContainerExecutor" class="headerlink" title="LinuxContainerExecutor"></a>LinuxContainerExecutor</h4><p>YARN框架使用的ContainerExecutor，用于定义任何容器的启动和控制方式。</p><p>以下是Hadoop YARN中可用内容:</p><div class="table-container"><table><thead><tr><th>ContainerExecutor</th><th>Description</th></tr></thead><tbody><tr><td>DefaultContainerExecutor</td><td>The default executor which YARN uses to manage container execution. The container process has the same Unix user as the NodeManager.</td></tr><tr><td>LinuxContainerExecutor</td><td>Supported only on GNU/Linux, this executor runs the containers as either the YARN user who submitted the application (when full security is enabled) or as a dedicated user (defaults to nobody) when full security is not enabled. When full security is enabled, this executor requires all user accounts to be created on the cluster nodes where the containers are launched. It uses a setuid executable that is included in the Hadoop distribution. The NodeManager uses this executable to launch and kill containers. The setuid executable switches to the user who has submitted the application and launches or kills the containers. For maximum security, this executor sets up restricted permissions and user/group ownership of local files and directories used by the containers such as the shared objects, jars, intermediate files, log files etc. Particularly note that, because of this, except the application owner and NodeManager, no other user can access any of the local files/directories including those localized as part of the distributed cache.</td></tr></tbody></table></div><p><br></p><p>要构建LinuxContainerExecutor可执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群配置文件路径</span></span><br><span class="line">mvn package -Dcontainer-executor.conf.dir=/opt/hadoop/etc/hadoop/</span><br></pre></td></tr></table></figure><p>LinuxTaskController 要求包含和导向 <code>yarn.nodemanager.local-dirs</code> 和 <code>yarn.nodemanager.log-dirs</code> 中指定的目录的路径设置为755权限。</p><p><br></p><p>可执行文件需要一个名为<code>container-executor.cfg(conf/container-executor.cfg)</code>的配置文件，该文件存在于上述mvn的目标配置目录里。该配置文件必须有NodeNanager的用户所有，权限应为<code>0400</code>。<br>可执行文件要求此配置文件存在以下配置项(KV):</p><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td>yarn.nodemanager.linux-container-executor.group</td><td>hadoop</td><td>Unix group of the NodeManager. The group owner of the container-executor binary should be this group. Should be same as the value with which the NodeManager is configured. This configuration is required for validating the secure access of the container-executor binary.</td></tr><tr><td>banned.users</td><td>hdfs,yarn,mapred,bin</td><td>Banned users.</td></tr><tr><td>allowed.system.users</td><td>foo,bar</td><td>Allowed system users.</td></tr><tr><td>min.user.id</td><td>1000</td><td>Prevent other super-users.</td></tr></tbody></table></div><p><br></p><p>以下是与LinuxContainerExecutor相关的各种路径所需的本地文件系统权限：</p><div class="table-container"><table><thead><tr><th>Filesystem</th><th>Path</th><th>User:Group</th><th>Permissions</th></tr></thead><tbody><tr><td><code>local</code></td><td><code>container-executor</code></td><td>root:hadoop</td><td>—Sr-s—*</td></tr><tr><td><code>local</code></td><td><code>conf/container-executor.cfg</code></td><td>root:hadoop</td><td>r———-*</td></tr><tr><td><code>local</code></td><td><code>yarn.nodemanager.local-dirs</code></td><td>yarn:hadoop</td><td>drwxr-xr-x</td></tr><tr><td><code>local</code></td><td><code>yarn.nodemanager.log-dirs</code></td><td>yarn:hadoop</td><td>drwxr-xr-x</td></tr></tbody></table></div><p><br><br><br></p><h4 id="MapReduce-JobHistory-Server"><a href="#MapReduce-JobHistory-Server" class="headerlink" title="MapReduce JobHistory Server"></a>MapReduce JobHistory Server</h4><div class="table-container"><table><thead><tr><th>Parameter</th><th>Value</th><th>Notes</th></tr></thead><tbody><tr><td><code>mapreduce.jobhistory.address</code></td><td>MapReduce JobHistory Server <code>host:port</code></td><td>Default port is 10020.</td></tr><tr><td><code>mapreduce.jobhistory.keytab</code></td><td><code>/etc/security/keytab/jhs.service.keytab</code></td><td>Kerberos keytab file for the MapReduce JobHistory Server.</td></tr><tr><td><code>mapreduce.jobhistory.principal</code></td><td><code>jhs/_HOST@REALM.TLD</code></td><td>Kerberos principal name for the MapReduce JobHistory Server.</td></tr></tbody></table></div><p><br><br><br><br><br></p><h3 id="Multihoming"><a href="#Multihoming" class="headerlink" title="Multihoming"></a>Multihoming</h3><p>多宿主设置，其中每个主机在DNS中具有多个主机名(如，对应于公共和专用网络接口的不同主机名)。可能需要额外的配置才能使Kerberos身份认证工作。</p><p><br><br><br></p><h3 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h3><p>Kerberos is hard to set up，and harder to debug。常见问题有:</p><ul><li>Network and DNS configuration</li><li>Kerberos configuration on hosts (<code>/etc/krb5.conf</code>)</li><li>Keytab creation and maintenance</li><li>Environment setup: JVM, user login, system clocks, etc</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Set the environment variable HADOOP_JAAS_DEBUG to true</span><br><span class="line">export HADOOP_JAAS_DEBUG=true</span><br><span class="line"></span><br><span class="line"># Edit the log4j.properties file to log Hadoop’s security package at DEBUG level</span><br><span class="line">log4j.logger.org.apache.hadoop.security=DEBUG</span><br><span class="line"></span><br><span class="line"># Enable JVM-level debugging by setting some system properties</span><br><span class="line">export HADOOP_OPTS=&quot;-Djava.net.preferIPv4Stack=true -Dsun.security.krb5.debug=true -Dsun.security.spnego.debug&quot;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="KDiag"><a href="#KDiag" class="headerlink" title="KDiag"></a>KDiag</h3><p>Troubleshooting with KDiag</p><p>Hadoop有一个工具来帮助验证设置：<strong>KDiag</strong>。</p><p>它包含一系列用于JVM配置和环境的探测器，转储出一些系统文件（<code>/etc/krb5.conf</code>, <code>/etc/ntp.conf</code>），打印出一些系统状态，然后尝试登录到Kerberos作为当前用户或命名密钥表中的特定主体。<br>该命令的输出可用于本地诊断，或转发给支持群集的任何人。<br>KDiag命令有自己的入口点，通过将kdiag传递给<code>hadoop</code>命令来调用它。因此，它将显示用于调用它的命令的kerberos客户端状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hadoop kdiag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 帮助</span></span><br><span class="line">bin/hadoop kdiag --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 栗子</span></span><br><span class="line">hadoop kdiag \</span><br><span class="line">  --nofail \</span><br><span class="line">  --resource hdfs-site.xml --resource yarn-site.xml \</span><br><span class="line">  --keylen 1024 \</span><br><span class="line">  --keytab zk.service.keytab --principal zookeeper/devix.example.org@REALM</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="关闭安全模式"><a href="#关闭安全模式" class="headerlink" title="关闭安全模式"></a>关闭安全模式</h3><p>Hadoop Secure Mode默认是开启的！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看</span></span><br><span class="line"><span class="comment"># bin/hadoop dfsadmin -safemode get(旧)</span></span><br><span class="line">bin/hdfs dfsadmin -safemode get</span><br><span class="line">Safe mode is ON</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line"><span class="comment"># bin/hdfs dfsadmin -safemode leave(旧)</span></span><br><span class="line">bin/hdfs dfsadmin -safemode  leave</span><br><span class="line">Safe mode is OFF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用</span></span><br><span class="line"><span class="comment"># bin/hdfs dfsadmin -safemode enter(旧)</span></span><br><span class="line">bin/hdfs dfsadmin -safemode enter</span><br><span class="line">Safe mode is ON</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="服务级别授权"><a href="#服务级别授权" class="headerlink" title="服务级别授权"></a>服务级别授权</h2><p><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-common/ServiceLevelAuth.html" target="_blank" rel="noopener">Service Level Authorization Guide</a></p><p>本节描述了如何配置和管理Hadoop服务级别的授权(Service Level Authorization)。</p><p><br></p><p><strong>Prerequisites:</strong></p><p>确已正确安装、配置和设置Hadoop！</p><p><br></p><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>服务级别授权是初始化授权机制，用于确保连接到特定的Hadoop服务的客户端具有必要的预配置设置，并且有权访问给定服务。例如，MapReduce集群可以使用此机制来允许已配置的用户/组列表提交作业。</p><p><code>$HADOOP_CONF_DIR/hadoop-policy.xml</code>配置文件用于定义各种Hadoop服务的访问控制列表(ACL)。<br>服务级别授权在其他访问控制检查之前执行很久，例如文件权限检查，作业队列上的访问控制等。</p><p><br><br><br></p><h3 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h3><p>通过配置文件<code>$HADOOP_CONF_DIR/hadoop-policy.xml</code>配置服务级别的授权。</p><p><br></p><h4 id="启用服务级别授权"><a href="#启用服务级别授权" class="headerlink" title="启用服务级别授权"></a>启用服务级别授权</h4><p>Enable Service Level Authorization</p><p>默认情况下，Hadoop禁用服务级别授权。要启用它，请在<code>$HADOOP_CONF_DIR/core-site.xml</code>中将配置属性<code>hadoop.security.authorization</code>设置为<code>true</code>。</p><p><br><br><br></p><h4 id="Hadoop服务和配置项"><a href="#Hadoop服务和配置项" class="headerlink" title="Hadoop服务和配置项"></a>Hadoop服务和配置项</h4><p>Hadoop Services and Configuration Properties</p><p>下面列出各种Hadoop服务及其配置项:</p><div class="table-container"><table><thead><tr><th>Property</th><th>Service</th></tr></thead><tbody><tr><td><code>security.client.protocol.acl</code></td><td>ACL for ClientProtocol, which is used by user code via the DistributedFileSystem.</td></tr><tr><td><code>security.client.datanode.protocol.acl</code></td><td>ACL for ClientDatanodeProtocol, the client-to-datanode protocol for block recovery.</td></tr><tr><td><code>security.datanode.protocol.acl</code></td><td>ACL for DatanodeProtocol, which is used by datanodes to communicate with the namenode.</td></tr><tr><td><code>security.inter.datanode.protocol.acl</code></td><td>ACL for InterDatanodeProtocol, the inter-datanode protocol for updating generation timestamp.</td></tr><tr><td><code>security.namenode.protocol.acl</code></td><td>ACL for NamenodeProtocol, the protocol used by the secondary namenode to communicate with the namenode.</td></tr><tr><td><code>security.job.client.protocol.acl</code></td><td>ACL for JobSubmissionProtocol, used by job clients to communciate with the resourcemanager for job submission, querying job status etc.</td></tr><tr><td><code>security.job.task.protocol.acl</code></td><td>ACL for TaskUmbilicalProtocol, used by the map and reduce tasks to communicate with the parent nodemanager.</td></tr><tr><td><code>security.refresh.policy.protocol.acl</code></td><td>ACL for RefreshAuthorizationPolicyProtocol, used by the dfsadmin and rmadmin commands to refresh the security policy in-effect.</td></tr><tr><td><code>security.ha.service.protocol.acl</code></td><td>ACL for HAService protocol used by HAAdmin to manage the active and stand-by states of namenode.</td></tr></tbody></table></div><p><br><br><br></p><h4 id="访问控制列表"><a href="#访问控制列表" class="headerlink" title="访问控制列表"></a>访问控制列表</h4><p>Access Control Lists</p><p><code>$HADOOP_CONF_DIR/hadoop-policy.xml</code>为每个Hadoop服务定义一个访问控制列表。</p><p>每个访问控制列表都有一个简单的格式: users/groups都是用逗号分隔的名称列表。如: <code>user1, user2, group1, group2</code></p><p>如果仅提供组列表，则在行的开头添加空格，等效地以逗号分隔的用户列表后跟空格或不显示仅包含一组给定用户。特殊值<code>*</code>表示允许所有用户访问该服务。如果未为服务定义访问控制列表，则应用<code>security.service.authorization.default.acl</code> 的值。如果未定义 <code>security.service.authorization.default.acl</code>，则应用<code>*</code>。</p><p><br><br><br></p><h4 id="被阻止的访问控制列表"><a href="#被阻止的访问控制列表" class="headerlink" title="被阻止的访问控制列表"></a>被阻止的访问控制列表</h4><p>Blocked Access Control Lists</p><p>在某些情况下，需要为服务指定阻止的访问控制列表。这指定了未授权访问该服务的用户和组的列表。被阻止的访问控制列表的格式与访问控制列表的格式相同。<br>可通过<code>$HADOOP_CONF_DIR/hadoop-policy.xml</code>指定阻止的访问控制列表。属性名称通过后缀<code>.blocked</code>派生。栗子: <code>security.client.protocol.acl</code> 的阻止访问控制列表的属性名称为<code>security.client.protocol.acl.blocked</code> 。</p><p>对于服务，可以指定访问控制列表和阻止的控制列表。如果用户在访问控制中而不在阻止的访问控制列表中，则授权用户访问该服务。</p><p>如果未为服务定义阻止访问控制列表，则应用 <code>security.service.authorization.default.acl.blocked</code> 的值。如果未定义 <code>security.service.authorization.default.acl.blocked</code>，则应用空的阻止访问控制列表。</p><p><br><br><br></p><h4 id="IP地址，主机名，IP范围进行访问控制"><a href="#IP地址，主机名，IP范围进行访问控制" class="headerlink" title="IP地址，主机名，IP范围进行访问控制"></a>IP地址，主机名，IP范围进行访问控制</h4><p>Access Control using Lists of IP Addresses, Host Names and IP Ranges</p><p>可以基于访问服务的客户端IP地址来控制对服务的访问。通过指定IP地址，主机名和IP范围列表，可以限制从一组计算机访问服务。每个服务的属性名称都是从相应的acl属性名称派生的。如果acl的属性名称为<code>security.client.protocol.acl</code>，则hosts列表的属性名称为 <code>security.client.protocol.hosts</code>。<br>如果未为服务定义主机列表，则应用 <code>security.service.authorization.default.hosts</code> 的值。如果未定义 <code>security.service.authorization.default.hosts</code>，则应用 <code>*</code> 。</p><p>可以指定阻止的主机列表。只有那些位于主机列表中但未在阻止主机列表中的计算机才会被授予对该服务的访问权限。属性名称通过后缀 <code>.blocked</code> 派生。栗子: <code>security.client.protocol.hosts</code> 的被阻止主机列表的属性名称为 <code>security.client.protocol.hosts.blocked</code>。<br>如果未为服务定义阻止主机列表，则应用 <code>security.service.authorization.default.hosts.blocked</code> 的值。如果未定义 <code>security.service.authorization.default.hosts.blocked</code>，则应用空的阻止主机列表。</p><p><br><br><br></p><h4 id="刷新服务级别授权配置"><a href="#刷新服务级别授权配置" class="headerlink" title="刷新服务级别授权配置"></a>刷新服务级别授权配置</h4><p>Refreshing Service Level Authorization Configuration</p><p>可在不重启Hadoop Daemon的情况下更改NameNode和ResourceManager的服务级别授权配置。集群管理员可在Master节点上更改<code>$HADOOP_CONF_DIR/hadoop-policy.xml</code>，并指示NameNode和ResourceManager分别通过<code>-refreshServiceAcl</code>开关将其各自的配置重新加载到<code>dfsadmin</code>和<code>rmadmin</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刷新NameNode的服务级别的授权配置</span></span><br><span class="line">bin/hdfs dfsadmin -refreshServiceAcl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新ResourceManager的服务级别授权配置</span></span><br><span class="line">bin/yarn rmadmin -refreshServiceAcl</span><br></pre></td></tr></table></figure><p>当然，也可以使用<code>$HADOOP_CONF_DIR/hadoop-policy.xml</code>中的<code>security.refresh.policy.protocol.acl</code>属性来限制对某些users/groups刷新服务级别授权的访问权限。</p><p><br><br><br></p><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><p>仅允许mapreduce gruop中的a, b users将作业提交到MapReduce集群:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;security.job.client.protocol.acl&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;a,b mapreduce&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><br></p><p>仅允许数据属于group datanodes的users运行的DataNode与NameNode进行通信:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;security.datanode.protocol.acl&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;datanodes&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><br></p><p>允许任何用户作为DFSClient与HDFS集群通信:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;security.client.protocol.acl&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;*&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="HTTP认证"><a href="#HTTP认证" class="headerlink" title="HTTP认证"></a>HTTP认证</h2><p><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-common/HttpAuthentication.html" target="_blank" rel="noopener">Authentication for Hadoop HTTP web-consoles</a></p><p><br></p><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>本节介绍如何配置Hadoop HTTP web-console以要求用户身份认证。</p><p>默认情况下，Hadoop HTTP web-console(ResourceManager, NameNode, NodeManager, DataNodes)允许无需任何形式的身份认证的访问。</p><p>可将Hadoop HTTP web-console配置为使用HTTP SPNEGO协议要求Kerberos身份认证。<br>此外，Hadoop HTTP web-console支持相当于Hadoop的 Pseudo/Simple 认证。如果启用此选项，则必须使用 <code>user.name</code> 查询字符串参数在浏览器交互中地址用户名。 如: <code>http://localhost:8088/cluster?user.name=usera</code>。<br>如果HTTP web-console需要自定义身份认证机制，则可以实现插件以支持备用身份认证机制。</p><p><br><br><br></p><h3 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h3><p>以下属性应位于集群中所有节点的 <code>core-site.xml</code> 中:</p><div class="table-container"><table><thead><tr><th>Property Name</th><th>Default Value</th><th>Description</th></tr></thead><tbody><tr><td><code>hadoop.http.filter.initializers</code></td><td>-</td><td>Add to this property the org.apache.hadoop.security.AuthenticationFilterInitializer initializer class.</td></tr><tr><td><code>hadoop.http.authentication.type</code></td><td>simple</td><td>Defines authentication used for the HTTP web-consoles. The supported values are: simple</td><td>kerberos</td><td>#AUTHENTICATION_HANDLER_CLASSNAME#.</td></tr><tr><td><code>hadoop.http.authentication.token.validity</code></td><td>36000</td><td>Indicates how long (in seconds) an authentication token is valid before it has to be renewed.</td></tr><tr><td><code>hadoop.http.authentication.token.max-inactive-interval</code></td><td>-1 (disabled)</td><td>Specifies the time, in seconds, between client requests the server will invalidate the token.</td></tr><tr><td><code>hadoop.http.authentication.signature.secret.file</code></td><td><code>$user.home/hadoop-http-auth-signature-secret</code></td><td>The signature secret file for signing the authentication tokens. The same secret should be used for all nodes in the cluster, ResourceManager, NameNode, DataNode and NodeManager. This file should be readable only by the Unix user running the daemons.</td></tr><tr><td><code>hadoop.http.authentication.cookie.domain</code></td><td>-</td><td>The domain to use for the HTTP cookie that stores the authentication token. For authentication to work correctly across all nodes in the cluster the domain must be correctly set. There is no default value, the HTTP cookie will not have a domain working only with the hostname issuing the HTTP cookie.</td></tr><tr><td><code>hadoop.http.authentication.cookie.persistent</code></td><td>false (session cookie)</td><td>Specifies the persistence of the HTTP cookie. If the value is true, the cookie is a persistent one. Otherwise, it is a session cookie. IMPORTANT: when using IP addresses, browsers ignore cookies with domain settings. For this setting to work properly all nodes in the cluster must be configured to generate URLs with hostname.domain names on it.</td></tr><tr><td><code>hadoop.http.authentication.simple.anonymous.allowed</code></td><td>true</td><td>Indicates whether anonymous requests are allowed when using ‘simple’ authentication.</td></tr><tr><td><code>hadoop.http.authentication.kerberos.principal</code></td><td><code>HTTP/_HOST@$LOCALHOST</code></td><td>Indicates the Kerberos principal to be used for HTTP endpoint when using ‘kerberos’ authentication. The principal short name must be HTTP per Kerberos HTTP SPNEGO specification. _HOST -if present- is replaced with bind address of the HTTP server.</td></tr><tr><td><code>hadoop.http.authentication.kerberos.keytab</code></td><td><code>$user.home/hadoop.keytab</code></td><td>Location of the keytab file with the credentials for the Kerberos principal used for the HTTP endpoint.</td></tr></tbody></table></div><p><br><br><br></p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>要启用跨域支持(CORS)，请设置以下配置参数:</p><p>将 <code>org.apache.hadoop.security.HttpCrossOriginFilterInitializer</code> 添加到 <code>core-site.xml</code> 中的 <code>hadoop.http.filter.initializers</code>。您还需要在 <code>core-site.xml</code> 中设置以下属性:</p><div class="table-container"><table><thead><tr><th>Property</th><th>Default Value</th><th>Description</th></tr></thead><tbody><tr><td><code>hadoop.http.cross-origin.enabled</code></td><td><code>false</code></td><td>Enables cross origin support for all web-services</td></tr><tr><td><code>hadoop.http.cross-origin.allowed-origins</code></td><td><code>*</code></td><td>Comma separated list of origins that are allowed. Values prefixed with regex: are interpreted as regular expressions. Values containing wildcards (*) are possible as well, here a regular expression is generated, the use is discouraged and support is only available for backward compatibility.</td></tr><tr><td><code>hadoop.http.cross-origin.allowed-methods</code></td><td>GET,POST,HEAD</td><td>Comma separated list of methods that are allowed</td></tr><tr><td><code>hadoop.http.cross-origin.allowed-headers</code></td><td>X-Requested-With,Content-Type,Accept,Origin</td><td>Comma separated list of headers that are allowed</td></tr><tr><td><code>hadoop.http.cross-origin.max-age</code></td><td>1800</td><td>Number of seconds a pre-flighted request can be cached</td></tr></tbody></table></div><p><br><br><br><br><br></p><h2 id="Credential-Provider-API"><a href="#Credential-Provider-API" class="headerlink" title="Credential Provider API"></a>Credential Provider API</h2><p><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-common/CredentialProviderAPI.html" target="_blank" rel="noopener">CredentialProvider API Guide</a></p><p>CredentialProvider API是一个用于插入可扩展凭据提供程序的SPI框架。凭据提供程序用于将敏感令牌(token)，机密(secret)和密码(passwd)的使用与其存储和管理的详细信息分开。选择各种存储机制来保护这些凭证的能力使我们能够使这些敏感资产远离明文(clear text)，远离窥探并可能由第三方解决方案管理。</p><p>本节描述CredentialProvider API的设计，开箱即用的实现，使用它们以及如何使用它们。</p><p><br><br><br><br><br></p><h2 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h2><p><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-kms/index.html" target="_blank" rel="noopener">Hadoop Key Management Server (KMS)</a></p><p><strong>Hadoop KMS</strong> 是一个基于Hadoop KeyProvider API的加密秘钥管理服务器。<br>它提供了一个Client和Server组件，它们使用REST API通过HTTP进行通信。<br>Client是KeyProvider实现，使用KMS HTTP REST API与KMS交互。<br>KMS及其Client內建有安全性，并且支持HTTP和 SPNEGO Kerberos认证和HTTPS安全传输。<br>KMS是一个Java Jetty Web应用程序。</p><p><br><br><br><br><br></p><h2 id="Tracing"><a href="#Tracing" class="headerlink" title="Tracing"></a>Tracing</h2><p><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-common/Tracing.html" target="_blank" rel="noopener">Enabling Dapper-like Tracing in Hadoop</a></p><p><br></p><h3 id="HTrace"><a href="#HTrace" class="headerlink" title="HTrace"></a>HTrace</h3><p>HDFS-5274 使用开源跟踪库(Apache HTrace)增加了对通过HDFS跟踪请求的支持。设置跟踪非常简单，但是它需要对客户端代码进行一些非常小的更改。</p><p><br><br><br></p><h3 id="SpanReceivers"><a href="#SpanReceivers" class="headerlink" title="SpanReceivers"></a>SpanReceivers</h3><p><br><br><br></p><hr><p><br><br><br></p><h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><p><br></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html" target="_blank" rel="noopener">HDFS Architecture</a></p><p>Hadoop Distributed File System(HDFS) 是一种分布式文件系统，设计用于在商业硬件上运行。它与现有的分布式文件系统有许多相似之处。但是，与其它分布式文件系统的差异很大。HDFS具有高度容错(fault-tolerant)能力，旨在部署在低成本硬件上。HDFS提供对应用程序数据的高吞吐量访问，适用于具有大型数据集的应用程序。HDFS放宽了一些POSIX要求，以实现对文件系统数据的流式访问。</p><p><br><br><br></p><h3 id="假设和目标"><a href="#假设和目标" class="headerlink" title="假设和目标"></a>假设和目标</h3><p>Assumptions and Goals</p><p><br></p><h4 id="硬件故障"><a href="#硬件故障" class="headerlink" title="硬件故障"></a>硬件故障</h4><p>Hardware Failure</p><p>硬件故障是常态而非异常。HDFS实例可能包含成百上千的主机，每台主机都存储文件系统数据的一部分。事实上，存在大量组件并且每个组件具有非平凡(non-trivial)的故障概率，这意味着HDFS某些组件始终不起作用(non-functional)。因此，检测故障并从中快速自动地恢复是HDFS的核心架构目标。</p><p><br><br><br></p><h4 id="流数据访问"><a href="#流数据访问" class="headerlink" title="流数据访问"></a>流数据访问</h4><p>Streaming Data Access</p><p>在HDFS上运行的应用程序需要对其数据集进行流式访问。它们不是通常在通用文件系统上运行的通用应用程序。HDFS设计用于批处理而不是用户的交互式使用。重点是数据访问的高吞吐量(high throughput)而不是数据访问的低延迟(low latency)。POSIX强加了许多针对HDFS的应用程序不需要的硬性要求。</p><p><br><br><br></p><h4 id="大型数据集"><a href="#大型数据集" class="headerlink" title="大型数据集"></a>大型数据集</h4><p>Large Data Sets</p><p>在HDFS上运行的应用程序具有大型数据集。HDFS中的典型文件大小为gigabytes到terabytes。因此，HDFS被调整为支持大文件。它应该为单个集群中的成百上千的节点提供高聚合数据带宽和扩展。它应该在单个实例中支持数千万个文件。</p><p><br><br><br></p><h4 id="简单的一致性模型"><a href="#简单的一致性模型" class="headerlink" title="简单的一致性模型"></a>简单的一致性模型</h4><p>Simple Coherency Model</p><p>HDFS应用程序需要一个<code>write-once-read-many</code>的文件访问模型。除了追加(append)和截断(truncates)之外，无需更改创建，写入和关闭的文件。支持将内容附加到文件末尾，但无法在任意点更新。此假设简化了数据一致性问题，并实现了高吞吐量数据访问。MapReduce应用程序或Web Crawler应用程序适合此模型。</p><p><br><br><br></p><h4 id="移动计算比移动数据更便宜"><a href="#移动计算比移动数据更便宜" class="headerlink" title="移动计算比移动数据更便宜"></a>移动计算比移动数据更便宜</h4><p>Moving Computation is Cheaper than Moving Data</p><p>如果应用程序在其操作的数据附近执行，则计算所请求的计算效率更高。当数据集很大时尤其如此。这可以最大限度地减少网络拥塞(network congestion)并提高系统的整体吞吐量。这个假设通常更好的是将计算迁移到更靠近数据所在的地方，而不是将数据移动到应用程序运行的地方。HDFS为应用程序移动到更靠近数据所在的地方的接口。</p><p><br><br><br></p><h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h4><p>Portability Across Heterogeneous Hardware and Software Platforms</p><p>HDFS的设计便于从一个平台移植到另一个平台。</p><p><br><br><br><br><br></p><h3 id="NameNode和DataNode"><a href="#NameNode和DataNode" class="headerlink" title="NameNode和DataNode"></a>NameNode和DataNode</h3><p>HDFS具有主从架构(Master-Slave)。HDFS集群由单个<strong>NameNode</strong>、一个管理文件系统命名空间和管理客户端对文件的访问的<strong>Master Server</strong>组成。此外，还有许多<strong>DataNode</strong>，通常是集群中每个节点一个，用于管理附加到它们运行节点的存储。HDFS公开文件系统命名空间，并允许用户数据存储在文件中。在内部，文件被分成一个或多个块(block)，这些块存储在一组DataNode中。<br>NameNode执行文件系统命名空间操作(如打开、关闭、重命名文件目录)。它还确定了block到DataNode的映射。<br>DataNode负责提供来自文件系统客户端的读写请求，它还根据NameNode的指令执行块操作(如创建、删除、副本)。</p><p><img src="/images/Hadoop/hdfsarchitecture.png" alt></p><p><br></p><p>NameNode和DataNode是设计用于在商用机器上运行的软件，这些机器通常运行GNU/Linux操作系统。HDFS使用Java语言构建，任何支持Java的机器都可运行NameNode或DataNode软件。使用高度可移植的Java语言意味着可以在各种计算机上部署HDFS。<br>典型部署具有仅运行NameNode软件的专用主机，群集中的每台其它主机都运行一个DataNode软件实例。虽然可以讲它们运行在同一台主机上，但这并不推荐。</p><p>群集中存在单个NameNode极大地简化了系统结构。NameNode是所有HDFS Metadata的仲裁者(arbitrator)和存储库(repository)。系统的设计使用户数据永远不会流经NameNode。</p><p><br><br><br><br><br></p><h3 id="文件系统命名空间"><a href="#文件系统命名空间" class="headerlink" title="文件系统命名空间"></a>文件系统命名空间</h3><p>The File System Namespace</p><p>HDFS支持传统的层次文件组织。用户或应用程序可以创建目录，并在这些目录中存储文件。文件系统命名空间层次结构类似于大多数其它现有文件系统；可创建、删除、移动、重命名文件。HDFS支持用户配额(user quotas)和访问权限。HDFS不支持硬链接和软链接。但是，HDFS架构并不排除实现这些功能。</p><p>NameNode维护文件系统命名空间。NameNode Record对文件系统命名空间或其属性的任何更改。应用程序可以指定应由HDFS维护的文件的副本数。文件的副本数称为该文件的复制因子，该信息由NameNode存储。</p><p><br><br><br><br><br></p><h3 id="数据副本"><a href="#数据副本" class="headerlink" title="数据副本"></a>数据副本</h3><p>Data Replication</p><p>HDFS旨在可靠地在大型群集中的计算机上存储非常大的文件。它将每个文件存储为一系列块。文件块的副本用以实现容错(fault tolerance)。块大小和副本因子可根据文件进行配置。</p><p>除了最后一个块之外，文件中的所有块都具有相同的大小。而用户可以在添加对可变长度块的支持以追加和hsync之后启动新块而不将最后一个块填充到配置的块大小。</p><p>应用程序可以指定文件的副本数量。副本因子可在文件创建时指定，并且可以在之后修改。HDFS中的文件是一次写入的，并且在任何时候都有一个写入器。</p><p>NameNode做出有关副本的所有决定。它定期从集群中的每个DataNode接收Heartbeat和Blockreport。收到心跳意味着DataNode正常运行，块上报包含DataNode上所有块的列表。</p><p><img src="/images/Hadoop/hdfsdatanodes.png" alt></p><p><br></p><h4 id="副本安置"><a href="#副本安置" class="headerlink" title="副本安置"></a>副本安置</h4><p>Replica Placement: The First Baby Steps</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wikipeadia&lt;/li&gt;
&lt;li&gt;Hadoop官网: &lt;a href=&quot;https://hadoop.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hadoop.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Apache Software Foundation: &lt;a href=&quot;https://www.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RHEL7x86_64&lt;/li&gt;
&lt;li&gt;Hadoop v3.2.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="Apache" scheme="https://zhang21.github.io/tags/Apache/"/>
    
      <category term="DataAnalysis" scheme="https://zhang21.github.io/tags/DataAnalysis/"/>
    
      <category term="Hadoop" scheme="https://zhang21.github.io/tags/Hadoop/"/>
    
      <category term="BigData" scheme="https://zhang21.github.io/tags/BigData/"/>
    
  </entry>
  
  <entry>
    <title>SonarQube</title>
    <link href="https://zhang21.github.io/2019/02/22/SonarQube/"/>
    <id>https://zhang21.github.io/2019/02/22/SonarQube/</id>
    <published>2019-02-22T07:28:44.000Z</published>
    <updated>2019-03-05T08:42:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>GitHub: <a href="https://github.com/SonarSource/sonarqube" target="_blank" rel="noopener">https://github.com/SonarSource/sonarqube</a></li><li>Website: <a href="https://www.sonarqube.org/" target="_blank" rel="noopener">https://www.sonarqube.org/</a></li><li>Docs: <a href="https://docs.sonarqube.org" target="_blank" rel="noopener">https://docs.sonarqube.org</a></li></ul><p>环境:</p><ul><li>RHEL7x86_64</li><li>SonarQube v7.6</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>SonarQube</strong> 是一个开源的代码质量管理系统。支持超过25中编程语言，不过有些是商业插件。</p><p>SonarQube 是一种自动代码审查(code review)工具，用于检测代码中的<strong>错误(bugs)</strong>，<strong>漏洞(vulnerabilities)</strong>和<strong>代码异味(code smell)</strong>。它可以与您现有的工作流程集成，以便在项目分支和拉取请求之间进行连续的代码检查。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="架构与集成"><a href="#架构与集成" class="headerlink" title="架构与集成"></a>架构与集成</h1><p>Architecture and Integration</p><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SonarQube平台由4个组件组成:</p><p><img src="/images/SonarQube/architecture-scanning.png" alt></p><p><br></p><ul><li><strong>SonarQube Server</strong>启动三个主进程:<ul><li><strong>Web Server</strong>，供开发人员，管理人员浏览质量快照并配置SonarQube实例</li><li><strong>Search Server</strong>，基于ElasticSearch从UI返回搜索</li><li><strong>Compute Engine Server</strong>，负责处理代码分析和上报并将其保存到SonarQube数据库中</li></ul></li><li><strong>SonarQube Database</strong>用于存储<ul><li>SonarQube实例的配置(安全，插件…的设置)</li><li>项目，视图…的质量快照</li></ul></li><li>Server上安装了多个插件，可能包括Language，SCM，Intergration，Authentication，Governance…</li><li>在CI/CD Server上运行一个或多个 <strong>SonarScanner</strong> 来分析项目</li></ul><p><br><br><br><br><br></p><h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><p>Integration</p><p>以下模式显示了SonarQube如何与其它ALM工具进行集成，以及在哪里使用SonarQube的各种组件。</p><p><img src="/images/SonarQube/architecture-integrate.png" alt></p><p><br></p><ol><li>开发者在他们的IDE中集成SonarLint运行本地分析</li><li>开发者推送他们的代码到代码库</li><li>CI Server触发自动构建，以及执行运行SonarQube分析所需的SonarScanner</li><li>分析报告将发送到SonarQube Server进行处理</li><li>SonarQube Server处理分析报告并将结果存储在SonarQuebe数据库中，并在UI中显示结果</li><li>开发者通过SonarQube UI审核，评论，挑战他们的Issues以管理和减少他们的技术债务</li><li>管理者从分析中接收报告，运维使用API自动配置并从SonarQube中提取数据，使用JMX监控SonarQube Server</li></ol><p><br><br><br><br><br></p><h2 id="关于机器和位置"><a href="#关于机器和位置" class="headerlink" title="关于机器和位置"></a>关于机器和位置</h2><p>About Machines and Locations</p><ul><li>SonarQube平台不能够有多个SonarQube Server和SonarQube Database</li><li>为获得最佳性能，每个组件(Server, Database, Scanner)应该安装在单独的机器上，并且此机器应该是专用的</li><li>SonarScanner通过添加机器进行扩展</li><li>所有机器必须时钟同步</li><li>SonarQube Server和SonarQube Database必须位于同一网络下</li><li>SonarScanner不需要与SonarQube Server位于同一网络下</li><li>SonarScanner与SonarQube Database之间没有通信</li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p>Requirements</p><p><br></p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>Prerequisites and Overview</p><p>运行SonarQube的唯一先决条件是安装Java(Oracle JRE 8/OpenJDK 8)。</p><p><br></p><h3 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h3><ul><li>2Cores+</li><li>2GB RAM+</li><li>建议使用高性能I/O的磁盘</li></ul><p><br><br><br></p><h3 id="支持的平台"><a href="#支持的平台" class="headerlink" title="支持的平台"></a>支持的平台</h3><ul><li>Java<ul><li>Oracle JRE 8</li><li>OpenJDK 8</li></ul></li><li>Database<ul><li>PostgreSQL v9.3-v9.6, v10. UTF-8 charset</li><li>SQL Server v2014, v2016. </li><li>Oracle v11, v12, vXE. UTF8-family charset, thin mode</li><li>MySQL v5.6, v5.7. UTF8 charset, InnoDB storage, mysql-connector-java</li></ul></li><li>Web Browser<ul><li>IE 11</li><li>Edge Latest</li><li>FireFox Latest</li><li>Chrome</li><li>Safari</li></ul></li></ul><p><br><br><br></p><h3 id="平台说明"><a href="#平台说明" class="headerlink" title="平台说明"></a>平台说明</h3><p><br></p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>如果在Linux上运行，请确保:</p><ul><li><code>vm.max_map_count</code> 大于或等于 262144</li><li><code>fs.file-max</code> 大于或等于 65535</li><li>运行SonarQube的用户可以打开至少65535个文件描述符</li><li>运行SonarQube的用户可以打开至少2048个线程</li></ul><p>用以下命令查看和配置它们:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sysctl vm.max_map_count</span><br><span class="line">sysctl fs.file-max</span><br><span class="line"><span class="built_in">ulimit</span> -n</span><br><span class="line"><span class="built_in">ulimit</span> -u</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置，但只是临时生效</span></span><br><span class="line"><span class="comment"># root</span></span><br><span class="line">sysctl -w vm.max_map_count=262144</span><br><span class="line">sysctl -w fs.file-max=65536</span><br><span class="line"><span class="built_in">ulimit</span> -n 65536</span><br><span class="line"><span class="built_in">ulimit</span> -u 2048</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久生效</span></span><br><span class="line"><span class="comment"># /etc/sysctl.d/99-sonarqube.conf 或 /etc/sysctl.conf</span></span><br><span class="line"><span class="comment"># user: sonarqube</span></span><br><span class="line">sonarqube   -   nofile   65536</span><br><span class="line">sonarqube   -   nproc    2048</span><br></pre></td></tr></table></figure><p><br></p><p>如果使用<code>systemd</code>来启动SonarQube，你必须在<code>[Service]</code>的单元文件中指定这些限制:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">...</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">LimitNPROC=2048</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="seccomp-filter"><a href="#seccomp-filter" class="headerlink" title="seccomp filter"></a>seccomp filter</h4><p>默认情况下，ElasticSearch使用<strong>seccomp filter</strong>。在大多数发行版中，此功能在内核中激活。但在RHL6等发行版上，此功能已停用。如果你的发行版中没有此功能，请无法升级到激活了seccomp filter功能的版本，则必须通过更新<code>$SONARQUBEHOME/conf/sonar.properties_</code>中的<code>sonar.search.javaAdditionalOpts</code>配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sonar.search.javaAdditionalOpts=-Dbootstrap.system_call_filter=false</span><br><span class="line"></span><br><span class="line"># 检查</span><br><span class="line">grep SECCOMP /boot/config-$(uname -r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如果内核有它，你将看到</span><br><span class="line">CONFIG_HAVE_ARCH_SECCOMP_FILTER=y</span><br><span class="line">CONFIG_SECCOMP_FILTER=y</span><br><span class="line">CONFIG_SECCOMP=y</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="配置和升级"><a href="#配置和升级" class="headerlink" title="配置和升级"></a>配置和升级</h1><p>Setup and Upgrade</p><p><br></p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>Get Started in Two Minutes Guide</p><ul><li>从ZIP文件安装</li><li>使用Docker</li></ul><p><br></p><h3 id="zip文件安装"><a href="#zip文件安装" class="headerlink" title="zip文件安装"></a>zip文件安装</h3><ol><li>现在 SonarQube CE</li><li>解压</li><li>运行</li><li>访问</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具体位置取决于你的安装位置</span></span><br><span class="line">/opt/sonarqube/bin/[OS]/sonar.sh console</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># localhost:9000（admin/admin）</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>在<a href="https://hub.docker.com/_/sonarqube/" target="_blank" rel="noopener">Docker Hub</a>上下载对应CE的镜像，上面有安装和配置的详细信息。</p><p><br><br><br><br><br></p><h2 id="安装Server"><a href="#安装Server" class="headerlink" title="安装Server"></a>安装Server</h2><p>支持多个数据库引擎，请务必遵守各个数据库引擎的要求。</p><p>创建一个空的schema和一个<code>sonarqube</code>用户。授予此用户<code>create, update, delete</code>此<code>schema</code>对象的权限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> <span class="string">`sonar`</span> <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'sonarqube'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'sonarqube-PW123'</span>;</span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> sonar.* <span class="keyword">TO</span> <span class="string">'sonarqube'</span>@<span class="string">'localhost'</span>;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h3><p><br></p><h4 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h4><p>跳过，有需要的请看: <a href="https://docs.sonarqube.org/latest/setup/install-server/" target="_blank" rel="noopener">https://docs.sonarqube.org/latest/setup/install-server/</a></p><p><br><br><br></p><h4 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h4><p>跳过！</p><p><br><br><br></p><h4 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h4><p>如果你想使用<code>custom schema</code>而不是默认的<code>public schema</code>，则必须设置PostgreSQL的<code>search_path</code>属性:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> mySonarUser <span class="keyword">SET</span> search_path <span class="keyword">to</span> mySonarQubeSchema</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><blockquote><p>注意:<br>Data Center Edition(Enterprise)不支持MySQL!<br>Data Center Edition: Designed for High Availability</p></blockquote><p>可在MySQL中使用两种众所周知的数据库引擎: <strong>MyISAM</strong>和<strong>InnoDB</strong>。MyISAM是最老的，并且正在逐渐被InnoDB替代。随着质量控制项目数量的增加，InnoDB显然更快，并且使用SonarQube可以更好地扩展。<br>如果你是SonarQube的早期使用者，你可能有一系列仍在使用MyISAM引擎的表。你应该将所有表的引擎更改为InnoDB。</p><p>一旦所有SonarQube表都使用InnoDB引擎，首先要做的是使用<code>innodb_buffer_pool_size</code>参数为MySQL实例分配最大的RAM，并为<code>query_cache_size</code>参数提供至少<code>15Mb</code>。</p><p>阅读这篇文档<a href="https://www.percona.com/blog/2007/11/01/innodb-performance-optimization-basics/" target="_blank" rel="noopener">InnoDB Performance Optimization</a>来优化InnoDB。</p><p><br><br><br></p><h3 id="安装Web-Server"><a href="#安装Web-Server" class="headerlink" title="安装Web Server"></a>安装Web Server</h3><p>首先，检查安装要求；<br>下载和解压压缩的发行版(不要解压到以数字开头的目录)；<br>下面变量<code>SONARQUBE-HOME</code>指的是解压的路径。</p><p><br></p><h4 id="设置数据库访问"><a href="#设置数据库访问" class="headerlink" title="设置数据库访问"></a>设置数据库访问</h4><p>编辑<code>$SONARQUBE-HOME/conf/sonar.properties</code>来配置数据库设置。模板可用于每个受支持的数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Example for MySQL</span><br><span class="line">sonar.jdbc.username=sonarqube</span><br><span class="line">sonar.jdbc.password=sonarqube-PW123</span><br><span class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false</span><br></pre></td></tr></table></figure><p><br></p><h4 id="添加JDBC驱动"><a href="#添加JDBC驱动" class="headerlink" title="添加JDBC驱动"></a>添加JDBC驱动</h4><p>已提供受支持数据库(Oracle除外)的驱动程序。不要更换提供的驱动程序，它们是唯一受支持的。</p><p>对于Oracle，将JDBC驱动复制到<code>$SONARQUBE-HOME/extensions/jdbc-driver/oracle</code>。</p><p><br><br><br></p><h4 id="配置ElasticSearch存储路径"><a href="#配置ElasticSearch存储路径" class="headerlink" title="配置ElasticSearch存储路径"></a>配置ElasticSearch存储路径</h4><p>默认情况下，ES数据存储在<code>$SONARQUBE-HOME/data</code>中，但不建议用于生产环境。相反，你应该将数据存储在其它位置，最好是在具有高速I/O的专用卷。除了保持可接受的性能之外，还可简化SonarQube的升级。</p><p>编辑<code>$SONARQUBE-HOME/conf/sonar.properties</code>来配置以下设置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 请记得添加读写权限</span><br><span class="line">sonar.path.data=/var/sonarqube/data</span><br><span class="line">sonar.path.temp=/var/sonarqube/temp</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="启动Web-Server"><a href="#启动Web-Server" class="headerlink" title="启动Web Server"></a>启动Web Server</h4><p>可在<code>$SONARQUBE-HOME/conf/sonar.properties</code>配置监听地址和端口等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sonar.web.host=192.0.0.1</span><br><span class="line">sonar.web.port=80</span><br><span class="line">sonar.web.context=/sonarqube</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">bin/sonar.sh start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认admin/admin</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="调整Web服务器"><a href="#调整Web服务器" class="headerlink" title="调整Web服务器"></a>调整Web服务器</h4><p>默认情况下，SonarQube配置为在任何具有简单Java JRE的计算机上运行。</p><p>为了更好地性能，生产环境实例要做的第一件事是使用Java JDK并通过在<code>sonar.web.javaOpts=-server</code>中设置以下行来激活服务器模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sonar.web.javaOpts=-server</span><br></pre></td></tr></table></figure><p>要修改SonarQube使用的Java JVM只需编辑<code>$SONARQUBE-HOME/conf/wrapper.conf</code>并更新以下行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrapper.java.command=/path/to/my/jdk/bin/java</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><p>docs: <a href="https://docs.sonarqube.org/latest/setup/install-server/" target="_blank" rel="noopener">https://docs.sonarqube.org/latest/setup/install-server/</a></p><p><br><br><br><br><br></p><h2 id="配置和操作Server"><a href="#配置和操作Server" class="headerlink" title="配置和操作Server"></a>配置和操作Server</h2><p>Configure &amp; Operate the Server</p><p><br></p><h3 id="以SystemD运行"><a href="#以SystemD运行" class="headerlink" title="以SystemD运行"></a>以SystemD运行</h3><p>Running SonarQube as a Service on Linux with SystemD</p><p>假设如下信息:</p><ul><li>sonarqube用户</li><li>sonarqube组</li><li>java virtual machine安装在<code>/opt/java/</code></li><li>sonarqube解压在<code>/opt/sonarqube/</code></li></ul><p><br></p><p>创建<code>sonarqube</code>用户:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -M -s /sbin/nologin</span><br></pre></td></tr></table></figure><p><br></p><p>创建service文件<code>/etc/systemd/system/sonarqube.service</code>，具体详情请安装自己的实际情况进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=SonarQube service</span><br><span class="line">After=syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=sonarqube</span><br><span class="line">Group=sonarqube</span><br><span class="line">PermissionsStartOnly=true</span><br><span class="line">ExecStart=/bin/nohup /opt/java/bin/java -Xms32m -Xmx32m -Djava.net.preferIPv4Stack=true -jar /opt/sonarqube/lib/sonar-application-7.6.jar</span><br><span class="line">StandardOutput=syslog</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">LimitNPROC=8192</span><br><span class="line">TimeoutStartSec=5</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> sonarqube.service</span><br><span class="line">sudo systemctl start sonarqube.service</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="在代理服务器后保护Server"><a href="#在代理服务器后保护Server" class="headerlink" title="在代理服务器后保护Server"></a>在代理服务器后保护Server</h3><p>Securing the Server Behind a Proxy</p><p><br></p><h4 id="Server配置"><a href="#Server配置" class="headerlink" title="Server配置"></a>Server配置</h4><p>要通过HTTPS运行SonarQube Server，必须构建标准的反向代理服务器。<br>必须配置反向代理，在每个HTTP Request Header中设置<code>X_FORWARDED_PROTO: https</code>值。如果没有此属性，SonarQube Server启动的重定向将回退到HTTP。</p><p><br><br><br></p><h4 id="使用Apache代理"><a href="#使用Apache代理" class="headerlink" title="使用Apache代理"></a>使用Apache代理</h4><p>跳过！</p><p><br><br><br></p><h4 id="使用Nginx代理"><a href="#使用Nginx代理" class="headerlink" title="使用Nginx代理"></a>使用Nginx代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># the server directive is nginx&apos;s virtual host directive</span><br><span class="line">server &#123;</span><br><span class="line">  # port to listen on. Can also be set to an IP:PORT</span><br><span class="line">  listen 80;</span><br><span class="line"></span><br><span class="line">  # sets the domain[s] that this vhost server requests for</span><br><span class="line">  server_name www.somecompany.com;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://sonarhost:sonarport;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="使用IIS"><a href="#使用IIS" class="headerlink" title="使用IIS"></a>使用IIS</h4><p>跳过！</p><p><br><br><br><br><br></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>在SonarQube中安装插件有两种选择:</p><ul><li><strong>Marketplace</strong>，从SonarQube UI自动地安装插件</li><li><strong>手动安装</strong>， 如果SonarQube实例无法访问Internet，请使用此方法</li></ul><p><br><br><br><br><br></p><h2 id="安装C-C-插件"><a href="#安装C-C-插件" class="headerlink" title="安装C/C++插件"></a>安装C/C++插件</h2><p>由于SonarQube的C, C++是商业版才有的功能，所以我使用的CE版就不支持对这两个语言的静态检查。</p><p>后来看到 <strong>SonarOpenCommunity</strong>: <a href="https://github.com/SonarOpenCommunity" target="_blank" rel="noopener">https://github.com/SonarOpenCommunity</a>，它里面有这个插件，先感谢开发者，然后再使用。</p><p>sonar-cxx: <a href="https://github.com/SonarOpenCommunity/sonar-cxx" target="_blank" rel="noopener">https://github.com/SonarOpenCommunity/sonar-cxx</a>，查看相关说明进行安装和配置。</p><p><br></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>明白哪个插件版本与当前使用的SonarQube版本监控</li><li>下载jar插件，将其放置于<code>$ SONARQUBE_HOME/extensions/plugins</code>目录下<ul><li><code>sonar-cxx-plugin-x.y.z.jar</code>: c++ plug-in</li><li><code>sonar-c-plugin-x.y.z.jar</code>: c plug-in</li></ul></li><li>重启SonarQube Server</li><li>在UI上的Marketplace查看更新</li></ul><p><br><br><br><br><br></p><h2 id="安装PS-SQL插件"><a href="#安装PS-SQL插件" class="headerlink" title="安装PS/SQL插件"></a>安装PS/SQL插件</h2><p>由于SonarQube的PL, SQL是商业版才有的功能，所以我使用的CE版就不支持对这两个语言的静态检查。</p><p>后来看到: sonar-plsql: <a href="https://github.com/felipebz/sonar-plsql" target="_blank" rel="noopener">https://github.com/felipebz/sonar-plsql</a> 社区开源项目，先感谢开发者，再使用。</p><p>安装方法与上面的C/C++一样，下载当前版本支持的插件到对应目录，重启SonarQube Server。</p><p><br><br><br><br><br></p><h2 id="将Server安装为集群"><a href="#将Server安装为集群" class="headerlink" title="将Server安装为集群"></a>将Server安装为集群</h2><p>docs: <a href="https://docs.sonarqube.org/latest/setup/install-cluster/" target="_blank" rel="noopener">https://docs.sonarqube.org/latest/setup/install-cluster/</a></p><p>先跳过！</p><p><br><br><br><br><br></p><h2 id="配置和操作集群"><a href="#配置和操作集群" class="headerlink" title="配置和操作集群"></a>配置和操作集群</h2><p>Configure &amp; Operate a Cluster</p><p>docs: <a href="https://docs.sonarqube.org/latest/setup/operate-cluster/" target="_blank" rel="noopener">https://docs.sonarqube.org/latest/setup/operate-cluster/</a></p><p>先跳过！</p><p><br><br><br><br><br></p><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>Upgrade the Server</p><p>自动处理<code>non-LTS</code>版本的升级。但是，如果在迁移路径中有LTS版本，则必须先迁移LTS，然后再迁移到目标版本。</p><p>例如，<code>v5.1</code> -&gt; <code>v7.0</code>，迁移路径为 <code>v5.1</code> -&gt; <code>5.6.7 LTS</code> -&gt; <code>v6.7.x LTS</code> -&gt; <code>v7.0</code>。</p><p><br></p><h3 id="如何升级"><a href="#如何升级" class="headerlink" title="如何升级"></a>如何升级</h3><p>在开始之前，请备份SnarQube Database。升级问题虽然很少见，但备份确实必须的。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="分析源代码"><a href="#分析源代码" class="headerlink" title="分析源代码"></a>分析源代码</h1><p>Analyzing Source Code</p><p><br></p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>一旦安装了SonarQube平台，你就可以安装分析器(analyzer)并开始创建项目了。为此，你必须安装和配置适合你需求的扫描器(scanner)。<br>Do you build with:</p><ul><li><strong>Gradle</strong> - <a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+Gradle" target="_blank" rel="noopener">SonarScanner for Gradle</a></li><li><strong>MSBuild</strong> - <a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild" target="_blank" rel="noopener">SonarScanner for MSBuild</a></li><li><strong>Maven</strong> - <a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+Maven" target="_blank" rel="noopener">use the SonarScanner for Maven</a></li><li><strong>Jenkins</strong> - <a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+Jenkins" target="_blank" rel="noopener">SonarScanner for Jenkins</a></li><li><strong>Azure DevOps</strong> - <a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Extension+for+VSTS-TFS" target="_blank" rel="noopener">SonarQube Extension for Azure DevOps</a></li><li><strong>Ant</strong> - <a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+Ant" target="_blank" rel="noopener">SonarScanner for Ant</a></li><li><strong>anything else (CLI)</strong> - <a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner" target="_blank" rel="noopener">SonarScanner</a></li></ul><p><strong>注意</strong>，不建议在运行SonarQube Scanner Analysis的机器上运行反病毒扫描程序，这可能会导致不可预测的行为。</p><p><br></p><h3 id="分析产生了什么"><a href="#分析产生了什么" class="headerlink" title="分析产生了什么"></a>分析产生了什么</h3><p>What does analysis produce?</p><p>SonarQube可以对20多种不同的语言进行分析。该分析的结果是 quality measures 和 issues。但是，分析的结果也会因语言而异:</p><ul><li>在所有语言中，<strong>blame</strong>数据将自动从支持的SCM提供程序导入(自动支持Git和SVN)。其它提供需要额外的插件</li><li>在所有语言中，执行源代码的静态分析</li><li>可对某些语言执行编译代码的静态分析</li><li>可对某些语言执行代码的动态分析</li></ul><p><br><br><br></p><h3 id="是否会分析所有文件"><a href="#是否会分析所有文件" class="headerlink" title="是否会分析所有文件"></a>是否会分析所有文件</h3><p>Will all files be analyzed?</p><p>默认情况下，在分析期间，只有语言分析器(language analyzer)可识别的文件才会加载到项目中。</p><p><br><br><br></p><h3 id="分析期间会发生什么"><a href="#分析期间会发生什么" class="headerlink" title="分析期间会发生什么"></a>分析期间会发生什么</h3><p>What happens during analysis?</p><p>在分析期间，从Server请求数据，分析提供给分析的文件，并以报告的形式将结果返回到Server，然后在Server-Side异步分析。</p><p>分析上报排队并按顺序处理，因此很可能在分析日志显示完成后的短暂时间内，更新的值在SonarQube项目中不可见。但是，你能够分辨出正在发生的事情，因为项目名称右侧的项目主页上会有一个图标。</p><p><img src="/images/SonarQube/backgroundTaskProcessingInProgress.jpeg" alt></p><p><img src="/images/SonarQube/backgroundTaskProcessingFailedIcon.jpeg" alt></p><p><br><br><br><br><br></p><h2 id="分析参数"><a href="#分析参数" class="headerlink" title="分析参数"></a>分析参数</h2><p>Analysis Parameters</p><p>可以在多个位置设置用于配置项目分析的参数。这是参数的层次结构：</p><ul><li>在UI里定义的<strong>全局分析参数(Global)</strong>，<code>Administration &gt; Configuration &gt; General Settings</code></li><li>在UI里定义的<strong>项目分析参数(Project)</strong>，<code>Project Level &gt; Administration &gt; General Settings</code></li><li>在项目分析配置文件或分析器配置文件中定义的<strong>项目分析参数</strong></li><li><strong>分析/命令行参数</strong>，再启动分析时定义，覆盖项目分析参数</li></ul><p>注意，只有通过UI设置的参数才会存储在数据库中。</p><p><br></p><h3 id="强制参数"><a href="#强制参数" class="headerlink" title="强制参数"></a>强制参数</h3><p>Mandatory Parameters</p><p><br></p><ul><li><strong>Server</strong></li></ul><div class="table-container"><table><thead><tr><th>Key</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>sonar.host.url</code></td><td>the server URL</td><td><code>http://localhost:9000</code></td></tr></tbody></table></div><p><br></p><ul><li><strong>Project Configuration</strong></li></ul><div class="table-container"><table><thead><tr><th>Key</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>sonar.projectKey</code></td><td>The project’s unique key. Allowed characters are: letters, numbers, - , _ , . and : , with at least one non-digit.</td><td>For Maven projects, this is automatically set to <code>&lt;groupId&gt;:&lt;artifactId&gt;</code></td></tr><tr><td><code>sonar.sources</code></td><td>Comma-separated paths to directories containing source files.</td><td>Read from build system for Maven, Gradle, MSBuild projects</td></tr></tbody></table></div><p><br><br><br></p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>Optional Parameters</p><ul><li><strong>Project Identity</strong></li></ul><div class="table-container"><table><thead><tr><th>Key</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>sonar.projectName</code></td><td>显示在Web实例上的项目名称</td><td>Maven项目的<code>&lt;name&gt;</code>，否则为项目密钥。如果DB中已有名称，则不会覆盖该名称</td></tr><tr><td><code>sonar.projectVersion</code></td><td>项目版本</td><td>Maven项目的<code>&lt;version&gt;</code>，否则未提供</td></tr></tbody></table></div><p><br></p><ul><li><strong>Authentication</strong></li></ul><div class="table-container"><table><thead><tr><th>Key</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>sonar.login</code></td><td>具有项目执行分析权限的SonarQube用户的登录或身份验证Token</td><td>xxx</td></tr><tr><td><code>sonar.password</code></td><td>与<code>sonar.login</code>用户名一起使用的密码。如果正在使用身份验Token，则应将此项留空</td><td>xxx</td></tr></tbody></table></div><p><br></p><ul><li><strong>Web Services</strong></li></ul><div class="table-container"><table><thead><tr><th>Key</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>sonar.ws.timeout</code></td><td>等待Web服务调用响应的最长时间（秒）。只有在等待服务器响应Web服务调用时在分析期间遇到超时时，才能从默认值修改此值。</td><td>60</td></tr></tbody></table></div><p><br></p><ul><li><strong>Project Configuration</strong></li></ul><div class="table-container"><table><thead><tr><th>Key</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>sonar.projectDescription</code></td><td>项目描述。与Maven不兼容</td><td><code>&lt;description</code>用于Maven项目</td></tr><tr><td><code>sonar.links.homepage</code></td><td>项目主页，与Maven不兼容</td><td><code>&lt;url&gt;</code>用于Maven项目</td></tr><tr><td><code>sonar.links.ci</code></td><td>CI，与Maven不兼容</td><td><code>&lt;ciManagement&gt;&lt;url&gt;</code>用于Maven项目</td></tr><tr><td><code>sonar.links.issue</code></td><td>Issue tracker，与Maven不兼容</td><td><code>&lt;issueManagement&gt;&lt;url&gt;</code>用于Maven项目</td></tr><tr><td><code>sonar.links.scm</code></td><td>项目原仓库，与Maven不兼容</td><td><code>&lt;scm&gt;&lt;url&gt;</code>用于Maven项目</td></tr><tr><td><code>sonar.links.scm_dev</code></td><td>开发者连接，与Maven不兼容</td><td><code>&lt;scm&gt;&lt;developerConnection&gt;</code>用于Maven项目</td></tr><tr><td><code>sonar.tests</code></td><td>包含测试的目录的逗号分隔路径,与Maven不兼容</td><td>Maven项目的默认测试位置</td></tr><tr><td><code>sonar.sourceEncoding</code></td><td>源文件编码</td><td>系统编码</td></tr><tr><td><code>sonar.externalIssuesReportPaths</code></td><td>以逗号分隔的通用Issue上报路径列表</td></tr><tr><td><code>sonar.projectDate</code></td><td>为分析指定日期(yyyy-MM-dd)</td><td>当前日志</td></tr><tr><td><code>sonar.projectBaseDir</code></td><td>当您需要在除启动它之外的目录中进行分析时，请使用此属性</td><td>xxx</td></tr><tr><td><code>sonar.working.directory</code></td><td>设置使用SonarScanner或SonarScanner for Ant（版本大于2.0）触发的分析的工作目录</td><td><code>.sonar</code></td></tr><tr><td><code>sonar.scm.provider</code></td><td>此属性可用于明确告知SonarQube应使用哪个SCM插件来获取项目上的SCM数据</td><td>xxx</td></tr><tr><td><code>sonar.scm.forceReloadAll</code></td><td>默认情况下，仅检索已更改文件的blame信息。将此属性设置为true可加载所有文件的blame信息</td><td>xxx</td></tr><tr><td><code>sonar.coverage.jacoco.xmlReportPaths</code></td><td>导入以XML文件形式提供的JaCoCo代码覆盖率报告。此属性接受多个逗号分隔的条目。必须在分析之前生成JaCoCo XML报告</td><td><code>target/site/jacoco/jacoco.xml</code> <br> <code>build/reports/jacoco/test/jacocoTestReport.xml</code></td></tr></tbody></table></div><p><br></p><ul><li><strong>Duplications</strong></li></ul><div class="table-container"><table><thead><tr><th>Key</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>sonar.cpd.exclusions</code></td><td>要从复制检测中排除的以逗号分隔的文件路径模式列表</td><td>xxx</td></tr><tr><td><code>sonar.cpd.${language}.minimumtokens</code></td><td>xxx</td><td>100</td></tr><tr><td><code>sonar.cpd.${language}.minimumLines</code></td><td>如上</td><td>10</td></tr></tbody></table></div><p><br></p><ul><li><strong>Analysis Logging</strong></li></ul><div class="table-container"><table><thead><tr><th>Key</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>sonar.log.level</code></td><td>控制分析期间生成的日志级别</td><td>INFO</td></tr><tr><td><code>sonar.verbose</code></td><td>向客户端和服务器端分析日志添加更多详细信息</td><td>false</td></tr><tr><td><code>sonar.showProfiling</code></td><td>显示日志以查看分析仪花费时间的位置</td><td>false</td></tr><tr><td><code>sonar.scanner.dumpToFile</code></td><td>将指向文件的完整属性列表输出到扫描程序API，作为调试分析的方法</td><td>xxx</td></tr><tr><td><code>sonar.scanner.metadataFilePath</code></td><td>设置扫描程序写入report-task.txt文件的位置，该文件包含ceTaskId等</td><td><code>sonar.working.directory</code>的值</td></tr></tbody></table></div><p><br><br><br><br><br></p><h2 id="后台任务"><a href="#后台任务" class="headerlink" title="后台任务"></a>后台任务</h2><p>Background Tasks</p><p>一个后台任务可以是:</p><ul><li>导入一个分析报告</li><li>the computation of a Portfolio</li><li>导入或导出一个项目</li></ul><p><br></p><h3 id="扫描程序完成分析后会发生什么"><a href="#扫描程序完成分析后会发生什么" class="headerlink" title="　扫描程序完成分析后会发生什么"></a>　扫描程序完成分析后会发生什么</h3><p>What happens after the scanner is done analyzing?</p><p>在相关后台任务完成之前，分析尚未完成。即使SonarScanner的日志显示执行完成，在完成后台任务之前，分析结果在SonarQube项目中将不可见。在SonarScanner外出分析代码后，分析结果(Sources, Issues, Metrics) - 分析报告 - 将发送到SonarQube Server，一共计算引擎进行最终处理。分析报告按顺序排队和处理。</p><p>在项目级别，当有待处理的分析报告等待消耗时，标题中的<strong>Pending（待处理）</strong>通知将在最近完成的分析的日期旁。</p><p>全局管理员可在<code>Administration &gt; Projects &gt; Background Tasks</code>查看当前队列；项目管理员可在<code>Administration &gt; Background Tasks</code>查看相关任务。</p><p><br><br><br></p><h3 id="如何知道分析报告处理失败的时间"><a href="#如何知道分析报告处理失败的时间" class="headerlink" title="如何知道分析报告处理失败的时间"></a>如何知道分析报告处理失败的时间</h3><p>How do I know when analysis report processing fails?</p><p>后台任务通常会成功，但有时候异常会导致处理失败。例如:</p><ul><li>处理大项目是内存不足(OOM)</li><li>现有模块或项目的密钥与报告中的密钥冲突</li><li>…</li></ul><p>当发生这种情况时，失败的状态会反映在项目主页上，但这需要有人注意到它。你还可以选择在后台任务失败时通过电子邮件接收通知(Notifications)——无论是逐个还是全局。</p><p><br><br><br></p><h3 id="如何诊断失败的后台任务"><a href="#如何诊断失败的后台任务" class="headerlink" title="如何诊断失败的后台任务"></a>如何诊断失败的后台任务</h3><p>How do I diagnose a failing background task?</p><p>对于没法分析报告，都有一个下拉菜单，允许你访问<strong>扫描程序上下文(Scanner Context)</strong>，显示代码扫描是扫描程序的配置。<br>如果任务处理失败，则可使用其它选项<strong>显示错误详细信息(Show Error Details)</strong>，以获取处理后台任务失败的详情。</p><p><br><br><br></p><h3 id="如何取消待处理的分析报告"><a href="#如何取消待处理的分析报告" class="headerlink" title="如何取消待处理的分析报告"></a>如何取消待处理的分析报告</h3><p>How do I cancel a pending analysis report?</p><p>管理员可通过单击取消处理待处理任务(pending task)，一旦报告开始处理，取消它就为时已晚。</p><p><br><br><br><br><br></p><h2 id="通用问题数据"><a href="#通用问题数据" class="headerlink" title="通用问题数据"></a>通用问题数据</h2><p>Generic Issue Data</p><p>SonarQube支持通用导入格式，用于在代码中引发<em>external</em> issues。它旨在允许你从你喜欢的<em>linter</em>导入issues，即使它不存在插件。</p><p>外部问题受到两个重要限制:</p><ul><li>它们无法在SonarQube内管理</li><li>在SonarQube中无法管理引发这些问题的规则的激活</li></ul><p><br></p><h3 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h3><p>分析参数<code>sonar.externalIssueReportPaths</code>接受以逗号分隔的报告路径列表。<br>每个报告必须在顶层(top-level)包含一个名为issues对象的问题对象数组。</p><p><strong>Issue字段:</strong></p><ul><li><code>engineId</code> - string</li><li><code>ruleId</code> - string</li><li><code>primaryLocation</code> - Location object</li><li><code>type</code> - string. One of BUG, VULNERABILITY, CODE_SMELL</li><li><code>severity</code> - string. One of BLOCKER, CRITICAL, MAJOR, MINOR, INFO</li><li><code>effortMinutes</code> - integer, optional. Defaults to 0</li><li><code>secondaryLocations</code> - array of Location objects, optional</li></ul><p><br></p><p><strong>Location字段:</strong></p><ul><li><code>message</code> - string</li><li><code>filePath</code> - string</li><li><code>textRange</code> - TextRange object, optional for secondary locations only</li></ul><p><br></p><p><strong>TextRange字段:</strong></p><ul><li><code>startLine</code> - integer. 1-indexed</li><li><code>endLine</code> - integer, optional. 1-indexed</li><li><code>startColumn</code> - integer, optional. 0-indexed</li><li><code>endColumn</code> - integer, optional. 0-indexed</li></ul><p><br><br><br></p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><p>以下是预期格式的栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;issues&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;engineId&quot;: &quot;test&quot;,</span><br><span class="line">      &quot;ruleId&quot;: &quot;rule1&quot;,</span><br><span class="line">      &quot;severity&quot;:&quot;BLOCKER&quot;,</span><br><span class="line">      &quot;type&quot;:&quot;CODE_SMELL&quot;,</span><br><span class="line">      &quot;primaryLocation&quot;: &#123;</span><br><span class="line">        &quot;message&quot;: &quot;fully-fleshed issue&quot;,</span><br><span class="line">        &quot;filePath&quot;: &quot;sources/A.java&quot;,</span><br><span class="line">        &quot;textRange&quot;: &#123;</span><br><span class="line">          &quot;startLine&quot;: 30,</span><br><span class="line">          &quot;endLine&quot;: 30,</span><br><span class="line">          &quot;startColumn&quot;: 9,</span><br><span class="line">          &quot;endColumn&quot;: 14</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;effortMinutes&quot;: 90,</span><br><span class="line">      &quot;secondaryLocations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;message&quot;: &quot;cross-file 2ndary location&quot;,</span><br><span class="line">          &quot;filePath&quot;: &quot;sources/B.java&quot;,</span><br><span class="line">          &quot;textRange&quot;: &#123;</span><br><span class="line">            &quot;startLine&quot;: 10,</span><br><span class="line">            &quot;endLine&quot;: 10,</span><br><span class="line">            &quot;startColumn&quot;: 6,</span><br><span class="line">            &quot;endColumn&quot;: 38</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;engineId&quot;: &quot;test&quot;,</span><br><span class="line">      &quot;ruleId&quot;: &quot;rule2&quot;,</span><br><span class="line">      &quot;severity&quot;: &quot;INFO&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;BUG&quot;,</span><br><span class="line">      &quot;primaryLocation&quot;: &#123;</span><br><span class="line">        &quot;message&quot;: &quot;minimal issue raised at file level&quot;,</span><br><span class="line">        &quot;filePath&quot;: &quot;sources/Measure.java&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="通用测试数据"><a href="#通用测试数据" class="headerlink" title="通用测试数据"></a>通用测试数据</h2><p>Generic Test Data</p><p>开箱即用，SonarQube支持用于测试覆盖和测试执行导入的通用格式。如果你的语言不插件不支持你的Coverage引擎的本机输出格式，只需将它们转换为这些格式即可。</p><p><br></p><h3 id="Generic-Coverage"><a href="#Generic-Coverage" class="headerlink" title="Generic Coverage"></a>Generic Coverage</h3><p>报告路径应该以逗号分隔的列表传递给: <code>sonar.coverageReportPaths</code></p><p>支持的格式由<code>sonar-generic-coverage.xsd</code>进行描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;xs:schema&gt;</span><br><span class="line">  &lt;xs:element name=&quot;coverage&quot;&gt;</span><br><span class="line">    &lt;xs:complexType&gt;</span><br><span class="line">      &lt;xs:sequence&gt;</span><br><span class="line">        &lt;xs:element name=&quot;file&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;</span><br><span class="line">          &lt;xs:complexType&gt;</span><br><span class="line">            &lt;xs:sequence&gt;</span><br><span class="line">              &lt;xs:element name=&quot;lineToCover&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;</span><br><span class="line">                &lt;xs:complexType&gt;</span><br><span class="line">                  &lt;xs:attribute name=&quot;lineNumber&quot; type=&quot;xs:positiveInteger&quot; use=&quot;required&quot;/&gt;</span><br><span class="line">                  &lt;xs:attribute name=&quot;covered&quot; type=&quot;xs:boolean&quot; use=&quot;required&quot;/&gt;</span><br><span class="line">                  &lt;xs:attribute name=&quot;branchesToCover&quot; type=&quot;xs:nonNegativeInteger&quot;/&gt;</span><br><span class="line">                  &lt;xs:attribute name=&quot;coveredBranches&quot; type=&quot;xs:nonNegativeInteger&quot;/&gt;</span><br><span class="line">                &lt;/xs:complexType&gt;</span><br><span class="line">              &lt;/xs:element&gt;</span><br><span class="line">            &lt;/xs:sequence&gt;</span><br><span class="line">          &lt;xs:attribute name=&quot;path&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;</span><br><span class="line">          &lt;/xs:complexType&gt;</span><br><span class="line">        &lt;/xs:element&gt;</span><br><span class="line">      &lt;/xs:sequence&gt;</span><br><span class="line">      &lt;xs:attribute name=&quot;version&quot; type=&quot;xs:positiveInteger&quot; use=&quot;required&quot;/&gt;</span><br><span class="line">    &lt;/xs:complexType&gt;</span><br><span class="line">  &lt;/xs:element&gt;</span><br><span class="line">&lt;/xs:schema&gt;</span><br></pre></td></tr></table></figure><p>看起来像这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;coverage version=&quot;1&quot;&gt;</span><br><span class="line">  &lt;file path=&quot;xources/hello/NoConditions.xoo&quot;&gt;</span><br><span class="line">    &lt;lineToCover lineNumber=&quot;6&quot; covered=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;lineToCover lineNumber=&quot;7&quot; covered=&quot;false&quot;/&gt;</span><br><span class="line">  &lt;/file&gt;</span><br><span class="line">  &lt;file path=&quot;xources/hello/WithConditions.xoo&quot;&gt;</span><br><span class="line">    &lt;lineToCover lineNumber=&quot;3&quot; covered=&quot;true&quot; branchesToCover=&quot;2&quot; coveredBranches=&quot;1&quot;/&gt;</span><br><span class="line">  &lt;/file&gt;</span><br><span class="line">&lt;/coverage&gt;</span><br></pre></td></tr></table></figure><p>根节点应该命名为<code>coverage</code>，其<code>version</code>属性应设置为1。</p><p>为每个文件插入一个可由测试覆盖的文件元素。其<code>path</code>属性可以是绝对的，也可是相对的。它具有以下属性:</p><ul><li><code>lineNumber</code>(强制性)</li><li><code>covered</code>(强制性) - 布尔值，指示测试是否实际命中改行</li><li><code>branchesToCover</code>(可选) - 可覆盖的分支数量</li><li><code>coveredBranches</code>(可选) - 实际有测试覆盖的分支数量</li></ul><p><br><br><br></p><h3 id="Generic-Execution"><a href="#Generic-Execution" class="headerlink" title="Generic Execution"></a>Generic Execution</h3><p>报告路径应以逗号分隔的列表传递给: <code>sonar.testExecutionReportPaths</code></p><p>支持的格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;testExecutions version=&quot;1&quot;&gt;</span><br><span class="line">  &lt;file path=&quot;testx/ClassOneTest.xoo&quot;&gt;</span><br><span class="line">    &lt;testCase name=&quot;test1&quot; duration=&quot;5&quot;/&gt;</span><br><span class="line">    &lt;testCase name=&quot;test2&quot; duration=&quot;500&quot;&gt;</span><br><span class="line">      &lt;skipped message=&quot;short message&quot;&gt;other&lt;/skipped&gt;</span><br><span class="line">    &lt;/testCase&gt;</span><br><span class="line">    &lt;testCase name=&quot;test3&quot; duration=&quot;100&quot;&gt;</span><br><span class="line">      &lt;failure message=&quot;short&quot;&gt;stacktrace&lt;/failure&gt;</span><br><span class="line">    &lt;/testCase&gt;</span><br><span class="line">    &lt;testCase name=&quot;test4&quot; duration=&quot;500&quot;&gt;</span><br><span class="line">      &lt;error message=&quot;short&quot;&gt;stacktrace&lt;/error&gt;</span><br><span class="line">    &lt;/testCase&gt;</span><br><span class="line">  &lt;/file&gt;</span><br><span class="line">&lt;/testExecutions&gt;</span><br></pre></td></tr></table></figure><p>根节点应该被命名为<code>testExecutions</code>，它的<code>version</code>属性应该被设置成1。<br>为每个测试文件插入一个文件元素，其<code>path</code>属性可以是绝对的，也可是相对于模块的根。</p><p>注意，与覆盖率报告不同，报告中的文件必须是测试文件名，而不是测试所涵盖的源代码文件。</p><p>在<code>file</code>元素内，通过单元测试为每个测试运行插入一个<code>testCase</code>。它具有以下属性/子项:</p><ul><li><code>testCase</code>（强制性）<ul><li><code>name</code>（强制性）: 测试事例的名称</li><li><code>duration</code>(强制性): long value，ms为单位</li><li><code>failure|error|skipped</code>(可选): 如果测试不正确，请使用消息和长描述报告原因</li><li><code>message</code>(强制): 描述原因的短消息</li><li><code>stacktrace</code>（可选）: 包含有关失败、错误、跳过状态的详细信息</li></ul></li></ul><p><br><br><br><br><br></p><h2 id="PR分析"><a href="#PR分析" class="headerlink" title="PR分析"></a>PR分析</h2><p>Pull Request Analysis</p><p>PR分析是作为Developer Edtion的一部分提供。它允许你:</p><ul><li>在SonarQube UI中查看你的PR分析结果并查看状态以显示存在未解决的问题</li><li>在你的SCM提供商界面中使用SonarQube issue自动装饰你的PR</li></ul><p>从项目的<strong>branch and pull request</strong>的下拉菜单中可以在SonarQube中看到PR。启用PR装饰后，SonarQube会在PR上发布分析状态。</p><p><br><br><br><br><br></p><h2 id="SCM集成"><a href="#SCM集成" class="headerlink" title="SCM集成"></a>SCM集成</h2><p>在代码分期期间收集SCM数据可以解锁许多SonarQube功能:</p><ul><li>自动Issue分配</li><li>代码查看器中查看代码注释</li><li>SCM-driver的新代码检测，没有SCM数据，SonarQube使用分析日期确定新代码</li></ul><p>SCM集成需要你的SCM提供商，默认情况下支持SVN和Git。其它提供商，请参阅Marketplace。<br>如果需要，你可以通过管理设置将其在全局/项目级别将其关闭。</p><p><br></p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p><br><br><br></p><h3 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h3><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Branches"><a href="#Branches" class="headerlink" title="Branches"></a>Branches</h1><p>分支分析作为Developer Editon的一部分提供。分支分析允许你:</p><ul><li>分析 long-lived branches</li><li>分析 short-lived branches</li><li>在短期分支的状态受到影响时通知外部系统</li></ul><p><br></p><p>由于分支功能是开发版(也就是付费版)功能，因此社区版只能对每个分支创建一个项目。</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">repo: zhang-repo</span><br><span class="line"></span><br><span class="line">branch:</span><br><span class="line">  - master</span><br><span class="line">  - test</span><br><span class="line">  - zhang</span><br><span class="line"></span><br><span class="line">projects:</span><br><span class="line">  - zhang-repo-master</span><br><span class="line">  - zhang-repo-test</span><br><span class="line">  - zhang-repo-zhang</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="用户指南"><a href="#用户指南" class="headerlink" title="用户指南"></a>用户指南</h1><p>User Guide</p><p><br></p><h2 id="修复漏水"><a href="#修复漏水" class="headerlink" title="修复漏水"></a>修复漏水</h2><p>Fixing the Water Leak</p><p><br></p><h3 id="什么是漏水"><a href="#什么是漏水" class="headerlink" title="什么是漏水"></a>什么是漏水</h3><p>What is the Water Leak</p><p>想象一下，有一天你回到家发现厨房地板上有一滩水，水慢慢变大。<br>你想去拿拖把？还是找到漏水源头并修复它？选择很明显，你得修复它。</p><p>那么为什么与代码质量(code quality)有什么不同呢？当你使用SonarQube分析应用程序并意识到它有很多技术债务(technical debt)，这种下意识的反应通常是开始修复-这样那样，要么整理一个补救计划。这就像每天拖地一次而却忽略了漏水源头一样。</p><p><br></p><p>通常在这种传统方法中，在发布版本之前，定期进行代码质量(code quality)审计结果是开发人员在发布之前应该采取的行动。这种方法可能在短期内有效，特别是在强有力的管理支持下，但在中长期内始终失败，因为:</p><ul><li>代码审查(code review)过程太迟，没有利益相关者热衷于解决问题，每个人都希望新版本发布</li><li>开发者通常会推迟不了解项目上下文的外部团队提出的建议。顺便提一下，正在审查的代码已经过时了</li><li>使用这种方法明显缺乏对代码质量的所有权。谁拥有质量审查权限？没有人</li><li>在整个应用程序投入生产之前，需要检查整个应用程序，显然不可能对所有应用程序使用相同的标准。每个项目都会进行谈判，这将耗尽整个过程的可信度</li></ul><p><br></p><p>相反，为什么不将你在家中使用的相同的简单逻辑应用于管理代码质量的方式？修复泄露(leak)意味着将重点放在<strong>新代码</strong>上，即自上次发布以来添加或更改的代码。然后事情就变得很容易了:</p><ul><li>Quality Gate可以每天运行，并且可通过它。发版时没有任何意外</li><li>开发人员很难回避他们前一天介绍的问题。相反，他们通常很乐意在代码仍然新鲜时修复问题</li><li>代码质量有明确的所有权</li><li>做不做的标准在不同的应用程序中是一致的，并且在团队之间共享</li><li>成本微不足道，因为它是开发过程中的一部分</li></ul><p>最为奖励，变化最大的代码具有最高的可维护性，并且未变更的代码具有最低的维护性，这很有意义。</p><p><br><br><br></p><h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><p>SonarQube提供两种主要工具来帮助你找到泄漏点:</p><ul><li>新代码指标(metrics)显示当前代码与你在其历史记录(<code>previous_version</code>)中选择的特定点之间的度量差异</li><li>新代码主要基于SCM blame 数据监测，从新代码期(泄漏期)的第一次分析开始，需要时使用回退机制</li><li>Quality Gates允许你设置测量代码的布尔阈值。将它们与差异指标一起使用，可确保你的代码质量随着时间的推移在正确的方向上行驶</li></ul><p><br><br><br><br><br></p><h2 id="项目页"><a href="#项目页" class="headerlink" title="项目页"></a>项目页</h2><p>Project Page</p><p>项目主页(Project Homepage)是任何项目的切入点，它显示:</p><ul><li>the releasability status of the project</li><li>the current state of its quality</li><li>the quality of what has been produced since the beginning of its New Code Period</li></ul><p>项目页面回答了两个问题:</p><ul><li>can I release my project today?</li><li>if not, what should I improve to make the project pass the Quality Gate?</li></ul><p><br></p><h3 id="今天能发版吗"><a href="#今天能发版吗" class="headerlink" title="今天能发版吗"></a>今天能发版吗</h3><p>Can I release today?</p><p>由于 Quality Gate 是你执行质量策略的最强大的工具，因此该页面以项目的当前质量门状态开始。如果项目通过，则会显示一个简单的绿色全清除。</p><p>如果没有，可立即获得详细信息和drill-downs，以便快速识别出错的地方，每个错误条件的一个部分显示当前项目值是什么以及它应该是什么。像往常一样，你可以点击当前值来进行深入分析。</p><p><br><br><br></p><h3 id="应该优先解决什么"><a href="#应该优先解决什么" class="headerlink" title="应该优先解决什么"></a>应该优先解决什么</h3><p>What should I fix first?</p><p>因为提高项目质量的最佳方法是在问题变得根深蒂固之前捕获并修复新问题，项目的第一个视图以新代码周期为中心，在项目主页右侧以黄色突出显示。项目空间页面显示关键指标的高级摘要，包括当前值和新代码周期值。</p><p>在Quality Gate信息的下方，可以获得可靠性和安全域中的旧问题和新问题的数量。然后是可维护性域。单击页面上的任何图形将转到“详细信息”页面或“问题”页面中的详细视图。</p><p>开发人员必须做的最重要的事情是确保屏幕黄色部分的新问题得到确认，审核和修复，并确保测试涵盖新代码以防止将来出现回归。无论过去引入了多少问题，或者总体上测试覆盖范围有多少，关注新增问题将确保情况不会降低您之前在生产中发布的版本。</p><p>那么，您应该先找到哪些问题：错误，漏洞或代码异味？这取决于，因为答案取决于您的问题的性质。假设你有一个重复5次的代码块问题，在这个重复的代码块中，你有3个Bug和5个安全问题。最好的方法可能是首先修复重复，然后解决新集中位置的错误和漏洞，而不是修复它们5次。<br>这就是为什么您需要在开始解决之前检查新问题。</p><p><br><br><br><br><br></p><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>Applications are available as part of the Enterprise Edition.</p><p><br><br><br><br><br></p><h2 id="Portfolios"><a href="#Portfolios" class="headerlink" title="Portfolios"></a>Portfolios</h2><p>Portfolios are available as part of the Enterprise Edition.</p><p><br><br><br><br><br></p><h2 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h2><p>在运行分析时，每当一段代码破坏编码规则时，SonarQube就会引发一个issue。编码规则(coding rules)是通过每种语言的相关质量配置文件定义的。</p><p>每个问题有五种严重程度:</p><ul><li><strong>BLOCKER</strong> - 很有可能影响生产中应用程序行为的错误。必须立即修复</li><li><strong>CRITICAL</strong> - 要么是在生产环境中影响应用程序行为可能性很小的bug，要么是代表安全漏洞的问题。必须立即检查代码</li><li><strong>MAJOR</strong> - 可能严重影响开发人员生产力的质量缺陷</li><li><strong>MINOR</strong> - 会轻微影响开发人员生产力产生的质量缺陷</li><li><strong>INFO</strong> - 既不是错误，也不是质量缺陷，只是一个提示</li></ul><p><br></p><h3 id="理解issue上下文"><a href="#理解issue上下文" class="headerlink" title="理解issue上下文"></a>理解issue上下文</h3><p>Understanding issue context</p><p>有时，一旦指出问题，问题就不言而喻了。例如，你的团队已约定了变量命名规则，在某个变量名出线问题时，你不需要理解大量上下文来理解该问题。但在其它情况下，上下文可能对理解为什么会出现这个问题至关重要。这就是为什么SonarQube不仅支持显示问题消息的主要问题位置，还支持次要问题位置。</p><p>但有时候，贡献位置地点并不足以理解问题。例如，当通过代码在某些路径上取消引用空指针时，您真正需要的是问题流。每个流程都是一组辅助位置，用于显示可能发生问题的代码的确切路径。</p><p><br><br><br></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Lifecycle of Code Smell, Bug, and Vulnerability Issues</p><p><br></p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>Status</p><p>创建之后，Issue会在生命周期中流动，可能为以下五种状态之一:</p><ul><li><strong>打开(Open)</strong> - 由SonarQube在新问题上设定</li><li><strong>确认(Confirmed)</strong> - 手动确认以指示问题有效</li><li><strong>解决(Resolved)</strong> - 手动设置以指示下一个分析应该关闭改问题</li><li><strong>重开(Reopened)</strong> - 当一个已解决的问题实际上没有得到纠正时，SonarQube会自动设置</li><li><strong>关闭(Closed)</strong> - 有SonarQube自动设置自动创建的问题</li></ul><p><br><br><br></p><h4 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h4><p>Resolutions</p><p>已关闭的问题将有一下两种方式之一:</p><ul><li><strong>已修复(Fixed)</strong> - 当后续分析显示问题已更正或文件不再可用时自动设置</li><li><strong>已移除(Removed)</strong> - 当相关规则不再可用时自动设置。改规则可能无法使用，因为它已从质量配置文件中删除，或者因为已卸载基础插件</li></ul><p>Resolved issues好友两个处理方式:</p><ul><li><strong>误判(False Positive)</strong> - 手动设置</li><li><strong>不会修复(Won’t Fix)</strong> - 不会修复</li></ul><p><br><br><br></p><h4 id="问题工作流程"><a href="#问题工作流程" class="headerlink" title="问题工作流程"></a>问题工作流程</h4><p>Issue Workflow</p><p>在以下情况下，问题会自动关闭(Status: Closed):</p><ul><li>问题以正确修复（Resolution: Fixed）</li><li>问题不再存在，因为相关编码规则已停用或不再可用(Resolution: Removed)</li></ul><p>在以下情况下，问题会自动重新打开(Status: Reopened):</p><ul><li>手动修改解决方式为已修复(但是不是误判)的问题，有后续分析显示仍然存在</li></ul><p><br><br><br></p><h3 id="安全热点问题的生命周期"><a href="#安全热点问题的生命周期" class="headerlink" title="安全热点问题的生命周期"></a>安全热点问题的生命周期</h3><p>Lifecycle of Security Hotspot Issues</p><p>安全热点问题具有专用的生命周期。它们不被视为可操作，必须由具有相关权限的用户进行审核。</p><p>创建之后，安全热点问题将流经专用的生命周期，可能是以下四种状态之一:</p><ul><li><strong>Open</strong> - 由SonarQube在新问题上自动设置</li><li><strong>Resolved</strong>(Won’t Fix) - 当安全审核员接受开发人员针对手动漏洞所做的修复或安全审核员清楚打开的热点或手动漏洞时，SonarQube会自动设置</li><li><strong>To Revied</strong> - 当开发人员请求安全审核员查看他对手动漏洞所做的修复时自动设置</li><li><strong>Reopened</strong> - 当开发人员解除打开的手动漏洞或安全审计员手动重新打开问题以便对已解决的问题运行新审计时设置</li></ul><p>如果删除了包含安全热点的代码，则只会关闭安全热点问题。如果从项目的质量配置文件中删除了标识热点的规则，则安全热点也可能会被删除。</p><p><br><br><br></p><h3 id="理解哪些问题是新的"><a href="#理解哪些问题是新的" class="headerlink" title="理解哪些问题是新的"></a>理解哪些问题是新的</h3><p>Understanding which Issues are “New”</p><p>为了确定问题的创建日期，在每次分析期间执行算法已确定问题是新的还是之前存在的。此算法依赖于报告问题的行的内容的哈希值(不包括空格)。对于多行问题，使用第一行的哈希值。对于每个文件(在检测到文件重命名后)，算法将从先前的分析中获取问题的基本列表，并尝试将这些问题与新分析报告的原始问题列表进行匹配。该算法尝试使用最强的证据进行首次匹配，然后再回到较弱的启发式算法。</p><ul><li>如果问题是在同一规则上，具有相同的行号和相同的行哈希 - 匹配</li><li>检测到块在文件内移动，然后如果问题出在同一行(移动的)和同一条规则上- 匹配</li><li>在相同的规则上，使用相同的消息并使用相同的行哈希 - 匹配</li><li>在相同的规则上，使用相同的消息并使用相同的行号 - 匹配</li><li>在相同的规则上，使用相同的行哈希 - 匹配</li><li>是否有匹配CLOSED的问题 - 匹配和重新打开</li></ul><p><br><br><br></p><h3 id="了解问题回溯"><a href="#了解问题回溯" class="headerlink" title="了解问题回溯"></a>了解问题回溯</h3><p>Understanding Issue Backdating</p><p>一旦问题被确定为新，下一个问题便是提供它的日期。例如，如果它已经在代码中存在了很长时间，但只能在最近的分析中找到，因为新的规则被添加到配置文件中？该问题是否应该在其行的最后一次更改日期或首次提出的分析日期之间给出？那就是它应该回溯吗？</p><p>如果最后一次更改改行的日期可用，那么在某些情况下，该问题将被回溯:</p><ul><li>首先分析项目或分支</li><li>当配置文件中的规则为新时</li><li>当分析程序升级后</li><li>当规则是外部的</li></ul><p>因此，回溯可能会使新提出的问题原理New Code Period。</p><p><br><br><br></p><h3 id="自动问题分配"><a href="#自动问题分配" class="headerlink" title="自动问题分配"></a>自动问题分配</h3><p>Automatic Issue Assignment</p><ul><li>For Bug, Vulnerability and Code Smell</li><li>For Security Hotspot</li><li>User Correlation</li><li>Known Limitation</li></ul><p><br><br><br></p><h3 id="问题编辑"><a href="#问题编辑" class="headerlink" title="问题编辑"></a>问题编辑</h3><p>Issue edits</p><p>SonarQube的问题工作流程可帮助你管理问题。你可对一个Issue做七件不同事情，这些行为可分为三类:</p><ul><li>Technical Review<ul><li>Confirm</li><li>False Positive</li><li>Won’t Fix</li><li>Severity change</li><li>Resolve</li></ul></li><li>Security Hotspots<ul><li>Detect</li><li>Clear</li><li>Request Review</li><li>Reject</li></ul></li><li>Dispositioning</li><li>General<ul><li>Comments</li><li>Tag</li></ul></li><li>Bulk Change</li></ul><p><br><br><br></p><h3 id="清除已解决的问题"><a href="#清除已解决的问题" class="headerlink" title="清除已解决的问题"></a>清除已解决的问题</h3><p>Purging Closed Issues</p><p>默认情况下，已关闭的问题将保留30天。当然，你也可以修改它。</p><p><br><br><br><br><br></p><h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><p>SonarSource Rules: <a href="https://rules.sonarsource.com/" target="_blank" rel="noopener">https://rules.sonarsource.com/</a></p><p><br></p><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>在SonarQube中，分析程序提供在源代码上执行的规则来生成问题。有四种类型的规则:</p><ul><li>Code Smell (Maintainability domain)</li><li>Bug (Reliability domain)</li><li>Vulnerability (Security domain)</li><li>Security Hotspot (Security domain)</li></ul><p><br><br><br></p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>默认情况下，点击带单栏<strong>Rules</strong>时，你将看到SonarQube实例上安装的分析程序带来的所有可用规则。你可根据以下条件缩小范围:</p><ul><li>Language</li><li>Type</li><li>Tag</li><li>Repository</li><li>Default Severity</li><li>Status</li><li>Available Since</li><li>Template: 显示允许创建自定义规则的规则模板</li><li>Quality Profile</li></ul><p><br><br><br></p><h3 id="规则细节"><a href="#规则细节" class="headerlink" title="规则细节"></a>规则细节</h3><p>要查看规则的详细信息，请点击它。除了基本规则数据之外，您还可以查看其中活动的配置文件（如果有）以及已经引发了多少未解决的问题。<br>只有拥有正确的权限时，才能使用以下两个操作:</p><ul><li>Add/Remove Tags</li><li>Extend Description</li></ul><p><br><br><br></p><h3 id="规则模板和自定义规则"><a href="#规则模板和自定义规则" class="headerlink" title="规则模板和自定义规则"></a>规则模板和自定义规则</h3><p>Rule Templates and Custom Rules</p><p>规则模板(Rule templates)由创建提供，允许用户在SonarQube中定义自己的规则。它位于<code>Rules -&gt; Template</code>。</p><p>要从模板创建自定义规则，你必须填写一下信息:</p><ul><li>Name</li><li>Key (auto-suggested)</li><li>Description (Markdown format is supported)</li><li>Default Severity</li><li>Status</li><li>The parameters specified by the template</li></ul><p><br><br><br></p><h3 id="扩展编码规则"><a href="#扩展编码规则" class="headerlink" title="扩展编码规则"></a>扩展编码规则</h3><p>Extending Coding Rules</p><p>可以添加<a href="https://docs.sonarqube.org/display/DEV/Adding+Coding+Rules" target="_blank" rel="noopener">自定义编码规则</a>。</p><p><br><br><br></p><h3 id="规则类型和严重性"><a href="#规则类型和严重性" class="headerlink" title="规则类型和严重性"></a>规则类型和严重性</h3><p>Rule Types and Severities</p><p>Type:</p><ul><li>Bug</li><li>Vulnerability</li><li>Code Smell</li><li>Security Hotspot</li></ul><p>Severity:</p><ul><li>Blocker</li><li>Critical</li><li>Major</li><li>Minor</li><li>Info</li></ul><p><br><br><br></p><h2 id="安全相关的规则"><a href="#安全相关的规则" class="headerlink" title="安全相关的规则"></a>安全相关的规则</h2><p>Security-related Rules</p><p>SonarQube质量类型有三种不同的规则:</p><ul><li>Reliability (bug)</li><li>Vulnerability (security)</li><li>Maintainability (code smell)</li></ul><p>但另外一种方式，只有两种类型:</p><ul><li>security rule</li><li>其它</li></ul><p>两者之间的区别并不在它们捕获的内容，而在于她们来自何处以及强加于它们的标准。</p><p><br></p><h3 id="从安全相关的规则的期望是什么"><a href="#从安全相关的规则的期望是什么" class="headerlink" title="从安全相关的规则的期望是什么"></a>从安全相关的规则的期望是什么</h3><p>What to expect from security-related rules</p><p>需要明确的是，SonarQube语言插件中实现的大多数规则的标准是非常严格: 没有误报。对于正常规则，你应该能够确信任何报告给你的问题确实是一个问题。</p><p>但对于与安全相关的规则，情况略有不同。例如，许多安全指南讨论了应如何处理<em>敏感数据</em>。但是，由于规则中不可能确定哪些数据是敏感，哪些是不敏感。因此选择变为： 保持无误判标准并且不实施与安全相关的规则，或者实施与安全的规则不同的标准。</p><p>这就是为什么与安全相关的规则很广泛。官方的想法是，该规则将标记任何可疑的内容，并将其留给安全审核人员来剔除误报并发送真正的问题进行补救。</p><p>安全热点是一种特殊类型的问题，用于识别安全审核人员应审核的敏感区域，以确定它们是否真的是漏洞。有关热点和审计过程的详细信息，请参阅安全审核和报告。</p><p><br><br><br></p><h3 id="与安全相关的规则来自何方"><a href="#与安全相关的规则来自何方" class="headerlink" title="与安全相关的规则来自何方"></a>与安全相关的规则来自何方</h3><p>Where security-related rules come from</p><p>绝大多数与安全相关的规则源于既定标准:</p><ul><li><strong>CWE(Common Weakness Enumeration)</strong>：是美国MITRE机构提出的一套语言标准，用于描述软件安全弱点的通用化描述语言。每个CWE条目都包含了CWE标识符/弱点类型名称、类型的描述、弱点的行为、弱点的利用方法、利用弱点的可能性、可能导致的后果、应对措施、代码示例、对应的CVE漏洞数量、参考信息等内容。</li><li><strong>SANS Top 25</strong> - <a href="https://www.sans.org/top25-software-errors/" target="_blank" rel="noopener">CWE/SANS TOP 25 Most Dangerous Software Errors</a></li><li><strong>OWASP Top 10</strong> - <a href="https://www.owasp.org/index.php/Top_10-2017_Top_10" target="_blank" rel="noopener">OWASP Top 10 Application Security Risks</a></li></ul><p>要查找与任何这些标准相关的规则，你可以按标签或文本搜索规则。</p><p><br></p><h4 id="CWE"><a href="#CWE" class="headerlink" title="CWE"></a>CWE</h4><p>CWE标准代表Common Weakness Enumeration:</p><p>Common Weakness Enumeration (CWE™) 是一个常见软件弱点的正式列表或字典，可能出现在软件的体系结构、设计代码或实现中。可能导致可利用的安全漏洞。创建CWE是为了描述软件安全漏洞的通用语言，作为针对这些弱点的软件安全工具的衡量标准；并为弱点识别、缓解和预防工作提供共同的基线标准。<br>CWE是弱化的描述的层次结构。层次结构中的最低级别是弱点基础(Weakness Base)，它描述了细腻度的弱点。</p><p>符合特定要求的工具可以认证为CWE兼容。这些要求是:</p><ul><li>您必须能够使用CWE标识符搜索与CWE相关的规则。要在SonarQube平台中执行此操作，只需将CWE标识符（例如CWE-595）放在规则页面上的搜索文本输入中并运行搜索</li><li>规则必须与其相关的CWE项目准确链接。要查看SonarQube规则的CWE映射，请参阅规则说明底部的规则参见部分</li><li>您必须能够从问题中识别相关的CWE。要在SonarQube平台中执行此操作，请参阅相关规则</li><li>产品文档必须包含CWE和CWE兼容性的说明</li><li>除了通过CWE id搜索规则外，您还可以通过 cwe rule tag 进行搜索</li></ul><p><br><br><br></p><h4 id="SANS-TOP-25"><a href="#SANS-TOP-25" class="headerlink" title="SANS TOP 25"></a>SANS TOP 25</h4><p>SANS Top 25列表是由SANS组织编制的CWE中列出的25个最危险错误的集合。当前的SANS列表分为三类：</p><ul><li>Insecure Interaction Between Components</li><li>Risky Resource Management</li><li>Porous Defenses</li></ul><p>要查找与SANS Top 25相关的规则，您可以对类别或相关CWE项目执行文本搜索，或执行规则标记搜索。</p><p><br><br><br></p><h4 id="OWASP-Top-10"><a href="#OWASP-Top-10" class="headerlink" title="OWASP Top 10"></a>OWASP Top 10</h4><p>OWASP代表Open Web Application Security Project。它是:</p><p><code>501(c)(3)</code>全球非营利慈善组织，致力于提高软件的安全性。我们的使命是使软件安全可见，以便全世界的个人和组织能够就真正的软件安全风险做出明智的决策。</p><p>OWASP Top 10列出了各种各样的弱点，每个弱点都可以映射到许多单独的规则。<br>OWASP TOP 10在SonarQube中也对应相关的tag。</p><p>要查找与OWASP Top 10相关的规则，您可以对类别执行文本搜索，或执行规则标记搜索。</p><p><br><br><br><br><br></p><h2 id="內建规则和标签"><a href="#內建规则和标签" class="headerlink" title="內建规则和标签"></a>內建规则和标签</h2><p>Built-in Rule Tags</p><p>标签(tag) 是一种对问题(issue)和规则(rule)进行分类的方法。问题会继承引发它们的规则上的标记。有些标签适用于特定语言，但是更多的标签出现在各种语言中。用户可以为规则和问题添加标签。但大多数规则都有一些开箱即用的标签。<br>以下是一些非全面的、包含一些內建标签:</p><ul><li><code>brain-overload</code> - 一次有太多的东西要留在脑海里</li><li><code>bad-practice</code> - 代码可能按设计工作，但它的设计方式被广泛认为是一个坏主意</li><li><code>cert</code> - 设计CERT标准中的规则</li><li><code>clumsy</code> - 用于完成可以更清晰和简洁地完成的事情的额外步骤</li><li><code>confusing</code> - 将使维护者更长时间地理解，而不是代码实际所做的事情</li><li><code>convention</code> - 编码约定，如格式化、命名、空格…</li><li><code>cwe</code> - CWE安全规则</li><li><code>design</code> - 代码设计存在一些问题</li><li><code>lock-in</code> - 使用特定于环境的功能</li><li><code>misra</code> - MISRA标准相关的规则</li><li><code>owasp</code> - 与OWASP TOP 10安全标准相关的规则</li><li><code>pitfall</code> - 没有什么不对，但未来可能出现问题;已经为下一个人设置了一个陷阱，他可能会陷入其中并搞砸了代码</li><li><code>sans-top25</code> - 与SANS Top 25 Coding Errors安全相关</li><li><code>suspicious</code> - 它不能保证这是一个bug，但它看起来很可疑。至少，代码应该重新检查并且可能为了清晰而重构</li><li><code>unpredictable</code> - 代码可以在当前条件下正常工作，但如果条件发生变化可能会失败</li><li><code>unused</code> - 未使用的代码</li><li><code>user-experience</code> - 代码在技术上没有任何问题，但它可能会使您的部分或全部用户讨厌您</li></ul><p><br><br><br><br><br></p><h2 id="Quality-Gates"><a href="#Quality-Gates" class="headerlink" title="Quality Gates"></a>Quality Gates</h2><p><br></p><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>质量阈(Quality Gates)是你在组织中实施质量策略的最佳方式。它可以回答一个问题: 我今天可以将项目发上线吗？<br>为了回答这个问题，你可以根据测量项目的度量阈值定义一组布尔条件，例如:</p><ul><li>No new blocker issues</li><li>Code coverage on new code greater than 80%</li><li>…</li></ul><p>理想状况下，所有项目都将通过同一质量阈进行验证。但这并不总是实用的。例如，你可能会发现:</p><ul><li>技术实现因应用程序而异</li><li>您希望确保对某些应用程序有更强的要求</li><li>…</li></ul><p>这就是为什么你可以根据需要自定义质量阈，它就在顶部的菜单栏上。</p><p><br><br><br></p><h3 id="最佳质量阈配置"><a href="#最佳质量阈配置" class="headerlink" title="最佳质量阈配置"></a>最佳质量阈配置</h3><p>Use the Best Quality Gate Configuration</p><p>质量阈默认激活并视为內建和只读的<code>Sonar war</code>方式，由SonarQube提供。它代表了我们对实施修复泄露。根据SonarQube的功能自动调整</p><p>有三个指标允许你强制执行给定的可靠性，安全性和可维护性的评级。不仅仅是整体而且还有新代码。建议使用这些指标，并将其作为默认质量阈的一部分，以便开发人员在项目页面上查看质量阈时更清楚的反馈。</p><p>不要忘记质量阈条件必须使用差值，检查绝对值是没有意义的(如: 代码行数大于1000)。</p><p><br></p><p><strong>推荐的质量阈(Recommended Quality Gate)</strong></p><p>內建的<code>Sonar way</code>质量阈都推荐用于大多数项目。如果专注于保持新代码清洁，而不是花费大量时间来修复旧代码。它开箱即用，已被设置为默认配置文件。</p><p><br><br><br></p><h3 id="质量阈状态"><a href="#质量阈状态" class="headerlink" title="质量阈状态"></a>质量阈状态</h3><p>Quality Gate Status</p><p><img src="/images/SonarQube/quality-gate-status.jpeg" alt></p><p><br><br><br></p><h3 id="当质量阈失败时获得通知"><a href="#当质量阈失败时获得通知" class="headerlink" title="当质量阈失败时获得通知"></a>当质量阈失败时获得通知</h3><p>Getting Notified When a Quality Gate Fails</p><p>使用通知机制，在质量阈失败时通知用户。为此，请订阅<strong>New quality gate status</strong>通知。</p><p><br><br><br></p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>Security</p><p>任何用户(甚至是匿名用户)都可以访问质量阈。<br>要就行更改(create, edit, delete)，必须授予用户管理质量阈的权限。<br>项目管理员可选择与他们项目相关的质量阈。</p><p><br><br><br></p><h3 id="定义质量阈"><a href="#定义质量阈" class="headerlink" title="定义质量阈"></a>定义质量阈</h3><p>Defining Quality Gates</p><p>要管理质量阈，请转到菜单栏的<strong>Quality Gates</strong>。</p><p>每个质量阈条件都是以下组合:</p><ul><li>测量(measure)</li><li>比较符(comparison operator)</li><li>错误值(error value)</li></ul><p>栗子，条件可能是:</p><ul><li>measure: <code>Blocker issue</code></li><li>comparison operator: <code>&gt;</code></li><li>error value: <code>0</code></li></ul><p><br><br><br><br><br></p><h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p>Metric Definitions</p><p>项目有如下指标:</p><ul><li>复杂度(Complexity)</li><li>重复(Duplications)</li><li>问题(Issues)</li><li>可维护性(Maintainability)</li><li>质量阈(Quality Gates)</li><li>可靠性(Reliability)</li><li>安全性(Security)</li><li>大小(Size)</li><li>测试(Tests)</li></ul><p><br></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>应用的控制流是简单还是复杂。</p><p><br></p><h4 id="圈复杂度"><a href="#圈复杂度" class="headerlink" title="圈复杂度"></a>圈复杂度</h4><p>Cyclomatic Complexity</p><p>可以计算出达到全面覆盖需要的最少测试用例。<br>它是基于通过代码的路径数计算的，每当函数的控制流分裂时，复杂度计数器就会增加1。每个函数的最小复杂度为1.此计算因语言而异，因为关键字和功能有所不同。</p><p><br></p><p><strong>特定语言的详细信息:</strong></p><div class="table-container"><table><thead><tr><th>Language</th><th>Notes</th></tr></thead><tbody><tr><td>ABAP</td><td>这些关键字将使复杂度加一: <code>AND , CATCH , CONTINUE , DO , ELSEIF , IF , LOOP , LOOPAT , OR , PROVIDE , SELECT…ENDSELECT , TRY , WHEN , WHILE</code></td></tr><tr><td>C/C++/Objective-C</td><td>复杂度加一: `function definitions, while , do while , for , throw statements, switch , case , default , &amp;&amp; operator,</td><td></td><td>operator, ? ternary operator, catch , break , continue , goto`</td></tr><tr><td>COBOL</td><td>复杂度加一: <code>ALSO , ALTER , AND , DEPENDING , END_OF_PAGE , ENTRY , EOP , EXCEPTION , EXIT , GOBACK , CONTINUE , IF , INVALID , OR , OVERFLOW , SIZE , STOP , TIMES , UNTIL , USE , VARYING , WHEN , EXEC CICS HANDLE , EXEC CICS LINK , EXEC CICS XCTL , EXEC CICS RETURN</code></td></tr><tr><td>Java</td><td>复杂度加一: `if , for , while , case , catch , throw , &amp;&amp; ,</td><td></td><td>, ?`</td></tr><tr><td>JS, PHP</td><td>复杂度加一: `function, if, &amp;&amp;,</td><td></td><td>, loop, switch case, throw, catch, go to`</td></tr><tr><td>PL/I</td><td>复杂度加一: `PROC , PROCEDURE , GOTO , GO TO , DO , IF , WHEN ,</td><td>, ! ,</td><td>= , != , &amp; , &amp;=`</td></tr><tr><td>PL/SQL</td><td>复杂度加一: create procedure, create trigger, procedure definition, basic loop statement, when clause statement, continue statement,exit statement, for loop statement, forall statement, if statement, elsif clause, raise statement, return statement, while loop statement, and expression, or expression, when clause expression</td></tr><tr><td>VB.NET</td><td>复杂度加一: <code>method or constructor declaration,  AndAlso , Case , Continue , End , Error , Exit , If , Loop , On Error , GoTo , OrElse , Resume , Stop , Throw , Try</code></td></tr></tbody></table></div><p><br><br><br></p><h4 id="认知复杂度"><a href="#认知复杂度" class="headerlink" title="认知复杂度"></a>认知复杂度</h4><p>Cognitive Complexity</p><p>对应这个应用是否很难被理解，理解代码的控制流程有多难。</p><p><br><br><br></p><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>有:</p><ul><li>重复的块(Duplicated blocks)</li><li>重复的行(Duplicated lines)</li><li>重读文件(Duplicated files)</li><li>密度/重复行%(Duplicated lines %)</li></ul><p><br></p><h4 id="重复的块"><a href="#重复的块" class="headerlink" title="重复的块"></a>重复的块</h4><p>重复的行的块数。</p><p><br></p><p><strong>特定语言的详细信息</strong></p><p>非Java项目:</p><ul><li>There should be at least 100 successive and duplicated tokens.</li><li>Those tokens should be spread at least on:<ul><li>30 lines of code for COBOL</li><li>20 lines of code for ABAP</li><li>10 lines of code for other languages</li></ul></li></ul><p>Java项目:</p><p>There should be at least 10 successive and duplicated statements whatever the number of tokens and lines.检测重复时忽略缩进和字符串文字的差异。</p><p><br><br><br></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有:</p><ul><li>新问题(New issues)</li><li>新的严重问题(New xxx issues)</li><li>所有问题(Issues)</li><li>严重问题(xxx issues)</li><li>误判问题(False positive issues)</li><li>开启问题(Open issues)</li><li>确认问题(Confirmed issues)</li><li>重开问题(Reopened issues)</li></ul><p><br><br><br></p><h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><p>有:</p><ul><li>异味(Code Smells)</li><li>新异味(New Code Smells)</li><li>维护率(Maintainability Rating)</li><li>技术债务(Technical Debt)</li><li>新代码的技术债务(Technical Debt on New Code)</li><li>技术债务率(Technical Debt Ratio)</li><li>新代码的技术债务率(Technical Debt Ratio on New Code)</li></ul><p><br></p><h4 id="维护率"><a href="#维护率" class="headerlink" title="维护率"></a>维护率</h4><p>使用<strong>SQALE评级</strong>。与您的技术债务比率值相关的项目评级。<br>默认的可维护性评级网格是:</p><ul><li>A=<code>0-0.05 (&lt;5%)</code></li><li>B=<code>0.06-0.1 (6%-10%)</code></li><li>C=<code>0.11-0.20(11%-20%)</code></li><li>D=<code>0.21-0.5(21%-50%)</code></li><li>E=<code>0.51-1(50%-100%)</code></li></ul><p><br><br><br></p><h4 id="技术债务"><a href="#技术债务" class="headerlink" title="技术债务"></a>技术债务</h4><p>努力修复所有异味。以分钟(min)为度量单位存储在数据库中，单位值中的天假设为8小时(h)。</p><p><br><br><br></p><h4 id="技术债务率"><a href="#技术债务率" class="headerlink" title="技术债务率"></a>技术债务率</h4><p>开发成本与修复成本之间的比率。技术债务公式为: <code>Remediation cost / Development cost</code></p><p>开发一行代码的成本价值为<code>0.06 day == 0.06 * 8 * 60 min</code></p><p><br><br><br></p><h3 id="质量阈"><a href="#质量阈" class="headerlink" title="质量阈"></a>质量阈</h3><p>有:</p><ul><li>质量阈状态(Quality Gate Status)</li><li>质量阈详情(Quality Gate Details)</li></ul><p><br><br><br></p><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>有:</p><ul><li>Bugs</li><li>New Bugs</li><li>可靠率(Reliability Rating)</li><li>可靠性的修复工作(Reliability remediation effort)</li><li>新代码可靠性的修复工作(Reliability remediation effort on new code)</li></ul><p><br></p><h4 id="可靠率"><a href="#可靠率" class="headerlink" title="可靠率"></a>可靠率</h4><ul><li>A = 0 Bugs</li><li>B = at least 1 Minor Bug</li><li>C = at least 1 Major Bug</li><li>D = at least 1 Critical Bug</li><li>E = at least 1 Blocker Bug</li></ul><p><br><br><br></p><h4 id="修复工作"><a href="#修复工作" class="headerlink" title="修复工作"></a>修复工作</h4><p>努力解决所有Bugs。以分钟为单位度量值存储在数据库中。如果数值天，则假设一天为8小时。</p><p><br><br><br></p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>有:</p><ul><li>漏洞(Vulnerabilities)</li><li>新漏洞(New Vulnerabilities)</li><li>安全级(Security Rating)</li><li>安全修复工作(Security remediation effort )</li><li>新代码的安全修复工作(Security remedation effort on new code)</li></ul><p><br></p><h4 id="安全评级"><a href="#安全评级" class="headerlink" title="安全评级"></a>安全评级</h4><ul><li>A = 0 Vulnerabilities</li><li>B = at least 1 Minor Vulnerability</li><li>C = at least 1 Major Vulnerability</li><li>D = at least 1 Critical Vulnerability</li><li>E = at least 1 Blocker Vulnerability</li></ul><p><br><br><br></p><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>有:</p><ul><li>类(Classes)</li><li>注释行(Comment lines)</li><li>注释占比(Comments %) - <code>Comment lines / (Lines of code + Comment lines) * 100</code></li><li>目录(Directories)</li><li>文件(Files)</li><li>行数(Lines)</li><li>代码行数(Lines of code)</li><li>每种语言的代码行数(Lines of code per language)</li><li>函数(Functions)</li></ul><p><br><br><br></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>有:</p><ul><li>条件覆盖(Condition coverage)</li><li>新代码条件覆盖(Condition coverage on new code)</li><li>条件覆盖命中(Condition coverage hits)</li><li>逐行条件(Conditions by line)</li><li>逐行条件覆盖(Covered conditions by line)</li><li>覆盖(Coverage)</li><li>新代码覆盖(Coverage on new code)</li><li>行覆盖(Line coverage)</li><li>新代码行覆盖(Line coverage on new code)</li><li>行覆盖命中(Line coverage hits)</li><li>要覆盖的行(Lines to cover)</li><li>新代码要覆盖的行(Lines to cover on new code)</li><li>跳过单元测试(Skipped unit tests)</li><li>未覆盖条件(Uncovered conditions)</li><li>新代码未覆盖条件(Uncovered conditions on new code)</li><li>未覆盖行(Uncovered lines)</li><li>新代码未覆盖行(Uncovered lines on new code)</li><li>单元测试(Unit tests)</li><li>单元测试持续时间(Unit tests duration)</li><li>单元测试错误(Unit test errors)</li><li>单元测试失败(Unit test failures)</li><li>单元测试成功密度(Unit test success density %) - <code>Test success density = (Unit tests - (Unit test errors + Unit test failures)) / Unit tests * 100</code></li></ul><p><br></p><h4 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h4><p>在包含一些布尔表达式的每行代码中，条件覆盖只是回答了以下问题: <em>每个布尔表达式是否都被评估为 <code>true</code> 和 <code>false</code>?</em>。这是在单元测试执行期间遵循的流控制结构中可能的条件密度。</p><p><code>Condition coverage = (CT + CF) / (2*B)</code>, where:</p><ul><li>CT = conditions that have been evaluated to ‘true’ at least once(已经被评估为<code>true</code>至少一次的条件)</li><li>CF = conditions that have been evaluated to ‘false’ at least once(已经被评估为<code>false</code>至少一次的条件)</li><li>B = 条件总数(total number of conditions)</li></ul><p><br><br><br></p><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>它是行覆盖和条件覆盖的混合。它的目标是为以下问题提供更准确的答案: <em>单元测试覆盖了多少源代码?</em></p><p><code>Coverage = (CT + CF + LC)/(2*B + EL)</code>, where:</p><ul><li>CT = 已经被评估为<code>true</code>至少一次的条件</li><li>CF = 已经被评估为<code>false</code>至少一次的条件</li><li>LC = 覆盖的行(covered lines)</li><li>B = 条件总数</li><li>EL = 可执行行的总数( total number of executable lines)</li></ul><p><br><br><br></p><h4 id="行覆盖"><a href="#行覆盖" class="headerlink" title="行覆盖"></a>行覆盖</h4><p>在给定的代码行上，行覆盖简单地回答了以下问题: <em>在执行单元测试期间是否执行了这行代码?</em></p><p>它是单元测试的覆盖率密度:</p><p><code>Line coverage = LC / EL</code>, where:</p><ul><li>LC = 覆盖的行(covered lines)</li><li>EL = 可执行行的总数(total number of executable lines)</li></ul><p><br><br><br><br><br></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Concepts</p><p><br><br><br></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>Architecture</p><div class="table-container"><table><thead><tr><th>概念</th><th>定义</th></tr></thead><tbody><tr><td>Analyzer</td><td>用于分析源代码以计算快照的客户端程序</td></tr><tr><td>Database</td><td>存储配置和快照</td></tr><tr><td>Server</td><td>用于浏览快照数据和进行配置修改的Web界面</td></tr></tbody></table></div><p><br><br><br></p><h3 id="质量"><a href="#质量" class="headerlink" title="质量"></a>质量</h3><p>Quality</p><div class="table-container"><table><thead><tr><th>概念</th><th>定义</th></tr></thead><tbody><tr><td>Bug</td><td>表示代码中出错的问题</td></tr><tr><td>Code Smell</td><td>代码中与可维护性相关的问题</td></tr><tr><td>Cost</td><td>花费</td></tr><tr><td>Debt</td><td>解决问题所需的时间</td></tr><tr><td>Issue</td><td>代码不符合规则时，快照上会记录一个问题。有: Bugs , Code Smells and Vulnerabilities</td></tr><tr><td>Measure</td><td>给定时间内给定文件或项目的度量值</td></tr><tr><td>Metric</td><td>一种测量方式。随着时间的推移，度量标准可能具有不同的值或度量</td></tr><tr><td>New Code Period</td><td>需要密切关注代码中引入新问题的时间段</td></tr><tr><td>Quality Profile</td><td>一组规则</td></tr><tr><td>Rule</td><td>应该遵循的编码标准或惯例</td></tr><tr><td>Remediation Cost</td><td>修复漏洞和可靠性问题所需的估计时间</td></tr><tr><td>Snapshot</td><td>在给定时间内针对给定项目的一组度量和问题</td></tr><tr><td>Security Hotspot</td><td>与安全相关的问题，突出显示使用安全敏感API的一段代码</td></tr><tr><td>Technical Debt</td><td>修复问题所需的估计时间</td></tr><tr><td>Vulnerability</td><td>与安全相关的问题，代表攻击者的后门</td></tr></tbody></table></div><p><br><br><br><br><br></p><h2 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h2><p>Activity and History</p><p>项目活动页面提供项目文件分析的完整列表，以及随着时间推移看到项目措施演变的能力。<br>活动页面上的图标可帮助你了解几种相互选择的度量方法的演变。</p><p><br></p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Events</p><p>有四种类型的事件:</p><ul><li>Quality Gate</li><li>Profile</li><li>Version</li><li>Other</li></ul><p><br><br><br><br><br></p><h2 id="SonarLint"><a href="#SonarLint" class="headerlink" title="SonarLint"></a>SonarLint</h2><p>SonarLint Smart Notifications</p><p>SonarLint Smart Notifications是作为Developer Edtion的一部分来提供。</p><p>智能通知允许使用SonarLint中的连接模式的开发人员以一下情况下从SonarQube接收IDE内的通知:</p><ul><li>the Quality Gate status (failed / success) of a project /solution open in the IDE changes</li><li>a SonarQube analysis raises new issues introduced by this developer in a project /solution open in the IDE</li></ul><p>SonarLint智能通知的激活和取消必须由每个开发人员直接在SonarLint(IDE端)进行单独完成。<br>可以在SonarQube上逐个服务器地在SonarLint端配置接收通知。</p><p><br><br><br><br><br></p><h2 id="Security-Reports"><a href="#Security-Reports" class="headerlink" title="Security Reports"></a>Security Reports</h2><p><br></p><h3 id="安全报告显示了什么"><a href="#安全报告显示了什么" class="headerlink" title="安全报告显示了什么"></a>安全报告显示了什么</h3><p>What do the Security Reports show?</p><p>安全报告旨在快速为您提供有关应用程序安全性的全景图，并详细说明OWASP, SANS, CWE标准的详细信息。安全报告由分析器提供，分析器依赖于质量配置文件中激活的规则来引发安全问题。</p><p><br><br><br></p><h3 id="热点和漏洞有什么区别"><a href="#热点和漏洞有什么区别" class="headerlink" title="热点和漏洞有什么区别"></a>热点和漏洞有什么区别</h3><p>What’s the difference between a Hotspot and a Vulnerability?</p><p>漏洞是代码中可以攻击的点。安全热点是安全敏感的代码段，应由具有安全审计员帽的人仔细审查。<br>安全热点的主要目标是帮助集中手动审查应用程序源代码的安全审核员的工作。第二个目标是教育开发人员并提高他们的安全意识。</p><p><br><br><br></p><h3 id="为什么某些热点和漏洞非常相似"><a href="#为什么某些热点和漏洞非常相似" class="headerlink" title="为什么某些热点和漏洞非常相似"></a>为什么某些热点和漏洞非常相似</h3><p>Why are some Hotspot and Vulnerability rules very similar?</p><p>它们是故意重叠的。热点规则应该包括漏洞规则的所有匹配，以及污点分析引擎无法检测漏洞的情况。</p><p><br><br><br></p><h3 id="为什么我看不到任何热点"><a href="#为什么我看不到任何热点" class="headerlink" title="为什么我看不到任何热点"></a>为什么我看不到任何热点</h3><p>Why are some Hotspot and Vulnerability rules very similar?</p><p>有三个原因:</p><ul><li>可能真的没有它们，因为代码是在没有使用任何安全敏感API的情况下编写的</li><li>热点规则可能可用，但尚未在你的质量配置文件中激活，因此自然不会引发任何问题</li><li>你正在使用的语言分析器可能还没有提供热点规则，所以它不会引发任何热点</li></ul><p><br><br><br></p><h3 id="为什么我看不到任何漏洞"><a href="#为什么我看不到任何漏洞" class="headerlink" title="为什么我看不到任何漏洞"></a>为什么我看不到任何漏洞</h3><p>由于一些热点原因，你可能没有看到任何漏洞的，但你可能会看到项目主页中报告了一些漏洞，而安全报告中没有漏洞。这是因为语言分析器可能尚未提供安全报告中可见问题所需的安全标准的元数据。</p><p><br><br><br></p><h3 id="开发者是否应该关心热点"><a href="#开发者是否应该关心热点" class="headerlink" title="开发者是否应该关心热点"></a>开发者是否应该关心热点</h3><p>可能并不需要。热点并不是真正可行的，它们只是标记潜在的问题，所以在代码上没有立即做任何事情。这就是为什么在引发热点问题时没有收到通知。</p><p><br><br><br></p><h3 id="如果热点确实标记为漏洞怎么办"><a href="#如果热点确实标记为漏洞怎么办" class="headerlink" title="如果热点确实标记为漏洞怎么办"></a>如果热点确实标记为漏洞怎么办</h3><p>如果您查看引发热点的代码并意识到确实存在问题，请单击当前状态以注册您在代码中检测到漏洞。完成后，它将转换为漏洞，最后触摸该行的开发人员将收到新问题通知。</p><p><br><br><br></p><h3 id="热点变为漏洞后会发生什么"><a href="#热点变为漏洞后会发生什么" class="headerlink" title="热点变为漏洞后会发生什么"></a>热点变为漏洞后会发生什么</h3><p>一旦您检测到热点位置确实存在问题，它将被分配给相应的开发人员，他们将进行修复，然后必须通过UI请求审核。</p><p><br><br><br></p><h3 id="热点被标记为不会修复是什么意思"><a href="#热点被标记为不会修复是什么意思" class="headerlink" title="热点被标记为不会修复是什么意思"></a>热点被标记为不会修复是什么意思</h3><p>What does it mean for a Hotspot to be marked “Won’t Fix”?</p><p>不会修复标记用于表示已经审查了热点，并且目前无法利用这段代码创建攻击。</p><p><br><br><br><br><br></p><h2 id="用户账户"><a href="#用户账户" class="headerlink" title="用户账户"></a>用户账户</h2><p>User Account</p><p>SonarQube用户可拥有自己的空间，可查看与自己相关的内容。</p><p><br><br><br><br><br></p><h2 id="User-Token"><a href="#User-Token" class="headerlink" title="User Token"></a>User Token</h2><p>每个用户都可生成令牌，这些令牌可用于运行分析或调用Web服务，而无需用户的实际凭据。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><p>Project Administration</p><p><br></p><h2 id="项目存在"><a href="#项目存在" class="headerlink" title="项目存在"></a>项目存在</h2><p>Project Existence</p><p>通常，项目在第一次分析时创建，不会删除(除非手动删除)。你可以管你你有权限管理的项目。</p><p><br></p><ul><li>在第一次分析之前配置项目</li><li>配置还未分析的项目</li><li>修改项目权限(Private/Public) - 默认情况下，任何新创建的项目都被视为Public。这意味着每个经过认证的用户都能够<strong>Browse</strong>和<strong>See Source Code</strong></li><li>删除项目</li><li>查找不再分析的项目</li></ul><p><br><br><br></p><h2 id="管理项目历史"><a href="#管理项目历史" class="headerlink" title="管理项目历史"></a>管理项目历史</h2><p>Managing Project History</p><p>SonarQube最强大的功能之一是它不仅向你展示了你今天的项目健康状况，还展示了它随时间的变化情况。它通过有选择地保留以前分析的数据来做到这一点。它没有保留所有以前的分析——这会使数据库膨胀。同样，对于它确实存在的分析，SonarQube不会保留所有数据。一旦项目快照(snapshot)从最后分析(Last analysis)移动到项目历史的一部分，项目级别下面的数据就会被清除——再次放置数据库膨胀。</p><p>通常这些都不是你需要考虑的事情。SonarQube只为你专门处理它们。但有时你可能需要从项目的历史记录中删除错误的快照或修改内存处理算法。</p><p><br></p><p>可查看数据库表大小:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># sonar</span><br><span class="line"><span class="keyword">USE</span> information_schema;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">TABLES</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> TABLE_SCHEMA, TABLE_NAME, TABLE_ROWS, DATA_LENGTH <span class="keyword">FROM</span> <span class="keyword">TABLES</span> <span class="keyword">WHERE</span> TABLE_SCHEMA = <span class="string">'sonar'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> DATA_LENGTH <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><br></p><p>有时你可能需要手动删除项目快照，无论是因为使用了错误的质量配置文件，还是因为分析存在问题…请注意，永远不能删除最新的快照。</p><p>对于每个快照，可以手动:</p><ul><li>Add, rename or remove a version</li><li>Add, rename or remove an event</li><li>Delete the snapshot</li></ul><p><br><br><br></p><h2 id="缩小关注点"><a href="#缩小关注点" class="headerlink" title="缩小关注点"></a>缩小关注点</h2><p>Narrowing the Focus</p><p>如果SonarQube的结果不相关，那么没有人会想要使用它。这就是为什么精确配置每个项目要分析的内容是非常重要的一步。<br>SonarQube为你提供了几种选项，可以准确配置要分析的内容。你可以:</p><ul><li>完全忽略一些文件或目录</li><li>从问题中排除文件或目录，但分析所有其它方面</li><li>从重复性中排除文件或目录，但分析所有其它方面</li><li>从覆盖率中排除文件或目录，但分析其它所有方面</li></ul><p>你可以在全局或项目级别配置它们。</p><p><br></p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>Ignore Files</p><p>建议你从库中排除生成的代码，源代码等。有四种不同的方法可将分析范围缩小到与开发团队相关的源代码。</p><ul><li>源目录(Source Directories)</li><li>文件后缀(File Suffixes)</li><li>选择文件(Choosing Files)<ul><li>源文件排除(Source File Exclusions)</li><li>测试文件排除(Test File Exclusions)</li><li>源文件包含(Source File Inclusions)</li><li>测试文件包含(Test File Inclusions)</li></ul></li></ul><p><img src="/images/SonarQube/exclusions.jpg" alt></p><p><img src="/images/SonarQube/inclusions.jpg" alt></p><p><br><br><br></p><h3 id="忽略问题"><a href="#忽略问题" class="headerlink" title="忽略问题"></a>忽略问题</h3><p>Ignore Issues</p><p>可使用SonarQube忽略某些组件和某些编码规则的问题。<code>Administration &gt; General Settings &gt; Analysis Scope &gt; Issues</code>。</p><p>请注意，以下属性只能通过Web界面设置，因为它们是多值的。</p><ul><li>Ignore Issues on Files</li><li>Ignore Issues in Blocks</li><li>Ignore Issues on Multiple Criteria</li><li>Restrict Scope of Coding Rules</li></ul><p><br><br><br></p><h3 id="忽略重复"><a href="#忽略重复" class="headerlink" title="忽略重复"></a>忽略重复</h3><p>Ignore Duplications</p><p>可在SonarQube中阻止检查某些文件的重复性。<code>Administration &gt; General Settings &gt; Analysis Scope &gt; Duplications</code>。</p><p><br><br><br></p><h3 id="忽略代码覆盖率"><a href="#忽略代码覆盖率" class="headerlink" title="忽略代码覆盖率"></a>忽略代码覆盖率</h3><p>Ignore Code Coverage</p><p>可以通过单元测试防止某些文件考虑用于代码覆盖。<code>Administration &gt; General Settings &gt; Analysis Scope &gt; Code Coverage &gt; Coverage Exclusions</code>。</p><p><br><br><br></p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>Patterns</p><p>SonarQube中可以使用以下通配符:</p><ul><li><code>*</code>    - 零个或多个字符(zero or more characters)</li><li><code>**</code> - 零个或多个目录(zero or more directories)</li><li><code>?</code> - 单个字符(a single character)</li></ul><p><br><br><br><br><br></p><h2 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h2><p>Project Settings</p><p><br></p><h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><p>项目标签(tags) 允许对项目进行分类和分组，以便在项目页面上更容易地选择。可以从项目主页管理项目标签。</p><p><br><br><br></p><h3 id="管理项"><a href="#管理项" class="headerlink" title="管理项"></a>管理项</h3><p>Administration Items:</p><ul><li>Adding a Project</li><li>Analysis Report Processing</li><li>Deleting a Project</li><li>Setting the New Code Period</li><li>Updating Project Key</li><li>Default Issue Assignee</li><li>Setting Quality Gate and Quality Profiles</li><li>Setting Exclusions</li><li>Customizing Links</li></ul><p><br><br><br><br><br></p><h2 id="Webhooks"><a href="#Webhooks" class="headerlink" title="Webhooks"></a>Webhooks</h2><p>网络调用(Webhooks) 在项目完成分析后通知外部服——An HTTP POST request including a JSON payload is sent to each URL。可在项目级别和全局指定URL。项目级别的配置不会取代全局的配置，两个级别的所有Webhooks都被调用。</p><p>HTTP(s) 调用:</p><ul><li>无论后台任务的状态如何</li><li>使用POST方法将JSON文档作为负载</li><li>使用<code>UTF-8</code>编码的内容类型<code>application/json</code></li></ul><p><br></p><h3 id="Delivery-and-Payload"><a href="#Delivery-and-Payload" class="headerlink" title="Delivery and Payload"></a>Delivery and Payload</h3><p>Webhook 管理控制台显示每个Webhook的最新交付的结果和时间戳，其中有效负载可通过列表图标获得。默认保留30天的记录。URL必须在10s响应，否则传递将标记为失败。</p><p>发送带有project key的 HTTP header <code>X-SonarQube-Project</code>，以便快速识别所涉及的项目。</p><p>Payload是一个JSON文档，包括:</p><ul><li>什么时候运行分析(<code>analysedAt</code>)</li><li>分析的项目的标识(<code>project</code>)</li><li>每个质量阈标准和状态(<code>qualityGate</code>)</li><li>每个项目的质量阈状态(<code>qualityGate.status</code>)</li><li>后台任务的状态和标识(<code>status</code>, <code>taskId</code>)</li><li>用于定义的属性(<code>properties</code>)</li></ul><p>栗子:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analysedAt"</span>: <span class="string">"2016-11-18T10:46:28+0100"</span>,</span><br><span class="line">    <span class="attr">"project"</span>: &#123;</span><br><span class="line">        <span class="attr">"key"</span>: <span class="string">"org.sonarqube:example"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Example"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"qualityGate"</span>: &#123;</span><br><span class="line">        <span class="attr">"conditions"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"errorThreshold"</span>: <span class="string">"1"</span>,</span><br><span class="line">                <span class="attr">"metric"</span>: <span class="string">"new_security_rating"</span>,</span><br><span class="line">                <span class="attr">"onLeakPeriod"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">"operator"</span>: <span class="string">"GREATER_THAN"</span>,</span><br><span class="line">                <span class="attr">"status"</span>: <span class="string">"OK"</span>,</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"1"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"errorThreshold"</span>: <span class="string">"1"</span>,</span><br><span class="line">                <span class="attr">"metric"</span>: <span class="string">"new_reliability_rating"</span>,</span><br><span class="line">                <span class="attr">"onLeakPeriod"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">"operator"</span>: <span class="string">"GREATER_THAN"</span>,</span><br><span class="line">                <span class="attr">"status"</span>: <span class="string">"OK"</span>,</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"1"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"errorThreshold"</span>: <span class="string">"1"</span>,</span><br><span class="line">                <span class="attr">"metric"</span>: <span class="string">"new_maintainability_rating"</span>,</span><br><span class="line">                <span class="attr">"onLeakPeriod"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">"operator"</span>: <span class="string">"GREATER_THAN"</span>,</span><br><span class="line">                <span class="attr">"status"</span>: <span class="string">"OK"</span>,</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"1"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"errorThreshold"</span>: <span class="string">"80"</span>,</span><br><span class="line">                <span class="attr">"metric"</span>: <span class="string">"new_coverage"</span>,</span><br><span class="line">                <span class="attr">"onLeakPeriod"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">"operator"</span>: <span class="string">"LESS_THAN"</span>,</span><br><span class="line">                <span class="attr">"status"</span>: <span class="string">"NO_VALUE"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"SonarQube way"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="string">"OK"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"serverUrl"</span>: <span class="string">"http://localhost:9000"</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"SUCCESS"</span>,</span><br><span class="line">    <span class="attr">"taskId"</span>: <span class="string">"AVh21JS2JepAEhwQ-b3u"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="附加参数"><a href="#附加参数" class="headerlink" title="附加参数"></a>附加参数</h3><p>Additional parameters</p><p>通过在Webhook的URL中提供<code>user/passwd</code>来支持基本的身份认证机制。(如: <code>https://myLogin:myPassword@my_server/foo</code>)</p><p>如果使用了<code>sonar.analysis.*</code>属性为SonarScanner提供其它属性，则这些属性将自动添加到有效负载的<code>properties</code>部分。</p><p>栗子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sonar-scanner -Dsonar.analysis.scmRevision=628f5175ada0d685fd7164baa7c6382c1f25cab4 -Dsonar.analysis.buildNumber=12345</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="实例管理"><a href="#实例管理" class="headerlink" title="实例管理"></a>实例管理</h1><p>Instance Administration</p><p><br></p><h2 id="质量配置"><a href="#质量配置" class="headerlink" title="质量配置"></a>质量配置</h2><p>Quality Profiles</p><p><br></p><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>质量配置(Quality Profiles)服务是SonarQube的核心，因为它是您通过定义规则集来定义需求的地方。。</p><p>理想情况下，对于任何给定的语言，所有项目都将使用相同的配置文件进行测量，但这并不总是实用的。<br>这就是为什么您可以根据需要定义尽可能多的质量配置文件，即使建议尽可能少的质量配置文件以确保公司项目的一致性。</p><p>每个语言都带有预定义的內建配置文件(通常称为 Sonar way)，因此你可以使用SonarQube分析进行快速开始。这就是为什么只要安装新的语言插件，就可以使用至少一个配置文件。</p><p>默认的Sonar way配置文件，它包含了通常适用于大多数项目的所有规则。但作为最佳实践，你应该创建一个新的配置文件(你可以通过复制Sonar way的内容来填充它)，并使用它。<br>因为默认的Sonar way是不可编辑的，因此你无法根据需要对其进行自定义。此外，这使你可将Sonar way视为一个基线，可在对其进行更改时跟踪自己的配置文件。此外Sonar way通常会随插件的每个新版本更新，已添加规则，有时还会调整规则严重性。任何继承自內建Sonar way的配置文件都将在事实上同时自动更新。</p><p><br><br><br></p><h3 id="我该怎么做"><a href="#我该怎么做" class="headerlink" title="我该怎么做"></a>我该怎么做</h3><p><br></p><h4 id="将质量配置管理的权限移交给其他人"><a href="#将质量配置管理的权限移交给其他人" class="headerlink" title="　将质量配置管理的权限移交给其他人"></a>　将质量配置管理的权限移交给其他人</h4><p>Delegate the management of Quality Profiles to someone else?</p><p>默认情况下，管理员才有此权限。但你可以授予用户/组权限来编辑配置文件。例如将Java配置文件权限分配给Java开发专家，将Python配置文件权限分配给Python专家…</p><p><br><br><br></p><h4 id="将规则从一个配置复制到另一个配置"><a href="#将规则从一个配置复制到另一个配置" class="headerlink" title="将规则从一个配置复制到另一个配置"></a>将规则从一个配置复制到另一个配置</h4><p>Copy the rules from one profile to another?</p><p>许多时候，人们希望使用基于內建的配置文件的配置文件进行工作，而无实际需要使用內建配置文件。</p><p><br><br><br></p><h4 id="了解配置中有什么改变"><a href="#了解配置中有什么改变" class="headerlink" title="了解配置中有什么改变"></a>了解配置中有什么改变</h4><p>Know what’s changed in a profile?</p><p>当SonarQube注意到使用与先前分析不同的配置文件执行分析时，会将质量配置文件事件添加到项目的事件日志中。</p><p><br><br><br></p><h4 id="将配置文件从一个实例复制到另一个实例"><a href="#将配置文件从一个实例复制到另一个实例" class="headerlink" title="将配置文件从一个实例复制到另一个实例"></a>将配置文件从一个实例复制到另一个实例</h4><p>Copy a profile from one SonarQube instance to another?</p><p>使用实例上的备份(Back UP)功能将配置文件导出到XML文件。然后在另一个实例中选择恢复(Restore)。</p><p><br><br><br></p><h4 id="将一组核心规则和附加规则应用于项目"><a href="#将一组核心规则和附加规则应用于项目" class="headerlink" title="将一组核心规则和附加规则应用于项目"></a>将一组核心规则和附加规则应用于项目</h4><p>Apply a core set of rules plus additional rules to a project?</p><p>使用继承，从root继承核心规则集。然后创建一个子配置文件(Sprout)，修改从Root继承，然后添加缺少的规则。</p><p><br><br><br></p><h4 id="确保我的非默认配置文件应用于项目"><a href="#确保我的非默认配置文件应用于项目" class="headerlink" title="确保我的非默认配置文件应用于项目"></a>确保我的非默认配置文件应用于项目</h4><p>Make sure my non-default profile is used on a project?</p><p><br><br><br></p><h4 id="确保我的个人配置中包含所有相关的新规则"><a href="#确保我的个人配置中包含所有相关的新规则" class="headerlink" title="确保我的个人配置中包含所有相关的新规则"></a>确保我的个人配置中包含所有相关的新规则</h4><p>Make sure I’ve got all the relevant new rules in my profile?</p><p><br><br><br></p><h4 id="比较两个规则"><a href="#比较两个规则" class="headerlink" title="比较两个规则"></a>比较两个规则</h4><p>Compare two profiles?</p><p><br><br><br></p><h4 id="确保我的配置中没有任何弃用的规则"><a href="#确保我的配置中没有任何弃用的规则" class="headerlink" title="确保我的配置中没有任何弃用的规则"></a>确保我的配置中没有任何弃用的规则</h4><p>Make sure I don’t have any deprecated rules in my profile?</p><p><br><br><br></p><h4 id="安全-1"><a href="#安全-1" class="headerlink" title="安全"></a>安全</h4><p>Security</p><p>任何用户都可以访问质量配置服务，你可以给他们配置质量配置管理权限，让他们可以创建，删除质量配置。</p><p><br><br><br><br><br></p><h2 id="安全-2"><a href="#安全-2" class="headerlink" title="安全"></a>安全</h2><p><br></p><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>SonarQube具有许多全局安全功能:</p><ul><li>认证和授权机制</li><li>强制身份认证</li><li>委派认证</li></ul><p>除此之外，还可在group/user级别配置:</p><ul><li>查看一个已存在的项目</li><li>访问项目的源代码</li><li>管理一个项目</li><li>管理质量配置，质量阈，实例…</li></ul><p><br><br><br></p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>Authentication</p><p>第一个问题: 匿名用户是否可以浏览SonarQube实例？<br>当然不行！那就需要强制用户认证。</p><p><br></p><p><strong>认证机制(Authentication Mechanisms)</strong></p><p>可通过多种方式来管理认证机制:</p><ul><li>通过SonarQube內建的user/group数据库</li><li>通过外部程序(如LDAP)</li><li>通过HTTP headers</li></ul><p><br></p><p><strong>技术用户(Technical Users)</strong></p><p>当你在SonarQube数据库中创建用户时，他将被视为本地用户，并且针对SonarQube自己的user/group数据库进行身份认证，而不是通过任何外部工具。<br>默认情况下，<code>admin</code>是本地账户。</p><p>同样，所有非本地(non-local)账户将仅针对外部工具进行身份认证。</p><p>管理员可以管理所有用户的<strong>Tokens</strong>——创建和删除。一旦创建，Token就是运行分析所需的唯一凭证，作为<code>sonar.login</code>属性的值来传递。</p><p><br></p><p><strong>默认管理员(Default Admin Credentials)</strong></p><p>当安装SonarQube时，会自动创建具有管理系统权限的默认用户:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">passwd:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="重置管理员密码"><a href="#重置管理员密码" class="headerlink" title="重置管理员密码"></a>重置管理员密码</h3><p>Reinstating Admin Access</p><p>如果你修改了管理员密码，但又忘记了:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> sonar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> crypted_password = <span class="string">'$2a$12$uCkkXmhW5ThVK8mpBvnXOOJRLd64LJeHTeCkSuB3lfaR2N0AYBaSi'</span>, <span class="keyword">salt</span>=<span class="literal">null</span>, hash_method=<span class="string">'BCRYPT'</span> <span class="keyword">where</span> login = <span class="string">'admin'</span></span><br></pre></td></tr></table></figure><p>如果您删除了管理员并随后锁定了具有全局管理权限的其他用户:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> sonar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_roles(user_id, <span class="keyword">role</span>) <span class="keyword">VALUES</span> ((<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> login=<span class="string">'mylogin'</span>), <span class="string">'admin'</span>);</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>Authorization</p><p>对不同组、不同用于仅限权限分配，以访问不同的资源。</p><ul><li>user</li><li>group</li><li>Global Permissions<ul><li>Administer System</li><li>Administer Quality Profiles</li><li>Administer Quality Gates</li><li>Execute Analysis</li><li>Create Projects</li><li>Create Applications</li><li>Create Portfolios</li></ul></li><li>Project Permissions<ul><li>Public and Private<ul><li>Administer Issues</li><li>Administer Security Hotspots</li><li>Administer</li><li>Execute Analysis</li></ul></li><li>Private<ul><li>Browse</li><li>See Source Code</li></ul></li></ul></li></ul><p><br><br><br></p><h3 id="默认权限的权限模板"><a href="#默认权限的权限模板" class="headerlink" title="默认权限的权限模板"></a>默认权限的权限模板</h3><p>Permission Templates for Default Permissions</p><p>SonarQube附带默认权限模板，该模板在创建项目，项目组合或应用程序自动授予特定组的特定权限。管理员可以编辑此模板。</p><p><br><br><br></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>Encryption</p><p>加密主要用于从设置中删除明文密码。实现的解决方案是基于对称密钥算法，关键是密钥存储在磁盘上的安全文件中。此文件必须由运行SonarQube Server的系统账户拥有和读取。<br>该算法是AES 128位。</p><ul><li><strong>Generate the secret key</strong></li><li><strong>Store the secret key on the SonarQube server</strong></li><li><strong>Generate the encrypted values of your settings</strong></li><li><strong>Use the encrypted values in your SonarQube server configuration</strong></li></ul><p>必须在SonarQube基础架构的所有部分之间共享唯一的密钥。在<code>Administration &gt; Configuration &gt; Encryption</code>生成密钥。<br>生成密钥之后，会显示如何使用此密钥。</p><p><img src="/images/SonarQube/secretKey.png" alt></p><p>之后便可以为你设置的值进行加密。同样在前面的加密下进行配置。<br>之后在SonarQube Server中使用加密后的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># conf/sonar.properties</span><br><span class="line"></span><br><span class="line">sonar.jdbc.password=&#123;aes&#125;CCGCFg4Xpm6r+PiJb1Swfg==  # Encrypted DB password</span><br><span class="line">...</span><br><span class="line">sonar.secretKeyPath=C:/path/to/my/secure/location/my_secret_key.txt</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h2 id="委托认证"><a href="#委托认证" class="headerlink" title="委托认证"></a>委托认证</h2><p>Delegating Authentication</p><p>docs: <a href="https://docs.sonarqube.org/latest/instance-administration/delegated-auth/" target="_blank" rel="noopener">https://docs.sonarqube.org/latest/instance-administration/delegated-auth/</a></p><p>SonarQube认证:</p><ul><li>自带用户数据库认证</li><li>外部<ul><li>HTTP header</li><li>LDAP</li><li>…</li></ul></li></ul><p><br></p><h3 id="HTTP-header认证"><a href="#HTTP-header认证" class="headerlink" title="HTTP header认证"></a>HTTP header认证</h3><p><br><br><br></p><h3 id="LDAP认证"><a href="#LDAP认证" class="headerlink" title="LDAP认证"></a>LDAP认证</h3><p><br><br><br><br><br></p><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>Notifications</p><p>可以通过邮件配置，向用户发送分析的信息的通知。</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="使用实践"><a href="#使用实践" class="headerlink" title="使用实践"></a>使用实践</h1><blockquote><p><strong>注意:</strong><br>由于使用的是SonarQube CE(社区版)，因此不支持在IDE中上传分析数据，也不支持多分支(branch)分析。所以需要对这些方面做一些规范。</p></blockquote><p><br></p><p>SonarQube的使用主要分为两个方面:</p><ul><li><strong>开发者 IDE</strong></li><li><strong>CI SonarScanner</strong></li></ul><p><br></p><h2 id="CI"><a href="#CI" class="headerlink" title="CI"></a>CI</h2><p>CI端 需先安装 <code>SonarQube Scanner</code> 应用程序，并配置相应的路径和token。</p><p>由于社区版的缘故，我只对测试分支的CI进行SonarScanner分析，并将结果上传到SonarQube Server对应项目的路径。</p><p>由于测试分支(stage)的代码都是由开发者现在本地IDE中检测过代码质量(Code Quality)之后才MR过来，所以这样更方便和实用些。</p><p>CI SonarScanner分析上传之后，SonarQube会通知项目负责人此项目代码相关情况。由项目负责人去SonarQube Web UI上再去核查相关issues，核查无误之后，才能将测试分支的代码上线。<br>如果项目负责人检查出相关代码的某些问题，请于相关分支开发者交流，叮嘱他们现在本地IDE自测，通过之后在MR代码。</p><p><br><br><br></p><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>只需在IDE中下载SonarLint插件，并配置上运维人员提供的地址和token就可以使用了。</p><p>由于社区版的缘故，我这里让<strong>开发者自己的分支</strong>在IDE中调用远程SonarQube进行本地代码质量检查，并不需要将开发者的分支代码情况上传到SonarQube Server端。</p><p>开发者自己检查和核对自己分支的代码质量，确认之后才将自己的代码MR到dev分支。<br>如果项目负责人检测到某位开发者的分支代码存在问题，则这个责任由分支开发者负责和处理。</p><p><br><br><br></p><h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><p>权限有一些地方需要注意:</p><ul><li>将项目设置为私有(默认: public)</li><li>项目对应项目组(group)，对应项目成员(user)</li><li>项目组中的CI, IDE用户具有不同的权限</li><li>…</li></ul><p><br></p><p>具体配置可以在使用的时候灵活修改！</p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>可通过SonarQube API 进行许多操作。</p><p><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如导出python的代码规则</span></span><br><span class="line">curl -X GET -v -u user:passwd  http://localhost:9000/api/rules/search?language=python &gt; python.json</span><br></pre></td></tr></table></figure><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h1><ul><li>docs: <a href="https://docs.sonarqube.org/display/SCAN" target="_blank" rel="noopener">https://docs.sonarqube.org/display/SCAN</a></li></ul><p>建议将SonarQube Scanner用作使用SonarQube分析项目的默认扫描程序。</p><p><br></p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p><br></p><h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><p>平台:</p><ul><li>Linux</li><li>Mac OS</li><li>Windows</li></ul><p><br></p><p>下载对应平台的Sonar Scanner应用程序，将它们解压之后加入系统路径(<code>$PATH</code>)。</p><p><br><br><br><br><br></p><h3 id="IDE-1"><a href="#IDE-1" class="headerlink" title="IDE"></a>IDE</h3><p>Sonar Scanner 支持的 IDE 有:</p><ul><li>MSBuild</li><li>Maven</li><li>Gradle</li><li>Ant</li><li>Jenkins</li><li>JetBrains</li></ul><p><br></p><p>在IDE中下载<strong>SonarLint</strong>插件，之后配置SonarQube Server地址和管理员给的Token便可以正常使用。<br>社区版的SonarQube 只能在IDE中检测，无法上传。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub: &lt;a href=&quot;https://github.com/SonarSource/sonarqube&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SonarSource/sonarqube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Website: &lt;a href=&quot;https://www.sonarqube.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.sonarqube.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docs: &lt;a href=&quot;https://docs.sonarqube.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.sonarqube.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RHEL7x86_64&lt;/li&gt;
&lt;li&gt;SonarQube v7.6&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="SonarQube" scheme="https://zhang21.github.io/tags/SonarQube/"/>
    
      <category term="Static Analysis" scheme="https://zhang21.github.io/tags/Static-Analysis/"/>
    
      <category term="Code Quality" scheme="https://zhang21.github.io/tags/Code-Quality/"/>
    
  </entry>
  
  <entry>
    <title>DevOps</title>
    <link href="https://zhang21.github.io/2019/02/13/DevOps/"/>
    <id>https://zhang21.github.io/2019/02/13/DevOps/</id>
    <published>2019-02-12T21:22:15.000Z</published>
    <updated>2019-03-19T01:05:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考:</p><ul><li>维基百科</li><li>GitLab</li><li>GitHub</li></ul><p><br><br><br></p><hr><a id="more"></a><p><br><br><br></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>DevOps</strong>（Development和Operations的组合词）是一种重视 <em>软件开发人员（Dev）</em> 和 <em>IT运维技术人员（Ops）</em> 之间沟通合作的文化、运动或惯例。透过自动化 <em>软件交付</em> 和 <em>架构变更</em> 的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p><p><img src="/images/DevOps/DevOps.png" alt></p><p><img src="/images/DevOps/devops-loop-and-spans-small.png" alt></p><p><br><br><br></p><hr><p><br><br><br></p><h1 id="Auto-DevOps"><a href="#Auto-DevOps" class="headerlink" title="Auto DevOps"></a>Auto DevOps</h1><p>GitLab Auto DevOps:</p><ul><li>Auto Build</li><li>Auto Test</li><li>Auto Code Quality</li><li>Auto SAST (Static Application Security Testing)</li><li>Auto Dependency Scanning</li><li>Auto License Management</li><li>Auto Container Scanning</li><li>Auto Review Apps</li><li>Auto DAST (Dynamic Application Security Testing)</li><li>Auto Deploy</li><li>Auto Browser Performance Testing</li><li>Auto Monitoring</li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="DevOps工具"><a href="#DevOps工具" class="headerlink" title="DevOps工具"></a>DevOps工具</h1><p>下面介绍一些DevOps需要用到的工具，可能不够详细。</p><p><br></p><h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><p>IaaS:</p><ul><li>VMware</li><li>Xen</li><li>KVM</li><li>OpenStack</li><li>云平台</li><li>…</li></ul><p><br><br><br></p><h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><p>Task:</p><ul><li>RedaMine</li><li>Jira</li><li>禅道</li><li>…</li></ul><p><br><br><br></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Code:</p><ul><li>git</li><li>GitLab</li><li>Gogs</li><li>svn</li><li>云平台</li><li>…</li></ul><p><br><br><br></p><h2 id="持续集成-发布"><a href="#持续集成-发布" class="headerlink" title="持续集成/发布"></a>持续集成/发布</h2><p>CI/CD:</p><ul><li>Jenkins</li><li>Jenkins X</li><li>GitLab CICD</li><li>Bamboo</li><li>Maven</li><li>云平台</li><li>…</li></ul><p><br><br><br></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Container:</p><ul><li>Docker</li><li>K8s</li><li>CoreOS</li><li>Mesos</li><li>Helm</li><li>云平台</li><li>…</li></ul><p><br><br><br></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Test:</p><ul><li><strong>Selenium</strong></li><li><strong>Katalon Studio</strong></li><li><strong>Watir</strong></li><li><strong>Jmeter</strong></li><li><strong>Loadrunner</strong></li><li><strong>LOCUST</strong></li></ul><p><br></p><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><ul><li>Website: <a href="https://www.seleniumhq.org/" target="_blank" rel="noopener">https://www.seleniumhq.org/</a></li></ul><p>Selenium是一个用于自动化测试Web apps的可移植框架。 Selenium提供了一种用于创作功能测试的回放工具，无需学习测试脚本语言。</p><p><br><br><br></p><h3 id="Katalon-Studio"><a href="#Katalon-Studio" class="headerlink" title="Katalon Studio"></a>Katalon Studio</h3><ul><li>Wetsite: <a href="https://www.katalon.com/" target="_blank" rel="noopener">https://www.katalon.com/</a></li></ul><p>Simplify API, Web, Mobile Automation Tests.</p><p><br><br><br></p><h3 id="Watir"><a href="#Watir" class="headerlink" title="Watir"></a>Watir</h3><ul><li>Website: <a href="http://watir.com/" target="_blank" rel="noopener">http://watir.com/</a></li></ul><p>An open source Ruby library for automating tests.<br>Watir interacts with a browser the same way people do: clicking links, filling out forms and validating text.</p><p><br><br><br></p><h3 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h3><p>Apache JMeter应用程序是开源软件，纯Java应用程序，旨在加载测试功能行为和测量性能。它最初是为测试Web应用程序而设计的，但后来扩展到其他测试功能。</p><p>Apache JMeter可用于测试静态和动态资源，Web动态应用程序的性能。<br>它可用于模拟服务器，服务器组，网络或对象上的重负载，以测试其强度或分析不同负载类型下的整体性能。</p><p><br></p><p>Apache JMeter功能包括:</p><ul><li>Ability to load and performance test many different applications/server/protocol types<ul><li>Web - HTTP, HTTPS (Java, NodeJS, PHP, ASP.NET, …)</li><li>SOAP / REST Webservices</li><li>FTP</li><li>Database via JDBC</li><li>LDAP</li><li>Message-oriented middleware (MOM) via JMS</li><li>Mail - SMTP(S), POP3(S) and IMAP(S)</li><li>Native commands or shell scripts</li><li>TCP</li><li>Java Objects</li></ul></li><li>Full featured Test IDE that allows fast Test Plan recording</li><li>CLI mode to load test from any Java compatible OS</li><li>Highly Extensible core</li><li>…</li></ul><p><br><br><br></p><h3 id="LoadRunner"><a href="#LoadRunner" class="headerlink" title="LoadRunner"></a>LoadRunner</h3><ul><li>Website: <a href="https://www.microfocus.com" target="_blank" rel="noopener">https://www.microfocus.com</a></li></ul><p>LoadRunner is a Load Testing Software</p><p><br><br><br></p><h3 id="LOCUST"><a href="#LOCUST" class="headerlink" title="LOCUST"></a>LOCUST</h3><ul><li>Website: <a href="https://locust.io/" target="_blank" rel="noopener">https://locust.io/</a></li><li>GitHub: <a href="https://github.com/locustio/locust/" target="_blank" rel="noopener">https://github.com/locustio/locust/</a></li></ul><p><br></p><p>An open source load testing tool.</p><p>Define user behaviour with Python code, and swarm your system with millions of simultaneous users.</p><p><br><br><br><br><br></p><h2 id="质量与安全"><a href="#质量与安全" class="headerlink" title="质量与安全"></a>质量与安全</h2><p>Quality and Security:</p><ul><li>infer</li><li>SonarQube</li><li>Cuckoo Sandbox</li><li>OWASP ZAProxy</li><li>Mobile-Security-Framework-MobSF</li><li>Clair</li></ul><p><br></p><h3 id="Infer"><a href="#Infer" class="headerlink" title="Infer"></a>Infer</h3><ul><li>GitHub: <a href="https://github.com/facebook/infer" target="_blank" rel="noopener">https://github.com/facebook/infer</a></li><li>Website: <a href="https://fbinfer.com/" target="_blank" rel="noopener">https://fbinfer.com/</a></li></ul><p><br></p><p><strong>Infer</strong> 是一个 <code>Java</code>，<code>C ++</code>，<code>Objective-C</code> 和 <code>C</code> 的代码静态分析工具。它会产生一个潜在的bug列表。任何人都可以使用Infer在发送给用户之前拦截关键错误，并帮助防止崩溃或性能不佳。</p><p>infer 主要用于 APP 端，也就是 Android/IOS App。</p><p><br><br><br></p><h3 id="SonarQube"><a href="#SonarQube" class="headerlink" title="SonarQube"></a>SonarQube</h3><ul><li>GitHub: <a href="https://github.com/SonarSource/sonarqube" target="_blank" rel="noopener">https://github.com/SonarSource/sonarqube</a></li><li>Website: <a href="https://www.sonarqube.org/" target="_blank" rel="noopener">https://www.sonarqube.org/</a></li></ul><p><br></p><p><strong>SonarQube</strong> 是一个开源平台，通过代码的自动化静态分析不断的检查代码质量。 SonarQube 支持20多种语言的分析，并在各种类型的项目中输出和存储问题。通过不同的插件对这些结果进行再加工处理，通过量化的方式度量代码质量的变化，从而可以方便地对不同规模和种类的工程进行代码质量管理。</p><p><br><br><br></p><h3 id="MobSF"><a href="#MobSF" class="headerlink" title="MobSF"></a>MobSF</h3><ul><li>GitHub: <a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF" target="_blank" rel="noopener">https://github.com/MobSF/Mobile-Security-Framework-MobSF</a></li></ul><p><br></p><p>Mobile Security Framework is an automated, all-in-one mobile application (Android/iOS/Windows) pen-testing framework capable of performing static analysis, dynamic analysis, malware analysis and web API testing.</p><p><br><br><br></p><h3 id="Clair"><a href="#Clair" class="headerlink" title="Clair"></a>Clair</h3><ul><li>GitHub: <a href="https://github.com/coreos/clair" target="_blank" rel="noopener">https://github.com/coreos/clair</a></li></ul><p>Vulnerability Static Analysis for Containers.<br>Clair is an open source project for the static analysis of vulnerabilities in application containers (currently including appc and docker).</p><p><br><br><br><br><br></p><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>Configuration Management:</p><ul><li>Ansible</li><li>ZooKeeper</li><li>CFEngine</li><li>Chef</li><li>MAAS</li><li>Puppet</li><li>SaltStack</li><li>Vagrant</li><li>Rundeck</li><li>Rudder</li><li>云平台</li><li>…</li></ul><p><br><br><br><br><br></p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>Data Analysis:</p><ul><li>Hadoop</li><li>Ambari</li><li>Avro</li><li>Flume</li><li>HBase</li><li>Hive</li><li>Spark</li><li>Sqoop</li><li>ZooKeeper</li></ul><p><br><br><br><br><br></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>Log:</p><ul><li>ElasticStack<ul><li>Elasticsearch</li><li>Logstash</li><li>Beat</li></ul></li><li>Hadoop, Hive - 与ELK类似的方案</li><li>Flume</li><li>Fluentd</li><li>Splunk</li><li>Kafka</li><li>Loggly</li><li>Papertrail</li><li>云平台</li><li>…</li></ul><p><br><br><br></p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>Stream:</p><ul><li>Kafka</li><li>Apex</li><li>Flink</li><li>Heron</li><li>Spark</li><li>Heka</li></ul><p><br><br><br></p><h2 id="Api网关"><a href="#Api网关" class="headerlink" title="Api网关"></a>Api网关</h2><p>Api Gateway:</p><ul><li>Gloo</li><li>Ambassador</li><li>Spring Cloud</li><li>Kong</li><li>Netflix Zuul</li><li>云平台</li><li>…</li></ul><p><br><br><br></p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>Performance:</p><ul><li>NetData</li><li>Pinpoint</li><li>Datadog</li><li>AppDynamics</li><li>Apache JMeter</li><li>ab(ApacheBench)</li><li>Gatling</li></ul><p><br><br><br></p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>Monitoring:</p><ul><li>Zabbix</li><li>Nagios</li><li>Prometheus</li><li>Grafana</li><li>Netdata</li><li>Graphite</li><li>Cacti</li><li>Glances</li><li>Collectd</li><li>Ganglia</li><li>Kibana</li><li>Sensu</li></ul><p><br><br><br></p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>Backup:</p><ul><li>全量</li><li>增量</li></ul><p><br><br><br></p><hr><p><br><br><br></p><h1 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h1><blockquote><p>ps:<br>参考百度百科!</p></blockquote><p><br></p><p>灰度发布（金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。<br>灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p><p>灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维基百科&lt;/li&gt;
&lt;li&gt;GitLab&lt;/li&gt;
&lt;li&gt;GitHub&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://zhang21.github.io/categories/DevOps/"/>
    
    
      <category term="自动化运维" scheme="https://zhang21.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
      <category term="运维开发" scheme="https://zhang21.github.io/tags/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/"/>
    
      <category term="Auto DevOps" scheme="https://zhang21.github.io/tags/Auto-DevOps/"/>
    
  </entry>
  
</feed>
