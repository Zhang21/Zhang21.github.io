<!DOCTYPE html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Docker," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="参考：  Docker文档:  https://docs.docker.com/ https://blog.csdn.net/sD7O95O/article/details/78623697 https://www.zhihu.com/question/22969309/answer/34030581  环境：  CentOS7x86_64 Docker v18.03">
<meta name="keywords" content="Docker">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="https://zhang21.github.io/2018/03/27/Docker/index.html">
<meta property="og:site_name" content="风继续吹">
<meta property="og:description" content="参考：  Docker文档:  https://docs.docker.com/ https://blog.csdn.net/sD7O95O/article/details/78623697 https://www.zhihu.com/question/22969309/answer/34030581  环境：  CentOS7x86_64 Docker v18.03">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://zhang21.github.io/images/Docker/engine-components-flow.png">
<meta property="og:image" content="https://zhang21.github.io/images/Docker/architecture.png">
<meta property="og:image" content="https://zhang21.github.io/images/Docker/laurel-docker-containers.png">
<meta property="og:image" content="https://zhang21.github.io/images/Docker/docker002.png">
<meta property="og:image" content="https://zhang21.github.io/images/Docker/docker003.png">
<meta property="og:image" content="https://zhang21.github.io/images/Docker/ingress-routing-mesh.png">
<meta property="og:image" content="https://zhang21.github.io/images/Docker/visualizer.png">
<meta property="og:image" content="https://zhang21.github.io/images/Docker/dockercloud.png">
<meta property="og:image" content="https://zhang21.github.io/images/Docker/types-of-mounts.png">
<meta property="og:image" content="https://zhang21.github.io/images/Docker/share_data_amon_machine.png">
<meta property="og:image" content="https://zhang21.github.io/images/Docker/container-layers.jpg">
<meta property="og:image" content="https://zhang21.github.io/images/Docker/sharing-layers.jpg">
<meta property="og:image" content="https://zhang21.github.io/images/Docker/aufs_layers.jpg">
<meta property="og:updated_time" content="2018-07-08T04:20:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker">
<meta name="twitter:description" content="参考：  Docker文档:  https://docs.docker.com/ https://blog.csdn.net/sD7O95O/article/details/78623697 https://www.zhihu.com/question/22969309/answer/34030581  环境：  CentOS7x86_64 Docker v18.03">
<meta name="twitter:image" content="https://zhang21.github.io/images/Docker/engine-components-flow.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zhang21.github.io/2018/03/27/Docker/"/>





  <title>Docker | 风继续吹</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风继续吹</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Yesterday, you said tomorrow!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhang21.github.io/2018/03/27/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhang21">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/leslie.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风继续吹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Docker</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-27T08:38:33+08:00">
                2018-03-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-07-08T12:20:00+08:00">
                2018-07-08
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DevOps/" itemprop="url" rel="index">
                    <span itemprop="name">DevOps</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/27/Docker/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/27/Docker/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  34,815
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>参考：</p>
<ul>
<li>Docker文档:  <a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></li>
<li><a href="https://blog.csdn.net/sD7O95O/article/details/78623697" target="_blank" rel="noopener">https://blog.csdn.net/sD7O95O/article/details/78623697</a></li>
<li><a href="https://www.zhihu.com/question/22969309/answer/34030581" target="_blank" rel="noopener">https://www.zhihu.com/question/22969309/answer/34030581</a></li>
</ul>
<p>环境：</p>
<ul>
<li>CentOS7x86_64</li>
<li>Docker v18.03</li>
</ul>
<p><br><br><br></p>
<a id="more"></a>
<hr>
<p><br></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Docker是一个开发、shipping、运行应用程序的开放平台。Docker使你能够将应用程序与基础架构(infrastructure)分离开，从而可以快速交付软件。借助Docker，你可以像管理应用程序一样管理基础架构。利用Docker的方法快速进行运输、测试和部署代码，可以显著缩短编写代码和在生存环境中运行代码之间的延迟。</p>
<p><br></p>
<h2 id="Docker平台"><a href="#Docker平台" class="headerlink" title="Docker平台"></a>Docker平台</h2><p>Docker提供了在称为容器的松散隔离(isolated)环境中 打包和运行应用程序的能力。隔离性和安全性允许你在给定的主机上同时运行多个容器。容器是轻量级(lightweight)的，因为它们不需要hypervisor的额外负载，而是直接使用主机的内核运行。这意味着，与使用虚拟机相比，你可以在给定的硬件组合上运行更多的容器。你甚至可以在虚拟主机中运行Docker容器。</p>
<p>Docker提供了工具和平台来管理容器的生命周期(lifecycle)：</p>
<ul>
<li>使用容器开发应用程序及其支持组件</li>
<li>容器成为分发和测试你应用程序的单元</li>
<li>准备好后，将你的应用程序部署到生产环境中，作为容器协调服</li>
</ul>
<p><br></p>
<h2 id="Docker引擎"><a href="#Docker引擎" class="headerlink" title="Docker引擎"></a>Docker引擎</h2><p>Docker引擎是一个包含如下部件的client-server应用程序：</p>
<ul>
<li>Server是称为守护进程的dockerd</li>
<li>REST API是指定程序可用于与守护进程进行通信并指示其执行操作的接口</li>
<li>Client是command line interface(CLI)</li>
</ul>
<p><img src="/images/Docker/engine-components-flow.png" alt=""></p>
<p>Docker的开源许可协议是Apache2.0</p>
<p><br></p>
<h2 id="能用Docker做什么"><a href="#能用Docker做什么" class="headerlink" title="能用Docker做什么"></a>能用Docker做什么</h2><p><strong>快速、一致的交付应用程序</strong></p>
<p>通过允许开发人员在 提供应用程序和服务的本地容器 的标准化环境 下工作，Docker简化了开发生命周期。容器非常适合<strong>持续集成(continuous intergration,CI)和持续交付(continuous deliver,CD)</strong>工作流程。</p>
<p>考虑如下示例场景：</p>
<ul>
<li>开发者在本地编写代码，并使用Docker容器分享工作给他们的同事</li>
<li>使用Docker将应用程序push到测试环境，并自动执行和手动测试</li>
<li>当开发人员发现bug，他们能在开发环境中修复bug，并重新部署应用程序到测试环境进行测试和验证</li>
<li>测试完成后，向客户提供修补的应用程序 与将更新的image push到生产环境一样简单</li>
</ul>
<p><br></p>
<p><strong>响应式部署和伸缩</strong></p>
<ul>
<li>Docker的基于容器的平台支持高度可移植的工作负载。Docker container可以运行在笔记本、物理机、虚拟机、云平台…</li>
<li>Docker的可移植性和轻量化特性也使得动态管理工作负载非常容易，可以近乎实时地按业务需求扩展或拆分应用程序和服务</li>
</ul>
<p><br></p>
<p><strong>在同一硬件上运行更多的工作负载</strong></p>
<p>Docker轻量且快速。它为基于hypersior的虚拟机提供了一种可行、经济高效的替代方案，因此你可以使用更多计算容量来实现业务目标。Docker是高密度环境和中小型部署的理想选择，你需要用更小的资源做更多的事情。</p>
<p><br></p>
<h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><p>Docker使用了client-server的体系架构。客户端向守护进程发送消息，守护进程负责构建、运行和分发 Docker容器。客户端和守护进程可以在同一系统上运行，也可将客户端连接到远程的Docker守护进程。客户端和守护进程使用REST API，通过Unix socket或network interface进程通信。</p>
<p><img src="/images/Docker/architecture.png" alt="Docker架构图"></p>
<p><br></p>
<h3 id="Docker-daemon"><a href="#Docker-daemon" class="headerlink" title="Docker daemon"></a>Docker daemon</h3><p>Docker daemon(<code>dockerd</code>)，监听Docker API请求并管理Docker对象——image、container、network、volume。<br>docker daemon还可与其它docker daemon通信来管理docker service。</p>
<p><br></p>
<h3 id="Docker-client"><a href="#Docker-client" class="headerlink" title="Docker client"></a>Docker client</h3><p>Docker client(<code>docker</code>)是许多Docker用户与Docker进行交互的主要方式。客户端将命令发送给守护进程，守护进程执行命令。<br>Docker命令使用Docker API，Docker客户端可与多个守护进程进行通信。</p>
<p><br></p>
<h3 id="Docker-registry"><a href="#Docker-registry" class="headerlink" title="Docker registry"></a>Docker registry</h3><p>Docker registry存储Docker image。Docker Hub和Docker Cloud是任何人都可使用的public registry，你可以创建private registry。</p>
<p><code>docker pull</code>或<code>docker run</code>需要的image便是从配置的registry中提取。<code>docker push</code>推送image到你配置的registry。</p>
<p><br></p>
<h2 id="Docker对象"><a href="#Docker对象" class="headerlink" title="Docker对象"></a>Docker对象</h2><p>当你使用Docker时，你会创建和使用 image、container、network、volume、plugin和其它对象。</p>
<p><br></p>
<h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>镜像是一个只读模板，带有创建Docker容器的说明。通常，镜像基于其它镜像，并具有一些额外的自定义功能。<br>例如，你可构建基于Ubuntu镜像的镜像，但会按照ApacheWeb服务器和应用程序，以及应用程序所需的配置。</p>
<p>你可能创建自己的镜像，或使用由别人创建并推送到registry上的镜像。构建自己的镜像，需要使用简单的语法创建一个Dockerfile，以定义创建镜像并运行它所需的步骤。</p>
<p><br></p>
<h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><p>容器是镜像的可运行实例。可将容器连接到一个或多个网络，将存储器连接到它，还可根据当前状态创建新镜像。</p>
<p>默认情况下，容器与其它容器以及主机是相对隔离的。你可以控制容器的网络、存储、其它底层子系统与其它容器或主机的隔离程度。</p>
<p>容器由镜像定义，以及你在创建或启动时提供给它的任何配置选项。当一个容器被移除时，其未被存储在永久存储器中的状态会消失。</p>
<p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#运行一个Ubuntu镜像，交互地连接到本地命令会话</span><br><span class="line"></span><br><span class="line">docker run -i -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>以上命令会发生如下步骤:</p>
<ol>
<li>如果本地没有Ubuntu镜像，docker会从registry拉取，就好像你手动运行 <code>docker pull ubuntu</code></li>
<li>Docker创建一个新容器，就好像你手动执行<code>docker container create</code></li>
<li>Docker分配一个读写文件系统给容器，作为它的最后一层</li>
<li>如果你没有指定任何网络选项，Docker会创建一个网络接口将容器连接到默认网络。</li>
<li>Docker开启容器并执行/bin/bash</li>
<li>发送<code>exit</code>到<code>/bin/bash</code>，容器停止但并未被移除</li>
</ol>
<p><br></p>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>服务允许你伸缩多个Docker守护进程的容器，这些守护进程可以作为一个swarm与多个manager和worker一起工作。默认情况下，该服务在所有node之间进行负载均衡。</p>
<p><br></p>
<h3 id="底层技术"><a href="#底层技术" class="headerlink" title="底层技术"></a>底层技术</h3><p>Docker使用GO编写，利用Linux内核的几个特性来提供其功能。</p>
<p><br></p>
<p><strong>namespace</strong></p>
<p>Docker使用一个称为<code>namespace</code>的技术来提供称为容器的独立工作空间。当你运行一个容器时，Docker会为该容器创建一组命名空间。<br>命名空间提供了一个隔离层。容器的每个方面都在单独<code>namespace</code>中运行，并且其访问权限仅限于该单独的<code>namespace</code>。</p>
<p>Docker引擎在Linux上使用如下<code>namespace</code>：</p>
<ul>
<li><code>pid</code> namespace： 进程隔离</li>
<li><code>net</code> namespace： 管理网络接口</li>
<li><code>ipc</code> namespace： 管理对IPC(InterProcess Communication)资源的访问</li>
<li><code>mnt</code> namespace： 管理文件系统挂载点</li>
<li><code>ust</code> namespace： 隔离内核和版本标识符(Unix Timesharing System)</li>
</ul>
<p><br></p>
<p><strong>control groups</strong></p>
<p>Linux上的Docker Engine也依赖与另一种称为控制组(cgroups)的技术。cgroup将应用程序限制为一组特定的资源。控制组允许Docker引擎将可用的硬件资源共享给容器，并可选地强制实施限制和约束。<br>例如，你可限制特定容器的内存是CPU使用率等。</p>
<p><br></p>
<p><strong>union file systems</strong></p>
<p>union file systems(UnionFS)，是通过创建layer进行操作的文件系统，使得它们非常轻量和快速。Docker引擎使用UnioFS为容器提供构建block。Docker引擎可以使用多种UnionFS变体，包括AUFS, brrfs, vfs, DeviceMapper…</p>
<p><br></p>
<p><strong>container format</strong></p>
<p>Docker引擎将namespace、cgroup、UnionFS组合成一个名为容器格式的包装器。默认的容器格式为<code>libcontainer</code>。</p>
<p><br><br><br></p>
<hr>
<p><br></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Docker有两个可获取的版本：</p>
<ul>
<li>Community Edition(CE)<ul>
<li>适合开始使用Docker并尝试基于容器的应用程序的开发人员和小型团队</li>
</ul>
</li>
<li>Enterprise Edition(EE)<ul>
<li>专为企业开发和IT团队而设计，可以在生产规模上构建，发布和运行关键业务应用程序</li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<h2 id="CentOS7安装Docker-CE"><a href="#CentOS7安装Docker-CE" class="headerlink" title="CentOS7安装Docker CE"></a>CentOS7安装Docker CE</h2><h3 id="OS要求"><a href="#OS要求" class="headerlink" title="OS要求"></a>OS要求</h3><ul>
<li>CentOS7.x</li>
<li><code>centos-extras</code> repository</li>
<li>推荐使用<code>overlay2</code>存储驱动</li>
<li>安装新版本Docker需卸载老版本Docker</li>
<li>Docker CE包被称为<code>docker-ce</code></li>
</ul>
<p><br></p>
<h3 id="安装Docker-CE"><a href="#安装Docker-CE" class="headerlink" title="安装Docker CE"></a>安装Docker CE</h3><ul>
<li><a href="https://download.docker.com/" target="_blank" rel="noopener">https://download.docker.com/</a></li>
</ul>
<p>多种安装方法：</p>
<ul>
<li>Docker’s repository</li>
<li>RPM package</li>
<li>scripts</li>
</ul>
<p><br></p>
<p><strong>使用repository安装：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#安装依赖</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#设置repository</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#安装Docker CE</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"></span><br><span class="line"> <span class="comment">#Docker安装但未启动，docker group会被创建，但没有用户添加到组中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#在生产环境中，你可能需要安装特定版本的Docker CE，而不是最新版</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line">yum search docker-ce --showduplicates</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#开启docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#测试docker</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"> <span class="comment">#此命令下载一个测试image并将其运行到container中</span></span><br><span class="line"> <span class="comment">#Hello from Docker!</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>使用package安装：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#下载rpm包</span></span><br><span class="line">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#安装</span></span><br><span class="line">yum install -y /path/docker-cexxx.rpm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>使用scripts安装：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line"></span><br><span class="line">sh get-docker.sh</span><br><span class="line"></span><br><span class="line"> <span class="comment">#手动添加group合user</span></span><br><span class="line">usermod -aG docker your-user</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="卸载Docker-CE"><a href="#卸载Docker-CE" class="headerlink" title="卸载Docker CE"></a>卸载Docker CE</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker-ce</span><br><span class="line"></span><br><span class="line"> <span class="comment">#默认文件</span></span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line"> <span class="comment">#你还需要手动删除其它配置文件</span></span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<hr>
<p><br></p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p><br><br><br></p>
<h2 id="关于Docker"><a href="#关于Docker" class="headerlink" title="关于Docker"></a>关于Docker</h2><p>Docker文档会有如下讲解：</p>
<ul>
<li>设置你的Docker环境</li>
<li>在一个容器(container)中构建并运行一个镜像</li>
<li>延伸你的APP以便在多个容器中运行</li>
<li>在整个集群中分配你的APP</li>
<li>通过添加后端数据库来堆栈服务</li>
<li>将应用部署到生产</li>
</ul>
<p><br></p>
<h3 id="Docker的概念"><a href="#Docker的概念" class="headerlink" title="Docker的概念"></a>Docker的概念</h3><p>Docker是开发人员，系统管理员使用容器来开发、部署和运行APP的平台。使用Linux容器来部署APP被称为<strong>集装箱化(containerzation)</strong></p>
<p><img src="/images/Docker/laurel-docker-containers.png" alt=""></p>
<p>集装箱受欢迎的几点原因：</p>
<ul>
<li>灵活(flexible)</li>
<li>轻量(lightweight)</li>
<li>通用(Interchangeable)</li>
<li>可移植(portable)</li>
<li>延伸(scalable)</li>
<li>堆栈(stackable)</li>
</ul>
<p><br></p>
<h3 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h3><p>通过运行镜像(image)启动容器(container)。镜像是一个可执行包，包含运行APP所需的所有内容：代码，库，环境变量，配置文件…</p>
<p>容器是镜像的运行时(runtime)实例。在Linux上使用<code>docker ps</code>命令查看运行的容器列表。</p>
<p><br></p>
<h3 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h3><p>容器在Linux本地上运行，并与其它容器共享主机Kernel。它是一个独立的进程，不占其它可执行文件内存，使其轻量化。</p>
<p>虚拟机(VM)运行一个完整的访客操作系统，通过虚拟机管理程序访问主机资源。一般来说，虚拟机比大多数应用程序需要的资源更多。</p>
<p><img src="/images/Docker/docker002.png" alt=""></p>
<p><br><br><br></p>
<h3 id="准备Docker环境"><a href="#准备Docker环境" class="headerlink" title="准备Docker环境"></a>准备Docker环境</h3><p>Docker版本：</p>
<ul>
<li>CE: Docker Community Edition</li>
<li>EE: Docker Enterprise Edition</li>
</ul>
<p><a href="#安装Docker">Install Docker</a></p>
<p><br></p>
<h2 id="测试Docker"><a href="#测试Docker" class="headerlink" title="测试Docker"></a>测试Docker</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看详细信息</span></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试安装工作是否正常</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看镜像</span></span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出容器</span></span><br><span class="line">docker container ls -all</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker命令</span></span><br><span class="line">docker</span><br><span class="line">docker container --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>集装箱化使得<strong>CI/CD</strong>无缝：</p>
<ul>
<li>持续集成(Continuous integration, CI)</li>
<li>持续部署(continuous deployment, CD)</li>
<li>APP无系统依赖</li>
<li>更新能够推送到分布式APP的任何部分</li>
<li>资源密度可以被优化</li>
</ul>
<p>使用Docker，扩展APP的过程就是启动新的可执行文件，而不是运行繁重的VM主机。</p>
<p><br><br><br></p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Container</p>
<p><br></p>
<h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>是时候使用Docker方式来构建一个APP了。</p>
<ul>
<li>从应用程序的层次结构底部开始，这是一个容器(container)</li>
<li>在此级别之上，是一个服务(service)，它定义了容器在生产中的表现</li>
<li>最后，顶层是堆栈(stack)，定义所有服务的交互(interaction)</li>
</ul>
<p>Like this:</p>
<ul>
<li>Stack</li>
<li>Service</li>
<li>Container</li>
</ul>
<p><br></p>
<h3 id="新开发环境"><a href="#新开发环境" class="headerlink" title="新开发环境"></a>新开发环境</h3><p>在过去，如果你要开始编写一个Python APP，你的第一要务是在你的机器运行时安装Python。但是，这会造成你的计算机上的环境，需要如预期般完美适合你的APP，并且还需要与你的生产环境相匹配。</p>
<p>使用Docker，你可以将一个可移植的Python运行时作为一个image，无需安装。接着，你的构建可以将基础Python image与APP代码一起包含在内，确保你的APP，依赖项…都构建一起。</p>
<p><br></p>
<h3 id="使用Dockerfile定义一个容器"><a href="#使用Dockerfile定义一个容器" class="headerlink" title="使用Dockerfile定义一个容器"></a>使用<code>Dockerfile</code>定义一个容器</h3><p><code>Dockerfile</code>定义了容器内环境中发生的事情。访问的网络接口(network interface)和磁盘驱动(disk driver)等资源是在此环境中虚拟化的(virtualized)，与系统其余部分隔离。因此你需要将端口映射(map port)到外部世界，并明确指定要将哪些文件<strong>复制</strong>到此环境中。但是，在完成这些后，你完全可以将它们看做一致 —— 在<code>Dockerfile</code>中定义的构建的APP的行为与它运行时的行为完全相同。</p>
<p><strong>Dockerfile</strong></p>
<p>创建一个空目录，并创建一个名叫<code>Dockerfile</code>的文件，复制以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to /app</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at /app</span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>
<p>注意代理服务器会阻断你与APP的连接！</p>
<p>这个<code>Dockerfile</code>引用了一些我们还没有创建的文件，分别是<code>app.py</code>和<code>requirements.txt</code>。接下来创建它们。</p>
<p><br></p>
<h3 id="APP自身"><a href="#APP自身" class="headerlink" title="APP自身"></a>APP自身</h3><p>创建另外的文件，如上面的<code>app.py</code>和<code>requirements.txt</code>，并将它们与<code>Dockerfile</code>放置于同一目录下。这就完成了我们的APP，这看起来非常简单。当这个<code>Dockerfile</code>被构建成一个image时，由于<code>Dockerfile</code>的<code>ADD</code>命令，<code>app.py</code>和<code>requirements.txt</code>仍然存在，而且由于使用了EXPOSE命令，<code>app.py</code>的输出仍可以通过HTTP访问。</p>
<p><strong>requirements.txt: </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure>
<p><strong>app.py: </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在容器内访问主机的名称将检索容器ID，这进程ID类似。</p>
</blockquote>
<p>仅此而已，在你的系统中，你不需要任何Python或requirements.txt文件，也不需要在你的系统上安装 构建或运行的image。看起来你并没有真正用Python和Flask建立一个环境，但是你确实已经拥有了。</p>
<p><br></p>
<h3 id="构建APP"><a href="#构建APP" class="headerlink" title="构建APP"></a>构建APP</h3><p>我们准备去构建(build)APP。确保你仍在目录的顶层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#查看是否还在顶层</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">Dockerfile		app.py			requirements.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在此目录运行build命令，这将创建一个Docker image，用 -t 命名</span><br><span class="line">docker build -t friendlyhello .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看你build的image</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">friendlyhello       latest              b24e21d7645f        13 minutes ago      150MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#运行APP</span><br><span class="line">docker run -p 4000:80 friendlyhello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#测试</span><br><span class="line">curl http://localhost:4000</span><br><span class="line">links http://localhost:4000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在后台运行</span><br><span class="line">docker run -d -p 4000:80 friendlyhello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看容器</span><br><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">146662dca737        friendlyhello       &quot;python app.py&quot;     16 seconds ago      Up 16 seconds       0.0.0.0:4000-&gt;80/tcp   goofy_chaplygin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#停止</span><br><span class="line">Ctrl + C</span><br><span class="line">docker container stop docker-ID</span><br><span class="line">docker container stop 146662dca737</span><br></pre></td></tr></table></figure>
<p><img src="/images/Docker/docker003.png" alt="效果图"></p>
<p><br></p>
<p>端口重映射<code>4000:80</code>是为了证明Dockerfile中的EXPOSE与使用<code>docker run -p</code>发布的内容之间的区别。<br>在后续步骤中，我们只需将主机的80端口映射到容器的80端口就好。</p>
<p><br></p>
<h3 id="分享你的image"><a href="#分享你的image" class="headerlink" title="分享你的image"></a>分享你的image</h3><p>为了演示刚才创建的image的可移植性(portability)，让我们上传build的image并在其它地方run它。毕竟，当你需要将container部署到生产环境时，你需要知道如何push注册。</p>
<p>注册表(registry)是一个repository的集合，而repository是image的集合——有点类似于GitHub repository，但代码是已经构建了的。<br>注册表上的账户可以创建许多repository。docker CLI 默认使用Docker’s public registry。你也可以选择其它注册表，或创建自己的注册表。</p>
<p><br></p>
<p><strong>使用Docker ID登录：</strong></p>
<p>如果没有Docker账户，请先注册 <cloud.docker.com>。</cloud.docker.com></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br><span class="line"></span><br><span class="line">docker login -u zhang21</span><br><span class="line"></span><br><span class="line">#时候docker login认证过后，会有~/.docker/config.json文件，里面包含了docker认证信息</span><br><span class="line">#k8s可使用此信息添加secret</span><br><span class="line"></span><br><span class="line">cat ~/.docker/config.json</span><br><span class="line">&#123;</span><br><span class="line">        &quot;auths&quot;: &#123;</span><br><span class="line">                &quot;https://index.docker.io/v1/&quot;: &#123;</span><br><span class="line">                        &quot;auth&quot;: &quot;base64encoding&quot;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;HttpHeaders&quot;: &#123;</span><br><span class="line">                &quot;User-Agent&quot;: &quot;Docker-Client/18.03.1-ce (linux)&quot;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>标记image：</strong></p>
<p>使用<code>username/repository:tag</code>将本地image与registry中的repository相关联。tag是可选的，但推荐使用tag。因为它是注册管理机构用于为Docker image提供版本的机制。为该内容提供一个有意义的repository和tag，例如<code>get-started:part2</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker tag image username/repository:tag</span><br><span class="line"></span><br><span class="line">#例子</span><br><span class="line">docker tag friendlyhello zhang/test:tag-test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看tag</span><br><span class="line">docker images ls</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>发布image：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#上传你标记了的image到repository</span><br><span class="line">docker push username/repository:tag</span><br><span class="line"></span><br><span class="line">docker push zhang21/test:tag-test</span><br><span class="line"></span><br><span class="line">#完成后，此image便可以公开获取</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>从远处repository拉取并运行image：</strong></p>
<p>无论在哪里执行<code>docker run</code>，它都会将你的image以及Python和所有依赖关系一起拉取下来，并运行你的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 username/repository:tag</span><br><span class="line"></span><br><span class="line">docker run -p 80:80 zhang21/test:tag-test</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="本节基础命令"><a href="#本节基础命令" class="headerlink" title="本节基础命令"></a>本节基础命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从Dockerfile创建image</span></span><br><span class="line">docker build -t image-name .</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行image</span></span><br><span class="line">docker run -p 4000:80 image-name</span><br><span class="line"></span><br><span class="line"><span class="comment">#后台运行</span></span><br><span class="line">docker run -d -p 4000:80 image-name</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出运行的容器</span></span><br><span class="line">docker container ls</span><br><span class="line"><span class="comment">#列出所有容器，包括未运行</span></span><br><span class="line">docker container ls -a</span><br><span class="line"></span><br><span class="line"><span class="comment">#优雅停止容器</span></span><br><span class="line">docker container stop 容器ID</span><br><span class="line"><span class="comment">#强制停止</span></span><br><span class="line">docker container <span class="built_in">kill</span> 容器ID</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除容器</span></span><br><span class="line">docker container rm 容器ID</span><br><span class="line"><span class="comment">#删除所有容器</span></span><br><span class="line">docker container rm $(docker container ls -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出镜像</span></span><br><span class="line">docker image ls</span><br><span class="line"><span class="comment">#列出所有镜像</span></span><br><span class="line">docker image ls -a</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除镜像</span></span><br><span class="line">docker image rm 镜像ID</span><br><span class="line"><span class="comment">#删除所有镜像</span></span><br><span class="line">docker image rm $(docker image ls -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment">#登录</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment">#标记</span></span><br><span class="line">docker tag 镜像 username/repository:tag</span><br><span class="line"></span><br><span class="line"><span class="comment">#上传到注册表</span></span><br><span class="line">docker push username/repository:tag</span><br><span class="line"></span><br><span class="line"><span class="comment">#从注册表拉取</span></span><br><span class="line">docker run username/repository:tag</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>service</p>
<p><br></p>
<h3 id="先决条件-1"><a href="#先决条件-1" class="headerlink" title="先决条件"></a>先决条件</h3><ul>
<li>安装Docker</li>
<li>获取Docker Compose</li>
<li>阅读Orientation</li>
<li>阅读Container</li>
<li>确保已发布friendlyhello image到你的registry</li>
<li>确保你的image工作为一个部署的container。<code>docker run -p 80:80 username/repo:tag</code></li>
</ul>
<p><br></p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>在此，我们<strong>扩展(scale)</strong>APP并启用<strong>负载均衡(load balancing)</strong>。要做到这样，我们必须在分布式(distributed)应用程序的层次结构中升一级: 服务</p>
<ul>
<li>Stack</li>
<li>Service</li>
<li>Container</li>
</ul>
<p><br></p>
<h3 id="关于服务"><a href="#关于服务" class="headerlink" title="关于服务"></a>关于服务</h3><p>在分布式应用程序中，应用程序的不同部分称为服务(service)。</p>
<p>例如，一个视频共享站点。那么它可能包含：</p>
<ul>
<li>用于将应用程序数据 存储到数据库中的服务</li>
<li>用户上传后的视频转码服务</li>
<li>前端服务</li>
<li>…</li>
</ul>
<p>服务是真正的生产环境中的容器。一个service只运行一个image，但它可修改image的运行方式 —— 哪个端口、容器应该运行多少个副本以便于服务所需的容量等.<br>伸缩服务会更改运行该软件的容器实例数量，从而为进程中的服务分配更多的计算资源。</p>
<p>在Docker平台上定义、运行和伸缩服务都是很简单的 —— 只需修改<code>docker-compose.yml</code>文件。</p>
<p><br></p>
<h3 id="你的第一个docker-compose-yml文件"><a href="#你的第一个docker-compose-yml文件" class="headerlink" title="你的第一个docker-compose.yml文件"></a>你的第一个<code>docker-compose.yml</code>文件</h3><p><code>docker-compose.yml</code>是一个YAML文件，它定义了Docker container在生产中的行为方式。</p>
<p><strong>docker-compose.yml：</strong></p>
<p>将如下信息保存为<code>docker-compose.yml</code>，确保你已经<code>pushed the image</code>到registry，并通过修改<code>.yml</code>文件的image detail来替换<code>username/repo:tag</code>。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line">    <span class="comment"># replace username/repo:tag with your name and image details</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">username/repo:tag</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">      resources:</span></span><br><span class="line"><span class="attr">        limits:</span></span><br><span class="line"><span class="attr">          cpus:</span> <span class="string">"0.1"</span></span><br><span class="line"><span class="attr">          memory:</span> <span class="number">50</span><span class="string">M</span></span><br><span class="line"><span class="attr">      restart_policy:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:80"</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">webnet</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  webnet:</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><code>docker-compose.yml</code>文件告诉Docker之下如下操作：</p>
<ul>
<li>pull the image</li>
<li>Run 5 instances of that image as a service called <code>web</code></li>
<li>限制每个实例最多使用10%的CPU和50MB的RAM</li>
<li>如果一个失败，马上重启container</li>
<li>映射主机的80端口到web的80端口</li>
<li>指示web container通过称为<code>webnet</code>的负载均衡网络共享80端口</li>
<li>使用默认设置定义<code>webnet</code>网络</li>
</ul>
<p><br></p>
<h3 id="运行你的负载均衡APP"><a href="#运行你的负载均衡APP" class="headerlink" title="运行你的负载均衡APP"></a>运行你的负载均衡APP</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行并设置APP名字</span></span><br><span class="line">docker stack -c docker-compose.yml app-name</span><br><span class="line"></span><br><span class="line">docker stack -c docker-compose.yml LoadBalance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在一个主机上，单个服务栈通过部署的image运行5个container instance</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取service ID</span></span><br><span class="line">docker service ls</span><br><span class="line"></span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                   PORTS</span><br><span class="line">3d1a48yse0t4        LoabBalance_web     replicated          5/5                 zhang21/<span class="built_in">test</span>:tag-test   *:80-&gt;80/tcp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看服务中的任务</span></span><br><span class="line">docker service ps app-name_web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker container ls -q</span><br><span class="line"></span><br><span class="line"><span class="comment">#5个容器ID</span></span><br><span class="line">c7ce0075890e</span><br><span class="line">52ba026bf28c</span><br><span class="line">6d4381be438f</span><br><span class="line">bd297a42e89d</span><br><span class="line">357b05cc38eb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#访问的时候容器ID会在此5个负载中变化</span></span><br></pre></td></tr></table></figure>
<p>在服务中运行的单个container称为任务(task)。任务是具有数字增量的唯一ID，最大数量是在<code>docker-compose.yml</code>中定义的副本数量。</p>
<p><br></p>
<h3 id="伸缩APP"><a href="#伸缩APP" class="headerlink" title="伸缩APP"></a>伸缩APP</h3><p>通过修改<code>docker-compose.yml</code>中<code>replicas</code>的值，并重新运行<code>docker stack deploy -c xxx app-name</code>来伸缩APP。</p>
<p>Docker执行就地更新，不需要stack down或kill any containers.</p>
<p><strong>卸下APP和swarm：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app</span></span><br><span class="line">docker stack rm app-name</span><br><span class="line"></span><br><span class="line">docker stack rm LoadBalance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#swarm</span></span><br><span class="line">docker swarm leave --force</span><br></pre></td></tr></table></figure>
<p>使用Docker扩展APP非常简单。</p>
<p><br></p>
<h3 id="本节命令"><a href="#本节命令" class="headerlink" title="本节命令"></a>本节命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出栈或APP</span></span><br><span class="line">docker stack ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行指定配置文件</span></span><br><span class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出与APP相关联的服务</span></span><br><span class="line">docker service ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出与APP相关联的任务</span></span><br><span class="line">docker service ps &lt;service&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查任务</span></span><br><span class="line">docker inspect &lt;task or container&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出容器ID</span></span><br><span class="line">docker container ls -q</span><br><span class="line"></span><br><span class="line"><span class="comment">#除掉APP</span></span><br><span class="line">docker stack rm &lt;appname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#从管理中除掉一个单一节点swarm</span></span><br><span class="line">docker swarm leave --force</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="swarm"><a href="#swarm" class="headerlink" title="swarm"></a>swarm</h2><p><br></p>
<h3 id="先决条件-2"><a href="#先决条件-2" class="headerlink" title="先决条件"></a>先决条件</h3><ul>
<li>前面几个小节的内容</li>
</ul>
<p><br></p>
<h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>前面你将一个服务运行在生产环境，并扩展为5个副本进程。</p>
<p>在此，你将APP部署到到集群上，并在多台机器上运行它。通过将多台主机连接到成为<strong>swarm</strong>的<strong>Dockerized</strong>集群，使得多容器、多主机应用成为可能。</p>
<p><br></p>
<h3 id="理解swarm集群"><a href="#理解swarm集群" class="headerlink" title="理解swarm集群"></a>理解swarm集群</h3><p>swarm是一组运行Docker并加入到集群中的机器。这样以后，你可以在集群的swarm manager上执行Docker命令。swarm中的机器可以是物理的或虚拟的，当他们加入swarm后，他们便被成为node。</p>
<p>swarm manager可以使用多种策略来运行容器，你可在compose file中指定相应的策略。</p>
<p>swarm manager是swarm中唯一可以执行命令、授权其他机器作为工作者加入swarm的机器。工作者(worker)只能在那提供能力(capacity)，并没有权力告诉任何机器能够做什么。</p>
<p>但目前为止，你已经在本机机器上以单主机(single host)模式使用Docker。但Docker也可以切换为swarm(集群)模式，这就是使用swarm的原因。立即启用swarm模式使得当前机器成为swarm manager。从此，Docker将运行在你管理的swarm上执行命令，而不仅仅是在当前机器上执行。</p>
<p><br></p>
<h3 id="建立swarm"><a href="#建立swarm" class="headerlink" title="建立swarm"></a>建立swarm</h3><p>一个swarm由多个节点组成，不管它是虚拟机还是物理机。</p>
<ul>
<li>基本概念很简单，运行<code>docker swarm init</code>来开启swarm模式并使得当前机器成为swarm manager</li>
<li>在其它机器上运行<code>docker swarm join</code>使他们作为worker加入swarm</li>
</ul>
<p><br></p>
<p><strong>栗子：</strong><br>使用VM快速创建两台机器的集群，并将其变为swarm。</p>
<p>使用<code>docker-machine</code>创建一对VM:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#CentOS7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装VirtualBox</span></span><br><span class="line">wget https://download.virtualbox.org/virtualbox/5.2.8/VirtualBox-5.2-5.2.8_121009_el7-1.x86_64.rpm &amp;&amp; yum install -y Virtual.xx.rpm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装docker-machine</span></span><br><span class="line"> curl -L https://github.com/docker/machine/releases/download/v0.14.0/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp; install /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在BIOS中开启虚拟化支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在VMware中开启虚拟化支持(如果是VM)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker-machine create --driver virtual myvm1</span><br><span class="line">docker-machine create --driver virtual myvm2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出虚拟机</span></span><br><span class="line">docker-machine ls</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>初始化swarm并添加node</strong></p>
<p>第一台机器作为swarm manager，执行命令和join认证，后面的机器作为worker。</p>
<p>你可以使用<code>docker-machine ssh</code>发送命令到VM。在<code>swarm mananger</code>上执行<code>docker swarm init</code>初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh &lt;swarm manager&gt; &quot;docker swarm init --advertise-assr &lt;mananger-IP&gt;&quot;</span><br><span class="line"></span><br><span class="line">#add worker</span><br><span class="line">docker swarm jion --toker &lt;token&gt; &lt;wroker-ip&gt;:&lt;port&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#添加manager</span><br><span class="line">docker swarm join-token manaer</span><br></pre></td></tr></table></figure>
<p><strong>由于我的虚拟的无法使用VT，因此我用的两台机器两个Docker来做swarm。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化这台机器默认为manager</span></span><br><span class="line">docker swarm init</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#作为worker加入，ip是manager的</span></span><br><span class="line"><span class="comment">#以下信息会在manager初始化时生成</span></span><br><span class="line"><span class="comment">#注意防火墙，可能会阻碍加入</span></span><br><span class="line"></span><br><span class="line">docker swarm join --toker &lt;toker&gt; &lt;ip:port&gt;</span><br><span class="line">docker swarm join --token SWMTKN-1-3vrbnuneu0hyu41evxlhbn5fp04ad5jvg9v5rzvdaedg2bghkt-e24mjnni3hu7782t3gkz0ny39 172.16.129.150:2377</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看swarm</span></span><br><span class="line">docker node ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#离开swarm</span></span><br><span class="line">docker swarm leave</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="在swarm集群上部署APP"><a href="#在swarm集群上部署APP" class="headerlink" title="在swarm集群上部署APP"></a>在swarm集群上部署APP</h3><p>主需要记住，只有swarm manager才能执行docker命令，worker仅仅是容量(capacity)。</p>
<p>在swarm manager上使用<code>docker-composr.yml</code>和<code>docker stack deploy</code>命令来部署APP。使用<code>docker  service ps &lt;service name&gt;</code>来验证部署。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#在manager部署</span><br><span class="line">docker stack deploy -c ./docker-compose.yml LoadBalance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker service ls</span><br><span class="line"></span><br><span class="line">docker stack ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#注意node名</span><br><span class="line">docker stack ps LoadBalance</span><br><span class="line"></span><br><span class="line">ID                  NAME                IMAGE                   NODE                DESIRED STATE       CURRENT STATE             ERROR               PORTS</span><br><span class="line">6nrn4mwc6pvt        LoadBalance_web.1   zhang21/test:tag-test   zhang22             Running             Preparing 2 minutes ago</span><br><span class="line">bpssrnzesl7n        LoadBalance_web.2   zhang21/test:tag-test   zhang22             Running             Preparing 2 minutes ago</span><br><span class="line">kmhd8p5wkc12        LoadBalance_web.3   zhang21/test:tag-test   zhang21             Running             Running 2 minutes ago</span><br><span class="line">i0pkf4foms87        LoadBalance_web.4   zhang21/test:tag-test   zhang22             Running             Preparing 2 minutes ago</span><br><span class="line">rvtpjk781frn        LoadBalance_web.5   zhang21/test:tag-test   zhang21             Running             Running 2 minutes ago</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#分别访问个主机的IP</span><br><span class="line">#创建的网络在它们之间共享并负载均衡</span><br><span class="line">links ip1</span><br><span class="line">links ip2</span><br></pre></td></tr></table></figure>
<p>两个IP地址工作的原因是集群中的节点参与入口(ingress)路由网络(routing mesh)。这可以确保部署在swarm中某个端口的服务始终将该端口保留给自己，而不管实际运行容器的节点是什么。</p>
<p><img src="/images/Docker/ingress-routing-mesh.png" alt="入口路由"></p>
<p><br></p>
<h3 id="清理并重启"><a href="#清理并重启" class="headerlink" title="清理并重启"></a>清理并重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack rm LoadBalance</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>先决条件，已完成前面的步骤。</p>
<p><br></p>
<h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>你已到达分布式应用程序层次结构的顶端——stack。堆栈是一组相互关联的服务，它们可以共享依赖关系，并可以进行协调和缩放。单个堆栈能够定义和协调整个应用程序的功能(尽管非常复杂的应用程序可能需要使用多个堆栈)。</p>
<p>在前面使用的<code>docker deploy</code>——是运行在单主机上的单个服务堆栈，这通常不会发生在生产环境中。在这里，你会使用学到的东西使多个服务相互关联，并在多台机器上运行它们。</p>
<p><br></p>
<h3 id="添加一个新服务并部署"><a href="#添加一个新服务并部署" class="headerlink" title="添加一个新服务并部署"></a>添加一个新服务并部署</h3><p>docker-compose2.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username/repo:tag with your name and image details</span><br><span class="line">    image: username/repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  #可视化</span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure>
<p>新增的东西使web对等服务，称为visualizer。注意两个事：</p>
<ul>
<li>volumes: 给予visualizer访问主机Docker的socket文件</li>
<li>placement： 确保服务运行在manager而不是worker上</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c ./docker-compose2.yml stack-test</span><br><span class="line"></span><br><span class="line">Creating network stack-test_webnet</span><br><span class="line">Creating service stack-test_visualizer</span><br><span class="line">Creating service stack-test_web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看visualizer，要等一会才能正常访问，别着急</span><br><span class="line">访问 IP:8080</span><br></pre></td></tr></table></figure>
<p><img src="/images/Docker/visualizer.png" alt=""></p>
<p><br></p>
<h3 id="持久化数据"><a href="#持久化数据" class="headerlink" title="持久化数据"></a>持久化数据</h3><p>让我们再次通过相同的工作流程来添加用于存储应用程序数据的Redis数据库。</p>
<p>docker-compose3.yml，添加一个Redis服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username/repo:tag with your name and image details</span><br><span class="line">    image: username/repo:tag</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/home/docker/data:/data&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    command: redis-server --appendonly yes</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#部署</span><br><span class="line">docker stack deploy -c docker-compose3.yml redis-test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#测试</span><br><span class="line">访问 IP:port</span><br></pre></td></tr></table></figure>
<p>Redis是一个Docker library中的官方image，并被授予redis镜像名称。</p>
<p>redis规范中有几件事使数据在这个堆栈的部署之间持续存在：</p>
<ul>
<li>redis运行在manager，所以它总是使用相同的文件系统</li>
<li>redis将数据存储在上面的目录</li>
<li>确保redis服务始终使用相同的主机</li>
<li>确保存储的数据的连续性</li>
</ul>
<p>如果没有创建，redis会将数据存储在容器文件系统的/data中，如果该容器被重新部署，则数据将被清除。</p>
<p><br><br><br></p>
<h2 id="部署APP"><a href="#部署APP" class="headerlink" title="部署APP"></a>部署APP</h2><p>先决条件为前面的操作步骤。</p>
<p><br></p>
<h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>compose file在生产环境中的效果与在您的计算机上的效果相同。</p>
<p><br></p>
<h3 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a>选择版本</h3><p>我安装的是社区版(ce)。如果你在生产环境中使用docker-ce，则可以使用Docker Cloud帮助管理你的应用程序，如AWS、Aliyun、腾讯云。<br>docker cloud： <cloud.docker.com>, 可注册后建立、上传、管理自己的repo。</cloud.docker.com></p>
<p>设置和部署：</p>
<ul>
<li>连接Docker Cloud并授权它自动为你配置Dockerize VM</li>
<li>使用Docker Cloud创建你的计算资源和swarm</li>
<li>部署应用程序</li>
</ul>
<p><br></p>
<h3 id="连接DockerCloud"><a href="#连接DockerCloud" class="headerlink" title="连接DockerCloud"></a>连接DockerCloud</h3><p>你可以标准模式或swarm模式运行Docker Cloud。</p>
<ul>
<li>AWS配置指南</li>
<li>Aliyun配置指南</li>
<li>腾讯云配置指南</li>
</ul>
<p><br></p>
<h3 id="创建swarm"><a href="#创建swarm" class="headerlink" title="创建swarm"></a>创建swarm</h3><p>你可在Docker Cloud UI创建你的node，或<code>docker swarm init|join</code>命令。</p>
<p><br></p>
<h3 id="在云提供商上部署应用程序"><a href="#在云提供商上部署应用程序" class="headerlink" title="在云提供商上部署应用程序"></a>在云提供商上部署应用程序</h3><p><img src="/images/Docker/dockercloud.png" alt="栗子"></p>
<p>我觉得阿里云和腾讯云也有对应的平台。</p>
<p>运行部署命令: <code>docker stack deploy -c xxx.yml &lt;cus_appname&gt;</code>，现在你的APP就运行在云提供商上。</p>
<p><strong>运行swarm命令来验证部署</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br><span class="line"></span><br><span class="line">docker service ls</span><br><span class="line"></span><br><span class="line">docker service ps &lt;service&gt;</span><br></pre></td></tr></table></figure>
<p><strong>在云提供商开放端口</strong></p>
<table>
<thead>
<tr>
<th>service</th>
<th>type</th>
<th>protocol</th>
<th>port</th>
</tr>
</thead>
<tbody>
<tr>
<td>web</td>
<td>http</td>
<td>tcp</td>
<td>80</td>
</tr>
<tr>
<td>visualizer</td>
<td>http</td>
<td>tcp</td>
<td>8080</td>
</tr>
<tr>
<td>redis</td>
<td>tcp</td>
<td>tcp</td>
<td>6379</td>
</tr>
</tbody>
</table>
<p>具体操作参见各云提供商。</p>
<p><br></p>
<h3 id="迭代和清理"><a href="#迭代和清理" class="headerlink" title="迭代和清理"></a>迭代和清理</h3><ul>
<li>改变<code>*.yml</code>文件伸缩应用程序</li>
<li>使用<code>docker stack deploy</code>部署应用程序</li>
<li>push和pull image</li>
<li>使用<code>docker stack rm &lt;name&gt;</code>清除stack</li>
</ul>
<p><br><br><br></p>
<h2 id="修改Docker默认路径"><a href="#修改Docker默认路径" class="headerlink" title="修改Docker默认路径"></a>修改Docker默认路径</h2><p>docker默认的目录为<code>/var/lib/docker</code>，但很多时候<code>/var</code>目录并没有单独挂载，可能导致空间不够。<br>前提是你已经把源配置目录对应的文件拷贝到替换的目录。</p>
<ul>
<li>方法1：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">cd /etc/docker</span><br><span class="line"></span><br><span class="line">vim daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	&quot;graph&quot;: &quot;/opt/docker&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line">#systemctl reload docker</span><br><span class="line"></span><br><span class="line">#查看变更</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li>方法2:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">cd /etc/sysconfig/</span><br><span class="line"></span><br><span class="line">vim docker-storage</span><br><span class="line"></span><br><span class="line">DOCKER_STORAGE_OPTIONS=--graph=/opt/docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">#查看变更</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="容器服务自启动"><a href="#容器服务自启动" class="headerlink" title="容器服务自启动"></a>容器服务自启动</h2><p>在运行docker容器时可以加如下参数来保证每次docker服务重启后容器也自动重启:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart=always -d -p 80:80 &lt;container-id&gt;</span><br><span class="line"></span><br><span class="line">#对于已启动的容器服务，更新它</span><br><span class="line">docker update --restart=always &lt;container-id&gt;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="交互式容器"><a href="#交互式容器" class="headerlink" title="交互式容器"></a>交互式容器</h2><p>进入Docker容器以获得交互式体验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;container-id&gt; /bin/bash</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="Docker日志"><a href="#Docker日志" class="headerlink" title="Docker日志"></a>Docker日志</h2><ul>
<li>docker服务日志：<ul>
<li><code>journalctl -u docker.service</code></li>
</ul>
</li>
<li>docker容器日志：<ul>
<li><code>&lt;docker-graph&gt;/containers/&lt;container-id&gt;/&lt;container-id&gt;-json.log</code></li>
<li>由于容器ID会变化，请注意提取容器ID</li>
<li>可使用ELK在此收集容器日志</li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<h2 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h2><p>使用<code>docker commit</code>从改变的容器中生成一个新镜像。</p>
<p>更新镜像步骤：</p>
<ol>
<li>备份镜像: <code>docker tag</code></li>
<li>运行镜像</li>
<li>修改容器</li>
<li>生成新镜像: <code>docker commit</code></li>
<li>推送镜像: <code>docker push</code></li>
</ol>
<p><br><br><br></p>
<h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><p><br></p>
<h3 id="备份容器"><a href="#备份容器" class="headerlink" title="备份容器"></a>备份容器</h3><ul>
<li><code>docker commit</code>: 生成新镜像</li>
<li><code>docker save</code>： 生成本地tar包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Usage:  docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">docker commit -m &quot;Just a test&quot; -p $&#123;container-id&#125; Zhang21/test:01</span><br><span class="line">docker image ls</span><br><span class="line">docker login</span><br><span class="line">docker push</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Usage:  docker save [OPTIONS] IMAGE [IMAGE...] [flags]</span><br><span class="line"></span><br><span class="line">docker save -o /path/$&#123;image&#125;.tar $&#123;image&#125;</span><br><span class="line">ls /path</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="恢复容器"><a href="#恢复容器" class="headerlink" title="恢复容器"></a>恢复容器</h3><ul>
<li><code>docker run ${image}</code></li>
<li><code>docker load</code>: 载入本地.tar镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage:  docker load [OPTIONS]</span><br><span class="line"></span><br><span class="line">docker load -i /path/$&#123;image&#125;.tar</span><br><span class="line">docker image ls</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="应用场景与注意事项"><a href="#应用场景与注意事项" class="headerlink" title="应用场景与注意事项"></a>应用场景与注意事项</h2><p><br></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>本地依赖</li>
<li>搭建环境</li>
<li>微服务</li>
<li>自动测试</li>
<li>部署过程</li>
<li>CI/CD</li>
<li>多租户环境</li>
<li>一台机器的多个APP</li>
<li>弹性伸缩</li>
<li>资源隔离</li>
</ul>
<p><br></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>一个进程，一个容器<br>不推荐在Docker容器中运行多个进程！</p>
</li>
<li><p>不要将数据存放到容器内<br>所以请使用挂在卷的方式映射到本地磁盘目录</p>
</li>
</ul>
<ul>
<li><p>使用磁盘进行数据存储</p>
</li>
<li><p>容器通信<br>每当一个Docker容器需要与另一个容器通信时，传递信息最好使用名称或环境变量。</p>
</li>
<li><p>以non-root用户运行Docker<br>默认情况下，Docker容器以root用户身份运行，众所周知，以root用户运行的容器完全可以控制主机系统。</p>
</li>
<li><p>注意容器的体积<br>选择一个容器的主要原因之一是它的体积小。但是，如果你把它做得更大，它的主要优势就没了。</p>
</li>
<li><p>制定控策略<br>开发和部署Docker容器不是你的工作的结束。您需要持续监控已部署的容器以及整个系统的运行状况。选择合适的工具并制定一个策略来有效地监控您的Docker容器，以确保最短的停机时间，从而使客户满意。</p>
</li>
<li><p>安全问题<br>安全补丁、防火墙…</p>
</li>
</ul>
<p><br><br><br></p>
<hr>
<p><br></p>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>参考:</p>
<ul>
<li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a></li>
</ul>
<p><br></p>
<p>将镜像每一层的修改、安装、配置、操作的命令写入Dockerfile，并用它来构建、定制镜像，那么镜像构建透明性问题便会得到解决。</p>
<p>Dockerfile是一个文本文件，包含了一条条指令(instrction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p><br><br><br></p>
<h2 id="使用Dockerfile定制镜像"><a href="#使用Dockerfile定制镜像" class="headerlink" title="使用Dockerfile定制镜像"></a>使用Dockerfile定制镜像</h2><p><br></p>
<h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>所谓指定镜像，就是以一个镜像为基础，在其上进行定制。基础镜像必须指定，而<code>FROM</code>就是指定<strong>基础镜像</strong>，因此一个<code>Dockerfile</code>中<code>FROM</code>是必备的指令，并且必须是第一条指令。</p>
<p>只有有可能，请使用当前官方repo作为你的基础镜像。我们推荐使用<strong>Alpine</strong>镜像，因为它严格控制，体积小(只有5MB)，同时也是完整的Linux发行版。</p>
<p>Docker Hub中有很多常用的官方镜像——常用软件、常用语言和常用系统镜像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#特殊镜像，scratch，空白镜像</span><br><span class="line">FROM scratch</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>在多行中使用反斜杠<code>\</code>或复杂的<code>RUN</code>语句，使Dockerfile更具可读性、易理解性和可维护性。</p>
<p><code>RUN</code>指令是用来执行命令行命令的。有两种格式：</p>
<ul>
<li><code>shell</code>格式<ul>
<li><code>RUN &lt;CMD&gt;</code>，就像直接在命令行中输入命令一样</li>
</ul>
</li>
<li><code>exec</code>格式<ul>
<li><code>RUN [&quot;可执行文件&quot;, &quot;参数&quot;]</code>，这更像函数调用中的格式</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure>
<p>Dockerfile中的每一个指令都会建立一层，<code>RUN</code>也不例外。每一个<code>RUN</code>的行为，就和手工建立镜像的过程一样 —— 新建立一层，在其上执行这些命令，执行结束后，<code>commit</code>这一层的修改，构成新的镜像。</p>
<p>上面这种写法，创建了7层镜像，这是完全没有意义的，而且很多运行时不需要的东西都被装进了镜像里，比如编译环境和更新的软件包等。结果就会产生非常臃肿、非常多层的镜像，不仅增加了构建部署的时间，也容易出错。这是很多初学Docker的人常犯的一个错误。</p>
<p>UnionFS是Linux、FreeBSD的文件系统服务，UnionFS是有最大层数限制的。</p>
<p>修改后的Dockerfile：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line">RUN buildDeps=&apos;gcc libc6-dev make&apos; \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure>
<p>仅仅使用一个<code>RUN</code>指令，并使用<code>&amp;&amp;</code>将各指令串联起来。将之前的7层简化为1层。在编写<code>Dockerfile</code>时，要经常提醒自己，这并不是在写shell脚本，而是在定义每一层该如何构建。</p>
<p><code>Dockerfile</code>支持shell类的换行<code>\</code>、注释<code>#</code>等格式，良好的格式，如换行、缩进、注释等，会让维护、排障更为容易，这也是一个好习惯。</p>
<p>此外，还可看到命令最后添加了清理工作的命令，删除了为编译构建所需要的软件，清理了所有下载文件。这很重要，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随镜像。<br>因此，构建镜像时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。<br>很多人初学docker制作出了很臃肿的镜像，原因之一就是顽疾了每一层构建的最后一定要清理无关文件。</p>
<p><br></p>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在<code>Dockerfile</code>目录下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#docker build [OPTIONS] PATH | URL | - [flags]</span><br><span class="line">#Build an image from a Dockerfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#-t指定镜像名称</span><br><span class="line">#.指的是上下文目录</span><br><span class="line">docker build -t nginx:test .</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>构建上下文(content)</strong></p>
<p>上面的<code>.</code>是在指定<strong>上下文路径</strong>。</p>
<p>当我们在进行镜像构建的时候，并非所有的定制都会通过<code>RUN</code>指令完成，经常会需要一些本地文件复制进镜像，比如通过<code>COPY</code>, <code>ADD</code>指令。而<code>docker build</code>命令并非是在本地构建镜像，而是在服务端，也就是Docker引擎<code>dockerd</code>中构建的。那么在这种C/S架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引进了上下文的概念。当构建的时候，用户会指定构建镜像的上下文的路径，<code>docker build</code>命令得知这个路径后，会将路径下的所有内容打包，然后上传给Docker引擎。这样Docker引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#复制上下文目录下的package.json</span><br><span class="line">COPY ./package.json /app/</span><br></pre></td></tr></table></figure>
<p>因此<code>COPY</code>这类指令中的源文件的路径都是相对路径，因为绝对路径已经超出了上下文的范围，Docker引擎无法获取这些位置的文件。如果真需要这些文件，请将它们复制到上下文目录中去。</p>
<p>理解构建上下文对于镜像构建很重要，避免犯一些不应该的错误。</p>
<p>一般来说，应将<code>Dockerfile</code>置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，则应该把所需文件复制一份过来。如果目录下有些东西不希望构建时传给Docker引擎，可以写一个<code>.dockerignore</code>文件，用于剔除不需要作为上下文传递给Docker引擎的。</p>
<p>实际上，<code>Dockerfile</code>的文件名并不要求必须为<code>Dockerfile</code>，也并不要求必须位于上下文目录中。可使用<code>-f</code>指定某个文件为<code>Dockerfile</code>。</p>
<p><br></p>
<p><strong>其它<code>docker build</code>的用法</strong></p>
<ol>
<li>直接使用Git repo进行构建</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#docker build URL</span><br><span class="line"></span><br><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14</span><br><span class="line">#docker会自己去clone、切换分支、并进入指定目录开始构建</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>使用给定tar压缩包构建</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build http://server/context.tar.gz</span><br><span class="line"></span><br><span class="line">#自动下载/解压缩 压缩包，以其作为上下文，开始构建</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>从标准输入中读取Dockerfile进行构建</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat Dockerfile | docker build -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><p><code>Dockerfile</code>提供了十多个指令供我们操作。</p>
<p><br></p>
<h3 id="LABLE"><a href="#LABLE" class="headerlink" title="LABLE"></a>LABLE</h3><p>你可以为你的镜像添加标签，以助于通过项目来组织镜像，记录相关信息。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set multiple labels at once, using line-continuation characters to break long lines</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> vendor=ACME\ Incorporated \</span></span><br><span class="line"><span class="bash">      com.example.is-beta= \</span></span><br><span class="line"><span class="bash">      com.example.is-production=<span class="string">""</span> \</span></span><br><span class="line"><span class="bash">      com.example.version=<span class="string">"0.0.1-beta"</span> \</span></span><br><span class="line"><span class="bash">      com.example.release-date=<span class="string">"2015-02-12"</span></span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>尽管<code>ADD</code>和<code>COPY</code>在功能上相似，但一般来说，<code>COPY</code>是首选，因为它比<code>COPY</code>更透明。<br><code>COPY</code>只支持将本地文件复制到容器中，而<code>ADD</code>具有一些功能(如提取tar文件和远程URL支持)</p>
<p><br></p>
<p><code>COPY</code>,复制文件。<br>从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置。</p>
<blockquote>
<p>源路径可以是多个，或通配符(需满足Go的规则)<br>目标路径可是容器内的绝对路径，也可是相对于工作目录(<code>WORKDIR</code>)的相对路径。目标路径不需要事先创建。<br>使用COPY指令，源文件的各种元数据都会保留 —— 如读、写、执行权限、文件变更时间…</p>
</blockquote>
<p><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">COPY  &lt;sourch&gt;  &lt;destination&gt;</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">COPY  [&quot;&lt;source1&gt;&quot;, ... &quot;&lt;destination&gt;&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子</span><br><span class="line">COPY package.json /usr/src/app/</span><br><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p><code>ADD</code>是更高级的复制文件。<br><code>ADD</code>和<code>COPY</code>的格式和性质基本一致，但增加了一些功能。<code>ADD</code>支持通过URL从远程服务器读取资源，但对远程的压缩包没有解压缩功能。<br>尽可能的使用<code>COPY</code>，因为<code>COPY</code>的语义很明确，就是复制文件而已，而<code>ADD</code>则包含了更复杂的功能，其行为也不一定很清晰。<br>最适合<code>ADD</code>的场合，就是所提及的需要自动解压缩的场合。</p>
<p>因此在<code>COPY</code>和<code>ADD</code>指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用<code>COPY</code>指令，仅在需要自动解压缩或远程资源的场合使用<code>ADD</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line"></span><br><span class="line">ADD ADD http://foo.com/bar.go /tmp/main.go</span><br><span class="line"></span><br><span class="line">ADD abc.tar.gz / &amp;&amp; \</span><br><span class="line">    http://example.com/big.tar.xz /usr/src/things/ &amp;&amp; \</span><br><span class="line">RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span><br><span class="line">RUN make -C /usr/src/things all</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>CMD</code>，容器启动命令。用于运行镜像中包含的软件以及任何参数。</p>
<p>也有两个格式：</p>
<ul>
<li><code>shell</code>格式： <code>CMD &lt;command&gt;</code></li>
</ul>
<p><code>shell</code>格式，在实际中会被包装成<code>sh -c</code>的参数形式进行执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CMD echo $HOME</span><br><span class="line"></span><br><span class="line">#转变为</span><br><span class="line">CMD[&quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot;]</span><br><span class="line"></span><br><span class="line">#-c string If  the  -c option is present, then commands are read from string.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理</span><br></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><code>exec</code>格式： <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot; ...]</code><br>CMD几乎总是以此格式使用。</li>
</ul>
<p>Docker不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code>指令就是用于指定默认的容器主进程的启动命令的。<br>``</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p><br></p>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p><code>ENTRYPOINT</code>，入口点。指令格式同样分为<code>shell</code>格式和<code>exec</code>两种。</p>
<p><code>ENTRYPOINT</code>和<code>CMD</code>一样，都是在指定容器启动程序及参数。<br>当指定了<code>ENTRYPOINT</code>后，<code>CMD</code>的含义就发生了改变，不再是直接的运行其命令，而是将<code>CMD</code>的内容作为参数传给<code>ENTRYPOINT</code>指令。即变为如下模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>有几大好处：</p>
<ul>
<li><strong>让镜像变成像命令一样使用</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#可以从腾讯上拉取，快一些</span><br><span class="line">#ccr.ccs.tencentyun.com/qcloud/ubuntu</span><br><span class="line"></span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker build -t myip</span><br><span class="line">docker run myip</span><br><span class="line">#当前 IP：182.150.x.xx 来自：四川省成都市 电信</span><br></pre></td></tr></table></figure>
<p>不过命令总有参数，例如我想查看HTTP header，使用<code>-i</code>参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run myip -i</span><br><span class="line">#这样会报错，-i替换了CMD命令，而不是-s参数，然而-i并不是命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#重新完整输入命令</span><br><span class="line">docker run myip curl -s http://ip.cn -i</span><br><span class="line">#这样又太麻烦</span><br></pre></td></tr></table></figure>
<p>这时便可以使用<code>ENTRYPOINT</code>解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker build it myip</span><br><span class="line">docker run myip</span><br><span class="line">#当前 IP：182.150.x.xx 来自：四川省成都市 电信</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run myip -i</span><br><span class="line">#成功</span><br></pre></td></tr></table></figure>
<p>当存在<code>ENTRYPOINT</code>后，<code>CMD</code>的内容将作为参数传递给<code>ENTRYPOINT</code>，而<code>-i</code>就是新的<code>CMD</code>，因此会作为参数传递给<code>curl</code>，从而达到预期效果。</p>
<p><br></p>
<ul>
<li><strong>应用运行前的准备工作</strong></li>
</ul>
<p>有时，在启动前需要做一些准备工作。</p>
<ul>
<li>如MySQL，需要一些配置文件、初始化工作，这些工作需要在MySQL server运行前解决</li>
<li>避免使用root用户去启动服务，从而提高安全性</li>
<li>这些准备工作和<code>CMD</code>无关</li>
</ul>
<p><br></p>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p><code>ENV</code>，设置环境变量。<br>为了使新软件更容易运行，使用此命令为你的容器内安装的软件更新环境变量。</p>
<p>两种格式：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV PATH $PATH:/root/bin \</span><br><span class="line">	EMAIL abc@zhang21.cn \</span><br><span class="line">	NAME=&quot;Zhang21&quot;</span><br></pre></td></tr></table></figure>
<p>下列指令可以支持环境变量展开： <code>ADD</code>, <code>COPY</code>, <code>ENV</code>, <code>EXPOSE</code>, <code>LABEL</code>, <code>USER</code>, <code>WORKDIR</code>, <code>VOLUME</code>, <code>STOPGIGNAL</code>, <code>ONBUILD</code>。</p>
<p>通过环境变量，我们可以让一份<code>Dockerfile</code>制作更多的镜像，只需使用不同的环境变量即可。</p>
<p><br></p>
<h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p><code>ARG</code>，构建参数</p>
<p>格式：</p>
<ul>
<li><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></li>
</ul>
<p><br></p>
<p>构建参数和<code>ENV</code>的效果一样，都是设置环境变量。所不同的是，<code>ARG</code>所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。</p>
<p><br></p>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><code>VOLUME</code>，定义匿名卷。用于显示有docker容器创建的任何数据库存储区域，配置存储或文件/文件夹。<br>强烈建议将VOLUME用于镜像的任何可变部分和用户可用部分。</p>
<p>格式：</p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p><br></p>
<p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。<br>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在<code>Dockerfile</code>中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会像容器存储层写入大量数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#在运行时自动挂载为匿名卷</span><br><span class="line">VOLUME /data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#覆盖挂载</span><br><span class="line">docker run -d -v mydata:/data xxx</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><code>EXPOSE</code>，声明容器监听连接的端口。</p>
<p>格式：</p>
<ul>
<li><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></li>
</ul>
<p><code>EXPOSE</code>指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。<br>在<code>Dockerfile</code>中写入这个声明有两个好处：</p>
<ul>
<li>一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便映射</li>
<li>另一个用处则是在运行时使用随机端口映射(未定义时)</li>
</ul>
<p>要将<code>EXPOSE</code>和在运行时使用<code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code>区分开。<code>EXPOSE</code>仅仅声明容器打算使用哪些端口，并未包含端口映射。</p>
<p><br></p>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p><code>WORKDIR</code>，指定工作目录。为了清晰可靠，请使用绝对路径。</p>
<p>使用<code>WORKDIR</code>指令可以来指定工作目录，以后各层的当前目录就被改为指定的目录，如目录不存在，<code>WORKDIR</code>会帮你建立目录。<br>如果需要改变<code>Dockerfile</code>各层的工作目录的位置，那么应该使用<code>WORKDIR</code>指令。</p>
<p>格式：</p>
<ul>
<li><code>WORKDIR &lt;工作目录&gt;</code></li>
</ul>
<p><br></p>
<h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p><code>USER</code>，指定当前用户。<br>如果服务可以在非特权模式下运行，请使用USER将其改为non-root用户。首先在Dockerfile中创建相应的用户和组:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r group &amp;&amp; \</span><br><span class="line">	useradd -r -g group group</span><br></pre></td></tr></table></figure>
<p><code>USER</code>和<code>WORKDIR</code>相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code>是改变工作目录，<code>USER</code>则是改变之后的层执行<code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>这类命令的身份。这个用户必须存在。</p>
<p>格式：</p>
<ul>
<li><code>USER &lt;用户名&gt;</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USER redis</span><br><span class="line">RUN [&quot;redis-server&quot;]</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p><code>HEALTHCHECK</code>，健康检查<br><code>HEALTHCHECK</code>指令告诉docker应该如何进行判断容器的状态是否正常。</p>
<p>格式：</p>
<ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>， 设置检查容器健康状况的命令</li>
<li><code>HEALTHCHECK NONE</code>， 如果基础镜像有健康检查，使用这行可以屏蔽其健康检查指令</li>
</ul>
<p>当在一个镜像指定了<code>HEALTHCHECK</code>指令后，用其启动容器，初始状态会为<code>starting</code>，在<code>HEALTHCHECK</code>指令检查成功后变为<code>healthy</code>，如果连续一定次数失败，则会变为<code>unhealthy</code>。<br>和<code>CMD</code>, <code>ENTRYPOINT</code>一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p><br></p>
<h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p><code>ONBUILD</code>，为他人做嫁衣。</p>
<p><code>ONBUILD</code>是一个特殊的指令，它后面跟的是其它指令。而这些指令，在当前镜像构建时不会被执行。只有当以当前镜像为基础镜像(父镜像)，去构建下一级镜像(子镜像)的时候才会被执行。<code>ONBUILD</code>命令在子镜像的Dockerfile中任何命令之前执行。<br><code>Dockerfile</code>中的其它指令都是为了定制当前镜像而准备的，唯有<code>ONBUILD</code>是为了帮助别人定制自己而准备的。</p>
<p>格式：</p>
<ul>
<li><code>ONBUILD &lt;其它指令&gt;</code></li>
</ul>
<p><br><br><br></p>
<h2 id="Dockerfile多阶段构建"><a href="#Dockerfile多阶段构建" class="headerlink" title="Dockerfile多阶段构建"></a>Dockerfile多阶段构建</h2><p><strong>全部放入一个Dockerfile</strong></p>
<p>将所有的构建过程包含在一个<code>Dockerfile</code>中，包括项目及其依赖库的编译、测试、打包等流程。<br>这可能会带来一些问题：</p>
<ul>
<li><code>Dockerfile</code>特别长，可维护性降低</li>
<li>镜像层次多，镜像体积较大，部署时间变长</li>
<li>源代码存在泄漏的风险</li>
</ul>
<p><br></p>
<p><strong>分散到多个Dockerfile</strong></p>
<p>事先在一个<code>Dockerfile</code>将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中。这种方式需要编写两个<code>Dockerfile</code>和一些编译脚本才能将两个阶段自动整合起来。这种方式虽然可以很好避免全部写入一个Dockerfile的风险，但明显部署过程较复杂。</p>
<p><br></p>
<p><strong>多阶段构建</strong></p>
<p>使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个<code>Dockerfile</code>。</p>
<p><br><br><br></p>
<h2 id="Dockerfile最佳实践"><a href="#Dockerfile最佳实践" class="headerlink" title="Dockerfile最佳实践"></a>Dockerfile最佳实践</h2><ul>
<li>一般性建议<ul>
<li>容器应该是短暂的</li>
<li>使用<code>.dockerignore</code>文件</li>
<li>使用多阶段构建减少镜像大小</li>
<li>避免安装不必要的包</li>
<li>一个镜像只运行一个进程</li>
<li>镜像层数尽可能少</li>
<li>将多行参数排序</li>
<li>构建缓存</li>
</ul>
</li>
<li>Dockerfile指令<ul>
<li><code>FROM</code></li>
<li><code>LABEL</code></li>
<li><code>RUN</code></li>
<li><code>CMD</code></li>
<li><code>EXPOSE</code></li>
<li><code>ENV</code></li>
<li><code>ADD</code></li>
<li><code>COPY</code></li>
<li><code>ENTRYPOINT</code></li>
<li><code>VOLUME</code></li>
<li><code>USER</code></li>
<li><code>WORKDIR</code></li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<hr>
<p><br></p>
<h1 id="Compose-file"><a href="#Compose-file" class="headerlink" title="Compose file"></a>Compose file</h1><p>参考:</p>
<ul>
<li><a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a></li>
</ul>
<p><br><br><br></p>
<hr>
<p><br></p>
<h1 id="使用Docker进行开发"><a href="#使用Docker进行开发" class="headerlink" title="使用Docker进行开发"></a>使用Docker进行开发</h1><p>Develop with Docker</p>
<p><br><br><br></p>
<h2 id="在Docker上开发应用程序"><a href="#在Docker上开发应用程序" class="headerlink" title="在Docker上开发应用程序"></a>在Docker上开发应用程序</h2><p>Develop new apps on Docker</p>
<ul>
<li>Learn to build an image from a Dockerfile</li>
<li>Use multistage builds to keep your images lean</li>
<li>Manage application data using volumes and bind mounts</li>
<li>Scale your app as a swarm service</li>
<li>Define your app stack using a compose file</li>
<li>General application development best practices</li>
</ul>
<p><br></p>
<p>了解有关Docker上特定语言的开发：</p>
<ul>
<li>Java</li>
<li>node.js</li>
<li>Ruby on Rails</li>
<li>.Net</li>
<li>ASP.Net</li>
</ul>
<p><br><br><br></p>
<h3 id="Docker开发最佳实践"><a href="#Docker开发最佳实践" class="headerlink" title="Docker开发最佳实践"></a>Docker开发最佳实践</h3><p>Docker development best practices</p>
<p>如下开发模式已被证明有助于人么使用Docker构建应用程序。</p>
<p><br></p>
<h4 id="如何保持较小的镜像"><a href="#如何保持较小的镜像" class="headerlink" title="如何保持较小的镜像"></a>如何保持较小的镜像</h4><p>How to keep your images small</p>
<p>在启动容器或服务时，小图像可以更快速通过网络pull镜像并加载到内存中。有几条经验法则可保持较小的镜像：</p>
<ul>
<li><p>从适当的基础镜像开始<br>例如，如果需要JDK，请考虑官方镜像，而不是从一个通用的Ubuntu/Centos镜像并将Openjdk作为Dockerfile的一部分安装开始。</p>
</li>
<li><p>使用多阶段构建<br>例如，你可以使用maven镜像构建java程序，然后重置到tomcat镜像，并将java构件复制到正确位置以部署应用程序，所有这些都位于相同的Dockerfile。这意味着你的最终镜像不包含构建时所引入的所有库和依赖项，仅包含运行它们所需的构件和环境。</p>
</li>
<li><p>如果你有多个共同的镜像，请考虑使用共享组件创建你的基本镜像，并在其上创建独特的镜像<br>Docker只要家在一次通用层，然后便会缓存。</p>
</li>
<li><p>保持生产环境镜像精简但允许调试(degub)，请考虑使用生产环境镜像作为调试镜像的基本镜像</p>
</li>
<li><p>在构建镜像时，应该始终使用有用的标签对其进行标记，如(test, prod)。不要依赖自动创建的<code>latest</code>标签</p>
</li>
</ul>
<p><br></p>
<h4 id="何处以及如何持久化应用程序数据"><a href="#何处以及如何持久化应用程序数据" class="headerlink" title="何处以及如何持久化应用程序数据"></a>何处以及如何持久化应用程序数据</h4><p>Where and how to persist application data</p>
<ul>
<li><p>避免使用存储驱动(storge drivers)将应用程序的数据存储在容器的可写层(writeable layer)中<br>与使用卷(volume)或绑定挂载(bound mounts)相比，这增加了容器的大小，并且从I/O角度来看效率较低</p>
</li>
<li><p>使用卷存储数据</p>
</li>
<li>适合使用绑定挂载的一种情况是在开发过程中，对于生产环境，请改用卷</li>
<li>对于生产环境，使用secerts来存储服务使用的敏感的应用程序数据，使用config来存储不敏感的数据(如配置文件)</li>
</ul>
<p><br></p>
<h4 id="尽可能使用swarm服务"><a href="#尽可能使用swarm服务" class="headerlink" title="尽可能使用swarm服务"></a>尽可能使用swarm服务</h4><p>Use swarm services when possible</p>
<ul>
<li>在可能的情况下，使用swarm服务进行伸缩的能力来设计你的应用程序</li>
<li>即使你只需运行单个实例，swarm服务也比standalone容器提供更多的优势</li>
<li>网络和卷可使用swarm服务连接和断开，并且docker可以以不中断的方式重新部署各个服务容器。standalone容器需要手动停止/移除/重新创建</li>
<li>一些功能仅适用于服务而不适用于standalone容器</li>
<li>让<code>docker stack deploy</code>处理任意镜像，而不是使用<code>docker pull</code>。通过这种方式，你的部署不会尝试从down的节点进行pull。此外，当新节点添加到集群时，镜像会自动pull</li>
</ul>
<p><br></p>
<h4 id="使用CI-CD进行测试和部署"><a href="#使用CI-CD进行测试和部署" class="headerlink" title="使用CI/CD进行测试和部署"></a>使用CI/CD进行测试和部署</h4><p>Use CI/CD for testing and deployment</p>
<ul>
<li>CI(Continuous integration)</li>
<li>CD(continuous deployment)</li>
<li>当更新源码库或创建拉取请求时，请使用CI/CD pipeline 自动构建并标记Docker镜像，并对其进行测试。也可将测试过的应用程序直接部署到生产环境中</li>
</ul>
<p><br><br><br></p>
<h3 id="Develop-images"><a href="#Develop-images" class="headerlink" title="Develop images"></a>Develop images</h3><h4 id="编写Dockerfile的最佳实践"><a href="#编写Dockerfile的最佳实践" class="headerlink" title="编写Dockerfile的最佳实践"></a>编写Dockerfile的最佳实践</h4><p>Best practices for writing Dockerfiles</p>
<p>Docker通过读取Dockerfile(一个包含命令的文本文件)中的命令来自动构建镜像。<br>Dockerfile reference: <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p>
<p><br></p>
<p>Dockerfile由read-only layer组成，每层代表一个Dockerfile指令。如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:15.04</span><br><span class="line">COPY . /app</span><br><span class="line">RUN make /app</span><br><span class="line">CMD python /app/app.py</span><br></pre></td></tr></table></figure>
<p>每个命令创建一个层:</p>
<ul>
<li><p><code>FROM</code><br>从<code>ubuntu:15.04</code> Docker image创建一个层</p>
</li>
<li><p><code>COPY</code><br>从Docker client的当前目录添加文件</p>
</li>
<li><p><code>RUN</code><br>使用<code>make</code>构建你的应用程序</p>
</li>
<li><p><code>CMD</code><br>指定在容器内运行的命令</p>
</li>
</ul>
<p>当你运行镜像并生成容器时，会在基础层的顶部添加一个可写层(writable layer)，也称容器层(container layer)。对正在运行的容器所做的所有更改(增删改文件)都会写入此可写容器层。</p>
<p><br></p>
<h4 id="一般准则和建议"><a href="#一般准则和建议" class="headerlink" title="一般准则和建议"></a>一般准则和建议</h4><p>General guidelines and recommendations</p>
<p><strong>创建临时(ephemeral)容器</strong></p>
<p>Create ephemeral containers<br>由Dockerfile定义的镜像应该生成尽可能临时的容器。临时的意思为容器可以被停止(stop)和销毁(destroy)，然后重建(rebuild)并使用绝对最小化的设置和配置来替代。</p>
<p><br></p>
<p><strong>理解构建上下文</strong></p>
<p>Understand build context<br>当你发出<code>docker build</code>命令时，当前的工作目录被称为构建上下文(build context)。默认情况下，假设Dockerfile位于此，但你也可以使用文件标志(-f)指定位置。无论Dockerfile位于何处，当前目录内的所有内容(除了.dockerignore中忽略的内容)都将作为构建上下文发送给Docker守护进程。</p>
<p><br></p>
<p><strong>从stdin读取Dockerfile</strong></p>
<p>Pipe Dockerfile through stdin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#local build-context</span><br><span class="line">docker build -t . -f-&lt;&lt;EOF</span><br><span class="line">FROM busybox</span><br><span class="line">RUN echo &quot;hello world&quot;</span><br><span class="line">COPY . /my-copied-files</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#remote</span><br><span class="line">docker build -t foo https://github.com/thajeztah/pgadmin4-docker.git -f-&lt;&lt;EOF</span><br><span class="line">FROM busybox</span><br><span class="line">COPY LICENSE config_local.py /usr/local/lib/python2.7/site-packages/pgadmin4/</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>使用<code>.dockerignore</code>排除文件</strong></p>
<p>Exclude with .dockerignore<br>要排除与构建无关的文件，请使用<code>.dockerignore</code>文件，这与<code>.gitignore类似</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ./dockerignore</span><br><span class="line"></span><br><span class="line">file1</span><br><span class="line">dir2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>使用多阶段构建</strong></p>
<p>Use multi-stage builds<br>多阶段构建允许你大幅缩减镜像大小，而不需要减少中间层和文件数。<br>由于镜像是在构建过程的最后阶段构建的，因此可以通过利用构建缓存(build cache)来最小化镜像层</p>
<p>例如，如果你的版本博涵包含多个层，你可以从 不经常改动的版本到频繁改动的版本进行排序:</p>
<ul>
<li>安装构建应用程序需要的工具</li>
<li>安装或更新依赖库</li>
<li>生成应用程序</li>
</ul>
<p>A Dockerfile for Go application:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.9.2-alpine3.6 AS build</span><br><span class="line"></span><br><span class="line"># Install tools required for project</span><br><span class="line"># Run `docker build --no-cache .` to update dependencies</span><br><span class="line">RUN apk add --no-cache git</span><br><span class="line">RUN go get github.com/golang/dep/cmd/dep</span><br><span class="line"></span><br><span class="line"># List project dependencies with Gopkg.toml and Gopkg.lock</span><br><span class="line"># These layers are only re-built when Gopkg files are updated</span><br><span class="line">COPY Gopkg.lock Gopkg.toml /go/src/project/</span><br><span class="line">WORKDIR /go/src/project/</span><br><span class="line"># Install library dependencies</span><br><span class="line">RUN dep ensure -vendor-only</span><br><span class="line"></span><br><span class="line"># Copy the entire project and build it</span><br><span class="line"># This layer is rebuilt when a file changes in the project directory</span><br><span class="line">COPY . /go/src/project/</span><br><span class="line">RUN go build -o /bin/project</span><br><span class="line"></span><br><span class="line"># This results in a single layer image</span><br><span class="line">FROM scratch</span><br><span class="line">COPY --from=build /bin/project /bin/project</span><br><span class="line">ENTRYPOINT [&quot;/bin/project&quot;]</span><br><span class="line">CMD [&quot;--help&quot;]</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>不要安装不必要的包</strong></p>
<p>Don’t install unnecessary packages<br>为了减少复杂性、依赖性，文件大小和构建时间，避免安装额外的或不不必要的软件包。</p>
<p><br></p>
<p><strong>分离应用程序</strong></p>
<p>Decouple applications<br>每个容器应该只有一个问题。将应用程序分离到多个容器中可以更轻松地水平伸缩和重新使用容器。<br>例如，Web应用程序堆栈可能有三个独立的容器组成，每个容器都有其独特的镜像，以分离的方式管理Web应用程序、数据库和内存缓存。</p>
<p>将每个容器限制为一个进程是一个很好的经验法则，但不是硬性规定。(想想高可用和负载均衡)。</p>
<p>尽你最大的努力使容器干净和模块化。如果容器相互依赖，则可以使用Docker container network来确保容器间可进行通信。</p>
<p><br></p>
<p><strong>最小化层数</strong></p>
<p>Minimize the number of layers<br>在老版本的docker中，重要的是减少镜像的层数，以确保它们的性能。</p>
<p><br></p>
<p><strong>对多行参数排序</strong></p>
<p>Sort multi-line arguments<br>只要有可能，通过按字母数字排序多行参数来简化修改。这有助于避免软件包重复，并使列表更容易更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">  bzr \</span><br><span class="line">  cvs \</span><br><span class="line">  git \</span><br><span class="line">  mercurial \</span><br><span class="line">  subversion</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>Leverage build cache</strong></p>
<p>在构建镜像时，Docker安装Dockerfile中的指令逐步执行，并按指定的顺序执行每个镜像。在检查每条指令时，docker会在其缓存中查找可重用的现有镜像，而不是创建新的(重复)镜像。</p>
<p>如果你不想使用缓存，可在<code>docker build</code>命令中使用<code>--no-cache=true</code>选项。如果让Docker使用了缓存，那么了解何时可以 找到/找不到 匹配的图像就很重要了。</p>
<p>Docker遵循的基本规则如下:</p>
<ul>
<li>从已经在缓存中的父镜像开始，将下一条指令与该基本镜像派生的所有子镜像进行比较，以查看是否使用完全相同的指令构建了其中的一条。否则，缓存失效。</li>
<li>大多数情况下，只需将Dockerfile中的指令与其中一个子镜像进行比较久够了。但是，某些说明需要更多的检查和解释。</li>
<li>对于<code>ADD</code>和<code>COPY</code>指令，将检查镜像文件中的内容，并为每个文件计算校验和。在缓存查找过程中，将检验和与现有镜像中的校验和进行比较，如果文件中由任何内容已更改，如内容和元数据，则缓存将失效。</li>
<li>除了<code>ADD</code>和<code>COPY</code>指令，缓存检查将不会查看容器中的文件已确定缓存。</li>
</ul>
<p>一旦缓存失效，所有后续的Dockerfile命令将生产新的镜像，并且不会使用缓存。</p>
<p><br></p>
<p><strong>Dockerfile instruction</strong></p>
<p>请参考: <a href="# Dockerfile">Dockerfile</a></p>
<p><br></p>
<h4 id="创建一个基镜像"><a href="#创建一个基镜像" class="headerlink" title="创建一个基镜像"></a>创建一个基镜像</h4><p>Create a base image</p>
<p>大多数Dockerfile从父镜像开始，如果需要完全控制镜像的内容，则可能需要创建基镜像(base image)。区别:</p>
<ul>
<li>父镜像是镜像的所基于的镜像</li>
<li>基镜像的Dockerfile中没有<code>FROM</code>行</li>
</ul>
<p><br></p>
<h4 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h4><p>Use multi-stage builds</p>
<p>多阶段构建需要Docker v17.05及以上版本。多阶段构建对于优化Dockerfile来说非常有用，同时让它易读和维护。</p>
<p><br></p>
<p><strong>构建之前</strong><br>构建镜像最具挑战的事情是保持镜像的大小。Dockerfile中的每条指令都会为镜像添加一层，在移动到下一层前清理不需要的任何构件。为了编写一个高效的Dockerfile，需要尽可能减小图层，并确保每个层都具有上一层需要的构件，而不是其它东西。</p>
<p><strong>使用多阶段构建</strong><br>使用多阶段构建，你可以在Dockerfile中使用多个<code>FROM</code>语句。每条<code>FROM</code>命令可以使用不同的基镜像，并且每个指令都可是构建的新阶段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3</span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go .</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=0 /go/src/github.com/alexellis/href-counter/app .</span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure>
<p><code>COPY --from=0</code>将前面构建的工作复制到这个新阶段。Go SDK和任何中间工作件都被留下，并未保存在最终镜像中</p>
<p><br></p>
<p><strong>命名你的构建阶段</strong><br>默认情况下，构建阶段没有命名。你可以通过它们的整数来引用它们，第一个指令<code>FROM</code>从0开始。但你可以命名它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.7.3 as builder</span><br><span class="line">WORKDIR /go/src/github.com/alexellis/href-counter/</span><br><span class="line">RUN go get -d -v golang.org/x/net/html</span><br><span class="line">COPY app.go    .</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=builder /go/src/github.com/alexellis/href-counter/app .</span><br><span class="line">CMD [&quot;./app&quot;]</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>停止一个特定的构建阶段</strong><br>构建镜像时，不一定需要构建包含每个阶段的整个Dockerfile。<br>如下的栗子停在名为<code>builder</code>的阶段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --target builder -t alexellis2/href-counter:latest .</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>使用外部镜像用作一个阶段</strong><br>多阶段构架可使用<code>COPY --from</code>指令从单独的镜像中进行复制，可以使用本机镜像、远程Registry的镜像和标记的ID。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="使用Docker-Engine-SDKs和API进行开发"><a href="#使用Docker-Engine-SDKs和API进行开发" class="headerlink" title="使用Docker Engine SDKs和API进行开发"></a>使用Docker Engine SDKs和API进行开发</h2><p>Develop with Docker Engine SDKs and API</p>
<p><br></p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>Docker提供了一个用于与Docker daemon(称为Docker Engine API)交互的API，以及用于Go和Python的SDK。</p>
<p>SDK允许你款速轻松地构建和扩展Docker APP。<br>如果Go或Python不适合你，你可以直接使用Docker Engine API——它是由HTTP客户端(curl, wget)访问的RESTful API，或者是大多数现代编程语言的一部分HTTP库。</p>
<p><br></p>
<h3 id="安装SDKs"><a href="#安装SDKs" class="headerlink" title="安装SDKs"></a>安装SDKs</h3><h4 id="Go-SDK"><a href="#Go-SDK" class="headerlink" title="Go SDK"></a>Go SDK</h4><ul>
<li>Go SDK参考：<a href="https://godoc.org/github.com/docker/docker/client" target="_blank" rel="noopener">https://godoc.org/github.com/docker/docker/client</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/docker/docker/client</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="Python-SDK"><a href="#Python-SDK" class="headerlink" title="Python SDK"></a>Python SDK</h4><ul>
<li>Python SDK参考: <a href="https://docker-py.readthedocs.io/en/stable/" target="_blank" rel="noopener">https://docker-py.readthedocs.io/en/stable/</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install docker</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="快速开始SDK和API"><a href="#快速开始SDK和API" class="headerlink" title="快速开始SDK和API"></a>快速开始SDK和API</h3><p>Python: 运行一个容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import docker</span><br><span class="line">client = docker.from_env()</span><br><span class="line">print (client.containers.run(&quot;alpine&quot;, [&quot;echo&quot;, &quot;hello&quot;, &quot;world&quot;]))</span><br></pre></td></tr></table></figure>
<p>HTTP:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ curl --unix-socket /var/run/docker.sock -H &quot;Content-Type: application/json&quot; \</span><br><span class="line">  -d &apos;&#123;&quot;Image&quot;: &quot;alpine&quot;, &quot;Cmd&quot;: [&quot;echo&quot;, &quot;hello world&quot;]&#125;&apos; \</span><br><span class="line">  -X POST http:/v1.24/containers/create</span><br><span class="line">&#123;&quot;Id&quot;:&quot;1c6594faf5&quot;,&quot;Warnings&quot;:null&#125;</span><br><span class="line"></span><br><span class="line">$ curl --unix-socket /var/run/docker.sock -X POST http:/v1.24/containers/1c6594faf5/start</span><br><span class="line"></span><br><span class="line">$ curl --unix-socket /var/run/docker.sock -X POST http:/v1.24/containers/1c6594faf5/wait</span><br><span class="line">&#123;&quot;StatusCode&quot;:0&#125;</span><br><span class="line"></span><br><span class="line">$ curl --unix-socket /var/run/docker.sock &quot;http:/v1.24/containers/1c6594faf5/logs?stdout=1&quot;</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="SDK和API栗子"><a href="#SDK和API栗子" class="headerlink" title="SDK和API栗子"></a>SDK和API栗子</h3><p>链接: <a href="https://docs.docker.com/develop/sdk/examples/" target="_blank" rel="noopener">https://docs.docker.com/develop/sdk/examples/</a></p>
<p><br></p>
<hr>
<p><br></p>
<h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><p>Configure networking</p>
<h2 id="综述-1"><a href="#综述-1" class="headerlink" title="综述"></a>综述</h2><p>Docker容器和服务如此强大的原因之一是——你可以将它们连接在一起，或将它们连接到non-docker工作负载。Docker容器和服务甚至不需要知道它们是否部署在Docker上，或它们的对等端是否也是Docker工作负载。都可以使用Docker方式管理它们。</p>
<p><br></p>
<h3 id="网络驱动"><a href="#网络驱动" class="headerlink" title="网络驱动"></a>网络驱动</h3><p>Network drivers</p>
<p>使用驱动程序，Docker的网络子系统是可插拔的(pluggable)。</p>
<p>集中驱动程序:</p>
<ul>
<li><p>brige<br>默认网络驱动。桥接网络通常用于你的应用程序运行在需要通信的独立容器中。</p>
</li>
<li><p>host<br>对于独立容器，删除容器和Docker主机之间的网络隔离，并直接使用主机的网络。</p>
</li>
<li><p>overlay<br>overlay网络将多个docker daemon连接在一起，并使集群服务能够无相互通信。</p>
</li>
<li><p>macvlan<br>macvlan网络允许你为容器分配MAC地址，使其成为你网络上的物理设备。docker daemon通过其MAC地址将流量路由到容器。</p>
</li>
<li><p>none<br>对于此容器，禁用所有网络。</p>
</li>
<li><p>network plugins<br>你可在Docker上安装和使用第三方网络插件，从Docker Store获取: <a href="https://store.docker.com" target="_blank" rel="noopener">https://store.docker.com</a></p>
</li>
</ul>
<p><br></p>
<p><strong>网络驱动总结</strong></p>
<ul>
<li><p><strong>User-defined bridge networks</strong><br>当你需要多个容器在同一个Docker主机上进行通信时</p>
</li>
<li><p><strong>Host networks</strong><br>当网络堆栈不应与Docker主机隔离时，但希望容器的其它方面被隔离</p>
</li>
<li><p><strong>Overlay networks</strong><br>当你需要运行在不同Docker主机上的容器进行通信时，或多个应用程序使用集群服务进行工作时</p>
</li>
<li><p><strong>Macvlan networks</strong><br>当你从虚拟机迁移或需要你的容器看起来像物理主机时，每个都具有唯一的MAC地址</p>
</li>
<li><p><strong>Third-party network plugins</strong><br>允许你将Docker与专用网络堆栈集成</p>
</li>
</ul>
<p><br><br><br></p>
<h2 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h2><p>就网络而言，桥接网络是一种链路层设备，用于转发网段之间的流量。桥接可以是硬件设备，或在主机内核中运行的软件设备。<br>就Docker而言，桥接网络允许连接到统一桥接网络的容器进行通信，同时提供与未连接到桥接网络的容器的隔离。Docker桥接驱动程序自动在主机上安装桥接规则，以便于不同桥接网络上的容器不能直接相互通信。</p>
<p>桥接网络适用于在同一个Docker daemon上运行的容器之间的通信。</p>
<p>当你启动Docker时，除非另有定义，否则将自动创建默认桥接网络，并且新启动的容器将连接到它。<br>你也可以创建用户自定义的桥接网络。</p>
<p><br><br><br></p>
<h3 id="bridge与user-defined-bridges"><a href="#bridge与user-defined-bridges" class="headerlink" title="bridge与user-defined bridges"></a>bridge与user-defined bridges</h3><p>Differences between user-defined bridges and the default bridge</p>
<p>两者的差别：</p>
<ul>
<li><p>用户自定义的桥接在集装箱化的应用程序之间提供了更好的隔离和互操作性</p>
</li>
<li><p>用户自定义的桥接提供了容器之间的自动DNS解析</p>
</li>
<li><p>容器可以在运行中与用户定义的网络进行连接(attach)和分离(detach)</p>
</li>
<li><p>每个用户定义的网络会创建一个可配置的桥接网络</p>
</li>
<li><p>在默认桥接网络上链接的容器共享环境变量</p>
</li>
</ul>
<p><br><br><br></p>
<h3 id="管理user-defined-bridge"><a href="#管理user-defined-bridge" class="headerlink" title="管理user-defined bridge"></a>管理user-defined bridge</h3><p>Manage a user-defined bridge</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker network create --help</span><br><span class="line"></span><br><span class="line">#创建一个用户自定义桥接网络</span><br><span class="line">#你还可以指定子网，范围，网关...</span><br><span class="line">docker network creat $&#123;name&#125;</span><br><span class="line"></span><br><span class="line">docker network creat my-net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">docker network rm $&#123;name&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="连接到自定义桥接网络"><a href="#连接到自定义桥接网络" class="headerlink" title="连接到自定义桥接网络"></a>连接到自定义桥接网络</h3><p>Connect a container to a user-defined bridge</p>
<p>当你创建一个新的容器时，你可以指定一个或多个<code>--network</code>标志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#创建时</span><br><span class="line">docker create --name my-nginx \</span><br><span class="line">  --network my-net \</span><br><span class="line">  --publish 8080:80 \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#运行中的容器</span><br><span class="line">docker network connect my-net my-nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#断开连接</span><br><span class="line">docker network disconnect my-net my-nginx</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="使用IPv6"><a href="#使用IPv6" class="headerlink" title="使用IPv6"></a>使用IPv6</h3><p>需要修改docker daemon的配置项以支持使用IPv6，在创建自定义网络是指定<code>--ipv6</code>标志。<br>你不能有选择地禁用默认桥接网络上的IPv6支持。</p>
<p><br><br><br></p>
<h3 id="启用容器转发"><a href="#启用容器转发" class="headerlink" title="启用容器转发"></a>启用容器转发</h3><p>Enable forwarding from Docker containers to the outside world</p>
<p>默认情况下，使用默认桥接网络的连接的容器的流量不会转发到外部世界。启用操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#配置Linux内核</span><br><span class="line">sysctl net.ipv4.conf.all.forwarding=1</span><br><span class="line"></span><br><span class="line">#修改iptables FORWARD默认策略</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br><span class="line"></span><br><span class="line">#重启后无效，请写入配置文件</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="默认桥接网络"><a href="#默认桥接网络" class="headerlink" title="默认桥接网络"></a>默认桥接网络</h3><p>Use the default bridge network</p>
<p>默认桥接网络被视为Docker的遗留细节，不建议用于生产环境。</p>
<p><br></p>
<p><strong>连接容器到默认桥接网络</strong><br>如果未指定网络，则默认使用默认桥接网络。</p>
<p><strong>配置默认桥接网络</strong><br>指定并配置<code>daemon.json</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bip&quot;: &quot;192.168.1.5/24&quot;,</span><br><span class="line">  &quot;fixed-cidr&quot;: &quot;192.168.1.5/25&quot;,</span><br><span class="line">  &quot;fixed-cidr-v6&quot;: &quot;2001:db8::/64&quot;,</span><br><span class="line">  &quot;mtu&quot;: 1500,</span><br><span class="line">  &quot;default-gateway&quot;: &quot;10.20.1.1&quot;,</span><br><span class="line">  &quot;default-gateway-v6&quot;: &quot;2001:db8:abcd::89&quot;,</span><br><span class="line">  &quot;dns&quot;: [&quot;10.20.1.2&quot;,&quot;10.20.1.3&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用IPv6</strong><br>修改配置文件以支持IPv6，则默认桥接网络自动支持IPv6。</p>
<p><br><br><br></p>
<h2 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h2><p>overlay网络驱动在多个docker daemon主机之间创建分布式网络。该网络位于特定主机网络之上，允许容器连接到此并安全地进行通信。</p>
<p>当初始化集群或将docker主机加入现有集群时，将在docker主机上创建两个新网络：</p>
<ul>
<li><p>称为<code>ingress</code>的overlay网络<br>处理与集群服务相关的控制和数据流量。<br>当你创建集群服务并且不将其连接到用户自定义的网络时，它默认连接到<code>ingress</code>网络。</p>
</li>
<li><p>称为<code>docker_gwbridge</code>的桥接网络<br>将单独的docker daemon连接到集群的其它docker daemon。</p>
</li>
</ul>
<p>与创建自定义桥接网络类似，你也可以使用<code>docker network create</code>来创建自动以的overlay网络。服务或容器一次可连接到多个网络，但只能通过连接的网络进行通信。</p>
<p>尽管可以将集群服务和独立容器连接到overlay网络，但默认行为和配置是不同的。</p>
<p><br><br><br></p>
<h3 id="所有overlay网络的操作"><a href="#所有overlay网络的操作" class="headerlink" title="所有overlay网络的操作"></a>所有overlay网络的操作</h3><p>Operations for all overlay networks</p>
<p><br></p>
<h4 id="创建overlay网络"><a href="#创建overlay网络" class="headerlink" title="创建overlay网络"></a>创建overlay网络</h4><p>Create an overlay network</p>
<p><strong>先决条件</strong></p>
<ul>
<li><p>使用overlay网络的docker daemon的防火墙规则</p>
<ul>
<li>2377(tcp): 集群通信管理</li>
<li>7946(tcp/udp)： 节点通信</li>
<li>4789(udp)： overlay网络流量</li>
</ul>
</li>
<li><p>创建overlay网络前，需要初始化docker daemon集群</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d overlay my-overlay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建可供集群服务或独立容器与其它docker daemon上的独立容器进行通信</span><br><span class="line">docker network create -d overlay --attachable my-attachable-overlay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#你可以指定IP地址范围，子网，网关...</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="加密overlay网络上的流量"><a href="#加密overlay网络上的流量" class="headerlink" title="加密overlay网络上的流量"></a>加密overlay网络上的流量</h4><p>Encrypt traffic on an overlay network</p>
<p><strong>Overlay network encryption is not supported on Windows！</strong></p>
<p>所有集群服务管理流量默认都是加密的，在GCM模式下使用AES算法。<br>要加密应用程序数据，在创建overlay网络时添加<code>--opt encrypted</code>。这种加密带来了不可忽视的性能问题，所以应该在生产环境使用前对其进行测试。<br>当启用overlay加密时，docker会在节点间创建IPsec tunnel，在这些节点上调度连接到overlay网络的服务的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#SWARM MODE OVERLAY NETWORKS AND STANDALONE CONTAINERS</span><br><span class="line"> docker network create --opt encrypted --driver overlay --attachable my-attachable-multi-host-network</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="自定义默认ingress网络"><a href="#自定义默认ingress网络" class="headerlink" title="自定义默认ingress网络"></a>自定义默认ingress网络</h4><p>如果自动选择的子网与已存在的网络冲突，或需要自定义其它低级网络设置(如MTU)，这次功能非常有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#显示详细信息</span><br><span class="line">docker network inspect ingress</span><br><span class="line"></span><br><span class="line">#移除现有网络</span><br><span class="line">docker network rm ingress</span><br><span class="line"></span><br><span class="line">#创建新网络 --ingress</span><br><span class="line">docker network create \</span><br><span class="line">  --driver overlay \</span><br><span class="line">  --ingress \</span><br><span class="line">  --subnet=10.11.0.0/16 \</span><br><span class="line">  --gateway=10.11.0.2 \</span><br><span class="line">  --opt com.docker.network.driver.mtu=1200 \</span><br><span class="line">  my-ingress</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="自定义docker-gwbridge"><a href="#自定义docker-gwbridge" class="headerlink" title="自定义docker_gwbridge"></a>自定义docker_gwbridge</h4><p><code>docker_gwbridge</code>是一个虚拟桥接网络，它将overlay网路连接到单独的docker daemon的物理网络。当初始化集群或将主机加入集群时，docker会自动创建它，但它不是docker设备。啊存在于docker主机的内核之中。如果你需要自定义其设置，则必须在主机加入集群之前或将主机临时从集群中删除之后才执行此操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 停止docker</span><br><span class="line"></span><br><span class="line">2. 删除已存在的docker_gwbridge</span><br><span class="line">ip link set docker_gwbridge doen</span><br><span class="line">ip link del dev docker_gwbridge</span><br><span class="line"></span><br><span class="line">3. 启动docker，但不加入或初始化集群</span><br><span class="line"></span><br><span class="line">4. 创建docker_gwbridge</span><br><span class="line">docker network create \</span><br><span class="line">--subnet 10.11.0.0/16 \</span><br><span class="line">--opt com.docker.network.bridge.name=docker_gwbridge \</span><br><span class="line">--opt com.docker.network.bridge.enable_icc=false \</span><br><span class="line">--opt com.docker.network.bridge.enable_ip_masquerade=true \</span><br><span class="line">docker_gwbridge</span><br><span class="line"></span><br><span class="line">5. 集群初始化或加入集群</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="swarm服务的操作"><a href="#swarm服务的操作" class="headerlink" title="swarm服务的操作"></a>swarm服务的操作</h3><p>Operations for swarm services</p>
<h4 id="在overlay网络上发布端口"><a href="#在overlay网络上发布端口" class="headerlink" title="在overlay网络上发布端口"></a>在overlay网络上发布端口</h4><p>Publish ports on an overlay network</p>
<p>连接到同一overlay网络的集群服务可有效地将所有端口暴露给对方。要是端口可在服务外可访问，必须使用<code>-p</code>或<code>--publish</code>标志暴露此端口。</p>
<p>两种方法：</p>
<ul>
<li>传统的冒号<code>:</code>分隔语法</li>
<li>较新的逗号<code>,</code>分隔语法</li>
</ul>
<table>
<thead>
<tr>
<th>Flag value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p 8080:80 or <br> -p published=8080,target=80</td>
<td>Map TCP port 80 on the service to port 8080 on the routing mesh</td>
</tr>
<tr>
<td>-p 8080:80/udp or <br> -p published=8080,target=80,protocol=udp</td>
<td>Map UDP port 80 on the service to port 8080 on the routing mesh</td>
</tr>
<tr>
<td>-p 8080:80/tcp -p 8080:80/udp or <br> -p published=8080,target=80,protocol=tcp -p published=8080,target=80,protocol=udp</td>
<td>Map TCP port 80 on the service to TCP port 8080 on the routing mesh, and map UDP port 80 on the service to UDP port 8080 on the routine mesh</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="绕过swarm的路由网格"><a href="#绕过swarm的路由网格" class="headerlink" title="绕过swarm的路由网格"></a>绕过swarm的路由网格</h4><p>Bypass the routing mesh for a swarm service</p>
<p>默认情况下，发布端口的集群服务使用路由网格来发布。当你连接到任何swarm节点上已发布的端口时，都会透明地将你重定向到正在运行服务的工作。实际上，docker充当集群服务的负载均衡器(Load-Balancer)。使用路由网格的服务以虚拟IP(vip)模式运行。即使在每个节点上运行服务也使用路由网格。使用路由网格时，不能保证那个docker node处理客户端请求。</p>
<p>要绕过路由网格，可使用DNS Round Robin(DNSRR)模式启动——<code>--endpoint-mode dnsrr</code>。你必须在服务前运行负载均衡器。docker主机上DNS查询服务名称会返回运行该服务的节点的IP地址列表。配置你的负载均衡器使用此列表并平衡各节点间的流量。</p>
<p><br></p>
<h4 id="分离控制流量和数据流量"><a href="#分离控制流量和数据流量" class="headerlink" title="分离控制流量和数据流量"></a>分离控制流量和数据流量</h4><p>默认情况下，尽管集群控制流量是加密的，但集群管理和应用程序之间的控制流量运行在同一个网络上。你可以配置docker来使用单独的网络接口来处理来种不同类型的流量。</p>
<p><br><br><br></p>
<h3 id="overlay网络上独立容器的操作"><a href="#overlay网络上独立容器的操作" class="headerlink" title="overlay网络上独立容器的操作"></a>overlay网络上独立容器的操作</h3><p>Operations for standalone containers on overlay networks</p>
<h4 id="将独立容器连接到overlay网络"><a href="#将独立容器连接到overlay网络" class="headerlink" title="将独立容器连接到overlay网络"></a>将独立容器连接到overlay网络</h4><p>Attach a standalone container to an overlay network</p>
<p>独立容器连接到<code>ingress</code>网络需添加<code>--attachable</code>标志。这使得运行在不同docker daemon上的独立容器能够进行通信，而无需在各个docker daemon主机上设置路由。</p>
<p><br></p>
<h4 id="发布端口"><a href="#发布端口" class="headerlink" title="发布端口"></a>发布端口</h4><p>Publish ports</p>
<table>
<thead>
<tr>
<th>Flag value</th>
<th>Desciption</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p 8080:80</td>
<td>Map TCP port 80 in the container to port 8080 on the overlay network</td>
</tr>
<tr>
<td>-p 8080:80/udp</td>
<td>Map UDP port 80 in the container to port 8080 on the overlay network</td>
</tr>
<tr>
<td>-p 8080:80/sctp</td>
<td>Map SCTP port 80 in the container to port 8080 on the overlay network</td>
</tr>
<tr>
<td>-p 8080:80/tcp -p 8080:80/udp</td>
<td>Map TCP port 80 in the container to TCP port 8080 on the overlay network, and map UDP port 80 in the container to UDP port 8080 on the overlay network</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="容器发现"><a href="#容器发现" class="headerlink" title="容器发现"></a>容器发现</h4><p>Container discovery</p>
<p>对于大多数情况，应该连接到服务名称——它是负载均衡的，并支持服务的所有容器处理。要获取支持该服务的所有任务的列表，请执行DNS查找服务——<code>tasks.&lt;service-name&gt;</code>。</p>
<p><br><br><br></p>
<h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><p>如果你对容器使用host网络驱动，则该容器的网络堆栈将不与docker主机隔离。例如，如果运行一个绑定在80端口并使用host网络的容器，则该容器的应用程序将在主机IP地址的80端口上可用。</p>
<p>host网络驱动只能运行在Linux主机上。</p>
<p><br><br><br></p>
<h2 id="Macvlan"><a href="#Macvlan" class="headerlink" title="Macvlan"></a>Macvlan</h2><p>一些应用程序，尤其是需要监视网络流量的应用程序，希望连接到物理网络上。在这种情况下，你可以使用<code>macvlan</code>驱动为容器的虚拟网络接口分配MAC地址，使其看起来像是直接连接到物理网络的物理网络接口。在这种情况下，你需要指定Docker主机上的物理接口用于macvlan，以及macvlan的子网和网关。</p>
<p><br></p>
<h3 id="创建一个macvaln网络"><a href="#创建一个macvaln网络" class="headerlink" title="创建一个macvaln网络"></a>创建一个macvaln网络</h3><p>macvlan网络可处于 <strong>bridge mode</strong> 或 <strong>802.1q trunk mode</strong>:</p>
<ul>
<li><p>在桥接模式下，macvlan流量通过主机上的物理设备</p>
</li>
<li><p>在802.1q主干桥接模式下，流量通过Docker在运行中创建的802.1q子接口。<br>这使你可以更细粒度地控制路由和过滤。</p>
</li>
</ul>
<p><br></p>
<p><strong>bridge mode</strong></p>
<p>创建bridge macvlan:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker networkcreate --driver macvlan \</span><br><span class="line">  --subnet=172.16.86.0/24 \</span><br><span class="line">  --gateway=172.16.86.1  \</span><br><span class="line">  -o parent=eth0 pub_net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--aux-addresses排除IP地址</span><br><span class="line">docker networkcreate --driver macvlan \</span><br><span class="line">  --subnet=172.16.86.0/24 \</span><br><span class="line">  --gateway=172.16.86.1  \</span><br><span class="line">  --aux-address=&quot;my-router=192.168.32.129&quot; \</span><br><span class="line">  -o parent=eth0 pub_net</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>802.1q truk bridge mode</strong></p>
<p>如果你指定了包含点<code>.</code>的接口名——如<strong>eth0.50</strong>，则Docker将其解释为eth0的子接口，并自动创建子接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker network  create  --driver macvlan \</span><br><span class="line">  --subnet=192.168.50.0/24 \</span><br><span class="line">  --gateway=192.168.50.1 \</span><br><span class="line">  -o parent=eth0.50 macvlan50</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>使用ipvlan替换macvlan</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d ipvlan \</span><br><span class="line">  --subnet=192.168.210.0/24 \</span><br><span class="line">  --subnet=192.168.212.0/24 \</span><br><span class="line">  --gateway=192.168.210.254  \</span><br><span class="line">  --gateway=192.168.212.254  \</span><br><span class="line">  -o ipvlan_mode=l2 ipvlan210</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>IPv6</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker network  create  -d macvlan \</span><br><span class="line">  --subnet=192.168.216.0/24 --subnet=192.168.218.0/24 \</span><br><span class="line">  --gateway=192.168.216.1  --gateway=192.168.218.1 \</span><br><span class="line">  --subnet=2001:db8:abc8::/64 --gateway=2001:db8:abc8::10 \</span><br><span class="line">  -o parent=eth0.218 \</span><br><span class="line">  -o macvlan_mode=bridge macvlan216</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="禁用容器网络"><a href="#禁用容器网络" class="headerlink" title="禁用容器网络"></a>禁用容器网络</h2><p>在启动容器时加上`–network none来禁用容器的网络堆栈，这样在容器内便仅仅创建loopback设备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -dit \</span><br><span class="line">  --network none \</span><br><span class="line">  --name no-net-alpine \</span><br><span class="line">  alpine:latest \</span><br><span class="line">  ash</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="网络教程"><a href="#网络教程" class="headerlink" title="网络教程"></a>网络教程</h2><p>Networking tutorials</p>
<p><br></p>
<h3 id="bridge-network"><a href="#bridge-network" class="headerlink" title="bridge network"></a>bridge network</h3><ul>
<li>default bridge network</li>
<li>user-defined bridge network</li>
</ul>
<p><br></p>
<h4 id="default-bridge-network"><a href="#default-bridge-network" class="headerlink" title="default bridge network"></a>default bridge network</h4><ol>
<li>基本docker网络</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">8d3b84bfe5a0        bridge              bridge              local</span><br><span class="line">3579d63da633        host                host                local</span><br><span class="line">f766b990db47        none                null                local</span><br></pre></td></tr></table></figure>
<p>以上列出了默认的桥接网络，主机网络(启动直接连接到docker daemon的主机的网络堆栈的容器)，none(启动一个没有网络设备的容器)。</p>
<p><br></p>
<ol>
<li>启动一个容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name alpine1 alpine ash</span><br></pre></td></tr></table></figure>
<p>由于启动时没有指定网络，所以默认为桥接网络。</p>
<p><br></p>
<ol>
<li>Inspect the bridge network，以查看哪个容器连接到它</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;8d3b84bfe5a034c65d043af80976a1e6127011fc1ab312446252f562e221d351&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-05-24T18:38:35.538308064+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;893903129d869f384bd78d63a382f1c9527d6979be0a6cf3c13ea4f45a1554d6&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;hardcore_rosalind&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;515d1435470c9f72d3b07680515d9c503457b8eb5bcaaaa915bb53901eac9424&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>连接到容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker attach alpine1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ # ip addr show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">506: eth0@if507: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP </span><br><span class="line">    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ # ping -c 2 www.baidu.com</span><br><span class="line">PING www.baidu.com (119.75.216.20): 56 data bytes</span><br><span class="line">64 bytes from 119.75.216.20: seq=0 ttl=55 time=46.521 ms</span><br><span class="line">64 bytes from 119.75.216.20: seq=1 ttl=55 time=45.189 ms</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>ping其它容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ # ping -c 2 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.125 ms</span><br><span class="line">64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.075 ms</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="user-defined-bridge-networks"><a href="#user-defined-bridge-networks" class="headerlink" title="user-defined bridge networks"></a>user-defined bridge networks</h4><ol>
<li>创建名为<code>apline-net</code>用户自定义网络<br>当然，你可以手动指定子网，网关这些。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge alpine-net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docket network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">810fb1e02000        alpine-net          bridge              local</span><br><span class="line">8d3b84bfe5a0        bridge              bridge              local</span><br><span class="line">3579d63da633        host                host                local</span><br><span class="line">f766b990db47        none                null                local</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>查看alpine-net网络详情<br>注意网关和子网发生了变化。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect alpine-net</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;alpine-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;810fb1e020008c7c6598f3b830ca25896dde638b1190d383ee6a5214d284e77d&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-06-14T15:45:19.43941906+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>创建两种网络的容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#alpine-net</span><br><span class="line">docker run -dit --name alpine1 --network alpine-net alpine ash</span><br><span class="line"></span><br><span class="line">#default bridge</span><br><span class="line">docker run -dit --name alpine2 alpine ash</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>显示两种网络情况</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;8d3b84bfe5a034c65d043af80976a1e6127011fc1ab312446252f562e221d351&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-05-24T18:38:35.538308064+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;893903129d869f384bd78d63a382f1c9527d6979be0a6cf3c13ea4f45a1554d6&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;hardcore_rosalind&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;515d1435470c9f72d3b07680515d9c503457b8eb5bcaaaa915bb53901eac9424&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;e7472c3ddda5043bc03868f4bf7ed59562220f05772f02f57ff589d086630562&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;alpine2&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;ba565a247e347feb59713c188eb38e184d781da0489ae80e26ecad6d24e165c2&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,</span><br><span class="line">            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker network inspect alpine-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;alpine-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;810fb1e020008c7c6598f3b830ca25896dde638b1190d383ee6a5214d284e77d&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-06-14T15:45:19.43941906+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;264ccde8b1d5198551d689f0dd49ffbfb612255e0bf76c9543325d7c2e588acb&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;alpine1&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;563c48cc6b936bcd9d3f57e9bb5e162a8cb52a23c8980346f288d42cc9b0a8fc&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>连接到容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker container attach alpine1</span><br><span class="line"></span><br><span class="line">#网段内通</span><br><span class="line">/ # ping -c 2 172.18.0.3</span><br><span class="line">PING 172.18.0.1 (172.18.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.097 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.070 ms</span><br><span class="line"></span><br><span class="line">--- 172.18.0.1 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 0.070/0.083/0.097 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#网段外不通</span><br><span class="line">/ # ping -c 2 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.16.0.1): 56 data bytes</span><br><span class="line"></span><br><span class="line">--- 172.17.0.2 ping statistics ---</span><br><span class="line">2 packets transmitted, 0 packets received, 100% packet loss</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>使容器连接到default bridge<br>这样，此容器便连接到了两个网络中。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network connect bridge apline1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ # ping -c 2 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.102 ms</span><br><span class="line">64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.071 ms</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="host-network"><a href="#host-network" class="headerlink" title="host network"></a>host network</h3><p>host网络不存在隔离问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#默认主机上的80端口</span><br><span class="line">docker run -rm -dit --network host --name my_nginx nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#访问</span><br><span class="line">http://localhost:80</span><br><span class="line">Welcome to nginx!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker network inspect host</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;host&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;3579d63da633adcc497417d39b8b1d270cf329a68b9222f6a75fae72086509d6&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-04-27T11:31:17.900886126+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;host&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;f02a3b11fce7228ad6ee196771bd9cf0b64966bfc2aa7c27719bc120dbdc7189&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;my_nginx&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;4ee67fb4d0a0c1a357b5fdd141f856a70c205fad5c49b1cb6a4f5245df0318a8&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="overlay-network"><a href="#overlay-network" class="headerlink" title="overlay network"></a>overlay network</h3><ul>
<li>default overlay network</li>
<li>user-defined overlay network</li>
<li>overlay network for standalone containers</li>
<li>Communicate between a container and a swarm service</li>
</ul>
<p><br></p>
<h4 id="default-overlay"><a href="#default-overlay" class="headerlink" title="default overlay"></a>default overlay</h4><p><strong>依赖：</strong></p>
<ul>
<li>swarm集群</li>
<li>集群节点<ul>
<li>worker-1</li>
<li>worker-2</li>
<li>mananger</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">495c570066be        bridge              bridge              local</span><br><span class="line">961c6cae9945        docker_gwbridge     bridge              local</span><br><span class="line">ff35ceda3643        host                host                local</span><br><span class="line">trtnl4tqnc3n        ingress             overlay             swarm</span><br><span class="line">c8357deec9cb        none                null                local</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>创建nginx-net的overlay的网络:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d overlay nginx-net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ docker service create \</span><br><span class="line">  --name my-nginx \</span><br><span class="line">  --publish target=80,published=80 \</span><br><span class="line">  --replicas=5 \</span><br><span class="line">  --network nginx-net \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="user-defined-overlay"><a href="#user-defined-overlay" class="headerlink" title="user-defined overlay"></a>user-defined overlay</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d overlay my-overlay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ docker service create \</span><br><span class="line">  --name my-nginx \</span><br><span class="line">  --network my-overlay \</span><br><span class="line">  --replicas 1 \</span><br><span class="line">  --publish published=8080,target=80 \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="overlay-network-for-standalone-containers"><a href="#overlay-network-for-standalone-containers" class="headerlink" title="overlay network for standalone containers"></a>overlay network for standalone containers</h4><p><br></p>
<h4 id="Communicate-between-a-container-and-a-swarm-service"><a href="#Communicate-between-a-container-and-a-swarm-service" class="headerlink" title="Communicate between a container and a swarm service"></a>Communicate between a container and a swarm service</h4><p><br><br><br></p>
<h3 id="macvalan-network"><a href="#macvalan-network" class="headerlink" title="macvalan network"></a>macvalan network</h3><p>假设主机网络接口为<code>eth0</code>。</p>
<p><br></p>
<h4 id="bridge-1"><a href="#bridge-1" class="headerlink" title="bridge"></a>bridge</h4><p>此模式下，流量通过eth0流动，docker使用其MAC地址就流量路由到容器。</p>
<ol>
<li>创建名为<code>my-macvlan-net</code>的macvlan网络</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d macvlan \</span><br><span class="line">  --subnet=172.16.86.0/24 \</span><br><span class="line">  --gateway=172.16.86.1 \</span><br><span class="line">  -o parent=eth0 \</span><br><span class="line">  my-macvlan-net</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>查看网络</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">810fb1e02000        alpine-net          bridge              local</span><br><span class="line">8d3b84bfe5a0        bridge              bridge              local</span><br><span class="line">3579d63da633        host                host                local</span><br><span class="line">6be80655739d        my-macvlan-net      macvlan             local</span><br><span class="line">f766b990db47        none                null                local</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>以此网络运行容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -itd \</span><br><span class="line">  --network my-macvlan-net \</span><br><span class="line">  --name my-macvlan-alpine \</span><br><span class="line">  alpine:latest \</span><br><span class="line">  ash</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>查看my-macvlan-net</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect my-macvlan-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;my-macvlan-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;6be80655739deffe204e087d098f97fc75072d95f9818e129cfd7d5667ed01f3&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-06-14T16:52:30.507647877+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;macvlan&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.16.86.0/24&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.16.86.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;8301b669b4b63afb20911b46243f11b70e5a9d0880beaafa922b52bcb8ab0477&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;my-macvlan-alpine&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;4f2971ba4bd92c34e2a299d301f739867d2b1b65d35566aef07d7a26b079662c&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:10:56:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.16.86.2/24&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;parent&quot;: &quot;ens160&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>查看容器网卡和路由</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker exec my-macvlan-alpine ip addr show eth0</span><br><span class="line">517: eth0@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UNKNOWN</span><br><span class="line">    link/ether 02:42:ac:10:56:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.16.86.2/24 brd 172.16.86.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">docker exec my-macvlan-alpine ip route</span><br><span class="line">default via 172.16.86.1 dev eth0</span><br><span class="line">172.16.86.0/24 dev eth0 scope link  src 172.16.86.2</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="802-1q-trunked-bridge-network"><a href="#802-1q-trunked-bridge-network" class="headerlink" title="802.1q trunked bridge network"></a>802.1q trunked bridge network</h4><p>此模式下，流量流经eth0的子接口(eth0.10)，docker使用其MAC地址将流量路由到容器。</p>
<ol>
<li>创建名为<code>my-8021q-macvlan-net</code>的macvlan网络</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d macvlan \</span><br><span class="line">  --subnet=172.16.87.0/24 \</span><br><span class="line">  --gateway=172.16.87.1 \</span><br><span class="line">  -o parent=eth0.10 \</span><br><span class="line">  my-8021q-macvlan-net</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>查看此网络</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line">NETWORK ID          NAME                   DRIVER              SCOPE</span><br><span class="line">2aeafd44fd67        my-8021q-macvlan-net   macvlan             local</span><br><span class="line">6be80655739d        my-macvlan-net         macvlan             local</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ifconfig</span><br><span class="line">eth0.10: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::20c:29ff:feaa:7e75  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:aa:7e:75  txqueuelen 0  (Ethernet)</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>用此网络启动一个容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -itd \</span><br><span class="line">  --network my-8021q-macvlan-net \</span><br><span class="line">  --name my-second-macvlan-alpine \</span><br><span class="line">  alpine:latest \</span><br><span class="line">  ash</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>查看my-8021q-macvlan-net</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect my-8021q-macvlan-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;my-8021q-macvlan-net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;2aeafd44fd67e6ee937c82788745b1d45fb291efd61f545537528eafdff94e3d&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-06-14T17:06:33.426800076+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;macvlan&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.16.87.0/24&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.16.87.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;90103673d94915c3c7fb572eec8bd97b2aee1c3dab877c598d0a62e6d797b06d&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;my-second-macvlan-alpine&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;5c93f2ea1d29150ee57f099d42fc8e04a571efd0d1273a4f6bed755dc34f2e54&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:ac:10:57:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;172.16.87.2/24&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;parent&quot;: &quot;ens160.10&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><br></p>
<ol>
<li>查看容器网络接口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker exec my-second-macvlan-alpine ip addr show eth0</span><br><span class="line">519: eth0@if518: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UNKNOWN </span><br><span class="line">    link/ether 02:42:ac:10:57:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.16.87.2/24 brd 172.16.87.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker exec my-second-macvlan-alpine ip route</span><br><span class="line">default via 172.16.87.1 dev eth0</span><br><span class="line">172.16.87.0/24 dev eth0 scope link  src 172.16.87.2</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="配置守护进程和容器"><a href="#配置守护进程和容器" class="headerlink" title="配置守护进程和容器"></a>配置守护进程和容器</h2><h3 id="启用IPv6"><a href="#启用IPv6" class="headerlink" title="启用IPv6"></a>启用IPv6</h3><p>启用IPv6前，请确保支持IPv6.</p>
<p>给docker daemon启用IPv6:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;ipv6&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>所有Docker的<code>iptables</code>规则都被添加到<code>DOKCER chain</code>。不要手动操作此表。<br>如果你需要添加Docker规则，请将其添加到<code>DOCKER-USER chain</code></p>
<p>栗子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I DOCKER-USER -m iprange -i ext_if ! --src-range 192.168.1.1-192.168.1.3 -j DROP</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h3><p>容器使用的网络类型(无论是bridge，overlay，macvlan还是自定义网络)，在容器内都是透明的。从容器的角度来看，它有一个带有IP地址，网关，路由表，DNS服务和其它网络细节的网络接口。</p>
<p><strong>publish port</strong><br>默认情况下，创建容器时，它不会将任何端口发布的外部世界。要是端口可用于docker之外的服务，请使用<code>--publish</code>或<code>-p</code>标志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-p 8080:80</span><br><span class="line">-p 192.168.1.100:8080:80</span><br><span class="line">-p 8080:80/udp</span><br><span class="line">-p 8080:80/tcp -p 8080:80/udp</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>ip add and hostname</strong><br>默认情况下，容器会为其连接的每个docker网络分配一个IP地址。IP地址是从分配给网络的地址池中分配的，因此docker daemon有效地充当了每个容器的DHCP服务器。每个网络也有一个默认的子网掩码和网关。<br>同样，一个容器的主机名也有docker daemon指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#指定运行网络</span><br><span class="line">docker run xxx --network</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#运行的容器连接到其它网络</span><br><span class="line">docker network connect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--ip，指定IP地址</span><br><span class="line">docker network connect my-bridge --ip 172.18.0.111</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--hostname，指定主机名</span><br><span class="line">docker run xxx --network xxx --hostname container-01</span><br><span class="line"></span><br><span class="line">docker network connect my-bridge --hostname container-02</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>DNS</strong><br>默认情况下，容器会继承docker daemon的DNS设置，包括<code>/etc/hosts</code>和<code>/etc/resolv.conf</code>。你也可以基于每个容器覆盖这些默认设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#DNS server</span><br><span class="line">--dns</span><br><span class="line"></span><br><span class="line">#DNS搜索域</span><br><span class="line">--dns-search</span><br><span class="line"></span><br><span class="line">#表示DNS选项值的键值对</span><br><span class="line">--dns-opt</span><br><span class="line"></span><br><span class="line">--hostname</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="Docker使用代理服务器"><a href="#Docker使用代理服务器" class="headerlink" title="Docker使用代理服务器"></a>Docker使用代理服务器</h3><p>在启动docker容器的用户主目录下创建此文件： <code>~/.docker/config.json</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;proxies&quot;:</span><br><span class="line"> &#123;</span><br><span class="line">   &quot;default&quot;:</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;httpProxy&quot;: &quot;http://127.0.0.1:3001&quot;,</span><br><span class="line">     &quot;noProxy&quot;: &quot;*.test.example.com,.example2.com&quot;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<hr>
<p><br></p>
<h1 id="应用程序数据"><a href="#应用程序数据" class="headerlink" title="应用程序数据"></a>应用程序数据</h1><p>Manage application data</p>
<p><br></p>
<h2 id="存储综述"><a href="#存储综述" class="headerlink" title="存储综述"></a>存储综述</h2><p>Manage data in Docker</p>
<p>默认情况下，容器内创建的所有文件都被存储容器的可写层上：</p>
<ul>
<li><p>当容器不在运行时，数据不是持续存在的。容器外的进程很难从容器中获取数据</p>
</li>
<li><p>容器的可写层与主机紧密耦合，你很难将数据移动到其他地方</p>
</li>
<li><p>向容器的可写入层写入数据，需要存储驱动(storage driver)管理文件系统才<br>存储驱动使用Linux kernel来提供一个union filesystem。与直接写入主机文件系统的数据卷相比，这种额外的抽象会降低性能。</p>
</li>
</ul>
<p><br></p>
<p>Docker容器有两种选项将文件存储到主机上，这样即使容器停止之后这些文件也会被保留:</p>
<ul>
<li>volumes</li>
<li>bind mounts</li>
<li>tmpfs mount(Docker on Linux)</li>
</ul>
<p><br></p>
<h3 id="选择正确的挂载方式"><a href="#选择正确的挂载方式" class="headerlink" title="选择正确的挂载方式"></a>选择正确的挂载方式</h3><p>Choose the right type of mount</p>
<p>无论你选用哪种挂载方式，数据在容器内看起来都是相同的。它被公开为容器文件系统中的目录或单个文件。</p>
<p>一个简单的方法——考虑数据在docker主机上的位置，可以看出<strong>volumes, bind mounts, temfs</strong>之间的差异：</p>
<ul>
<li><p>Volumes<br>volumes存储在由docker管理的主机文件系统的一部分中(如Linux上: <code>/var/lib/docker/volumes/</code>)。<br>non-docker进程不应该修改这部分文件系统。Volume是Docker中保存数据的最佳方式。</p>
</li>
<li><p>Bind mounts<br>bind mounts可存储在主机系统上的任何地方。它们可能是最要的系统文件或目录。<br>docker主机或docker容器上的non-docker进程可以随时修改它们。</p>
</li>
<li><p>tmpfs<br>仅存储在主机系统的内存中，不会写入主机系统的文件系统。</p>
</li>
</ul>
<p><img src="/images/Docker/types-of-mounts.png" alt=""></p>
<p><br></p>
<h4 id="volumes的好栗子"><a href="#volumes的好栗子" class="headerlink" title="volumes的好栗子"></a>volumes的好栗子</h4><p>Good use cases for volumes</p>
<p>Volemes是在docker容器和服务中持久化数据的首选方式:</p>
<ul>
<li><p>在多个运行容器之间共享数据。如果你没有明确创建它，会在第一次挂载到容器时创建volume。当容器停止或删除时，volume仍然存在。多个容器可以挂载相同的volume，无论是read-write还是read-only。只有在你手动删除volume时它才会被删除。</p>
</li>
<li><p>当docker主机不能保证具有给定的目录或文件结构时，volume帮助你将docker主机的配置与运行时的容器进行分离。</p>
</li>
<li><p>当你想要将容器的数据存储在远程主机而不是本地的时候。</p>
</li>
<li><p>当你需要备份、还原或将数据从一台docker主机迁移到另一台时，volume时更好的选择。</p>
</li>
</ul>
<p><br></p>
<h4 id="bind-mounts的好栗子"><a href="#bind-mounts的好栗子" class="headerlink" title="bind mounts的好栗子"></a>bind mounts的好栗子</h4><p>一般来说，你应该尽量使用volumes。bind mounts适合以下案例：</p>
<ul>
<li><p>从主机共享配置文件到容器<br>这就是默认情况下，通过将主机的/<code>etc/resolv.conf</code>挂载到每个容器中，Docker为每个容器提供DNS解析。</p>
</li>
<li><p>在docker主机/容器的开发环境上共享源码或构建工件</p>
</li>
<li><p>当docker主机的文件或目录结构保证与容器所需的bind mounts一致时</p>
</li>
</ul>
<p><br></p>
<h4 id="tmpfs-mounts的好栗子"><a href="#tmpfs-mounts的好栗子" class="headerlink" title="tmpfs mounts的好栗子"></a>tmpfs mounts的好栗子</h4><p>当你不希望数据在主机上或容器内持久存储时，tmpfs mounts最合适。<br>这可能处于安全原因，或在应用于程序需要编写大量非持久性状态数据时保护容器的性能。</p>
<p><br></p>
<h4 id="使用bind或volumes的提示"><a href="#使用bind或volumes的提示" class="headerlink" title="使用bind或volumes的提示"></a>使用bind或volumes的提示</h4><p>如果你要使用bind mounts 或 volumes，牢记以下事项：</p>
<ul>
<li><p>如果你挂载一个空卷(empty volume)到存在文件或目录的容器中的目录上，则会将这些文件或目录赋值到卷中。同样，如果你启动容器并制定了一个尚不存在的卷，则会为你创建一个空卷。</p>
</li>
<li><p>如果你挂载一个bind mount或non-empty volume到存在文件或目录的容器中的目录上，则这些文件或目录会被挂载所遮蔽。就像在Linux上挂载卷一样。</p>
</li>
</ul>
<p><br><br><br></p>
<h2 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h2><p>volumes是持久化Docker数据的首选机制，卷由docker完全管理。另外，由于卷不会增加使用它的容器的大小，并且该卷的内容存在于给定容器的周期之外，因此卷通产是比将容器的可写入层中的数据持久化更好的选择。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-v/--volume</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#此选项更详细和简单</span><br><span class="line">#如果你需要指定volume driver，请使用此flag</span><br><span class="line">--mount</span><br><span class="line"></span><br><span class="line">docker service create \</span><br><span class="line">  --mount &apos;type=volume,src=&lt;VOLUME-NAME&gt;,dst=&lt;CONTAINER-PATH&gt;,volume-driver=local,volume-opt=type=nfs,volume-opt=device=&lt;nfs-server&gt;:&lt;nfs-path&gt;,&quot;volume-opt=o=addr=&lt;nfs-address&gt;,vers=4,soft,timeo=180,bg,tcp,rw&quot;&apos;</span><br><span class="line">  --name myservice \</span><br><span class="line">  &lt;IMAGE&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--volume</code></li>
</ul>
<p>由三个由冒号<code>:</code>分割的字段组成。这些字段必须按照正确的顺序排列，每个字段的含义并不明显。<br>第一个字段是卷的名称，并且在给定主机上是唯一的。对于匿名卷，第一个字段被省略。<br>第二个字段是文件或目录在容器中的挂载路径。<br>第三个字段是可选的，是由一个逗号`,分隔的选项列表。</p>
<ul>
<li><code>--mount</code></li>
</ul>
<p>由多个键值对组成，以逗号<code>,</code>分隔。<code>--mount</code>的语法比<code>--volume</code>更冗长，但键的顺序并不重要，并且标志的值更易于理解。<br>挂载的类型(type)有<code>bind, volume, tmpfs</code>。<br>挂载的来源(source, src)为卷的名称，对于匿名卷该字段可被省略。<br>目的地(destination, dst, target)的值是安装在容器中的文件或目录的路径。<br>只读(readonly)选项将导致bind mount以只读方式挂载到容器中。<br><code>volume-opt</code>选项可以多次指定，它是由选项名称和值组成的键值对组成。</p>
<p><br></p>
<h3 id="创建和管理卷"><a href="#创建和管理卷" class="headerlink" title="创建和管理卷"></a>创建和管理卷</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my-vol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               my-vol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2018-06-15T17:19:02+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/opt/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker volume rm my-vol</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="启动用卷的容器"><a href="#启动用卷的容器" class="headerlink" title="启动用卷的容器"></a>启动用卷的容器</h3><p>Start a container with a volume</p>
<p>包括两种卷：</p>
<ul>
<li><p>已存在的卷</p>
</li>
<li><p>未存在的卷<br>会自动创建</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount source=myvol2,target=/app \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --volume myvol2:/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               my-vol</span><br><span class="line">local               myvol2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker inspect devtest</span><br><span class="line">#找到挂载</span><br><span class="line">        &quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;myvol2&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/opt/docker/volumes/myvol2/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/app&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="启动用卷的服务"><a href="#启动用卷的服务" class="headerlink" title="启动用卷的服务"></a>启动用卷的服务</h3><p>Start a service with volumes</p>
<p>docker服务不支持使用<code>--volume</code>标志，请使用<code>--mount</code>标志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service create -d \</span><br><span class="line">  --replicas=4 \</span><br><span class="line">  --name devtest-service \</span><br><span class="line">  --mount source=myvol2,target=/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="在机器间共享数据"><a href="#在机器间共享数据" class="headerlink" title="在机器间共享数据"></a>在机器间共享数据</h3><p>Share data among machines</p>
<p>在构建容错应用程序时，可能需要配置同一服务的多个副本能访问相同的文件，而这些副本可能分布于不同的节点上。</p>
<p><img src="/images/Docker/share_data_amon_machine.png" alt=""></p>
<p>卷驱动程序(volume driver)允许你从应用程序逻辑中抽象出底层存储系统。</p>
<p><br></p>
<h3 id="使用卷驱动"><a href="#使用卷驱动" class="headerlink" title="使用卷驱动"></a>使用卷驱动</h3><p>Use a volume driver</p>
<p>在创建卷或启动带卷的容器时，你可以指定卷驱动。如<code>vieux/sshfs</code>卷驱动程序。</p>
<ul>
<li>初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker plugin install --grant-all-permissions vieux/sshfs</span><br></pre></td></tr></table></figure>
<ul>
<li>使用卷驱动创建卷</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#操作node2</span><br><span class="line">docker volume create --driver vieux/sshfs \</span><br><span class="line">  -o sshcmd=test@node2:/home/test \</span><br><span class="line">  -o password=testpassword \</span><br><span class="line">  sshvolume</span><br></pre></td></tr></table></figure>
<ul>
<li>启动一个带用卷驱动程序创建的卷的容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name sshfs-container \</span><br><span class="line">  --volume-driver vieux/sshfs \</span><br><span class="line">  --mount src=sshvolume,target=/app,volume-opt=sshcmd=test@node2:/home/test,volume-opt=password=testpassword \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>
<ul>
<li>备份，还原或迁移数据卷</li>
</ul>
<p>使用<code>--volumes-from</code>标志创建一个挂载该卷的新容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#备份</span><br><span class="line">docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#从备份还原</span><br><span class="line">docker run -v /dbdata --name dbstore2 ubuntu /bin/bash</span><br><span class="line">docker run --rm --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c &quot;cd /dbdata &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="bind-mounts"><a href="#bind-mounts" class="headerlink" title="bind mounts"></a>bind mounts</h2><p>与volumes相比，bind mounts功能有限。当你使用bind mounts时，主机上的文件或目录(绝对路径或相对路径)被挂载到容器内。相比之下，当你使用volumes时，会在主机上的Docker存储目录中创建一个新目录，并且Docker会管理该目录的内容。<br>该文件或目录不需要已经存在于Docker主机上。如果它尚未存在，它会根据需求创建。bind mounts非常高效，但是它们依赖于具有特定目录结构的主机文件系统。如果你正在开发新的Docker Application，请考虑使用volumes。你不能使用Docker CLI直接管理bind mounts。</p>
<p>你可以使用<code>--volume</code>或<code>--mount</code>(语法更详细)flag。具体区别参考volumes的介绍。</p>
<p><br></p>
<h3 id="启动用bind-mount的容器"><a href="#启动用bind-mount的容器" class="headerlink" title="启动用bind mount的容器"></a>启动用bind mount的容器</h3><p>Start a container with a bind mount</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>挂载到容器内非空目录</strong><br>如果挂载在容器内非空目录上，则该目录的已有内容将被隐藏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name broken-container \</span><br><span class="line">  --mount type=bind,source=/tmp,target=/usr \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name broken-container \</span><br><span class="line">  -v /tmp:/usr \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="只读bind-mount"><a href="#只读bind-mount" class="headerlink" title="只读bind mount"></a>只读bind mount</h3><p>Use a read-only bind mount</p>
<p>某些时候，容器可能只需要只读权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app,readonly \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app:ro \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="bind-propagation"><a href="#bind-propagation" class="headerlink" title="bind propagation"></a>bind propagation</h3><p>对于bind mounts和volumes，bind propagation(传播)默认为<code>rprivate</code>。它只能对Linux主机上的bind mounts进行配置。它是一个高级话题，许多用户并不需要配置它。</p>
<p>bind propagation(传播)是指在给定的bind-mounts或named volume中创建的挂载是否可以传播(propagation)到该挂载(mount)的副本(replicas)。<br>考虑一个挂载点<code>/mnt</code>，挂载在<code>/tmp</code>上。传播设置控制<code>/tmp/a</code>上的挂载点是否也可用于<code>/mnt/a</code>。每个传播设置都有一个递归对应点。在递归的情况下，考虑<code>/tmp/a</code>也被挂载到<code>/foo</code>。传播设置控制是否存在<code>/mnt/a</code>和<code>/tmp/a</code>。</p>
<table>
<thead>
<tr>
<th>传播设置</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>shared</td>
<td>原始mount的sub-mount会暴露给replica mounts，并且replica mounts的sub-mount同样传播给原始mount。也就是双向</td>
</tr>
<tr>
<td>slave</td>
<td>类似于shared，但仅限于单方向。</td>
</tr>
<tr>
<td>private</td>
<td>私有挂载</td>
</tr>
<tr>
<td>rshared</td>
<td>与shared相同，但传播也扩展到嵌套在任何原始或副本挂载点内的挂载点</td>
</tr>
<tr>
<td>rslave</td>
<td>与slave相同，但传播也扩展到嵌套在任何原始或副本挂载点内的挂载点</td>
</tr>
<tr>
<td>rprivate</td>
<td>默认值。与private相同，这意味着原始或副本挂载点内的任何位置的挂载点都不会沿任一方向传播</td>
</tr>
</tbody>
</table>
<p>在设置bind propagation之前，主机文件系统需要已经支持bind propagatin: <a href="https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app \</span><br><span class="line">  --mount type=bind,source=&quot;$(pwd)&quot;/target,target=/app2,readonly,bind-propagation=rslave \</span><br><span class="line">  nginx:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--volume</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app2:ro,rslave \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="selinux-label"><a href="#selinux-label" class="headerlink" title="selinux label"></a>selinux label</h3><p>如果你使用selinux，你可以添加<code>z</code>或<code>Z</code>选项来修改挂载到容器内的主机文件或目录的selinux标签。这户影响主机本身的文件或目录，并可能导致Docker范围之外的后果。</p>
<ul>
<li><p><code>z</code><br>bind mount的内容在多个容器之间共享。</p>
</li>
<li><p><code>Z</code><br>bind mount的内容是私有和非共享的。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#不支持--mount</span><br><span class="line">docker run -d \</span><br><span class="line">  -it \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v &quot;$(pwd)&quot;/target:/app:z \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="tmpfs-mounts"><a href="#tmpfs-mounts" class="headerlink" title="tmpfs mounts"></a>tmpfs mounts</h2><p>tmpfs: <a href="https://docs.docker.com/storage/tmpfs/#limitations-of-tmpfs-mounts" target="_blank" rel="noopener">https://docs.docker.com/storage/tmpfs/#limitations-of-tmpfs-mounts</a><br>tmpfs mounts只支持运行在Linux上的Docker。</p>
<p><br><br><br></p>
<h2 id="Troubleshoot"><a href="#Troubleshoot" class="headerlink" title="Troubleshoot"></a>Troubleshoot</h2><p>troubleshoot: <a href="https://docs.docker.com/storage/troubleshooting_volume_errors/" target="_blank" rel="noopener">https://docs.docker.com/storage/troubleshooting_volume_errors/</a></p>
<p><br><br><br></p>
<h2 id="将数据存储到容器内"><a href="#将数据存储到容器内" class="headerlink" title="将数据存储到容器内"></a>将数据存储到容器内</h2><p>Store data within containers</p>
<h3 id="关于存储驱动"><a href="#关于存储驱动" class="headerlink" title="关于存储驱动"></a>关于存储驱动</h3><p>为了有效地使用存储驱动(storage driver)，了解Docker如何构建和存储镜像，以及容器如何使用镜像是很重要的。你可以使用这些信息作出明智的选择，以便找到应用程序数据持久化的最佳方式，并避免出现性能问题。</p>
<p>存储驱动允许你在容器的可写入层创建数据。在容器停止后，这些文件将不会被保留，并且读写速度都很低。</p>
<p><br></p>
<h4 id="镜像和层"><a href="#镜像和层" class="headerlink" title="镜像和层"></a>镜像和层</h4><p>Images and layers</p>
<p>Docker镜像由一系列层(layer)构建而成。每个层代表镜像的Dockerfile中的指令，除最后一层外的每个层都是只读的。</p>
<p>考虑如下Dockerfile:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:15.04</span><br><span class="line">COPY . /app</span><br><span class="line">RUN make /app</span><br><span class="line">CMD python /app/app.py</span><br></pre></td></tr></table></figure>
<p>此Dockerfile包含4个命令，每个命令创建一个层。<br>当你创建一个新容器时，你在底层之上添加了一个新的可写入层——它通常被称为<strong>容器层(container layer)</strong>。<br>对运行中的容器所做的所有更改(增删改文件)都会写入此可写容器层。</p>
<p><img src="/images/Docker/container-layers.jpg" alt="容器层"></p>
<p>存储驱动处理有关这些层相互交互的详细信息。有几个不同的驱动程序，在不同的情况下具有相应的优点和缺点。</p>
<p><br></p>
<h4 id="容器和层"><a href="#容器和层" class="headerlink" title="容器和层"></a>容器和层</h4><p>Container and layers</p>
<p>容器和镜像之间的主要区别是最高的可写入层。当容器删除时，可写入层也被删除。但底层镜像保持不变。</p>
<p>由于每个容器都有自己的可写入容器层，并且所有的更改都存储在此容器中，因此多个容器可以共享相同的基础镜像的访问权限，并拥有自己的数据状态。</p>
<p><img src="/images/Docker/sharing-layers.jpg" alt="容器和层"></p>
<p>Docker使用存储驱动来管理镜像层和可写入容器层的内容。每个存储驱动程序都已不同方式实现，但所有驱动程序都是用可堆叠(stackable)的镜像层和写入时复制(copy-on-write)策略。</p>
<p><br></p>
<h4 id="容器大小"><a href="#容器大小" class="headerlink" title="容器大小"></a>容器大小</h4><p>Container size on disk</p>
<p>使用<code>docker ps -s(--size)</code>命令查看正在运行的容器的大小。有两个大小:</p>
<ul>
<li><p><code>size</code><br>每个容器的可写入层的数据量(在磁盘上的)</p>
</li>
<li><p><code>virtual size</code><br>容器使用的只读镜像的数据量加上容器可写入层大小</p>
</li>
</ul>
<p><br><br><br></p>
<h4 id="写入时复制"><a href="#写入时复制" class="headerlink" title="写入时复制"></a>写入时复制</h4><p>The copy-on-write (CoW) strategy</p>
<p>写入时复制是一种共享和复制文件以实现最高效率的策略。如果文件或目录存在于镜像的较低层中，而另外的层(包括可写入层)需要对其进行读取访问，则它只是用已有文件。第一次需要修改文件时，该文件将被复制到该层并进行修改。这最大限度减少了每个后续层的I/O和大小。</p>
<p><strong>共享促进了较小的容器</strong><br>Sharing promotes smaller images</p>
<p>当你创建和拉取镜像时，它们通常存储于本机的<code>/var/lib/docker</code>下。每层都存储在主机存储区内的特定目录下<code>/var/lib/docker/&lt;storage-driver&gt;/layers</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls /var/lib/docker/aufs/layers</span><br><span class="line"></span><br><span class="line">1d6674ff835b10f76e354806e16b950f91a191d3b471236609ab13a930275e24</span><br><span class="line">5dbb0cbe0148cf447b9464a358c1587be586058d9a4c9ce079320265e2bb94e7</span><br><span class="line">bef7199f2ed8e86fa4ada1309cfad3089e0542fec8894690529e4c04a7ca2d73</span><br><span class="line">ebf814eccfe98f2704660ca1d844e4348db3b5ccc637eb905d4818fbfb00a06a</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>复制使容器高效</strong><br>Copying makes containers efficient</p>
<p>容器不会更改的任何文件都不会被复制到此可写入层中。这意味着可写入层尽可能小。</p>
<p>当容器中存在的文件被修改时，存储驱动之赐你个写入时复制操作(CoW)。涉及的具体步骤取决于具体的存储驱动。</p>
<p>aufs, overlay, overlay2存储驱动 遵循的基本顺序:</p>
<ul>
<li>通过镜像层搜索要更新的文件</li>
<li>对找到的文件的第一个副本执行<code>copy_up</code>操作，将文件复制到容器的可写入层</li>
<li>任何修改应用于此复制的文件，并且该容器不能看到存在于较低层中的文件的只读副本</li>
</ul>
<p><br><br><br></p>
<h3 id="选择存储驱动"><a href="#选择存储驱动" class="headerlink" title="选择存储驱动"></a>选择存储驱动</h3><p>Select a storage driver</p>
<p>理想情况下，将很少的数据写入容器的可写入层，并且使用Docker volume写入数据。但某些工作负载要求你能够写入容器的可写入层，这就是存储驱动进来的地方。</p>
<p>存储驱动控制镜像和容器在Docker主机上的存储和管理方式。</p>
<p>考虑三个高层次因素：</p>
<ul>
<li><p>如果你的Kernel支持多个存储驱动，在没有指定存储驱动的情况下，Docker会列出要使用拿个存储驱动程序的优先级列表</p>
<ul>
<li>如果可能，将使用配置最少的存储驱动。如<code>brrfs</code>, <code>zfs</code></li>
<li>否则，请尝试在最常见的情况下使用具有最佳整体性能和稳定性的存储驱动程序<ul>
<li><code>overlay2</code>是首选(Docker CE的默认选择)，其次是<code>overlay</code>。这些都不需要额外的配置。</li>
<li><code>devicemapper</code>居次，但需要<code>direc-lvm</code>用于生产环境，因为<code>loopback-lvm</code>的性能很差。</li>
</ul>
</li>
</ul>
</li>
<li><p>你的选择会受限于Docker版本、操作系统和发行版</p>
</li>
<li><p>某些存储驱动要求你为文件系统使用特定格式</p>
</li>
<li><p>你的选择还取决于工作负载和所需的稳定级别</p>
</li>
</ul>
<p><br></p>
<h4 id="Linux发行版支持的存储驱动"><a href="#Linux发行版支持的存储驱动" class="headerlink" title="Linux发行版支持的存储驱动"></a>Linux发行版支持的存储驱动</h4><p><strong>Docker CE</strong></p>
<table>
<thead>
<tr>
<th>Linux distribution</th>
<th>Recommended storage drivers</th>
</tr>
</thead>
<tbody>
<tr>
<td>Docker CE on Ubuntu</td>
<td>aufs, devicemapper, overlay2 (Ubuntu 14.04.4 or later, 16.04 or later), overlay, zfs, vfs</td>
</tr>
<tr>
<td>Docker CE on Debian</td>
<td>aufs, devicemapper, overlay2 (Debian Stretch), overlay, vfs</td>
</tr>
<tr>
<td>Docker CE on CentOS</td>
<td>devicemapper, vfs</td>
</tr>
<tr>
<td>Docker CE on Fedora</td>
<td>devicemapper, overlay2 (Fedora 26 or later, experimental), overlay (experimental), vfs</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="存储驱动支持的文件系统"><a href="#存储驱动支持的文件系统" class="headerlink" title="存储驱动支持的文件系统"></a>存储驱动支持的文件系统</h4><table>
<thead>
<tr>
<th>Storage driver</th>
<th>Supported backing filesystems</th>
</tr>
</thead>
<tbody>
<tr>
<td>overlay, overlay2</td>
<td>ext4, xfs</td>
</tr>
<tr>
<td>aufs</td>
<td>ext4, xfs</td>
</tr>
<tr>
<td>devicemapper</td>
<td>direct-lvm</td>
</tr>
<tr>
<td>btrfs</td>
<td>btrfs</td>
</tr>
<tr>
<td>zfs</td>
<td>zfs</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="查看存储驱动"><a href="#查看存储驱动" class="headerlink" title="查看存储驱动"></a>查看存储驱动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Version: 18.03.1-ce</span><br><span class="line">Storage Driver: overlay2</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="AUFS存储驱动"><a href="#AUFS存储驱动" class="headerlink" title="AUFS存储驱动"></a>AUFS存储驱动</h3><p>AUFS is a union filesystem.</p>
<p>aufs存储驱动用于管理Ubuntu上Docker的镜像和层。</p>
<p>我的发行版是Centos，此驱动针对Ubuntu。注意</p>
<p><br></p>
<h4 id="使用aufs存储驱动配置Docker"><a href="#使用aufs存储驱动配置Docker" class="headerlink" title="使用aufs存储驱动配置Docker"></a>使用aufs存储驱动配置Docker</h4><ul>
<li>判断kernel是否支持aufs</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep aufs /proc/filesystems</span><br></pre></td></tr></table></figure>
<ul>
<li>查看Docker存储驱动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>
<ul>
<li>配置存储驱动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">--storage-driver</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="aufs存储驱动如何工作"><a href="#aufs存储驱动如何工作" class="headerlink" title="aufs存储驱动如何工作"></a>aufs存储驱动如何工作</h4><p>AUFS是一个联合文件系统，这意味着它在单个Linux主机上对多个目录进行分层并将它们呈现为单个目录。这些目录在AUFS术语中称为分支，在Docker术语中称为层。统一过程被称为联合安装。</p>
<p><img src="/images/Docker/aufs_layers.jpg" alt=""></p>
<p><br></p>
<h4 id="容器如何使用aufs进行读写"><a href="#容器如何使用aufs进行读写" class="headerlink" title="容器如何使用aufs进行读写"></a>容器如何使用aufs进行读写</h4><p><strong>读取文件</strong></p>
<p><br></p>
<h3 id="Btrfs存储驱动"><a href="#Btrfs存储驱动" class="headerlink" title="Btrfs存储驱动"></a>Btrfs存储驱动</h3><p>Use the BTRFS storage driver</p>
<p><br></p>
<h3 id="Device-Mapper存储驱动"><a href="#Device-Mapper存储驱动" class="headerlink" title="Device Mapper存储驱动"></a>Device Mapper存储驱动</h3><p>Use the Device Mapper storage driver</p>
<p>Device Mapper是基于kernel的框架，支持Linux上的许多高级卷管理技术。Docker的<code>devicemapper</code>存储驱动利用此框架的精简配置和快照功能进行镜像和容器管理。</p>
<p>对于支持它的系统，<code>devicemapper</code>支持包含在Linux内核中。但是，需要特定配置才能将其用于Docker。<code>devicemapper</code>驱动使用专用于Docker的块设备，并在块级(block level)而不是文件级(file level)运行。这些设备可通过在Docker主机添加物理设备来扩展，并且它们比咋子操作系统级别使用文件系统更好。</p>
<p><br></p>
<p><strong>依赖</strong></p>
<ul>
<li>Docker EE</li>
<li>Docker CE</li>
<li>更改存储驱动会使已创建的容器在本地系统上都无法访问</li>
</ul>
<p><br></p>
<p><strong>配置devicemapper存储驱动</strong></p>
<ul>
<li>loop-lvm</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#loop-lvm模式</span><br><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;storage-driver&quot;: &quot;devicemapper&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>
<ul>
<li>direct-lvm<br>生产环境的devicemapper存储驱动必须使用direct-lvm模式。此模式使用块设备创建精简池。这比使用loopback设备更快，更高效地使用系统资源，并且块设备可以根据需求进行扩展。</li>
</ul>
<p><br></p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Required</th>
<th>Default</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>dm.directlvm_device</td>
<td>The path to the block device to configure for direct-lvm.</td>
<td>Yes</td>
<td>-</td>
<td>dm.directlvm_device=”/dev/xvdf”</td>
</tr>
<tr>
<td>dm.thinp_percent</td>
<td>The percentage of space to use for storage from the passed in block device.</td>
<td>No</td>
<td>95</td>
<td>dm.thinp_percent=95</td>
</tr>
<tr>
<td>dm.thinp_metapercent</td>
<td>The percentage of space to for metadata storage from the passed-in block device.</td>
<td>No</td>
<td>1</td>
<td>dm.thinp_metapercent=1</td>
</tr>
<tr>
<td>dm.thinp_autoextend_threshold</td>
<td>The threshold for when lvm should automatically extend the thin pool as a percentage of the total storage space.</td>
<td>No</td>
<td>80</td>
<td>dm.thinp_autoextend_threshold=80</td>
</tr>
<tr>
<td>dm.thinp_autoextend_percent</td>
<td>The percentage to increase the thin pool by when an autoextend is triggered.</td>
<td>No</td>
<td>20</td>
<td>dm.thinp_autoextend_percent=20</td>
</tr>
<tr>
<td>dm.directlvm_device_force</td>
<td>Whether to format the block device even if a filesystem already exists on it. If set to false and a filesystem is present, an error is logged and the filesystem is left intact.</td>
<td>No</td>
<td>false</td>
<td>dm.directlvm_device_force=true</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#安装依赖</span><br><span class="line">RHEL / CentOS: device-mapper-persistent-data, lvm2, and all dependencies</span><br><span class="line">Ubuntu / Debian: thin-provisioning-tools, lvm2, and all dependencies</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建物理卷(physical volume)</span><br><span class="line">pvcreate /dev/cvdf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建卷组(volume group)</span><br><span class="line">vgcreat docker /dev/xvdf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建逻辑卷(logical volume)</span><br><span class="line">lvcreate --wipesignatures y -n thinpool docker -l 95%VG</span><br><span class="line">lvcreate --wipesignatures y -n thinpoolmeta docker -l 1%VG</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#转换卷为精简池</span><br><span class="line">lvconvert -y \</span><br><span class="line">--zero n \</span><br><span class="line">-c 512K \</span><br><span class="line">--thinpool docker/thinpool \</span><br><span class="line">--poolmetadata docker/thinpoolmeta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#配置lvm配置文件精简池自动扩展</span><br><span class="line">/etc/lvm/profile/docker-thinpool.profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定thin_pool_autoextend_threshold 和 thin_pool_autoextend_percent的值</span><br><span class="line">activation &#123;</span><br><span class="line">  thin_pool_autoextend_threshold=80</span><br><span class="line">  thin_pool_autoextend_percent=20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#应用LVM profile</span><br><span class="line">lvchange --metadataprofile docker-thinpool docker/thinpool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#启用监控LV</span><br><span class="line">lvs -o+seg_monitor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#配置devicemapper存储驱动</span><br><span class="line">/etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;storage-driver&quot;: &quot;devicemapper&quot;,</span><br><span class="line">    &quot;storage-opts&quot;: [</span><br><span class="line">    &quot;dm.thinpooldev=/dev/mapper/docker-thinpool&quot;,</span><br><span class="line">    &quot;dm.use_deferred_removal=true&quot;,</span><br><span class="line">    &quot;dm.use_deferred_deletion=true&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="管理devicemapper"><a href="#管理devicemapper" class="headerlink" title="管理devicemapper"></a>管理devicemapper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查看LVM logs</span><br><span class="line">journalctl -fu dm-event.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pvdisplay</span><br><span class="line">vgdisplay/vgextend</span><br><span class="line">lvdisplay/lvextend/lvchange</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="OverlayFS存储驱动"><a href="#OverlayFS存储驱动" class="headerlink" title="OverlayFS存储驱动"></a>OverlayFS存储驱动</h3><p>Use the OverlayFS storage driver</p>
<p><br></p>
<h3 id="ZFS存储驱动"><a href="#ZFS存储驱动" class="headerlink" title="ZFS存储驱动"></a>ZFS存储驱动</h3><p>Use the ZFS storage driver</p>
<p><br></p>
<h3 id="VFS存储驱动"><a href="#VFS存储驱动" class="headerlink" title="VFS存储驱动"></a>VFS存储驱动</h3><p>Use the VFS storage driver</p>
<p>VFS存储驱动不是联合文件系统，相反，每层都是磁盘上的一个目录，它不支持CoW。要创建一个新层，先前的层会进行<strong>深层复制(deep copy)</strong>。与其它驱动相比，这导致磁盘性能下降和占用更多磁盘空间。但是，它强大，稳定，适用于各种环境。</p>
<p><strong>配置VFS存储驱动</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;storage-driver&quot;: &quot;vfs&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#控制大小</span><br><span class="line">&#123;</span><br><span class="line">  &quot;storage-opts&quot;: [&quot;size=256M&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<hr>
<p><br></p>
<h1 id="在生产环境运行应用程序"><a href="#在生产环境运行应用程序" class="headerlink" title="在生产环境运行应用程序"></a>在生产环境运行应用程序</h1><p>Run your app in production</p>
<p><br></p>
<h2 id="配置对象"><a href="#配置对象" class="headerlink" title="配置对象"></a>配置对象</h2><p>Configure all objects</p>
<p><br></p>
<h3 id="自定义原数据"><a href="#自定义原数据" class="headerlink" title="自定义原数据"></a>自定义原数据</h3><p>Apply custom metadata to objects</p>
<p><strong>Docker object label</strong><br>标签(label)是一种将原数据(metadata)应用于docker object的机制，包含:</p>
<ul>
<li>image</li>
<li>container</li>
<li>local daemon</li>
<li>volume</li>
<li>network</li>
<li>node</li>
<li>service</li>
</ul>
<p><br></p>
<h4 id="label-key-and-value"><a href="#label-key-and-value" class="headerlink" title="label key and value"></a>label key and value</h4><p>标签是一组键值对，以字符串形式存储。可以为对象指定多个标签，但每个键值对必须唯一。如果一个键有多个值，则最新写入的值会覆盖以前的值。</p>
<p><strong>key格式建议</strong><br>label key是可能包含字母，数字，<code>.</code>，<code>-</code>组成的字符串。</p>
<ul>
<li>第三方工具的作者给每个label key加上前缀域，如<code>com.example.some-label</code></li>
<li>未经允许，不得使用他人域</li>
<li><code>com.docker.*</code>, <code>io.docker.*</code>, <code>org.dockerproject.*</code>命名空间保留给Docker内部使用</li>
<li>以小写字母开头和结尾</li>
<li>用<code>.</code>分割命令空间字段</li>
</ul>
<p><br></p>
<p><strong>value 指南</strong><br>label value可以包含任何可表示为字符串的数据类型，包括JSON, XML, CSV, YAML…唯一的要求是，首先使用特定于结构类型的机制将该值序列化为字符串。</p>
<p><br><br><br></p>
<h3 id="清理未使用的对象"><a href="#清理未使用的对象" class="headerlink" title="清理未使用的对象"></a>清理未使用的对象</h3><p>Prune unused Docker objects</p>
<p>Docker采取保守的方法来清理未使用的对象(通常称为垃圾回收)，通常它不会删除这些对象，除非你明确要求Docker这样做。对于每个类型的对象，docker提供了<code>prune</code>命令。你也可以使用<code>docker system prune</code>命令一次清理多种类型的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#prune image</span><br><span class="line">docker image prune</span><br><span class="line"> docker image prune -a --filter &quot;until=24h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#prune container</span><br><span class="line">docker container prune</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#prune volume</span><br><span class="line">docker volume prune</span><br><span class="line">docker volume prune --filter &quot;label!=keep&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#prune everything</span><br><span class="line">docker system prune</span><br><span class="line">docker system prune --volumes</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>Format command and log output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#join</span><br><span class="line">docker inspect --format &apos;&#123;&#123;join .Args &quot; , &quot;&#125;&#125;&apos; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#json</span><br><span class="line">docker inspect --format &apos;&#123;&#123;json .Mounts&#125;&#125;&apos; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#lower</span><br><span class="line">docker inspect --format &quot;&#123;&#123;lower .Name&#125;&#125;&quot; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#split</span><br><span class="line">docker inspect --format &apos;&#123;&#123;split .Image &quot;:&quot;&#125;&#125;&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#title</span><br><span class="line">docker inspect --format &quot;&#123;&#123;title .Name&#125;&#125;&quot; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#upper</span><br><span class="line">docker inspect --format &quot;&#123;&#123;upper .Name&#125;&#125;&quot; container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#printIn</span><br><span class="line">docker inspect --format=&apos;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;println .IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&apos; container</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="配置daemon"><a href="#配置daemon" class="headerlink" title="配置daemon"></a>配置daemon</h2><p>Configure the daemon</p>
<p><br></p>
<h3 id="配置和运行Docker"><a href="#配置和运行Docker" class="headerlink" title="配置和运行Docker"></a>配置和运行Docker</h3><p><strong>配置docker daemon</strong></p>
<ul>
<li>使用json配置文件</li>
<li>使用<code>dockerd --flag</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;debug&quot;: true,</span><br><span class="line">  &quot;tls&quot;: true,</span><br><span class="line">  &quot;tlscert&quot;: &quot;/var/docker/server.pem&quot;,</span><br><span class="line">  &quot;tlskey&quot;: &quot;/var/docker/serverkey.pem&quot;,</span><br><span class="line">  &quot;hosts&quot;: [&quot;tcp://192.168.59.3:2376&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#或</span><br><span class="line">dockerd --debug \</span><br><span class="line">  --tls=true \</span><br><span class="line">  --tlscert=/var/docker/server.pem \</span><br><span class="line">  --tlskey=/var/docker/serverkey.pem \</span><br><span class="line">  --host tcp://192.168.59.3:2376</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>docker daemon目录</strong><br>docker daemon将所有数据保存在一个目录中。你可以手动修改它。</p>
<p>默认目录:</p>
<ul>
<li>Linux： <code>/var/lib/docker</code></li>
<li>Windows: <code>C:\ProgramData\docker</code></li>
</ul>
<p><br><br><br></p>
<h3 id="使用systemd控制docker"><a href="#使用systemd控制docker" class="headerlink" title="使用systemd控制docker"></a>使用systemd控制docker</h3><p>Control Docker with systemd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/lib/systemd/system/docker.service</span><br><span class="line">#or</span><br><span class="line">cat /etc/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl enable/start/stop/status docker</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>自定义docker daemon选项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;data-root&quot;: &quot;/mnt/docker-data&quot;,</span><br><span class="line">    &quot;storage-driver&quot;: &quot;overlay&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>http/https proxy</strong><br>Docker daemon使用<code>HTTP_PROXY</code>，<code>HTTPS_PROXY</code>和<code>NO_PROXY</code>环境变量来配置代理行为。无法使用<code>daemon.json</code>文件来配置环境变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#/etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot;</span><br><span class="line"></span><br><span class="line">#/etc/systemd/system/docker.service.d/https-proxy.conf</span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTPS_PROXY=https://proxy.example.com:443/&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl show --property=Environment docker</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="收集Docker指标"><a href="#收集Docker指标" class="headerlink" title="收集Docker指标"></a>收集Docker指标</h3><p>Collect Docker metrics with Prometheus</p>
<p>Promethus: <a href="https://prometheus.io/" target="_blank" rel="noopener">https://prometheus.io/</a><br>Prometheus是一个开源的系统监控和报警工具包。你可以将Docker配置为Prometheus target。设置Prometheus作为Docker容器运行，并使用Prometheus监控Docker实例。</p>
<p><strong>配置Docker</strong><br>配置docker daemon作为Prometheus target，你需要指定<code>metrics-address</code>。最佳方式是通过<code>daemon.json</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;metrics-addr&quot; : &quot;127.0.0.1:9323&quot;,</span><br><span class="line">  &quot;experimental&quot; : true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>配置和运行Prometheus</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/tmp/prometheus.yml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># my global config</span><br><span class="line">global:</span><br><span class="line">  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br><span class="line">  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.</span><br><span class="line">  # scrape_timeout is set to the global default (10s).</span><br><span class="line"></span><br><span class="line">  # Attach these labels to any time series or alerts when communicating with</span><br><span class="line">  # external systems (federation, remote storage, Alertmanager).</span><br><span class="line">  external_labels:</span><br><span class="line">      monitor: &apos;codelab-monitor&apos;</span><br><span class="line"></span><br><span class="line"># Load rules once and periodically evaluate them according to the global &apos;evaluation_interval&apos;.</span><br><span class="line">rule_files:</span><br><span class="line">  # - &quot;first.rules&quot;</span><br><span class="line">  # - &quot;second.rules&quot;</span><br><span class="line"></span><br><span class="line"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class="line"># Here it&apos;s Prometheus itself.</span><br><span class="line">scrape_configs:</span><br><span class="line">  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br><span class="line">  - job_name: &apos;prometheus&apos;</span><br><span class="line"></span><br><span class="line">    # metrics_path defaults to &apos;/metrics&apos;</span><br><span class="line">    # scheme defaults to &apos;http&apos;.</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&apos;localhost:9090&apos;]</span><br><span class="line"></span><br><span class="line">  - job_name: &apos;docker&apos;</span><br><span class="line">         # metrics_path defaults to &apos;/metrics&apos;</span><br><span class="line">         # scheme defaults to &apos;http&apos;.</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&apos;localhost:9323&apos;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker service create --replicas 1 --name my-prometheus \</span><br><span class="line">    --mount type=bind,source=/tmp/prometheus.yml,destination=/etc/prometheus/prometheus.yml \</span><br><span class="line">    --publish published=9090,target=9090,protocol=tcp \</span><br><span class="line">    prom/prometheus</span><br></pre></td></tr></table></figure>
<p>访问: <a href="http://localhost:9090/targets/" target="_blank" rel="noopener">http://localhost:9090/targets/</a></p>
<p><br><br><br></p>
<h2 id="配置容器"><a href="#配置容器" class="headerlink" title="配置容器"></a>配置容器</h2><p>Configure containers</p>
<h3 id="自动启动容器"><a href="#自动启动容器" class="headerlink" title="自动启动容器"></a>自动启动容器</h3><p>Start containers automatically</p>
<p>Docker提供了重启策略，以控制容器在退出或重启时自动启动。重启策略可确保链接的容器以正确的书序启动。Docker建议你使用重启策略，并避免使用进程管理器(如supervisor)来启动容器。<br>重启策略与<code>docker xxx --live-restart</code>标志不同，后者可以让你在Docker upgrage期间保持容器运行。</p>
<p><br></p>
<p><strong>重启策略</strong><br>使用<code>docker run xxx --restart</code>标志来配置重启策略，<code>--restart</code>的值如下：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>no</td>
<td>不要自动重启容器(默认值)</td>
</tr>
<tr>
<td>on-failure</td>
<td>如果容器由于错误(非零退出码)退出，则重启容器</td>
</tr>
<tr>
<td>unless-stopped</td>
<td>除非明确停止或docker本身停止或重启，则重启容器</td>
</tr>
<tr>
<td>always</td>
<td>如果停止，则始终重启容器</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#栗子</span><br><span class="line">docker run -dit --restart unless-stopped redis</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>重启策略注意事项</strong></p>
<ul>
<li><p>重启策略尽在容器成功启动后才生效——这意味着容器已启动至少10s，并且Docker已开始监视它。<br>这可以防止根本不启动的容器进入重启循环。</p>
</li>
<li><p>如果你手动停止容器(状态码为0)，则在重启Docker daemon或手动启动容器之前，其重启策略将会被忽略。<br>这是另一个防止重启循环的尝试。</p>
</li>
<li><p>重启策略仅适用于容器。集群服务的重启策略与此不同。</p>
</li>
</ul>
<p><br><br><br></p>
<h3 id="在daemon停机期间保持容器活着"><a href="#在daemon停机期间保持容器活着" class="headerlink" title="在daemon停机期间保持容器活着"></a>在daemon停机期间保持容器活着</h3><p>Keep containers alive during daemon downtime</p>
<p>默认情况下，当Docker daemon终止时，它会关闭正在运行的容器。从Docker Engine 1.12开始，你可配置守护进程，以便在守护进程不可用时容器保持运行。这个功能被称为<strong>实时恢复(live restore)</strong>。<br>它不支持Windows container。</p>
<p><br></p>
<p><strong>实时恢复</strong><br>有两种方式来启用live restore，只启用其中一个就好。<br>实时恢复仅适用于独立容器，不适用于集群服务。</p>
<ul>
<li>修改配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--live-restore</code>标志<br>不推荐</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockerd xxx --live-restore</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="在一个容器中运行多个服务"><a href="#在一个容器中运行多个服务" class="headerlink" title="在一个容器中运行多个服务"></a>在一个容器中运行多个服务</h3><p>Run multiple services in a container</p>
<p>容器的主要运行进程是Dockerfile末尾的<code>ENTRYPOINT</code>或<code>CMD</code>指令。通常建议你通过每个容器运行一项服务来分割关注区域。这些服务可能会分成多个进程(如Nginx的worker processe)。你可以使用用户定义的network和shared volumes来连接多个容器。</p>
<p>容器的主进程负责管理它启动的所有进程。在某些情况下，主进程设计不好，在容器退出时无法正常处理<strong>停止</strong>子进程。如果你的进程属于这个类别，你可在容器运行时使用<code>--init</code>选型。<code>--init</code>标志将一个微小的<code>inti-process</code>作为主进程插入到容器中，并在容器退出时处理所有进程的停止。以这种方式处理这些进程优于使用完整的初始化进程。</p>
<p><br></p>
<p>如果你需要在一个容器中运行多个服务，则可通过几种不同方式来完成此操作。</p>
<ul>
<li>将所有命令封装进一个脚本中，并附带测试和调试信息。以封装脚本作为你的CMD</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vim my_wrapper.sh</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">xxxxx</span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim Dockerfile</span><br><span class="line"></span><br><span class="line">FROM ubuntu:latest</span><br><span class="line">COPY my_first_process my_first_process</span><br><span class="line">COPY my_second_process my_second_process</span><br><span class="line">COPY my_wrapper_script.sh my_wrapper_script.sh</span><br><span class="line">CMD ./my_wrapper_script.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>使用如<code>supervisord</code>这样的进程管理器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y supervisor</span><br><span class="line">RUN mkdir -p /var/log/supervisor</span><br><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br><span class="line">COPY my_first_process my_first_process</span><br><span class="line">COPY my_second_process my_second_process</span><br><span class="line">CMD [&quot;/usr/bin/supervisord&quot;]</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="容器运行指标"><a href="#容器运行指标" class="headerlink" title="容器运行指标"></a>容器运行指标</h3><p>Container runtime metrics</p>
<p><strong>docker stats</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker stats redis1 redis2</span><br><span class="line"></span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O</span><br><span class="line">redis1              0.07%               796 KB / 64 MB        1.21%               788 B / 648 B       3.568 MB / 512 KB</span><br><span class="line">redis2              0.07%               2.746 MB / 64 MB      4.29%               1.266 KB / 648 B    12.4 MB / 0 B</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>Control groups</strong></p>
<p>Linux Container依赖于<code>control group</code>，这些组不仅跟踪进程组，还公开有关CPU，mem，block I/O的使用情况和度量标准。你可以访问这些指标并判断容器运行状况。<br>control group通过为文件系统(pseudo-fs)公开，你应该可在<code>/proc/fs/cgroup</code>中找到它。</p>
<p>查看cgroup子系统：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">grep cgroup /proc/mounts</span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">mount -l | grep cgroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#进程</span><br><span class="line">/proc/&lt;pid&gt;/cgroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#/表示进程尚未分配给group</span><br><span class="line">cat /proc/1/cgroup</span><br><span class="line">11:devices:/</span><br><span class="line">10:cpuset:/</span><br><span class="line">9:hugetlb:/</span><br><span class="line">8:memory:/</span><br><span class="line">7:blkio:/</span><br><span class="line">6:net_prio,net_cls:/</span><br><span class="line">5:pids:/</span><br><span class="line">4:perf_event:/</span><br><span class="line">3:cpuacct,cpu:/</span><br><span class="line">2:freezer:/</span><br><span class="line">1:name=systemd:/</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>查找给定容器的cgroup</strong><br>对于每个容器，每个层次结构中创建一个cgroup。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/sys/fs/cgroup/memory/docker/&lt;docker-longid&gt;/</span><br><span class="line"></span><br><span class="line">cd /sys/fs/cgroup/memory/docker/893903129d869f384bd78d63a382f1c9527d6979be0a6cf3c13ea4f45a1554d6</span><br><span class="line">cat memory.stat</span><br><span class="line"></span><br><span class="line">cache 36282368</span><br><span class="line">rss 196608</span><br><span class="line">rss_huge 0</span><br><span class="line">mapped_file 1077248</span><br><span class="line">swap 0</span><br><span class="line">pgpgin 212904</span><br><span class="line">pgpgout 205531</span><br><span class="line">pgfault 314692</span><br><span class="line">pgmajfault 204</span><br><span class="line">inactive_anon 131072</span><br><span class="line">active_anon 65536</span><br><span class="line">inactive_file 18223104</span><br><span class="line">active_file 18059264</span><br><span class="line">unevictable 0</span><br><span class="line">hierarchical_memory_limit 9223372036854771712</span><br><span class="line">hierarchical_memsw_limit 9223372036854771712</span><br><span class="line">total_cache 36282368</span><br><span class="line">total_rss 196608</span><br><span class="line">total_rss_huge 0</span><br><span class="line">total_mapped_file 1077248</span><br><span class="line">total_swap 0</span><br><span class="line">total_pgpgin 212904</span><br><span class="line">total_pgpgout 205531</span><br><span class="line">total_pgfault 314692</span><br><span class="line">total_pgmajfault 204</span><br><span class="line">total_inactive_anon 131072</span><br><span class="line">total_active_anon 65536</span><br><span class="line">total_inactive_file 18223104</span><br><span class="line">total_active_file 18059264</span><br><span class="line">total_unevictable 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#其它信息类似</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="限制容器的资源"><a href="#限制容器的资源" class="headerlink" title="限制容器的资源"></a>限制容器的资源</h3><p>Limit a container’s resources</p>
<p>默认情况下，容器没有资源限制，可以使用主机内核调度程序允许给定的资源。Docker提供了一些方法来控制容器可以使用的CPU、memory、block I/O。</p>
<p>许多这些功能需要内核的支持。使用<code>docker info</code>命令检查是否支持。如果内核禁用了某功能，则可能会有如下警告: <strong>WARNING: No swap limit support</strong></p>
<p><br></p>
<h4 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h4><p><strong>你需要了解内存耗尽(out of memory)的风险</strong><br>不要让正在运行的容器消耗太多的主机内存，这很重要。在Linux主机上，如果内核检测到没有足够的内存来执行重要的系统功能，它会抛出一个<strong>OOME(out of memory exception)</strong>，并开始killing process以释放进程。任何进程都会是killing objects，包括Docker和其它重要应用程序。</p>
<p>docker尝试通过调整docker daemon的OOM优先级来降低这些风险，从而使其比系统上的其它进程更小(less)可能的被killing。容器的OOM优先级不进行调整，这使得单个容器被killing的可能性要大于docker或其它进程。你不应该给docker daemon的<code>--oom-score-adj</code>或container的<code>--oom-kill-disable</code>标志来绕过这些安全措施。</p>
<p>你可以通过以下方式减轻由OOM引起的系统不稳定的风险:</p>
<ul>
<li>在上线之前，进行测试以了解应用程序的内存需求</li>
<li>确保应用程序仅在拥有足够资源的主机上运行</li>
<li>限制容器可使用的内存量</li>
<li>在主机上配置swap时请注意。swap比内存更慢，性能更低，但可以提供缓冲区以防系统内存耗尽</li>
<li>考虑将容器转换为服务，并使用服务级别约束和节点标签来确保应用程序仅在具有足够内存的主机上运行</li>
</ul>
<p><br></p>
<p><strong>限制容器对内存的</strong><br>Limit a container’s access to memory</p>
<p>Docker可以强制<code>hard limit</code>，允许容器使用不超过给定数量的用户/系统内存，或<code>soft limit</code>。这允许容器使用尽可能多的内存。</p>
<p>如下这些选项具有这样一些效果，注意内存单位<code>b, k, m, g</code>：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-m/--memory=</code></td>
<td>容器可使用的最大内存量。如果你设置此选项，则允许的最小值为4m</td>
</tr>
<tr>
<td><code>--memory-swap</code></td>
<td>容器允许使用的swap量。只有在<code>--momery</code>设置时才有意义</td>
</tr>
<tr>
<td><code>--memory-swappiness</code></td>
<td>默认情况下，容器可使用的主机内核可交换的匿名页面的百分比<0-100></0-100></td>
</tr>
<tr>
<td><code>--memory-reservation</code></td>
<td>允许你指定一个小于<code>--memory</code>的soft limit。当docker检测到内存不足时，此会被激活</td>
</tr>
<tr>
<td><code>--kernel-memory</code></td>
<td>容器可以使用的最大kernel memory。内核内存不能够被swap out，因此内核内存不足的容器可能会阻塞主机资源，这会对主机和其它容器产生副作用</td>
</tr>
<tr>
<td><code>--oom-kill-disable</code></td>
<td>默认情况下，如果发生内存溢出(OOM)，内核会杀死容器中的进程。使用此选项改变此行为</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h4><p>默认情况下，每个容器对主机CPU周期的访问是无限制的。你可以设置各种约束来限制给定容器访问主机的CPU周期。</p>
<p><strong>CFS scheduler</strong><br>CFS是用于普通Linux进程的Linux kernel CPU调度器，一些运行时标志用于配置容器的CPU资源访问量。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--cpu=&lt;value&gt;</code></td>
<td>指定容器可以使用的CPU资源，如<code>--cpu=&quot;1.6&quot;</code></td>
</tr>
<tr>
<td><code>--cpu-period=&lt;value&gt;</code></td>
<td>指定CFS调度器周期，它与<code>--cpu-quota</code>一起使用。默认100ms。Docker1.13以后，使用<code>--cpus</code>替代</td>
</tr>
<tr>
<td><code>--cpu-quota=&lt;value&gt;</code></td>
<td>在容器上条件CFS配额。在Docker1.13以后，使用<code>--cpus</code>替代</td>
</tr>
<tr>
<td><code>--cpuset-cpus</code></td>
<td>限制容器可以使用的特定CPU或CORE。如果有多个CPU，请使用逗号<code>,</code>分割。如<code>0,2</code></td>
</tr>
<tr>
<td><code>--cpu-shares</code></td>
<td>将此标志设置为大于/小于1024(默认值)的值，以增加或减少容器的重量，并使其能够访问更大或更小比例的主机CPU周期。这仅在CPU周期受到限制时才会执行。</td>
</tr>
</tbody>
</table>
<p>如果你只有1 CPU，如下命令可保证容器每秒最多有50%的CPU——<code>docker run -it --cpus=&quot;.5&quot; xxx</code></p>
<p><br></p>
<p><strong>realtime scheduler</strong></p>
<p>在Docker1.13及更高版本，对于无法使用CFS的任务，你可以使用realtime scheduler。<br>在你配置docker daemon和container之前，请正确地配置主机内核。</p>
<p><strong>注意： CPU调度和优先级是高级内核功能。大多数用户不需要修改它。错误地设置将导致主机系统不稳定或不可用。</strong></p>
<ul>
<li><p>配置主机内核<br>通过运行<code>zcat /proc/config.gz | grep CONFIG_RT_GROUP_SCHED</code>或检查<code>/sys/fs/cgroup/cpu.rt_runtime_us</code>来验证内核是否启用了<code>CONFIG_RT_GROUP_SCHED</code>。有关配置内核实时调度器的指导，请参考相关文档。</p>
</li>
<li><p>配置docker daemon<br>运行docker daemon时使用<code>--cpu-rt-runtime</code>标志设置每个运行时间段的实时任务保留的最大微秒数。可使用systemd的docker.service进行配置。</p>
</li>
<li><p>配置独立容器<br>当使用<code>docker run</code>启动容器时，可以传递多个标志来控制容器CPU的优先级。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--cap-add=sys_nice</code></td>
<td>授予容器<code>CAP_SYS_NICE</code>功能，允许容器提升进程的nice值，设置实时调度策略，设置CPU关联和其它操作</td>
</tr>
<tr>
<td><code>--cpu-rt-runtime=&lt;value&gt;</code></td>
<td>Docker实时调度器期间，容器可以以实时优先级运行的最大微秒数。需要<code>--cap-add=sys_nice</code>标志</td>
</tr>
<tr>
<td><code>--ulimit rtprio=&lt;value&gt;</code></td>
<td>容器允许的最大实时优先级，需要<code>--cap-add=sys_nice</code>标志</td>
</tr>
</tbody>
</table>
<p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --it --cpu-rt-runtime=950000 \</span><br><span class="line">                  --ulimit rtprio=99 \</span><br><span class="line">                  --cap-add=sys_nice \</span><br><span class="line">                  debian:jessie</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><h4 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h4><p>记录的信息和日志格式取决于容器的端点命令。<br><code>docker logs</code>命令显示正在运行的容器记录的信息。<br><code>docker service logs</code>命令显示参与服务的所有容器记录的信息。在swarm模式下。</p>
<p>在某些情况下，<code>docker logs</code>可能不会显示有用的信息，除非你采取其它措施。</p>
<ul>
<li>如果将日志发送到文件、主机、数据库或其它日志驱动程序，则<code>docker logs</code>可能不会显示有用的信息</li>
<li>如果你的镜像运行non-interactive进程(如数据库)，则该应用程序可能会将output发送到日志文件而不是stdout/stderr</li>
</ul>
<p><br></p>
<h4 id="配置日志驱动"><a href="#配置日志驱动" class="headerlink" title="配置日志驱动"></a>配置日志驱动</h4><p>Configure logging drivers</p>
<p>docker提供了多种日志记录机制(logging mechanisms)来帮助你从运行的容器和服务中获取信息。这些机制被称为日志驱动(logging driver)。<br>每个docker daemon都有一个默认日志驱动，每个容器也默认使用该驱动。除非你给容器配置了其它日志驱动。<br>除了使用docker附带日志驱动，在Docker v17.05之后，你还可以使用日志驱动插件(logging driver plugin)。</p>
<p><br></p>
<p><strong>配置默认日志驱动</strong><br>默认的日志驱动是<code>json-flie</code>。<br>可在<code>daemon.json</code>文件里通过<code>log-driver</code>选项匹配置日志驱动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">#设置为syslog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;syslog&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果日志驱动存在可配置选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;labels&quot;: &quot;production_status&quot;,</span><br><span class="line">    &quot;env&quot;: &quot;os,customer&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">docker info | grep &apos;Loggin Driver&apos;</span><br><span class="line">Logging Driver: json-file</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>为容器配置日志驱动</strong><br>启动容器时，可使用<code>--log-driver</code>标志为其配置不同于docker daemon的日志驱动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --log-driver none alpine ash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看容器日志驱动</span><br><span class="line">docker inspect -f &apos;&#123;&#123;.HostConfig.LogConfig.Type&#125;&#125;&apos; &lt;CONTAINER&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>配置从容器到日志驱动的log message的交付模式</strong><br>Docker为从容器到日志驱动的日志消息提供了两种交付(delivery）模式：</p>
<ul>
<li><p>直接阻塞(blocking)从容器到驱动的交付(默认)</p>
</li>
<li><p>非阻塞交付(non-blocking)，将日志消息存储在中间每个容器的环形缓冲区中供驱动使用<br>非阻塞消息交付模式可防止应用程序因日志反压而被阻塞。当STDERR或STDOUT流阻塞时，应用程序可能会以意想不到的方式失败。</p>
</li>
</ul>
<p><strong>注意：当缓冲区已满且新消息排入队列时，内存中最早的消息将被丢弃。丢弃消息通常首选阻止应用程序的日志写入过程。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --log-opt mode=non-blocking --log-opt max-buffer-size=4m alpine ping 127.0.0.1</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>日志驱动使用环境变量或label</strong><br>一些日志驱动将容器的<code>--env/-e</code>或<code>--label</code>标签的值添加到容器的日志中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --label production_status=testing -e os=ubuntu alpine sh</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>支持的日志驱动</strong><br>如下是受支持的日志驱动。</p>
<table>
<thead>
<tr>
<th>驱动</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>No logs are available for the container and docker logs does not return any output.</td>
</tr>
<tr>
<td>json-file</td>
<td>The logs are formatted as JSON. The default logging driver for Docker.</td>
</tr>
<tr>
<td>syslog</td>
<td>Writes logging messages to the syslog facility. The syslog daemon must be running on the host machine.</td>
</tr>
<tr>
<td>journald</td>
<td>Writes log messages to journald. The journald daemon must be running on the host machine.</td>
</tr>
<tr>
<td>gelf</td>
<td>Writes log messages to a Graylog Extended Log Format (GELF) endpoint such as Graylog or Logstash.</td>
</tr>
<tr>
<td>fluentd</td>
<td>Writes log messages to fluentd (forward input). The fluentd daemon must be running on the host machine.</td>
</tr>
<tr>
<td>splunk</td>
<td>Writes log messages to splunk using the HTTP Event Collector.</td>
</tr>
<tr>
<td>logentries</td>
<td>Writes log messages to Rapid7 Logentries.</td>
</tr>
<tr>
<td>云日志系统</td>
<td>各类云服务商提供的云日志系统</td>
</tr>
</tbody>
</table>
<p><code>docker logs</code>命令不适用于除<code>json-file</code>和<code>journald</code>之外的其它日志驱动。</p>
<p><br></p>
<h4 id="日志驱动插件"><a href="#日志驱动插件" class="headerlink" title="日志驱动插件"></a>日志驱动插件</h4><p>日志驱动插件允许你扩展和定制docker的日志记录功能，超越了内置的日志驱动的功能。</p>
<ul>
<li>安装日志驱动插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker plugin install &lt;org/image&gt;</span><br><span class="line"></span><br><span class="line">docker plugin ls</span><br></pre></td></tr></table></figure>
<ul>
<li>将插件配置为docker daemon默认日志驱动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.josn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">--loggin-driver</span><br></pre></td></tr></table></figure>
<ul>
<li>将插件配置为容器日志驱动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run xxx --log-driver</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="定制日志驱动输出"><a href="#定制日志驱动输出" class="headerlink" title="定制日志驱动输出"></a>定制日志驱动输出</h4><p>Customize log driver output</p>
<p>日志选项<code>tag</code>指定如何格式化表示容器日志消息。默认情况下，系统使用容器ID的前12个字符。你可以指定<code>tag</code>选项来覆盖此行为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">log</span>-driver=fluentd \</span><br><span class="line">		  --<span class="built_in">log</span>-opt fluentd-address=myhost.local:24224 \</span><br><span class="line">		  --<span class="built_in">log</span>-opt tag=<span class="string">"mailer"</span></span><br></pre></td></tr></table></figure>
<p>在指定<code>tag</code>时，Docker支持的一些特殊模板标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;.ID&#125;&#125;</span><br><span class="line">The first 12 characters of the container ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.FullID&#125;&#125;</span><br><span class="line">The full container ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.Name&#125;&#125;</span><br><span class="line">The container name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.ImageID&#125;&#125;</span><br><span class="line">The first 12 characters of the container’s image ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.ImageFullID&#125;&#125;</span><br><span class="line">The container’s full image ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.ImageName&#125;&#125;</span><br><span class="line">The name of the image used by the container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;.DaemonName&#125;&#125;</span><br><span class="line">The name of the docker program (docker)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--log-opt tag=&quot;&#123;&#123;.ImageName&#125;&#125;/&#123;&#123;.Name&#125;&#125;/&#123;&#123;.ID&#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line">Aug  7 18:33:19 HOSTNAME hello-world/foobar/5790672ab6a0[9103]: Hello from Docker.</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="日志驱动"><a href="#日志驱动" class="headerlink" title="日志驱动"></a>日志驱动</h4><p>介绍如下日志驱动！</p>
<h5 id="Logentries"><a href="#Logentries" class="headerlink" title="Logentries"></a>Logentries</h5><p>Logentries日志驱动将容器日志发送到Logentries server。</p>
<p><code>--log-opt</code>:</p>
<ul>
<li><code>logentries-token</code>: 指定Logentries log设置的token</li>
<li><code>line-only</code>: 仅发送原始有效载荷</li>
</ul>
<p>docker daemon:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dockerd --log-driver=logentries</span><br><span class="line"></span><br><span class="line">#可在docker.service中设置</span><br></pre></td></tr></table></figure>
<p>docker container:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --log-driver=logentries ...</span><br></pre></td></tr></table></figure>
<p>在使用此日志驱动之前，你需要在Logentries web界面中创建一个新的日志集，并将该日志集的令牌传递给docker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --log-driver=logentries --log-opt logentries-token=abcd1234-12ab-34cd-5678-0123456789ab</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="json-file"><a href="#json-file" class="headerlink" title="json file"></a>json file</h5><p>默认情况下，docker捕获所有容器的STDOUT和STDERR，并使用json格式将它们写入文件。每个文件包含仅包含一个容器的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;10m&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">docker run \</span><br><span class="line">      --log-driver json-file --log-opt max-size=10m \</span><br><span class="line">      alpine echo hello world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#栗子</span><br><span class="line">docker run -it --log-opt max-size=10m --log-opt max-file=3 alpine ash</span><br></pre></td></tr></table></figure>
<p>json-file支持的日志选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
<th>栗子</th>
</tr>
</thead>
<tbody>
<tr>
<td>max-size</td>
<td>The maximum size of the log before it is rolled. A positive integer plus a modifier representing the unit of measure (k, m, or g). Defaults to -1 (unlimited).</td>
<td>–log-opt max-size=10m</td>
</tr>
<tr>
<td>max-file</td>
<td>The maximum number of log files that can be present. If rolling the logs creates excess files, the oldest file is removed. Only effective when max-size is also set. A positive integer. Defaults to 1.</td>
<td>–log-opt max-file=3</td>
</tr>
<tr>
<td>labels</td>
<td>Applies when starting the Docker daemon. A comma-separated list of logging-related labels this daemon accepts. Used for advanced log tag options.</td>
<td>–log-opt labels=production_status,geo</td>
</tr>
<tr>
<td>env</td>
<td>Applies when starting the Docker daemon. A comma-separated list of logging-related environment variables this daemon accepts. Used for advanced log tag options.</td>
<td>–log-opt env=os,customer</td>
</tr>
<tr>
<td>env-regex</td>
<td>Similar to and compatible with env. A regular expression to match logging-related environment variables. Used for advanced log tag options.</td>
<td>–log-opt env-regex=^(os或customer).</td>
</tr>
</tbody>
</table>
<p><br></p>
<h5 id="Graylog-Extended-Format-gelf"><a href="#Graylog-Extended-Format-gelf" class="headerlink" title="Graylog Extended Format(gelf)"></a>Graylog Extended Format(gelf)</h5><p><code>gelf</code>日志驱动是一种方便的格式，可被Graylog, Logstash, Fluentd等工具所理解。许多工具使用这种格式。</p>
<p>在GELF中，每条日志消息都是带有一下字段的字典：</p>
<ul>
<li>version</li>
<li>host</li>
<li>timestamp</li>
<li>short and long version of the message</li>
<li>自定义的字段</li>
</ul>
<p><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;gelf&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;gelf-address&quot;: &quot;udp://1.2.3.4:12201&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">dockerd --log-driver gelf –-log-opt gelf-address=udp://1.2.3.4:12201</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#容器</span><br><span class="line">docker run \</span><br><span class="line">      --log-driver gelf –-log-opt gelf-address=udp://1.2.3.4:12201 \</span><br><span class="line">      alpine echo hello world</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>GELF选项：</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Required</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>gelf-address</code></td>
<td>required</td>
<td>GELF服务器地址(tcp/udp)</td>
<td><code>--log-opt gelf-address=udp://192.168.0.42:12201</code></td>
</tr>
<tr>
<td><code>gelf-compression-type</code></td>
<td>optional</td>
<td>仅限于UDP。类型有gzip(default),zlib,none</td>
<td><code>--log-opt gelf-compression-type=gzip</code></td>
</tr>
<tr>
<td><code>gelf-compression-level</code></td>
<td>optional</td>
<td><code>-1/0 - 9</code>,<code>-1/0</code>(禁用压缩)，1(BestSpeed)，9(BestCompress)</td>
<td><code>--log-opt gelf-compression-level=2</code></td>
</tr>
<tr>
<td><code>gelf-tcp-max-reconnect</code></td>
<td>optional</td>
<td>仅TCP，连接断开尝试的最大重连次数，默认3</td>
<td><code>--log-opt gelf-tcp-max-reconnect=3</code></td>
</tr>
<tr>
<td><code>gelf-tcp-reconnect-delay</code></td>
<td>optinal</td>
<td>仅TCP，重连等待的秒数，默认1s</td>
<td><code>--log-opt gelf-tcp-reconnect-delay=1</code></td>
</tr>
<tr>
<td><code>tag</code></td>
<td>optional</td>
<td>默认使用Docker容器ID的前12位</td>
<td><code>--log-opt tag=mailer</code></td>
</tr>
<tr>
<td><code>labels</code></td>
<td>optional</td>
<td>以逗号分隔的日志相关标签</td>
<td><code>--log-opt labels=production_status,geo</code></td>
</tr>
<tr>
<td><code>env</code></td>
<td>optional</td>
<td>以逗号分隔的日志相关的环境变量</td>
<td><code>--log-opt env=os,customer</code></td>
</tr>
<tr>
<td><code>evn-regex</code></td>
<td>optional</td>
<td>匹配日志相关环境变量的正则表达式</td>
<td><code>--log-opt env-regex=^(os l customer)</code></td>
</tr>
</tbody>
</table>
<p><br></p>
<h5 id="Syslog"><a href="#Syslog" class="headerlink" title="Syslog"></a>Syslog</h5><p>syslog日志驱动将日志路由到系统日志服务器。系统日志必须以特定方式格式化才能生效。从有效的消息中，接收者可以提取以下消息：</p>
<ul>
<li><p>priority<br>日志级别，debug, info, warning, error…</p>
</li>
<li><p>timestamp</p>
</li>
<li>hostname</li>
<li><p>facility<br>记录消息的子系统</p>
</li>
<li><p>process name</p>
</li>
<li>pid</li>
</ul>
<p><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;syslog&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;syslog-address&quot;: &quot;udp://1.2.3.4:1111&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">#syslog-address支持tcp和udp</span><br><span class="line">docker run \</span><br><span class="line">      -–log-driver syslog –-log-opt syslog-address=udp://1.2.3.4:1111 \</span><br><span class="line">      alpine echo hello world</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>syslog日志驱动选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
<th>栗子</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>syslog-address</code></td>
<td><code>[tcp l udp l tcp+tls]:host:port</code>, <code>unixgram://path</code>, <code>unix://path</code></td>
<td><code>--log-opt syslog-address=tcp+tls://192.168.1.3:514</code>, <code>--log-opt syslog-address=unix:///tmp/syslog.sock</code></td>
</tr>
<tr>
<td><code>syslog-facility</code></td>
<td>子系统</td>
<td><code>--log-opt syslog-facility=daemon</code></td>
</tr>
<tr>
<td><code>syslog-tls-ca-cert</code></td>
<td>CA</td>
<td><code>--log-opt syslog-tls-ca-cert=/etc/ca-certificates/custom/ca.pem</code></td>
</tr>
<tr>
<td><code>syslog-tls-cert</code></td>
<td>TLS certificate</td>
<td><code>--log-opt syslog-tls-key=/etc/ca-certificates/custom/key.pem</code></td>
</tr>
<tr>
<td><code>syslog-tls-skip-verify</code></td>
<td>跳过tls验证</td>
<td><code>--log-opt syslog-tls-skip-verify=true</code></td>
</tr>
<tr>
<td><code>tag</code></td>
<td>如前</td>
<td>如前</td>
</tr>
<tr>
<td><code>syslog-format</code></td>
<td>日志格式</td>
<td><code>--log-opt syslog-format=rfc5424micro</code></td>
</tr>
<tr>
<td><code>lables</code></td>
<td>如前</td>
<td>如前</td>
</tr>
<tr>
<td><code>env</code></td>
<td>如前</td>
<td>如前</td>
</tr>
<tr>
<td><code>env-regex</code></td>
<td>如前</td>
<td>如前</td>
</tr>
</tbody>
</table>
<p><br></p>
<h5 id="ETW"><a href="#ETW" class="headerlink" title="ETW"></a>ETW</h5><p>ETW日志驱动将容器日志转发为ETW事件。每个ETW时间都包含一条日志及其上下文信息的消息，然后客户端可以创建一个ETW监听器来监听这些事件。</p>
<p><br></p>
<h5 id="Fluentd"><a href="#Fluentd" class="headerlink" title="Fluentd"></a>Fluentd</h5><p>fluentd日志驱动将容器日志作为结构化日志数据发送到fluentd收集器。接着，用户便可以使用任意一种Fluentd output plugin将这些日志写入不同的目的地。</p>
<p>fluentd发送一下这些元数据：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>container_id</code></td>
<td>完整的64位容器ID</td>
</tr>
<tr>
<td><code>container_ame</code></td>
<td>启动时的容器名</td>
</tr>
<tr>
<td>source</td>
<td>stdout or stderr</td>
</tr>
<tr>
<td>log</td>
<td>容器日志</td>
</tr>
</tbody>
</table>
<p><code>docker logs</code>命令不可用于此日志驱动。</p>
<p><br></p>
<ul>
<li><p><code>fluentd-address</code><br>指定fluentd daemon地址</p>
</li>
<li><p>tag</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   &quot;log-driver&quot;: &quot;fluentd&quot;,</span><br><span class="line">   &quot;log-opts&quot;: &#123;</span><br><span class="line">     &quot;fluentd-address&quot;: &quot;fluentdhost:24224&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">docker run --log-driver=fluentd --log-opt fluentd-address=fluentdhost:24224</span><br><span class="line">docker run --log-driver=fluentd --log-opt fluentd-address=tcp://fluentdhost:24224</span><br><span class="line">docker run --log-driver=fluentd --log-opt fluentd-address=unix:///path/to/fluentd.sock</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="Journald"><a href="#Journald" class="headerlink" title="Journald"></a>Journald</h5><p>journald 日志驱动将容器日志发送给 systemd journal。可以通过<code>journalctl</code>命令，<code>journal</code> API，<code>docker logs</code>来检索日志条目。</p>
<p>journald日志驱动还提供如下元数据：</p>
<ul>
<li><code>CONTAINER_ID</code></li>
<li><code>CONTAINER_ID_FULL</code></li>
<li><code>CONTAINER_NAME</code></li>
<li><code>CONTAINER_TAG</code></li>
<li><code>CONTAINER_PARTIAL_MESSAGE</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;journald&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#or</span><br><span class="line">docker run --log-driver=journald ...</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>几个选项：</p>
<ul>
<li>tag</li>
<li>label</li>
<li>env</li>
<li>env-regex</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --log-driver=journald \</span><br><span class="line">    --log-opt labels=location \</span><br><span class="line">    --log-opt env=TEST \</span><br><span class="line">    --env &quot;TEST=false&quot; \</span><br><span class="line">    --label location=west \</span><br><span class="line">    your/application</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>使用<code>journalctl</code>命令查看日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">journalctl CONTAINER_NAME=webserver</span><br><span class="line">journalctl -o json CONTAINER_NAME=webserver</span><br></pre></td></tr></table></figure>
<p>使用journal API：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> systemd.journal</span><br><span class="line"></span><br><span class="line">reader = systemd.journal.Reader()</span><br><span class="line">reader.add_match(<span class="string">'CONTAINER_NAME=web'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> reader:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'&#123;CONTAINER_ID_FULL&#125;: &#123;MESSAGE&#125;'</span>.format(**msg)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="Splunk"><a href="#Splunk" class="headerlink" title="Splunk"></a>Splunk</h5><p>splunk日志驱动将容器日志发送到Splunk Enterprise和Splunk Clound的HTTP Event Collector。</p>
<p><br><br><br></p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Docker/" rel="tag"># Docker</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/05/网站运维/" rel="next" title="《网站运维》读书笔记">
                <i class="fa fa-chevron-left"></i> 《网站运维》读书笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/05/Consul/" rel="prev" title="Consul">
                Consul <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/leslie.jpg"
              alt="Zhang21" />
          
            <p class="site-author-name" itemprop="name">Zhang21</p>
            <p class="site-description motion-element" itemprop="description">踏踏实实谋发展</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">55</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">74</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/f13278e94ecb" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-circle-o"></i>简书</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/Zhang21" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:elite_zhang21@163.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://instagram.com/Zhang21_" target="_blank" title="Instagram">
                  
                    <i class="fa fa-fw fa-instagram"></i>Instagram</a>
              </span>
            
          
        </div>

        
        

        
        
<br>
<!--����������������ⲿ����,auto=1��ʾ�Զ�����-->
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=411315632&auto=0&height=66"></iframe>


        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker平台"><span class="nav-number">1.1.</span> <span class="nav-text">Docker平台</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker引擎"><span class="nav-number">1.2.</span> <span class="nav-text">Docker引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#能用Docker做什么"><span class="nav-number">1.3.</span> <span class="nav-text">能用Docker做什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker架构"><span class="nav-number">1.4.</span> <span class="nav-text">Docker架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-daemon"><span class="nav-number">1.4.1.</span> <span class="nav-text">Docker daemon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-client"><span class="nav-number">1.4.2.</span> <span class="nav-text">Docker client</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-registry"><span class="nav-number">1.4.3.</span> <span class="nav-text">Docker registry</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker对象"><span class="nav-number">1.5.</span> <span class="nav-text">Docker对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#image"><span class="nav-number">1.5.1.</span> <span class="nav-text">image</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#container"><span class="nav-number">1.5.2.</span> <span class="nav-text">container</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#service"><span class="nav-number">1.5.3.</span> <span class="nav-text">service</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#底层技术"><span class="nav-number">1.5.4.</span> <span class="nav-text">底层技术</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#安装"><span class="nav-number">2.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CentOS7安装Docker-CE"><span class="nav-number">2.1.</span> <span class="nav-text">CentOS7安装Docker CE</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OS要求"><span class="nav-number">2.1.1.</span> <span class="nav-text">OS要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装Docker-CE"><span class="nav-number">2.1.2.</span> <span class="nav-text">安装Docker CE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#卸载Docker-CE"><span class="nav-number">2.1.3.</span> <span class="nav-text">卸载Docker CE</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#开始"><span class="nav-number">3.</span> <span class="nav-text">开始</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Docker"><span class="nav-number">3.1.</span> <span class="nav-text">关于Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker的概念"><span class="nav-number">3.1.1.</span> <span class="nav-text">Docker的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#镜像和容器"><span class="nav-number">3.1.2.</span> <span class="nav-text">镜像和容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器和虚拟机"><span class="nav-number">3.1.3.</span> <span class="nav-text">容器和虚拟机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备Docker环境"><span class="nav-number">3.1.4.</span> <span class="nav-text">准备Docker环境</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试Docker"><span class="nav-number">3.2.</span> <span class="nav-text">测试Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">3.2.1.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器"><span class="nav-number">3.3.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#先决条件"><span class="nav-number">3.3.1.</span> <span class="nav-text">先决条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍"><span class="nav-number">3.3.2.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新开发环境"><span class="nav-number">3.3.3.</span> <span class="nav-text">新开发环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Dockerfile定义一个容器"><span class="nav-number">3.3.4.</span> <span class="nav-text">使用Dockerfile定义一个容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#APP自身"><span class="nav-number">3.3.5.</span> <span class="nav-text">APP自身</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建APP"><span class="nav-number">3.3.6.</span> <span class="nav-text">构建APP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分享你的image"><span class="nav-number">3.3.7.</span> <span class="nav-text">分享你的image</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本节基础命令"><span class="nav-number">3.3.8.</span> <span class="nav-text">本节基础命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务"><span class="nav-number">3.4.</span> <span class="nav-text">服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#先决条件-1"><span class="nav-number">3.4.1.</span> <span class="nav-text">先决条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-1"><span class="nav-number">3.4.2.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于服务"><span class="nav-number">3.4.3.</span> <span class="nav-text">关于服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#你的第一个docker-compose-yml文件"><span class="nav-number">3.4.4.</span> <span class="nav-text">你的第一个docker-compose.yml文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行你的负载均衡APP"><span class="nav-number">3.4.5.</span> <span class="nav-text">运行你的负载均衡APP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伸缩APP"><span class="nav-number">3.4.6.</span> <span class="nav-text">伸缩APP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本节命令"><span class="nav-number">3.4.7.</span> <span class="nav-text">本节命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#swarm"><span class="nav-number">3.5.</span> <span class="nav-text">swarm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#先决条件-2"><span class="nav-number">3.5.1.</span> <span class="nav-text">先决条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-2"><span class="nav-number">3.5.2.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解swarm集群"><span class="nav-number">3.5.3.</span> <span class="nav-text">理解swarm集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建立swarm"><span class="nav-number">3.5.4.</span> <span class="nav-text">建立swarm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在swarm集群上部署APP"><span class="nav-number">3.5.5.</span> <span class="nav-text">在swarm集群上部署APP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#清理并重启"><span class="nav-number">3.5.6.</span> <span class="nav-text">清理并重启</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stack"><span class="nav-number">3.6.</span> <span class="nav-text">stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-3"><span class="nav-number">3.6.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加一个新服务并部署"><span class="nav-number">3.6.2.</span> <span class="nav-text">添加一个新服务并部署</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久化数据"><span class="nav-number">3.6.3.</span> <span class="nav-text">持久化数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#部署APP"><span class="nav-number">3.7.</span> <span class="nav-text">部署APP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-4"><span class="nav-number">3.7.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择版本"><span class="nav-number">3.7.2.</span> <span class="nav-text">选择版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接DockerCloud"><span class="nav-number">3.7.3.</span> <span class="nav-text">连接DockerCloud</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建swarm"><span class="nav-number">3.7.4.</span> <span class="nav-text">创建swarm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在云提供商上部署应用程序"><span class="nav-number">3.7.5.</span> <span class="nav-text">在云提供商上部署应用程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代和清理"><span class="nav-number">3.7.6.</span> <span class="nav-text">迭代和清理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#修改Docker默认路径"><span class="nav-number">3.8.</span> <span class="nav-text">修改Docker默认路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器服务自启动"><span class="nav-number">3.9.</span> <span class="nav-text">容器服务自启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交互式容器"><span class="nav-number">3.10.</span> <span class="nav-text">交互式容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker日志"><span class="nav-number">3.11.</span> <span class="nav-text">Docker日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新镜像"><span class="nav-number">3.12.</span> <span class="nav-text">更新镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#备份与恢复"><span class="nav-number">3.13.</span> <span class="nav-text">备份与恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#备份容器"><span class="nav-number">3.13.1.</span> <span class="nav-text">备份容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#恢复容器"><span class="nav-number">3.13.2.</span> <span class="nav-text">恢复容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景与注意事项"><span class="nav-number">3.14.</span> <span class="nav-text">应用场景与注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#应用场景"><span class="nav-number">3.14.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项"><span class="nav-number">3.14.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Dockerfile"><span class="nav-number">4.</span> <span class="nav-text">Dockerfile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Dockerfile定制镜像"><span class="nav-number">4.1.</span> <span class="nav-text">使用Dockerfile定制镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FROM"><span class="nav-number">4.1.1.</span> <span class="nav-text">FROM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RUN"><span class="nav-number">4.1.2.</span> <span class="nav-text">RUN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建镜像"><span class="nav-number">4.1.3.</span> <span class="nav-text">构建镜像</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dockerfile指令"><span class="nav-number">4.2.</span> <span class="nav-text">Dockerfile指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LABLE"><span class="nav-number">4.2.1.</span> <span class="nav-text">LABLE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#COPY"><span class="nav-number">4.2.2.</span> <span class="nav-text">COPY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ADD"><span class="nav-number">4.2.3.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMD"><span class="nav-number">4.2.4.</span> <span class="nav-text">CMD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ENTRYPOINT"><span class="nav-number">4.2.5.</span> <span class="nav-text">ENTRYPOINT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ENV"><span class="nav-number">4.2.6.</span> <span class="nav-text">ENV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARG"><span class="nav-number">4.2.7.</span> <span class="nav-text">ARG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VOLUME"><span class="nav-number">4.2.8.</span> <span class="nav-text">VOLUME</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXPOSE"><span class="nav-number">4.2.9.</span> <span class="nav-text">EXPOSE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WORKDIR"><span class="nav-number">4.2.10.</span> <span class="nav-text">WORKDIR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#USER"><span class="nav-number">4.2.11.</span> <span class="nav-text">USER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HEALTHCHECK"><span class="nav-number">4.2.12.</span> <span class="nav-text">HEALTHCHECK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ONBUILD"><span class="nav-number">4.2.13.</span> <span class="nav-text">ONBUILD</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dockerfile多阶段构建"><span class="nav-number">4.3.</span> <span class="nav-text">Dockerfile多阶段构建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dockerfile最佳实践"><span class="nav-number">4.4.</span> <span class="nav-text">Dockerfile最佳实践</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Compose-file"><span class="nav-number">5.</span> <span class="nav-text">Compose file</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用Docker进行开发"><span class="nav-number">6.</span> <span class="nav-text">使用Docker进行开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#在Docker上开发应用程序"><span class="nav-number">6.1.</span> <span class="nav-text">在Docker上开发应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker开发最佳实践"><span class="nav-number">6.1.1.</span> <span class="nav-text">Docker开发最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何保持较小的镜像"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">如何保持较小的镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何处以及如何持久化应用程序数据"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">何处以及如何持久化应用程序数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#尽可能使用swarm服务"><span class="nav-number">6.1.1.3.</span> <span class="nav-text">尽可能使用swarm服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用CI-CD进行测试和部署"><span class="nav-number">6.1.1.4.</span> <span class="nav-text">使用CI/CD进行测试和部署</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Develop-images"><span class="nav-number">6.1.2.</span> <span class="nav-text">Develop images</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编写Dockerfile的最佳实践"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">编写Dockerfile的最佳实践</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一般准则和建议"><span class="nav-number">6.1.2.2.</span> <span class="nav-text">一般准则和建议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建一个基镜像"><span class="nav-number">6.1.2.3.</span> <span class="nav-text">创建一个基镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用多阶段构建"><span class="nav-number">6.1.2.4.</span> <span class="nav-text">使用多阶段构建</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Docker-Engine-SDKs和API进行开发"><span class="nav-number">6.2.</span> <span class="nav-text">使用Docker Engine SDKs和API进行开发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#综述"><span class="nav-number">6.3.</span> <span class="nav-text">综述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装SDKs"><span class="nav-number">6.3.1.</span> <span class="nav-text">安装SDKs</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Go-SDK"><span class="nav-number">6.3.1.1.</span> <span class="nav-text">Go SDK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python-SDK"><span class="nav-number">6.3.1.2.</span> <span class="nav-text">Python SDK</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速开始SDK和API"><span class="nav-number">6.3.2.</span> <span class="nav-text">快速开始SDK和API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDK和API栗子"><span class="nav-number">6.3.3.</span> <span class="nav-text">SDK和API栗子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络配置"><span class="nav-number">7.</span> <span class="nav-text">网络配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#综述-1"><span class="nav-number">7.1.</span> <span class="nav-text">综述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#网络驱动"><span class="nav-number">7.1.1.</span> <span class="nav-text">网络驱动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bridge"><span class="nav-number">7.2.</span> <span class="nav-text">bridge</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bridge与user-defined-bridges"><span class="nav-number">7.2.1.</span> <span class="nav-text">bridge与user-defined bridges</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管理user-defined-bridge"><span class="nav-number">7.2.2.</span> <span class="nav-text">管理user-defined bridge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接到自定义桥接网络"><span class="nav-number">7.2.3.</span> <span class="nav-text">连接到自定义桥接网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用IPv6"><span class="nav-number">7.2.4.</span> <span class="nav-text">使用IPv6</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启用容器转发"><span class="nav-number">7.2.5.</span> <span class="nav-text">启用容器转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认桥接网络"><span class="nav-number">7.2.6.</span> <span class="nav-text">默认桥接网络</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#overlay"><span class="nav-number">7.3.</span> <span class="nav-text">overlay</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#所有overlay网络的操作"><span class="nav-number">7.3.1.</span> <span class="nav-text">所有overlay网络的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建overlay网络"><span class="nav-number">7.3.1.1.</span> <span class="nav-text">创建overlay网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加密overlay网络上的流量"><span class="nav-number">7.3.1.2.</span> <span class="nav-text">加密overlay网络上的流量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义默认ingress网络"><span class="nav-number">7.3.1.3.</span> <span class="nav-text">自定义默认ingress网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义docker-gwbridge"><span class="nav-number">7.3.1.4.</span> <span class="nav-text">自定义docker_gwbridge</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swarm服务的操作"><span class="nav-number">7.3.2.</span> <span class="nav-text">swarm服务的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在overlay网络上发布端口"><span class="nav-number">7.3.2.1.</span> <span class="nav-text">在overlay网络上发布端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#绕过swarm的路由网格"><span class="nav-number">7.3.2.2.</span> <span class="nav-text">绕过swarm的路由网格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分离控制流量和数据流量"><span class="nav-number">7.3.2.3.</span> <span class="nav-text">分离控制流量和数据流量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#overlay网络上独立容器的操作"><span class="nav-number">7.3.3.</span> <span class="nav-text">overlay网络上独立容器的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将独立容器连接到overlay网络"><span class="nav-number">7.3.3.1.</span> <span class="nav-text">将独立容器连接到overlay网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发布端口"><span class="nav-number">7.3.3.2.</span> <span class="nav-text">发布端口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器发现"><span class="nav-number">7.3.3.3.</span> <span class="nav-text">容器发现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#host"><span class="nav-number">7.4.</span> <span class="nav-text">host</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Macvlan"><span class="nav-number">7.5.</span> <span class="nav-text">Macvlan</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个macvaln网络"><span class="nav-number">7.5.1.</span> <span class="nav-text">创建一个macvaln网络</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#禁用容器网络"><span class="nav-number">7.6.</span> <span class="nav-text">禁用容器网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络教程"><span class="nav-number">7.7.</span> <span class="nav-text">网络教程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bridge-network"><span class="nav-number">7.7.1.</span> <span class="nav-text">bridge network</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#default-bridge-network"><span class="nav-number">7.7.1.1.</span> <span class="nav-text">default bridge network</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#user-defined-bridge-networks"><span class="nav-number">7.7.1.2.</span> <span class="nav-text">user-defined bridge networks</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#host-network"><span class="nav-number">7.7.2.</span> <span class="nav-text">host network</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#overlay-network"><span class="nav-number">7.7.3.</span> <span class="nav-text">overlay network</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#default-overlay"><span class="nav-number">7.7.3.1.</span> <span class="nav-text">default overlay</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#user-defined-overlay"><span class="nav-number">7.7.3.2.</span> <span class="nav-text">user-defined overlay</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#overlay-network-for-standalone-containers"><span class="nav-number">7.7.3.3.</span> <span class="nav-text">overlay network for standalone containers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Communicate-between-a-container-and-a-swarm-service"><span class="nav-number">7.7.3.4.</span> <span class="nav-text">Communicate between a container and a swarm service</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#macvalan-network"><span class="nav-number">7.7.4.</span> <span class="nav-text">macvalan network</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bridge-1"><span class="nav-number">7.7.4.1.</span> <span class="nav-text">bridge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#802-1q-trunked-bridge-network"><span class="nav-number">7.7.4.2.</span> <span class="nav-text">802.1q trunked bridge network</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置守护进程和容器"><span class="nav-number">7.8.</span> <span class="nav-text">配置守护进程和容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启用IPv6"><span class="nav-number">7.8.1.</span> <span class="nav-text">启用IPv6</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iptables"><span class="nav-number">7.8.2.</span> <span class="nav-text">iptables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器网络"><span class="nav-number">7.8.3.</span> <span class="nav-text">容器网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker使用代理服务器"><span class="nav-number">7.8.4.</span> <span class="nav-text">Docker使用代理服务器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#应用程序数据"><span class="nav-number">8.</span> <span class="nav-text">应用程序数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#存储综述"><span class="nav-number">8.1.</span> <span class="nav-text">存储综述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#选择正确的挂载方式"><span class="nav-number">8.1.1.</span> <span class="nav-text">选择正确的挂载方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#volumes的好栗子"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">volumes的好栗子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bind-mounts的好栗子"><span class="nav-number">8.1.1.2.</span> <span class="nav-text">bind mounts的好栗子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tmpfs-mounts的好栗子"><span class="nav-number">8.1.1.3.</span> <span class="nav-text">tmpfs mounts的好栗子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用bind或volumes的提示"><span class="nav-number">8.1.1.4.</span> <span class="nav-text">使用bind或volumes的提示</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Volumes"><span class="nav-number">8.2.</span> <span class="nav-text">Volumes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建和管理卷"><span class="nav-number">8.2.1.</span> <span class="nav-text">创建和管理卷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动用卷的容器"><span class="nav-number">8.2.2.</span> <span class="nav-text">启动用卷的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动用卷的服务"><span class="nav-number">8.2.3.</span> <span class="nav-text">启动用卷的服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在机器间共享数据"><span class="nav-number">8.2.4.</span> <span class="nav-text">在机器间共享数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用卷驱动"><span class="nav-number">8.2.5.</span> <span class="nav-text">使用卷驱动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bind-mounts"><span class="nav-number">8.3.</span> <span class="nav-text">bind mounts</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启动用bind-mount的容器"><span class="nav-number">8.3.1.</span> <span class="nav-text">启动用bind mount的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#只读bind-mount"><span class="nav-number">8.3.2.</span> <span class="nav-text">只读bind mount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bind-propagation"><span class="nav-number">8.3.3.</span> <span class="nav-text">bind propagation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#selinux-label"><span class="nav-number">8.3.4.</span> <span class="nav-text">selinux label</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tmpfs-mounts"><span class="nav-number">8.4.</span> <span class="nav-text">tmpfs mounts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Troubleshoot"><span class="nav-number">8.5.</span> <span class="nav-text">Troubleshoot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将数据存储到容器内"><span class="nav-number">8.6.</span> <span class="nav-text">将数据存储到容器内</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于存储驱动"><span class="nav-number">8.6.1.</span> <span class="nav-text">关于存储驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#镜像和层"><span class="nav-number">8.6.1.1.</span> <span class="nav-text">镜像和层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器和层"><span class="nav-number">8.6.1.2.</span> <span class="nav-text">容器和层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器大小"><span class="nav-number">8.6.1.3.</span> <span class="nav-text">容器大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写入时复制"><span class="nav-number">8.6.1.4.</span> <span class="nav-text">写入时复制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择存储驱动"><span class="nav-number">8.6.2.</span> <span class="nav-text">选择存储驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux发行版支持的存储驱动"><span class="nav-number">8.6.2.1.</span> <span class="nav-text">Linux发行版支持的存储驱动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存储驱动支持的文件系统"><span class="nav-number">8.6.2.2.</span> <span class="nav-text">存储驱动支持的文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看存储驱动"><span class="nav-number">8.6.2.3.</span> <span class="nav-text">查看存储驱动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AUFS存储驱动"><span class="nav-number">8.6.3.</span> <span class="nav-text">AUFS存储驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用aufs存储驱动配置Docker"><span class="nav-number">8.6.3.1.</span> <span class="nav-text">使用aufs存储驱动配置Docker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#aufs存储驱动如何工作"><span class="nav-number">8.6.3.2.</span> <span class="nav-text">aufs存储驱动如何工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器如何使用aufs进行读写"><span class="nav-number">8.6.3.3.</span> <span class="nav-text">容器如何使用aufs进行读写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Btrfs存储驱动"><span class="nav-number">8.6.4.</span> <span class="nav-text">Btrfs存储驱动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Device-Mapper存储驱动"><span class="nav-number">8.6.5.</span> <span class="nav-text">Device Mapper存储驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#管理devicemapper"><span class="nav-number">8.6.5.1.</span> <span class="nav-text">管理devicemapper</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OverlayFS存储驱动"><span class="nav-number">8.6.6.</span> <span class="nav-text">OverlayFS存储驱动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZFS存储驱动"><span class="nav-number">8.6.7.</span> <span class="nav-text">ZFS存储驱动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VFS存储驱动"><span class="nav-number">8.6.8.</span> <span class="nav-text">VFS存储驱动</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在生产环境运行应用程序"><span class="nav-number">9.</span> <span class="nav-text">在生产环境运行应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#配置对象"><span class="nav-number">9.1.</span> <span class="nav-text">配置对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义原数据"><span class="nav-number">9.1.1.</span> <span class="nav-text">自定义原数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#label-key-and-value"><span class="nav-number">9.1.1.1.</span> <span class="nav-text">label key and value</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#清理未使用的对象"><span class="nav-number">9.1.2.</span> <span class="nav-text">清理未使用的对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化输出"><span class="nav-number">9.1.3.</span> <span class="nav-text">格式化输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置daemon"><span class="nav-number">9.2.</span> <span class="nav-text">配置daemon</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置和运行Docker"><span class="nav-number">9.2.1.</span> <span class="nav-text">配置和运行Docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用systemd控制docker"><span class="nav-number">9.2.2.</span> <span class="nav-text">使用systemd控制docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#收集Docker指标"><span class="nav-number">9.2.3.</span> <span class="nav-text">收集Docker指标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置容器"><span class="nav-number">9.3.</span> <span class="nav-text">配置容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自动启动容器"><span class="nav-number">9.3.1.</span> <span class="nav-text">自动启动容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在daemon停机期间保持容器活着"><span class="nav-number">9.3.2.</span> <span class="nav-text">在daemon停机期间保持容器活着</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在一个容器中运行多个服务"><span class="nav-number">9.3.3.</span> <span class="nav-text">在一个容器中运行多个服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器运行指标"><span class="nav-number">9.3.4.</span> <span class="nav-text">容器运行指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限制容器的资源"><span class="nav-number">9.3.5.</span> <span class="nav-text">限制容器的资源</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#memory"><span class="nav-number">9.3.5.1.</span> <span class="nav-text">memory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpu"><span class="nav-number">9.3.5.2.</span> <span class="nav-text">cpu</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Logging"><span class="nav-number">9.3.6.</span> <span class="nav-text">Logging</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#查看容器日志"><span class="nav-number">9.3.6.1.</span> <span class="nav-text">查看容器日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#配置日志驱动"><span class="nav-number">9.3.6.2.</span> <span class="nav-text">配置日志驱动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#日志驱动插件"><span class="nav-number">9.3.6.3.</span> <span class="nav-text">日志驱动插件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定制日志驱动输出"><span class="nav-number">9.3.6.4.</span> <span class="nav-text">定制日志驱动输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#日志驱动"><span class="nav-number">9.3.6.5.</span> <span class="nav-text">日志驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Logentries"><span class="nav-number">9.3.6.5.1.</span> <span class="nav-text">Logentries</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#json-file"><span class="nav-number">9.3.6.5.2.</span> <span class="nav-text">json file</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Graylog-Extended-Format-gelf"><span class="nav-number">9.3.6.5.3.</span> <span class="nav-text">Graylog Extended Format(gelf)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Syslog"><span class="nav-number">9.3.6.5.4.</span> <span class="nav-text">Syslog</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ETW"><span class="nav-number">9.3.6.5.5.</span> <span class="nav-text">ETW</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Fluentd"><span class="nav-number">9.3.6.5.6.</span> <span class="nav-text">Fluentd</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Journald"><span class="nav-number">9.3.6.5.7.</span> <span class="nav-text">Journald</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Splunk"><span class="nav-number">9.3.6.5.8.</span> <span class="nav-text">Splunk</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全"><span class="nav-number">9.3.7.</span> <span class="nav-text">安全</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 &mdash; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang21</span>

<!--字数统计-->
  <div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count"> 字数: 527.2k</span>
</div>


  
</div>



<!--

  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>

-->


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Zhang21.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://zhang21.github.io/2018/03/27/Docker/';
          this.page.identifier = '2018/03/27/Docker/';
          this.page.title = 'Docker';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://Zhang21.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->





  

  

  

  
  


  

  

</body>
</html>
